From 85cf03be82c5ec406fe249197cc06a5b1cbbfb6c Mon Sep 17 00:00:00 2001
From: tstegema <tstegema@90b65887-3827-0410-9a23-83215b262276>
Date: Wed, 22 Sep 2010 13:15:14 +0000
Subject: [PATCH 0037/1077] V1.0.1.7 Added   - interface barcode,
 implementation barcode39, barcode128, barcodeIndustrial2of5            create
 barcode bitmap   - interface bitmap, implementation blackAndWhiteBitmap      
      create bitmap from stringbuffer   - bitarray            access single
 bit   - pixelrow            create a bitmap of a single bitarray (repeating
 the line)   - stringbuffer            hold a char* buffer, allow direct
 access to char* (read and write)   - localtrace            write traces to
 stdout

git-svn-id: svn://localhost/SelfServiceCommon/trunk@39 90b65887-3827-0410-9a23-83215b262276
---
 .../Interfaces/inc/Tools/barcode.h            |  30 +
 .../Interfaces/inc/Tools/barcode128.h         |  46 ++
 .../Interfaces/inc/Tools/barcode39.h          |  43 ++
 .../inc/Tools/barcodeIndustrial2of5.h         |  43 ++
 .../Interfaces/inc/Tools/bitarray.h           |  49 ++
 .../Interfaces/inc/Tools/bitmap.h             |  30 +
 .../inc/Tools/blackAndWhiteBitmap.h           |  37 ++
 .../Interfaces/inc/Tools/localtrace.h         |  31 +
 .../Interfaces/inc/Tools/stringbuffer.h       |  77 +++
 SelfServiceCommon/Interfaces/inc/barcode.h    |  30 +
 SelfServiceCommon/Interfaces/inc/barcode128.h |  46 ++
 SelfServiceCommon/Interfaces/inc/barcode39.h  |  43 ++
 .../Interfaces/inc/barcodeIndustrial2of5.h    |  43 ++
 SelfServiceCommon/Interfaces/inc/bitarray.h   |  49 ++
 SelfServiceCommon/Interfaces/inc/bitmap.h     |  30 +
 .../Interfaces/inc/blackAndWhiteBitmap.h      |  37 ++
 SelfServiceCommon/Interfaces/inc/localtrace.h |  31 +
 SelfServiceCommon/Interfaces/inc/pixelrow.h   |  36 ++
 .../Interfaces/inc/stringbuffer.h             |  77 +++
 .../cpp/Tools/inc/local_def_msystools.h       |  21 +-
 .../Massai/cpp/Tools/makefile.mak             |  47 +-
 .../Massai/cpp/Tools/src/TestBarcode128.cpp   |  59 ++
 .../Massai/cpp/Tools/src/TestBarcode39.cpp    |  40 ++
 .../Tools/src/TestBarcodeIndustrial2of5.cpp   |  40 ++
 .../Massai/cpp/Tools/src/TestBitArray.cpp     |  78 +++
 .../Massai/cpp/Tools/src/barcode.cpp          |  19 +
 .../Massai/cpp/Tools/src/barcode128.cpp       | 579 ++++++++++++++++++
 .../Massai/cpp/Tools/src/barcode39.cpp        | 285 +++++++++
 .../cpp/Tools/src/barcodeIndustrial2of5.cpp   | 230 +++++++
 .../Massai/cpp/Tools/src/bitarray.cpp         | 217 +++++++
 .../cpp/Tools/src/blackAndWhiteBitmap.cpp     |  98 +++
 .../Massai/cpp/Tools/src/localtrace.cpp       |  80 +++
 .../Massai/cpp/Tools/src/pixelrow.cpp         |  36 ++
 .../Massai/cpp/Tools/src/stringbuffer.cpp     | 235 +++++++
 34 files changed, 2866 insertions(+), 6 deletions(-)
 create mode 100644 SelfServiceCommon/Interfaces/inc/Tools/barcode.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/Tools/barcode128.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/Tools/barcode39.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/Tools/barcodeIndustrial2of5.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/Tools/bitarray.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/Tools/bitmap.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/Tools/blackAndWhiteBitmap.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/Tools/localtrace.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/Tools/stringbuffer.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/barcode.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/barcode128.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/barcode39.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/barcodeIndustrial2of5.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/bitarray.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/bitmap.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/blackAndWhiteBitmap.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/localtrace.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/pixelrow.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/stringbuffer.h
 create mode 100644 SelfServiceCommon/Massai/cpp/Tools/src/TestBarcode128.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Tools/src/TestBarcode39.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Tools/src/TestBarcodeIndustrial2of5.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Tools/src/TestBitArray.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Tools/src/barcode.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Tools/src/barcode128.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Tools/src/barcode39.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Tools/src/barcodeIndustrial2of5.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Tools/src/bitarray.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Tools/src/blackAndWhiteBitmap.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Tools/src/localtrace.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Tools/src/pixelrow.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Tools/src/stringbuffer.cpp

diff --git a/SelfServiceCommon/Interfaces/inc/Tools/barcode.h b/SelfServiceCommon/Interfaces/inc/Tools/barcode.h
new file mode 100644
index 00000000..a2f72258
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/Tools/barcode.h
@@ -0,0 +1,30 @@
+/**
+ **************************************************************************
+ *
+ * @file barcode.h
+ *
+ * create barcode bitmap
+ *
+ **************************************************************************
+**/
+#ifndef BARCODE
+#define BARCODE
+
+#include "bitmap.h"
+
+namespace MASSAI
+{
+  namespace Barcode
+  {
+    class Barcode
+    {
+      public:
+        virtual ~Barcode();
+
+        virtual Bitmap::Bitmap createBarcode(const std::string& barcodeData) const= 0;
+        virtual std::string createBarcodeData(const std::string& data) const= 0;
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/Tools/barcode128.h b/SelfServiceCommon/Interfaces/inc/Tools/barcode128.h
new file mode 100644
index 00000000..7d492254
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/Tools/barcode128.h
@@ -0,0 +1,46 @@
+/**
+ **************************************************************************
+ *
+ * @file barcode128.h
+ *
+ * create barcode128 bitmap
+ *
+ **************************************************************************
+**/
+#ifndef BARCODE128_INCLUDED
+#define BARCODE128_INCLUDED
+
+#include "barcode.h"
+#include <stddef.h>
+
+namespace MASSAI
+{
+  namespace Barcode
+  {
+    struct Barcode128Settings
+    {
+      size_t blockSize;
+      size_t height;
+      bool useQuietZone;
+      bool allowStartCodeA;
+      bool allowStartCodeB;
+      bool allowStartCodeC;
+      bool allowCodeA;
+      bool allowCodeB;
+      bool allowCodeC;
+    };
+    class Barcode128: public Barcode
+    {
+      public:
+        Barcode128(Barcode128Settings settings);
+        virtual ~Barcode128();
+
+        virtual Bitmap::Bitmap createBarcode(const std::string& barcodeData) const;
+        virtual std::string createBarcodeData(const std::string& data) const;
+      private:
+        Barcode128Settings m_settings;
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/Tools/barcode39.h b/SelfServiceCommon/Interfaces/inc/Tools/barcode39.h
new file mode 100644
index 00000000..b0769ea5
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/Tools/barcode39.h
@@ -0,0 +1,43 @@
+/**
+ **************************************************************************
+ *
+ * @file barcode39.h
+ *
+ * create barcode39 bitmap
+ *
+ **************************************************************************
+**/
+#ifndef BARCODE39_INCLUDED
+#define BARCODE39_INCLUDED
+
+#include "barcode.h"
+#include <stddef.h>
+
+namespace MASSAI
+{
+  namespace Barcode
+  {
+    struct Barcode39Settings
+    {
+      size_t narrowBlockSize;
+      size_t wideBlockSize;
+      size_t intercharacterBlockSize;
+      size_t height;
+      bool useQuietZone;
+      bool useChecksum;
+    };
+    class Barcode39: public Barcode
+    {
+      public:
+        Barcode39(Barcode39Settings settings);
+        virtual ~Barcode39();
+
+        virtual Bitmap::Bitmap createBarcode(const std::string& barcodeData) const;
+        virtual std::string createBarcodeData(const std::string& data) const;
+      private:
+        Barcode39Settings m_settings;
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/Tools/barcodeIndustrial2of5.h b/SelfServiceCommon/Interfaces/inc/Tools/barcodeIndustrial2of5.h
new file mode 100644
index 00000000..f10b03be
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/Tools/barcodeIndustrial2of5.h
@@ -0,0 +1,43 @@
+/**
+ **************************************************************************
+ *
+ * @file barcodeIndustrial2of5.h
+ *
+ * create barcodeIndustrial2of5 bitmap
+ *
+ **************************************************************************
+**/
+#ifndef BARCODEIndustrial2of5_INCLUDED
+#define BARCODEIndustrial2of5_INCLUDED
+
+#include "barcode.h"
+#include <stddef.h>
+
+namespace MASSAI
+{
+  namespace Barcode
+  {
+    struct BarcodeIndustrial2of5Settings
+    {
+      size_t narrowBlockSize;
+      size_t wideBlockSize;
+      size_t spaceBlockSize;
+      size_t height;
+      bool useQuietZone;
+      bool useChecksum;
+    };
+    class BarcodeIndustrial2of5: public Barcode
+    {
+      public:
+        BarcodeIndustrial2of5(BarcodeIndustrial2of5Settings settings);
+        virtual ~BarcodeIndustrial2of5();
+
+        virtual Bitmap::Bitmap createBarcode(const std::string& barcodeData) const;
+        virtual std::string createBarcodeData(const std::string& data) const;
+      private:
+        BarcodeIndustrial2of5Settings m_settings;
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/Tools/bitarray.h b/SelfServiceCommon/Interfaces/inc/Tools/bitarray.h
new file mode 100644
index 00000000..a2578aaf
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/Tools/bitarray.h
@@ -0,0 +1,49 @@
+/**
+ **************************************************************************
+ *
+ * @file bitarray.h
+ *
+ *
+ **************************************************************************
+**/
+#ifndef BITARRAY_INCLUDED
+#define BITARRAY_INCLUDED
+
+#include <stddef.h>
+#include "stringbuffer.h"
+
+namespace MASSAI
+{
+  class BitArray
+  {
+    public:
+      typedef unsigned char byte;
+
+      BitArray(const byte* data, size_t size);
+      explicit BitArray(size_t size);
+      size_t size() const;
+      size_t capacity() const;
+      size_t buffer_size() const;
+      void resize(size_t size);
+      void reserve(size_t size);
+      const byte* data() const;
+      byte* data();
+      const MASSAI::text::StringBuffer buffer() const;
+      void flip(size_t index, size_t count= 1);
+      void reset(size_t index, size_t count= 1);
+      void set(size_t index, bool value= true, size_t count= 1);
+//       void and(size_t index, const BitArray& data, size_t start, size_t size);
+//       void or(size_t index, const BitArray& data, size_t start, size_t size);
+//       void xor(size_t index, const BitArray& data, size_t start, size_t size);
+      bool get(size_t index);
+    private:
+      void copy(const byte* src, size_t size, size_t capacity);
+      static size_t getBufferSize(size_t size);
+
+      MASSAI::text::StringBuffer m_data;
+      size_t m_size;
+      size_t m_capacity;
+  };
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/Tools/bitmap.h b/SelfServiceCommon/Interfaces/inc/Tools/bitmap.h
new file mode 100644
index 00000000..eb30a816
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/Tools/bitmap.h
@@ -0,0 +1,30 @@
+/**
+ **************************************************************************
+ *
+ * @file bitmap.h
+ *
+ * create bitmap
+ *
+ **************************************************************************
+**/
+#ifndef BITMAP_INCLUDED
+#define BITMAP_INCLUDED
+
+#include <stddef.h>
+#include "stringbuffer.h"
+
+namespace MASSAI
+{
+  namespace Bitmap
+  {
+    struct Bitmap
+    {
+      public:
+        size_t width;
+        size_t height;
+        MASSAI::text::StringBuffer bmp;
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/Tools/blackAndWhiteBitmap.h b/SelfServiceCommon/Interfaces/inc/Tools/blackAndWhiteBitmap.h
new file mode 100644
index 00000000..53532acd
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/Tools/blackAndWhiteBitmap.h
@@ -0,0 +1,37 @@
+/**
+ **************************************************************************
+ *
+ * @file blackAndWhiteBitmap.h
+ *
+ * create bitmap
+ *
+ **************************************************************************
+**/
+#ifndef BLACKANDWHITEBITMAP
+#define BLACKANDWHITEBITMAP
+
+#include "bitmap.h"
+
+namespace MASSAI
+{
+  namespace Bitmap
+  {
+    class PixelRows
+    {
+      public:
+        virtual ~PixelRows();
+        virtual size_t getHeight() const= 0;
+        virtual size_t getWidth() const= 0;
+        virtual const MASSAI::text::StringBuffer& getRow(size_t y) const= 0;
+    };
+    class BlackAndWhiteBitmap
+    {
+      public:
+        BlackAndWhiteBitmap();
+        ~BlackAndWhiteBitmap();
+        Bitmap createBitmap(const PixelRows& pixel);
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/Tools/localtrace.h b/SelfServiceCommon/Interfaces/inc/Tools/localtrace.h
new file mode 100644
index 00000000..737e8979
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/Tools/localtrace.h
@@ -0,0 +1,31 @@
+#ifndef TRACE_H
+#define TRACE_H
+
+#define TRC_OK                    0
+#define TRC_ERROR                 1
+
+#define __FUNCTION__ ""
+
+#define MajorError_HERE         1,__FILE__,__LINE__,__FUNCTION__
+#define MinorError_HERE         2,__FILE__,__LINE__,__FUNCTION__
+#define MajorWarning_HERE       3,__FILE__,__LINE__,__FUNCTION__
+#define MinorWarning_HERE       4,__FILE__,__LINE__,__FUNCTION__
+#define BasicRuntime_HERE       5,__FILE__,__LINE__,__FUNCTION__
+#define BasicProcess_HERE       6,__FILE__,__LINE__,__FUNCTION__
+#define SecondaryRuntime_HERE   7,__FILE__,__LINE__,__FUNCTION__
+#define SecondaryFrequent_HERE  8,__FILE__,__LINE__,__FUNCTION__
+
+namespace MASSAI
+{
+  namespace localtrace
+  {
+    void openTrace(const char* pszApplication);
+    long writeTraceText(long lTraceLevel, const char* pszFile, short sLine, const char* pszFunction, const char* pszText);
+    long wrtTrace (long lTraceLevel, const char* pszFile, short sLine, const char* pszFunction, const char* pszFormat, ...);
+    long dumpTrace(long lTraceLevel, const char* pszFile, short sLine, const char* pszFunction, long lDumpSize, const char* pDump);
+
+    void closeTrace();
+  }
+
+}
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/Tools/stringbuffer.h b/SelfServiceCommon/Interfaces/inc/Tools/stringbuffer.h
new file mode 100644
index 00000000..62363ae6
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/Tools/stringbuffer.h
@@ -0,0 +1,77 @@
+/**
+ **************************************************************************
+ *
+ * @file stringbuffer.h
+ *
+ *
+ *
+ * Copyright (c) 2008 MATERNA Information & Communications
+ *
+ **************************************************************************
+**/
+
+#ifndef _STRINGBUFFER_H_
+#define _STRINGBUFFER_H_
+
+#include <string>
+#include <stddef.h>
+
+namespace MASSAI
+{
+  namespace text
+  {
+    class StringBuffer
+    {
+      public:
+        StringBuffer();
+        explicit StringBuffer(size_t size);
+        StringBuffer(size_t size, size_t capacity);
+
+        StringBuffer(const StringBuffer& assign);
+        StringBuffer(const StringBuffer& assign, size_t capacity);
+
+        explicit StringBuffer(const char* assign);
+        StringBuffer(const char* assign, size_t size);
+        StringBuffer(const char* assign, size_t size, size_t capacity);
+
+        explicit StringBuffer(const unsigned char* uassign);
+        StringBuffer(const unsigned char* uassign, size_t size);
+        StringBuffer(const unsigned char* uassign, size_t size, size_t capacity);
+
+        explicit StringBuffer(const signed char* sassign);
+        StringBuffer(const signed char* sassign, size_t size);
+        StringBuffer(const signed char* sassign, size_t size, size_t capacity);
+
+        explicit StringBuffer(const std::string& assign);
+        StringBuffer(const std::string& assign, size_t capacity);
+
+        StringBuffer& operator= (const StringBuffer& assign);
+        ~StringBuffer();
+
+        size_t size() const;
+        size_t capacity() const;
+        void resize(size_t size);
+        void reserve(size_t size);
+
+        char* data();
+        const char* data() const;
+
+        unsigned char* udata();
+        const unsigned char* udata() const;
+
+        signed char* sdata();
+        const signed char* sdata() const;
+
+      private:
+        void init(const char* pBuf, size_t size, size_t capacity);
+        static void free(char*& pBuf);
+        void finit();
+
+        char* m_pBuf;
+        size_t m_size;
+        size_t m_capacity;
+    };
+  }
+}
+
+#endif // _STRINGBUFFER_H_
diff --git a/SelfServiceCommon/Interfaces/inc/barcode.h b/SelfServiceCommon/Interfaces/inc/barcode.h
new file mode 100644
index 00000000..a2f72258
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/barcode.h
@@ -0,0 +1,30 @@
+/**
+ **************************************************************************
+ *
+ * @file barcode.h
+ *
+ * create barcode bitmap
+ *
+ **************************************************************************
+**/
+#ifndef BARCODE
+#define BARCODE
+
+#include "bitmap.h"
+
+namespace MASSAI
+{
+  namespace Barcode
+  {
+    class Barcode
+    {
+      public:
+        virtual ~Barcode();
+
+        virtual Bitmap::Bitmap createBarcode(const std::string& barcodeData) const= 0;
+        virtual std::string createBarcodeData(const std::string& data) const= 0;
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/barcode128.h b/SelfServiceCommon/Interfaces/inc/barcode128.h
new file mode 100644
index 00000000..7d492254
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/barcode128.h
@@ -0,0 +1,46 @@
+/**
+ **************************************************************************
+ *
+ * @file barcode128.h
+ *
+ * create barcode128 bitmap
+ *
+ **************************************************************************
+**/
+#ifndef BARCODE128_INCLUDED
+#define BARCODE128_INCLUDED
+
+#include "barcode.h"
+#include <stddef.h>
+
+namespace MASSAI
+{
+  namespace Barcode
+  {
+    struct Barcode128Settings
+    {
+      size_t blockSize;
+      size_t height;
+      bool useQuietZone;
+      bool allowStartCodeA;
+      bool allowStartCodeB;
+      bool allowStartCodeC;
+      bool allowCodeA;
+      bool allowCodeB;
+      bool allowCodeC;
+    };
+    class Barcode128: public Barcode
+    {
+      public:
+        Barcode128(Barcode128Settings settings);
+        virtual ~Barcode128();
+
+        virtual Bitmap::Bitmap createBarcode(const std::string& barcodeData) const;
+        virtual std::string createBarcodeData(const std::string& data) const;
+      private:
+        Barcode128Settings m_settings;
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/barcode39.h b/SelfServiceCommon/Interfaces/inc/barcode39.h
new file mode 100644
index 00000000..b0769ea5
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/barcode39.h
@@ -0,0 +1,43 @@
+/**
+ **************************************************************************
+ *
+ * @file barcode39.h
+ *
+ * create barcode39 bitmap
+ *
+ **************************************************************************
+**/
+#ifndef BARCODE39_INCLUDED
+#define BARCODE39_INCLUDED
+
+#include "barcode.h"
+#include <stddef.h>
+
+namespace MASSAI
+{
+  namespace Barcode
+  {
+    struct Barcode39Settings
+    {
+      size_t narrowBlockSize;
+      size_t wideBlockSize;
+      size_t intercharacterBlockSize;
+      size_t height;
+      bool useQuietZone;
+      bool useChecksum;
+    };
+    class Barcode39: public Barcode
+    {
+      public:
+        Barcode39(Barcode39Settings settings);
+        virtual ~Barcode39();
+
+        virtual Bitmap::Bitmap createBarcode(const std::string& barcodeData) const;
+        virtual std::string createBarcodeData(const std::string& data) const;
+      private:
+        Barcode39Settings m_settings;
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/barcodeIndustrial2of5.h b/SelfServiceCommon/Interfaces/inc/barcodeIndustrial2of5.h
new file mode 100644
index 00000000..f10b03be
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/barcodeIndustrial2of5.h
@@ -0,0 +1,43 @@
+/**
+ **************************************************************************
+ *
+ * @file barcodeIndustrial2of5.h
+ *
+ * create barcodeIndustrial2of5 bitmap
+ *
+ **************************************************************************
+**/
+#ifndef BARCODEIndustrial2of5_INCLUDED
+#define BARCODEIndustrial2of5_INCLUDED
+
+#include "barcode.h"
+#include <stddef.h>
+
+namespace MASSAI
+{
+  namespace Barcode
+  {
+    struct BarcodeIndustrial2of5Settings
+    {
+      size_t narrowBlockSize;
+      size_t wideBlockSize;
+      size_t spaceBlockSize;
+      size_t height;
+      bool useQuietZone;
+      bool useChecksum;
+    };
+    class BarcodeIndustrial2of5: public Barcode
+    {
+      public:
+        BarcodeIndustrial2of5(BarcodeIndustrial2of5Settings settings);
+        virtual ~BarcodeIndustrial2of5();
+
+        virtual Bitmap::Bitmap createBarcode(const std::string& barcodeData) const;
+        virtual std::string createBarcodeData(const std::string& data) const;
+      private:
+        BarcodeIndustrial2of5Settings m_settings;
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/bitarray.h b/SelfServiceCommon/Interfaces/inc/bitarray.h
new file mode 100644
index 00000000..a2578aaf
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/bitarray.h
@@ -0,0 +1,49 @@
+/**
+ **************************************************************************
+ *
+ * @file bitarray.h
+ *
+ *
+ **************************************************************************
+**/
+#ifndef BITARRAY_INCLUDED
+#define BITARRAY_INCLUDED
+
+#include <stddef.h>
+#include "stringbuffer.h"
+
+namespace MASSAI
+{
+  class BitArray
+  {
+    public:
+      typedef unsigned char byte;
+
+      BitArray(const byte* data, size_t size);
+      explicit BitArray(size_t size);
+      size_t size() const;
+      size_t capacity() const;
+      size_t buffer_size() const;
+      void resize(size_t size);
+      void reserve(size_t size);
+      const byte* data() const;
+      byte* data();
+      const MASSAI::text::StringBuffer buffer() const;
+      void flip(size_t index, size_t count= 1);
+      void reset(size_t index, size_t count= 1);
+      void set(size_t index, bool value= true, size_t count= 1);
+//       void and(size_t index, const BitArray& data, size_t start, size_t size);
+//       void or(size_t index, const BitArray& data, size_t start, size_t size);
+//       void xor(size_t index, const BitArray& data, size_t start, size_t size);
+      bool get(size_t index);
+    private:
+      void copy(const byte* src, size_t size, size_t capacity);
+      static size_t getBufferSize(size_t size);
+
+      MASSAI::text::StringBuffer m_data;
+      size_t m_size;
+      size_t m_capacity;
+  };
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/bitmap.h b/SelfServiceCommon/Interfaces/inc/bitmap.h
new file mode 100644
index 00000000..eb30a816
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/bitmap.h
@@ -0,0 +1,30 @@
+/**
+ **************************************************************************
+ *
+ * @file bitmap.h
+ *
+ * create bitmap
+ *
+ **************************************************************************
+**/
+#ifndef BITMAP_INCLUDED
+#define BITMAP_INCLUDED
+
+#include <stddef.h>
+#include "stringbuffer.h"
+
+namespace MASSAI
+{
+  namespace Bitmap
+  {
+    struct Bitmap
+    {
+      public:
+        size_t width;
+        size_t height;
+        MASSAI::text::StringBuffer bmp;
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/blackAndWhiteBitmap.h b/SelfServiceCommon/Interfaces/inc/blackAndWhiteBitmap.h
new file mode 100644
index 00000000..53532acd
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/blackAndWhiteBitmap.h
@@ -0,0 +1,37 @@
+/**
+ **************************************************************************
+ *
+ * @file blackAndWhiteBitmap.h
+ *
+ * create bitmap
+ *
+ **************************************************************************
+**/
+#ifndef BLACKANDWHITEBITMAP
+#define BLACKANDWHITEBITMAP
+
+#include "bitmap.h"
+
+namespace MASSAI
+{
+  namespace Bitmap
+  {
+    class PixelRows
+    {
+      public:
+        virtual ~PixelRows();
+        virtual size_t getHeight() const= 0;
+        virtual size_t getWidth() const= 0;
+        virtual const MASSAI::text::StringBuffer& getRow(size_t y) const= 0;
+    };
+    class BlackAndWhiteBitmap
+    {
+      public:
+        BlackAndWhiteBitmap();
+        ~BlackAndWhiteBitmap();
+        Bitmap createBitmap(const PixelRows& pixel);
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/localtrace.h b/SelfServiceCommon/Interfaces/inc/localtrace.h
new file mode 100644
index 00000000..737e8979
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/localtrace.h
@@ -0,0 +1,31 @@
+#ifndef TRACE_H
+#define TRACE_H
+
+#define TRC_OK                    0
+#define TRC_ERROR                 1
+
+#define __FUNCTION__ ""
+
+#define MajorError_HERE         1,__FILE__,__LINE__,__FUNCTION__
+#define MinorError_HERE         2,__FILE__,__LINE__,__FUNCTION__
+#define MajorWarning_HERE       3,__FILE__,__LINE__,__FUNCTION__
+#define MinorWarning_HERE       4,__FILE__,__LINE__,__FUNCTION__
+#define BasicRuntime_HERE       5,__FILE__,__LINE__,__FUNCTION__
+#define BasicProcess_HERE       6,__FILE__,__LINE__,__FUNCTION__
+#define SecondaryRuntime_HERE   7,__FILE__,__LINE__,__FUNCTION__
+#define SecondaryFrequent_HERE  8,__FILE__,__LINE__,__FUNCTION__
+
+namespace MASSAI
+{
+  namespace localtrace
+  {
+    void openTrace(const char* pszApplication);
+    long writeTraceText(long lTraceLevel, const char* pszFile, short sLine, const char* pszFunction, const char* pszText);
+    long wrtTrace (long lTraceLevel, const char* pszFile, short sLine, const char* pszFunction, const char* pszFormat, ...);
+    long dumpTrace(long lTraceLevel, const char* pszFile, short sLine, const char* pszFunction, long lDumpSize, const char* pDump);
+
+    void closeTrace();
+  }
+
+}
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/pixelrow.h b/SelfServiceCommon/Interfaces/inc/pixelrow.h
new file mode 100644
index 00000000..94faac22
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/pixelrow.h
@@ -0,0 +1,36 @@
+/**
+ **************************************************************************
+ *
+ * @file PixelRow.h
+ *
+ * create bitmap
+ *
+ **************************************************************************
+**/
+#ifndef PIXELROW_INCLUDED
+#define PIXELROW_INCLUDED
+
+#include "blackAndWhiteBitmap.h"
+#include "bitarray.h"
+#include <stddef.h>
+
+namespace MASSAI
+{
+  namespace Bitmap
+  {
+    class PixelRow: public PixelRows
+    {
+      public:
+        PixelRow(const MASSAI::BitArray& barcodeData, size_t height);
+        virtual size_t getHeight() const;
+        virtual size_t getWidth() const;
+        virtual const MASSAI::text::StringBuffer& getRow(size_t y) const;
+      private:
+        size_t m_height;
+        size_t m_width;
+        MASSAI::text::StringBuffer m_row;
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/stringbuffer.h b/SelfServiceCommon/Interfaces/inc/stringbuffer.h
new file mode 100644
index 00000000..62363ae6
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/stringbuffer.h
@@ -0,0 +1,77 @@
+/**
+ **************************************************************************
+ *
+ * @file stringbuffer.h
+ *
+ *
+ *
+ * Copyright (c) 2008 MATERNA Information & Communications
+ *
+ **************************************************************************
+**/
+
+#ifndef _STRINGBUFFER_H_
+#define _STRINGBUFFER_H_
+
+#include <string>
+#include <stddef.h>
+
+namespace MASSAI
+{
+  namespace text
+  {
+    class StringBuffer
+    {
+      public:
+        StringBuffer();
+        explicit StringBuffer(size_t size);
+        StringBuffer(size_t size, size_t capacity);
+
+        StringBuffer(const StringBuffer& assign);
+        StringBuffer(const StringBuffer& assign, size_t capacity);
+
+        explicit StringBuffer(const char* assign);
+        StringBuffer(const char* assign, size_t size);
+        StringBuffer(const char* assign, size_t size, size_t capacity);
+
+        explicit StringBuffer(const unsigned char* uassign);
+        StringBuffer(const unsigned char* uassign, size_t size);
+        StringBuffer(const unsigned char* uassign, size_t size, size_t capacity);
+
+        explicit StringBuffer(const signed char* sassign);
+        StringBuffer(const signed char* sassign, size_t size);
+        StringBuffer(const signed char* sassign, size_t size, size_t capacity);
+
+        explicit StringBuffer(const std::string& assign);
+        StringBuffer(const std::string& assign, size_t capacity);
+
+        StringBuffer& operator= (const StringBuffer& assign);
+        ~StringBuffer();
+
+        size_t size() const;
+        size_t capacity() const;
+        void resize(size_t size);
+        void reserve(size_t size);
+
+        char* data();
+        const char* data() const;
+
+        unsigned char* udata();
+        const unsigned char* udata() const;
+
+        signed char* sdata();
+        const signed char* sdata() const;
+
+      private:
+        void init(const char* pBuf, size_t size, size_t capacity);
+        static void free(char*& pBuf);
+        void finit();
+
+        char* m_pBuf;
+        size_t m_size;
+        size_t m_capacity;
+    };
+  }
+}
+
+#endif // _STRINGBUFFER_H_
diff --git a/SelfServiceCommon/Massai/cpp/Tools/inc/local_def_msystools.h b/SelfServiceCommon/Massai/cpp/Tools/inc/local_def_msystools.h
index bfca9d9a..c7f72c01 100644
--- a/SelfServiceCommon/Massai/cpp/Tools/inc/local_def_msystools.h
+++ b/SelfServiceCommon/Massai/cpp/Tools/inc/local_def_msystools.h
@@ -1,6 +1,21 @@
 /*! \mainpage msystools
  *
  *
+ *  \date 22.09.2010 \li V1.0.1.7
+ *                   \li SteT - Added
+ *                   \li   - interface barcode, implementation barcode39, barcode128, barcodeIndustrial2of5
+ *                   \li            create barcode bitmap
+ *                   \li   - interface bitmap, implementation blackAndWhiteBitmap
+ *                   \li            create bitmap from stringbuffer
+ *                   \li   - bitarray
+ *                   \li            access single bit
+ *                   \li   - pixelrow
+ *                   \li            create a bitmap of a single bitarray (repeating the line)
+ *                   \li   - stringbuffer
+ *                   \li            hold a char* buffer, allow direct access to char* (read and write)
+ *                   \li   - localtrace
+ *                   \li            write traces to stdout
+ *
  *  \date 23.06.2009 \li V1.0.1.6
  *                   \li JK - Added mSysThread module.
  *                   \li      This module replaces matThread. Differences:
@@ -13,7 +28,7 @@
  *  \date 05.02.2009 \li V1.0.1.5
  *                   \li JK - Extended mSysProcess module.
  *                   \li      - allow also to redirect stdin
- *                   \li      - allo to hide a child window
+ *                   \li      - allow to hide a child window
  *
  *  \date 04.02.2009 \li V1.0.1.4
  *                   \li JK - Added mSysProcess module.
@@ -42,8 +57,8 @@
  *
  */
 
-#define FILE_VER_BIN     1,0,1,5
-#define FILE_VER_STR     "FileVersion", "1.0.1.5\0"
+#define FILE_VER_BIN     1,0,1,7
+#define FILE_VER_STR     "FileVersion", "1.0.1.7\0"
 
 #define FILEDESCRIPTION  "FileDescription"  ,"mSysTools\0"
 #define INTERNALNAME     "InternalName"     ,"mSysTools\0"
diff --git a/SelfServiceCommon/Massai/cpp/Tools/makefile.mak b/SelfServiceCommon/Massai/cpp/Tools/makefile.mak
index 13b0cc31..54e24c53 100644
--- a/SelfServiceCommon/Massai/cpp/Tools/makefile.mak
+++ b/SelfServiceCommon/Massai/cpp/Tools/makefile.mak
@@ -45,7 +45,16 @@ MY_LIB1_OBJS =          $(_OBJ)\mArgScan.obj \
                         $(_OBJ)\dateProperties.obj \
                         $(_OBJ)\AssoFlat.obj \
                         $(_OBJ)\AssoDump.obj \
-                        $(_OBJ)\textTemplate.obj
+                        $(_OBJ)\textTemplate.obj \
+                        $(_OBJ)\barcode128.obj \
+                        $(_OBJ)\bitarray.obj \
+                        $(_OBJ)\localtrace.obj \
+                        $(_OBJ)\stringbuffer.obj \
+                        $(_OBJ)\blackAndWhiteBitmap.obj \
+                        $(_OBJ)\barcode.obj \
+                        $(_OBJ)\pixelrow.obj \
+                        $(_OBJ)\barcode39.obj \
+                        $(_OBJ)\barcodeIndustrial2of5.obj
 
 
 
@@ -83,11 +92,43 @@ MY_BIN4_OBJS =          $(_OBJ)\HexDump2Bin.obj
 
 ######################################################################
 
-MY_BIN5 =               $(_BIN)\TestSysThread.exe
+MY_BIN5 =               $(_BIN)\TestBitArray.exe
 
 MY_BIN5_LINKLIBS =      $(_LIB)\msystools.lib
 
-MY_BIN5_OBJS =          $(_OBJ)\TestSysThread.obj
+MY_BIN5_OBJS =          $(_OBJ)\TestBitArray.obj
+
+######################################################################
+
+MY_BIN6 =               $(_BIN)\TestSysThread.exe
+
+MY_BIN6_LINKLIBS =      $(_LIB)\msystools.lib
+
+MY_BIN6_OBJS =          $(_OBJ)\TestSysThread.obj
+
+######################################################################
+
+MY_BIN6 =               $(_BIN)\TestBarcode128.exe
+
+MY_BIN6_LINKLIBS =      $(_LIB)\msystools.lib
+
+MY_BIN6_OBJS =          $(_OBJ)\TestBarcode128.obj
+
+######################################################################
+
+MY_BIN7 =               $(_BIN)\TestBarcode39.exe
+
+MY_BIN7_LINKLIBS =      $(_LIB)\msystools.lib
+
+MY_BIN7_OBJS =          $(_OBJ)\TestBarcode39.obj
+
+######################################################################
+
+MY_BIN8 =               $(_BIN)\TestBarcodeIndustrial2of5.exe
+
+MY_BIN8_LINKLIBS =      $(_LIB)\msystools.lib
+
+MY_BIN8_OBJS =          $(_OBJ)\TestBarcodeIndustrial2of5.obj
 
 ######################################################################
 #
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/TestBarcode128.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/TestBarcode128.cpp
new file mode 100644
index 00000000..42f049e0
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/TestBarcode128.cpp
@@ -0,0 +1,59 @@
+#include "barcode128.h"
+#include "localtrace.h"
+#include <fstream>
+
+using namespace MASSAI::localtrace;
+using namespace MASSAI::Barcode;
+using namespace MASSAI::Bitmap;
+
+
+void createBarcode(const std::string& name, const std::string& data, Barcode128Settings settings)
+{
+  Barcode128 test(settings);
+  std::string barcodeData= test.createBarcodeData(data);
+  Bitmap bitmap= test.createBarcode(barcodeData);
+  dumpTrace(BasicRuntime_HERE, barcodeData.size(), barcodeData.data());
+  dumpTrace(BasicRuntime_HERE, bitmap.bmp.size(), bitmap.bmp.data());
+  std::ofstream out((name + ".bmp").c_str());
+  out.write(bitmap.bmp.data(), bitmap.bmp.size());
+}
+
+int main(int argc, char** argv)
+{
+  openTrace(argv[0]);
+  {
+    Barcode128Settings settings= {1, 1, true, true, true, true};
+    createBarcode("Any_7", "7", settings);
+    createBarcode("Any_123456789", "123456789", settings);
+    createBarcode("Any_ABcDE", "AB\ncDE\n", settings);
+    createBarcode("Any_AB12345", "AB12345", settings);
+    createBarcode("Any_AB123456", "AB123456", settings);
+  }
+  {
+    Barcode128Settings settings= {1, 1, true, true, false, false};
+    createBarcode("A_7", "7", settings);
+    createBarcode("A_123456789", "123456789", settings);
+    createBarcode("A_ABcDE", "AB\ncDE\n", settings);
+    createBarcode("A_AB12345", "AB12345", settings);
+    createBarcode("A_AB123456", "AB123456", settings);
+  }
+  {
+    Barcode128Settings settings= {1, 1, true, false, true, false};
+    createBarcode("B_7", "7", settings);
+    createBarcode("B_123456789", "123456789", settings);
+    createBarcode("B_ABcDE", "AB\ncDE\n", settings);
+    createBarcode("B_AB12345", "AB12345", settings);
+    createBarcode("B_AB123456", "AB123456", settings);
+  }
+  {
+    Barcode128Settings settings= {1, 1, true, false, false, true};
+    createBarcode("C_7", "7", settings);
+    createBarcode("C_123456789", "123456789", settings);
+    createBarcode("C_ABcDE", "AB\ncDE\n", settings);
+    createBarcode("C_AB12345", "AB12345", settings);
+    createBarcode("C_AB123456", "AB123456", settings);
+  }
+
+  closeTrace();
+  return 0;
+}
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/TestBarcode39.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/TestBarcode39.cpp
new file mode 100644
index 00000000..27311afa
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/TestBarcode39.cpp
@@ -0,0 +1,40 @@
+#include "barcode39.h"
+#include "localtrace.h"
+#include <fstream>
+
+using namespace MASSAI::localtrace;
+using namespace MASSAI::Barcode;
+using namespace MASSAI::Bitmap;
+
+
+void createBarcode(const std::string& name, const std::string& data, Barcode39Settings settings)
+{
+  Barcode39 test(settings);
+  std::string barcodeData= test.createBarcodeData(data);
+  Bitmap bitmap= test.createBarcode(barcodeData);
+  dumpTrace(BasicRuntime_HERE, barcodeData.size(), barcodeData.data());
+  dumpTrace(BasicRuntime_HERE, bitmap.bmp.size(), bitmap.bmp.data());
+  std::ofstream out((name + ".bmp").c_str());
+  out.write(bitmap.bmp.data(), bitmap.bmp.size());
+}
+
+      size_t narrowBlockSize;
+      size_t wideBlockSize;
+      size_t intermediateBlockSize;
+      size_t height;
+      bool useQuietZone;
+      bool useChecksum;
+
+int main(int argc, char** argv)
+{
+  openTrace(argv[0]);
+  Barcode39Settings settings= {1, 2, 1, 1, true, true};
+  createBarcode("7", "7", settings);
+  createBarcode("123456789", "123456789", settings);
+  createBarcode("ABcDE", "AB\ncDE\n", settings);
+  createBarcode("AB12345", "AB12345", settings);
+  createBarcode("AB123456", "AB123456", settings);
+
+  closeTrace();
+  return 0;
+}
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/TestBarcodeIndustrial2of5.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/TestBarcodeIndustrial2of5.cpp
new file mode 100644
index 00000000..62279256
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/TestBarcodeIndustrial2of5.cpp
@@ -0,0 +1,40 @@
+#include "barcodeIndustrial2of5.h"
+#include "localtrace.h"
+#include <fstream>
+
+using namespace MASSAI::localtrace;
+using namespace MASSAI::Barcode;
+using namespace MASSAI::Bitmap;
+
+
+void createBarcode(const std::string& name, const std::string& data, BarcodeIndustrial2of5Settings settings)
+{
+  BarcodeIndustrial2of5 test(settings);
+  std::string barcodeData= test.createBarcodeData(data);
+  Bitmap bitmap= test.createBarcode(barcodeData);
+  dumpTrace(BasicRuntime_HERE, barcodeData.size(), barcodeData.data());
+  dumpTrace(BasicRuntime_HERE, bitmap.bmp.size(), bitmap.bmp.data());
+  std::ofstream out((name + ".bmp").c_str());
+  out.write(bitmap.bmp.data(), bitmap.bmp.size());
+}
+
+      size_t narrowBlockSize;
+      size_t wideBlockSize;
+      size_t intermediateBlockSize;
+      size_t height;
+      bool useQuietZone;
+      bool useChecksum;
+
+int main(int argc, char** argv)
+{
+  openTrace(argv[0]);
+  BarcodeIndustrial2of5Settings settings= {1, 2, 1, 1, true, true};
+  createBarcode("7", "7", settings);
+  createBarcode("123456789", "123456789", settings);
+  createBarcode("ABcDE", "AB\ncDE\n", settings);
+  createBarcode("AB12345", "AB12345", settings);
+  createBarcode("AB123456", "AB123456", settings);
+
+  closeTrace();
+  return 0;
+}
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/TestBitArray.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/TestBitArray.cpp
new file mode 100644
index 00000000..bc68c0c9
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/TestBitArray.cpp
@@ -0,0 +1,78 @@
+#include "bitarray.h"
+#include "localtrace.h"
+
+using namespace MASSAI::localtrace;
+using MASSAI::BitArray;
+
+int main(int argc, char** argv)
+{
+  unsigned char set[6][3]={
+    {0xe0, 0x00, 0x00},
+    {0xfc, 0x00, 0x00},
+    {0xff, 0x80, 0x00},
+    {0xff, 0xf0, 0x00},
+    {0xff, 0xfe, 0x00},
+    {0xff, 0xff, 0xc0}
+  };
+  unsigned char reset[6][3]={
+    {0x1f, 0xff, 0xc0},
+    {0x03, 0xff, 0xc0},
+    {0x00, 0x7f, 0xc0},
+    {0x00, 0x0f, 0xc0},
+    {0x00, 0x01, 0xc0},
+    {0x00, 0x00, 0x00}
+  };
+
+  openTrace(argv[0]);
+  BitArray test(20);
+  { // test set
+    for(int i= 0, j= 0; i < 17, j < 6; i+=3, j++)
+    {
+      test.set(i, 1, 3);
+      if(memcmp(set[j], test.data(), 3) != 0)
+      {
+        wrtTrace(MajorError_HERE, "mismatch in test set index (%d), testset (%d)", i, j);
+        dumpTrace(BasicRuntime_HERE, test.buffer_size(), reinterpret_cast<char*>(test.data()));
+        dumpTrace(BasicRuntime_HERE, 3, reinterpret_cast<char*>(set[j]));
+      }
+    }
+  }
+  { // test reset
+    for(int i= 0, j= 0; i < 17, j < 6; i+=3, j++)
+    {
+      test.reset(i, 3);
+      if(memcmp(reset[j], test.data(), 3) != 0)
+      {
+        wrtTrace(MajorError_HERE, "mismatch in test reset index (%d), testset (%d)", i, j);
+        dumpTrace(BasicRuntime_HERE, test.buffer_size(), reinterpret_cast<char*>(test.data()));
+        dumpTrace(BasicRuntime_HERE, 3, reinterpret_cast<char*>(reset[j]));
+      }
+    }
+  }
+  { // test flip
+    for(int i= 0, j= 0; i < 17, j < 6; i+=3, j++)
+    {
+      test.flip(i, 3);
+      if(memcmp(set[j], test.data(), 3) != 0)
+      {
+        wrtTrace(MajorError_HERE, "mismatch in test flip(set) index (%d), testset (%d)", i, j);
+        dumpTrace(BasicRuntime_HERE, test.buffer_size(), reinterpret_cast<char*>(test.data()));
+        dumpTrace(BasicRuntime_HERE, 3, reinterpret_cast<char*>(set[j]));
+      }
+    }
+  }
+  { // test flip
+    for(int i= 0, j= 0; i < 17, j < 6; i+=3, j++)
+    {
+      test.flip(i, 3);
+      if(memcmp(reset[j], test.data(), 3) != 0)
+      {
+        wrtTrace(MajorError_HERE, "mismatch in test flip(reset) index (%d), testset (%d)", i, j);
+        dumpTrace(BasicRuntime_HERE, test.buffer_size(), reinterpret_cast<char*>(test.data()));
+        dumpTrace(BasicRuntime_HERE, 3, reinterpret_cast<char*>(reset[j]));
+      }
+    }
+  }
+  closeTrace();
+  return 0;
+}
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/barcode.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/barcode.cpp
new file mode 100644
index 00000000..26d04970
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/barcode.cpp
@@ -0,0 +1,19 @@
+/**
+ **************************************************************************
+ *
+ * @file barcode.cpp
+ *
+ * create barcode bitmap
+ *
+ **************************************************************************
+**/
+#include "barcode.h"
+
+namespace MASSAI
+{
+  namespace Barcode
+  {
+    Barcode::~Barcode()
+    {}
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/barcode128.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/barcode128.cpp
new file mode 100644
index 00000000..096a720f
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/barcode128.cpp
@@ -0,0 +1,579 @@
+/**
+ **************************************************************************
+ *
+ * @file barcode128.cpp
+ *
+ * Implementation for definitions in "barcode128.h".
+ *
+ **************************************************************************
+**/
+
+#include "barcode128.h"
+#include "blackAndWhiteBitmap.h"
+#include "bitarray.h"
+#include "pixelrow.h"
+#include <vector>
+
+namespace
+{
+  using MASSAI::Barcode::Barcode128Settings;
+
+  typedef int BC128_Value;
+  const BC128_Value invalidBCValue= -1;
+  enum { BC_128_PATTERN_SIZE= 7 };
+  enum { BC_128_PATTERN_WIDTH= 11, BC_128_STOP_PATTERN_WIDTH = 13, BC_128_QUIET_ZONE_WIDTH = 10 };
+  enum { BC_128_VALUE_COUNT = 107 };
+  // SHIFT: change code for next character (from A to B or B to A)
+  // CODE A, CODE B, CODE C: change code for all following characters
+  // FNC 1, FNC 2, FNC 3, FNC 4: wird nicht genutzt.
+  enum {
+    BC_128_SHIFT_VALUE = 98,
+    BC_128_CODE_C_VALUE = 99,
+    BC_128_CODE_B_VALUE = 100,
+    BC_128_CODE_A_VALUE = 101,
+    BC_128_START_A_VALUE = 103,
+    BC_128_START_B_VALUE = 104,
+    BC_128_START_C_VALUE = 105,
+    BC_128_STOP_VALUE = 106
+  };
+
+
+  struct BC_128_Barcode
+  {
+    BC128_Value value;
+    int pattern[BC_128_PATTERN_SIZE];
+  };
+
+  const BC_128_Barcode barcode[BC_128_VALUE_COUNT] =
+  {
+    {0,   {2, 1, 2, 2, 2, 2, 0}},
+    {1,   {2, 2, 2, 1, 2, 2, 0}},
+    {2,   {2, 2, 2, 2, 2, 1, 0}},
+    {3,   {1, 2, 1, 2, 2, 3, 0}},
+    {4,   {1, 2, 1, 3, 2, 2, 0}},
+    {5,   {1, 3, 1, 2, 2, 2, 0}},
+    {6,   {1, 2, 2, 2, 1, 3, 0}},
+    {7,   {1, 2, 2, 3, 1, 2, 0}},
+    {8,   {1, 3, 2, 2, 1, 2, 0}},
+    {9,   {2, 2, 1, 2, 1, 3, 0}},
+    {10,  {2, 2, 1, 3, 1, 2, 0}},
+    {11,  {2, 3, 1, 2, 1, 2, 0}},
+    {12,  {1, 1, 2, 2, 3, 2, 0}},
+    {13,  {1, 2, 2, 1, 3, 2, 0}},
+    {14,  {1, 2, 2, 2, 3, 1, 0}},
+    {15,  {1, 1, 3, 2, 2, 2, 0}},
+    {16,  {1, 2, 3, 1, 2, 2, 0}},
+    {17,  {1, 2, 3, 2, 2, 1, 0}},
+    {18,  {2, 2, 3, 2, 1, 1, 0}},
+    {19,  {2, 2, 1, 1, 3, 2, 0}},
+    {20,  {2, 2, 1, 2, 3, 1, 0}},
+    {21,  {2, 1, 3, 2, 1, 2, 0}},
+    {22,  {2, 2, 3, 1, 1, 2, 0}},
+    {23,  {3, 1, 2, 1, 3, 1, 0}},
+    {24,  {3, 1, 1, 2, 2, 2, 0}},
+    {25,  {3, 2, 1, 1, 2, 2, 0}},
+    {26,  {3, 2, 1, 2, 2, 1, 0}},
+    {27,  {3, 1, 2, 2, 1, 2, 0}},
+    {28,  {3, 2, 2, 1, 1, 2, 0}},
+    {29,  {3, 2, 2, 2, 1, 1, 0}},
+    {30,  {2, 1, 2, 1, 2, 3, 0}},
+    {31,  {2, 1, 2, 3, 2, 1, 0}},
+    {32,  {2, 3, 2, 1, 2, 1, 0}},
+    {33,  {1, 1, 1, 3, 2, 3, 0}},
+    {34,  {1, 3, 1, 1, 2, 3, 0}},
+    {35,  {1, 3, 1, 3, 2, 1, 0}},
+    {36,  {1, 1, 2, 3, 1, 3, 0}},
+    {37,  {1, 3, 2, 1, 1, 3, 0}},
+    {38,  {1, 3, 2, 3, 1, 1, 0}},
+    {39,  {2, 1, 1, 3, 1, 3, 0}},
+    {40,  {2, 3, 1, 1, 1, 3, 0}},
+    {41,  {2, 3, 1, 3, 1, 1, 0}},
+    {42,  {1, 1, 2, 1, 3, 3, 0}},
+    {43,  {1, 1, 2, 3, 3, 1, 0}},
+    {44,  {1, 3, 2, 1, 3, 1, 0}},
+    {45,  {1, 1, 3, 1, 2, 3, 0}},
+    {46,  {1, 1, 3, 3, 2, 1, 0}},
+    {47,  {1, 3, 3, 1, 2, 1, 0}},
+    {48,  {3, 1, 3, 1, 2, 1, 0}},
+    {49,  {2, 1, 1, 3, 3, 1, 0}},
+    {50,  {2, 3, 1, 1, 3, 1, 0}},
+    {51,  {2, 1, 3, 1, 1, 3, 0}},
+    {52,  {2, 1, 3, 3, 1, 1, 0}},
+    {53,  {2, 1, 3, 1, 3, 1, 0}},
+    {54,  {3, 1, 1, 1, 2, 3, 0}},
+    {55,  {3, 1, 1, 3, 2, 1, 0}},
+    {56,  {3, 3, 1, 1, 2, 1, 0}},
+    {57,  {3, 1, 2, 1, 1, 3, 0}},
+    {58,  {3, 1, 2, 3, 1, 1, 0}},
+    {59,  {3, 3, 2, 1, 1, 1, 0}},
+    {60,  {3, 1, 4, 1, 1, 1, 0}},
+    {61,  {2, 2, 1, 4, 1, 1, 0}},
+    {62,  {4, 3, 1, 1, 1, 1, 0}},
+    {63,  {1, 1, 1, 2, 2, 4, 0}},
+    {64,  {1, 1, 1, 4, 2, 2, 0}},
+    {65,  {1, 2, 1, 1, 2, 4, 0}},
+    {66,  {1, 2, 1, 4, 2, 1, 0}},
+    {67,  {1, 4, 1, 1, 2, 2, 0}},
+    {68,  {1, 4, 1, 2, 2, 1, 0}},
+    {69,  {1, 1, 2, 2, 1, 4, 0}},
+    {70,  {1, 1, 2, 4, 1, 2, 0}},
+    {71,  {1, 2, 2, 1, 1, 4, 0}},
+    {72,  {1, 2, 2, 4, 1, 1, 0}},
+    {73,  {1, 4, 2, 1, 1, 2, 0}},
+    {74,  {1, 4, 2, 2, 1, 1, 0}},
+    {75,  {2, 4, 1, 2, 1, 1, 0}},
+    {76,  {2, 2, 1, 1, 1, 4, 0}},
+    {77,  {4, 1, 3, 1, 1, 1, 0}},
+    {78,  {2, 4, 1, 1, 1, 2, 0}},
+    {79,  {1, 3, 4, 1, 1, 1, 0}},
+    {80,  {1, 1, 1, 2, 4, 2, 0}},
+    {81,  {1, 2, 1, 1, 4, 2, 0}},
+    {82,  {1, 2, 1, 2, 4, 1, 0}},
+    {83,  {1, 1, 4, 2, 1, 2, 0}},
+    {84,  {1, 2, 4, 1, 1, 2, 0}},
+    {85,  {1, 2, 4, 2, 1, 1, 0}},
+    {86,  {4, 1, 1, 2, 1, 2, 0}},
+    {87,  {4, 2, 1, 1, 1, 2, 0}},
+    {88,  {4, 2, 1, 2, 1, 1, 0}},
+    {89,  {2, 1, 2, 1, 4, 1, 0}},
+    {90,  {2, 1, 4, 1, 2, 1, 0}},
+    {91,  {4, 1, 2, 1, 2, 1, 0}},
+    {92,  {1, 1, 1, 1, 4, 3, 0}},
+    {93,  {1, 1, 1, 3, 4, 1, 0}},
+    {94,  {1, 3, 1, 1, 4, 1, 0}},
+    {95,  {1, 1, 4, 1, 1, 3, 0}},
+    {96,  {1, 1, 4, 3, 1, 1, 0}},
+    {97,  {4, 1, 1, 1, 1, 3, 0}},
+    {98,  {4, 1, 1, 3, 1, 1, 0}},
+    {99,  {1, 1, 3, 1, 4, 1, 0}},
+    {100, {1, 1, 4, 1, 3, 1, 0}},
+    {101, {3, 1, 1, 1, 4, 1, 0}},
+    {102, {4, 1, 1, 1, 3, 1, 0}},
+    {103, {2, 1, 1, 4, 1, 2, 0}},
+    {104, {2, 1, 1, 2, 1, 4, 0}},
+    {105, {2, 1, 1, 2, 3, 2, 0}},
+    {106, {2, 3, 3, 1, 1, 1, 2}}
+  };
+  size_t getBarcodePixelCount(const std::string barcodeData)
+  {
+    size_t result= 0;
+    for(size_t i= 0; i < barcodeData.size(); i++)
+    {
+      char c= barcodeData[i];
+      if(c >= 0 && c < BC_128_VALUE_COUNT)
+      {
+        if(c == BC_128_STOP_VALUE)
+        {
+          result+= BC_128_STOP_PATTERN_WIDTH;
+        }
+        else
+        {
+          result+= BC_128_PATTERN_WIDTH;
+        }
+      }
+    }
+    return result;
+  }
+  MASSAI::BitArray createBarcodePixel(const std::string barcodeData, Barcode128Settings settings)
+  {
+    size_t width= getBarcodePixelCount(barcodeData) * settings.blockSize;
+    if(settings.useQuietZone)
+    {
+      width+= 2 * BC_128_QUIET_ZONE_WIDTH * settings.blockSize;
+    }
+    MASSAI::BitArray result(width);
+    size_t bitIndex= 0;
+    if(settings.useQuietZone)
+    {
+      size_t width= BC_128_QUIET_ZONE_WIDTH * settings.blockSize;
+      result.set(bitIndex, true, width);
+      bitIndex+= width;
+    }
+    for(size_t i= 0; i < barcodeData.size(); i++)
+    {
+      char c= barcodeData[i];
+      if(c >= 0 && c < BC_128_VALUE_COUNT)
+      {
+        const BC_128_Barcode& code= barcode[c];
+        bool value= false;
+        for(size_t j= 0; j < BC_128_PATTERN_SIZE; j++)
+        {
+          size_t width= code.pattern[j] * settings.blockSize;
+          result.set(bitIndex, value, width);
+          bitIndex+= width;
+          value= !value;
+        }
+      }
+    }
+    if(settings.useQuietZone)
+    {
+      size_t width= BC_128_QUIET_ZONE_WIDTH * settings.blockSize;
+      result.set(bitIndex, true, width);
+      bitIndex+= width;
+    }
+    return result;
+  }
+
+  enum BC_128_Code
+  {
+    BC_128_CODE_A,
+    BC_128_CODE_B,
+    BC_128_CODE_C,
+  };
+  struct BC_128_CharState
+  {
+    size_t digitCount;
+    bool useCodeA;
+    bool useCodeB;
+  };
+  BC_128_CharState stateUseAny= {0, true, true};
+  BC_128_CharState stateUseA= {0, true, false};
+  BC_128_CharState stateUseB= {0, false, true};
+  BC_128_CharState stateUseNone= {0, false, false};
+
+
+
+  BC128_Value getValueTypeA(char in)
+  {
+    // NUL..US
+    // 0..31 -> 64..95
+    // Space!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_
+    // 32..127 -> 0..95
+    if((0 <= in) && (in < 32))
+      return in + 64;
+    else if((32 <= in) && (in < 96))
+      return in - 32;
+    else
+      return invalidBCValue;
+  }
+  BC128_Value getValueTypeB(char in)
+  {
+    // Space!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_'abcdefghijklmnopqrstuvwxyz{|}~DEL
+    // 32..127 -> 0..95
+    if((32 <= in) && (in <= 127))
+      return in - 32;
+    else
+      return invalidBCValue;
+  }
+  BC128_Value getValue(BC_128_Code code, char in)
+  {
+    switch(code)
+    {
+      case BC_128_CODE_A: return getValueTypeA(in);
+      case BC_128_CODE_B: return getValueTypeB(in);
+    }
+    return invalidBCValue;
+  }
+  BC128_Value getStartCode(BC_128_Code code)
+  {
+    switch(code)
+    {
+      case BC_128_CODE_A: return BC_128_START_A_VALUE;
+      case BC_128_CODE_B: return BC_128_START_B_VALUE;
+      case BC_128_CODE_C: return BC_128_START_C_VALUE;
+    }
+    return invalidBCValue;
+  }
+  BC128_Value getSwitchCode(BC_128_Code code)
+  {
+    switch(code)
+    {
+      case BC_128_CODE_A: return BC_128_CODE_A_VALUE;
+      case BC_128_CODE_B: return BC_128_CODE_B_VALUE;
+      case BC_128_CODE_C: return BC_128_CODE_C_VALUE;
+    }
+    return invalidBCValue;
+  }
+  BC128_Value getShiftCode()
+  {
+    return BC_128_SHIFT_VALUE;
+  }
+  BC128_Value getStopCode()
+  {
+    return BC_128_STOP_VALUE;
+  }
+
+  std::string filterValidData(const std::string data, Barcode128Settings settings)
+  {
+    std::string validData;
+    validData.reserve(data.size());
+    for(int i= 0; i < data.size(); i++)
+    {
+      if(isdigit(data[i])
+        || (settings.allowCodeA && getValueTypeA(data[i]) != invalidBCValue)
+        || (settings.allowCodeB && getValueTypeB(data[i]) != invalidBCValue))
+      {
+        validData.append(1, data[i]);
+      }
+    }
+    return validData;
+  }
+  typedef std::vector<BC_128_CharState> StateVector;
+  StateVector getStates(const std::string data)
+  {
+    StateVector states(data.size());
+    BC_128_CharState state= stateUseAny;
+
+    for(int i= data.size() - 1; i >= 0; i--)
+    {
+      if(isdigit(data[i]))
+      {
+        state.digitCount++;
+      }
+      else
+      {
+        if(getValueTypeA(data[i]) == invalidBCValue)
+        {
+          if(getValueTypeB(data[i]) == invalidBCValue)
+          {
+            state= stateUseNone; // never occur
+          }
+          else
+          {
+            state= stateUseB;
+          }
+        }
+        else
+        {
+          if(getValueTypeB(data[i]) == invalidBCValue)
+          {
+            state= stateUseA;
+          }
+          else
+          {
+            state.digitCount= 0;
+          }
+        }
+      }
+      states[i] = state;
+    }
+    return states;
+  }
+  BC_128_Code getStartCode(const StateVector& states, Barcode128Settings settings)
+  {
+    BC_128_Code code= BC_128_CODE_A;
+    if(!settings.allowStartCodeA)
+    {
+      if(settings.allowStartCodeB)
+      {
+        code= BC_128_CODE_B;
+      }
+      else
+      {
+        code= BC_128_CODE_C;
+      }
+    }
+    if(states.size() > 0)
+    {
+      if(states[0].digitCount > 3 && settings.allowStartCodeC)
+      {
+        code= BC_128_CODE_C;
+      }
+      else if(states[0].digitCount > 1 && states[0].digitCount == states.size() && settings.allowStartCodeC)
+      {
+        code= BC_128_CODE_C;
+      }
+      else if(states[0].useCodeA && settings.allowStartCodeA)
+      {
+        code= BC_128_CODE_A;
+      }
+      else if(states[0].useCodeB && settings.allowStartCodeB)
+      {
+        code= BC_128_CODE_B;
+      }
+    }
+    return code;
+  }
+  struct CheckSum
+  {
+    public:
+      CheckSum():
+        checksum(0)
+      {}
+      void addValue(int position, BC128_Value value)
+      {
+        if(position > 0)
+        {
+          checksum+= value * (position % 103);
+          checksum%= 103;
+        }
+      }
+      BC128_Value getValue()
+      {
+        return checksum;
+      }
+    private:
+      BC128_Value checksum;
+  };
+
+  void appendCode(std::string& result, CheckSum& check, BC128_Value value)
+  {
+    check.addValue(result.size(), value);
+    result.append(1, value);
+  }
+  void appendCode(std::string& result, CheckSum& check, const std::string& data, int& source, BC_128_Code code)
+  {
+    switch(code)
+    {
+      case BC_128_CODE_A:
+      case BC_128_CODE_B:
+      {
+        appendCode(result, check, getValue(code, data[source]));
+        source++;
+        break;
+      }
+      case BC_128_CODE_C:
+      {
+        if(data.size() > source+1 && isdigit(data[source+1]))
+        {
+          appendCode(result, check, (data[source] - '0') * 10 + (data[source+1] - '0'));
+          source+= 2;
+        }
+        else
+        {
+          // never occur
+          // add a 0
+          appendCode(result, check, data[source] - '0' * 10);
+          source++;
+        }
+        break;
+      }
+    }
+  }
+  BC_128_Code getSwitchCode(const StateVector& states, int position, BC_128_Code& code, Barcode128Settings settings)
+  {
+    BC_128_Code result= code;
+    bool shift= false;
+    switch(code)
+    {
+      case BC_128_CODE_A:
+      {
+        if(states[position].digitCount > 5 && settings.allowCodeC)
+        {
+          result= BC_128_CODE_C;
+        }
+        else if(!states[position].useCodeA)
+        {
+          if(states[position].digitCount > 3 && settings.allowCodeC)
+          {
+            result= BC_128_CODE_C;
+          }
+          else if(settings.allowCodeB)
+          {
+            result= BC_128_CODE_B;
+            if(states.size() > position+1)
+            {
+              if(!states[position+1].useCodeB)
+              {
+                shift= true;
+              }
+            }
+          }
+        }
+        break;
+      }
+      case BC_128_CODE_B:
+      {
+        if(states[position].digitCount > 5 && settings.allowCodeC)
+        {
+          result= BC_128_CODE_C;
+        }
+        else if(!states[position].useCodeB)
+        {
+          if(states[position].digitCount > 3 && settings.allowCodeC)
+          {
+            result= BC_128_CODE_C;
+          }
+          else if(settings.allowCodeB)
+          {
+            result= BC_128_CODE_A;
+            if(states.size() > position+1)
+            {
+              if(!states[position+1].useCodeA)
+              {
+                shift= true;
+              }
+            }
+          }
+        }
+        break;
+      }
+      case BC_128_CODE_C:
+      {
+        if(states[position].digitCount < 2)
+        {
+          if(states[position].useCodeA && settings.allowCodeA)
+          {
+            result= BC_128_CODE_A;
+          }
+          else
+          {
+            result= BC_128_CODE_B;
+          }
+        }
+        break;
+      }
+    }
+    if(!shift)
+    {
+      code= result;
+    }
+    return result;
+  }
+  std::string createBarcodeData_(const std::string data, Barcode128Settings settings)
+  {
+    std::string validData = filterValidData(data, settings);
+    StateVector states= getStates(validData);
+    BC_128_Code code = getStartCode(states, settings);
+
+    std::string result;
+    result.reserve(validData.size() * 2 + 2);
+    CheckSum check;
+    int i= 0;
+    appendCode(result, check, getStartCode(code));
+    while(i < validData.size())
+    {
+      BC_128_Code oldCode= code;
+      BC_128_Code currentCode= getSwitchCode(states, i, code, settings);
+      if(currentCode != code)
+      {
+        appendCode(result, check, getShiftCode());
+      }
+      else if(currentCode != oldCode)
+      {
+        appendCode(result, check, getSwitchCode(currentCode));
+      }
+      appendCode(result, check, validData, i, currentCode);
+    }
+    appendCode(result, check, check.getValue());
+    appendCode(result, check, getStopCode());
+
+    return result;
+  }
+}
+
+
+namespace MASSAI
+{
+  namespace Barcode
+  {
+    Barcode128::Barcode128(Barcode128Settings settings):
+      m_settings(settings)
+    {}
+    Barcode128::~Barcode128()
+    {}
+
+    Bitmap::Bitmap Barcode128::createBarcode(const std::string& barcodeData) const
+    {
+      Bitmap::Bitmap result;
+      MASSAI::BitArray bitArray= createBarcodePixel(barcodeData, m_settings);
+      MASSAI::Bitmap::PixelRow pixel(bitArray, m_settings.height);
+      MASSAI::Bitmap::BlackAndWhiteBitmap bitmap;
+      return bitmap.createBitmap(pixel);
+    }
+    std::string Barcode128::createBarcodeData(const std::string& data) const
+    {
+      return createBarcodeData_(data, m_settings);
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/barcode39.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/barcode39.cpp
new file mode 100644
index 00000000..4c4ac627
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/barcode39.cpp
@@ -0,0 +1,285 @@
+/**
+ **************************************************************************
+ *
+ * @file barcode39.cpp
+ *
+ * Implementation for definitions in "barcode39.h".
+ *
+ **************************************************************************
+**/
+
+#include "barcode39.h"
+#include "blackAndWhiteBitmap.h"
+#include "bitarray.h"
+#include "pixelrow.h"
+#include <vector>
+
+namespace
+{
+  using MASSAI::Barcode::Barcode39Settings;
+
+  typedef int BC39_Value;
+  const BC39_Value invalidBCValue= -1;
+  enum { BC_39_PATTERN_SIZE = 9 };
+  enum
+  {
+    BC_39_PATTERN_NARROW_COUNT= 6,
+    BC_39_PATTERN_WIDE_COUNT = 3,
+    BC_39_QUIET_ZONE_WIDTH = 10
+  };
+  enum { BC_39_VALUE_COUNT = 44 };
+  enum
+  {
+    BC_39_START_VALUE = 39,
+    BC_39_STOP_VALUE = 39
+  };
+
+
+  struct BC_39_Barcode
+  {
+    BC39_Value value;
+    char pattern[BC_39_PATTERN_SIZE + 1];  // include terminating zero
+  };
+
+  const BC_39_Barcode barcode[BC_39_VALUE_COUNT] =
+  {
+    {0,  "nnnwwnwnn"},
+    {1,  "wnnwnnnnw"},
+    {2,  "nnwwnnnnw"},
+    {3,  "wnwwnnnnn"},
+    {4,  "nnnwwnnnw"},
+    {5,  "wnnwwnnnn"},
+    {6,  "nnwwwnnnn"},
+    {7,  "nnnwnnwnw"},
+    {8,  "wnnwnnwnn"},
+    {9,  "nnwwnnwnn"},
+    {10, "wnnnnwnnw"},
+    {11, "nnwnnwnnw"},
+    {12, "wnwnnwnnn"},
+    {13, "nnnnwwnnw"},
+    {14, "wnnnwwnnn"},
+    {15, "nnwnwwnnn"},
+    {16, "nnnnnwwnw"},
+    {17, "wnnnnwwnn"},
+    {18, "nnwnnwwnn"},
+    {19, "nnnnwwwnn"},
+    {20, "wnnnnnnww"},
+    {21, "nnwnnnnww"},
+    {22, "wnwnnnnwn"},
+    {23, "nnnnwnnww"},
+    {24, "wnnnwnnwn"},
+    {25, "nnwnwnnwn"},
+    {26, "nnnnnnwww"},
+    {27, "wnnnnnwwn"},
+    {28, "nnwnnnwwn"},
+    {29, "nnnnwnwwn"},
+    {30, "wwnnnnnnw"},
+    {31, "nwwnnnnnw"},
+    {32, "wwwnnnnnn"},
+    {33, "nwnnwnnnw"},
+    {34, "wwnnwnnnn"},
+    {35, "nwwnwnnnn"},
+    {36, "nwnnnnwnw"},
+    {37, "wwnnnnwnn"},
+    {38, "nwwnnnwnn"},
+    {39, "nwnnwnwnn"},
+    {40, "nwnwnwnnn"},
+    {41, "nwnwnnnwn"},
+    {42, "nwnnnwnwn"},
+    {43, "nnnwnwnwn"}
+  };
+
+  BC39_Value getValue(char in)
+  {
+    switch(in)
+    {
+      case '0': return 0;
+      case '1': return 1;
+      case '2': return 2;
+      case '3': return 3;
+      case '4': return 4;
+      case '5': return 5;
+      case '6': return 6;
+      case '7': return 7;
+      case '8': return 8;
+      case '9': return 9;
+      case 'A': return 10;
+      case 'B': return 11;
+      case 'C': return 12;
+      case 'D': return 13;
+      case 'E': return 14;
+      case 'F': return 15;
+      case 'G': return 16;
+      case 'H': return 17;
+      case 'I': return 18;
+      case 'J': return 19;
+      case 'K': return 20;
+      case 'L': return 21;
+      case 'M': return 22;
+      case 'N': return 23;
+      case 'O': return 24;
+      case 'P': return 25;
+      case 'Q': return 26;
+      case 'R': return 27;
+      case 'S': return 28;
+      case 'T': return 29;
+      case 'U': return 30;
+      case 'V': return 31;
+      case 'W': return 32;
+      case 'X': return 33;
+      case 'Y': return 34;
+      case 'Z': return 35;
+      case '-': return 36;
+      case '.': return 37;
+      case ' ': return 38;
+      case '*': return 39;
+      case '$': return 40;
+      case '/': return 41;
+      case '+': return 42;
+      case '%': return 43;
+      default:  return invalidBCValue;
+    }
+  }
+
+  MASSAI::BitArray createBarcodePixel(const std::string barcodeData, Barcode39Settings settings)
+  {
+    // calculate width
+    size_t character_width= BC_39_PATTERN_NARROW_COUNT * settings.narrowBlockSize
+                          + BC_39_PATTERN_WIDE_COUNT * settings.wideBlockSize;
+    size_t width= barcodeData.size() * character_width
+                  + (barcodeData.size() - 1) * settings.intercharacterBlockSize;
+    if(settings.useQuietZone)
+    {
+      width+= 2 * BC_39_QUIET_ZONE_WIDTH * settings.narrowBlockSize;
+    }
+
+    MASSAI::BitArray result(width);
+    size_t bitIndex= 0;
+    // quiet zone
+    if(settings.useQuietZone)
+    {
+      size_t width= BC_39_QUIET_ZONE_WIDTH * settings.narrowBlockSize;
+      result.set(bitIndex, true, width);
+      bitIndex+= width;
+    }
+    // characters
+    for(size_t i= 0; i < barcodeData.size(); i++)
+    {
+      char c= barcodeData[i];
+      if(c >= 0 && c < BC_39_VALUE_COUNT)
+      {
+        // character block
+        const BC_39_Barcode& code= barcode[c];
+        bool value= false;
+        for(size_t j= 0; j < BC_39_PATTERN_SIZE; j++)
+        {
+          size_t width= settings.narrowBlockSize;
+          if(code.pattern[j] == 'w')
+          {
+            width= settings.wideBlockSize;
+          }
+          result.set(bitIndex, value, width);
+          bitIndex+= width;
+          value= !value;
+        }
+      }
+      // intermediate block between characters
+      if(i < barcodeData.size() - 1)
+      {
+        size_t width= settings.intercharacterBlockSize;
+        result.set(bitIndex, true, width);
+        bitIndex+= width;
+      }
+    }
+    // quiet zone
+    if(settings.useQuietZone)
+    {
+      size_t width= BC_39_QUIET_ZONE_WIDTH * settings.narrowBlockSize;
+      result.set(bitIndex, true, width);
+      bitIndex+= width;
+    }
+    return result;
+  }
+  BC39_Value getStartCode()
+  {
+    return BC_39_START_VALUE;
+  }
+  BC39_Value getStopCode()
+  {
+    return BC_39_STOP_VALUE;
+  }
+  struct CheckSum
+  {
+    public:
+      CheckSum():
+        checksum(0)
+      {}
+      void addValue(int position, BC39_Value value)
+      {
+        if(position > 0)
+        {
+          checksum+= value;
+          checksum%= 43;
+        }
+      }
+      BC39_Value getValue()
+      {
+        return checksum;
+      }
+    private:
+      BC39_Value checksum;
+  };
+
+  void appendCode(std::string& result, CheckSum& check, BC39_Value value)
+  {
+    if(value != invalidBCValue)
+    {
+      check.addValue(result.size(), value);
+      result.append(1, value);
+    }
+  }
+
+  std::string createBarcodeData_(const std::string data, Barcode39Settings settings)
+  {
+    std::string result;
+    result.reserve(data.size() + 3);
+    CheckSum check;
+    appendCode(result, check, getStartCode());
+    for(int i= 0; i < data.size(); i++)
+    {
+      appendCode(result, check, getValue(data[i]));
+    }
+    if(settings.useChecksum)
+    {
+      appendCode(result, check, check.getValue());
+    }
+    appendCode(result, check, getStopCode());
+
+    return result;
+  }
+}
+
+namespace MASSAI
+{
+  namespace Barcode
+  {
+    Barcode39::Barcode39(Barcode39Settings settings):
+      m_settings(settings)
+    {}
+    Barcode39::~Barcode39()
+    {}
+
+    Bitmap::Bitmap Barcode39::createBarcode(const std::string& barcodeData) const
+    {
+      Bitmap::Bitmap result;
+      MASSAI::BitArray bitArray= createBarcodePixel(barcodeData, m_settings);
+      MASSAI::Bitmap::PixelRow pixel(bitArray, m_settings.height);
+      MASSAI::Bitmap::BlackAndWhiteBitmap bitmap;
+      return bitmap.createBitmap(pixel);
+    }
+    std::string Barcode39::createBarcodeData(const std::string& data) const
+    {
+      return createBarcodeData_(data, m_settings);
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/barcodeIndustrial2of5.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/barcodeIndustrial2of5.cpp
new file mode 100644
index 00000000..2ac7a78e
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/barcodeIndustrial2of5.cpp
@@ -0,0 +1,230 @@
+/**
+ **************************************************************************
+ *
+ * @file barcodeIndustrial2of5.cpp
+ *
+ * Implementation for definitions in "barcodeIndustrial2of5.h".
+ *
+ **************************************************************************
+**/
+
+#include "barcodeIndustrial2of5.h"
+#include "blackAndWhiteBitmap.h"
+#include "bitarray.h"
+#include "pixelrow.h"
+#include <vector>
+
+namespace
+{
+  using MASSAI::Barcode::BarcodeIndustrial2of5Settings;
+
+  typedef int BCIndustrial2of5_Value;
+  const BCIndustrial2of5_Value invalidBCValue= -1;
+  enum { BC_Industrial2of5_PATTERN_SIZE= 5 };
+  enum { BC_Industrial2of5_PATTERN_NARROW_COUNT= 3,
+         BC_Industrial2of5_PATTERN_WIDE_COUNT = 2,
+         BC_Industrial2of5_QUIET_ZONE_WIDTH = 10 };
+  enum { BC_Industrial2of5_VALUE_COUNT = 12 };
+  enum {
+    BC_Industrial2of5_START_VALUE = 10,
+    BC_Industrial2of5_STOP_VALUE = 11
+  };
+
+
+  struct BC_Industrial2of5_Barcode
+  {
+    BCIndustrial2of5_Value value;
+    char pattern[BC_Industrial2of5_PATTERN_SIZE + 1];  // include terminating zero
+  };
+
+  const BC_Industrial2of5_Barcode barcode[BC_Industrial2of5_VALUE_COUNT] =
+  {
+    { 0, "nnwwn"},
+    { 1, "wnnnw"},
+    { 2, "nwnnw"},
+    { 3, "wwnnn"},
+    { 4, "nnwnw"},
+    { 5, "wnwnn"},
+    { 6, "nwwnn"},
+    { 7, "nnnww"},
+    { 8, "wnnwn"},
+    { 9, "nwnwn"},
+    {10, "wwn"},
+    {11, "wnw"},
+  };
+
+  BCIndustrial2of5_Value getValue(char in)
+  {
+    switch(in)
+    {
+      case '0': return 0;
+      case '1': return 1;
+      case '2': return 2;
+      case '3': return 3;
+      case '4': return 4;
+      case '5': return 5;
+      case '6': return 6;
+      case '7': return 7;
+      case '8': return 8;
+      case '9': return 9;
+      default:  return invalidBCValue;
+    }
+  }
+
+  MASSAI::BitArray createBarcodePixel(const std::string barcodeData, BarcodeIndustrial2of5Settings settings)
+  {
+    // calculate width
+    size_t character_width= BC_Industrial2of5_PATTERN_NARROW_COUNT * settings.narrowBlockSize
+                          + BC_Industrial2of5_PATTERN_WIDE_COUNT * settings.wideBlockSize
+                          + BC_Industrial2of5_PATTERN_SIZE * settings.spaceBlockSize;
+    size_t width= barcodeData.size() * character_width
+                - (settings.narrowBlockSize + settings.spaceBlockSize) * 4; // start and stop are smaller
+    if(settings.useQuietZone)
+    {
+      width+= 2 * BC_Industrial2of5_QUIET_ZONE_WIDTH * settings.narrowBlockSize;
+    }
+
+    MASSAI::BitArray result(width);
+    size_t bitIndex= 0;
+    // quiet zone
+    if(settings.useQuietZone)
+    {
+      size_t width= BC_Industrial2of5_QUIET_ZONE_WIDTH * settings.narrowBlockSize;
+      result.set(bitIndex, true, width);
+      bitIndex+= width;
+    }
+    // characters
+    for(size_t i= 0; i < barcodeData.size(); i++)
+    {
+      char c= barcodeData[i];
+      if(c >= 0 && c < BC_Industrial2of5_VALUE_COUNT)
+      {
+        // character block
+        const BC_Industrial2of5_Barcode& code= barcode[c];
+        for(size_t j= 0; j < BC_Industrial2of5_PATTERN_SIZE; j++)
+        {
+          if(code.pattern[j] == 'n')
+          {
+            result.set(bitIndex, false, settings.narrowBlockSize);
+            bitIndex+= settings.narrowBlockSize;
+            result.set(bitIndex, true, settings.spaceBlockSize);
+            bitIndex+= settings.spaceBlockSize;
+          }
+          else if(code.pattern[j] == 'w')
+          {
+            result.set(bitIndex, false, settings.wideBlockSize);
+            bitIndex+= settings.wideBlockSize;
+            result.set(bitIndex, true, settings.spaceBlockSize);
+            bitIndex+= settings.spaceBlockSize;
+          }
+        }
+      }
+    }
+    // quiet zone
+    if(settings.useQuietZone)
+    {
+      size_t width= BC_Industrial2of5_QUIET_ZONE_WIDTH * settings.narrowBlockSize;
+      result.set(bitIndex, true, width);
+      bitIndex+= width;
+    }
+    return result;
+  }
+  BCIndustrial2of5_Value getStartCode()
+  {
+    return BC_Industrial2of5_START_VALUE;
+  }
+  BCIndustrial2of5_Value getStopCode()
+  {
+    return BC_Industrial2of5_STOP_VALUE;
+  }
+  struct CheckSum
+  {
+    public:
+      CheckSum():
+        odd(0),
+        even(0)
+      {}
+      void addValue(int position, BCIndustrial2of5_Value value)
+      {
+        if(position > 0)
+        {
+          if(position % 2 == 1)
+          {
+            odd+= value;
+            odd%= 10;
+          }
+          else
+          {
+            even+= value;
+            even%= 10;
+          }
+        }
+      }
+      BCIndustrial2of5_Value getValue(int position)
+      {
+        if(position % 2 == 1)
+        {
+          return 10 - (3 * even + odd) % 10;
+        }
+        else
+        {
+          return 10 - (3 * odd + even) % 10;
+        }
+      }
+    private:
+      BCIndustrial2of5_Value odd;
+      BCIndustrial2of5_Value even;
+  };
+
+  void appendCode(std::string& result, CheckSum& check, BCIndustrial2of5_Value value)
+  {
+    if(value != invalidBCValue)
+    {
+      check.addValue(result.size(), value);
+      result.append(1, value);
+    }
+  }
+  std::string createBarcodeData_(const std::string data, BarcodeIndustrial2of5Settings settings)
+  {
+    std::string result;
+    result.reserve(data.size() + 3);
+    CheckSum check;
+    appendCode(result, check, getStartCode());
+    for(int i= 0; i < data.size(); i++)
+    {
+      appendCode(result, check, getValue(data[i]));
+    }
+    if(settings.useChecksum)
+    {
+      appendCode(result, check, check.getValue(result.size()));
+    }
+    appendCode(result, check, getStopCode());
+
+    return result;
+  }
+}
+
+namespace MASSAI
+{
+  namespace Barcode
+  {
+    BarcodeIndustrial2of5::BarcodeIndustrial2of5(BarcodeIndustrial2of5Settings settings):
+      m_settings(settings)
+    {}
+    BarcodeIndustrial2of5::~BarcodeIndustrial2of5()
+    {}
+
+    Bitmap::Bitmap BarcodeIndustrial2of5::createBarcode(const std::string& barcodeData) const
+    {
+      Bitmap::Bitmap result;
+      MASSAI::BitArray bitArray= createBarcodePixel(barcodeData, m_settings);
+      MASSAI::Bitmap::PixelRow pixel(bitArray, m_settings.height);
+      MASSAI::Bitmap::BlackAndWhiteBitmap bitmap;
+      return bitmap.createBitmap(pixel);
+    }
+    std::string BarcodeIndustrial2of5::createBarcodeData(const std::string& data) const
+    {
+      return createBarcodeData_(data, m_settings);
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/bitarray.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/bitarray.cpp
new file mode 100644
index 00000000..dd566a7b
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/bitarray.cpp
@@ -0,0 +1,217 @@
+/**
+ **************************************************************************
+ *
+ * @file bitarray.cpp
+ *
+ *
+ **************************************************************************
+**/
+#include "bitarray.h"
+#include <stdexcept>
+#include <sstream>
+
+namespace
+{
+  using MASSAI::BitArray::byte;
+  class BitMask
+  {
+    public:
+      enum { BIT_COUNT= 8 };
+      BitMask()
+      {
+        byte bit_= 1;
+        byte tail_= 0;
+        for(int i= BIT_COUNT; i-->0; )
+        {
+          head[i]= ~tail_;
+          tail_= tail_ | bit_;
+          bit[i]= bit_;
+          tail[i]= tail_;
+          mask[i]= ~bit_;
+          bit_ <<= 1;
+        }
+      };
+
+      byte bit[BIT_COUNT];   // bit[i]:  bit an position i: 1 sonst 0
+      byte mask[BIT_COUNT];  // mask[i]: bit an position i: 0 sonst 1
+      byte head[BIT_COUNT];  // head[i]: bit von position 0 bis i: 1 sonst 0
+      byte tail[BIT_COUNT];  // tail[i]: bit von position i bis ende: 1 sonst 0
+  };
+  BitMask bitmask;
+
+  class BitChange
+  {
+    public:
+      virtual ~BitChange() {};
+      virtual void change(byte& data, size_t first, size_t last)
+      {
+        change(data, bitmask.tail[first] & bitmask.head[last]);
+      };
+      virtual void change(byte& data, byte mask)= 0;
+  };
+  class BitSet: public BitChange
+  {
+    public:
+      virtual void change(byte& data, byte mask)
+      {
+        data|= mask;
+      }
+  };
+  class BitFlip: public BitChange
+  {
+    public:
+      virtual void change(byte& data, byte mask)
+      {
+        data^= mask;
+      }
+  };
+  class BitReset: public BitChange
+  {
+    public:
+      virtual void change(byte& data, byte mask)
+      {
+        data&= ~mask;
+      }
+  };
+  void checkIndex(size_t index, size_t size)
+  {
+    if(index >= size)
+    {
+      std::ostringstream out;
+      out << "index: " << index << " >= size: " << size;
+      throw std::out_of_range(out.str().c_str());
+    }
+  }
+  void bitChange(byte* data, size_t size, size_t index, size_t count, BitChange& change)
+  {
+    if(count > 0)
+    {
+      size_t lastIndex= index + count - 1;
+      checkIndex(lastIndex, size);
+      size_t first = index / BitMask::BIT_COUNT;
+      size_t last = lastIndex / BitMask::BIT_COUNT;
+      size_t firstOffset= index % BitMask::BIT_COUNT;
+      size_t lastOffset= lastIndex % BitMask::BIT_COUNT;
+      if(first == last)
+      {
+        change.change(data[first], firstOffset, lastOffset);
+      }
+      else
+      {
+        change.change(data[first], firstOffset, BitMask::BIT_COUNT - 1);
+        for(size_t i = first + 1; i < last; i++)
+        {
+          change.change(data[i], 0, BitMask::BIT_COUNT - 1);
+        }
+        change.change(data[last], 0, lastOffset);
+      }
+    }
+  }
+}
+
+namespace MASSAI
+{
+  using MASSAI::text::StringBuffer;
+
+  BitArray::BitArray(const byte* data, size_t size)
+  {
+    copy(data, size, size);
+  }
+  BitArray::BitArray(size_t size):
+    m_size(size),
+    m_capacity(size),
+    m_data(StringBuffer(size))
+  {}
+  size_t BitArray::size() const
+  {
+    return m_size;
+  }
+  size_t BitArray::buffer_size() const
+  {
+    return m_data.size();
+  }
+  size_t BitArray::capacity() const
+  {
+    return m_capacity;
+  }
+  void BitArray::resize(size_t size)
+  {
+    if(size <= m_capacity)
+    {
+      m_size= size;
+    }
+    else
+    {
+      m_data.resize(getBufferSize(size));
+      m_size= size;
+      m_capacity= size;
+    }
+  }
+  void BitArray::reserve(size_t size)
+  {
+    if(size != m_capacity)
+    {
+      m_data.reserve(getBufferSize(size));
+      m_capacity= size;
+      if(size < m_size)
+      {
+        m_size= size;
+      }
+    }
+  }
+  const byte* BitArray::data() const
+  {
+    return m_data.udata();
+  }
+  byte* BitArray::data()
+  {
+    return m_data.udata();
+  }
+  const StringBuffer BitArray::buffer() const
+  {
+    return m_data;
+  }
+
+  void BitArray::flip(size_t index, size_t count)
+  {
+    BitFlip change;
+    bitChange(m_data.udata(), m_size, index, count, change);
+  }
+  void BitArray::reset(size_t index, size_t count)
+  {
+    BitReset change;
+    bitChange(m_data.udata(), m_size, index, count, change);
+  }
+  void BitArray::set(size_t index, bool value, size_t count)
+  {
+    if(value)
+    {
+      BitSet change;
+      bitChange(m_data.udata(), m_size, index, count, change);
+    }
+    else
+    {
+      BitReset change;
+      bitChange(m_data.udata(), m_size, index, count, change);
+    }
+  }
+  bool BitArray::get(size_t index)
+  {
+    checkIndex(index, m_size);
+    size_t i= index / BitMask::BIT_COUNT;
+    size_t offset = index % BitMask::BIT_COUNT;
+    return (m_data.udata()[i] & bitmask.bit[offset]) != 0;
+  }
+  void BitArray::copy(const byte* src, size_t size, size_t capacity)
+  {
+    m_capacity= capacity;
+    m_size= size;
+    size_t bufsize= getBufferSize(m_capacity);
+    size_t srcsize= getBufferSize(m_size);
+    m_data= StringBuffer(src, bufsize, srcsize);
+  }
+  size_t BitArray::getBufferSize(size_t size)
+  {
+    return (size + BitMask::BIT_COUNT - 1) / BitMask::BIT_COUNT;
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/blackAndWhiteBitmap.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/blackAndWhiteBitmap.cpp
new file mode 100644
index 00000000..166d1127
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/blackAndWhiteBitmap.cpp
@@ -0,0 +1,98 @@
+/**
+ **************************************************************************
+ *
+ * @file blackAndWhiteBitmap.cpp
+ *
+ * create bitmap
+ *
+ **************************************************************************
+**/
+
+#include "blackAndWhiteBitmap.h"
+#include <windows.h>
+
+namespace
+{
+  enum { BITMAP_BITCOUNT = 8 };
+  enum { BITMAP_BYTEALIGNMENT = 4 };
+  enum { COLOR_COUNT = 2 };
+  size_t div_up(size_t dividend, size_t divisor) // divide and round up
+  {
+    return (dividend + divisor - 1) / divisor;
+  }
+}
+
+namespace MASSAI
+{
+
+  namespace Bitmap
+  {
+    PixelRows::~PixelRows()
+    {}
+
+    BlackAndWhiteBitmap::BlackAndWhiteBitmap()
+    {}
+    BlackAndWhiteBitmap::~BlackAndWhiteBitmap()
+    {}
+    Bitmap BlackAndWhiteBitmap::createBitmap(const PixelRows& pixel)
+    {
+      Bitmap result;
+      std::string buffer;
+      result.width = pixel.getWidth();
+      result.height = pixel.getHeight();
+      const size_t row_byte_count = div_up(result.width, BITMAP_BITCOUNT);
+      const size_t aligned_row_byte_count = div_up(row_byte_count, BITMAP_BYTEALIGNMENT) * BITMAP_BYTEALIGNMENT; // byte alignment
+
+      const DWORD imagesize = aligned_row_byte_count * result.height;
+      const DWORD headersize = sizeof(BITMAPFILEHEADER)
+                       + sizeof(BITMAPINFOHEADER)
+                       + COLOR_COUNT * sizeof(RGBQUAD);
+      const DWORD totalsize = headersize + imagesize;
+
+      const BITMAPFILEHEADER fileheader =
+      {
+        'MB',      // type BM in big endian
+        totalsize, // size
+        0,         // reserved
+        0,         // reserved
+        headersize // bitmap offset in file
+      };
+
+      const BITMAPINFOHEADER infoheader =
+      {
+        sizeof(BITMAPINFOHEADER),
+        result.width,
+        result.height,
+        1,            // bitplanes
+        1,            // bitcount
+        BI_RGB,       // biCompression;
+        imagesize,    // biSizeImage;
+        0,            // biXPelsPerMeter;
+        0,            // biYPelsPerMeter;
+        0,            // biClrUsed;
+        0             // biClrImportant;
+      };
+
+      const RGBQUAD colortable[COLOR_COUNT]=
+      {
+        {0, 0, 0, 0},
+        {0xFF, 0xFF, 0xFF, 0}
+      };
+
+      buffer.reserve(totalsize);
+      buffer.append(reinterpret_cast<const char*>(&fileheader), sizeof(fileheader));
+      buffer.append(reinterpret_cast<const char*>(&infoheader), sizeof(infoheader));
+      buffer.append(reinterpret_cast<const char *>(colortable), sizeof(colortable));
+
+      size_t alignment = aligned_row_byte_count - row_byte_count;
+      for(int y= 0; y < result.height; y++)
+      {
+        buffer.append(pixel.getRow(y).data(), row_byte_count);
+        buffer.append("\0\0\0", alignment);
+      }
+      result.bmp = MASSAI::text::StringBuffer(buffer);
+      return result;
+    }
+  }
+}
+
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/localtrace.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/localtrace.cpp
new file mode 100644
index 00000000..4c930a8d
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/localtrace.cpp
@@ -0,0 +1,80 @@
+#include <windows.h>
+#include <stdio.h>
+#include "localtrace.h"
+
+namespace
+{
+  void printHeader(long lTraceLevel, const char* pszFile, short sLine)
+  {
+    SYSTEMTIME now;
+    GetLocalTime(&now);
+    printf("\n%d %02d.%02d.%04d %02d:%02d:%02d.%03d ", lTraceLevel, now.wDay, now.wMonth, now.wYear, now.wHour, now.wMinute, now.wSecond, now.wMilliseconds);
+    printf("%11.11s(%03d): ", pszFile, sLine);
+  }
+}
+
+namespace MASSAI
+{
+  namespace localtrace
+  {
+    void openTrace(const char* pszApplication)
+    {
+      wrtTrace(MajorError_HERE, "--- Trace Init --- (%s)", pszApplication);
+    }
+    void closeTrace()
+    {
+      wrtTrace(MajorError_HERE, "--- Trace Close ---");
+    }
+
+    long writeTraceText(long lTraceLevel, const char* pszFile, short sLine, const char* pszFunction, const char* pszText)
+    {
+      printHeader(lTraceLevel, pszFile, sLine);
+      printf("%s", pszText);
+      return TRC_OK;
+    }
+
+    long wrtTrace(long lTraceLevel, const char* pszFile, short sLine, const char* pszFunction, const char* pszFormat, ...)
+    {
+      va_list   arg_ptr;
+      va_start( arg_ptr, pszFormat);
+
+      printHeader(lTraceLevel, pszFile, sLine);
+      vprintf(pszFormat, arg_ptr);
+      va_end( arg_ptr);
+      return TRC_OK;
+    }
+
+    long dumpTrace(long lTraceLevel, const char* pszFile, short sLine, const char* pszFunction, long lDumpSize, const char* pDump)
+    {
+      printHeader(lTraceLevel, pszFile, sLine);
+      printf("\n");
+      for(long i = 0; i < lDumpSize; i += 16)
+      {
+        printf("[%04x,%04d] ", i, i);
+        for(long j = 0; j < 16 && (i+j) < lDumpSize; j++)
+        {
+          if(j == 8)
+          {
+            printf("- ");
+          }
+          printf("%02x ",((unsigned char*)pDump)[i+j]);
+        }
+
+        while(j < 16)
+        {
+          if(j == 8)
+            printf("     ");
+          else
+            printf("   ");
+          j++;
+        }
+
+        for(j = 0; j < 16 && (i+j) < lDumpSize; j++)
+          printf("%c", (pDump[i+j] >= ' ') ? pDump[i+j]: '.');
+
+        printf("\n");
+      }
+      return TRC_OK;
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/pixelrow.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/pixelrow.cpp
new file mode 100644
index 00000000..5710fe95
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/pixelrow.cpp
@@ -0,0 +1,36 @@
+/**
+ **************************************************************************
+ *
+ * @file pxielrow.h
+ *
+ * Implementation for definitions in "pixelrow.h".
+ *
+ **************************************************************************
+**/
+
+#include "pixelrow.h"
+
+namespace MASSAI
+{
+  namespace Bitmap
+  {
+    PixelRow::PixelRow(const MASSAI::BitArray& barcodeData, unsigned int height):
+      m_height(height)
+    {
+      m_width= barcodeData.size();
+      m_row= barcodeData.buffer();
+    }
+    unsigned int PixelRow::getWidth() const
+    {
+      return m_width;
+    }
+    unsigned int PixelRow::getHeight() const
+    {
+      return m_height;
+    }
+    const MASSAI::text::StringBuffer& PixelRow::getRow(size_t y) const
+    {
+      return m_row;
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/stringbuffer.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/stringbuffer.cpp
new file mode 100644
index 00000000..10b3fcb1
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/stringbuffer.cpp
@@ -0,0 +1,235 @@
+/**
+ **************************************************************************
+ *
+ * @file stringbuffer.cpp
+ *
+ *
+ *
+ * Copyright (c) 2008 MATERNA Information & Communications
+ *
+ **************************************************************************
+**/
+
+#include <string>
+#include "stringbuffer.h"
+
+namespace MASSAI
+{
+  namespace text
+  {
+    StringBuffer::StringBuffer()
+    {
+      init(0, 0, 0);
+    }
+    StringBuffer::StringBuffer(size_t size)
+    {
+      init(0, size, size);
+    }
+    StringBuffer::StringBuffer(size_t size, size_t capacity)
+    {
+      init(0, size, capacity);
+    }
+    StringBuffer::StringBuffer(const StringBuffer& assign)
+    {
+      init(assign.data(), assign.size(), assign.capacity());
+    }
+    StringBuffer::StringBuffer(const StringBuffer& assign, size_t capacity)
+    {
+      init(assign.data(), assign.size(), capacity);
+    }
+    StringBuffer::StringBuffer(const char* assign)
+    {
+      if(assign != 0)
+      {
+        size_t size= strlen(assign) + 1;
+        init(assign, size, size);  // one extra char for terminating zero
+      }
+      else
+      {
+        init(0, 0, 0);
+      }
+    }
+    StringBuffer::StringBuffer(const char* assign, size_t size)
+    {
+      init(assign, size, size);
+    }
+    StringBuffer::StringBuffer(const char* assign, size_t size, size_t capacity)
+    {
+      init(assign, size, capacity);
+    }
+    StringBuffer::StringBuffer(const unsigned char* uassign)
+    {
+      const char* assign= reinterpret_cast<const char*>(uassign);
+      if(assign != 0)
+      {
+        size_t size= strlen(assign) + 1;
+        init(assign, size, size);  // one extra char for terminating zero
+      }
+      else
+      {
+        init(0, 0, 0);
+      }
+    }
+    StringBuffer::StringBuffer(const unsigned char* uassign, size_t size)
+    {
+      const char* assign= reinterpret_cast<const char*>(uassign);
+      init(assign, size, size);
+    }
+    StringBuffer::StringBuffer(const unsigned char* uassign, size_t size, size_t capacity)
+    {
+      const char* assign= reinterpret_cast<const char*>(uassign);
+      init(assign, size, capacity);
+    }
+    StringBuffer::StringBuffer(const signed char* sassign)
+    {
+      const char* assign= reinterpret_cast<const char*>(sassign);
+      if(assign != 0)
+      {
+        size_t size= strlen(assign) + 1;
+        init(assign, size, size);  // one extra char for terminating zero
+      }
+      else
+      {
+        init(0, 0, 0);
+      }
+    }
+    StringBuffer::StringBuffer(const signed char* sassign, size_t size)
+    {
+      const char* assign= reinterpret_cast<const char*>(sassign);
+      init(assign, size, size);
+    }
+    StringBuffer::StringBuffer(const signed char* sassign, size_t size, size_t capacity)
+    {
+      const char* assign= reinterpret_cast<const char*>(sassign);
+      init(assign, size, capacity);
+    }
+    StringBuffer::StringBuffer(const std::string& assign)
+    {
+      size_t size= assign.size();
+      init(assign.data(), size, size);
+    }
+    StringBuffer::StringBuffer(const std::string& assign, size_t capacity)
+    {
+      size_t size= assign.size();
+      init(assign.data(), size, capacity);
+    }
+    StringBuffer& StringBuffer::operator= (const StringBuffer& assign)
+    {
+      if(&assign != this)
+      {
+        finit();
+        init(assign.data(), assign.size(), assign.capacity());
+      }
+      return *this;
+    }
+    StringBuffer::~StringBuffer()
+    {
+      finit();
+    }
+    void StringBuffer::init(const char* pBuf, size_t size, size_t capacity)
+    {
+      m_size= size;
+      if(size > capacity)
+      {
+        m_capacity= size;
+      }
+      else
+      {
+        m_capacity= capacity;
+      }
+      if(m_size == 0)
+      {
+        m_pBuf= 0;
+      }
+      else
+      {
+        m_pBuf= new char[m_capacity];
+        if(pBuf != 0)
+        {
+          memcpy(m_pBuf, pBuf, m_size);
+          if(m_capacity > m_size)
+          {
+            memset(m_pBuf, 0, m_capacity - m_size);
+          }
+        }
+        else
+        {
+          memset(m_pBuf, 0, m_capacity);
+        }
+      }
+    }
+    void StringBuffer::finit()
+    {
+      free(m_pBuf);
+      m_size= 0;
+      m_capacity= 0;
+    }
+    void StringBuffer::free(char*& pBuf)
+    {
+      if(pBuf != 0)
+      {
+        delete[] pBuf;
+        pBuf= 0;
+      }
+    }
+    size_t StringBuffer::size() const
+    {
+      return m_size;
+    }
+    size_t StringBuffer::capacity() const
+    {
+      return m_capacity;
+    }
+    void StringBuffer::resize(size_t size)
+    {
+      if(size <= m_capacity)
+      {
+        m_size= size;
+      }
+      else
+      {
+        char* swap= m_pBuf;
+        init(swap, m_size, size);
+        m_size= size;
+        free(swap);
+      }
+    }
+    void StringBuffer::reserve(size_t size)
+    {
+      if(size != m_capacity)
+      {
+        char* swap= m_pBuf;
+        if(size < m_size)
+        {
+          m_size= size;
+        }
+        init(swap, m_size, size);
+        free(swap);
+      }
+    }
+    char* StringBuffer::data()
+    {
+      return m_pBuf;
+    }
+    const char* StringBuffer::data() const
+    {
+      return m_pBuf;
+    }
+    unsigned char* StringBuffer::udata()
+    {
+      return reinterpret_cast<unsigned char*>(m_pBuf);
+    }
+    const unsigned char* StringBuffer::udata() const
+    {
+      return reinterpret_cast<const unsigned char*>(m_pBuf);
+    }
+    signed char* StringBuffer::sdata()
+    {
+      return reinterpret_cast<signed char*>(m_pBuf);
+    }
+    const signed char* StringBuffer::sdata() const
+    {
+      return reinterpret_cast<const signed char*>(m_pBuf);
+    }
+  }
+}
-- 
2.41.0.windows.1

