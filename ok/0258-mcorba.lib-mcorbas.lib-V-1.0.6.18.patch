From 9d9ee902b39cdf322bd5798ac5f94607a4a607a0 Mon Sep 17 00:00:00 2001
From: tstegema <tstegema@90b65887-3827-0410-9a23-83215b262276>
Date: Fri, 23 Mar 2012 15:45:52 +0000
Subject: [PATCH 0258/1076] mcorba.lib, mcorbas.lib V 1.0.6.18

Mantis 0018942: mCorba: creation order of servant orb and client orb and synchronization problems

environment settings
  CORBA_AUTOPOLL_ENABLE     enable auto polling, client only
  CORBA_AUTOPOLL_DISABLE    disable auto polling, client only
  CORBA_AUTOPOLL_TIMEOUT    poll timeout in ms, default 60000 ms, client only
  CORBA_INVOCATION_TIMEOUT  default invocation timeout in ms, default 60000ms
  ORBENDPOINT_PORT          default orb endpoint port
  CORBA_NUMERIC_ORB         use ip instead of hostname in ior
  CORBA_ENABLE_LOGGING      enable ORB logging
  CORBA_NO_NESTED_CALLS     disable nested calls, do not use the threads in client calls for processing servant calls

logging
  TAO ORB logging is written to stderr
  massaiCORBA logging is written with OutputDebugString

localhost
  cfg: empty host in configuration (CORBA.SERVANTS.*) is mapped to localhost
  servant creation: localhost is mapped to 0.0.0.0
  client connecting servant: localhost is mapped to local hostname
  to bind and connect to 127.0.0.1 use 127.0.0.1 for hostname

multiple network interfaces
  the hostname in the ior is set to the local hostname, if the servant is listening on all interfaces (interface = localhost or no interface)
  to use multiple hostnames in the ior use the interface = 0.0.0.0

multiple orbs
  every module creates his own orbs (avoid interaction between orb creation in dlls and executable)
  for every ORBEndpoint a new orb is created
  clients use the first servant orb or an own client orb, if no servant orb is created
  for implicit activation the first servant orb is used
     warning: this is not module independent, all modules use the same orb for implicit activation
              the first servant orb of the module that creates its first servant orb at last is used
              => avoid creating servants in dlls



git-svn-id: svn://localhost/SelfServiceCommon/trunk@311 90b65887-3827-0410-9a23-83215b262276
---
 .../generic/fsm/mStateMachineQueue.hpp        |    3 +-
 .../generic/massaiCorba/corbaclnt.h           |  524 +++-----
 .../generic/massaiCorba/corbaclnt.hpp         |  155 +++
 .../generic/massaiCorba/corbasrvr.h           |  520 +++-----
 .../generic/massaiCorba/corbasrvr.hpp         |  111 ++
 SelfServiceCommon/Interfaces/inc/corbaorbEx.h |    9 -
 .../Interfaces/inc/massaiCorba/corbacfg.h     |   15 +-
 .../inc/massaiCorba/corbaclntbase.h           |   87 ++
 .../Interfaces/inc/massaiCorba/corbaorb.h     |  128 +-
 .../Interfaces/inc/massaiCorba/corbaorbEx.h   |  129 --
 .../Interfaces/inc/massaiCorba/corbapoll.h    |   10 +-
 .../inc/massaiCorba/corbasrvrbase.h           |   97 ++
 .../Interfaces/inc/massaiCorba/orbIncDefs.h   |   60 +-
 .../Massai/cpp/MassaiCorba/dll/makefile.mak   |   17 +-
 .../Massai/cpp/MassaiCorba/inc/envSettings.h  |   26 +
 .../cpp/MassaiCorba/inc/massaiCORBA_def.h     |   46 +-
 .../Massai/cpp/MassaiCorba/inc/orbContainer.h |  108 ++
 .../Massai/cpp/MassaiCorba/inc/orbimpl.h      |   28 +
 .../Massai/cpp/MassaiCorba/inc/tools.h        |   34 +
 .../Massai/cpp/MassaiCorba/inc/tracedef.h     |   33 +-
 .../Massai/cpp/MassaiCorba/src/Realtime.cpp   |  181 +--
 .../Massai/cpp/MassaiCorba/src/corbacfg.cpp   |  302 ++---
 .../Massai/cpp/MassaiCorba/src/corbaclnt.cpp  |  132 +-
 .../Massai/cpp/MassaiCorba/src/corbaorb.cpp   | 1082 ++++-------------
 .../Massai/cpp/MassaiCorba/src/corbapoll.cpp  |   42 +-
 .../Massai/cpp/MassaiCorba/src/corbasrvr.cpp  |  201 ++-
 .../cpp/MassaiCorba/src/envSettings.cpp       |   74 ++
 .../cpp/MassaiCorba/src/orbContainer.cpp      |  277 +++++
 .../Massai/cpp/MassaiCorba/src/orbimpl.cpp    |    3 +
 .../cpp/MassaiCorba/src/orbimpl_tao.cpp       |  306 +++++
 .../Massai/cpp/MassaiCorba/src/tools.cpp      |   90 ++
 .../Massai/cpp/MassaiCorba/src/trace.cpp      |  300 ++---
 .../cpp/MassaiCorba/static/makefile.mak       |   16 +-
 .../MassaiCorba/test/inc/testcase_common.h    |   49 +
 .../Massai/cpp/MassaiCorba/test/makefile.mak  |   78 +-
 .../Massai/cpp/MassaiCorba/test/src/cbclt.cpp |  105 --
 .../Massai/cpp/MassaiCorba/test/src/cbsrv.cpp |   70 --
 .../Massai/cpp/MassaiCorba/test/src/stclt.cpp |   25 -
 .../Massai/cpp/MassaiCorba/test/src/tclt.cpp  |  108 --
 .../MassaiCorba/test/src/testcase1_clnt1.cpp  |   98 ++
 .../MassaiCorba/test/src/testcase2_clnt1.cpp  |   92 ++
 .../MassaiCorba/test/src/testcase2_clnt2.cpp  |  181 +++
 .../MassaiCorba/test/src/testcase3_clnt1.cpp  |  119 ++
 .../MassaiCorba/test/src/testcase_common.cpp  |  135 ++
 .../MassaiCorba/test/src/testcase_srv1.cpp    |   81 ++
 .../cpp/MassaiCorba/test/src/testcases.txt    |   27 +
 .../cpp/MassaiCorba/test/src/testclnt.cpp     |  190 ---
 .../cpp/MassaiCorba/test/src/testsrvr.cpp     |  318 -----
 .../Massai/cpp/MassaiCorba/test/src/tsrv.cpp  |  118 --
 .../Massai/cpp/Tools/src/TraceSystem.cpp      |    2 +-
 50 files changed, 3509 insertions(+), 3433 deletions(-)
 create mode 100644 SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt.hpp
 create mode 100644 SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr.hpp
 delete mode 100644 SelfServiceCommon/Interfaces/inc/corbaorbEx.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/massaiCorba/corbaclntbase.h
 delete mode 100644 SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorbEx.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/massaiCorba/corbasrvrbase.h
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba/inc/envSettings.h
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba/inc/orbContainer.h
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba/inc/orbimpl.h
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba/inc/tools.h
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba/src/envSettings.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba/src/orbContainer.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba/src/orbimpl.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba/src/orbimpl_tao.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba/src/tools.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba/test/inc/testcase_common.h
 delete mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/cbclt.cpp
 delete mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/cbsrv.cpp
 delete mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/stclt.cpp
 delete mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/tclt.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcase1_clnt1.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcase2_clnt1.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcase2_clnt2.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcase3_clnt1.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcase_common.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcase_srv1.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcases.txt
 delete mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testclnt.cpp
 delete mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testsrvr.cpp
 delete mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/tsrv.cpp

diff --git a/SelfServiceCommon/Interfaces/generic/fsm/mStateMachineQueue.hpp b/SelfServiceCommon/Interfaces/generic/fsm/mStateMachineQueue.hpp
index 8d270c0c..19e82e65 100644
--- a/SelfServiceCommon/Interfaces/generic/fsm/mStateMachineQueue.hpp
+++ b/SelfServiceCommon/Interfaces/generic/fsm/mStateMachineQueue.hpp
@@ -284,7 +284,8 @@ namespace StateMachine
          M_Active( true ),
          M_EventQueue( QSiz ),
          M_QueueXH( false ),
-         M_TMutex()
+         M_TMutex(),
+         M_WorkerStackTraced( false )
       {
          start();
       }
diff --git a/SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt.h b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt.h
index d2c4242d..14627c69 100644
--- a/SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt.h
+++ b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt.h
@@ -1,14 +1,4 @@
-/**
- *  @file      corbaclnt.h
- *
- *  @brief     Header file for CORBA client classes.
- *
- *  @date      16.12.2003
- *
- *  @author    Materna Information & Communications (AGe)
- *
- ************************************************************************/
-
+// Interface for CORBA client
 #ifndef CORBACLNT_H
 #define CORBACLNT_H
 
@@ -17,339 +7,201 @@
 #endif
 
 #include <iostream>
-#include <string>
-
-#include "massaiCorba/corbaorb.h"
-#include "massaiCorba/corbacfg.h"
-#include "massaiCorba/corbapoll.h"
-
-/** Template class for the implementation of simple CORBA clients that
- *  don't need callback functionality.
- */
+#include "massaiCorba/corbaclnt.hpp"
 
-template<class T> class corbaClient : public corbaOrb, public corbaPoll
+template<class T>
+void corbaClient<T>::narrow(CORBA::Object_var obj)
 {
-protected:
-
-    T *remoteServant;
-
-private:
-
-    CORBA::Object_var obj;
-
-    std::string m_ior;
-
-    long connect()
-    {
-      long rc = 0;
-
-      try
-      {
-
 #if defined (CHECKED_NARROW)
-
-        // TAO 1.4 should have fixed this ...
-
-        remoteServant = T::_narrow(obj);
+  // TAO 1.4 should have fixed this ...
+  remoteServant = T::_narrow(obj);
 #else
-
-        // less memory consuming for TAO 1.2
-
-        remoteServant = T::_unchecked_narrow(obj);
+  // less memory consuming for TAO 1.2
+  remoteServant = T::_unchecked_narrow(obj);
 #endif
-      }
-      catch(CORBA::SystemException& e)
-      {
-        printf("%s",e._message());
-        rc = -1;
-      }
-
-      return(rc);
-    }
-
-public:
-
-    bool poll()
-    {
-      bool result= false;
-      CORBA::PolicyList_var inconsistent_policies;
-      if(remoteServant->_validate_connection(inconsistent_policies))
-      {
-         result= true;
-      }
-      return result;
-    }
-
-    /** Returns the IOR of this object */
-
-    const char *ior()
-    {
-      if(m_ior.size() == 0)
-      {
-        CORBA::String_var ior_= orb()->object_to_string(obj);
-        m_ior= ior_.in();
-      }
-      return m_ior.c_str();
-    }
-
-    /** Returns a reference to the servant proxy */
-
-    T* proxy() { return(remoteServant); }
-
-    /** Class constructor
-        @param pszIOR_or_ServantName - Valid CORBA IOR or CORBALOC address
-
-        @note If the given parameter does not specify a valid IOR or CORBALOC address
-              the host address and port is read from the configuration. This allows
-              to contact servants via its names only.
-
-              \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b host:port
-     */
-
-    corbaClient(const char *pszIOR_or_ServantName, long lCORBA_Invocation_Timeout = -1, AutoPolling autopoll= AUTO_POLL_OFF)
-    {
-      long err;
-
-      remoteServant = NULL;
-
-#if defined(_TAO_1_4_) || defined (_TAO_1_5_)
-      if( lCORBA_Invocation_Timeout > 0)
-      {
-          // override the Invocation Timeout for this client
-          //
-          SetInvocationTimeout(  orb(),            ///< the CORBA ORB
-                                 lCORBA_Invocation_Timeout,
-                                 true             ///< true: for thread, false: for ORB
-                              );
-      }
-#endif // _TAO_1_4_
-      bool local= false;
-      std::string name;
-      if((err = createObject(pszIOR_or_ServantName,obj, local, name)) == 0)
-      {
-        pollingName(name);
-        err = connect();
-
-        if(err == 0)
-        {
-          run();
-          startAutoPolling(local, autopoll);
-        }
-      }
-    }
-
-    /** Class constructor
-        @param pszInitialService - CORBA initial service, like Naming Service to connect to
-        @param pszIOR - CORBA IOR to connect to
-        @attention Not yet implememted
-     */
-
-    corbaClient(const char *pszInitialService, const char *pszIOR, long lCORBA_Invocation_Timeout = -1, AutoPolling autopoll= AUTO_POLL_OFF)
-    {
-#if defined(_TAO_1_4_) || defined (_TAO_1_5_)
-      if( lCORBA_Invocation_Timeout > 0)
-      {
-          // override the Invocation Timeout for this client
-          //
-          SetInvocationTimeout(  orb(),            ///< the CORBA ORB
-                                 lCORBA_Invocation_Timeout,
-                                 true             ///< true: for thread, false: for ORB
-                              );
-      }
-#endif //_TAO_1_4_
-
-      // rest remains uncoded
-    }
-
-    /** Class constructor
-        @param pszHost - IP address of the remote host to connect to
-        @param port - The port on the remote host to connect to
-        @param pszServant - Name of the remote servant to connect to
-     */
-
-    corbaClient(const char *pszHost, long port, const char* pszServant, long lCORBA_Invocation_Timeout = -1, AutoPolling autopoll= AUTO_POLL_OFF)
-    {
-      long err;
-
-      remoteServant = NULL;
-
-#if defined(_TAO_1_4_) || defined (_TAO_1_5_)
-      if( lCORBA_Invocation_Timeout > 0)
-      {
-          // override the Invocation Timeout for this client
-          //
-          SetInvocationTimeout(  orb(),            ///< the CORBA ORB
-                                 lCORBA_Invocation_Timeout,
-                                 true             ///< true: for thread, false: for ORB
-                              );
-      }
-#endif // _TAO_1_4_
-
-      bool local= false;
-      std::string name;
-      if((err = createObject(pszHost,port,pszServant,obj, local, name)) == 0)
-      {
-        pollingName(name);
-        err = connect();
-
-        if(err == 0)
-        {
-          run();
-          startAutoPolling(local, autopoll);
-        }
-      }
-    }
+}
 
-    /** Class constructor
-        @param Host - IP address of the remote host to connect to
-        @param port - The port on the remote host to connect to
-        @param pszServant - Name of the remote servant to connect to
-     */
-
-    corbaClient(std::string const & Host, long port, const char* pszServant, long lCORBA_Invocation_Timeout = -1, AutoPolling autopoll= AUTO_POLL_OFF)
-    {
-      long err;
-
-      remoteServant = NULL;
-
-#if defined(_TAO_1_4_) || defined (_TAO_1_5_)
-      if( lCORBA_Invocation_Timeout > 0)
-      {
-          // override the Invocation Timeout for this client
-          //
-          SetInvocationTimeout(  orb(),            ///< the CORBA ORB
-                                 lCORBA_Invocation_Timeout,
-                                 true             ///< true: for thread, false: for ORB
-                              );
-      }
-#endif // _TAO_1_4_
-
-      bool local= false;
-      std::string name;
-      if((err = createObject(Host.c_str(),port,pszServant,obj, local, name)) == 0)
-      {
-        pollingName(name);
-        err = connect();
-
-        if(err == 0)
-        {
-          run();
-          startAutoPolling(local, autopoll);
-        }
-      }
-    }
-
-    /** Class constructor
-        @param servant - duplicated in constructor, released in destructor
-     */
-
-    corbaClient(T* servant, long lCORBA_Invocation_Timeout = -1, AutoPolling autopoll= AUTO_POLL_OFF)
-    {
-      long err;
-
-      remoteServant = NULL;
-
-#if defined(_TAO_1_4_) || defined (_TAO_1_5_)
-      if( lCORBA_Invocation_Timeout > 0)
-      {
-          // override the Invocation Timeout for this client
-          //
-          SetInvocationTimeout(  orb(),            ///< the CORBA ORB
-                                 lCORBA_Invocation_Timeout,
-                                 true             ///< true: for thread, false: for ORB
-                              );
-      }
-#endif // _TAO_1_4_
-
-      remoteServant = servant->_duplicate(servant);
-      obj= remoteServant->_duplicate(remoteServant);
-      pollingName(ior());
-      run();
-      startAutoPolling(false, autopoll);
-    }
-
-
-    /** Class destructor */
-
-   ~corbaClient()
-    {
-      stopPolling();
-      if(remoteServant)
-      {
-        CORBA::release(remoteServant);
-        remoteServant = NULL;
-      }
-    }
-};
-
-/** Template class for the implementation of simple CORBA clients that
- *  don't need callback functionality.
- */
-
-template<class T> class corbaCallbackClient : public corbaClient <T>
+template<class T>
+bool corbaClient<T>::poll()
 {
-public:
-
-    /** Class constructor
-        @param pszIOR_or_ServantName - Valid CORBA IOR or CORBALOC address
-
-        @note If the given parameter does not specify a valid IOR or CORBALOC address
-              the host address and port is read from the configuration. This allows
-              to contact servants via its names only.
-
-              \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b host:port
-     */
-
-    corbaCallbackClient(const char *pszIOR_or_ServantName, long lCORBA_Invocation_Timeout = -1, AutoPolling autopoll= AUTO_POLL_OFF):
-      corbaClient<T> (pszIOR_or_ServantName, lCORBA_Invocation_Timeout, autopoll)
-    {
-       createRootPOA();
-
-       long rc = activateCallback();
-    }
-
-    /** Class constructor
-        @param pszHost - IP address of the remote host to connect to
-        @param port - The port on the remote host to connect to
-        @param pszServant - Name of the remote servant to connect to
-     */
-
-    corbaCallbackClient(const char *pszHost,
-                        const long  port,
-                        const char *pszServant,
-                        long lCORBA_Invocation_Timeout = -1,
-                        AutoPolling autopoll= AUTO_POLL_OFF
-                       ) : corbaClient<T> (pszHost, port, pszServant, lCORBA_Invocation_Timeout, autopoll)
-    {
-       createRootPOA();
-
-       long rc = activateCallback();
-    }
-
-    /** Class constructor
-        @param Host - IP address of the remote host to connect to
-        @param port - The port on the remote host to connect to
-        @param pszServant - Name of the remote servant to connect to
-     */
-
-    corbaCallbackClient(std::string const & Host,
-                        const long  port,
-                        const char *pszServant,
-                        long lCORBA_Invocation_Timeout = -1,
-                        AutoPolling autopoll= AUTO_POLL_OFF
-                       ) : corbaClient<T> (Host, port, pszServant, lCORBA_Invocation_Timeout, autopoll)
-    {
-       createRootPOA();
+  bool result= false;
+  CORBA::PolicyList_var inconsistent_policies;
+  if(remoteServant->_validate_connection(inconsistent_policies))
+  {
+    result= true;
+  }
+  return result;
+}
+
+/** Returns a reference to the servant proxy */
+template<class T>
+T* corbaClient<T>::proxy()
+{
+  return remoteServant;
+}
+
+/** Class constructor
+    @param pszIOR_or_ServantName - Valid CORBA IOR or CORBALOC address
+
+    @note If the given parameter does not specify a valid IOR or CORBALOC address
+          the host address and port is read from the configuration. This allows
+          to contact servants via its names only.
+
+          \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b host:port
+*/
+template<class T>
+corbaClient<T>::corbaClient
+(
+  const char* pszIOR_or_ServantName,
+  long invocationTimeout,
+  AutoPolling autopoll
+): remoteServant(0)
+{
+ init(pszIOR_or_ServantName, invocationTimeout, autopoll);
+}
+
+/** Class constructor
+    @param pszInitialService - CORBA initial service, like Naming Service to connect to
+    @param pszIOR - CORBA IOR to connect to
+    @attention Not yet implememted
+*/
+template<class T>
+corbaClient<T>::corbaClient
+(
+  const char* pszInitialService,
+  const char* pszIOR,
+  long invocationTimeout,
+  AutoPolling autopoll
+): remoteServant(0)
+{
+  init(pszInitialService, pszIOR, invocationTimeout, autopoll);
+}
+
+/** Class constructor
+    @param pszHost - IP address of the remote host to connect to
+    @param port - The port on the remote host to connect to
+    @param pszServant - Name of the remote servant to connect to
+*/
+template<class T>
+corbaClient<T>::corbaClient
+(
+  const char* pszHost,
+  long port,
+  const char* pszServant,
+  long invocationTimeout,
+  AutoPolling autopoll
+): remoteServant(0)
+{
+  init(pszHost, port, pszServant, invocationTimeout, autopoll);
+}
+
+/** Class constructor
+    @param Host - IP address of the remote host to connect to
+    @param port - The port on the remote host to connect to
+    @param pszServant - Name of the remote servant to connect to
+*/
+template<class T>
+corbaClient<T>::corbaClient
+(
+  const std::string& host,
+  long port,
+  const char* pszServant,
+  long invocationTimeout,
+  AutoPolling autopoll
+): remoteServant(0)
+{
+  init(host.c_str(), port, pszServant, invocationTimeout, autopoll);
+}
+
+/** Class constructor
+    @param servant - duplicated in constructor, released in destructor
+*/
+template<class T>
+corbaClient<T>::corbaClient
+(
+  T* servant,
+  long invocationTimeout,
+  AutoPolling autopoll
+): remoteServant(servant->_duplicate(servant))
+{
+  setTimeout(invocationTimeout);
+  obj= remoteServant->_duplicate(remoteServant);
+  startProcessing(ior(), false, false, autopoll);
+}
 
-       long rc = activateCallback();
-    }
 
-    /** Class destructor */
+/** Class destructor */
+template<class T>
+corbaClient<T>::~corbaClient()
+{
+  stopPolling();
+  if(remoteServant)
+  {
+    CORBA::release(remoteServant);
+    remoteServant = 0;
+  }
+}
+
+
+/** Class constructor
+    @param pszIOR_or_ServantName - Valid CORBA IOR or CORBALOC address
+
+    @note If the given parameter does not specify a valid IOR or CORBALOC address
+          the host address and port is read from the configuration. This allows
+          to contact servants via its names only.
+
+          \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b host:port
+*/
+template<class T>
+corbaCallbackClient<T>::corbaCallbackClient
+(
+  const char* pszIOR_or_ServantName,
+  long invocationTimeout,
+  AutoPolling autopoll
+): corbaClient<T>(pszIOR_or_ServantName, invocationTimeout, autopoll)
+{
+  initCallbackClient();
+}
+
+/** Class constructor
+    @param pszHost - IP address of the remote host to connect to
+    @param port - The port on the remote host to connect to
+    @param pszServant - Name of the remote servant to connect to
+*/
+template<class T>
+corbaCallbackClient<T>::corbaCallbackClient
+(
+  const char* pszHost,
+  long  port,
+  const char* pszServant,
+  long invocationTimeout,
+  AutoPolling autopoll
+): corbaClient<T> (pszHost, port, pszServant, invocationTimeout, autopoll)
+{
+  initCallbackClient();
+}
+
+/** Class constructor
+    @param Host - IP address of the remote host to connect to
+    @param port - The port on the remote host to connect to
+    @param pszServant - Name of the remote servant to connect to
+*/
+template<class T>
+corbaCallbackClient<T>::corbaCallbackClient
+(
+  const std::string& Host,
+  long  port,
+  const char* pszServant,
+  long invocationTimeout,
+  AutoPolling autopoll
+): corbaClient<T> (Host.c_str(), port, pszServant, invocationTimeout, autopoll)
+{
+  initCallbackClient();
+}
 
-   ~corbaCallbackClient()
-   {
-      // everything is done in ~corbaClient() ...
-   }
-};
+/** Class destructor */
+template<class T>
+corbaCallbackClient<T>::~corbaCallbackClient()
+{}
 
-#endif //CORBACLNT_H
+#endif
diff --git a/SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt.hpp b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt.hpp
new file mode 100644
index 00000000..ff6cbab1
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt.hpp
@@ -0,0 +1,155 @@
+// Interface for CORBA client
+#ifndef CORBACLNT_HPP
+#define CORBACLNT_HPP
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include <string>
+
+#include "massaiCorba/corbaorb.h"
+#include "massaiCorba/corbaclntbase.h"
+#include "massaiCorba/corbacfg.h"
+#include "massaiCorba/corbapoll.h"
+
+/** Template class for the implementation of simple CORBA clients that
+    don't need callback functionality.
+*/
+template<class T> class corbaClient: public massaiCorba::corbaClientBase
+{
+  public:
+    bool poll();
+    /** Returns a reference to the servant proxy */
+    T* proxy();
+
+    /** Class constructor
+        @param pszIOR_or_ServantName - Valid CORBA IOR or CORBALOC address
+
+        @note If the given parameter does not specify a valid IOR or CORBALOC address
+              the host address and port is read from the configuration. This allows
+              to contact servants via its names only.
+
+              \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b host:port
+    */
+    corbaClient
+    (
+      const char* pszIOR_or_ServantName,
+      long invocationTimeout = -1,
+      AutoPolling autopoll = AUTO_POLL_OFF
+    );
+
+    /** Class constructor
+        @param pszInitialService - CORBA initial service, like Naming Service to connect to
+        @param pszIOR - CORBA IOR to connect to
+        @attention Not yet implememted
+    */
+    corbaClient
+    (
+      const char* pszInitialService,
+      const char* pszIOR,
+      long invocationTimeout = -1,
+      AutoPolling autopoll = AUTO_POLL_OFF
+    );
+
+    /** Class constructor
+        @param pszHost - IP address of the remote host to connect to
+        @param port - The port on the remote host to connect to
+        @param pszServant - Name of the remote servant to connect to
+    */
+    corbaClient
+    (
+      const char* pszHost,
+      long port,
+      const char* pszServant,
+      long invocationTimeout = -1,
+      AutoPolling autopoll = AUTO_POLL_OFF
+    );
+
+    /** Class constructor
+        @param Host - IP address of the remote host to connect to
+        @param port - The port on the remote host to connect to
+        @param pszServant - Name of the remote servant to connect to
+    */
+    corbaClient
+    (
+      const std::string& host,
+      long port,
+      const char* pszServant,
+      long invocationTimeout = -1,
+      AutoPolling autopoll = AUTO_POLL_OFF
+    );
+
+    /** Class constructor
+        @param servant - duplicated in constructor, released in destructor
+    */
+    corbaClient
+    (
+      T* servant,
+      long invocationTimeout = -1,
+      AutoPolling autopoll = AUTO_POLL_OFF
+    );
+
+    ~corbaClient();
+
+  private:
+    T* remoteServant;
+
+    void narrow(CORBA::Object_var obj);
+};
+
+/** Template class for the implementation of simple CORBA clients that
+ *  don't need callback functionality.
+ */
+template<class T> class corbaCallbackClient : public corbaClient<T>
+{
+  public:
+    /** Class constructor
+        @param pszIOR_or_ServantName - Valid CORBA IOR or CORBALOC address
+
+        @note If the given parameter does not specify a valid IOR or CORBALOC address
+              the host address and port is read from the configuration. This allows
+              to contact servants via its names only.
+
+              \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b host:port
+     */
+    corbaCallbackClient
+    (
+      const char* pszIOR_or_ServantName,
+      long invocationTimeout = -1,
+      AutoPolling autopoll = AUTO_POLL_OFF
+    );
+
+    /** Class constructor
+        @param pszHost - IP address of the remote host to connect to
+        @param port - The port on the remote host to connect to
+        @param pszServant - Name of the remote servant to connect to
+     */
+    corbaCallbackClient
+    (
+      const char* pszHost,
+      long  port,
+      const char* pszServant,
+      long invocationTimeout = -1,
+      AutoPolling autopoll = AUTO_POLL_OFF
+    );
+
+    /** Class constructor
+        @param Host - IP address of the remote host to connect to
+        @param port - The port on the remote host to connect to
+        @param pszServant - Name of the remote servant to connect to
+     */
+    corbaCallbackClient
+    (
+      const std::string& host,
+      long  port,
+      const char* pszServant,
+      long invocationTimeout = -1,
+      AutoPolling autopoll = AUTO_POLL_OFF
+    );
+
+    /** Class destructor */
+    ~corbaCallbackClient();
+};
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr.h b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr.h
index 9413d316..01ce4505 100644
--- a/SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr.h
+++ b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr.h
@@ -16,395 +16,163 @@
 #pragma message("including: " __FILE__)
 #endif
 
-#include "massaiCorba/corbaorb.h"
-#include "massaiCorba/corbaorbEx.h"
-#include "massaiCorba/corbacfg.h"
-#include <string>
+#include "massaiCorba/corbasrvr.hpp"
 
-#if defined (_MICO_)
-
-#error Use MICO for clients only !!!
-
-#endif
-
-template<class T> class corbaChildServant
+// corbaChildServant
+template<class T>
+PortableServer::Servant corbaChildServant<T>::getServant()
 {
-private:
-
-    T *servant;
-
-    CORBA::Object_var            obj;
-    PortableServer::ObjectId_var objID;
-
-    //char szServantName[256];
-    //char szIOR[1024];
-    std::string m_ior;
-    std::string m_servantName;
-
-public:
-
-    const char *ior() { return(m_ior.c_str()); }
-
-    long activate(CORBA::ORB_ptr orb, PortableServer::POA_ptr poa)
-    {
-      long rc = 0;
-
-      if((m_servantName.size() > 0) && servant)
-      {
-        objID = PortableServer::string_to_ObjectId(m_servantName.c_str());
-
-        poa->activate_object_with_id(objID,servant);
-
-#if defined(_ORBACUS_)
-
-        PortableServer::ObjectId_var bindingObjID;
-
-        bindingObjID = PortableServer::string_to_ObjectId(m_servantName.c_str());
-
-        CORBA::Object_var bootManagerObj = orb->resolve_initial_references("BootManager");
-
-        OB::BootManager_var bootManager = OB::BootManager::_narrow(bootManagerObj);
-
-        bootManager->add_binding(bindingObjID,servant->_this());
-
-#elif defined(_TAO_)
-
-        // Turn your object reference into an IOR string
-
-        CORBA::String_var ior = orb->object_to_string(servant->_this());
-
-        // Get a reference to the IOR Table
-
-        CORBA::Object_var tableObj = orb->resolve_initial_references("IORTable");
-
-        IORTable::Table_var table = IORTable::Table::_narrow(tableObj.in());
-
-        // Bind your stringified IOR in the IOR Table
-
-        table->bind(m_servantName.c_str(), ior.in());
-
-        // save IOR ...
-
-        //strcpy(szIOR,ior.in());
-        m_ior= ior.in();
-#endif
-      }
-      else
-        rc = -1;
-
-      return(rc);
-    }
-
-
-    long remove(CORBA::ORB_ptr orb)
-    {
-#if defined(_TAO_)
-
-       // Get a reference to the IOR Table
-
-       CORBA::Object_var tableObj = orb->resolve_initial_references("IORTable");
-
-       IORTable::Table_var table = IORTable::Table::_narrow(tableObj.in());
-
-       // Bind your stringified IOR in the IOR Table
-
-       try
-       {
-         table->unbind(m_servantName.c_str());
-       }
-       catch(CORBA::SystemException& e)
-       {
-         TRACE(HERE_5,"CORBA Exception: %s",e._message());
-       }
-       catch(CORBA::UserException& e)
-       {
-         TRACE(HERE_5,"CORBA UserException: %s",e._message());
-       }
-       catch(exception& e)
-       {
-         TRACE(HERE_5,"Exception: %s",e.what());
-       }
-       catch(...)
-       {
-         TRACE(HERE_5,"unknown exception");
-       }
-       return 0;
-#else
-        return -1;
-#endif
-    }
-
-    corbaChildServant(T& servant, const char *pszServantName)
-    {
-      // initialize & set defaults
-
-      //*szServantName = '\0';
-      //*szIOR         = '\0';
-
-      this->servant = &servant;
-
-      if(pszServantName)
-      {
-        //strcpy(szServantName,pszServantName);
-        m_servantName= pszServantName;
-      }
-    }
+  return servant;
+}
 
-   ~corbaChildServant()
-    {
-       PortableServer::POA_var p;
-
-       TRACE(HERE_8,">> ~corbaChildServant()");
-       try
-       {
-         p = servant->_default_POA();
-         p->deactivate_object(objID);
-       }
-       catch(CORBA::SystemException& e)
-       {
-         TRACE(HERE_5,"CORBA Exception: %s",e._message());
-       }
-       catch(CORBA::UserException& e)
-       {
-         TRACE(HERE_5,"CORBA UserException: %s",e._message());
-       }
-       catch(exception& e)
-       {
-         TRACE(HERE_5,"Exception: %s",e.what());
-       }
-       catch(...)
-       {
-         TRACE(HERE_5,"unknown exception");
-       }
-       TRACE(HERE_8,"<< ~corbaChildServant()");
-    }
-};
-
-/** Template class for the implementation of (extended) CORBA servants that
- *  provides the functionality for connected clients.
- */
-
-template<class T> class corbaServantEx : public corbaOrbEx
+template<class T>
+std::string corbaChildServant<T>::getIOR(CORBA::ORB_ptr orb)
 {
-protected:
-
-    T *servant;
-
-    CORBA::Object_var       obj;
-    PortableServer::POA_var poa;
-
-    PortableServer::ObjectId_var objID;
-
-    std::string m_ior;
-
-    long createServant(const char *pszServantName)
-    {
-        long rc = 0;
-
-        if(!pszServantName || !*pszServantName)
-          return(-1);
-
-        createRootPOA();
-
-        poa = createPOA(pszServantName);
-
-        objID = PortableServer::string_to_ObjectId(pszServantName);
-
-        poa->activate_object_with_id(objID,servant);
-
-#if defined(_ORBACUS_)
+  // Turn your object reference into an IOR string
+  CORBA::String_var ior = orb->object_to_string(servant->_this());
+  return ior.in();
+}
 
-        PortableServer::ObjectId_var bindingObjID;
-
-        bindingObjID = PortableServer::string_to_ObjectId(pszServantName);
-
-        CORBA::Object_var bootManagerObj = orb()->resolve_initial_references("BootManager");
-
-        OB::BootManager_var bootManager = OB::BootManager::_narrow(bootManagerObj);
-
-        bootManager->add_binding(bindingObjID,servant->_this());
-
-#elif defined(_TAO_)
-
-        // Turn your object reference into an IOR string
-
-        CORBA::String_var ior = orb()->object_to_string(servant->_this());
-
-        // Get a reference to the IOR Table
-
-        CORBA::Object_var tableObj = orb()->resolve_initial_references("IORTable");
-
-        IORTable::Table_var table = IORTable::Table::_narrow(tableObj.in());
-
-        // Bind your stringified IOR in the IOR Table
-
-        table->bind(pszServantName,ior.in());
-
-#endif
-        // execute ORB(s)...
-
-        start();
-
-        // ... and activate POA(s)
-
-        return(activateServer());
-    }
-
-public:
-
-    // adds a new child servant to the POA structure
-
-    long addServant(const void *childServant)
-    {
-        if(childServant)
-          return(((corbaChildServant<T> *)childServant)->activate(orb(), servant->_default_POA()));
-        else
-          return(-1);
-    }
-
-
-    // removes a child servant out of the POA structure
-
-    long removeServant(const void *childServant)
-    {
-        if(childServant)
-          return(((corbaChildServant<T> *)childServant)->remove(orb()));
-        else
-          return(-1);
-    }
-
-
-    /** Returns the IOR of this object */
-
-    const char *ior()
-    {
-      if(m_ior.size() == 0)
-      {
-        CORBA::String_var ior_= orb()->object_to_string(servant->_this());
-        m_ior= ior_.in();
-      }
-      return m_ior.c_str();
-    }
-
-    /** This constructor reads the port from the configuration.
-        \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b (host:)port
-
-        @param lThreads - The number of concurrent threads for this servant
-        @param servant - The servant class that implements the servants functionality
-        @param pszServantName - The name of the servant
-     */
-
-    corbaServantEx(const long lThreads, T& servant, const char *pszServantName = "")
-     : corbaOrbEx(getConfigHost(pszServantName).c_str(), getConfigPort(pszServantName),lThreads)
-    {
-      long err;
-
-      this->servant = &servant;
-      err = createServant(pszServantName);
-    }
-
-    /** Class constructor
-        @param lThreads - The number of concurrent threads for this servant
-        @param servant - The servant class that implements the servants functionality
-        @param pszServantName - The name of the servant
-        @param port - The port to which the ORB is listening to
-     */
-
-    corbaServantEx(const long lThreads, T& servant, const char *pszServantName, const long port)
-      : corbaOrbEx(port,lThreads)
-    {
-      long err;
-
-      this->servant = &servant;
-      err = createServant(pszServantName);
-    }
-
-    /** Class constructor
-        @param lThreads - The number of concurrent threads for this servant
-        @param servant - The servant class that implements the servants functionality
-        @param pszServantName - The name of the servant
-        @param interface - The interface to which the ORB is listening
-        @param port - The port to which the ORB is listening to
-     */
-
-    corbaServantEx( const long lThreads, T& servant, 
-				    const char *pszServantName, const char *pSzInterface, const long port)
-      : corbaOrbEx( pSzInterface, port, lThreads )
-    {
-      long err;
-
-      this->servant = &servant;
-      err = createServant(pszServantName);
-    }
-
-    /** Class constructor
-        @param lThreads - The number of concurrent threads for this servant
-        @param servant - The servant class that implements the servants functionality
-        @param pszServantName - The name of the servant
-        @param port - The port to which the ORB is listening to
-        @param pszHostname_in_ior - Use that CORBA option
-     */
-
-    corbaServantEx(const long lThreads, T& servant, const char *pszServantName,
-                   const long port, const char *pszHostname_in_ior)
-      : corbaOrbEx(port,lThreads,pszHostname_in_ior)
-    {
-      long err;
-
-      this->servant = &servant;
-      err = createServant(pszServantName);
-    }
-
-
-    /** Class destructor */
-
-   ~corbaServantEx()
-   {
-       PortableServer::POA_var      p;
-       PortableServer::ObjectId_var id;
-
-       try
-       {
-         p  = servant->_default_POA();
-         id = p->servant_to_id(servant);
-
-         p->deactivate_object(id);
-       }
-       catch(...) { }
+template<class T>
+PortableServer::POA_ptr corbaChildServant<T>::getPOA()
+{
+  return servant->_default_POA()
+}
 
-       try
-       {
-         if(!CORBA::is_nil(poa))
-           poa->destroy(false,false);
-       }
-       catch(...) { }
-   }
-};
+template<class T>
+corbaChildServant<T>::corbaChildServant(T& servant, const char* pszServantName):
+  corbaChildServantBase(pszServantName)
+{
+  this->servant = &servant;
+}
 
-/** Template class for the implementation of CORBA servants that
- *  provides the functionality for connected clients.
- */
+template<class T>
+corbaChildServant<T>::~corbaChildServant()
+{
+  deactivate();
+}
 
-template<class T> class corbaServant : public corbaServantEx <T>
+// corbaServantEx
+template<class T>
+PortableServer::Servant corbaServantEx<T>::getServant()
 {
-public:
+  return servant;
+}
 
-    corbaServant(T& servant, const char *pszServantName = "")
-     : corbaServantEx <T> (1,servant,pszServantName) { }
+template<class T>
+std::string corbaServantEx<T>::getIOR(CORBA::ORB_ptr orb)
+{
+  // Turn your object reference into an IOR string
+  CORBA::String_var ior = orb->object_to_string(servant->_this());
+  return ior.in();
+}
 
-    /** Class constructor
-        @param servant - The servant class that implements the servants functionality
-        @param pszServantName - The name of the servant
-        @param port - The port to which the ORB is listening to
-     */
+template<class T>
+PortableServer::POA_ptr corbaServantEx<T>::getPOA()
+{
+  return servant->_default_POA();
+}
 
-    corbaServant(T& servant, const char *pszServantName, const long port)
-     : corbaServantEx <T> (1,servant,pszServantName,port) { }
 
-    /** Class destructor */
+/** This constructor reads the port from the configuration.
+    \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b (host:)port
 
-   ~corbaServant() { }
-};
+    @param lThreads - The number of concurrent threads for this servant
+    @param servant - The servant class that implements the servants functionality
+    @param pszServantName - The name of the servant
+*/
+template<class T>
+corbaServantEx<T>::corbaServantEx(long lThreads, T& servant, const char* pszServantName):
+  corbaServantExBase(getConfigHost(pszServantName).c_str(), getConfigPort(pszServantName), lThreads),
+  servant(&servant)
+{
+  createServant(pszServantName);
+}
+
+/** Class constructor
+    @param lThreads - The number of concurrent threads for this servant
+    @param servant - The servant class that implements the servants functionality
+    @param pszServantName - The name of the servant
+    @param port - The port to which the ORB is listening to
+*/
+template<class T>
+corbaServantEx<T>::corbaServantEx(long lThreads, T& servant, const char* pszServantName, long port):
+  corbaServantExBase(port, lThreads),
+  servant(&servant)
+{
+  createServant(pszServantName);
+}
+
+/** Class constructor
+    @param lThreads - The number of concurrent threads for this servant
+    @param servant - The servant class that implements the servants functionality
+    @param pszServantName - The name of the servant
+    @param interface - The interface to which the ORB is listening
+    @param port - The port to which the ORB is listening to
+*/
+template<class T>
+corbaServantEx<T>::corbaServantEx
+(
+  long lThreads,
+  T& servant,
+  const char* pszServantName,
+  const char* pszInterface,
+  long port
+):
+  corbaServantExBase(pszInterface, port, lThreads),
+  servant(&servant)
+{
+  createServant(pszServantName);
+}
+
+/** Class constructor
+    @param lThreads - The number of concurrent threads for this servant
+    @param servant - The servant class that implements the servants functionality
+    @param pszServantName - The name of the servant
+    @param port - The port to which the ORB is listening to
+    @param pszHostname_in_ior - Use that CORBA option
+*/
+template<class T>
+corbaServantEx<T>::corbaServantEx
+(
+  long lThreads,
+  T& servant,
+  const char* pszServantName,
+  long port,
+  const char* pszHostname_in_ior
+):
+  corbaServantExBase(port, lThreads, pszHostname_in_ior),
+  servant(&servant)
+{
+  createServant(pszServantName);
+}
 
+/** Class destructor */
+template<class T>
+corbaServantEx<T>::~corbaServantEx()
+{
+  deactivate();
+}
+
+// corbaServant
+template<class T>
+corbaServant<T>::corbaServant(T& servant, const char* pszServantName):
+  corbaServantEx <T>(1, servant, pszServantName)
+{}
+
+/** Class constructor
+    @param servant - The servant class that implements the servants functionality
+    @param pszServantName - The name of the servant
+    @param port - The port to which the ORB is listening to
+*/
+template<class T>
+corbaServant<T>::corbaServant(T& servant, const char* pszServantName, long port):
+  corbaServantEx<T>(1, servant, pszServantName, port)
+{}
+
+/** Class destructor */
+template<class T>
+corbaServant<T>::~corbaServant()
+{}
 
-#endif //CORBASRVR_H
+#endif
diff --git a/SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr.hpp b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr.hpp
new file mode 100644
index 00000000..de3ad260
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr.hpp
@@ -0,0 +1,111 @@
+// Interface CORBA server/servant classes.
+#ifndef CORBASRVR_HPP
+#define CORBASRVR_HPP
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "massaiCorba/corbaorb.h"
+#include "massaiCorba/corbasrvrbase.h"
+#include "massaiCorba/corbacfg.h"
+#include <string>
+
+template<class T> class corbaChildServant: public massaiCorba::corbaChildServantBase
+{
+  public:
+    corbaChildServant(T& servant, const char* pszServantName);
+   ~corbaChildServant();
+
+  private:
+    T* servant;
+
+    virtual PortableServer::Servant getServant();
+    virtual PortableServer::POA_ptr getPOA();
+    virtual std::string getIOR(CORBA::ORB_ptr orb);
+};
+
+/** Template class for the implementation of (extended) CORBA servants that
+   provides the functionality for connected clients.
+*/
+template<class T> class corbaServantEx: public massaiCorba::corbaServantExBase
+{
+  public:
+    /** This constructor reads the port from the configuration.
+        \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b (host:)port
+
+        @param lThreads - The number of concurrent threads for this servant
+        @param servant - The servant class that implements the servants functionality
+        @param pszServantName - The name of the servant
+     */
+    corbaServantEx(long lThreads, T& servant, const char* pszServantName = "");
+
+    /** Class constructor
+        @param lThreads - The number of concurrent threads for this servant
+        @param servant - The servant class that implements the servants functionality
+        @param pszServantName - The name of the servant
+        @param port - The port to which the ORB is listening to
+     */
+    corbaServantEx(long lThreads, T& servant, const char* pszServantName, long port);
+
+    /** Class constructor
+        @param lThreads - The number of concurrent threads for this servant
+        @param servant - The servant class that implements the servants functionality
+        @param pszServantName - The name of the servant
+        @param interface - The interface to which the ORB is listening
+        @param port - The port to which the ORB is listening to
+     */
+    corbaServantEx
+    (
+      long lThreads,
+      T& servant,
+      const char* pszServantName,
+      const char* pszInterface,
+      long port
+    );
+
+    /** Class constructor
+        @param lThreads - The number of concurrent threads for this servant
+        @param servant - The servant class that implements the servants functionality
+        @param pszServantName - The name of the servant
+        @param port - The port to which the ORB is listening to
+        @param pszHostname_in_ior - Use that CORBA option
+     */
+    corbaServantEx
+    (
+      long lThreads,
+      T& servant,
+      const char* pszServantName,
+      long port,
+      const char* pszHostname_in_ior
+    );
+
+    /** Class destructor */
+    ~corbaServantEx();
+
+  private:
+    T *servant;
+
+    virtual PortableServer::Servant getServant();
+    virtual PortableServer::POA_ptr getPOA();
+    virtual std::string getIOR(CORBA::ORB_ptr orb);
+};
+
+/** Template class for the implementation of CORBA servants that
+    provides the functionality for connected clients.
+*/
+template<class T> class corbaServant : public corbaServantEx<T>
+{
+  public:
+    corbaServant(T& servant, const char* pszServantName = "");
+    /** Class constructor
+        @param servant - The servant class that implements the servants functionality
+        @param pszServantName - The name of the servant
+        @param port - The port to which the ORB is listening to
+     */
+    corbaServant(T& servant, const char* pszServantName, long port);
+    /** Class destructor */
+   ~corbaServant();
+};
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/corbaorbEx.h b/SelfServiceCommon/Interfaces/inc/corbaorbEx.h
deleted file mode 100644
index b5ec1e80..00000000
--- a/SelfServiceCommon/Interfaces/inc/corbaorbEx.h
+++ /dev/null
@@ -1,9 +0,0 @@
-#if defined(SHOW_INCLUDE_FILES) 
-#pragma message("including: " __FILE__) 
-#endif 
-#if defined(IGNORE_DEPRECATED_MASSAI_HEADER) 
-#error "corbaorbEx.h" is deprecated, use "massaiCorba/corbaorbEx.h" instead. 
-#else 
-// #pragma message ("Warning: \"corbaorbEx.h\" is deprecated, use \"massaiCorba/corbaorbEx.h\" instead.") 
-#include "massaiCorba/corbaorbEx.h" 
-#endif 
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbacfg.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbacfg.h
index 871cfd55..74d76037 100644
--- a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbacfg.h
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbacfg.h
@@ -18,18 +18,9 @@
 
 #include <string>
 
-#define CORBA_INVOCATION_TIMEOUT_CFG_LOCATION   "CORBA.InvocationTimeout"
-#define CORBA_INVOCATION_TIMEOUT_DEFAULT        (60 * 1000) // [in msec]
-#define CORBA_CONNECTION_TIMEOUT_DEFAULT        (15 * 1000) // [in msec]
-
 // exported functions
-
-long getConfigPort( char const * ServantName );
-
-std::string getConfigHost( char const * ServantName );
-
-#if defined(_TAO_1_4_) || defined (_TAO_1_5_) || defined (_TAO_2_0_)
-long getConfigInvocationTimeout( char const * ServantName );
-#endif // _TAO_1_4_
+long getConfigPort(const char* ServantName);
+std::string getConfigHost(const char* ServantName);
+long getConfigInvocationTimeout(const char* ServantName);
 
 #endif //CORBACFG_H
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaclntbase.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaclntbase.h
new file mode 100644
index 00000000..55123b8b
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaclntbase.h
@@ -0,0 +1,87 @@
+// base classes for CORBA client template class
+
+#ifndef CORBACLNTBASE_H
+#define CORBACLNTBASE_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "massaiCorba/orbIncDefs.h"
+#include "massaiCorba/corbaorb.h"
+#include "massaiCorba/corbapoll.h"
+#include <string>
+
+namespace massaiCorba
+{
+  class corbaClientBase: public corbaOrb, public corbaPoll
+  {
+    public:
+      /** Returns the IOR of this object */
+      const char* ior();
+
+    protected:
+      corbaClientBase();
+
+      /** init client
+          @param pszIOR_or_ServantName - Valid CORBA IOR or CORBALOC address
+
+          @note If the given parameter does not specify a valid IOR or CORBALOC address
+                the host address and port is read from the configuration. This allows
+                to contact servants via its names only.
+
+                \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b host:port
+      */
+      void init
+      (
+        const char* pszIOR_or_ServantName,
+        long invocationTimeout,
+        AutoPolling autopoll
+      );
+
+      /** init client
+          @param pszInitialService - CORBA initial service, like Naming Service to connect to
+          @param pszIOR - CORBA IOR to connect to
+          @attention Not yet implememted
+      */
+      void init
+      (
+        const char* pszInitialService,
+        const char* pszIOR,
+        long invocationTimeout,
+        AutoPolling autopoll
+      );
+
+      /** init client
+          @param pszHost - IP address of the remote host to connect to
+          @param port - The port on the remote host to connect to
+          @param pszServant - Name of the remote servant to connect to
+      */
+      void init
+      (
+        const char* pszHost,
+        long port,
+        const char* pszServant,
+        long invocationTimeout,
+        AutoPolling autopoll
+      );
+
+      void startProcessing
+      (
+        const std::string& servantName,
+        bool doConnect,
+        bool local,
+        AutoPolling autopoll
+      );
+      void initCallbackClient();
+      void setTimeout(long invocationTimeout);
+
+    private:
+      CORBA::Object_var obj;
+      std::string m_ior;
+      long connect();
+      virtual void narrow(CORBA::Object_var obj) = 0;
+  };
+}
+#endif
+
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorb.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorb.h
index a2cd215b..45eaeb5e 100644
--- a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorb.h
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorb.h
@@ -18,89 +18,53 @@
 #endif
 
 #include "massaiCorba/orbIncDefs.h"
-#include "massaidll/mThreadEx.h"
 #include <string>
 
-/** Implementation of the base class for all CORBA clients and servers */
-
-class corbaOrb
+namespace massaiCorba
 {
-private:
-
-    CORBA::ORB_var                 _orb;
-    CORBA::Object_var               poaObj;
-    PortableServer::POA_var         rootPoa;
-    PortableServer::POAManager_var  poaManager;
-    CORBA::PolicyList               policies;
-
-    bool fServer;
-
-
-    void init(const char * pszHostName, long port, bool client);
-
-protected:
-
-    /** Helper function for derived classes */
-
-    long createObject(const char *pszIOR, CORBA::Object_var& obj);
-    long createObject(const char *pszIOR, CORBA::Object_var& obj, bool& local, std::string& name);
-
-    /** Helper function for derived classes */
-
-    long createObject(const char *pszHost, long port, const char* pszServant, CORBA::Object_var& obj);
-    long createObject(const char *pszHost, long port, const char* pszServant, CORBA::Object_var& obj, bool& local, std::string& name);
-
-    /** Helper function for derived classes */
-
-    char *bindingID(const char *pszServantName);
-
-    /** Helper function for derived classes */
-
-    void createRootPOA();
-
-    /** Helper function for derived classes */
-
-    PortableServer::POA *createPOA (const char *pszServantName);
-
-    /** Helper function for derived classes */
+  /** Implementation of the base class for all CORBA clients and servers */
+  class corbaOrb
+  {
+    public:
+      /** Returns a pointer to the ORB */
+      CORBA::ORB_ptr orb();
+
+      /** Class constructor for CORBA server applications
+          @param hostname  - Specifies a host address for the ORB to listen on, this
+                                may be necessary if the host machine has multiple IP-adresses
+          @param port - Specifies a fixed port for the ORB to listen to
+          @param lThreads - The number of threads for this servant
+          @param pszHostname_in_ior - hostname to use in ior
+      */
+      corbaOrb(const std::string& hostname, long port, long lThreads, const std::string& hostname_in_ior);
+
+      /** class destructor */
+      ~corbaOrb();
+
+    protected:
+      /** Helper function for derived classes */
+      bool createObject(const std::string& IOR, CORBA::Object_var& obj, bool& local, std::string& name);
+
+      /** Helper function for derived classes */
+      bool createObject(const std::string& host, long port, const std::string& servant, CORBA::Object_var& obj, bool& local, std::string& name);
+
+      /** Helper function for derived classes */
+      void createRootPOA();
+
+      /** Helper function for derived classes */
+      PortableServer::POA *createPOA (const char *pszServantName);
+
+      /** Helper function for derived classes */
+      bool activateCallback();
+
+      /** Helper function for derived classes */
+      bool activateServer();
+
+    private:
+      CORBA::ORB_var                  _orb;
+      PortableServer::POA_var         rootPoa;
+      PortableServer::POAManager_var  poaManager;
+  };
+}
 
-    long activateCallback();
-
-    /** Helper function for derived classes */
-
-    long activateServer();
-
-public:
-
-    /** Starts execution of the ORB */
-
-    void run();
-
-    /** Returns a pointer to the ORB */
-
-    CORBA::ORB_ptr orb();
-
-    /** Class constructor for CORBA client only applicatons */
-
-    corbaOrb();
-
-    /** Class constructor for CORBA server applications
-     *  @param port - Specifies a fixed port for the ORB to listen to
-     */
-
-    corbaOrb(long port);
-
-    /** Class constructor for CORBA server applications
-     *  @param pszHostName  - Specifies a host address for the ORB to listen on, this
-     *                        may be necessary if the host machine has multiple IP-adresses
-     *  @param port         - Specifies a fixed port for the ORB to listen to
-     */
-
-    corbaOrb(const char * pszHostName, long port);
-
-    /** class destructor */
-
-   ~corbaOrb();
-};
-
-#endif //CORBACLNT_H
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorbEx.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorbEx.h
deleted file mode 100644
index 4ece4559..00000000
--- a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorbEx.h
+++ /dev/null
@@ -1,129 +0,0 @@
-/**
- *  @file      corbaorbEx.h
- *
- *  @brief     Definition for extended ORB classes
- *
- *  @date      19.12.2003
- *
- *  @author    Materna Information & Communications (AGe)
- *
- ************************************************************************/
-
-#ifndef CORBAORBEX_H
-#define CORBAORBEX_H
-
-#ifdef  SHOW_INCLUDE_FILES
-#pragma message("including: " __FILE__)
-#endif
-
-#include "massaiCorba/orbIncDefs.h"
-
-class threadPool;
-
-/** Implementation of the base class for all CORBA servers.
-    This implementation now provides thread pools to support scalable servers.
-*/
-
-class corbaOrbEx
-{
-private:
-
-    CORBA::ORB_var                 _orb;
-    CORBA::ORB_var                 _orbSrvr;
-
-    CORBA::Object_var               poaObj;
-    PortableServer::POA_var         rootPoa;
-    PortableServer::POAManager_var  poaManager;
-    CORBA::PolicyList               policies;
-
-    char        szOrbName  [256];
-
-    char        szHostName [256];
-    char        szIORName  [256];
-    long        lPort;
-    long        lWorkers;
-
-    threadPool *workers;
-
-    long        createOrb();
-
-    void initialize(const char * pszHostName, long port, long lThreads, const char *pszHostname_in_ior);
-
-protected:
-
-    /** Helper function for derived classes */
-
-    long createObject(const char *pszIOR, CORBA::Object_var& obj);
-
-    /** Helper function for derived classes */
-
-    long createObject(const char *pszHost, long port, const char* pszServant, CORBA::Object_var& obj);
-
-    /** Helper function for derived classes */
-
-    char *bindingID(const char *pszServantName);
-
-    /** Helper function for derived classes */
-
-    void createRootPOA();
-
-    /** Helper function for derived classes */
-
-    PortableServer::POA *createPOA (const char *pszServantName);
-
-    /** Helper function for derived classes */
-
-    long activateCallback();
-
-    /** Helper function for derived classes */
-
-    long activateServer();
-
-public:
-
-    /** Starts execution of the ORB worker thread(s) */
-
-    void start();
-
-    /** Returns a pointer to the ORB */
-
-    CORBA::ORB_ptr orb();
-
-
-    /** Class constructor for CORBA server applications
-     */
-
-    corbaOrbEx();
-
-    /** Class constructor for CORBA server applications
-     *  @param port - Specifies a fixed port for the ORB to listen to
-        @param lThreads - The number of threads for this servant
-     */
-
-    corbaOrbEx(long port, long lThreads);
-
-
-    /** Class constructor for CORBA server applications
-     *  @param port - Specifies a fixed port for the ORB to listen to
-        @param lThreads - The number of threads for this servant
-        @param pszHostname_in_ior - hostname to use in ior
-     */
-
-    corbaOrbEx(long port, long lThreads, const char *pszHostname_in_ior);
-
-
-    /** Class constructor for CORBA server applications
-     *  @param pszHostName  - Specifies a host address for the ORB to listen on, this
-     *                        may be necessary if the host machine has multiple IP-adresses
-     *  @param port         - Specifies a fixed port for the ORB to listen to
-        @param lThreads - The number of threads for this servant
-     */
-
-    corbaOrbEx(const char * pszHostName, long port, long lThreads);
-
-    /** class destructor */
-
-   ~corbaOrbEx();
-};
-
-#endif //CORBACLNT_H
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbapoll.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbapoll.h
index d1b2f133..028346d1 100644
--- a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbapoll.h
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbapoll.h
@@ -1,10 +1,4 @@
-//---------------------------------------------------------------------------
-//
-//  file:       corbapoll.h
-//
-//  purpose:    Header file for CORBA polling class.
-//
-//---------------------------------------------------------------------------
+// CORBA polling
 
 #ifndef CORBAPOLL_H
 #define CORBAPOLL_H
@@ -57,4 +51,4 @@ class corbaPoll
     corbaPoll& operator=(const corbaPoll& assign);
 };
 
-#endif // CORBAPOLL_H
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbasrvrbase.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbasrvrbase.h
new file mode 100644
index 00000000..bb523cfe
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbasrvrbase.h
@@ -0,0 +1,97 @@
+// base classes for CORBA servant template class
+
+#ifndef CORBASRVRBASE_H
+#define CORBASRVRBASE_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "massaiCorba/corbaorb.h"
+#include <string>
+
+namespace massaiCorba
+{
+  class corbaServantBase
+  {
+    public:
+      corbaServantBase();
+      ~corbaServantBase();
+
+      /** Returns the IOR of this object */
+      const char* ior();
+
+    protected:
+      virtual PortableServer::Servant getServant() = 0;
+      virtual PortableServer::POA_ptr getPOA() = 0;
+      virtual std::string getIOR(CORBA::ORB_ptr orb) = 0;
+
+      bool hasServant();
+      void activate(const std::string& pszServantName, CORBA::ORB_ptr orb, PortableServer::POA_ptr poa);
+      void deactivate();
+
+    private:
+      CORBA::Object_var            obj;
+      PortableServer::ObjectId_var objID;
+      std::string m_ior;
+  };
+
+  class corbaChildServantBase: public corbaServantBase
+  {
+    public:
+      corbaChildServantBase(const char* pszServantName);
+      virtual ~corbaChildServantBase();
+      bool activate(CORBA::ORB_ptr orb, PortableServer::POA_ptr poa);
+      bool remove(CORBA::ORB_ptr orb);
+
+    private:
+      std::string m_servantName;
+
+  };
+
+  class corbaServantExBase: public corbaServantBase, public corbaOrb
+  {
+    public:
+      /** Class constructor for CORBA server applications
+       */
+      corbaServantExBase();
+
+      ~corbaServantExBase();
+
+      /** Class constructor for CORBA server applications
+       *  @param port - Specifies a fixed port for the ORB to listen to
+          @param lThreads - The number of threads for this servant
+       */
+      corbaServantExBase(long port, long lThreads);
+
+      /** Class constructor for CORBA server applications
+       *  @param port - Specifies a fixed port for the ORB to listen to
+          @param lThreads - The number of threads for this servant
+          @param pszHostname_in_ior - hostname to use in ior
+       */
+      corbaServantExBase(long port, long lThreads, const char* pszHostname_in_ior);
+
+      /** Class constructor for CORBA server applications
+       *  @param pszHostName  - Specifies a host address for the ORB to listen on, this
+       *                        may be necessary if the host machine has multiple IP-adresses
+       *  @param port         - Specifies a fixed port for the ORB to listen to
+          @param lThreads - The number of threads for this servant
+       */
+      corbaServantExBase(const char* pszHostName, long port, long lThreads);
+
+      // adds a new child servant to the POA structure
+      bool addServant(corbaChildServantBase* childServant);
+      // removes a child servant out of the POA structure
+      bool removeServant(corbaChildServantBase* childServant);
+
+    protected:
+      PortableServer::POA_var poa;
+
+      bool createServant(const char *pszServantName);
+      void cleanup();
+
+  };
+}
+
+#endif
+
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/orbIncDefs.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/orbIncDefs.h
index 184bdfdb..2a9925c6 100644
--- a/SelfServiceCommon/Interfaces/inc/massaiCorba/orbIncDefs.h
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/orbIncDefs.h
@@ -24,22 +24,15 @@
 
 #if defined(_TAO_)
 
-
-#if defined (_TAO_1_4_)
-    // nie, nie INLINE wollen, sonst viele unresolved externals
-    // #define ACE_NO_INLINE //doesn't work with Tao 1.2
-#endif
-
 #include "tao/corba.h"
 
-#if defined (_TAO_1_2_) || defined (_TAO_1_4_) 
+#if defined (_TAO_1_2_) || defined (_TAO_1_4_)
 #include "tao/portableserver/poa.h"
 #else
 #include "tao/portableserver/PortableServer.h"
 #include "ace/String_Base.h"
 #endif
 
-
 #include "tao/IORTable/IORTable.h"
 
 // seems that ORBACUS defines this, but TAO doesn't !!
@@ -50,45 +43,24 @@ typedef unsigned char byte;
 
 using namespace CORBA;
 
-#if defined(_TAO_1_4_) || defined(_TAO_1_5_) || defined (_TAO_2_0_)
-/** RoundTrip Timeout initialization for both corbaOrb and corbaOrbEx
-  */
-#define CORBA_TIMEOUT_MAX  0x7FFFFFFF // in ms (24days 20hours 31minutes 23seconds 647milliseconds)
-
-void SetInvocationTimeout(  ORB_ptr  orb_ptr,            ///< the CORBA ORB
-                            long     lTimeoutInMSec,     ///< timeout in milliseconds
-                            bool     bForCurrentThread   ///< true: for thread, false: for ORB
-                         );
-void ClearInvocationTimeout( CORBA::ORB_ptr  orb_ptr, bool bForCurrentThread);
-long GetInvocationTimeout( CORBA::ORB_ptr  orb_ptr, bool bForCurrentThread);
-
-#endif // _TAO_1_4_
-
-#elif defined(_ORBACUS_)
-
-#include "OB/CORBA.h"
-#include "OB/Properties.h"
-#include "OB\CORBAClient.h"
-#include "OB\POAInterface.h"
-#include "OB\BootManager.h"
-#include "OB\ORB_init.h"
-#include "OB\OBORB.h"
-
-#define _message() _to_string()
-
-using namespace CORBA;
-
-#elif defined(_MICO_)
+#else
 
-#include <windows.h>
-#include "CORBA.h"
+#error Please specify the -D_TAO_ in your compiler flags
 
-#define _message() _repoid ()
+#endif
 
-#else
 
-#error Please specify the -D_TAO_ or -D_ORBACUS_ or -D_MICO_ in your compiler flags
+/** RoundTrip Timeout initialization for both corbaOrb and corbaOrbEx
+  */
+#define CORBA_TIMEOUT_MAX  0x7FFFFFFF // in ms (24days 20hours 31minutes 23seconds 647milliseconds)
 
-#endif
+void SetInvocationTimeout
+(
+  ORB_ptr  orb_ptr,            ///< the CORBA ORB
+  long     lTimeoutInMSec,     ///< timeout in milliseconds
+  bool     bForCurrentThread   ///< true: for thread, false: for ORB
+);
+void ClearInvocationTimeout(CORBA::ORB_ptr orb_ptr, bool bForCurrentThread);
+long GetInvocationTimeout(CORBA::ORB_ptr orb_ptr, bool bForCurrentThread);
 
-#endif //ORBINCDEFS_H
\ No newline at end of file
+#endif //ORBINCDEFS_H
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/dll/makefile.mak b/SelfServiceCommon/Massai/cpp/MassaiCorba/dll/makefile.mak
index 8d71b656..056b9ec9 100644
--- a/SelfServiceCommon/Massai/cpp/MassaiCorba/dll/makefile.mak
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/dll/makefile.mak
@@ -7,9 +7,11 @@
 !include $(BUILDROOT)\Build\cpp\makefile.common.mak
 
 MY_CFLAGS = \
-    -Gi -GR -G5 -Gy \
+    -GR -Gy \
+    \
     -I$(P_INC) \
     $(INC_ACETAO) \
+    $(INC_BOOST) \
     $(INC_INTERFACES)
 
 MY_RCFLAGS = \
@@ -18,16 +20,17 @@ MY_RCFLAGS = \
 MY_LIB1 = $(LIB_DST_MCORBA)
 
 MY_LIB1_OBJS = \
+    $(_OBJ)\corbaorb.obj \
     $(_OBJ)\corbacfg.obj \
     $(_OBJ)\corbaclnt.obj \
-    $(_OBJ)\corbaorb.obj \
-    $(_OBJ)\corbaorbcfg.obj \
-    $(_OBJ)\corbaorbEx.obj \
     $(_OBJ)\corbasrvr.obj \
     $(_OBJ)\iorparser.obj \
-    $(_OBJ)\Realtime.obj \
+    $(_OBJ)\realtime.obj \
     $(_OBJ)\trace.obj \
-    $(_OBJ)\corbapoll.obj
-
+    $(_OBJ)\corbapoll.obj \
+    $(_OBJ)\orbContainer.obj \
+    $(_OBJ)\orbimpl.obj \
+    $(_OBJ)\envSettings.obj \
+    $(_OBJ)\tools.obj
 
 !include $(BUILDROOT)\Build\cpp\makefile.rules.mak
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/inc/envSettings.h b/SelfServiceCommon/Massai/cpp/MassaiCorba/inc/envSettings.h
new file mode 100644
index 00000000..ead71fde
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/inc/envSettings.h
@@ -0,0 +1,26 @@
+// read environment variables for configuration
+
+#ifndef ENVSETTINGS_H_INCLUDED
+#define ENVSETTINGS_H_INCLUDED
+
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+namespace massaiCorba
+{
+  bool isAutoPollEnabled();
+  bool isAutoPollDisabled();
+  long getAutoPollTimeout();
+
+  long getORBInvocationTimeout();
+
+  long getORBDefaultPort();
+  bool useNumericAddress();
+
+  bool useLogging();
+
+  bool preventNestedCalls();
+}
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/inc/massaiCORBA_def.h b/SelfServiceCommon/Massai/cpp/MassaiCorba/inc/massaiCORBA_def.h
index d233c538..2326247c 100644
--- a/SelfServiceCommon/Massai/cpp/MassaiCorba/inc/massaiCORBA_def.h
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/inc/massaiCORBA_def.h
@@ -9,12 +9,51 @@
  *
  ************************************************************************/
 
-/*! \page massaicorbalib Massai CORBA library - Release Notes
+// #define FILE_VER_BIN     1,0,6,18
+// #define FILE_VER_STR     "FileVersion", "1.0.6.18\0"
+
+/*! \page mcorba.lib, mcorbas.lib Massai CORBA library - Release Notes
  *
- *  @version 1.0.6.17
+ *  @version 1.0.6.18
  *
  *  \section change1 Change history
  *
+ *  \date 13.03.2012 \li V1.0.6.18
+ *                   \li SteT - enhancement, Mantis 0018942: mCorba: creation order of servant orb and client orb and synchronisation problems
+ *
+ *                   \li environment settings:
+ *                      CORBA_AUTOPOLL_ENABLE     enable auto polling, client only
+ *                      CORBA_AUTOPOLL_DISABLE    disable auto polling, client only
+ *                      CORBA_AUTOPOLL_TIMEOUT    poll timeout in ms, default 60000 ms, client only
+ *                      CORBA_INVOCATION_TIMEOUT  default invocation timeout in ms, default 60000ms
+ *                      ORBENDPOINT_PORT          default orb endpoint port
+ *                      CORBA_NUMERIC_ORB         use ip instead of hostname in ior
+ *                      CORBA_ENABLE_LOGGING      enable ORB logging
+ *                      CORBA_NO_NESTED_CALLS     disable nested calls, do not use the threads in client calls for processing servant calls
+ *
+ *                   \li logging
+ *                      TAO ORB logging is written to stderr
+ *                      massaiCORBA logging is written with OutputDebugString
+ *
+ *                   \li localhost
+ *                      cfg: empty host in configuration (CORBA.SERVANTS.*) is mapped to localhost
+ *                      servant creation: localhost is mapped to 0.0.0.0
+ *                      client connecting servant: localhost is mapped to local hostname
+ *                      to bind and connect to 127.0.0.1 use 127.0.0.1 for hostname
+ *
+ *                   \li multiple network interfaces
+ *                      the hostname in the ior is set to the local hostname, if the servant is listening on all interfaces (interface = localhost or no interface)
+ *                      to use multiple hostnames in the ior use the interface = 0.0.0.0
+ *
+ *                   \li multiple orbs
+ *                      every module creates his own orbs (avoid interaction between orb creation in dlls and executable)
+ *                      for every ORBEndpoint a new orb is created
+ *                      clients use the first servant orb or an own client orb, if no servant orb is created
+ *                      for implicit activation the first servant orb is used
+ *                         warning: this is not module independent, all modules use the same orb for implicit activation
+ *                                  the first servant orb of the module that creates its first servant orb at last is used
+ *                                  => avoid creating servants in dlls
+ *
  *  \date 09.06.2011 \li V1.0.6.17
  *                   \li GiT, rollback of previous change
  *
@@ -98,9 +137,6 @@
  *
  */
 
-// #define FILE_VER_BIN     1,0,6,17
-// #define FILE_VER_STR     "FileVersion", "1.0.6.17\0"
-
 // #define FILEDESCRIPTION  "FileDescription"  ,"Massai CORBA library\0"
 // #define INTERNALNAME     "InternalName"     ,MassaiCORBA"\0"
 // #define LEGALTRADEMARKS  "LegalTrademarks"  ,"\0"
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/inc/orbContainer.h b/SelfServiceCommon/Massai/cpp/MassaiCorba/inc/orbContainer.h
new file mode 100644
index 00000000..6c428960
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/inc/orbContainer.h
@@ -0,0 +1,108 @@
+// create and store orbs
+
+#ifndef ORBCONTAINER_H_INCLUDED
+#define ORBCONTAINER_H_INCLUDED
+
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "massaiCorba/orbIncDefs.h"
+#include "systools/mSysThread.hpp"
+#include "systools/mMutexCS.h"
+#include "boost/shared_ptr.hpp"
+#include "systools/mAutoMutexCS.h"
+
+#include <list>
+#include <string>
+#include <map>
+
+namespace massaiCorba
+{
+  class ORBSettings
+  {
+    public:
+      ORBSettings
+      (
+        const std::string& interface,
+        long port,
+        const std::string& host,
+        long threadCount
+      );
+
+      std::string interface;
+      std::string hostname;
+      long port;
+      long threadCount;
+      long invocationTimeout;
+      bool numericAddress;
+      bool logging;
+      bool nestedCalls;
+  };
+
+  class ORBProcessing: public mSysThread::thread
+  {
+    public:
+      ORBProcessing(const std::string& id, CORBA::ORB_ptr orb);
+
+    private:
+      void function();
+
+      std::string m_id;
+      CORBA::ORB_ptr m_orb;
+  };
+  typedef std::list<ORBProcessing*> ThreadList;
+
+  class ORBData
+  {
+    public:
+      ORBData(const std::string& id, ORBSettings settings);
+      ~ORBData();
+
+      ORBSettings settings;
+      CORBA::ORB_var orb;
+      ThreadList threadList;
+      long refcount;
+      std::string orbId;
+
+    private:
+      void createORB();
+      void startProcessing();
+
+    private:
+      ORBData(const ORBData& assign);
+      ORBData& operator=(const ORBData& assign);
+  };
+
+  class ORBSettingsLess
+  {
+    public:
+      bool operator()(const ORBSettings& cmp1, const ORBSettings& cmp2) const;
+  };
+  typedef std::map<CORBA::ORB_ptr, ORBData*> DataByPtr;
+  typedef std::map<ORBSettings, ORBData*, ORBSettingsLess> DataBySettings;
+
+  class ORBContainer
+  {
+    public:
+      ORBContainer();
+      ~ORBContainer();
+      CORBA::ORB_var createORB(const ORBSettings& settings);
+      void freeORB(CORBA::ORB_ptr orb);
+
+    private:
+      ORBData* createORBData(const ORBSettings& settings);
+
+      DataByPtr m_dataByPtr;
+      DataBySettings m_dataBySettings;
+      ORBData* m_client;
+      Materna::MSSD::Mutex m_access;
+      std::string m_id;
+
+    private:
+      ORBContainer(const ORBContainer& assign);
+      ORBContainer& operator=(const ORBContainer& assign);
+  };
+}
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/inc/orbimpl.h b/SelfServiceCommon/Massai/cpp/MassaiCorba/inc/orbimpl.h
new file mode 100644
index 00000000..b6358b6b
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/inc/orbimpl.h
@@ -0,0 +1,28 @@
+// ORB specific implementation
+
+#ifndef ORBIMPL_H_INCLUDED
+#define ORBIMPL_H_INCLUDED
+
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "orbContainer.h"
+
+#include <string>
+#include <list>
+
+namespace massaiCorbaImpl
+{
+  typedef std::list<std::string> ParameterList;
+
+  std::string orbEndpoint(const massaiCorba::ORBSettings& settings);
+  ParameterList getORBParameter(const massaiCorba::ORBSettings& settings);
+  bool supportInvocationTimeout();
+  void setInvocationTimeout(ORB_ptr orb_ptr, long lTimeoutInMSec, bool bForCurrentThread);
+  void clearInvocationTimeout(CORBA::ORB_ptr orb_ptr, bool bForCurrentThread);
+  long getInvocationTimeout(CORBA::ORB_ptr orb_ptr, bool bForCurrentThread);
+  void setDefaultORB(CORBA::ORB_ptr orb);
+}
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/inc/tools.h b/SelfServiceCommon/Massai/cpp/MassaiCorba/inc/tools.h
new file mode 100644
index 00000000..f54f4d6c
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/inc/tools.h
@@ -0,0 +1,34 @@
+// helper functions
+
+#ifndef TOOLS_H_INCLUDED
+#define TOOLS_H_INCLUDED
+
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "orbimpl.h"
+
+#include <string>
+
+namespace massaiCorba
+{
+  const char* notNull(const char* pszText);
+  std::string getHostname();
+  std::string getModuleName();
+  class Arguments
+  {
+    public:
+      Arguments(const massaiCorbaImpl::ParameterList& parameterList);
+      ~Arguments();
+
+      int argc;
+      char** argv;
+
+    private:
+      Arguments(const Arguments&);
+      Arguments& operator=(const Arguments&);
+  };
+}
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/inc/tracedef.h b/SelfServiceCommon/Massai/cpp/MassaiCorba/inc/tracedef.h
index 8131e309..070c4333 100644
--- a/SelfServiceCommon/Massai/cpp/MassaiCorba/inc/tracedef.h
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/inc/tracedef.h
@@ -14,18 +14,25 @@
 
 // for easier traces --------------------------------------------------------
 
-#define _HERE  255,__FILE__,__LINE__     // unconditional trace
+#ifndef __FUNCTION__      // __FUNCTION__ is not available on all compilers
+#define __FUNCTION__ ""
+#endif
 
-#define _HERE_1  1,__FILE__,__LINE__     // level 1 trace (high)
-#define _HERE_2  2,__FILE__,__LINE__
-#define _HERE_3  3,__FILE__,__LINE__
-#define _HERE_4  4,__FILE__,__LINE__
-#define _HERE_5  5,__FILE__,__LINE__
-#define _HERE_6  6,__FILE__,__LINE__
-#define _HERE_7  7,__FILE__,__LINE__
-#define _HERE_8  8,__FILE__,__LINE__
-#define _HERE_9  9,__FILE__,__LINE__     // level 9 trace (low)
+#define _HERE  255,__FILE__,__LINE__,__FUNCTION__     // unconditional trace
 
-void trace   (long lLevel,char *pszFile,long lLine,char *pszFormat, ...);
-void dump    (long lLevel,char *pszFile,long lLine,char *pData,long lLen);
-long setLevel(long level);
\ No newline at end of file
+#define _HERE_1  1,__FILE__,__LINE__,__FUNCTION__     // level 1 trace (high)
+#define _HERE_2  2,__FILE__,__LINE__,__FUNCTION__
+#define _HERE_3  3,__FILE__,__LINE__,__FUNCTION__
+#define _HERE_4  4,__FILE__,__LINE__,__FUNCTION__
+#define _HERE_5  5,__FILE__,__LINE__,__FUNCTION__
+#define _HERE_6  6,__FILE__,__LINE__,__FUNCTION__
+#define _HERE_7  7,__FILE__,__LINE__,__FUNCTION__
+#define _HERE_8  8,__FILE__,__LINE__,__FUNCTION__
+#define _HERE_9  9,__FILE__,__LINE__,__FUNCTION__     // level 9 trace (low)
+
+namespace massaiCorba
+{
+  void trace   (long lLevel, const char* pszFile, long lLine, const char* pszFunction, const char* pszFormat, ...);
+  void dump    (long lLevel, const char* pszFile, long lLine, const char* pszFunction, const char* pData, long lLen);
+  long setLevel(long level);
+}
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/src/Realtime.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba/src/Realtime.cpp
index 99355490..475d6a99 100644
--- a/SelfServiceCommon/Massai/cpp/MassaiCorba/src/Realtime.cpp
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/src/Realtime.cpp
@@ -24,186 +24,19 @@
  */
 /* ----------------- system includes ----------------- */
 
-#if defined(_TAO_1_4_)  || defined(_TAO_1_5_) || defined (_TAO_2_0_)
+#include "orbimpl.h"
 
-/* ----------------- global includes ----------------- */
-#include "tao/Messaging/Messaging.h"
-#include "massaiCorba/corbaorb.h"
-#include "massaiCorba/corbacfg.h"
-
-/* ----------------- local includes  ----------------- */
-#include "tracedef.h"
-
-/* ----------------- defines         ----------------- */
-
-/* ----------------- macros          ----------------- */
-
-/* ----------------- static data     ----------------- */
-static const long TimeoutBase = 10000;//TimeT has 100 nanosecond resolution
-
-/* ----------------- exported data     --------------- */
-
-/* ----------------- external data   ----------------- */
-
-/* ----------------- prototypes       ---------------- */
-
-/* ----------------- static functions  --------------- */
-
-/* ----------------- exported functions  ------------ */
-
-
-
-void SetInvocationTimeout(  CORBA::ORB_ptr  orb_ptr,            ///< the CORBA ORB
-                            long            lTimeoutInMSec,     ///< timeout in milliseconds
-                            bool            bForCurrentThread   ///< true: for thread, false: for ORB
-                         )
+void SetInvocationTimeout(CORBA::ORB_ptr orb_ptr, long lTimeoutInMSec, bool bForCurrentThread)
 {
-  if(lTimeoutInMSec < 0)
-  {
-    ClearInvocationTimeout(orb_ptr, bForCurrentThread);
-  }
-  else
-  {
-    try
-    {
-        CORBA::PolicyManager_var policy_manager;
-        CORBA::PolicyList     policy_list;
-
-        if(!bForCurrentThread)
-        {
-            // get the ORBPolicyManager object
-            CORBA::Object_var object = orb_ptr->resolve_initial_references( "ORBPolicyManager");
-
-            policy_manager =    CORBA::PolicyManager::_narrow (object.in());
-
-        }
-        else
-        {
-            // get the PolicyCurrent object
-            CORBA::Object_var  object = orb_ptr->resolve_initial_references ( "PolicyCurrent");
-            policy_manager =     CORBA::PolicyCurrent::_narrow (object.in());
-        }
-
-        // disable all default policies
-        policy_list.length (0);
-        policy_manager->set_policy_overrides( policy_list, CORBA::SET_OVERRIDE );
-
-        policy_list.length (2);
-
-        // set the RelativeRoundtripTimeout policy
-        CORBA::Any  object_timeout;
-        TimeBase::TimeT timeout = static_cast<TimeBase::TimeT>(lTimeoutInMSec) * TimeoutBase;
-        object_timeout <<= timeout;
-        policy_list[0] = orb_ptr->create_policy ( Messaging::RELATIVE_RT_TIMEOUT_POLICY_TYPE,
-                                                  object_timeout );
-        // set the ConnectionTimeout policy
-        CORBA::Any conn_timeout;
-		    TimeBase::TimeT c_timeout = CORBA_CONNECTION_TIMEOUT_DEFAULT*TimeoutBase;
-		    conn_timeout <<= c_timeout;
-        policy_list[1] = orb_ptr->create_policy ( TAO::CONNECTION_TIMEOUT_POLICY_TYPE, conn_timeout);
-
-
-        policy_manager->set_policy_overrides ( policy_list, CORBA::SET_OVERRIDE );
-    }
-    catch(const CORBA::Exception& ex)
-    {
-        trace(_HERE,"ORB: SetInvocationTimeout: %s",ex._message());
-    }
-    catch(std::exception& ex)
-    {
-        trace(_HERE,"ORB: SetInvocationTimeout: %s",ex.what());
-    }
-    catch(...)
-    {
-        trace(_HERE,"ORB: SetInvocationTimeout failed: other error");
-    }
-  }
+  massaiCorbaImpl::setInvocationTimeout(orb_ptr, lTimeoutInMSec, bForCurrentThread);
 }
 
-void ClearInvocationTimeout(CORBA::ORB_ptr  orb_ptr, bool bForCurrentThread)
+void ClearInvocationTimeout(CORBA::ORB_ptr orb_ptr, bool bForCurrentThread)
 {
-    try
-    {
-        CORBA::PolicyManager_var policy_manager;
-        CORBA::PolicyList        policy_list;
-
-        if(!bForCurrentThread)
-        {
-            // get the ORBPolicyManager object
-            CORBA::Object_var object = orb_ptr->resolve_initial_references("ORBPolicyManager");
-            policy_manager = CORBA::PolicyManager::_narrow(object.in());
-        }
-        else
-        {
-            // get the PolicyCurrent object
-            CORBA::Object_var object = orb_ptr->resolve_initial_references("PolicyCurrent");
-            policy_manager = CORBA::PolicyCurrent::_narrow(object.in());
-        }
-
-        policy_list.length(0);
-        policy_manager->set_policy_overrides(policy_list, CORBA::SET_OVERRIDE);
-   }
-   catch(const CORBA::Exception& ex)
-   {
-       trace(_HERE, "ORB: ClearInvocationTimeout: %s", ex._message());
-   }
-   catch(std::exception& ex)
-   {
-       trace(_HERE, "ORB: ClearInvocationTimeout: %s", ex.what());
-   }
-   catch(...)
-   {
-       trace(_HERE, "ORB: ClearInvocationTimeout failed: other error");
-   }
+  massaiCorbaImpl::clearInvocationTimeout(orb_ptr, bForCurrentThread);
 }
 
-long GetInvocationTimeout(CORBA::ORB_ptr  orb_ptr, bool bForCurrentThread)
+long GetInvocationTimeout(CORBA::ORB_ptr orb_ptr, bool bForCurrentThread)
 {
-    try
-    {
-        CORBA::PolicyTypeSeq     policy_Type;
-        CORBA::PolicyManager_var policy_manager;
-        CORBA::PolicyList_var    policy_listp;
-
-        if(!bForCurrentThread)
-        {
-            // get the ORBPolicyManager object
-            CORBA::Object_var object = orb_ptr->resolve_initial_references("ORBPolicyManager");
-            policy_manager = CORBA::PolicyManager::_narrow(object.in());
-        }
-        else
-        {
-            // get the PolicyCurrent object
-            CORBA::Object_var object = orb_ptr->resolve_initial_references("PolicyCurrent");
-            policy_manager = CORBA::PolicyCurrent::_narrow(object.in());
-        }
-
-        policy_Type.length(1);
-        policy_Type[0] = Messaging::RELATIVE_RT_TIMEOUT_POLICY_TYPE;
-
-        policy_listp = policy_manager->get_policy_overrides(policy_Type);
-
-        if(policy_listp->length() > 0)
-        {
-            Messaging::RelativeRoundtripTimeoutPolicy_var m;
-            m = Messaging::RelativeRoundtripTimeoutPolicy::_narrow((*policy_listp)[0]);
-
-            TimeBase::TimeT timeout = m->relative_expiry();
-            return static_cast<long>(timeout/10000);
-        }
-   }
-   catch(const CORBA::Exception& ex)
-   {
-       trace(_HERE, "ORB: GetInvocationTimeout: %s", ex._message());
-   }
-   catch(std::exception& ex)
-   {
-       trace(_HERE, "ORB: GetInvocationTimeout: %s", ex.what());
-   }
-   catch(...)
-   {
-       trace(_HERE, "ORB: GetInvocationTimeout failed: other error");
-   }
-   return -1;
+  return massaiCorbaImpl::getInvocationTimeout(orb_ptr, bForCurrentThread);
 }
-#endif // defined _TAO_1_4_
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/src/corbacfg.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba/src/corbacfg.cpp
index c2be9cef..80f38c4f 100644
--- a/SelfServiceCommon/Massai/cpp/MassaiCorba/src/corbacfg.cpp
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/src/corbacfg.cpp
@@ -13,49 +13,59 @@
 #include "cfgclnt/nConfigText.hpp"
 #include "cfgclnt/nConfigNumber.hpp"
 #include "massaiCorba/corbacfg.h"
-#include "limits.h"
+#include "orbimpl.h"
 #include "tracedef.h"
+#include <limits.h>
+#include <string>
 
-// base configuration class
+#define CORBA_INVOCATION_TIMEOUT_CFG_LOCATION   "CORBA.InvocationTimeout"
+#define CORBA_INVOCATION_TIMEOUT_DEFAULT        (60 * 1000) // [in msec]
 
-class mCorbaCfg : public nConfig::gcText
-{
-
-   /** This method is called, when the configuration subsystem needs to
-    *  create a new confuguration item.
-    */
-
-   void create
-      (
-         char const * & Rights,
-         char const * & Explanation,
-         char const * & Default
-      )
-   {
-      Rights = "rwl";
-      Explanation = "TCP/IP address and/or TCP/IP Port of"
-                    " the CORBA-Servant to connect.\n"
-                    "SYNTAX: [host:]port";
-      Default = "127.0.0.1:00000";
-   }
-
-public:
+using namespace massaiCorba;
 
-   /** Constructor */
-   mCorbaCfg
-      (
-         char const * Item,
-         char const * User
-      ) :
-      nConfig::gcText( Item, User )
-   {
-   }
-
-private:
+namespace
+{
+  // base configuration class
+  class mCorbaCfg : public nConfig::gcText
+  {
+    public:
+      /** Constructor */
+      mCorbaCfg(const char* Item, const char* User):
+        nConfig::gcText( Item, User )
+      {}
+
+    private:
+      /** This method is called, when the configuration subsystem needs to
+       *  create a new confuguration item.
+       */
+      void create(const char*& Rights, const char*& Explanation, const char*& Default)
+      {
+        Rights = "rwl";
+        Explanation = "TCP/IP address and/or TCP/IP Port of"
+                      " the CORBA-Servant to connect.\n"
+                      "SYNTAX: [host:]port";
+        Default = "127.0.0.1:00000";
+      }
+  };
 
-   mCorbaCfg();
+  std::string getServantConfig(const char* pszServantName)
+  {
+    std::string result;
+    if(pszServantName)
+    {
+      std::string configItem = "CORBA.SERVANTS.";
+      configItem += pszServantName;
+      mCorbaCfg servantCfg(configItem.c_str(), "massaiCorba");
+      const char* pszConfigValue = servantCfg.get();
+      if(pszConfigValue)
+      {
+        result = pszConfigValue;
+      }
+    }
+    return result;
+  }
 
-};
+}
 
 //---------------------------------------------------------------------------
 //
@@ -68,55 +78,34 @@ private:
 //  author:     Materna Information & Communications (AGe)
 //
 //---------------------------------------------------------------------------
-
 long getConfigPort(const char *pszServantName)
 {
-char  szTmp [256];
-char *pStr;
-long  lPort;
-
-    if(pszServantName)
-    {
-      sprintf(szTmp,"CORBA.SERVANTS.%s",pszServantName);
-
-      mCorbaCfg port(szTmp,"massaiCorba");
-
-      if(port.get())
-      {
-        strcpy(szTmp,port.get());
-
-        if((pStr = strchr(szTmp,':')) != NULL)
-          lPort = atol(++pStr);
-        else
-          lPort = atol(szTmp);
-
-        if(!lPort)
-        {
-          static char exception_buffer[256];
-          sprintf
-            (
-              exception_buffer,
-              "ERROR: The TCP/IP port for CORBA.SERVANTS.%s is ZERO.",
-              pszServantName
-            );
-          //
-          // JK: Throwing a pointer to C string is not exactly good.
-          // A more sophisticated solution would however affect existing
-          // applications -> we better do not touch the interface.
-          // See also Mantis ticket 0009468.
-          //
-          throw(exception_buffer);
-        }
-
-        trace(_HERE,"port for servant %s = %d",pszServantName,lPort);
-
-        return(lPort);
-      }
-      else
-        return(-1);
-    }
-    else
-      return(-1);
+  long lPort = -1;
+  std::string port = getServantConfig(pszServantName);
+  int pos = port.find(':');
+  if(pos != std::string::npos)
+  {
+    lPort = atol(port.c_str() + pos);
+  }
+  else
+  {
+    lPort = atol(port.c_str());
+  }
+  if(!lPort)
+  {
+    static char exception_buffer[256];
+    sprintf(exception_buffer, "ERROR: The TCP/IP port for CORBA.SERVANTS.%s is ZERO.",
+      pszServantName);
+    //
+    // JK: Throwing a pointer to C string is not exactly good.
+    // A more sophisticated solution would however affect existing
+    // applications -> we better do not touch the interface.
+    // See also Mantis ticket 0009468.
+    //
+    throw exception_buffer;
+  }
+  trace(_HERE, "port for servant %s = %d", pszServantName, lPort);
+  return lPort;
 }
 
 //---------------------------------------------------------------------------
@@ -130,83 +119,49 @@ long  lPort;
 //  author:     Materna Information & Communications (AGe)
 //
 //---------------------------------------------------------------------------
-
 std::string getConfigHost(const char *pszServantName)
 {
-char szTmp [256];
-char   *pStr;
-
-    *szTmp = '\0';
-
-    if(pszServantName)
-    {
-      sprintf(szTmp,"CORBA.SERVANTS.%s",pszServantName);
-
-      mCorbaCfg host(szTmp,"massaiCorba");
-
-      if(host.get())
-      {
-        strcpy(szTmp,host.get());
-
-        if((pStr = strchr(szTmp,':')) != NULL)
-          *pStr = '\0';
-        else
-          strcpy(szTmp,"127.0.0.1");
-      }
-    }
-
-    trace(_HERE,"host address for servant %s = %s",pszServantName,szTmp);
-    std::string r( szTmp, strlen(szTmp) );
-    return r;
+  std::string host = getServantConfig(pszServantName);
+  int pos = host.find(':');
+  if(pos != std::string::npos)
+  {
+    host = std::string(host, 0, pos);
+  }
+  else
+  {
+    host = "localhost";
+  }
+  trace(_HERE, "host address for servant %s = %s", pszServantName, host.c_str());
+  return host;
 }
 
-
-
-
-#if defined (_TAO_1_4_)  || defined(_TAO_1_5_) || defined(_TAO_2_0_)
-
-// base configuration class for CORBA_InvocationTimeout
-
-class mCorbaCfgTO : public nConfig::gcNumber
+namespace
 {
-
-   /** This method is called, when the configuration subsystem needs to
-    *  create a new confuguration item.
-    */
-
-   void create( char const * &      Rights,
-                char const * &      Explanation,
-                long &              Default,
-                long &              Min,
-                long &              Max
-              )
-   {
-      Rights = "rwl";
-      Explanation = "CORBA Invocation Timeout for Client/Servant"
-                    " in ms.\n"
-                    "SYNTAX: CORBA_InvocationTimeout";
-      Default = CORBA_INVOCATION_TIMEOUT_DEFAULT;
-      Min     = 0;
-      Max     = LONG_MAX;
-   }
-
-public:
-
-   /** Constructor */
-   mCorbaCfgTO
-      (
-         char const * Item,
-         char const * User
-      ) :
-      nConfig::gcNumber( Item, User )
-   {
-   }
-
-private:
-
-   mCorbaCfgTO();
-
-};
+  // base configuration class for CORBA_InvocationTimeout
+  class mCorbaCfgTO : public nConfig::gcNumber
+  {
+    public:
+      /** Constructor */
+      mCorbaCfgTO(const char* Item, const char* User):
+        nConfig::gcNumber( Item, User )
+      {}
+
+    private:
+     /** This method is called, when the configuration subsystem needs to
+      *  create a new confuguration item.
+      */
+     void create(const char*& Rights, const char*& Explanation, long& Default, long& Min, long& Max)
+     {
+       Rights = "rwl";
+       Explanation = "CORBA Invocation Timeout for Client/Servant"
+                     " in ms.\n"
+                     "SYNTAX: CORBA_InvocationTimeout";
+       Default = CORBA_INVOCATION_TIMEOUT_DEFAULT;
+       Min     = 0;
+       Max     = LONG_MAX;
+     }
+  };
+}
 
 
 //---------------------------------------------------------------------------
@@ -224,36 +179,23 @@ private:
 
 long getConfigInvocationTimeout(const char *pszServantName)
 {
-char  szTmp [256];
-
+  long result = CORBA_INVOCATION_TIMEOUT_DEFAULT;
+  if(massaiCorbaImpl::supportInvocationTimeout())
+  {
     if(pszServantName)
     {
-      sprintf
-         (
-            szTmp, "%s.%s",
-            CORBA_INVOCATION_TIMEOUT_CFG_LOCATION,
-            pszServantName
-         );
-
+      std::string configItem = CORBA_INVOCATION_TIMEOUT_CFG_LOCATION;
+      configItem +=".";
+      configItem += pszServantName;
       try
       {
-
-        mCorbaCfgTO Timeout(szTmp,"massaiCorba");
-        return( Timeout.get());
+        mCorbaCfgTO Timeout(configItem.c_str(), "massaiCorba");
+        result = Timeout.get();
       }
       catch(...)
-      {
-          // MaM 17.01.2007 EDB 27073
-          // in case of error do not return -1!
-          // -1 causes clearing all CORBA Roundtrip TO in
-          // setConfigInvocationTimeout
-          return CORBA_INVOCATION_TIMEOUT_DEFAULT;
-      };
+      {}
     }
-    else
-      // MaM see above
-      //
-      return CORBA_INVOCATION_TIMEOUT_DEFAULT;
+  }
+  return result;
 }
 
-#endif // _TAO_1_4_
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/src/corbaclnt.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba/src/corbaclnt.cpp
index eebe3e39..840f21e1 100644
--- a/SelfServiceCommon/Massai/cpp/MassaiCorba/src/corbaclnt.cpp
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/src/corbaclnt.cpp
@@ -10,5 +10,135 @@
 //
 //---------------------------------------------------------------------------
 
-#include "massaiCorba/corbaclnt.h"
+#include "massaiCorba/corbaclntbase.h"
+#include "tracedef.h"
+#include "tools.h"
 
+using massaiCorba::notNull;
+
+namespace massaiCorba
+{
+  corbaClientBase::corbaClientBase():
+    corbaOrb("", 0, 1, "")
+  {}
+
+  long corbaClientBase::connect()
+  {
+    long rc = 0;
+    try
+    {
+      narrow(obj);
+    }
+    catch(CORBA::SystemException& e)
+    {
+      trace(_HERE_1, "narrow failed (%s)", e._message());
+      rc = -1;
+    }
+    return rc;
+  }
+
+  void corbaClientBase::setTimeout(long invocationTimeout)
+  {
+    if(invocationTimeout > 0)
+    {
+      // override the Invocation Timeout for this client
+      SetInvocationTimeout(orb(), invocationTimeout,true);
+    }
+  }
+
+  /** Returns the IOR of this object */
+  const char* corbaClientBase::ior()
+  {
+    if(m_ior.size() == 0)
+    {
+      CORBA::String_var ior_= orb()->object_to_string(obj);
+      m_ior= ior_.in();
+    }
+    return m_ior.c_str();
+  }
+
+  void corbaClientBase::startProcessing(const std::string& servantName, bool doConnect, bool local, AutoPolling autopoll)
+  {
+    pollingName(servantName);
+    long err = 0;
+    if(doConnect)
+    {
+      err = connect();
+    }
+    if(err == 0)
+    {
+      startAutoPolling(local, autopoll);
+    }
+  }
+
+  void corbaClientBase::initCallbackClient()
+  {
+    createRootPOA();
+    activateCallback();
+  }
+
+  /** initialize client
+      @param pszIOR_or_ServantName - Valid CORBA IOR or CORBALOC address
+
+      @note If the given parameter does not specify a valid IOR or CORBALOC address
+            the host address and port is read from the configuration. This allows
+            to contact servants via its names only.
+
+            \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b host:port
+  */
+  void corbaClientBase::init
+  (
+    const char* pszIOR_or_ServantName,
+    long invocationTimeout,
+    AutoPolling autopoll
+  )
+  {
+    setTimeout(invocationTimeout);
+    bool local= false;
+    std::string name;
+    if(createObject(pszIOR_or_ServantName, obj, local, name))
+    {
+      startProcessing(name, true, local, autopoll);
+    }
+  }
+
+  /** initialize client
+      @param pszInitialService - CORBA initial service, like Naming Service to connect to
+      @param pszIOR - CORBA IOR to connect to
+      @attention Not yet implememted
+  */
+  void corbaClientBase::init
+  (
+    const char* pszInitialService,
+    const char* pszIOR,
+    long invocationTimeout,
+    AutoPolling autopoll
+  )
+  {
+    setTimeout(invocationTimeout);
+    // rest remains uncoded
+  }
+
+  /** initialize client
+      @param pszHost - IP address of the remote host to connect to
+      @param port - The port on the remote host to connect to
+      @param pszServant - Name of the remote servant to connect to
+  */
+  void corbaClientBase::init
+  (
+    const char* pszHost,
+    long port,
+    const char* pszServant,
+    long invocationTimeout,
+    AutoPolling autopoll
+  )
+  {
+    setTimeout(invocationTimeout);
+    bool local= false;
+    std::string name;
+    if(createObject(pszHost, port, pszServant, obj, local, name))
+    {
+      startProcessing(name, true, local, autopoll);
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/src/corbaorb.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba/src/corbaorb.cpp
index a11f31df..61198e6d 100644
--- a/SelfServiceCommon/Massai/cpp/MassaiCorba/src/corbaorb.cpp
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/src/corbaorb.cpp
@@ -11,865 +11,319 @@
 //---------------------------------------------------------------------------
 
 #include "tracedef.h"
+#include "tools.h"
+#include "orbContainer.h"
 #include "massaiCorba/corbaorb.h"
 #include "massaiCorba/corbacfg.h"
+#include "text/textTools.h"
+#include <sstream>
 
+using namespace MASSAI::text;
+using namespace massaiCorba;
 
 namespace
 {
-  void enableTAO_Logging(int& argc, char **argv)
+  // create corbaloc
+  std::string corbaloc(const std::string& host, long port, const std::string& servant)
   {
-    argv[argc++] = "-ORBDebug";
-
-    argv[argc++] = "-ORBDebugLevel";
-    argv[argc++] = "10";
-
-    argv[argc++] = "-ORBVerboseLogging";
-    argv[argc++] = "2";
+    std::ostringstream out;
+    out << "corbaloc:iiop:" << host << ":" << port << "/" << servant;
+    return out.str();
   }
-}
-
-
-// simple singleton class
-
-static CORBA::ORB_var _orbClnt = NULL;
-static CORBA::ORB_var _orbSrvr = NULL;
-
-class orbClntSingleton : public mThreadEx
-{
-private:
-
-    long function();
-
-public:
-
-     orbClntSingleton() { };
-
-    ~orbClntSingleton();
-};
-
-class orbSrvrSingleton : public mThreadEx
-{
-private:
-
-    long function();
-
-public:
-
-     orbSrvrSingleton() { };
-
-    ~orbSrvrSingleton();
-};
-
-// max. two ORBs per process
-
-static orbClntSingleton clntSingleton;
-static orbSrvrSingleton srvrSingleton;
 
-//------------------------------------------------------------------------
-/**
- *  @fn        CORBA::ORB_var clientOrb()
- *
- *  @brief     retuen reference to client orb (internal use only)
- *
- *  @date      02.01.2004
- *
- *  @author    Materna Information & Communications (AGe)
- */
-//------------------------------------------------------------------------
-
-CORBA::ORB_var clientOrb()
-{
-    return(_orbClnt);
-}
-
-//------------------------------------------------------------------------
-/**
- *  @fn        void killClientOrb()
- *
- *  @brief     kills the client orb (internal use only)
- *
- *  @date      02.01.2004
- *
- *  @author    Materna Information & Communications (AGe)
- */
-//------------------------------------------------------------------------
-
-void killClientOrb()
-{
-    if(!CORBA::is_nil(_orbClnt))
+  std::string getPOAName(const std::string& servantName, corbaOrb* pOrb)
+  {
+    std::ostringstream out;
+    out << "POA_";
+    if(servantName.size() > 0)
     {
-      try
-      {
-        _orbClnt->shutdown(0);  // returns threads from run() method.
-      }
-      catch(...) { }
-
-      try
-      {
-        _orbClnt->destroy(); // destroy the ORB
-      }
-      catch(...) { }
-
-
-      _orbClnt = NULL;
+      out << servantName;
     }
-}
-
-//---------------------------------------------------------------------------
-//
-//  function:   static char *getHostName()
-//
-//  purpose:    get the TCPIP name of this machine
-//
-//  date:       03.12.2001, 13:27
-//
-//  author:     Materna Information & Communications (AGe)
-//
-//---------------------------------------------------------------------------
-
-static char *getHostName()
-{
-static char szTmp[256];
-
-    gethostname(szTmp,sizeof(szTmp));
-
-    return(szTmp);
-}
-
-//---------------------------------------------------------------------------
-//
-//  function:   long orbSrvrSingleton::function()
-//
-//  purpose:    thread function that runs the ORB
-//
-//  date:       21.11.2001, 09:26
-//
-//  author:     Materna Information & Communications (AGe)
-//
-//---------------------------------------------------------------------------
-
-long orbSrvrSingleton::function()
-{
-    //trace(_HERE,"orbSrvrSingleton::function() ...");
-
-    _orbSrvr->run();
-
-    //trace(_HERE,"orbSrvrSingleton::function(), end.");
-
-    return(-1);
-}
-
-//---------------------------------------------------------------------------
-//
-//  function:   long orbClntSingleton::function()
-//
-//  purpose:    thread function that runs the ORB
-//
-//  date:       21.11.2001, 09:26
-//
-//  author:     Materna Information & Communications (AGe)
-//
-//---------------------------------------------------------------------------
-
-long orbClntSingleton::function()
-{
-    //trace(_HERE,"orbClntSingleton::function() ...");
-
-    try { if(_orbClnt) _orbClnt->run(); } catch (...) {};
-
-    //trace(_HERE,"orbClntSingleton::function(), end.");
-
-    return(-1);
-}
-
-//---------------------------------------------------------------------------
-//
-//  function:   orbClntSingleton::~orbClntSingleton()
-//
-//  purpose:    class destructor
-//
-//  date:       24.01.2002, 16:32
-//
-//  author:     Materna Information & Communications (AGe)
-//
-//---------------------------------------------------------------------------
-
-orbClntSingleton::~orbClntSingleton()
-{
-    if(!CORBA::is_nil(_orbClnt))
+    else
     {
-      try
-      {
-        _orbClnt->shutdown(false);  // returns from run() method.
-      }
-      catch(...) { }
-
-      try
-      {
-
-#if defined (_ORBACUS_)
-
-        mThreadEx::killWait();
-
-#else
-
-        mThreadEx::kill();
-
-#endif
-
-        _orbClnt->destroy(); // destroy the ORB
-        _orbClnt = NULL;
-      }
-      catch(...) { }
+      out << std::hex << pOrb;
     }
-}
-
-//---------------------------------------------------------------------------
-//
-//  function:   orbSrvrSingleton::~orbSrvrSingleton()
-//
-//  purpose:    class destructor
-//
-//  date:       24.01.2002, 16:32
-//
-//  author:     Materna Information & Communications (AGe)
-//
-//---------------------------------------------------------------------------
+    return out.str();
+  }
 
-orbSrvrSingleton::~orbSrvrSingleton()
-{
-    if(!CORBA::is_nil(_orbSrvr))
+  // create corbaloc, check if host is localhost
+  std::string corbaloc(const std::string& host, long port, const std::string& servant, bool& local)
+  {
+    std::string hostLower = toLower(host);
+    std::string hostname = getHostname();
+    std::string hostnameLower = toLower(hostname);
+    std::string result;
+    if(hostLower == "localhost" /*|| hostLower == "127.0.0.1"*/)
     {
-      try
-      {
-        _orbSrvr->shutdown(false);  // returns from run() method.
-      }
-      catch(...) { }
-
-      try
-      {
-
-#if defined (_ORBACUS_)
-
-        mThreadEx::killWait();
-
-#else
-
-        mThreadEx::kill();
-
-#endif
-
-        _orbSrvr->destroy(); // destroy the ORB
-        _orbSrvr = NULL;
-      }
-      catch(...) { }
+      // statt localhost wird der lokale hostname verwendet;
+      // damit wird ein LOCATION_FORWARD vermieden
+      local = true;
+      result = corbaloc(hostname, port, servant);
     }
-}
-
-//---------------------------------------------------------------------------
-//
-//  function:   char *corbaOrb::bindingID(const char *pszServantName)
-//
-//  purpose:    create a binding name that works for all ORBs
-//
-//  date:       22.11.2001, 15:10
-//
-//  author:     Materna Information & Communications (AGe)
-//
-//---------------------------------------------------------------------------
-
-char *corbaOrb::bindingID(const char *pszServantName)
-{
-static char szBindingName[1024];
-
-    *szBindingName = '\0';
-
-    if(pszServantName)
+    else if(hostLower == hostnameLower)
     {
-#if defined(_MICO_)
-
-      sprintf(szBindingName,"massai.materna.com/POA_%s/%s",pszServantName,pszServantName);
-
-#else
-
-      sprintf(szBindingName,"%s",pszServantName);
-
-#endif
+      local = true;
+      result = corbaloc(host, port, servant);
     }
-
-    return(szBindingName);
-}
-
-//---------------------------------------------------------------------------
-//
-//  function:   CORBA::ORB_ptr corbaOrb::orb()
-//
-//  purpose:    returns pointer to orb
-//
-//  date:       24.01.2002, 16:27
-//
-//  author:     Materna Information & Communications (AGe)
-//
-//---------------------------------------------------------------------------
-
-CORBA::ORB_ptr corbaOrb::orb()
-{
-    return(_orb);
-}
-
-//---------------------------------------------------------------------------
-//
-//  function:   void corbaOrb::createRootPOA()
-//
-//  purpose:    helper for servants and clients
-//
-//  date:       22.11.2001, 09:12
-//
-//  author:     Materna Information & Communications (AGe)
-//
-//---------------------------------------------------------------------------
-
-void corbaOrb::createRootPOA()
-{
-    poaObj  = _orb->resolve_initial_references("RootPOA");
-    rootPoa = PortableServer::POA::_narrow(poaObj);
-
-    // Get a reference to the POA manager
-
-    poaManager = rootPoa->the_POAManager();
-}
-
-//---------------------------------------------------------------------------
-//
-//  function:   PortableServer::POA *corbaOrb::createPOA(const char *pszServantName)
-//
-//  purpose:    create a new POA with standard policies
-//
-//  date:       22.11.2001, 09:38
-//
-//  author:     Materna Information & Communications (AGe)
-//
-//---------------------------------------------------------------------------
-
-PortableServer::POA *corbaOrb::createPOA(const char *pszServantName)
-{
-char szPoaName[512];
-
-    policies.length(3);
-
-    policies[0]= rootPoa->create_lifespan_policy(PortableServer::PERSISTENT);
-    policies[1]= rootPoa->create_id_assignment_policy(PortableServer::USER_ID);
-    policies[2]= rootPoa->create_implicit_activation_policy(PortableServer::NO_IMPLICIT_ACTIVATION);
-
-    if(pszServantName)
-      sprintf(szPoaName,"POA_%s",pszServantName);
     else
-      sprintf(szPoaName,"POA_%08x",this);
-
-    return(rootPoa->create_POA(szPoaName,poaManager,policies));
-}
-
-//---------------------------------------------------------------------------
-//
-//  function:   long corbaOrb::activateCallback()
-//
-//  purpose:    simply activate the POA manager to have callback facilities
-//
-//  date:       22.11.2001, 09:13
-//
-//  author:     Materna Information & Communications (AGe)
-//
-//---------------------------------------------------------------------------
+    {
+      local = false;
+      result = corbaloc(host, port, servant);
+    }
+    return result;
+  }
 
-long corbaOrb::activateCallback()
-{
-    // just do the same as for normal servers
+  ORBContainer* pContainer;
 
-    return(activateServer());
+  ORBContainer& getORBContainer()
+  {
+    if(pContainer == 0)
+    {
+      pContainer = new ORBContainer;
+    }
+    return *pContainer;
+  }
 }
 
-//---------------------------------------------------------------------------
-//
-//  function:   long corbaOrb::activateServer()
-//
-//  purpose:    simply activate the POA manager to enable callees
-//
-//  date:       22.11.2001, 09:23
-//
-//  author:     Materna Information & Communications (AGe)
-//
-//---------------------------------------------------------------------------
-
-long corbaOrb::activateServer()
+namespace massaiCorba
 {
-long rc = 0;
-
-   try
-   {
-     // activate the POA
-
-     poaManager->activate();
-   }
-   catch(CORBA::SystemException & e)
-   {
-     trace(_HERE,"ORB: activateServer failure: %s",e._message());
+  //---------------------------------------------------------------------------
+  //
+  //  purpose:    class constructor for servants
+  //
+  //  date:       21.11.2001, 09:26
+  //
+  //  author:     Materna Information & Communications (AGe)
+  //
+  //---------------------------------------------------------------------------
+
+  corbaOrb::corbaOrb(const std::string& hostname, long port, long lThreads, const std::string& hostname_in_ior)
+  {
+    ORBContainer& orbs = getORBContainer();
+    std::string interface = hostname;
+    std::string interfaceLower = toLower(interface);
+    if(interfaceLower == "localhost" /*|| interface == "127.0.0.1"*/)
+    {
+      interface = "";
+    }
+    ORBSettings settings(interface, port, hostname_in_ior, lThreads);
+    _orb = orbs.createORB(settings);
+  }
 
-     rc = -1;
-   }
+  //---------------------------------------------------------------------------
+  //
+  //  function:   corbaOrb::~corbaOrb()
+  //
+  //  purpose:    class destructor
+  //
+  //  date:       21.11.2001, 09:26
+  //
+  //  author:     Materna Information & Communications (AGe)
+  //
+  //---------------------------------------------------------------------------
+
+  corbaOrb::~corbaOrb()
+  {
+    ORBContainer& orbs = getORBContainer();
+    orbs.freeORB(_orb);
+    _orb = 0;
+  }
 
-   return(rc);
-}
+  //---------------------------------------------------------------------------
+  //
+  //  function:   void corbaOrb::createRootPOA()
+  //
+  //  purpose:    helper for servants and clients
+  //
+  //  date:       22.11.2001, 09:12
+  //
+  //  author:     Materna Information & Communications (AGe)
+  //
+  //---------------------------------------------------------------------------
+  void corbaOrb::createRootPOA()
+  {
+    if(!CORBA::is_nil(_orb))
+    {
+      CORBA::Object_var poaObj = _orb->resolve_initial_references("RootPOA");
+      rootPoa = PortableServer::POA::_narrow(poaObj);
+      poaManager = rootPoa->the_POAManager();
+    }
+  }
 
-//---------------------------------------------------------------------------
-//
-//  function:   void corbaOrb::run()
-//
-//  purpose:    start the thread
-//
-//  date:       21.11.2001, 10:03
-//
-//  author:     Materna Information & Communications (AGe)
-//
-//---------------------------------------------------------------------------
+  //---------------------------------------------------------------------------
+  //
+  //  function:   PortableServer::POA *corbaOrb::createPOA(const char *pszServantName)
+  //
+  //  purpose:    create a new POA with standard policies
+  //
+  //  date:       22.11.2001, 09:38
+  //
+  //  author:     Materna Information & Communications (AGe)
+  //
+  //---------------------------------------------------------------------------
+  PortableServer::POA* corbaOrb::createPOA(const char* pszServantName)
+  {
+    CORBA::PolicyList policies;
+    policies.length(3);
+    policies[0] = rootPoa->create_lifespan_policy(PortableServer::PERSISTENT);
+    policies[1] = rootPoa->create_id_assignment_policy(PortableServer::USER_ID);
+    policies[2] = rootPoa->create_implicit_activation_policy(PortableServer::NO_IMPLICIT_ACTIVATION);
 
-void corbaOrb::run()
-{
-    if(fServer)
+    std::string poaName = getPOAName(pszServantName, this);
+    trace(_HERE, "new POA: (%.1000s)", poaName.c_str());
+    try
     {
-      srvrSingleton.run();
+      return rootPoa->create_POA(poaName.c_str(), poaManager, policies);
     }
-    else
+    catch(CORBA::SystemException & e)
     {
-      clntSingleton.run();
+      trace(_HERE, "CORBA::SystemException: %.1000s", e._message());
     }
-}
-
-//---------------------------------------------------------------------------
-//
-//  function:   corbaOrb::corbaOrb()
-//
-//  purpose:    class constructor for clients
-//
-//  date:       21.11.2001, 09:26
-//
-//  author:     Materna Information & Communications (AGe)
-//
-//---------------------------------------------------------------------------
-
-corbaOrb::corbaOrb()
-{
-int    argc= 0;
-char  *argv[20];
-long   port = 0;
-char   szArgs1[256];
-
-    argv[argc++] = "exefile";
-
-    if(CORBA::is_nil(_orbClnt) && CORBA::is_nil(_orbSrvr))
+    catch(...)
     {
-#if defined (_ORBACUS_)
-
-       OB::Properties_var defProps = OB::Properties::getDefaultProperties();
-       OB::Properties_var props    = new OB::Properties( defProps );
-
-       #if defined(NUMERIC_ORB)
-
-       props->setProperty("ooc.orb.oa.numeric","true");
-
-       #endif
-
-       _orbClnt = OBCORBA::ORB_init(argc,argv,props);
-
-        fServer = false;
-
-       _orb = _orbClnt;
-#elif defined(_TAO_)
-#if defined(_TAO_1_5_)
-       argv[argc++] = "-ORBKeepalive";
-       argv[argc++] = "1";
-#endif
-
-       if(getenv("ORBENDPOINT_PORT"))
-       {
-         port = atoi(getenv("ORBENDPOINT_PORT"));
-       }
-
-       if(getenv("TAO_ENABLE_LOGGING"))
-       {
-         enableTAO_Logging(argc, argv);
-       }
-       if(port > 0)
-       {
-         sprintf(szArgs1,"iiop://:%d",port); // bind TAO-ORB to this port
-
-         if(getenv("TAO_NUMERIC_ORB"))
-         {
-           argv[argc++] = "-ORBEndpoint";
-           argv[argc++] = szArgs1;
-           argv[argc++] = "-ORBDottedDecimalAddresses";
-           argv[argc++] = "1";
-         }
-         else
-         {
-           argv[argc++] = "-ORBEndpoint";
-           argv[argc++] = szArgs1;
-         }
-
-         // if we already have a client ORB running, kill him !!
-         killClientOrb();
-
-         // create the new ORB ...
-
-        trace(_HERE,"binding new srv ORB to [%s]", szArgs1);
-
-         _orbSrvr = CORBA::ORB_init(argc,argv);
-
-         fServer = true;
-
-         _orb = _orbSrvr;
-       } else
-       {
-         if(getenv("TAO_NUMERIC_ORB"))
-         {
-           argv[argc++] = "-ORBDottedDecimalAddresses";
-           argv[argc++] = "1";
-        }
-
-        trace(_HERE,"binding new clnt ORB");
-
-         _orbClnt = CORBA::ORB_init(argc,argv);
-
-         fServer = false;
-
-         _orb = _orbClnt;
-       }
-#if defined (_TAO_1_4_)  || defined(_TAO_1_5_)
-
-       long lto = -1;
-       if(getenv("CORBA_INVOCATION_TIMEOUT"))
-       {
-           lto = atoi(getenv("CORBA_INVOCATION_TIMEOUT"));
-       }
-       if( lto > 0)
-           SetInvocationTimeout( _orb, lto, false);
-       else
-           SetInvocationTimeout( _orb, CORBA_INVOCATION_TIMEOUT_DEFAULT, false);
-#endif // _TAO_1_4_
+      trace(_HERE, "POA: (%.1000s) not created.", poaName.c_str());
+    }
 
-#elif defined(_MICO_)
+    return 0;
+  }
 
-       _orbClnt = CORBA::ORB_init(argc,argv,"mico-local-orb");
+  //---------------------------------------------------------------------------
+  //
+  //  function:   long corbaOrb::activateCallback()
+  //
+  //  purpose:    simply activate the POA manager to have callback facilities
+  //
+  //  date:       22.11.2001, 09:13
+  //
+  //  author:     Materna Information & Communications (AGe)
+  //
+  //---------------------------------------------------------------------------
+  bool corbaOrb::activateCallback()
+  {
+    // just do the same as for normal servers
+    return activateServer();
+  }
 
-        fServer = false;
+  //---------------------------------------------------------------------------
+  //
+  //  function:   long corbaOrb::activateServer()
+  //
+  //  purpose:    simply activate the POA manager to enable callees
+  //
+  //  date:       22.11.2001, 09:23
+  //
+  //  author:     Materna Information & Communications (AGe)
+  //
+  //---------------------------------------------------------------------------
+  bool corbaOrb::activateServer()
+  {
+    bool rc = false;
+    try
+    {
+      // activate the POA
+      poaManager->activate();
+      rc = true;
+    }
+    catch(CORBA::SystemException & e)
+    {
+      trace(_HERE, "CORBA::SystemException: %s", e._message());
+    }
+    return rc;
+  }
 
-       _orb = _orbClnt;
+  //---------------------------------------------------------------------------
+  //
+  //  function:   CORBA::ORB_ptr corbaOrb::orb()
+  //
+  //  purpose:    returns pointer to orb
+  //
+  //  date:       24.01.2002, 16:27
+  //
+  //  author:     Materna Information & Communications (AGe)
+  //
+  //---------------------------------------------------------------------------
+  CORBA::ORB_ptr corbaOrb::orb()
+  {
+    return _orb;
+  }
 
-#endif
-    } else
+  //---------------------------------------------------------------------------
+  //
+  //  function:   long corbaOrb::createObject(const char *pszIOR,
+  //                                          CORBA::Object_var& obj)
+  //
+  //  purpose:    helper function for clients/servants
+  //
+  //  date:       21.11.2001, 16:02
+  //
+  //  author:     Materna Information & Communications (AGe)
+  //
+  //---------------------------------------------------------------------------
+  bool corbaOrb::createObject(const std::string& IOR, CORBA::Object_var& obj, bool& local, std::string& name)
+  {
+    long rc = false;
+    local= false;
+    if(IOR.size() > 0)
     {
-      if(!CORBA::is_nil(_orbClnt))
+      std::string name = IOR;
+      std::string iorLower = toLower(name);
+      if(!startsWith(iorLower, "corbaloc:") && !startsWith(iorLower, "ior:"))
       {
-        fServer = false;
-
-        _orb = _orbClnt;
+        // servant instead of ior => get configuration for servant
+        name = corbaloc(getConfigHost(name.c_str()), getConfigPort(name.c_str()), name, local);
       }
-
-      if(!CORBA::is_nil(_orbSrvr))
+      obj = orb()->string_to_object(name.c_str());
+      if(!CORBA::is_nil(obj))
       {
-        fServer = true;
-
-        _orb = _orbSrvr;
+        rc = true;
       }
     }
-}
-
-//---------------------------------------------------------------------------
-//
-//  function:   corbaOrb::corbaOrb(long port)
-//
-//  purpose:    class constructor for servants
-//
-//  date:       21.11.2001, 09:26
-//
-//  author:     Materna Information & Communications (AGe)
-//
-//---------------------------------------------------------------------------
-
-corbaOrb::corbaOrb(long port)
-{
-int    argc;
-char  *argv[20];
-char   szArgs1[256];
-
-    argc    = 0;
-    argv[argc++] = "exefile";
-
-    if(CORBA::is_nil(_orbSrvr))
-    {
-#if defined (_ORBACUS_)
-
-       OB::Properties_var defProps = OB::Properties::getDefaultProperties();
-       OB::Properties_var props    = new OB::Properties( defProps );
-
-       #if defined(NUMERIC_ORB)
-
-       props->setProperty("ooc.orb.oa.numeric","true");
-
-       #endif
-
-       if(port > 0)
-       {
-         sprintf(szArgs1,"%d",port);
-         props->setProperty("ooc.orb.oa.port", szArgs1 );
-       }
-
-       _orbSrvr = OBCORBA::ORB_init(argc,argv,props);
-
-#elif defined(_TAO_)
-
-#if defined(_TAO_1_5_)
-       argv[argc++] = "-ORBKeepalive";
-       argv[argc++] = "1";
-#endif
-       if(getenv("TAO_ENABLE_LOGGING"))
-       {
-         enableTAO_Logging(argc, argv);
-       }
-       if(port <= 0)
-       {
-         if(getenv("ORBENDPOINT_PORT"))
-         {
-           port = atoi(getenv("ORBENDPOINT_PORT"));
-         }
-       }
-
-       if(port > 0)
-       {
-         sprintf(szArgs1,"iiop://:%d",port); // bind TAO-ORB to this port
-
-         if(getenv("TAO_NUMERIC_ORB"))
-         {
-           argv[argc++] = "-ORBEndpoint";
-           argv[argc++] = szArgs1;
-           argv[argc++] = "-ORBDottedDecimalAddresses";
-           argv[argc++] = "1";
-
-         }
-         else
-         {
-           argv[argc++] = "-ORBEndpoint";
-           argv[argc++] = szArgs1;
-         }
-       }
-
-       // if we already have a client ORB running, kill him !!
-       killClientOrb();
-
-       // create the new ORB ...
-
-       trace(_HERE,"binding new srv ORB to [%s]", szArgs1);
-
-       _orbSrvr = CORBA::ORB_init(argc,argv);
-
-#if defined (_TAO_1_4_)  || defined(_TAO_1_5_)
-       long lto = -1;
-       if(getenv("CORBA_INVOCATION_TIMEOUT"))
-       {
-           lto = atoi(getenv("CORBA_INVOCATION_TIMEOUT"));
-       }
-       if( lto > 0)
-           SetInvocationTimeout( _orbSrvr, lto, false);
-       else
-           SetInvocationTimeout( _orbSrvr, CORBA_INVOCATION_TIMEOUT_DEFAULT, false);
-#endif //_TAO_1_4_
-
-#elif defined(_MICO_)
-
-       if(port > 0)
-       {
-         sprintf(szArgs1,"inet:%s:%d",getHostName(),port); // bind MICO-ORB to this port
-         sprintf(szArgs2,"%s","massai.materna.com");
-
-         argv[argc++] = "-ORBIIOPAddr";
-         argv[argc++] = szArgs1;
-         argv[argc++] = "-POAImplName";
-         argv[argc++] = szArgs2;
-       }
-
-       _orbSrvr = CORBA::ORB_init(argc,argv,"mico-local-orb");
-
-#endif
-    }
-
-    fServer = true;
-
-   _orb = _orbSrvr;
-}
-
-//---------------------------------------------------------------------------
-//
-//  function:   corbaOrb::corbaOrb(const char * pszHostName, long port)
-//
-//  purpose:    class constructor for servants
-//
-//  date:       21.11.2001, 09:26
-//
-//  author:     Materna Information & Communications (AGe)
-//
-//---------------------------------------------------------------------------
-
-corbaOrb::corbaOrb(const char * pszHostName, long port)
-{
-  init(pszHostName, port, false);
-}
-
-//---------------------------------------------------------------------------
-//
-//  function:   corbaOrb::init(const char * pszHostName, long port)
-//
-//  purpose:    initialize corbaOrb
-//
-//  date:       26.07.2007
-//
-//  author:     Materna Information & Communications (SteT)
-//
-//---------------------------------------------------------------------------
-void corbaOrb::init(const char * pszHostName, long port, bool client)
-{
-int    argc;
-char  *argv[20];
-char   szArgs1[256];
-
-    argc    = 0;
-    argv[argc++] = "exefile";
+    return rc;
+  }
 
-    if(CORBA::is_nil(_orbSrvr))
+  //---------------------------------------------------------------------------
+  //
+  //  function:   long corbaOrb::createObject(const char *pszHost,
+  //                                          long port,
+  //                                          const char* pszServant,
+  //                                          CORBA::Object_var& obj)
+  //
+  //  purpose:    helper function for clients/servants
+  //
+  //  date:       21.11.2001, 16:02
+  //
+  //  author:     Materna Information & Communications (AGe)
+  //
+  //---------------------------------------------------------------------------
+  bool corbaOrb::createObject
+  (
+    const std::string& host,
+    long port,
+    const std::string& servant,
+    CORBA::Object_var& obj,
+    bool& local,
+    std::string& name
+  )
+  {
+    long rc = false;
+    local= false;
+    if(port > 0 && servant.size() > 0)
     {
-#if defined (_ORBACUS_)
-
-       OB::Properties_var defProps = OB::Properties::getDefaultProperties();
-       OB::Properties_var props    = new OB::Properties( defProps );
-
-       #if defined(NUMERIC_ORB)
-
-       props->setProperty("ooc.orb.oa.numeric","true");
-
-       #endif
-
-       if(port > 0)
-       {
-         sprintf(szArgs1,"%d",port);
-         props->setProperty("ooc.orb.oa.port", szArgs1 );
-       }
-
-       _orbSrvr = OBCORBA::ORB_init(argc,argv,props);
-
-#elif defined(_TAO_)
-
-#if defined(_TAO_1_5_)
-       argv[argc++] = "-ORBKeepalive";
-       argv[argc++] = "1";
-#endif
-
-       if(getenv("TAO_ENABLE_LOGGING"))
-       {
-         enableTAO_Logging(argc, argv);
-       }
-       if(port <= 0)
-       {
-         if(getenv("ORBENDPOINT_PORT"))
-         {
-           port = atoi(getenv("ORBENDPOINT_PORT"));
-         }
-       }
-
-       if(port > 0)
-       {
-         if(pszHostName && *pszHostName && (strcmp(pszHostName, "127.0.0.1") != 0))
-         {
-           // bind TAO-ORB to the specified port and the specified hostname
-           sprintf(szArgs1,"iiop://%s:%d", pszHostName, port);
-         }
-         else
-         {
-           // bind TAO-ORB to the port and the hostname of this machine
-           // sprintf(szArgs1,"iiop://%s:%d",getHostName(),port);
-           sprintf(szArgs1,"iiop://:%d", port);
-         }
-
-         if(getenv("TAO_NUMERIC_ORB"))
-         {
-           argv[argc++] = "-ORBEndpoint";
-           argv[argc++] = szArgs1;
-           argv[argc++] = "-ORBDottedDecimalAddresses";
-           argv[argc++] = "1";
-         }
-         else
-         {
-           argv[argc++] = "-ORBEndpoint";
-           argv[argc++] = szArgs1;
-         }
-       }
-
-       killClientOrb();
-
-       // create the new ORB ...
-
-       trace(_HERE,"binding new srv ORB to [%s]", szArgs1);
-
-       _orbSrvr = CORBA::ORB_init(argc,argv);
-
-#if defined (_TAO_1_4_)  || defined(_TAO_1_5_)
-       long lto = -1;
-       if(getenv("CORBA_INVOCATION_TIMEOUT"))
-       {
-           lto = atoi(getenv("CORBA_INVOCATION_TIMEOUT"));
-       }
-       if( lto > 0)
-           SetInvocationTimeout( _orbSrvr, lto, false);
-       else
-           SetInvocationTimeout( _orbSrvr, CORBA_INVOCATION_TIMEOUT_DEFAULT, false);
-#endif // _TAO_1_4_
-
-#elif defined(_MICO_)
-
-       if(port > 0)
-       {
-         sprintf(szArgs1,"inet:%s:%d",getHostName(),port); // bind MICO-ORB to this port
-         sprintf(szArgs2,"%s","massai.materna.com");
-
-         argv[argc++] = "-ORBIIOPAddr";
-         argv[argc++] = szArgs1;
-         argv[argc++] = "-POAImplName";
-         argv[argc++] = szArgs2;
-       }
-
-       _orbSrvr = CORBA::ORB_init(argc,argv,"mico-local-orb");
-
-#endif
+      if(host.size() > 0)
+      {
+        name = corbaloc(host, port, servant, local);
+      }
+      else
+      {
+        local= true;
+        name = corbaloc(getHostname(), port, servant);
+      }
+      obj = orb()->string_to_object(name.c_str());
+      if(!CORBA::is_nil(obj))
+      {
+        rc = true;
+      }
     }
-
-    fServer = true;
-
-   _orb = _orbSrvr;
-}
-
-
-//---------------------------------------------------------------------------
-//
-//  function:   corbaOrb::~corbaOrb()
-//
-//  purpose:    class destructor
-//
-//  date:       21.11.2001, 09:26
-//
-//  author:     Materna Information & Communications (AGe)
-//
-//---------------------------------------------------------------------------
-
-corbaOrb::~corbaOrb()
-{
-    if(!CORBA::is_nil(_orb))
-      _orb = NULL;
+    return rc;
+  }
 }
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/src/corbapoll.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba/src/corbapoll.cpp
index c5a2dc08..c41f7f29 100644
--- a/SelfServiceCommon/Massai/cpp/MassaiCorba/src/corbapoll.cpp
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/src/corbapoll.cpp
@@ -11,8 +11,10 @@
 #include "massaiCorba/corbapoll.h"
 #include "massaiCorba/orbIncDefs.h"
 #include "tracedef.h"
+#include "envSettings.h"
+
+using namespace massaiCorba;
 
-#define CORBA_AUTOPOLL_TIMEOUT 60000
 namespace
 {
   int global_id= 0;
@@ -48,10 +50,11 @@ corbaPollImpl::corbaPollImpl():
   m_stop(),
   m_name(),
   m_id(global_id++)
-{
-}
+{}
+
 corbaPollImpl::~corbaPollImpl()
 {}
+
 void corbaPollImpl::startPolling(corbaPoll* owner, long pollTimeout)
 {
   if(owner)
@@ -63,16 +66,17 @@ void corbaPollImpl::startPolling(corbaPoll* owner, long pollTimeout)
       trace(_HERE_7,"startThread... %d", m_id);
       m_owner= owner;
       m_started= true;
-      //run();
       start();
       trace(_HERE_7,"startThread done %d", m_id);
     }
   }
 }
+
 void corbaPollImpl::stopPolling()
 {
   m_poll= false;
 }
+
 void corbaPollImpl::stopThread()
 {
   trace(_HERE_7,"stopThread... %d", m_id);
@@ -81,6 +85,7 @@ void corbaPollImpl::stopThread()
   long rc= waitTerminated();
   trace(_HERE_7,"stopThread done %d %d", m_id, rc);
 }
+
 void corbaPollImpl::function()
 {
   try
@@ -138,22 +143,23 @@ void corbaPollImpl::function()
   catch(...)
   {}
   trace(_HERE_7,"polling done %d", m_id);
-  // return -1;
 }
+
 void corbaPollImpl::pollingName(const std::string& name)
 {
   m_name= name;
 }
+
 std::string corbaPollImpl::getName() const
 {
   return m_name;
 }
 
 
-
 corbaPoll::corbaPoll():
   m_pImpl(new corbaPollImpl)
 {}
+
 corbaPoll::~corbaPoll()
 {
   try
@@ -174,6 +180,7 @@ bool corbaPoll::poll()
 {
   return false;
 }
+
 void corbaPoll::pollingFailed()
 {}
 
@@ -183,9 +190,10 @@ void corbaPoll::startPolling(long pollTimeout)
     pollTimeout= 100;
   m_pImpl->startPolling(this, pollTimeout);
 }
+
 void corbaPoll::startAutoPolling(bool local, AutoPolling autopoll)
 {
-  if(autopoll == AUTO_POLL_OFF && !getenv("CORBA_AUTOPOLL_ENABLE"))
+  if(autopoll == AUTO_POLL_OFF && !massaiCorba::isAutoPollEnabled())
   {
     trace(_HERE_7,"(%.200s) automatic poll not selected", m_pImpl->getName().c_str());
   }
@@ -193,35 +201,23 @@ void corbaPoll::startAutoPolling(bool local, AutoPolling autopoll)
   {
     trace(_HERE_7,"(%.200s) automatic not for local servant", m_pImpl->getName().c_str());
   }
-  else if(getenv("CORBA_AUTOPOLL_DISABLE") && !(autopoll == AUTO_POLL_NON_LOCAL_FORCE || autopoll == AUTO_POLL_ON_FORCE))
+  else if(massaiCorba::isAutoPollDisabled() && !(autopoll == AUTO_POLL_NON_LOCAL_FORCE || autopoll == AUTO_POLL_ON_FORCE))
   {
     trace(_HERE_7,"(%.200s) automatic poll disabled", m_pImpl->getName().c_str());
   }
   else
   {
     trace(_HERE,"(%.200s) automatic poll enabled", m_pImpl->getName().c_str());
-    char* pszPollTimeout= getenv("CORBA_AUTOPOLL_TIMEOUT");
-    if(pszPollTimeout)
-    {
-      startPolling(atoi(pszPollTimeout));
-    }
-    else
-    {
-      startPolling(CORBA_AUTOPOLL_TIMEOUT);
-    }
+    startPolling(massaiCorba::getAutoPollTimeout());
   }
 }
+
 void corbaPoll::stopPolling()
 {
   m_pImpl->stopPolling();
 }
+
 void corbaPoll::pollingName(const std::string& name)
 {
   m_pImpl->pollingName(name);
 }
-
-
-
-// intentionally not implemented, do not copy this class
-// corbaPoll::corbaPoll(const corbaPoll& assign);
-// corbaPoll& corbaPoll::operator=(const corbaPoll& assign);
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/src/corbasrvr.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba/src/corbasrvr.cpp
index d03868c4..37032a64 100644
--- a/SelfServiceCommon/Massai/cpp/MassaiCorba/src/corbasrvr.cpp
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/src/corbasrvr.cpp
@@ -10,4 +10,203 @@
 //
 //---------------------------------------------------------------------------
 
-#include "massaiCorba/corbasrvr.h"
+#include "massaiCorba/corbasrvrbase.h"
+#include "tracedef.h"
+#include "tools.h"
+#include <exception>
+
+using massaiCorba::notNull;
+
+
+namespace massaiCorba
+{
+  corbaServantBase::corbaServantBase()
+  {}
+
+  corbaServantBase::~corbaServantBase()
+  {}
+
+  bool corbaServantBase::hasServant()
+  {
+    return getServant() != 0;
+  }
+
+  void corbaServantBase::activate(const std::string& servantName, CORBA::ORB_ptr orb, PortableServer::POA_ptr poa)
+  {
+    objID = PortableServer::string_to_ObjectId(servantName.c_str());
+    poa->activate_object_with_id(objID, getServant());
+    m_ior = getIOR(orb);
+    // Get a reference to the IOR Table
+    CORBA::Object_var tableObj = orb->resolve_initial_references("IORTable");
+    IORTable::Table_var table = IORTable::Table::_narrow(tableObj.in());
+    // Bind your stringified IOR in the IOR Table
+    table->bind(servantName.c_str(), m_ior.c_str());
+  }
+
+  void corbaServantBase::deactivate()
+  {
+    trace(_HERE_8, ">> deactivate");
+    try
+    {
+      getPOA()->deactivate_object(objID);
+    }
+    catch(CORBA::SystemException& e)
+    {
+      trace(_HERE_5, "CORBA Exception: %s", e._message());
+    }
+    catch(CORBA::UserException& e)
+    {
+      trace(_HERE_5, "CORBA UserException: %s", e._message());
+    }
+    catch(std::exception& e)
+    {
+      trace(_HERE_5, "Exception: %s", e.what());
+    }
+    catch(...)
+    {
+      trace(_HERE_5, "unknown exception");
+    }
+    trace(_HERE_8, "<< deactivate");
+  }
+
+  const char* corbaServantBase::ior()
+  {
+    return m_ior.c_str();
+  }
+
+  corbaChildServantBase::corbaChildServantBase(const char* pszServantName)
+  {
+    if(pszServantName)
+    {
+      m_servantName= pszServantName;
+    }
+  }
+
+  corbaChildServantBase::~corbaChildServantBase()
+  {}
+
+  bool corbaChildServantBase::activate(CORBA::ORB_ptr orb, PortableServer::POA_ptr poa)
+  {
+    long rc = false;
+    if((m_servantName.size() > 0) && hasServant())
+    {
+      corbaServantBase::activate(m_servantName, orb, poa);
+      rc = true;
+    }
+    return rc;
+  }
+
+  bool corbaChildServantBase::remove(CORBA::ORB_ptr orb)
+  {
+     // Get a reference to the IOR Table
+     CORBA::Object_var tableObj = orb->resolve_initial_references("IORTable");
+     IORTable::Table_var table = IORTable::Table::_narrow(tableObj.in());
+     // Bind your stringified IOR in the IOR Table
+     try
+     {
+       table->unbind(m_servantName.c_str());
+     }
+     catch(CORBA::SystemException& e)
+     {
+       trace(_HERE_5, "CORBA Exception: %s", e._message());
+     }
+     catch(CORBA::UserException& e)
+     {
+       trace(_HERE_5, "CORBA UserException: %s", e._message());
+     }
+     catch(std::exception& e)
+     {
+       trace(_HERE_5, "Exception: %s", e.what());
+     }
+     catch(...)
+     {
+       trace(_HERE_5, "unknown exception");
+     }
+     return true;
+  }
+
+  bool corbaServantExBase::createServant(const char* pszServantName)
+  {
+    if(!pszServantName || !*pszServantName)
+    {
+      return false;
+    }
+    else
+    {
+      createRootPOA();
+      poa = createPOA(pszServantName);
+      activate(pszServantName, orb(), poa);
+      // ... and activate POA(s)
+      return activateServer();
+    }
+  }
+
+  void corbaServantExBase::cleanup()
+  {
+    try
+    {
+      if(!CORBA::is_nil(poa))
+      {
+        poa->destroy(false, false);
+      }
+    }
+    catch(...)
+    {}
+  }
+
+  // adds a new child servant to the POA structure
+  bool corbaServantExBase::addServant(corbaChildServantBase* childServant)
+  {
+    if(childServant)
+      return childServant->activate(orb(), getPOA());
+    else
+      return false;
+  }
+
+  // removes a child servant out of the POA structure
+  bool corbaServantExBase::removeServant(corbaChildServantBase* childServant)
+  {
+    if(childServant)
+      return childServant->remove(orb());
+    else
+      return false;
+  }
+
+  /** Class constructor for CORBA server applications
+   */
+  corbaServantExBase::corbaServantExBase():
+    corbaOrb("", 0, 1, "")
+  {}
+
+  /** Class constructor for CORBA server applications
+   *  @param port - Specifies a fixed port for the ORB to listen to
+      @param lThreads - The number of threads for this servant
+   */
+  corbaServantExBase::corbaServantExBase(long port, long lThreads):
+    corbaOrb("", port, lThreads, "")
+  {}
+
+  /** Class constructor for CORBA server applications
+   *  @param port - Specifies a fixed port for the ORB to listen to
+      @param lThreads - The number of threads for this servant
+      @param pszHostname_in_ior - hostname to use in ior
+   */
+  corbaServantExBase::corbaServantExBase(long port, long lThreads, const char* pszHostname_in_ior):
+    corbaOrb("", port, lThreads, notNull(pszHostname_in_ior))
+  {}
+
+  /** Class constructor for CORBA server applications
+   *  @param pszHostName  - Specifies a host address for the ORB to listen on, this
+   *                        may be necessary if the host machine has multiple IP-adresses
+   *  @param port         - Specifies a fixed port for the ORB to listen to
+      @param lThreads - The number of threads for this servant
+   */
+  corbaServantExBase::corbaServantExBase(const char* pszHostName, long port, long lThreads):
+    corbaOrb(pszHostName, port, lThreads, "")
+  {}
+
+  corbaServantExBase::~corbaServantExBase()
+  {
+    cleanup();
+  }
+}
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/src/envSettings.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba/src/envSettings.cpp
new file mode 100644
index 00000000..1878e9ca
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/src/envSettings.cpp
@@ -0,0 +1,74 @@
+// read environment variables for configuration
+
+#include "envSettings.h"
+#include "massaiCORBA/corbacfg.h"
+
+#include <stdlib.h>
+
+namespace
+{
+  enum Constants
+  {
+    CORBA_AUTOPOLL_TIMEOUT = 60000,
+    CORBA_INVOCATION_TIMEOUT_DEFAULT = (60 * 1000),  // [in msec]
+  };
+
+  long getNumber(const char* key, long defaultValue)
+  {
+    long result = defaultValue;
+    const char* value = getenv(key);
+    if(value != 0)
+    {
+      result = atoi(value);
+    }
+    return defaultValue;
+  }
+
+  bool checkKey(const char* key)
+  {
+    return getenv(key) != 0;
+  }
+}
+
+namespace massaiCorba
+{
+  bool isAutoPollEnabled()
+  {
+    return checkKey("CORBA_AUTOPOLL_ENABLE");
+  }
+
+  bool isAutoPollDisabled()
+  {
+    return checkKey("CORBA_AUTOPOLL_DISABLE");
+  }
+
+  long getAutoPollTimeout()
+  {
+    return getNumber("CORBA_AUTOPOLL_TIMEOUT", CORBA_AUTOPOLL_TIMEOUT);
+  }
+
+  long getORBInvocationTimeout()
+  {
+    return getNumber("CORBA_INVOCATION_TIMEOUT", CORBA_INVOCATION_TIMEOUT_DEFAULT);
+  }
+
+  long getORBDefaultPort()
+  {
+    return getNumber("ORBENDPOINT_PORT", 0);
+  }
+
+  bool useNumericAddress()
+  {
+    return checkKey("CORBA_NUMERIC_ORB");
+  }
+
+  bool useLogging()
+  {
+    return checkKey("CORBA_ENABLE_LOGGING");
+  }
+
+  bool preventNestedCalls()
+  {
+    return checkKey("CORBA_NO_NESTED_CALLS");
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/src/orbContainer.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba/src/orbContainer.cpp
new file mode 100644
index 00000000..6d90560b
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/src/orbContainer.cpp
@@ -0,0 +1,277 @@
+// create and store orbs
+
+#include "orbContainer.h"
+#include "orbimpl.h"
+#include "envSettings.h"
+#include "tools.h"
+#include "tracedef.h"
+#include "systools/mAutoMutexCS.h"
+#include "systools/mSysException.hpp"
+
+#include <sstream>
+#include <iomanip>
+
+using Materna::MSSD::AutoMutexCS;
+using massaiCorbaImpl::ParameterList;
+using mSysException::standardException;
+using namespace massaiCorba;
+
+namespace
+{
+  std::string orbId(const ORBContainer* id)
+  {
+    std::ostringstream out;
+    out << "MASSAI_CORBA_[" << std::hex << id << "]";
+    return out.str();
+  }
+}
+
+namespace massaiCorba
+{
+  ORBSettings::ORBSettings
+  (
+    const std::string& interface,
+    long port,
+    const std::string& host,
+    long threadCount
+  ):
+    interface(interface),
+    hostname(host),
+    port(port),
+    threadCount(threadCount),
+    invocationTimeout(getORBInvocationTimeout()),
+    numericAddress(useNumericAddress()),
+    logging(useLogging()),
+    nestedCalls(!preventNestedCalls())
+  {
+    if(port == 0)
+    {
+      port = getORBDefaultPort();
+    }
+    // if listening on all interface add a hostname to the ior
+    if(interface.size() == 0 && hostname.size() == 0)
+    {
+      hostname = getHostname();
+    }
+  }
+
+  ORBProcessing::ORBProcessing(const std::string& id, CORBA::ORB_ptr orb):
+    thread(0),
+    m_id(id),
+    m_orb(orb)
+  {}
+
+  void ORBProcessing::function()
+  {
+    trace(_HERE_5,"ORB (%s) thread started", m_id.c_str());
+    if(m_orb != 0)
+    {
+      standardException Guard;
+      try
+      {
+        m_orb->run();
+      }
+      catch(const CORBA::SystemException& e)
+      {
+        trace(_HERE_1,"ORB (%s): CORBA::SystemException: %s", m_id.c_str(), e._message());
+      }
+      catch(const std::exception& e)
+      {
+        trace(_HERE_1,"ORB (%s): exception: (%s)", m_id.c_str(), e.what());
+      }
+      catch(const char* e)
+      {
+        trace(_HERE_1,"ORB (%s): exception: (%s)", m_id.c_str(), e);
+      }
+      catch(...)
+      {
+        trace(_HERE_1,"ORB (%s): unknown exception", m_id.c_str());
+      }
+    }
+    trace(_HERE_5,"ORB (%s) thread terminated", m_id.c_str());
+  }
+
+
+  ORBData::ORBData(const std::string& id, ORBSettings settings):
+    settings(settings),
+    orb(0),
+    threadList(),
+    refcount(0)
+  {
+    orbId = id + massaiCorbaImpl::orbEndpoint(settings);
+    createORB();
+    startProcessing();
+  }
+
+  void ORBData::createORB()
+  {
+    trace(_HERE_5, "ORB (%s) create", orbId.c_str());
+    ParameterList parameterList = massaiCorbaImpl::getORBParameter(settings);
+    Arguments args(parameterList);
+    for(int i = 0; i < args.argc; i++)
+    {
+      trace(_HERE_5, "ORB parameter (%d) = (%s)", i, args.argv[i]);
+    }
+    orb = ORB_init(args.argc, args.argv, orbId.c_str());
+    massaiCorbaImpl::setInvocationTimeout(orb, settings.invocationTimeout, false);
+  }
+
+  void ORBData::startProcessing()
+  {
+    // start threads
+    for(int i= 0; i < settings.threadCount; i++)
+    {
+      ORBProcessing* thread = new ORBProcessing(orbId, orb);
+      thread->start();
+      threadList.push_back(thread);
+    }
+  }
+
+
+  ORBData::~ORBData()
+  {
+    trace(_HERE_5, "ORB (%s) destroy", orbId.c_str());
+    if(orb)
+    {
+      try
+      {
+        orb->shutdown(0);  // returns threads from run() method.
+      }
+      catch(...)
+      {
+        trace(_HERE_5, "ORB (%s) shutdown failed", orbId.c_str());
+      }
+      ThreadList::iterator it= threadList.begin();
+      ThreadList::iterator end= threadList.end();
+      for(; it != end; it++)
+      {
+        ORBProcessing* pThread = *it;
+        pThread->waitTerminated();
+        delete pThread;
+      }
+      try
+      {
+        orb->destroy(); // destroy the ORB
+      }
+      catch(...)
+      {
+        trace(_HERE_5, "ORB (%s) destroy failed", orbId.c_str());
+      }
+    }
+    else
+    {
+      ThreadList::iterator it= threadList.begin();
+      ThreadList::iterator end= threadList.end();
+      for(; it != end; it++)
+      {
+        ORBProcessing* pThread = *it;
+        delete pThread;
+      }
+    }
+    trace(_HERE_5, "ORB (%s) destroy done", orbId.c_str());
+  }
+
+  bool ORBSettingsLess::operator()(const ORBSettings& cmp1, const ORBSettings& cmp2) const
+  {
+    return (cmp1.port < cmp2.port)
+      || ((cmp1.port == cmp2.port)
+        && (cmp1.interface < cmp2.interface)
+          || ((cmp1.interface == cmp2.interface)
+            && (cmp1.hostname <  cmp2.hostname)));
+  }
+
+  ORBContainer::ORBContainer():
+    m_dataByPtr(),
+    m_dataBySettings(),
+    m_client(0),
+    m_access(),
+    m_id()
+  {
+    m_id = orbId(this);
+  }
+
+  ORBContainer::~ORBContainer()
+  {
+    DataByPtr::iterator it = m_dataByPtr.begin();
+    DataByPtr::iterator end = m_dataByPtr.end();
+    for(; it != end; it++)
+    {
+      delete it->second;
+    }
+  }
+
+  CORBA::ORB_var ORBContainer::createORB(const ORBSettings& settings)
+  {
+    ORBData* result = 0;
+    AutoMutexCS mx(m_access);
+    if(settings.port == 0)
+    {
+      if(m_client != 0)
+      {
+        result = m_client;
+      }
+      else
+      {
+        result = createORBData(settings);
+      }
+    }
+    else
+    {
+      DataBySettings::iterator it = m_dataBySettings.find(settings);
+      if(it != m_dataBySettings.end())
+      {
+        result = it->second;
+      }
+      else
+      {
+        result = createORBData(settings);
+      }
+    }
+    result->refcount++;
+    return result->orb;
+  }
+
+  ORBData* ORBContainer::createORBData(const ORBSettings& settings)
+  {
+    ORBData* result = new ORBData(m_id, settings);
+    if(m_client == 0)
+    {
+      m_client = result;
+      m_client->refcount++;
+    }
+    else if(m_client->settings.port == 0)
+    {
+      m_client->refcount--;
+      if(m_client->refcount <= 0)
+      {
+        m_dataByPtr.erase(m_client->orb);
+        m_dataBySettings.erase(m_client->settings);
+        delete m_client;
+      }
+      m_client = result;
+      m_client->refcount++;
+      massaiCorbaImpl::setDefaultORB(m_client->orb);
+
+    }
+    m_dataByPtr[result->orb] = result;
+    m_dataBySettings[result->settings] = result;
+    return result;
+  }
+
+  void ORBContainer::freeORB(CORBA::ORB_ptr orb)
+  {
+    AutoMutexCS mx(m_access);
+    DataByPtr::iterator it = m_dataByPtr.find(orb);
+    if(it != m_dataByPtr.end())
+    {
+      ORBData* pData = it->second;
+      pData->refcount--;
+      if(pData->refcount <= 0)
+      {
+        m_dataByPtr.erase(it);
+        m_dataBySettings.erase(pData->settings);
+        delete pData;
+      }
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/src/orbimpl.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba/src/orbimpl.cpp
new file mode 100644
index 00000000..7d79e4af
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/src/orbimpl.cpp
@@ -0,0 +1,3 @@
+#if defined(_TAO_)
+#include "orbimpl_tao.cpp"
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/src/orbimpl_tao.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba/src/orbimpl_tao.cpp
new file mode 100644
index 00000000..a338db8f
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/src/orbimpl_tao.cpp
@@ -0,0 +1,306 @@
+// ORB specific implementation
+
+#include "orbimpl.h"
+#include "envSettings.h"
+#include "tools.h"
+#include "tracedef.h"
+#include "tao/ORB_Core.h"
+
+#if defined(_TAO_1_4_)  || defined(_TAO_1_5_) || defined (_TAO_2_0_)
+#include "tao/Messaging/Messaging.h"
+#define USE_INVOCATION_TIMEOUT
+#endif
+#if defined(_TAO_1_5_) || defined (_TAO_2_0_)
+#define USE_CONNECTION_HANDLER_CLEANUP
+#define USE_KEEPALIVE
+#endif
+
+
+#include <sstream>
+
+using namespace massaiCorbaImpl;
+using namespace massaiCorba;
+using massaiCorba::ORBSettings;
+
+namespace
+{
+  enum Constants
+  {
+    TimeoutBase = 10000, // TimeT has 100 nanosecond resolution
+    CORBA_CONNECTION_TIMEOUT_DEFAULT = (15 * 1000), // [in msec]
+  };
+
+  void enableLogging(ParameterList& parameterList)
+  {
+    parameterList.push_back("-ORBDebug");
+    parameterList.push_back("-ORBDebugLevel");
+    parameterList.push_back("10");
+    parameterList.push_back("-ORBVerboseLogging");
+    parameterList.push_back("2");
+  }
+
+  void preventNestedCalls(ParameterList& parameterList)
+  {
+    parameterList.push_back("-ORBSvcConfDirective");
+    parameterList.push_back("static Client_Strategy_Factory \""
+      "-ORBClientConnectionHandler rw "
+      "-ORBTransportMuxStrategy exclusive "
+      "-ORBConnectStrategy blocked "
+#if defined(USE_CONNECTION_HANDLER_CLEANUP)
+      "-ORBConnectionHandlerCleanup 1 "
+#endif
+      "\"");
+    parameterList.push_back("-ORBSvcConfDirective");
+    parameterList.push_back("static Resource_Factory \"-ORBFlushingStrategy blocking\"");
+  }
+
+  void setORBEndpoint(ParameterList& parameterList, const std::string& endpoint)
+  {
+    parameterList.push_back("-ORBEndpoint");
+    parameterList.push_back(endpoint);
+  }
+
+  void setNumericEndpoint(ParameterList& parameterList)
+  {
+    parameterList.push_back("-ORBDottedDecimalAddresses");
+    parameterList.push_back("1");
+  }
+
+#if defined(USE_PREFERRED_INTEFACES)
+// prefer interface wird erst ab TAO1.5 untersttzt
+// Damit wird nur das lokale Interface eingestellt.
+// Das RemoteInteface hngt ab von der IP die getAddrInfo liefert
+//   siehe tao/IIOP_Endpoint.cpp; object_addr_i
+// Damit nur das lokale Interface verwendet wird,
+// msste der DNS fr den Hostnamen des lokalen Rechners 127.0.0.1 liefern
+//  oder der Servant bindet sowohl auf 127.0.0.1 und liefert dort localhost
+//                          als auch auf das externe Interface und liefert dort den externen hostnamen
+  void setPreferLocalInterface(ParameterList& parameterList)
+  {
+    parameterList.push_back("-ORBPreferredInterfaces");
+    std::string prefer = massaiCorba::getHostname() + "=127.0.0.1";
+    parameterList.push_back(prefer);
+  }
+#endif
+
+  void setKeepAlive(ParameterList& parameterList)
+  {
+#if defined(USE_KEEPALIVE)
+       parameterList.push_back("-ORBKeepalive");
+       parameterList.push_back("1");
+#endif
+  }
+
+}
+
+namespace massaiCorbaImpl
+{
+  std::string orbEndpoint(const ORBSettings& settings)
+  {
+    std::ostringstream out;
+    out << "iiop://" << settings.interface;
+    if(settings.port != 0)
+    {
+      out << ":" << settings.port;
+    }
+    if(settings.hostname.size() > 0)
+    {
+      out << "/hostname_in_ior=" << settings.hostname;
+    }
+    return out.str();
+  }
+
+  ParameterList getORBParameter(const ORBSettings& settings)
+  {
+    ParameterList parameterList;
+    parameterList.push_back(massaiCorba::getModuleName());
+    std::string endpoint = orbEndpoint(settings);
+    setORBEndpoint(parameterList, endpoint);
+    setKeepAlive(parameterList);
+    if(settings.numericAddress)
+    {
+      setNumericEndpoint(parameterList);
+    }
+    if(settings.logging)
+    {
+      enableLogging(parameterList);
+    }
+    if(!settings.nestedCalls)
+    {
+      preventNestedCalls(parameterList);
+    }
+    return parameterList;
+  }
+
+  bool supportInvocationTimeout()
+  {
+#if defined(USE_INVOCATION_TIMEOUT)
+    return true;
+#else
+    return false;
+#endif
+  }
+
+
+  void setInvocationTimeout
+  (
+    CORBA::ORB_ptr  orb_ptr,            ///< the CORBA ORB
+    long            lTimeoutInMSec,     ///< timeout in milliseconds
+    bool            bForCurrentThread   ///< true: for thread, false: for ORB
+  )
+  {
+#if defined(USE_INVOCATION_TIMEOUT)
+    if(lTimeoutInMSec < 0)
+    {
+      clearInvocationTimeout(orb_ptr, bForCurrentThread);
+    }
+    else
+    {
+      try
+      {
+        CORBA::PolicyManager_var policy_manager;
+        if(!bForCurrentThread)
+        {
+          // get the ORBPolicyManager object
+          CORBA::Object_var object = orb_ptr->resolve_initial_references("ORBPolicyManager");
+          policy_manager = CORBA::PolicyManager::_narrow (object.in());
+        }
+        else
+        {
+          // get the PolicyCurrent object
+          CORBA::Object_var  object = orb_ptr->resolve_initial_references("PolicyCurrent");
+          policy_manager = CORBA::PolicyCurrent::_narrow (object.in());
+        }
+
+        CORBA::PolicyList policy_list;
+
+        // disable all default policies
+        policy_list.length (0);
+        policy_manager->set_policy_overrides(policy_list, CORBA::SET_OVERRIDE);
+
+        policy_list.length (2);
+        // set the RelativeRoundtripTimeout policy
+        CORBA::Any  object_timeout;
+        TimeBase::TimeT timeout = static_cast<TimeBase::TimeT>(lTimeoutInMSec) * TimeoutBase;
+        object_timeout <<= timeout;
+        policy_list[0] = orb_ptr->create_policy
+        (
+          Messaging::RELATIVE_RT_TIMEOUT_POLICY_TYPE,
+          object_timeout
+        );
+        // set the ConnectionTimeout policy
+        CORBA::Any conn_timeout;
+        TimeBase::TimeT c_timeout = CORBA_CONNECTION_TIMEOUT_DEFAULT* TimeoutBase;
+        conn_timeout <<= c_timeout;
+        policy_list[1] = orb_ptr->create_policy(TAO::CONNECTION_TIMEOUT_POLICY_TYPE, conn_timeout);
+        policy_manager->set_policy_overrides(policy_list, CORBA::SET_OVERRIDE);
+      }
+      catch(const CORBA::Exception& ex)
+      {
+        trace(_HERE,"ORB: SetInvocationTimeout: %s",ex._message());
+      }
+      catch(const std::exception& ex)
+      {
+        trace(_HERE,"ORB: SetInvocationTimeout: %s",ex.what());
+      }
+      catch(...)
+      {
+        trace(_HERE,"ORB: SetInvocationTimeout failed: other error");
+      }
+    }
+#endif
+  }
+
+  void clearInvocationTimeout(CORBA::ORB_ptr  orb_ptr, bool bForCurrentThread)
+  {
+#if defined(USE_INVOCATION_TIMEOUT)
+    try
+    {
+      CORBA::PolicyManager_var policy_manager;
+      if(!bForCurrentThread)
+      {
+        // get the ORBPolicyManager object
+        CORBA::Object_var object = orb_ptr->resolve_initial_references("ORBPolicyManager");
+        policy_manager = CORBA::PolicyManager::_narrow (object.in());
+      }
+      else
+      {
+        // get the PolicyCurrent object
+        CORBA::Object_var  object = orb_ptr->resolve_initial_references("PolicyCurrent");
+        policy_manager = CORBA::PolicyCurrent::_narrow (object.in());
+      }
+
+      CORBA::PolicyList policy_list;
+      policy_list.length(0);
+      policy_manager->set_policy_overrides(policy_list, CORBA::SET_OVERRIDE);
+    }
+    catch(const CORBA::Exception& ex)
+    {
+      trace(_HERE, "ORB: ClearInvocationTimeout: %s", ex._message());
+    }
+    catch(const std::exception& ex)
+    {
+      trace(_HERE, "ORB: ClearInvocationTimeout: %s", ex.what());
+    }
+    catch(...)
+    {
+      trace(_HERE, "ORB: ClearInvocationTimeout failed: other error");
+    }
+#endif
+  }
+
+  long getInvocationTimeout(CORBA::ORB_ptr orb_ptr, bool bForCurrentThread)
+  {
+#if defined(USE_INVOCATION_TIMEOUT)
+    try
+    {
+      CORBA::PolicyTypeSeq     policy_Type;
+      CORBA::PolicyManager_var policy_manager;
+      if(!bForCurrentThread)
+      {
+        // get the ORBPolicyManager object
+        CORBA::Object_var object = orb_ptr->resolve_initial_references("ORBPolicyManager");
+        policy_manager = CORBA::PolicyManager::_narrow (object.in());
+      }
+      else
+      {
+        // get the PolicyCurrent object
+        CORBA::Object_var  object = orb_ptr->resolve_initial_references("PolicyCurrent");
+        policy_manager = CORBA::PolicyCurrent::_narrow (object.in());
+      }
+
+      CORBA::PolicyList_var policy_listp;
+      policy_Type.length(1);
+      policy_Type[0] = Messaging::RELATIVE_RT_TIMEOUT_POLICY_TYPE;
+      policy_listp = policy_manager->get_policy_overrides(policy_Type);
+
+      if(policy_listp->length() > 0)
+      {
+        Messaging::RelativeRoundtripTimeoutPolicy_var m;
+        m = Messaging::RelativeRoundtripTimeoutPolicy::_narrow((*policy_listp)[0]);
+
+        TimeBase::TimeT timeout = m->relative_expiry();
+        return static_cast<long>(timeout/10000);
+      }
+    }
+    catch(const CORBA::Exception& ex)
+    {
+      trace(_HERE, "ORB: GetInvocationTimeout: %s", ex._message());
+    }
+    catch(const std::exception& ex)
+    {
+      trace(_HERE, "ORB: GetInvocationTimeout: %s", ex.what());
+    }
+    catch(...)
+    {
+      trace(_HERE, "ORB: GetInvocationTimeout failed: other error");
+    }
+#endif
+    return -1;
+  }
+
+  void setDefaultORB(CORBA::ORB_ptr orb)
+  {
+    orb->orb_core()->set_default(orb->id());
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/src/tools.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba/src/tools.cpp
new file mode 100644
index 00000000..0708eeff
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/src/tools.cpp
@@ -0,0 +1,90 @@
+// helper functions
+
+#include "tools.h"
+
+#include <winsock2.h>
+
+using massaiCorbaImpl::ParameterList;
+
+namespace
+{
+  bool _getHostname(char* buffer, int size)
+  {
+    bool result = true;
+    if(gethostname(buffer, size - 1) == 0)
+    {
+      buffer[size - 1] = 0;
+    }
+    else
+    {
+      buffer[0] = 0;
+      result = false;
+    }
+    return result;
+  }
+}
+
+namespace massaiCorba
+{
+  const char* notNull(const char* pszText)
+  {
+    if(pszText)
+    {
+      return pszText;
+    }
+    else
+    {
+      return "";
+    }
+  }
+
+  std::string getHostname()
+  {
+    char hostname[256];
+    if(!_getHostname(hostname, sizeof(hostname)))
+    {
+      WSADATA wsaData;
+      WORD    wVersionRequested = MAKEWORD(1,1);
+      WSAStartup(wVersionRequested, &wsaData);
+      _getHostname(hostname, sizeof(hostname));
+    }
+    return hostname;
+  }
+
+  std::string getModuleName()
+  {
+    char szBuffer[1000];
+    if(!GetModuleFileName(0, szBuffer, sizeof(szBuffer)))
+    {
+      szBuffer[0]= 0;
+    }
+    szBuffer[sizeof(szBuffer) - 1]= 0;
+    return szBuffer;
+  }
+
+  Arguments::Arguments(const ParameterList& parameterList)
+  {
+    argc = parameterList.size();
+    argv = new char*[argc];
+    ParameterList::const_iterator it = parameterList.begin();
+    ParameterList::const_iterator end = parameterList.end();
+    for(int i = 0; i < argc && it != end; i++, it++)
+    {
+      const std::string& parameter = *it;
+      int size = parameter.size();
+      argv[i] = new char[size + 1];
+      memcpy(argv[i], parameter.data(), size);
+      argv[i][size] = 0;
+    }
+  }
+
+  Arguments::~Arguments()
+  {
+    for(int i = 0; i < argc; i++)
+    {
+      delete[] argv[i];
+    }
+    delete[] argv;
+  }
+}
+
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/src/trace.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba/src/trace.cpp
index a7e694ea..03fadc0b 100644
--- a/SelfServiceCommon/Massai/cpp/MassaiCorba/src/trace.cpp
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/src/trace.cpp
@@ -14,238 +14,90 @@
 //
 //---------------------------------------------------------------------------
 
-#include <iostream>
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdarg.h>
-#include <string.h>
-#include <time.h>
-#include <sys/types.h>
-#include <sys/timeb.h>
-#include <windows.h>
-
+#include "tools/TraceSetLevelDelegate.h"
+#include "tools/TraceSystem.h"
 #include "tracedef.h"
 
-#define MAX_TRACE_BUF (1024L * 32L)
-
-static int traceLevel = 0;
-
-//---------------------------------------------------------------------------
-//
-//  function:   long setLevel(long level)
-//
-//  purpose:    set new trace level and return the old one
-//
-//  date:       12.04.2001, 12:46
-//
-//  author:     Materna Information & Communications (AGe)
-//
-//---------------------------------------------------------------------------
-
-long setLevel(long level)
-{
-long oldLevel = traceLevel;
-
-    if(level >= 0)
-    {
-      traceLevel = level;
-      return(oldLevel);
-    }
-    else
-      return(-1);
-}
+#include <stdarg.h>
+#include <stdio.h>
 
-//---------------------------------------------------------------------------
-//
-//  function:   void trace(long lLevel,char *pszFile,long sLine,char *pszFormat, ...)
-//
-//  purpose:    trace function
-//
-//  date:       12.04.2001, 12:47
-//
-//  author:     Materna Information & Communications (AGe)
-//
-//---------------------------------------------------------------------------
+using MASSAI::trace::TraceSetLevelDelegate;
+using MASSAI::trace::TraceSystem;
 
-void trace(long lLevel,char *pszFile,long sLine,char *pszFormat, ...)
+namespace
 {
-long     rc = 0;
-long     ulLen;
-long     ulDump;
-long     ulTmp;
-char     *pTmp;
-char     *pArg;
-char     *pStr;
-char      szFile[256];
-
-va_list       arg_ptr;
-time_t        ltime;
-struct  tm   *today;
-struct _timeb tstruct;
-
-    if(lLevel <= traceLevel || lLevel == 255)
+  enum Constants
+  {
+    BUFFERSIZE = (1024L * 32L),
+  };
+
+  TraceSetLevelDelegate* pTraceDelegate;
+  TraceSystem* pTrace;
+  TraceSetLevelDelegate& getTrace()
+  {
+    if(pTraceDelegate == 0)
     {
-
-      time(&ltime);
-      _ftime(&tstruct);
-
-      today = localtime(&ltime);
-
-      if((pTmp = (char*) malloc(MAX_TRACE_BUF)) == NULL)
-        return;
-
-      /* write traces with date and time */
-
-      memset(pTmp,0,MAX_TRACE_BUF);
-
-      ulLen = ulTmp = 0;
-
-      ulLen += sprintf(pTmp + ulLen,"%02d%02d %02d%02d:%02d.%02d ",
-                                    today->tm_mday,
-                                    today->tm_mon,
-                                    today->tm_hour,
-                                    today->tm_min,
-                                    today->tm_sec,
-                                    tstruct.millitm /10);
-
-      /* check given arguments */
-
-      if(pszFile && pszFormat)
-      {
-        strcpy(szFile,pszFile);
-
-        // cut path from file name
-
-        if((pStr = strrchr(szFile,'\\')) != NULL)
-          strcpy(szFile,pStr +1);
-
-        // cut file name extension
-
-        if((pStr = strrchr(szFile,'.')) != NULL)
-          *pStr = '\0';
-
-        ulLen += sprintf(pTmp + ulLen,"%-16s(%4d): ",szFile,sLine);
-
-        if(*pszFormat == '%' && *(pszFormat +1) == 'T')
-        {
-          // comes from mTrace.dump() -> copy only !!
-
-          va_start(arg_ptr,pszFormat);
-
-          // get pointer to first argument
-
-          pArg = (char *)va_arg(arg_ptr,char*);
-
-          // get length of dump
-
-          ulDump = (long) va_arg(arg_ptr,long);
-
-          /* copy to buffer */
-
-          strcpy(pTmp + ulLen,pArg);
-
-          ulLen += ulDump;
-
-          va_end(arg_ptr);
-        }
-        else
-        {
-          /* get pointer to first argument */
-
-          va_start(arg_ptr,pszFormat);
-
-          /* print into buffer */
-
-          ulLen += vsprintf(pTmp + ulLen,pszFormat,arg_ptr);
-
-          va_end(arg_ptr);
-        }
-
-        ulLen += sprintf(pTmp + ulLen,"\n");
-      }
-      else
-        ulLen = sprintf(pTmp,"<< INVALID TRACE >>");
-
-      *(pTmp + ulLen) = '\0';
-
-      if(ulTmp)
-      {
-        OutputDebugString((char *)(pTmp + ulTmp));
-      }
-      else
-      {
-        OutputDebugString((char *)pTmp);
-      }
-
-      free(pTmp);
+      pTrace = new TraceSystem("mCorba");
+      pTraceDelegate = new TraceSetLevelDelegate(5, true, pTrace);
     }
-
-    return;
+    return *pTraceDelegate;
+  }
 }
 
-//---------------------------------------------------------------------------
-//
-//  function:   void dump(long lLevel,char *pszFile,long sLine,char *pData,long usLen)
-//
-//  purpose:    dump function (using trace function)
-//
-//  date:       12.04.2001, 12:47
-//
-//  author:     Materna Information & Communications (AGe)
-//
-//---------------------------------------------------------------------------
-
-void dump(long lLevel,char *pszFile,long sLine,char *pData,long usLen)
+namespace massaiCorba
 {
-long   i,j;
-long   rc;
-char  *pTmp;
-long   ulSize;
-
-    if(lLevel <= traceLevel || lLevel == 255)
-    {
-      ulSize = ((usLen >> 4) +1) * 80;
-
-      if(!pData || !usLen || ulSize > MAX_TRACE_BUF -128)
-        return;
-
-      if((pTmp = (char*) malloc(ulSize)) == NULL) // XXX
-        return;
-
-      rc = sprintf(pTmp,"%c",'\n');
-
-      for(i = 0; i < usLen; i += 16)
-      {
-        rc += sprintf(pTmp +rc,"[%04x,%04d] ",i,i);
-
-        for(j = 0; j < 16 && (i+j) < usLen; j++)
-        {
-          if(j == 8)
-            rc += sprintf(pTmp + rc,"- %02x ",(unsigned char)(pData)[i+j]);
-          else
-            rc += sprintf(pTmp + rc,"%02x ",(unsigned char)(pData[i+j]));
-        }
-
-        while(j < 16)
-        {
-          if(j == 8)
-            rc += sprintf(pTmp + rc,"     ");
-          else
-            rc += sprintf(pTmp + rc,"   ");
-
-          j++;
-        }
-
-        for(j = 0; j < 16 && (i+j) < usLen; j++)
-          rc += sprintf(pTmp + rc,"%c",(pData[i+j] >= ' ') ? pData[i+j]: '.');
-
-        rc += sprintf(pTmp + rc,"\n");
-      }
-
-      trace(lLevel,pszFile,sLine,"%T",pTmp,rc);
-
-      free(pTmp);
-    }
-
-    return;
+  //---------------------------------------------------------------------------
+  //
+  //  function:   long setLevel(long level)
+  //
+  //  purpose:    set new trace level and return the old one
+  //
+  //  date:       12.04.2001, 12:46
+  //
+  //  author:     Materna Information & Communications (AGe)
+  //
+  //---------------------------------------------------------------------------
+  long setLevel(long level)
+  {
+    getTrace().setTraceLevel(level);
+    return 0;
+  }
+
+  //---------------------------------------------------------------------------
+  //
+  //  function:   void trace(long lLevel,char *pszFile,long sLine,char *pszFormat, ...)
+  //
+  //  purpose:    trace function
+  //
+  //  date:       12.04.2001, 12:47
+  //
+  //  author:     Materna Information & Communications (AGe)
+  //
+  //---------------------------------------------------------------------------
+  void trace(long lLevel, const char *pszFile, long sLine, const char* pszFunction, const char* pszFormat, ...)
+  {
+    va_list arg_ptr;
+    va_start(arg_ptr, pszFormat);
+    char buffer[BUFFERSIZE];
+    _vsnprintf(buffer, sizeof(buffer), pszFormat, arg_ptr);
+    buffer[sizeof(buffer)-1]= 0;
+    getTrace().writeTraceText(lLevel, pszFile, sLine, pszFunction, buffer);
+    va_end(arg_ptr);
+  }
+
+  //---------------------------------------------------------------------------
+  //
+  //  function:   void dump(long lLevel,char *pszFile,long sLine,char *pData,long usLen)
+  //
+  //  purpose:    dump function (using trace function)
+  //
+  //  date:       12.04.2001, 12:47
+  //
+  //  author:     Materna Information & Communications (AGe)
+  //
+  //---------------------------------------------------------------------------
+  void dump(long lLevel, const char* pszFile, long sLine, const char* pszFunction, const char* pData, long usLen)
+  {
+    getTrace().dumpTrace(lLevel, pszFile, sLine, pszFunction, usLen, pData);
+  }
 }
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/static/makefile.mak b/SelfServiceCommon/Massai/cpp/MassaiCorba/static/makefile.mak
index 6603a3d3..8131ab5b 100644
--- a/SelfServiceCommon/Massai/cpp/MassaiCorba/static/makefile.mak
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/static/makefile.mak
@@ -7,28 +7,30 @@
 !include $(BUILDROOT)\Build\cpp\makefile.common.mak
 
 MY_CFLAGS = \
-    -Gi -GR -G5 -Gy \
+    -GR -Gy \
     -DTAO_AS_STATIC_LIBS -DACE_AS_STATIC_LIBS \
     -I$(P_INC) \
     $(INC_ACETAO) \
+    $(INC_BOOST) \
     $(INC_INTERFACES)
 
 MY_RCFLAGS = \
     -I$(P_INC)
 
-
 MY_LIB1 = $(LIB_DST_MCORBAS)
 
 MY_LIB1_OBJS = \
+    $(_OBJ)\corbaorb.obj \
     $(_OBJ)\corbacfg.obj \
     $(_OBJ)\corbaclnt.obj \
-    $(_OBJ)\corbaorb.obj \
-    $(_OBJ)\corbaorbcfg.obj \
-    $(_OBJ)\corbaorbEx.obj \
     $(_OBJ)\corbasrvr.obj \
     $(_OBJ)\iorparser.obj \
-    $(_OBJ)\Realtime.obj \
+    $(_OBJ)\realtime.obj \
     $(_OBJ)\trace.obj \
-    $(_OBJ)\corbapoll.obj
+    $(_OBJ)\corbapoll.obj \
+    $(_OBJ)\orbContainer.obj \
+    $(_OBJ)\orbimpl.obj \
+    $(_OBJ)\envSettings.obj \
+    $(_OBJ)\tools.obj
 
 !include $(BUILDROOT)\Build\cpp\makefile.rules.mak
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/test/inc/testcase_common.h b/SelfServiceCommon/Massai/cpp/MassaiCorba/test/inc/testcase_common.h
new file mode 100644
index 00000000..823353d6
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/test/inc/testcase_common.h
@@ -0,0 +1,49 @@
+// common implementation for testcases
+#ifndef TESTCASE_COMMON_H_INCLUDED
+#define TESTCASE_COMMON_H_INCLUDED
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "test.h"
+#include "test_skel.h"
+#include "text/mArgScan.hpp"
+#include "systools/mMutexCS.h"
+#include <string>
+#include <list>
+
+namespace massaiCorba
+{
+  typedef std::list<CorbaTest::callback_ptr> CallbackList;
+  class TestServant: public POA_CorbaTest::test
+  {
+    public:
+      TestServant(const std::string& id);
+      CORBA::Long doit();
+      CORBA::Long say(const char* s);
+      CORBA::Long setListener(CorbaTest::callback_ptr listener);
+      CORBA::Long rmvListener(CorbaTest::callback_ptr listener);
+      void setORB(CORBA::ORB_ptr orb);
+
+    private:
+      Materna::MSSD::Mutex m_access;
+      std::string m_id;
+      CallbackList m_listener;
+      CORBA::ORB_ptr m_orb;
+  };
+
+  class TestCallbackServant: public POA_CorbaTest::callback
+  {
+    public:
+      TestCallbackServant(const std::string& id);
+      void callClient();
+    private:
+      std::string m_id;
+  };
+
+  std::string option(argScan& args, const std::string& key, const std::string& defaultValue);
+  long setLevel(long level);
+}
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/test/makefile.mak b/SelfServiceCommon/Massai/cpp/MassaiCorba/test/makefile.mak
index 3925b1ba..afe87155 100644
--- a/SelfServiceCommon/Massai/cpp/MassaiCorba/test/makefile.mak
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/test/makefile.mak
@@ -7,16 +7,14 @@
 !include $(BUILDROOT)\Build\cpp\makefile.common.mak
 
 MY_CFLAGS = \
-    -Gi -GR \
-    -DCHECKED_NARROW  \
+    -GR \
+#    -DCHECKED_NARROW  \
     $(INC_INTERFACES) \
     $(INC_ACETAO)
 
 STDUSERLIBS = \
-    $(LIB_MASSAI) \
     $(LIB_MCORBA) \
-    $(LIB_MCFGCLNT) \
-    $(LIB_TRACE)
+    $(LIB_MSYSTOOLS)
 
 STDLINKLIBS = \
     $(SYS_ACETAO)
@@ -24,12 +22,13 @@ STDLINKLIBS = \
 ######################################################################
 
 MY_BIN1 = \
-    $(_BIN)\tclt.exe
+    $(_BIN)\mCorba_testcase_srv1.exe
 
 MY_BIN1_OBJS = \
-    $(_OBJ)\tclt.obj \
+    $(_OBJ)\testcase_srv1.obj \
     $(_OBJ)\test_skel.obj \
-    $(_OBJ)\test.obj
+    $(_OBJ)\test.obj \
+    $(_OBJ)\testcase_common.obj
     
 MY_BIN1_USER_LIBS = \
     $(STDUSERLIBS)
@@ -40,12 +39,13 @@ MY_BIN1_LINKLIBS = \
 ######################################################################
 
 MY_BIN2 = \
-    $(_BIN)\tsrv.exe
+    $(_BIN)\mCorba_testcase1_clnt1.exe
 
 MY_BIN2_OBJS = \
-    $(_OBJ)\tsrv.obj \
+    $(_OBJ)\testcase1_clnt1.obj \
     $(_OBJ)\test_skel.obj \
-    $(_OBJ)\test.obj
+    $(_OBJ)\test.obj \
+    $(_OBJ)\testcase_common.obj
 
 MY_BIN2_USER_LIBS = \
     $(STDUSERLIBS)
@@ -56,13 +56,14 @@ MY_BIN2_LINKLIBS = \
 ######################################################################
 
 MY_BIN3 = \
-    $(_BIN)\testclnt.exe
+    $(_BIN)\mCorba_testcase2_clnt1.exe
 
 MY_BIN3_OBJS = \
-    $(_OBJ)\testclnt.obj \
+    $(_OBJ)\testcase2_clnt1.obj \
     $(_OBJ)\test_skel.obj \
-    $(_OBJ)\test.obj
-    
+    $(_OBJ)\test.obj \
+    $(_OBJ)\testcase_common.obj
+
 MY_BIN3_USER_LIBS = \
     $(STDUSERLIBS)
 
@@ -72,12 +73,13 @@ MY_BIN3_LINKLIBS = \
 ######################################################################
 
 MY_BIN4 = \
-    $(_BIN)\testsrvr.exe
+    $(_BIN)\mCorba_testcase2_clnt2.exe
 
 MY_BIN4_OBJS = \
-    $(_OBJ)\testsrvr.obj \
+    $(_OBJ)\testcase2_clnt2.obj \
     $(_OBJ)\test_skel.obj \
-    $(_OBJ)\test.obj
+    $(_OBJ)\test.obj \
+    $(_OBJ)\testcase_common.obj
 
 MY_BIN4_USER_LIBS = \
     $(STDUSERLIBS)
@@ -88,47 +90,19 @@ MY_BIN4_LINKLIBS = \
 ######################################################################
 
 MY_BIN5 = \
-    $(_BIN)\stclt.exe
+    $(_BIN)\mCorba_testcase3_clnt1.exe
 
 MY_BIN5_OBJS = \
-    $(_OBJ)\stclt.obj \
-    $(_OBJ)\test_skel.obj \
-    $(_OBJ)\test.obj
-    
-MY_BIN5_LINKLIBS = \
-    $(SYS_ACETAO) 
-
-######################################################################
-
-MY_BIN6 = \
-    $(_BIN)\cbclt.exe
-
-MY_BIN6_OBJS = \
-    $(_OBJ)\cbclt.obj \
+    $(_OBJ)\testcase3_clnt1.obj \
     $(_OBJ)\test_skel.obj \
-    $(_OBJ)\test.obj
+    $(_OBJ)\test.obj \
+    $(_OBJ)\testcase_common.obj
 
-MY_BIN6_USER_LIBS = \
+MY_BIN5_USER_LIBS = \
     $(STDUSERLIBS)
 
-MY_BIN6_LINKLIBS = \
+MY_BIN5_LINKLIBS = \
     $(STDLINKLIBS)
 
-######################################################################
-
-MY_BIN7 = \
-    $(_BIN)\cbsrv.exe
-
-MY_BIN7_OBJS = \
-    $(_OBJ)\cbsrv.obj \
-    $(_OBJ)\test_skel.obj \
-    $(_OBJ)\test.obj
-
-MY_BIN7_USER_LIBS = \
-    $(STDUSERLIBS)
-
-MY_BIN7_LINKLIBS = \
-    $(STDLINKLIBS)
-    
 ######################################################################
 !include $(BUILDROOT)\Build\cpp\makefile.rules.mak
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/cbclt.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/cbclt.cpp
deleted file mode 100644
index 2781dc9d..00000000
--- a/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/cbclt.cpp
+++ /dev/null
@@ -1,105 +0,0 @@
-//---------------------------------------------------------------------------
-//
-//  file:       cbclt.cpp
-//
-//  purpose:
-//
-//  date:       25.07.2007
-//
-//  author:     Materna Information & Communications (SteT)
-//
-//---------------------------------------------------------------------------
-
-#include "massaiCorba/corbaclnt.h"
-#include "test.h"
-#include "test_skel.h"
-
-#include <iostream>
-#include <windows.h>
-
-using namespace CorbaTest;
-
-class TestServant : public POA_CorbaTest::callback
-{
-  public:
-    void callClient()
-    {
-       std::cout << ".";
-    }
-};
-
-
-int main(int argc, char** argv)
-{
-  char* host;
-  if(argc > 1)
-    host= argv[1];
-  else
-    host= "127.0.0.1";
-  for(;;)
-  {
-    try
-    {
-      std::cout << std::endl << "connect..." << std::endl;
-      TestServant myCBServant;
-      callback_var listener= myCBServant._this();
-      corbaCallbackClient<hello> clt(host, 30000, "TestServant");
-      hello* proxy= clt.proxy();
-      if(proxy != 0)
-      {
-        std::cout << "connect done." << std::endl;
-        try
-        {
-          proxy->setListener(listener);
-        }
-        catch(const CORBA::Exception& ex)
-        {
-          std::cout << std::endl << "setListener: " << ex._message() << std::endl;
-        }
-        catch(...)
-        {
-          std::cout << std::endl << "setListener: unknown exception" << std::endl;
-        }
-        try
-        {
-          CorbaTest::mString x;
-          x.in1 = CORBA::string_dup("in1");
-          x.in2 = CORBA::string_dup("in2");
-          proxy->say(x);
-        }
-        catch(const CORBA::Exception& ex)
-        {
-          std::cout << std::endl << "say: " << ex._message() << std::endl;
-        }
-        catch(...)
-        {
-          std::cout << std::endl << "say: unknown exception" << std::endl;
-        }
-        try
-        {
-          proxy->rmvListener(listener);
-        }
-        catch(const CORBA::Exception& ex)
-        {
-          std::cout << std::endl << "rmvListener: " << ex._message() << std::endl;
-        }
-        catch(...)
-        {
-          std::cout << std::endl << "rmvListener: unknown exception" << std::endl;
-        }
-        std::cout << ",";
-        //Sleep(1000);
-      }
-    }
-    catch(const CORBA::Exception& ex)
-    {
-      std::cout << std::endl << "connect: " << ex._message() << std::endl;
-    }
-    catch(...)
-    {
-      std::cout << std::endl << "connect: unknown exception" << std::endl;
-    }
-    //Sleep(1000);
-  }
-  return 0;
-}
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/cbsrv.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/cbsrv.cpp
deleted file mode 100644
index 3d530281..00000000
--- a/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/cbsrv.cpp
+++ /dev/null
@@ -1,70 +0,0 @@
-//---------------------------------------------------------------------------
-//
-//  file:       cbsrv.cpp
-//
-//  purpose:
-//
-//  date:       25.07.2007
-//
-//  author:     Materna Information & Communications (SteT)
-//
-//---------------------------------------------------------------------------
-
-#include "massaiCorba/corbasrvr.h"
-#include "test_skel.h"
-
-#include <iostream>
-#include <windows.h>
-
-using namespace CorbaTest;
-
-class testServant : public POA_CorbaTest::hello
-{
-  public:
-    CORBA::Long  say(const struct CorbaTest::mString& x)
-    {
-      if(!CORBA::is_nil(listener))
-      {
-        listener->callClient();
-      }
-      return 0;
-    }
-    CORBA::Long  setListener(callback_ptr li)
-    {
-      listener= li->_duplicate(li);
-      return 0;
-    }
-    CORBA::Long  rmvListener(callback_ptr li)
-    {
-      CORBA::release(listener);
-      listener= 0;
-      return 0;
-    }
-  private:
-    CorbaTest::callback_ptr listener;
-
-};
-
-int main(int argc, char** argv)
-{
-  try
-  {
-    std::cout << std::endl << "create servant..." << std::endl;
-    testServant srvnt;
-    corbaServantEx<testServant> corbaSrvnt(10, srvnt, "TestServant", 30000);
-    //std::cout << "create servant done." << corbaSrvnt.ior("TestServant") << std::endl;
-    for(;;)
-    {
-      Sleep(20000);
-    }
-  }
-  catch(const CORBA::Exception& ex)
-  {
-    std::cout << std::endl << ex._message() << std::endl;
-  }
-  catch(...)
-  {
-    std::cout << std::endl << "unknown exception" << std::endl;
-  }
-  return 0;
-}
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/stclt.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/stclt.cpp
deleted file mode 100644
index 4e8097fb..00000000
--- a/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/stclt.cpp
+++ /dev/null
@@ -1,25 +0,0 @@
-#include "test.h"
-#include <iostream>
-#include <windows.h>
-
-int main (int argc, char *argv[])
-{
-  try
-  {
-    CORBA::ORB_var orb = CORBA::ORB_init (argc, argv);
-    for(;;)
-    {
-      CORBA::Object_var tmp = orb->string_to_object("corbaloc:iiop:isengart:30000/TestServant");
-      CorbaTest::test_var hello = CorbaTest::test::_narrow(tmp.in ());
-      std::cout << ",";
-      // hello->doit ();
-    }
-    orb->destroy ();
-  }
-  catch (const CORBA::Exception& ex)
-  {
-    ex._tao_print_exception ("Exception caught:");
-    return 1;
-  }
-  return 0;
-}
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/tclt.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/tclt.cpp
deleted file mode 100644
index 16b153a2..00000000
--- a/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/tclt.cpp
+++ /dev/null
@@ -1,108 +0,0 @@
-//---------------------------------------------------------------------------
-//
-//  file:       tclt.cpp
-//
-//  purpose:
-//
-//  date:       12.04.2006
-//
-//  author:     Materna Information & Communications (SteT)
-//
-//---------------------------------------------------------------------------
-
-#include "massaiCorba/corbaclnt.h"
-#include "test.h"
-#include "test_skel.h"
-
-#include <iostream>
-#include <windows.h>
-
-using namespace CorbaTest;
-
-long setLevel(long level);
-
-
-class testServant : public POA_CorbaTest::callback
-{
-public:
-
-    int j;
-    void callClient()
-    {
-       j++;
-       if(j%32 == 0)
-         std::cout << ":";
-    }
-};
-
-int main(int argc, char** argv)
-{
-  setLevel(9);
-  char* host;
-  if(argc > 1)
-    host= argv[1];
-  else
-    host= "127.0.0.1";
-  //corbaClient<test> cltd(host, 30000, "TestServant");
-  //test* proxyd= cltd.proxy();
-
-  for(;;)
-  {
-    int i;
-    try
-    {
-      std::cout << std::endl << "connect..." << std::endl;
-      corbaCallbackClient<test> clt(host, 30000, "TestServant");
-      //corbaClient<test> clt(host, 30000, "TestServant");
-      test* proxy= clt.proxy();
-      testServant  servant; // callback servant
-      if(proxy != 0)
-      {
-        std::cout << "connect done." << std::endl;
-        try
-        {
-          callback_var myservant= servant._this();
-          proxy->setListener(myservant);
-          //for(;;)
-          {
-            //proxy->setListener(myservant);
-            //proxy->setListener(servant._this()); // memory leak
-            CORBA::String_var s = CORBA::string_dup("Hello");
-            proxy->say(s);
-//            CORBA::PolicyList_var inconsistent_policies;
-//            proxy->_validate_connection(inconsistent_policies);
-/*
-      CORBA::PolicyList_out inconsistent_policies
-      ACE_ENV_ARG_DECL_WITH_DEFAULTS);
-*/
-
-            //proxy->say(s);
-            i++;
-            if(i%32 ==  0)
-              std::cout << ",";
-            Sleep(1);
-          }
-          //proxy->rmvListener(myservant);
-        }
-        catch(const CORBA::Exception& ex)
-        {
-          std::cout << std::endl << "doit: " << ex._message() << std::endl;
-        }
-        catch(...)
-        {
-          std::cout << std::endl << "doit: unknown exception" << std::endl;
-        }
-      }
-    }
-    catch(const CORBA::Exception& ex)
-    {
-      std::cout << std::endl << "connect: " << ex._message() << std::endl;
-    }
-    catch(...)
-    {
-      std::cout << std::endl << "connect: unknown exception" << std::endl;
-    }
-    Sleep(1);
-  }
-  return 0;
-}
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcase1_clnt1.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcase1_clnt1.cpp
new file mode 100644
index 00000000..270fa912
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcase1_clnt1.cpp
@@ -0,0 +1,98 @@
+// testcase1
+#include "massaiCorba/corbaclnt.h"
+#include "test.h"
+#include "testcase_common.h"
+#include "text/mArgScan.hpp"
+#include "tools/localtrace.h"
+#include <iostream>
+
+using namespace CorbaTest;
+using namespace MASSAI::localtrace;
+using namespace massaiCorba;
+
+namespace
+{
+  void printUsage(int argc, char** argv, char* error= 0)
+  {
+    std::cout << std::endl;
+    std::cout << argv[0];
+    std::cout << " [-host:<remoteServantHost, default localhost>]";
+    std::cout << " [-port:<remoteservantPort, default 10100>]";
+    std::cout << " [-servant:<remoteServantName, default TestServant>]";
+    std::cout << " [-create:<number of client creations, default 5>]";
+    std::cout << " [-send:<number of client invocations, default 5>]";
+    std::cout << std::endl;
+    if(error)
+    {
+      std::cout << error << std::endl;
+    }
+    else
+    {
+      std::cout << "repeated create and destroy corba clients" << std::endl;
+    }
+  }
+}
+
+int main(int argc, char** argv)
+{
+  int result = 0;
+  argScan args(argc, argv);
+  std::string host= option(args, "HOST", "localhost");
+  std::string servant= option(args, "SERVANT", "TestServant");
+  int port = args.optionInteger("PORT", 10100);
+  int create = args.optionInteger("CREATE", 5);
+  int send = args.optionInteger("SEND", 5);
+  if(args.help())
+  {
+    printUsage(argc, argv);
+    result= 1;
+  }
+  else
+  {
+    openTrace(argv[0]);
+    massaiCorba::setLevel(9);
+    for(int i = 0; i < create; i++)
+    {
+      try
+      {
+        writeTrace(BasicRuntime_HERE, "create client (%d) (%s:%d/%s)", i, host.c_str(), port, servant.c_str());
+        corbaClient<test> clt(host.c_str(), port, servant.c_str());
+        test* clientProxy = clt.proxy();
+        if(clientProxy != 0)
+        {
+          for(int j= 0; j < send; j++)
+          {
+            writeTrace(BasicRuntime_HERE, "call say (%d) (%d)", i, j);
+            try
+            {
+              CORBA::String_var hello = CORBA::string_dup("Hello");
+              clientProxy->say(hello);
+            }
+            catch(const CORBA::Exception& ex)
+            {
+              writeTrace(MajorError_HERE, "call say failed (%s)", ex._message());
+            }
+            catch(...)
+            {
+              writeTraceText(MajorError_HERE, "call say failed");
+            }
+          }
+        }
+        else
+        {
+          writeTraceText(MajorError_HERE, "client proxy ist null");
+        }
+      }
+      catch(const CORBA::Exception& ex)
+      {
+        writeTrace(MajorError_HERE, "create client failed (%s)", ex._message());
+      }
+      catch(...)
+      {
+        writeTraceText(MajorError_HERE, "create client failed");
+      }
+    }
+    closeTrace();
+  }
+  return result;
+}
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcase2_clnt1.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcase2_clnt1.cpp
new file mode 100644
index 00000000..f08bc4a4
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcase2_clnt1.cpp
@@ -0,0 +1,92 @@
+// testcase1
+#include "massaiCorba/corbaclnt.h"
+#include "massaiCorba/corbasrvr.h"
+#include "sysTools/mSysProcessTerminate.h"
+#include "test.h"
+#include "testcase_common.h"
+#include "text/mArgScan.hpp"
+#include "tools/localtrace.h"
+#include "tools/TraceLocal.h"
+#include <iostream>
+
+using namespace CorbaTest;
+using namespace MASSAI::localtrace;
+using namespace massaiCorba;
+using namespace mSysProcessTerminate;
+
+namespace
+{
+  void printUsage(int argc, char** argv, char* error= 0)
+  {
+    std::cout << std::endl;
+    std::cout << argv[0];
+    std::cout << " [-remotehost:<remoteServantHost, default localhost>]";
+    std::cout << " [-remoteport:<remoteServantPort, default 10100>]";
+    std::cout << " [-remoteservant:<remoteServantName, default TestServant>]";
+    std::cout << " [-localhost:<localservantHost, default localhost>]";
+    std::cout << " [-localport:<localservantPort, default 10101>]";
+    std::cout << " [-localservant:<localServantName, default TestServant1>]";
+    std::cout << " [-threads:<number of servant processing threads, default 5>]";
+    std::cout << std::endl;
+    if(error)
+    {
+      std::cout << error << std::endl;
+    }
+    else
+    {
+      std::cout << "repeated create and destroy corba clients" << std::endl;
+    }
+  }
+}
+
+int main(int argc, char** argv)
+{
+  int result = 0;
+  argScan args(argc, argv);
+  std::string host1 = option(args, "REMOTEHOST", "localhost");
+  std::string host2 = option(args, "LOCALHOST", "localhost");
+  std::string servant1 = option(args, "REMOTESERVANT", "TestServant1");
+  std::string servant2 = option(args, "LOCALSERVANT", "TestServant2");
+  int threadcount = args.optionInteger("THREADS", 5);
+  int port1 = args.optionInteger("REMOTEPORT", 10101);
+  int port2 = args.optionInteger("LOCALPORT", 10102);
+  if(args.help())
+  {
+    printUsage(argc, argv);
+    result= 1;
+  }
+  else
+  {
+    openTrace(argv[0]);
+    MASSAI::trace::TraceLocal trc(argv[0]);
+    Materna::MSSD::eventSemaphore terminate;
+    setShutdownHook(SHUTDOWN_NORMAL, &terminate, &trc);
+    massaiCorba::setLevel(9);
+    try
+    {
+      writeTrace(BasicRuntime_HERE, "create servant (%s:%d/%s)", host2.c_str(), port2, servant2.c_str());
+      TestServant srvnt("S1");
+      corbaServantEx<TestServant> corbaSrvnt(threadcount, srvnt, servant2.c_str(), host2.c_str(), port2);
+
+      writeTrace(BasicRuntime_HERE, "create client (%s:%d/%s)", host1.c_str(), port1, servant1.c_str());
+      corbaCallbackClient<test> clt(host1.c_str(), port1, servant1.c_str());
+      test* clientProxy = clt.proxy();
+
+      writeTraceText(MajorError_HERE, "doit");
+      clientProxy->doit();
+
+      terminate.wait();
+    }
+    catch(const CORBA::Exception& ex)
+    {
+      writeTrace(MajorError_HERE, "failed (%s)", ex._message());
+    }
+    catch(...)
+    {
+      writeTraceText(MajorError_HERE, "failed");
+    }
+    resetShutdownHook();
+    closeTrace();
+  }
+  return result;
+}
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcase2_clnt2.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcase2_clnt2.cpp
new file mode 100644
index 00000000..219d016f
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcase2_clnt2.cpp
@@ -0,0 +1,181 @@
+// testcase1
+#include "massaiCorba/corbaclnt.h"
+#include "massaiCorba/corbasrvr.h"
+#include "sysTools/mSysProcessTerminate.h"
+#include "sysTools/mSysThread.hpp"
+#include "test.h"
+#include "testcase_common.h"
+#include "text/mArgScan.hpp"
+#include "tools/localtrace.h"
+#include "tools/TraceLocal.h"
+#include <iostream>
+#include <list>
+
+using namespace CorbaTest;
+using namespace MASSAI::localtrace;
+using namespace massaiCorba;
+using namespace mSysProcessTerminate;
+using namespace mSysThread;
+
+namespace
+{
+  class TestServantBlock: public TestServant
+  {
+    public:
+      TestServantBlock(Materna::MSSD::eventSemaphore& block, Materna::MSSD::eventSemaphore& terminate, const std::string& id):
+        TestServant(id),
+        m_block(block),
+        m_terminate(terminate)
+      {}
+
+      CORBA::Long doit()
+      {
+        m_block.post();
+        m_terminate.wait();
+        return 0;
+      }
+
+    private:
+      Materna::MSSD::eventSemaphore& m_block;
+      Materna::MSSD::eventSemaphore& m_terminate;
+  };
+
+  class StressClient: public thread
+  {
+    public:
+      StressClient(const std::string& host, int port, const std::string& servant, int invocationCall):
+        thread(0),
+        m_host(host),
+        m_port(port),
+        m_servant(servant),
+        m_invocationCall(invocationCall)
+      {}
+
+      void function()
+      {
+        try
+        {
+          writeTrace(BasicRuntime_HERE, "create client (%s:%d/%s)", m_host.c_str(), m_port, m_servant.c_str());
+          corbaCallbackClient<test> clt(m_host.c_str(), m_port, m_servant.c_str());
+          test* clientProxy = clt.proxy();
+
+          for(int i = 0; i < m_invocationCall; i++)
+          {
+            writeTraceText(MajorError_HERE, "doit");
+            clientProxy->doit();
+          }
+        }
+        catch(const CORBA::Exception& ex)
+        {
+          writeTrace(MajorError_HERE, "failed (%s)", ex._message());
+        }
+        catch(...)
+        {
+          writeTraceText(MajorError_HERE, "failed");
+        }
+      }
+
+    private:
+      std::string m_host;
+      int m_port;
+      std::string m_servant;
+      int m_invocationCall;
+  };
+  typedef std::list<StressClient*> ClientList;
+
+  void printUsage(int argc, char** argv, char* error= 0)
+  {
+    std::cout << std::endl;
+    std::cout << argv[0];
+    std::cout << " [-remotehost:<remoteServantHost, default localhost>]";
+    std::cout << " [-remoteport:<remoteServantPort, default 10100>]";
+    std::cout << " [-remoteservant:<remoteServantName, default TestServant>]";
+    std::cout << " [-localhost:<localservantHost, default localhost>]";
+    std::cout << " [-localport:<localservantPort, default 10101>]";
+    std::cout << " [-localservant:<localServantName, default TestServant1>]";
+    std::cout << " [-threads:<number of servant processing threads, default 5>]";
+    std::cout << " [-clients:<number of clients created, default 10>]";
+    std::cout << " [-calls:<number of calls a clients invokes, default 10>]";
+    std::cout << std::endl;
+    if(error)
+    {
+      std::cout << error << std::endl;
+    }
+    else
+    {
+      std::cout << "repeated create and destroy corba clients" << std::endl;
+    }
+  }
+}
+
+int main(int argc, char** argv)
+{
+  int result = 0;
+  argScan args(argc, argv);
+  std::string host1 = option(args, "REMOTEHOST", "localhost");
+  std::string host2 = option(args, "LOCALHOST", "localhost");
+  std::string servant1 = option(args, "REMOTESERVANT", "TestServant2");
+  std::string servant2 = option(args, "LOCALSERVANT", "TestServant1");
+  int threadcount = args.optionInteger("THREADS", 5);
+  int port1 = args.optionInteger("REMOTEPORT", 10102);
+  int port2 = args.optionInteger("LOCALPORT", 10101);
+  int clients = args.optionInteger("CLIENTS", 10);
+  int calls = args.optionInteger("CALLS", 10);
+  if(args.help())
+  {
+    printUsage(argc, argv);
+    result= 1;
+  }
+  else
+  {
+    openTrace(argv[0]);
+    MASSAI::trace::TraceLocal trc(argv[0]);
+    Materna::MSSD::eventSemaphore terminate;
+    Materna::MSSD::eventSemaphore block;
+    setShutdownHook(SHUTDOWN_NORMAL, &terminate, &trc);
+    massaiCorba::setLevel(9);
+    try
+    {
+      writeTrace(BasicRuntime_HERE, "create servant (%s:%d/%s)", host2.c_str(), port2, servant2.c_str());
+      TestServantBlock srvnt(block, terminate, "S1");
+      corbaServantEx<TestServant> corbaSrvnt(threadcount, srvnt, servant2.c_str(), host2.c_str(), port2);
+
+      block.wait();
+
+      ClientList clientList;
+      for(int i = 0; i < clients; i++)
+      {
+        clientList.push_back(new StressClient(host1, port1, servant1, calls));
+      }
+      {
+        ClientList::iterator it = clientList.begin();
+        ClientList::iterator end = clientList.end();
+        for(; it != end; it++)
+        {
+          (*it)->start();
+        }
+      }
+      terminate.wait();
+
+      {
+        ClientList::iterator it = clientList.begin();
+        ClientList::iterator end = clientList.end();
+        for(; it != end; it++)
+        {
+          delete *it;
+        }
+      }
+    }
+    catch(const CORBA::Exception& ex)
+    {
+      writeTrace(MajorError_HERE, "failed (%s)", ex._message());
+    }
+    catch(...)
+    {
+      writeTraceText(MajorError_HERE, "failed");
+    }
+    resetShutdownHook();
+    closeTrace();
+  }
+  return result;
+}
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcase3_clnt1.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcase3_clnt1.cpp
new file mode 100644
index 00000000..83a876ca
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcase3_clnt1.cpp
@@ -0,0 +1,119 @@
+// testcase1
+#include "massaiCorba/corbaclnt.h"
+#include "massaiCorba/corbasrvr.h"
+#include "sysTools/mSysProcessTerminate.h"
+#include "test.h"
+#include "testcase_common.h"
+#include "text/mArgScan.hpp"
+#include "tools/localtrace.h"
+#include "tools/TraceLocal.h"
+#include <iostream>
+
+using namespace CorbaTest;
+using namespace MASSAI::localtrace;
+using namespace massaiCorba;
+using namespace mSysProcessTerminate;
+
+namespace
+{
+  void printUsage(int argc, char** argv, char* error= 0)
+  {
+    std::cout << std::endl;
+    std::cout << argv[0];
+    std::cout << " [-host:<remoteServantHost, default localhost>]";
+    std::cout << " [-port:<remoteServantPort, default 10100>]";
+    std::cout << " [-servant:<remoteServantName, default TestServant>]";
+    std::cout << " [-host1:<servantHost1, default localhost>]";
+    std::cout << " [-port1:<servantPort1, default 10101>]";
+    std::cout << " [-servant1:<remoteServantName, default TestServant1>]";
+    std::cout << " [-host2:<servantHost2, default localhost>]";
+    std::cout << " [-port2:<servantPort2, default 10102>]";
+    std::cout << " [-servant2:<remoteServantName, default TestServant2>]";
+    std::cout << " [-threads:<number of servant processing threads, default 5>]";
+    std::cout << std::endl;
+    if(error)
+    {
+      std::cout << error << std::endl;
+    }
+    else
+    {
+      std::cout << "repeated create and destroy corba clients" << std::endl;
+    }
+  }
+}
+
+int main(int argc, char** argv)
+{
+  int result = 0;
+  argScan args(argc, argv);
+  std::string host  = option(args, "HOST",  "localhost");
+  std::string host1 = option(args, "HOST1", "localhost");
+  std::string host2 = option(args, "HOST2", "localhost");
+  std::string servant  = option(args, "SERVANT", "TestServant");
+  std::string servant1 = option(args, "SERVANT1", "TestServant1");
+  std::string servant2 = option(args, "SERVANT2", "TestServant2");
+  int threadcount = args.optionInteger("THREADS", 5);
+  int port  = args.optionInteger("PORT",  10100);
+  int port1 = args.optionInteger("PORT1", 10101);
+  int port2 = args.optionInteger("PORT2", 10102);
+  if(args.help())
+  {
+    printUsage(argc, argv);
+    result= 1;
+  }
+  else
+  {
+    openTrace(argv[0]);
+    MASSAI::trace::TraceLocal trc(argv[0]);
+    Materna::MSSD::eventSemaphore terminate;
+    setShutdownHook(SHUTDOWN_NORMAL, &terminate, &trc);
+    massaiCorba::setLevel(9);
+    try
+    {
+      TestCallbackServant callback1("CC1");
+      writeTrace(BasicRuntime_HERE, "create callback client (%s:%d/%s)", host.c_str(), port, servant.c_str());
+      corbaCallbackClient<test> clt1(host.c_str(), port, servant.c_str());
+      test* clientProxy1 = clt1.proxy();
+      writeTraceText(MajorError_HERE, "setListener");
+      clientProxy1->setListener(callback1._this());
+      writeTraceText(MajorError_HERE, "doit");
+      clientProxy1->doit();
+
+      TestServant srvnt1("S1");
+      corbaServantEx<TestServant> corbaSrvnt1(threadcount, srvnt1, servant1.c_str(), host1.c_str(), port1);
+
+      TestCallbackServant callback2("CC2");
+      writeTrace(BasicRuntime_HERE, "create callback client (%s:%d/%s)", host.c_str(), port, servant.c_str());
+      corbaCallbackClient<test> clt2(host.c_str(), port, servant.c_str());
+      test* clientProxy2 = clt2.proxy();
+      writeTraceText(MajorError_HERE, "setListener");
+      clientProxy2->setListener(callback2._this());
+      writeTraceText(MajorError_HERE, "doit");
+      clientProxy2->doit();
+
+      TestServant srvnt2("S2");
+      corbaServantEx<TestServant> corbaSrvnt2(threadcount, srvnt2, servant2.c_str(), host2.c_str(), port2);
+
+      TestCallbackServant callback3("CC3");
+      writeTrace(BasicRuntime_HERE, "create callback client (%s:%d/%s)", host.c_str(), port, servant.c_str());
+      corbaCallbackClient<test> clt3(host.c_str(), port, servant.c_str());
+      test* clientProxy3 = clt3.proxy();
+      writeTraceText(MajorError_HERE, "setListener");
+      clientProxy3->setListener(callback3._this());
+      writeTraceText(MajorError_HERE, "doit");
+      clientProxy3->doit();
+      terminate.wait();
+    }
+    catch(const CORBA::Exception& ex)
+    {
+      writeTrace(MajorError_HERE, "failed (%s)", ex._message());
+    }
+    catch(...)
+    {
+      writeTraceText(MajorError_HERE, "failed");
+    }
+    resetShutdownHook();
+    closeTrace();
+  }
+  return result;
+}
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcase_common.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcase_common.cpp
new file mode 100644
index 00000000..2f8836e7
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcase_common.cpp
@@ -0,0 +1,135 @@
+// common implementation for testcases
+#include "massaiCorba/iorparser.h"
+#include "massaiCorba/orbIncDefs.h"
+#include "sysTools/mAutoMutexCS.h"
+#include "testcase_common.h"
+#include "tools/localtrace.h"
+#include "tools/stringbuffer.h"
+
+using Materna::MSSD::AutoMutexCS;
+using namespace MASSAI::localtrace;
+using MASSAI::text::StringBuffer;
+
+namespace
+{
+  void writeTraceIOR(long lLevel, const char* pszFile, long lLine, const char* pszFunction, const char* context, const char* ior)
+  {
+    StringBuffer buf(ior);
+    writeTrace(lLevel, pszFile, lLine, pszFunction, "(%s): (%s)", context, ior);
+  };
+}
+
+namespace massaiCorba
+{
+  TestServant::TestServant(const std::string& id):
+    m_access(),
+    m_id(id),
+    m_listener(),
+    m_orb(0)
+  {}
+
+  CORBA::Long TestServant::doit()
+  {
+    writeTrace(BasicRuntime_HERE, "doit (%s)", m_id.c_str());
+    AutoMutexCS mx(m_access);
+    CallbackList::iterator it = m_listener.begin();
+    CallbackList::iterator end = m_listener.end();
+    for(; it != end; it++)
+    {
+      try
+      {
+        writeTrace(BasicRuntime_HERE, "callClient (%s)", m_id.c_str());
+        (*it)->callClient();
+      }
+      catch(const CORBA::Exception& ex)
+      {
+        writeTrace(MajorError_HERE, "callClient failed (%s) (%s)", m_id.c_str(), ex._message());
+      }
+      catch(...)
+      {
+        writeTrace(MajorError_HERE, "callClient failed (%s)", m_id.c_str());
+      }
+    }
+    return 0;
+  }
+
+  CORBA::Long TestServant::say(const char* s)
+  {
+    writeTrace(BasicRuntime_HERE, "say (%s) (%s)", m_id.c_str(), s);
+    return 0;
+  }
+
+  CORBA::Long TestServant::setListener(CorbaTest::callback_ptr listener)
+  {
+    writeTrace(BasicRuntime_HERE, "setListener (%s)", m_id.c_str());
+    if(listener && m_orb)
+    {
+      CORBA::String_var ior = m_orb->object_to_string(listener);
+      writeTraceIOR(BasicRuntime_HERE, "setListener", ior.in());
+    }
+    if(listener)
+    {
+      AutoMutexCS mx(m_access);
+      m_listener.push_back(listener->_duplicate(listener));
+      writeTrace(BasicRuntime_HERE, "setListener (%s) done", m_id.c_str());
+    }
+    return 0;
+  }
+
+  CORBA::Long TestServant::rmvListener(CorbaTest::callback_ptr listener)
+  {
+    writeTrace(BasicRuntime_HERE, "rmvListener (%s)", m_id.c_str());
+    if(listener && m_orb)
+    {
+      CORBA::String_var ior = m_orb->object_to_string(listener);
+      writeTraceIOR(BasicRuntime_HERE, "rmvListener", ior.in());
+    }
+    if(listener)
+    {
+      AutoMutexCS mx(m_access);
+      CallbackList::iterator it = m_listener.begin();
+      while(it != m_listener.end())
+      {
+        if((*it)->_is_equivalent(listener))
+        {
+          it = m_listener.erase(it);
+          writeTrace(BasicRuntime_HERE, "rmvListener (%s) done", m_id.c_str());
+        }
+        else
+        {
+          it++;
+        }
+      }
+    }
+    return 0;
+  }
+
+  void TestServant::setORB(CORBA::ORB_ptr orb)
+  {
+    m_orb = orb;
+  }
+
+  TestCallbackServant::TestCallbackServant(const std::string& id):
+    m_id(id)
+  {}
+
+  void TestCallbackServant::callClient()
+  {
+    writeTrace(BasicRuntime_HERE, "callback (%s)", m_id.c_str());
+  }
+
+  std::string option(argScan& args, const std::string& key, const std::string& defaultValue)
+  {
+    std::string result;
+    const char* value = args.option(key.c_str());
+    if(value)
+    {
+      result = value;
+    }
+    else
+    {
+      result = defaultValue;
+    }
+    return result;
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcase_srv1.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcase_srv1.cpp
new file mode 100644
index 00000000..7b8cf096
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcase_srv1.cpp
@@ -0,0 +1,81 @@
+// testcase1
+#include "massaiCorba/corbasrvr.h"
+#include "sysTools/mSysProcessTerminate.h"
+#include "test.h"
+#include "test_skel.h"
+#include "testcase_common.h"
+#include "text/mArgScan.hpp"
+#include "tools/localtrace.h"
+#include "tools/TraceLocal.h"
+#include <iostream>
+#include <map>
+
+using namespace CorbaTest;
+using namespace mSysProcessTerminate;
+using namespace MASSAI::localtrace;
+using namespace massaiCorba;
+
+namespace
+{
+  void printUsage(int argc, char** argv, char* error= 0)
+  {
+    std::cout << std::endl;
+    std::cout << argv[0];
+    std::cout << " [-host:<servantHost, default localhost>]";
+    std::cout << " [-port:<servantPort, default 10100>]";
+    std::cout << " [-servant:<servantName, default TestServant>]";
+    std::cout << " [-threads:<number of servant processing threads, default 5>]";
+    std::cout << std::endl;
+    if(error)
+    {
+      std::cout << error << std::endl;
+    }
+    else
+    {
+      std::cout << "testservant" << std::endl;
+    }
+  }
+}
+
+int main(int argc, char** argv)
+{
+  int result = 0;
+  argScan args(argc, argv);
+  std::string host= option(args, "HOST", "localhost");
+  std::string servant= option(args, "SERVANT", "TestServant");
+  int port = args.optionInteger("PORT", 10100);
+  int threadcount = args.optionInteger("THREADS", 5);
+  if(args.help())
+  {
+    printUsage(argc, argv);
+    result= 1;
+  }
+  else
+  {
+    openTrace(argv[0]);
+    MASSAI::trace::TraceLocal trc(argv[0]);
+    Materna::MSSD::eventSemaphore terminate;
+    setShutdownHook(SHUTDOWN_NORMAL, &terminate, &trc);
+    massaiCorba::setLevel(9);
+    try
+    {
+      writeTrace(BasicRuntime_HERE, "create servant (%s:%d/%s); threads(%d)", host.c_str(), port, servant.c_str(), threadcount);
+      TestServant srvnt("S1");
+      corbaServantEx<TestServant> corbaSrvnt(threadcount, srvnt, servant.c_str(), host.c_str(), port);
+      srvnt.setORB(corbaSrvnt.orb());
+      terminate.wait();
+      writeTraceText(MajorError_HERE, "terminate");
+    }
+    catch(const CORBA::Exception& ex)
+    {
+      writeTrace(MajorError_HERE, "create servant failed (%s)", ex._message());
+    }
+    catch(...)
+    {
+      writeTraceText(MajorError_HERE, "create servant failed");
+    }
+    resetShutdownHook();
+    closeTrace();
+  }
+  return result;
+}
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcases.txt b/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcases.txt
new file mode 100644
index 00000000..d1e04bf7
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testcases.txt
@@ -0,0 +1,27 @@
+Test cases:
+
+- Test case 1: create and destroy multiple clients
+    start mCorba_testcase_srv1.exe
+    start mCorba_testcase1_clnt1.exe
+
+    check for memory leak
+    check only one test client is created
+passed
+
+- Test case 3: client use first servant orb
+    start mCorba_testcase_srv1.exe
+    start mCorba_testcase2_clnt1.exe
+
+    check CC1 verwendet ClientORB 
+    check CC2 und CC3 verwenden 1. Servant ORB
+passed
+
+
+- Test case 2: Nested Upcalls
+    start mCorba_testcase2_clnt2
+    set environment CORBA_NO_NESTED_CALLS
+    start mCorba_testcase2_clnt1
+
+    check thread of client call is not used by servant calls
+
+passed
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testclnt.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testclnt.cpp
deleted file mode 100644
index b3d27208..00000000
--- a/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testclnt.cpp
+++ /dev/null
@@ -1,190 +0,0 @@
-//---------------------------------------------------------------------------
-//
-//  file:       testclnt.cpp
-//
-//  purpose:
-//
-//  date:       21.11.2001, 11:35
-//
-//  author:     Materna Information & Communications (AGe)
-//
-//---------------------------------------------------------------------------
-
-#include <conio.h>
-
-#include "massaiCorba/corbasrvr.h"
-#include "massaiCorba/corbaclnt.h"
-#include "massaiCorba/corbacfg.h"
-
-#include "test.h"
-
-#if !defined(_MICO_)
-#include "test_skel.h"
-#endif
-
-
-
-#define MCORBA
-#define TEST_HELLO
-#define TEST_DOIT
-
-using namespace CorbaTest;
-
-class testServant : public POA_CorbaTest::callback
-{
-public:
-
-    void callClient()
-    {
-       printf("server calls client, tid = 0x%0x\n",GetCurrentThreadId());
-    }
-};
-
-int main(int argc, char** argv)
-{
-#ifdef MCORBA
-
-char  *host   = "127.0.0.1";
-char  *sName1 = "corbaTest1";
-char  *sName2 = "corbaTest2";
-long   port1  = 30001;
-long   port2  = 30002;
-
-hello *p1;
-test  *p2;
-
-testServant  servant; // callback servant
-callback_var li;      // listener to pass to server (TAO smart pointer)
-
-CorbaTest::mString x;
-
-    printf("connecting to: corbaloc:iiop:%s:%d/%s\n\n",host,port1,sName1);
-    printf("connecting to: corbaloc:iiop:%s:%d/%s\n\n",host,port2,sName2);
-
-    // get the proxies
-
-    while(!_kbhit())
-    {
-      // create callback- & normal client
-
-#ifdef TEST_HELLO
-      corbaCallbackClient <hello> clnt1(host,port1,sName1);
-
-      if((p1 = clnt1.proxy()) != NULL)
-      {
-        try
-        {
-          // prepare the string to pass
-
-          CORBA::String_var s1 = CORBA::string_dup("first what ??");
-          CORBA::String_var s2 = CORBA::string_dup("second what ??");
-
-          // x.in1 = s1;
-          // x.in2 = s2;
-
-          x.in1 = CORBA::string_dup("first what ??");
-          x.in2 = CORBA::string_dup("second what ??");
-
-          // set the listener to pass on to server
-          li = servant._this();
-
-          // call server with listener
-          p1->setListener(li);
-
-          // call server with string var
-          p1->say(x);
-
-          // call server (again) with listener
-          p1->rmvListener(li);
-
-        }
-        catch(const CORBA::Exception& cex)
-        {
-            std::cerr << cex._message() << std::endl;
-        }
-        catch(exception& ex)
-        {
-            std::cerr << ex.what() << std::endl;
-        }
-        catch(...)
-        {
-            std::cerr << "other exception" << std::endl;
-        }
-      }
-#endif // TEST_HELLO
-
-#ifdef TEST_DOIT
-      corbaClient <test> clnt2(host,port2,sName2);
-
-#if defined (_TAO_1_4_)
-      long lTO = getConfigInvocationTimeout( "TestClient2");
-      SetInvocationTimeout( clnt2.orb(), lTO, true);
-#endif // _TAO_1_4_
-
-      if((p2 = clnt2.proxy()) != NULL)
-      {
-        try
-        {
-          // call second servant on the server
-
-          std::cout << "block servant now for Client Timeout test..." << std::endl;
-          Sleep( 2000);
-          p2->doit();
-        }
-        catch( CORBA::TIMEOUT $timeout)
-        {
-            std::cerr << "timeout occured" << std::endl;
-        }
-        catch(...) {}
-      }
-
-#endif // TEST_DOIT
-
-    }
-
-#else // MCORBA
-
-    CORBA::ORB_var orb;
-
-    try
-    {
-      orb = CORBA::ORB_init(argc, argv);
-
-
-      while(!_kbhit())
-      {
-        CORBA::Object_var obj = orb->string_to_object("corbaloc:iiop:mazze:30002/corbaTest2");
-
-        obj->_is_a ("IDL:CorbaTest/test:1.0");
-
-        //test_var  ptest = test::_unchecked_narrow(obj);
-
-        test_var  ptest = test::_narrow(obj);
-
-        //ptest->doit();
-
-        //CORBA::release(obj);
-        //CORBA::release(ptest);
-      }
-    }
-    catch(const CORBA::Exception& ex)
-    {
-        std::cerr << ex._message() << std::endl;
-    }
-
-    if(!CORBA::is_nil(orb))
-    {
-      try
-      {
-        orb->destroy();
-      }
-      catch(const CORBA::Exception& ex)
-      {
-        std::cerr << ex._message() << std::endl;
-      }
-    }
-
-#endif // MCORBA
-
-    return 0;
-}
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testsrvr.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testsrvr.cpp
deleted file mode 100644
index 359d7d89..00000000
--- a/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/testsrvr.cpp
+++ /dev/null
@@ -1,318 +0,0 @@
-//---------------------------------------------------------------------------
-//
-//  file:       testsvr.cpp
-//
-//  purpose:
-//
-//  date:       21.11.2001, 11:35
-//
-//  author:     Materna Information & Communications (AGe)
-//
-//---------------------------------------------------------------------------
-
-#include <iostream>
-#include <list>
-
-#include <stdio.h>
-#include <conio.h>
-
-#include "massaiCorba/corbasrvr.h"
-#include "massaiCorba/corbacfg.h"
-
-#include "test.h"
-
-#if !defined(_MICO_)
-#include "test_skel.h"
-#endif
-
-#define MCORBA
-
-
-#define SERVANTNAME  "corbaTest"
-#define SERVANTNAME1 "corbaTest1"
-#define SERVANTNAME2 "corbaTest2"
-
-using namespace CorbaTest;
-
-long i = 0;
-
-class testServant1 : public POA_CorbaTest::hello
-{
-private:
-    CorbaTest::callback_ptr p_li;
-
-public:
-    CorbaTest::callback_ptr getListener()
-    {
-        return p_li;
-    }
-
-
-    CORBA::Long setListener(CorbaTest::callback_ptr li)
-    {
-      if(li)
-      {
-        printf("tid = 0x%0x, client sets listener\n",GetCurrentThreadId());
-        p_li = li->_duplicate(li);
-
-        try
-        {
-            p_li->callClient();
-        }
-        catch( CORBA::TIMEOUT $timeout)
-        {
-            printf( "timeout occured\n");
-        }
-        catch(const CORBA::Exception& cex)
-        {
-            printf( "%s\n", cex._message());
-        }
-        catch(exception& ex)
-        {
-            printf( "%s\n", ex.what());
-        }
-        catch(...)
-        {
-            printf( "other exception\n");
-        }
-      }
-
-      return(0);
-    }
-
-    CORBA::Long rmvListener(CorbaTest::callback_ptr li)
-    {
-      if(li)
-      {
-        printf("tid = 0x%0x, client removes listener\n",GetCurrentThreadId());
-
-        p_li->callClient();
-      }
-
-      return(0);
-    }
-
-    CORBA::Long say(const struct CorbaTest::mString& x)
-    {
-      printf("tid = 0x%0x, client says: %s, %s, %d\n",GetCurrentThreadId(),x.in1,x.in2,++i);
-
-again:
-        try
-        {
-            printf( "block clnt now for Listener Timeout test...\n");
-            Sleep( 2000);
-            printf( "go\n");
-
-            p_li->callClient();
-        }
-        catch( CORBA::TIMEOUT $timeout)
-        {
-            printf( "timeout occured\n");
-            Sleep( 300);
-            goto again;
-        }
-        catch(const CORBA::Exception& cex)
-        {
-            printf( "%s\n", cex._message());
-        }
-        catch(exception& ex)
-        {
-            printf( "%s\n", ex.what());
-        }
-        catch(...)
-        {
-            printf( "other exception\n");
-        }
-      return(0);
-    }
-};
-
-/*
-class testServant2 : public POA_CorbaTest::Test
-{
-public:
-
-    CORBA::Long doit()
-    {
-      printf("tid = 0x%0x, client called doit()\n",GetCurrentThreadId());
-
-      return(0);
-    }
-};
-*/
-
-int main(int argc, char** argv)
-{
-#ifdef MCORBA
-
-char szTmp[256];
-
-/*
-    p = CORBA::string_dup("");
-
-    ::gethostname(szTmp,sizeof(szTmp));
-
-    printf("hostname = %s\n", szTmp);
-
-    while(!_kbhit());
-*/
-
-long lThreads;
-
-long port1 = 30001;
-long port2 = 30002;
-
-
-    {
-      testServant1 srvntClass1;
-
-      printf("servant = [corbaloc:iiop:127.0.0.1:%d/%s]\n",port1,SERVANTNAME1);
-
-      lThreads = 50;
-
-      corbaServantEx <testServant1> srvnt1(lThreads,srvntClass1,SERVANTNAME1,port1);
-#if defined (_TAO_1_4_)
-
-      long lTO = getConfigInvocationTimeout( "TestServant1");
-      SetInvocationTimeout( srvnt1.orb(), lTO, false);
-#endif // _TAO_1_4_
-
-      printf("ior = \n%s\n\n",srvnt1.ior());
-
-      //testServant2 srvntClass2;
-
-      // printf("servant = [corbaloc:iiop:127.0.0.1:%d/%s]\n",port2,SERVANTNAME2);
-
-      //corbaServant <testServant2> srvnt2(srvntClass2,SERVANTNAME2,port2);
-#if defined (_TAO_1_4_)
-      //lTO = getConfigInvocationTimeout( "TestServant2");
-      //SetInvocationTimeout( srvnt2.orb(), lTO, true);
-#endif // _TAO_1_4_
-
-
-      //printf("ior = \n%s\n\n",srvnt2.ior());
-
-      while(getchar() != 'q')
-      {
-        Sleep(10);
-      }
-    }
-
-    printf("DONE, please press any key\n");
-
-    gets(szTmp);
-
-#else // MCORBA
-
-int    _argc;
-char  *_argv[10];
-
-char   szArgs1[256];
-char   szArgs2[256];
-
-CORBA::ORB_var                  orb;
-CORBA::Object_var               poaObj;
-CORBA::PolicyList               policies;
-
-PortableServer::POA_var         rootPoa;
-PortableServer::POAManager_var  poaManager;
-PortableServer::ObjectId_var    objID;
-PortableServer::POA_var         poa;
-
-    _argc    = 1;
-    _argv[0] = "exefile";
-
-    sprintf(szArgs1,"-ORBEndpoint");
-    sprintf(szArgs2,"iiop://localhost:30000"); // bind TAO-ORB to this port
-
-    _argc    = 3;
-
-    _argv[1] = szArgs1;
-    _argv[2] = szArgs2;
-
-    char szPoaName[512];
-
-    orb = CORBA::ORB_init(_argc, _argv);
-
-    //
-    // Resolve Root POA
-    //
-
-    poaObj = orb -> resolve_initial_references("RootPOA");
-    rootPoa = PortableServer::POA::_narrow(poaObj);
-
-    //
-    // Get a reference to the POA manager
-    //
-
-    poaManager = rootPoa->the_POAManager();
-
-    // create new POA
-
-    policies.length(3);
-
-    policies[0]= rootPoa->create_lifespan_policy(PortableServer::PERSISTENT);
-    policies[1]= rootPoa->create_id_assignment_policy(PortableServer::USER_ID);
-    policies[2]= rootPoa->create_implicit_activation_policy(PortableServer::NO_IMPLICIT_ACTIVATION);
-
-    sprintf(szPoaName,"POA_%s",SERVANTNAME);
-
-    poa = rootPoa->create_POA(szPoaName,poaManager,policies);
-
-    //
-    // Create implementation object
-    //
-
-    testServant* helloImpl = new testServant();
-
-    PortableServer::ServantBase_var servant = helloImpl;
-
-    hello_var phello = helloImpl->_this();
-
-    //
-    //  Activate the NAMED servant
-    //
-
-    objID = PortableServer::string_to_ObjectId(SERVANTNAME);
-
-    poa->activate_object_with_id(objID,helloImpl);
-
-    // Turn your object reference into an IOR string
-
-    CORBA::String_var ior = orb->object_to_string(helloImpl->_this());
-
-    // Get a reference to the IOR Table
-
-    CORBA::Object_var tableObj = orb->resolve_initial_references("IORTable");
-
-    IORTable::Table_var table = IORTable::Table::_narrow(tableObj.in());
-
-    // Bind your stringified IOR in the IOR Table
-
-    table->bind(SERVANTNAME,ior.in());
-
-    //
-    // Run implementation
-    //
-
-    poaManager->activate();
-    orb->run();
-
-    if(!CORBA::is_nil(orb))
-    {
-      try
-      {
-        orb->destroy();
-      }
-      catch(const CORBA::Exception& ex)
-      {
-        cout << ex._message() << endl;
-
-        printf("%s",ex._message());
-      }
-    }
-
-#endif // MCORBA
-
-    return 0;
-}
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/tsrv.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/tsrv.cpp
deleted file mode 100644
index 7b4aa934..00000000
--- a/SelfServiceCommon/Massai/cpp/MassaiCorba/test/src/tsrv.cpp
+++ /dev/null
@@ -1,118 +0,0 @@
-//---------------------------------------------------------------------------
-//
-//  file:       tsrv.cpp
-//
-//  purpose:
-//
-//  date:       14.04.2006
-//
-//  author:     Materna Information & Communications (SteT)
-//
-//---------------------------------------------------------------------------
-
-#include "massaiCorba/corbasrvr.h"
-#include "test_skel.h"
-#include "massaiCorba/corbaclnt.h"
-
-#include <iostream>
-#include <windows.h>
-
-using namespace CorbaTest;
-
-//CorbaTest::callback_ptr p_li;  // memory leak
-CorbaTest::callback_var p_li;
-class testServant : public POA_CorbaTest::test
-{
-  public:
-    int count_doit;
-    int count_say;
-    testServant() : clnt(0)
-    {}
-    CORBA::Long doit()
-    {
-      count_doit++;
-      if(count_doit%32 == 0)
-        std::cout << ".";
-      return(0);
-    }
-    CORBA::Long say(const char* s)
-    {
-      count_say++;
-      if(count_say%32 == 0)
-        std::cout << ",";
-      if(clnt && clnt->proxy())
-      {
-        clnt->proxy()->callClient();
-        clnt->proxy()->callClient();
-        std::cout << "#";
-      }
-/*
-      if(p_li)
-      {
-        p_li->callClient();
-        p_li->callClient();
-        std::cout << "#";
-      }
-*/
-      return(0);
-    }
-    CORBA::Long setListener(CorbaTest::callback_ptr li)
-    {
-      if(li)
-      {
-//        p_li = li->_duplicate(li);
-        if(clnt)
-        {
-          delete clnt;
-          clnt= 0;
-        }
-        clnt= new corbaClient<CorbaTest::callback>(li);
-      }
-      return(0);
-    }
-    CORBA::Long rmvListener(CorbaTest::callback_ptr li)
-    {
-//      p_li= 0;
-      if(clnt)
-      {
-        delete clnt;
-        clnt= 0;
-      }
-      return(0);
-    }
-
-  private:
-    corbaClient<CorbaTest::callback>* clnt;
-};
-
-int main(int argc, char** argv)
-{
-  try
-  {
-    std::cout << std::endl << "create servant..." << std::endl;
-    testServant srvnt;
-    corbaServantEx<testServant> corbaSrvnt(10, srvnt, "TestServant", 30000);
-    //std::cout << "create servant done." << corbaSrvnt.ior("TestServant") << std::endl;
-    int i;
-    for(;;)
-    {
-      Sleep(100);
-      if(p_li)
-      {
-        p_li->callClient();
-        i++;
-        if(i%32 == 0)
-          std::cout << ":";
-      }
-    }
-  }
-  catch(const CORBA::Exception& ex)
-  {
-    std::cout << std::endl << ex._message() << std::endl;
-  }
-  catch(...)
-  {
-    std::cout << std::endl << "unknown exception" << std::endl;
-  }
-  return 0;
-}
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/TraceSystem.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/TraceSystem.cpp
index 37f8830d..cf9d4f68 100644
--- a/SelfServiceCommon/Massai/cpp/Tools/src/TraceSystem.cpp
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/TraceSystem.cpp
@@ -21,7 +21,7 @@ namespace
     public:
       virtual void traceLine(const std::string& head, const std::string& data) const
       {
-        OutputDebugString((head+data).c_str());
+        OutputDebugString((head + data + "\n").c_str());
       }
   };
   SystemTrace* pTrace= 0;
-- 
2.41.0.windows.1

