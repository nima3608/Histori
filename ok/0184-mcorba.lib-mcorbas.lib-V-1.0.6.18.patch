From dcda3e3a690d7c0623cc637c1fa32d6562410464 Mon Sep 17 00:00:00 2001
From: tstegema <tstegema@90b65887-3827-0410-9a23-83215b262276>
Date: Mon, 26 Mar 2012 18:33:46 +0000
Subject: [PATCH 0184/1000] mcorba.lib, mcorbas.lib V 1.0.6.18 cannot use
 bugfix with vc6 (TAO1.4 does not support ORB.set_default) revert to old
 version for vc6

git-svn-id: svn://localhost/SelfServiceCommon/trunk@313 90b65887-3827-0410-9a23-83215b262276
---
 .../generic/massaiCorba/corbaclnt.h           | 208 +----
 .../generic/massaiCorba/corbaclnt.hpp         | 156 +---
 .../generic/massaiCorba/corbaclnt_VC10.h      | 207 +++++
 .../generic/massaiCorba/corbaclnt_VC10.hpp    | 155 ++++
 .../generic/massaiCorba/corbaclnt_VC6.h       | 355 +++++++
 .../generic/massaiCorba/corbasrvr.h           | 181 +---
 .../generic/massaiCorba/corbasrvr.hpp         | 112 +--
 .../generic/massaiCorba/corbasrvr_VC10.h      | 178 ++++
 .../generic/massaiCorba/corbasrvr_VC10.hpp    | 111 +++
 .../generic/massaiCorba/corbasrvr_VC6.h       | 410 ++++++++
 SelfServiceCommon/Interfaces/inc/corbaorbEx.h |   9 +
 .../Interfaces/inc/massaiCorba/corbacfg.h     |  29 +-
 .../inc/massaiCorba/corbacfg_vc10.h           |  26 +
 .../Interfaces/inc/massaiCorba/corbacfg_vc6.h |  35 +
 .../inc/massaiCorba/corbaclntbase.h           |  88 +-
 .../inc/massaiCorba/corbaclntbase_vc10.h      |  87 ++
 .../Interfaces/inc/massaiCorba/corbaorb.h     |  73 +-
 .../Interfaces/inc/massaiCorba/corbaorbEx.h   |   3 +
 .../inc/massaiCorba/corbaorbEx_vc6.h          | 129 +++
 .../inc/massaiCorba/corbaorb_vc10.h           |  70 ++
 .../Interfaces/inc/massaiCorba/corbaorb_vc6.h | 106 +++
 .../Interfaces/inc/massaiCorba/corbapoll.h    |  57 +-
 .../inc/massaiCorba/corbapoll_vc10.h          |  54 ++
 .../inc/massaiCorba/corbapoll_vc6.h           |  60 ++
 .../inc/massaiCorba/corbasrvrbase.h           |  98 +-
 .../inc/massaiCorba/corbasrvrbase_vc10.h      |  97 ++
 .../Interfaces/inc/massaiCorba/iorparser.h    | 162 +---
 .../inc/massaiCorba/iorparser_vc10.h          | 159 ++++
 .../inc/massaiCorba/iorparser_vc6.h           | 159 ++++
 .../Interfaces/inc/massaiCorba/orbIncDefs.h   |  67 +-
 .../inc/massaiCorba/orbIncDefs_vc10.h         |  66 ++
 .../inc/massaiCorba/orbIncDefs_vc6.h          |  94 ++
 .../cpp/MassaiCorba_VC6/inc/localclnt_def.h   |   9 +
 .../cpp/MassaiCorba_VC6/inc/localsrv_def.h    |   9 +
 .../cpp/MassaiCorba_VC6/inc/massaiCORBA_def.h | 108 +++
 .../Massai/cpp/MassaiCorba_VC6/inc/tracedef.h |  31 +
 .../MassaiCorba_VC6/res/FileVersionClnt.rc    | 108 +++
 .../cpp/MassaiCorba_VC6/res/FileVersionSrv.rc | 108 +++
 .../cpp/MassaiCorba_VC6/src/Realtime.cpp      | 209 +++++
 .../cpp/MassaiCorba_VC6/src/corbacfg.cpp      | 259 ++++++
 .../cpp/MassaiCorba_VC6/src/corbaclnt.cpp     |  14 +
 .../cpp/MassaiCorba_VC6/src/corbaorb.cpp      | 875 ++++++++++++++++++
 .../cpp/MassaiCorba_VC6/src/corbaorbEx.cpp    | 716 ++++++++++++++
 .../cpp/MassaiCorba_VC6/src/corbaorbcfg.cpp   | 174 ++++
 .../cpp/MassaiCorba_VC6/src/corbapoll.cpp     | 227 +++++
 .../cpp/MassaiCorba_VC6/src/corbasrvr.cpp     |  13 +
 .../cpp/MassaiCorba_VC6/src/iorparser.cpp     | 583 ++++++++++++
 .../Massai/cpp/MassaiCorba_VC6/src/trace.cpp  | 251 +++++
 .../cpp/MassaiCorba_VC6/static/makefile.mak   |  34 +
 .../cpp/MassaiCorba_VC6/test/idl/makefile.mak |  12 +
 .../cpp/MassaiCorba_VC6/test/idl/test.idl     |  29 +
 .../cpp/MassaiCorba_VC6/test/makefile.mak     | 134 +++
 .../cpp/MassaiCorba_VC6/test/src/cbclt.cpp    | 105 +++
 .../cpp/MassaiCorba_VC6/test/src/cbsrv.cpp    |  70 ++
 .../cpp/MassaiCorba_VC6/test/src/stclt.cpp    |  25 +
 .../cpp/MassaiCorba_VC6/test/src/tclt.cpp     | 108 +++
 .../cpp/MassaiCorba_VC6/test/src/testclnt.cpp | 190 ++++
 .../cpp/MassaiCorba_VC6/test/src/testsrvr.cpp | 318 +++++++
 .../cpp/MassaiCorba_VC6/test/src/tsrv.cpp     | 118 +++
 59 files changed, 7441 insertions(+), 1197 deletions(-)
 create mode 100644 SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt_VC10.h
 create mode 100644 SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt_VC10.hpp
 create mode 100644 SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt_VC6.h
 create mode 100644 SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr_VC10.h
 create mode 100644 SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr_VC10.hpp
 create mode 100644 SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr_VC6.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/corbaorbEx.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/massaiCorba/corbacfg_vc10.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/massaiCorba/corbacfg_vc6.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/massaiCorba/corbaclntbase_vc10.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorbEx.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorbEx_vc6.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorb_vc10.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorb_vc6.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/massaiCorba/corbapoll_vc10.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/massaiCorba/corbapoll_vc6.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/massaiCorba/corbasrvrbase_vc10.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/massaiCorba/iorparser_vc10.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/massaiCorba/iorparser_vc6.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/massaiCorba/orbIncDefs_vc10.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/massaiCorba/orbIncDefs_vc6.h
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/inc/localclnt_def.h
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/inc/localsrv_def.h
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/inc/massaiCORBA_def.h
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/inc/tracedef.h
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/res/FileVersionClnt.rc
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/res/FileVersionSrv.rc
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/Realtime.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbacfg.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbaclnt.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbaorb.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbaorbEx.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbaorbcfg.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbapoll.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbasrvr.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/iorparser.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/trace.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/static/makefile.mak
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/idl/makefile.mak
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/idl/test.idl
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/makefile.mak
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/cbclt.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/cbsrv.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/stclt.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/tclt.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/testclnt.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/testsrvr.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/tsrv.cpp

diff --git a/SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt.h b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt.h
index 14627c69..362cbb44 100644
--- a/SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt.h
+++ b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt.h
@@ -1,207 +1,5 @@
-// Interface for CORBA client
-#ifndef CORBACLNT_H
-#define CORBACLNT_H
-
-#ifdef  SHOW_INCLUDE_FILES
-#pragma message("including: " __FILE__)
-#endif
-
-#include <iostream>
-#include "massaiCorba/corbaclnt.hpp"
-
-template<class T>
-void corbaClient<T>::narrow(CORBA::Object_var obj)
-{
-#if defined (CHECKED_NARROW)
-  // TAO 1.4 should have fixed this ...
-  remoteServant = T::_narrow(obj);
+#if defined(_COMPILER_VERSION_VC6)
+#include "massaiCorba/corbaclnt_vc6.h"
 #else
-  // less memory consuming for TAO 1.2
-  remoteServant = T::_unchecked_narrow(obj);
-#endif
-}
-
-template<class T>
-bool corbaClient<T>::poll()
-{
-  bool result= false;
-  CORBA::PolicyList_var inconsistent_policies;
-  if(remoteServant->_validate_connection(inconsistent_policies))
-  {
-    result= true;
-  }
-  return result;
-}
-
-/** Returns a reference to the servant proxy */
-template<class T>
-T* corbaClient<T>::proxy()
-{
-  return remoteServant;
-}
-
-/** Class constructor
-    @param pszIOR_or_ServantName - Valid CORBA IOR or CORBALOC address
-
-    @note If the given parameter does not specify a valid IOR or CORBALOC address
-          the host address and port is read from the configuration. This allows
-          to contact servants via its names only.
-
-          \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b host:port
-*/
-template<class T>
-corbaClient<T>::corbaClient
-(
-  const char* pszIOR_or_ServantName,
-  long invocationTimeout,
-  AutoPolling autopoll
-): remoteServant(0)
-{
- init(pszIOR_or_ServantName, invocationTimeout, autopoll);
-}
-
-/** Class constructor
-    @param pszInitialService - CORBA initial service, like Naming Service to connect to
-    @param pszIOR - CORBA IOR to connect to
-    @attention Not yet implememted
-*/
-template<class T>
-corbaClient<T>::corbaClient
-(
-  const char* pszInitialService,
-  const char* pszIOR,
-  long invocationTimeout,
-  AutoPolling autopoll
-): remoteServant(0)
-{
-  init(pszInitialService, pszIOR, invocationTimeout, autopoll);
-}
-
-/** Class constructor
-    @param pszHost - IP address of the remote host to connect to
-    @param port - The port on the remote host to connect to
-    @param pszServant - Name of the remote servant to connect to
-*/
-template<class T>
-corbaClient<T>::corbaClient
-(
-  const char* pszHost,
-  long port,
-  const char* pszServant,
-  long invocationTimeout,
-  AutoPolling autopoll
-): remoteServant(0)
-{
-  init(pszHost, port, pszServant, invocationTimeout, autopoll);
-}
-
-/** Class constructor
-    @param Host - IP address of the remote host to connect to
-    @param port - The port on the remote host to connect to
-    @param pszServant - Name of the remote servant to connect to
-*/
-template<class T>
-corbaClient<T>::corbaClient
-(
-  const std::string& host,
-  long port,
-  const char* pszServant,
-  long invocationTimeout,
-  AutoPolling autopoll
-): remoteServant(0)
-{
-  init(host.c_str(), port, pszServant, invocationTimeout, autopoll);
-}
-
-/** Class constructor
-    @param servant - duplicated in constructor, released in destructor
-*/
-template<class T>
-corbaClient<T>::corbaClient
-(
-  T* servant,
-  long invocationTimeout,
-  AutoPolling autopoll
-): remoteServant(servant->_duplicate(servant))
-{
-  setTimeout(invocationTimeout);
-  obj= remoteServant->_duplicate(remoteServant);
-  startProcessing(ior(), false, false, autopoll);
-}
-
-
-/** Class destructor */
-template<class T>
-corbaClient<T>::~corbaClient()
-{
-  stopPolling();
-  if(remoteServant)
-  {
-    CORBA::release(remoteServant);
-    remoteServant = 0;
-  }
-}
-
-
-/** Class constructor
-    @param pszIOR_or_ServantName - Valid CORBA IOR or CORBALOC address
-
-    @note If the given parameter does not specify a valid IOR or CORBALOC address
-          the host address and port is read from the configuration. This allows
-          to contact servants via its names only.
-
-          \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b host:port
-*/
-template<class T>
-corbaCallbackClient<T>::corbaCallbackClient
-(
-  const char* pszIOR_or_ServantName,
-  long invocationTimeout,
-  AutoPolling autopoll
-): corbaClient<T>(pszIOR_or_ServantName, invocationTimeout, autopoll)
-{
-  initCallbackClient();
-}
-
-/** Class constructor
-    @param pszHost - IP address of the remote host to connect to
-    @param port - The port on the remote host to connect to
-    @param pszServant - Name of the remote servant to connect to
-*/
-template<class T>
-corbaCallbackClient<T>::corbaCallbackClient
-(
-  const char* pszHost,
-  long  port,
-  const char* pszServant,
-  long invocationTimeout,
-  AutoPolling autopoll
-): corbaClient<T> (pszHost, port, pszServant, invocationTimeout, autopoll)
-{
-  initCallbackClient();
-}
-
-/** Class constructor
-    @param Host - IP address of the remote host to connect to
-    @param port - The port on the remote host to connect to
-    @param pszServant - Name of the remote servant to connect to
-*/
-template<class T>
-corbaCallbackClient<T>::corbaCallbackClient
-(
-  const std::string& Host,
-  long  port,
-  const char* pszServant,
-  long invocationTimeout,
-  AutoPolling autopoll
-): corbaClient<T> (Host.c_str(), port, pszServant, invocationTimeout, autopoll)
-{
-  initCallbackClient();
-}
-
-/** Class destructor */
-template<class T>
-corbaCallbackClient<T>::~corbaCallbackClient()
-{}
-
+#include "massaiCorba/corbaclnt_vc10.h"
 #endif
diff --git a/SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt.hpp b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt.hpp
index ff6cbab1..e170aa4c 100644
--- a/SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt.hpp
+++ b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt.hpp
@@ -1,155 +1,3 @@
-// Interface for CORBA client
-#ifndef CORBACLNT_HPP
-#define CORBACLNT_HPP
-
-#ifdef  SHOW_INCLUDE_FILES
-#pragma message("including: " __FILE__)
-#endif
-
-#include <string>
-
-#include "massaiCorba/corbaorb.h"
-#include "massaiCorba/corbaclntbase.h"
-#include "massaiCorba/corbacfg.h"
-#include "massaiCorba/corbapoll.h"
-
-/** Template class for the implementation of simple CORBA clients that
-    don't need callback functionality.
-*/
-template<class T> class corbaClient: public massaiCorba::corbaClientBase
-{
-  public:
-    bool poll();
-    /** Returns a reference to the servant proxy */
-    T* proxy();
-
-    /** Class constructor
-        @param pszIOR_or_ServantName - Valid CORBA IOR or CORBALOC address
-
-        @note If the given parameter does not specify a valid IOR or CORBALOC address
-              the host address and port is read from the configuration. This allows
-              to contact servants via its names only.
-
-              \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b host:port
-    */
-    corbaClient
-    (
-      const char* pszIOR_or_ServantName,
-      long invocationTimeout = -1,
-      AutoPolling autopoll = AUTO_POLL_OFF
-    );
-
-    /** Class constructor
-        @param pszInitialService - CORBA initial service, like Naming Service to connect to
-        @param pszIOR - CORBA IOR to connect to
-        @attention Not yet implememted
-    */
-    corbaClient
-    (
-      const char* pszInitialService,
-      const char* pszIOR,
-      long invocationTimeout = -1,
-      AutoPolling autopoll = AUTO_POLL_OFF
-    );
-
-    /** Class constructor
-        @param pszHost - IP address of the remote host to connect to
-        @param port - The port on the remote host to connect to
-        @param pszServant - Name of the remote servant to connect to
-    */
-    corbaClient
-    (
-      const char* pszHost,
-      long port,
-      const char* pszServant,
-      long invocationTimeout = -1,
-      AutoPolling autopoll = AUTO_POLL_OFF
-    );
-
-    /** Class constructor
-        @param Host - IP address of the remote host to connect to
-        @param port - The port on the remote host to connect to
-        @param pszServant - Name of the remote servant to connect to
-    */
-    corbaClient
-    (
-      const std::string& host,
-      long port,
-      const char* pszServant,
-      long invocationTimeout = -1,
-      AutoPolling autopoll = AUTO_POLL_OFF
-    );
-
-    /** Class constructor
-        @param servant - duplicated in constructor, released in destructor
-    */
-    corbaClient
-    (
-      T* servant,
-      long invocationTimeout = -1,
-      AutoPolling autopoll = AUTO_POLL_OFF
-    );
-
-    ~corbaClient();
-
-  private:
-    T* remoteServant;
-
-    void narrow(CORBA::Object_var obj);
-};
-
-/** Template class for the implementation of simple CORBA clients that
- *  don't need callback functionality.
- */
-template<class T> class corbaCallbackClient : public corbaClient<T>
-{
-  public:
-    /** Class constructor
-        @param pszIOR_or_ServantName - Valid CORBA IOR or CORBALOC address
-
-        @note If the given parameter does not specify a valid IOR or CORBALOC address
-              the host address and port is read from the configuration. This allows
-              to contact servants via its names only.
-
-              \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b host:port
-     */
-    corbaCallbackClient
-    (
-      const char* pszIOR_or_ServantName,
-      long invocationTimeout = -1,
-      AutoPolling autopoll = AUTO_POLL_OFF
-    );
-
-    /** Class constructor
-        @param pszHost - IP address of the remote host to connect to
-        @param port - The port on the remote host to connect to
-        @param pszServant - Name of the remote servant to connect to
-     */
-    corbaCallbackClient
-    (
-      const char* pszHost,
-      long  port,
-      const char* pszServant,
-      long invocationTimeout = -1,
-      AutoPolling autopoll = AUTO_POLL_OFF
-    );
-
-    /** Class constructor
-        @param Host - IP address of the remote host to connect to
-        @param port - The port on the remote host to connect to
-        @param pszServant - Name of the remote servant to connect to
-     */
-    corbaCallbackClient
-    (
-      const std::string& host,
-      long  port,
-      const char* pszServant,
-      long invocationTimeout = -1,
-      AutoPolling autopoll = AUTO_POLL_OFF
-    );
-
-    /** Class destructor */
-    ~corbaCallbackClient();
-};
-
+#if !defined(_COMPILER_VERSION_VC6)
+#include "massaiCorba/corbaclnt_vc10.hpp"
 #endif
diff --git a/SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt_VC10.h b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt_VC10.h
new file mode 100644
index 00000000..14627c69
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt_VC10.h
@@ -0,0 +1,207 @@
+// Interface for CORBA client
+#ifndef CORBACLNT_H
+#define CORBACLNT_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include <iostream>
+#include "massaiCorba/corbaclnt.hpp"
+
+template<class T>
+void corbaClient<T>::narrow(CORBA::Object_var obj)
+{
+#if defined (CHECKED_NARROW)
+  // TAO 1.4 should have fixed this ...
+  remoteServant = T::_narrow(obj);
+#else
+  // less memory consuming for TAO 1.2
+  remoteServant = T::_unchecked_narrow(obj);
+#endif
+}
+
+template<class T>
+bool corbaClient<T>::poll()
+{
+  bool result= false;
+  CORBA::PolicyList_var inconsistent_policies;
+  if(remoteServant->_validate_connection(inconsistent_policies))
+  {
+    result= true;
+  }
+  return result;
+}
+
+/** Returns a reference to the servant proxy */
+template<class T>
+T* corbaClient<T>::proxy()
+{
+  return remoteServant;
+}
+
+/** Class constructor
+    @param pszIOR_or_ServantName - Valid CORBA IOR or CORBALOC address
+
+    @note If the given parameter does not specify a valid IOR or CORBALOC address
+          the host address and port is read from the configuration. This allows
+          to contact servants via its names only.
+
+          \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b host:port
+*/
+template<class T>
+corbaClient<T>::corbaClient
+(
+  const char* pszIOR_or_ServantName,
+  long invocationTimeout,
+  AutoPolling autopoll
+): remoteServant(0)
+{
+ init(pszIOR_or_ServantName, invocationTimeout, autopoll);
+}
+
+/** Class constructor
+    @param pszInitialService - CORBA initial service, like Naming Service to connect to
+    @param pszIOR - CORBA IOR to connect to
+    @attention Not yet implememted
+*/
+template<class T>
+corbaClient<T>::corbaClient
+(
+  const char* pszInitialService,
+  const char* pszIOR,
+  long invocationTimeout,
+  AutoPolling autopoll
+): remoteServant(0)
+{
+  init(pszInitialService, pszIOR, invocationTimeout, autopoll);
+}
+
+/** Class constructor
+    @param pszHost - IP address of the remote host to connect to
+    @param port - The port on the remote host to connect to
+    @param pszServant - Name of the remote servant to connect to
+*/
+template<class T>
+corbaClient<T>::corbaClient
+(
+  const char* pszHost,
+  long port,
+  const char* pszServant,
+  long invocationTimeout,
+  AutoPolling autopoll
+): remoteServant(0)
+{
+  init(pszHost, port, pszServant, invocationTimeout, autopoll);
+}
+
+/** Class constructor
+    @param Host - IP address of the remote host to connect to
+    @param port - The port on the remote host to connect to
+    @param pszServant - Name of the remote servant to connect to
+*/
+template<class T>
+corbaClient<T>::corbaClient
+(
+  const std::string& host,
+  long port,
+  const char* pszServant,
+  long invocationTimeout,
+  AutoPolling autopoll
+): remoteServant(0)
+{
+  init(host.c_str(), port, pszServant, invocationTimeout, autopoll);
+}
+
+/** Class constructor
+    @param servant - duplicated in constructor, released in destructor
+*/
+template<class T>
+corbaClient<T>::corbaClient
+(
+  T* servant,
+  long invocationTimeout,
+  AutoPolling autopoll
+): remoteServant(servant->_duplicate(servant))
+{
+  setTimeout(invocationTimeout);
+  obj= remoteServant->_duplicate(remoteServant);
+  startProcessing(ior(), false, false, autopoll);
+}
+
+
+/** Class destructor */
+template<class T>
+corbaClient<T>::~corbaClient()
+{
+  stopPolling();
+  if(remoteServant)
+  {
+    CORBA::release(remoteServant);
+    remoteServant = 0;
+  }
+}
+
+
+/** Class constructor
+    @param pszIOR_or_ServantName - Valid CORBA IOR or CORBALOC address
+
+    @note If the given parameter does not specify a valid IOR or CORBALOC address
+          the host address and port is read from the configuration. This allows
+          to contact servants via its names only.
+
+          \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b host:port
+*/
+template<class T>
+corbaCallbackClient<T>::corbaCallbackClient
+(
+  const char* pszIOR_or_ServantName,
+  long invocationTimeout,
+  AutoPolling autopoll
+): corbaClient<T>(pszIOR_or_ServantName, invocationTimeout, autopoll)
+{
+  initCallbackClient();
+}
+
+/** Class constructor
+    @param pszHost - IP address of the remote host to connect to
+    @param port - The port on the remote host to connect to
+    @param pszServant - Name of the remote servant to connect to
+*/
+template<class T>
+corbaCallbackClient<T>::corbaCallbackClient
+(
+  const char* pszHost,
+  long  port,
+  const char* pszServant,
+  long invocationTimeout,
+  AutoPolling autopoll
+): corbaClient<T> (pszHost, port, pszServant, invocationTimeout, autopoll)
+{
+  initCallbackClient();
+}
+
+/** Class constructor
+    @param Host - IP address of the remote host to connect to
+    @param port - The port on the remote host to connect to
+    @param pszServant - Name of the remote servant to connect to
+*/
+template<class T>
+corbaCallbackClient<T>::corbaCallbackClient
+(
+  const std::string& Host,
+  long  port,
+  const char* pszServant,
+  long invocationTimeout,
+  AutoPolling autopoll
+): corbaClient<T> (Host.c_str(), port, pszServant, invocationTimeout, autopoll)
+{
+  initCallbackClient();
+}
+
+/** Class destructor */
+template<class T>
+corbaCallbackClient<T>::~corbaCallbackClient()
+{}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt_VC10.hpp b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt_VC10.hpp
new file mode 100644
index 00000000..ff6cbab1
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt_VC10.hpp
@@ -0,0 +1,155 @@
+// Interface for CORBA client
+#ifndef CORBACLNT_HPP
+#define CORBACLNT_HPP
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include <string>
+
+#include "massaiCorba/corbaorb.h"
+#include "massaiCorba/corbaclntbase.h"
+#include "massaiCorba/corbacfg.h"
+#include "massaiCorba/corbapoll.h"
+
+/** Template class for the implementation of simple CORBA clients that
+    don't need callback functionality.
+*/
+template<class T> class corbaClient: public massaiCorba::corbaClientBase
+{
+  public:
+    bool poll();
+    /** Returns a reference to the servant proxy */
+    T* proxy();
+
+    /** Class constructor
+        @param pszIOR_or_ServantName - Valid CORBA IOR or CORBALOC address
+
+        @note If the given parameter does not specify a valid IOR or CORBALOC address
+              the host address and port is read from the configuration. This allows
+              to contact servants via its names only.
+
+              \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b host:port
+    */
+    corbaClient
+    (
+      const char* pszIOR_or_ServantName,
+      long invocationTimeout = -1,
+      AutoPolling autopoll = AUTO_POLL_OFF
+    );
+
+    /** Class constructor
+        @param pszInitialService - CORBA initial service, like Naming Service to connect to
+        @param pszIOR - CORBA IOR to connect to
+        @attention Not yet implememted
+    */
+    corbaClient
+    (
+      const char* pszInitialService,
+      const char* pszIOR,
+      long invocationTimeout = -1,
+      AutoPolling autopoll = AUTO_POLL_OFF
+    );
+
+    /** Class constructor
+        @param pszHost - IP address of the remote host to connect to
+        @param port - The port on the remote host to connect to
+        @param pszServant - Name of the remote servant to connect to
+    */
+    corbaClient
+    (
+      const char* pszHost,
+      long port,
+      const char* pszServant,
+      long invocationTimeout = -1,
+      AutoPolling autopoll = AUTO_POLL_OFF
+    );
+
+    /** Class constructor
+        @param Host - IP address of the remote host to connect to
+        @param port - The port on the remote host to connect to
+        @param pszServant - Name of the remote servant to connect to
+    */
+    corbaClient
+    (
+      const std::string& host,
+      long port,
+      const char* pszServant,
+      long invocationTimeout = -1,
+      AutoPolling autopoll = AUTO_POLL_OFF
+    );
+
+    /** Class constructor
+        @param servant - duplicated in constructor, released in destructor
+    */
+    corbaClient
+    (
+      T* servant,
+      long invocationTimeout = -1,
+      AutoPolling autopoll = AUTO_POLL_OFF
+    );
+
+    ~corbaClient();
+
+  private:
+    T* remoteServant;
+
+    void narrow(CORBA::Object_var obj);
+};
+
+/** Template class for the implementation of simple CORBA clients that
+ *  don't need callback functionality.
+ */
+template<class T> class corbaCallbackClient : public corbaClient<T>
+{
+  public:
+    /** Class constructor
+        @param pszIOR_or_ServantName - Valid CORBA IOR or CORBALOC address
+
+        @note If the given parameter does not specify a valid IOR or CORBALOC address
+              the host address and port is read from the configuration. This allows
+              to contact servants via its names only.
+
+              \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b host:port
+     */
+    corbaCallbackClient
+    (
+      const char* pszIOR_or_ServantName,
+      long invocationTimeout = -1,
+      AutoPolling autopoll = AUTO_POLL_OFF
+    );
+
+    /** Class constructor
+        @param pszHost - IP address of the remote host to connect to
+        @param port - The port on the remote host to connect to
+        @param pszServant - Name of the remote servant to connect to
+     */
+    corbaCallbackClient
+    (
+      const char* pszHost,
+      long  port,
+      const char* pszServant,
+      long invocationTimeout = -1,
+      AutoPolling autopoll = AUTO_POLL_OFF
+    );
+
+    /** Class constructor
+        @param Host - IP address of the remote host to connect to
+        @param port - The port on the remote host to connect to
+        @param pszServant - Name of the remote servant to connect to
+     */
+    corbaCallbackClient
+    (
+      const std::string& host,
+      long  port,
+      const char* pszServant,
+      long invocationTimeout = -1,
+      AutoPolling autopoll = AUTO_POLL_OFF
+    );
+
+    /** Class destructor */
+    ~corbaCallbackClient();
+};
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt_VC6.h b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt_VC6.h
new file mode 100644
index 00000000..d2c4242d
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbaclnt_VC6.h
@@ -0,0 +1,355 @@
+/**
+ *  @file      corbaclnt.h
+ *
+ *  @brief     Header file for CORBA client classes.
+ *
+ *  @date      16.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ *
+ ************************************************************************/
+
+#ifndef CORBACLNT_H
+#define CORBACLNT_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include <iostream>
+#include <string>
+
+#include "massaiCorba/corbaorb.h"
+#include "massaiCorba/corbacfg.h"
+#include "massaiCorba/corbapoll.h"
+
+/** Template class for the implementation of simple CORBA clients that
+ *  don't need callback functionality.
+ */
+
+template<class T> class corbaClient : public corbaOrb, public corbaPoll
+{
+protected:
+
+    T *remoteServant;
+
+private:
+
+    CORBA::Object_var obj;
+
+    std::string m_ior;
+
+    long connect()
+    {
+      long rc = 0;
+
+      try
+      {
+
+#if defined (CHECKED_NARROW)
+
+        // TAO 1.4 should have fixed this ...
+
+        remoteServant = T::_narrow(obj);
+#else
+
+        // less memory consuming for TAO 1.2
+
+        remoteServant = T::_unchecked_narrow(obj);
+#endif
+      }
+      catch(CORBA::SystemException& e)
+      {
+        printf("%s",e._message());
+        rc = -1;
+      }
+
+      return(rc);
+    }
+
+public:
+
+    bool poll()
+    {
+      bool result= false;
+      CORBA::PolicyList_var inconsistent_policies;
+      if(remoteServant->_validate_connection(inconsistent_policies))
+      {
+         result= true;
+      }
+      return result;
+    }
+
+    /** Returns the IOR of this object */
+
+    const char *ior()
+    {
+      if(m_ior.size() == 0)
+      {
+        CORBA::String_var ior_= orb()->object_to_string(obj);
+        m_ior= ior_.in();
+      }
+      return m_ior.c_str();
+    }
+
+    /** Returns a reference to the servant proxy */
+
+    T* proxy() { return(remoteServant); }
+
+    /** Class constructor
+        @param pszIOR_or_ServantName - Valid CORBA IOR or CORBALOC address
+
+        @note If the given parameter does not specify a valid IOR or CORBALOC address
+              the host address and port is read from the configuration. This allows
+              to contact servants via its names only.
+
+              \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b host:port
+     */
+
+    corbaClient(const char *pszIOR_or_ServantName, long lCORBA_Invocation_Timeout = -1, AutoPolling autopoll= AUTO_POLL_OFF)
+    {
+      long err;
+
+      remoteServant = NULL;
+
+#if defined(_TAO_1_4_) || defined (_TAO_1_5_)
+      if( lCORBA_Invocation_Timeout > 0)
+      {
+          // override the Invocation Timeout for this client
+          //
+          SetInvocationTimeout(  orb(),            ///< the CORBA ORB
+                                 lCORBA_Invocation_Timeout,
+                                 true             ///< true: for thread, false: for ORB
+                              );
+      }
+#endif // _TAO_1_4_
+      bool local= false;
+      std::string name;
+      if((err = createObject(pszIOR_or_ServantName,obj, local, name)) == 0)
+      {
+        pollingName(name);
+        err = connect();
+
+        if(err == 0)
+        {
+          run();
+          startAutoPolling(local, autopoll);
+        }
+      }
+    }
+
+    /** Class constructor
+        @param pszInitialService - CORBA initial service, like Naming Service to connect to
+        @param pszIOR - CORBA IOR to connect to
+        @attention Not yet implememted
+     */
+
+    corbaClient(const char *pszInitialService, const char *pszIOR, long lCORBA_Invocation_Timeout = -1, AutoPolling autopoll= AUTO_POLL_OFF)
+    {
+#if defined(_TAO_1_4_) || defined (_TAO_1_5_)
+      if( lCORBA_Invocation_Timeout > 0)
+      {
+          // override the Invocation Timeout for this client
+          //
+          SetInvocationTimeout(  orb(),            ///< the CORBA ORB
+                                 lCORBA_Invocation_Timeout,
+                                 true             ///< true: for thread, false: for ORB
+                              );
+      }
+#endif //_TAO_1_4_
+
+      // rest remains uncoded
+    }
+
+    /** Class constructor
+        @param pszHost - IP address of the remote host to connect to
+        @param port - The port on the remote host to connect to
+        @param pszServant - Name of the remote servant to connect to
+     */
+
+    corbaClient(const char *pszHost, long port, const char* pszServant, long lCORBA_Invocation_Timeout = -1, AutoPolling autopoll= AUTO_POLL_OFF)
+    {
+      long err;
+
+      remoteServant = NULL;
+
+#if defined(_TAO_1_4_) || defined (_TAO_1_5_)
+      if( lCORBA_Invocation_Timeout > 0)
+      {
+          // override the Invocation Timeout for this client
+          //
+          SetInvocationTimeout(  orb(),            ///< the CORBA ORB
+                                 lCORBA_Invocation_Timeout,
+                                 true             ///< true: for thread, false: for ORB
+                              );
+      }
+#endif // _TAO_1_4_
+
+      bool local= false;
+      std::string name;
+      if((err = createObject(pszHost,port,pszServant,obj, local, name)) == 0)
+      {
+        pollingName(name);
+        err = connect();
+
+        if(err == 0)
+        {
+          run();
+          startAutoPolling(local, autopoll);
+        }
+      }
+    }
+
+    /** Class constructor
+        @param Host - IP address of the remote host to connect to
+        @param port - The port on the remote host to connect to
+        @param pszServant - Name of the remote servant to connect to
+     */
+
+    corbaClient(std::string const & Host, long port, const char* pszServant, long lCORBA_Invocation_Timeout = -1, AutoPolling autopoll= AUTO_POLL_OFF)
+    {
+      long err;
+
+      remoteServant = NULL;
+
+#if defined(_TAO_1_4_) || defined (_TAO_1_5_)
+      if( lCORBA_Invocation_Timeout > 0)
+      {
+          // override the Invocation Timeout for this client
+          //
+          SetInvocationTimeout(  orb(),            ///< the CORBA ORB
+                                 lCORBA_Invocation_Timeout,
+                                 true             ///< true: for thread, false: for ORB
+                              );
+      }
+#endif // _TAO_1_4_
+
+      bool local= false;
+      std::string name;
+      if((err = createObject(Host.c_str(),port,pszServant,obj, local, name)) == 0)
+      {
+        pollingName(name);
+        err = connect();
+
+        if(err == 0)
+        {
+          run();
+          startAutoPolling(local, autopoll);
+        }
+      }
+    }
+
+    /** Class constructor
+        @param servant - duplicated in constructor, released in destructor
+     */
+
+    corbaClient(T* servant, long lCORBA_Invocation_Timeout = -1, AutoPolling autopoll= AUTO_POLL_OFF)
+    {
+      long err;
+
+      remoteServant = NULL;
+
+#if defined(_TAO_1_4_) || defined (_TAO_1_5_)
+      if( lCORBA_Invocation_Timeout > 0)
+      {
+          // override the Invocation Timeout for this client
+          //
+          SetInvocationTimeout(  orb(),            ///< the CORBA ORB
+                                 lCORBA_Invocation_Timeout,
+                                 true             ///< true: for thread, false: for ORB
+                              );
+      }
+#endif // _TAO_1_4_
+
+      remoteServant = servant->_duplicate(servant);
+      obj= remoteServant->_duplicate(remoteServant);
+      pollingName(ior());
+      run();
+      startAutoPolling(false, autopoll);
+    }
+
+
+    /** Class destructor */
+
+   ~corbaClient()
+    {
+      stopPolling();
+      if(remoteServant)
+      {
+        CORBA::release(remoteServant);
+        remoteServant = NULL;
+      }
+    }
+};
+
+/** Template class for the implementation of simple CORBA clients that
+ *  don't need callback functionality.
+ */
+
+template<class T> class corbaCallbackClient : public corbaClient <T>
+{
+public:
+
+    /** Class constructor
+        @param pszIOR_or_ServantName - Valid CORBA IOR or CORBALOC address
+
+        @note If the given parameter does not specify a valid IOR or CORBALOC address
+              the host address and port is read from the configuration. This allows
+              to contact servants via its names only.
+
+              \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b host:port
+     */
+
+    corbaCallbackClient(const char *pszIOR_or_ServantName, long lCORBA_Invocation_Timeout = -1, AutoPolling autopoll= AUTO_POLL_OFF):
+      corbaClient<T> (pszIOR_or_ServantName, lCORBA_Invocation_Timeout, autopoll)
+    {
+       createRootPOA();
+
+       long rc = activateCallback();
+    }
+
+    /** Class constructor
+        @param pszHost - IP address of the remote host to connect to
+        @param port - The port on the remote host to connect to
+        @param pszServant - Name of the remote servant to connect to
+     */
+
+    corbaCallbackClient(const char *pszHost,
+                        const long  port,
+                        const char *pszServant,
+                        long lCORBA_Invocation_Timeout = -1,
+                        AutoPolling autopoll= AUTO_POLL_OFF
+                       ) : corbaClient<T> (pszHost, port, pszServant, lCORBA_Invocation_Timeout, autopoll)
+    {
+       createRootPOA();
+
+       long rc = activateCallback();
+    }
+
+    /** Class constructor
+        @param Host - IP address of the remote host to connect to
+        @param port - The port on the remote host to connect to
+        @param pszServant - Name of the remote servant to connect to
+     */
+
+    corbaCallbackClient(std::string const & Host,
+                        const long  port,
+                        const char *pszServant,
+                        long lCORBA_Invocation_Timeout = -1,
+                        AutoPolling autopoll= AUTO_POLL_OFF
+                       ) : corbaClient<T> (Host, port, pszServant, lCORBA_Invocation_Timeout, autopoll)
+    {
+       createRootPOA();
+
+       long rc = activateCallback();
+    }
+
+    /** Class destructor */
+
+   ~corbaCallbackClient()
+   {
+      // everything is done in ~corbaClient() ...
+   }
+};
+
+#endif //CORBACLNT_H
diff --git a/SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr.h b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr.h
index 01ce4505..f5a0a288 100644
--- a/SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr.h
+++ b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr.h
@@ -1,178 +1,5 @@
-/**
- *  @file      corbasrvr.h
- *
- *  @brief     Header file for CORBA server/servant classes.
- *
- *  @date      16.12.2003
- *
- *  @author    Materna Information & Communications (AGe)
- *
- ************************************************************************/
-
-#ifndef CORBASRVR_H
-#define CORBASRVR_H
-
-#ifdef  SHOW_INCLUDE_FILES
-#pragma message("including: " __FILE__)
-#endif
-
-#include "massaiCorba/corbasrvr.hpp"
-
-// corbaChildServant
-template<class T>
-PortableServer::Servant corbaChildServant<T>::getServant()
-{
-  return servant;
-}
-
-template<class T>
-std::string corbaChildServant<T>::getIOR(CORBA::ORB_ptr orb)
-{
-  // Turn your object reference into an IOR string
-  CORBA::String_var ior = orb->object_to_string(servant->_this());
-  return ior.in();
-}
-
-template<class T>
-PortableServer::POA_ptr corbaChildServant<T>::getPOA()
-{
-  return servant->_default_POA()
-}
-
-template<class T>
-corbaChildServant<T>::corbaChildServant(T& servant, const char* pszServantName):
-  corbaChildServantBase(pszServantName)
-{
-  this->servant = &servant;
-}
-
-template<class T>
-corbaChildServant<T>::~corbaChildServant()
-{
-  deactivate();
-}
-
-// corbaServantEx
-template<class T>
-PortableServer::Servant corbaServantEx<T>::getServant()
-{
-  return servant;
-}
-
-template<class T>
-std::string corbaServantEx<T>::getIOR(CORBA::ORB_ptr orb)
-{
-  // Turn your object reference into an IOR string
-  CORBA::String_var ior = orb->object_to_string(servant->_this());
-  return ior.in();
-}
-
-template<class T>
-PortableServer::POA_ptr corbaServantEx<T>::getPOA()
-{
-  return servant->_default_POA();
-}
-
-
-/** This constructor reads the port from the configuration.
-    \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b (host:)port
-
-    @param lThreads - The number of concurrent threads for this servant
-    @param servant - The servant class that implements the servants functionality
-    @param pszServantName - The name of the servant
-*/
-template<class T>
-corbaServantEx<T>::corbaServantEx(long lThreads, T& servant, const char* pszServantName):
-  corbaServantExBase(getConfigHost(pszServantName).c_str(), getConfigPort(pszServantName), lThreads),
-  servant(&servant)
-{
-  createServant(pszServantName);
-}
-
-/** Class constructor
-    @param lThreads - The number of concurrent threads for this servant
-    @param servant - The servant class that implements the servants functionality
-    @param pszServantName - The name of the servant
-    @param port - The port to which the ORB is listening to
-*/
-template<class T>
-corbaServantEx<T>::corbaServantEx(long lThreads, T& servant, const char* pszServantName, long port):
-  corbaServantExBase(port, lThreads),
-  servant(&servant)
-{
-  createServant(pszServantName);
-}
-
-/** Class constructor
-    @param lThreads - The number of concurrent threads for this servant
-    @param servant - The servant class that implements the servants functionality
-    @param pszServantName - The name of the servant
-    @param interface - The interface to which the ORB is listening
-    @param port - The port to which the ORB is listening to
-*/
-template<class T>
-corbaServantEx<T>::corbaServantEx
-(
-  long lThreads,
-  T& servant,
-  const char* pszServantName,
-  const char* pszInterface,
-  long port
-):
-  corbaServantExBase(pszInterface, port, lThreads),
-  servant(&servant)
-{
-  createServant(pszServantName);
-}
-
-/** Class constructor
-    @param lThreads - The number of concurrent threads for this servant
-    @param servant - The servant class that implements the servants functionality
-    @param pszServantName - The name of the servant
-    @param port - The port to which the ORB is listening to
-    @param pszHostname_in_ior - Use that CORBA option
-*/
-template<class T>
-corbaServantEx<T>::corbaServantEx
-(
-  long lThreads,
-  T& servant,
-  const char* pszServantName,
-  long port,
-  const char* pszHostname_in_ior
-):
-  corbaServantExBase(port, lThreads, pszHostname_in_ior),
-  servant(&servant)
-{
-  createServant(pszServantName);
-}
-
-/** Class destructor */
-template<class T>
-corbaServantEx<T>::~corbaServantEx()
-{
-  deactivate();
-}
-
-// corbaServant
-template<class T>
-corbaServant<T>::corbaServant(T& servant, const char* pszServantName):
-  corbaServantEx <T>(1, servant, pszServantName)
-{}
-
-/** Class constructor
-    @param servant - The servant class that implements the servants functionality
-    @param pszServantName - The name of the servant
-    @param port - The port to which the ORB is listening to
-*/
-template<class T>
-corbaServant<T>::corbaServant(T& servant, const char* pszServantName, long port):
-  corbaServantEx<T>(1, servant, pszServantName, port)
-{}
-
-/** Class destructor */
-template<class T>
-corbaServant<T>::~corbaServant()
-{}
-
+#if defined(_COMPILER_VERSION_VC6)
+#include "massaiCorba/corbasrvr_vc6.h"
+#else
+#include "massaiCorba/corbasrvr_vc10.h"
 #endif
diff --git a/SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr.hpp b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr.hpp
index de3ad260..7cd75e72 100644
--- a/SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr.hpp
+++ b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr.hpp
@@ -1,111 +1,3 @@
-// Interface CORBA server/servant classes.
-#ifndef CORBASRVR_HPP
-#define CORBASRVR_HPP
-
-#ifdef  SHOW_INCLUDE_FILES
-#pragma message("including: " __FILE__)
-#endif
-
-#include "massaiCorba/corbaorb.h"
-#include "massaiCorba/corbasrvrbase.h"
-#include "massaiCorba/corbacfg.h"
-#include <string>
-
-template<class T> class corbaChildServant: public massaiCorba::corbaChildServantBase
-{
-  public:
-    corbaChildServant(T& servant, const char* pszServantName);
-   ~corbaChildServant();
-
-  private:
-    T* servant;
-
-    virtual PortableServer::Servant getServant();
-    virtual PortableServer::POA_ptr getPOA();
-    virtual std::string getIOR(CORBA::ORB_ptr orb);
-};
-
-/** Template class for the implementation of (extended) CORBA servants that
-   provides the functionality for connected clients.
-*/
-template<class T> class corbaServantEx: public massaiCorba::corbaServantExBase
-{
-  public:
-    /** This constructor reads the port from the configuration.
-        \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b (host:)port
-
-        @param lThreads - The number of concurrent threads for this servant
-        @param servant - The servant class that implements the servants functionality
-        @param pszServantName - The name of the servant
-     */
-    corbaServantEx(long lThreads, T& servant, const char* pszServantName = "");
-
-    /** Class constructor
-        @param lThreads - The number of concurrent threads for this servant
-        @param servant - The servant class that implements the servants functionality
-        @param pszServantName - The name of the servant
-        @param port - The port to which the ORB is listening to
-     */
-    corbaServantEx(long lThreads, T& servant, const char* pszServantName, long port);
-
-    /** Class constructor
-        @param lThreads - The number of concurrent threads for this servant
-        @param servant - The servant class that implements the servants functionality
-        @param pszServantName - The name of the servant
-        @param interface - The interface to which the ORB is listening
-        @param port - The port to which the ORB is listening to
-     */
-    corbaServantEx
-    (
-      long lThreads,
-      T& servant,
-      const char* pszServantName,
-      const char* pszInterface,
-      long port
-    );
-
-    /** Class constructor
-        @param lThreads - The number of concurrent threads for this servant
-        @param servant - The servant class that implements the servants functionality
-        @param pszServantName - The name of the servant
-        @param port - The port to which the ORB is listening to
-        @param pszHostname_in_ior - Use that CORBA option
-     */
-    corbaServantEx
-    (
-      long lThreads,
-      T& servant,
-      const char* pszServantName,
-      long port,
-      const char* pszHostname_in_ior
-    );
-
-    /** Class destructor */
-    ~corbaServantEx();
-
-  private:
-    T *servant;
-
-    virtual PortableServer::Servant getServant();
-    virtual PortableServer::POA_ptr getPOA();
-    virtual std::string getIOR(CORBA::ORB_ptr orb);
-};
-
-/** Template class for the implementation of CORBA servants that
-    provides the functionality for connected clients.
-*/
-template<class T> class corbaServant : public corbaServantEx<T>
-{
-  public:
-    corbaServant(T& servant, const char* pszServantName = "");
-    /** Class constructor
-        @param servant - The servant class that implements the servants functionality
-        @param pszServantName - The name of the servant
-        @param port - The port to which the ORB is listening to
-     */
-    corbaServant(T& servant, const char* pszServantName, long port);
-    /** Class destructor */
-   ~corbaServant();
-};
-
+#if !defined(_COMPILER_VERSION_VC6)
+#include "massaiCorba/corbasrvr_vc10.hpp"
 #endif
diff --git a/SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr_VC10.h b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr_VC10.h
new file mode 100644
index 00000000..01ce4505
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr_VC10.h
@@ -0,0 +1,178 @@
+/**
+ *  @file      corbasrvr.h
+ *
+ *  @brief     Header file for CORBA server/servant classes.
+ *
+ *  @date      16.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ *
+ ************************************************************************/
+
+#ifndef CORBASRVR_H
+#define CORBASRVR_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "massaiCorba/corbasrvr.hpp"
+
+// corbaChildServant
+template<class T>
+PortableServer::Servant corbaChildServant<T>::getServant()
+{
+  return servant;
+}
+
+template<class T>
+std::string corbaChildServant<T>::getIOR(CORBA::ORB_ptr orb)
+{
+  // Turn your object reference into an IOR string
+  CORBA::String_var ior = orb->object_to_string(servant->_this());
+  return ior.in();
+}
+
+template<class T>
+PortableServer::POA_ptr corbaChildServant<T>::getPOA()
+{
+  return servant->_default_POA()
+}
+
+template<class T>
+corbaChildServant<T>::corbaChildServant(T& servant, const char* pszServantName):
+  corbaChildServantBase(pszServantName)
+{
+  this->servant = &servant;
+}
+
+template<class T>
+corbaChildServant<T>::~corbaChildServant()
+{
+  deactivate();
+}
+
+// corbaServantEx
+template<class T>
+PortableServer::Servant corbaServantEx<T>::getServant()
+{
+  return servant;
+}
+
+template<class T>
+std::string corbaServantEx<T>::getIOR(CORBA::ORB_ptr orb)
+{
+  // Turn your object reference into an IOR string
+  CORBA::String_var ior = orb->object_to_string(servant->_this());
+  return ior.in();
+}
+
+template<class T>
+PortableServer::POA_ptr corbaServantEx<T>::getPOA()
+{
+  return servant->_default_POA();
+}
+
+
+/** This constructor reads the port from the configuration.
+    \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b (host:)port
+
+    @param lThreads - The number of concurrent threads for this servant
+    @param servant - The servant class that implements the servants functionality
+    @param pszServantName - The name of the servant
+*/
+template<class T>
+corbaServantEx<T>::corbaServantEx(long lThreads, T& servant, const char* pszServantName):
+  corbaServantExBase(getConfigHost(pszServantName).c_str(), getConfigPort(pszServantName), lThreads),
+  servant(&servant)
+{
+  createServant(pszServantName);
+}
+
+/** Class constructor
+    @param lThreads - The number of concurrent threads for this servant
+    @param servant - The servant class that implements the servants functionality
+    @param pszServantName - The name of the servant
+    @param port - The port to which the ORB is listening to
+*/
+template<class T>
+corbaServantEx<T>::corbaServantEx(long lThreads, T& servant, const char* pszServantName, long port):
+  corbaServantExBase(port, lThreads),
+  servant(&servant)
+{
+  createServant(pszServantName);
+}
+
+/** Class constructor
+    @param lThreads - The number of concurrent threads for this servant
+    @param servant - The servant class that implements the servants functionality
+    @param pszServantName - The name of the servant
+    @param interface - The interface to which the ORB is listening
+    @param port - The port to which the ORB is listening to
+*/
+template<class T>
+corbaServantEx<T>::corbaServantEx
+(
+  long lThreads,
+  T& servant,
+  const char* pszServantName,
+  const char* pszInterface,
+  long port
+):
+  corbaServantExBase(pszInterface, port, lThreads),
+  servant(&servant)
+{
+  createServant(pszServantName);
+}
+
+/** Class constructor
+    @param lThreads - The number of concurrent threads for this servant
+    @param servant - The servant class that implements the servants functionality
+    @param pszServantName - The name of the servant
+    @param port - The port to which the ORB is listening to
+    @param pszHostname_in_ior - Use that CORBA option
+*/
+template<class T>
+corbaServantEx<T>::corbaServantEx
+(
+  long lThreads,
+  T& servant,
+  const char* pszServantName,
+  long port,
+  const char* pszHostname_in_ior
+):
+  corbaServantExBase(port, lThreads, pszHostname_in_ior),
+  servant(&servant)
+{
+  createServant(pszServantName);
+}
+
+/** Class destructor */
+template<class T>
+corbaServantEx<T>::~corbaServantEx()
+{
+  deactivate();
+}
+
+// corbaServant
+template<class T>
+corbaServant<T>::corbaServant(T& servant, const char* pszServantName):
+  corbaServantEx <T>(1, servant, pszServantName)
+{}
+
+/** Class constructor
+    @param servant - The servant class that implements the servants functionality
+    @param pszServantName - The name of the servant
+    @param port - The port to which the ORB is listening to
+*/
+template<class T>
+corbaServant<T>::corbaServant(T& servant, const char* pszServantName, long port):
+  corbaServantEx<T>(1, servant, pszServantName, port)
+{}
+
+/** Class destructor */
+template<class T>
+corbaServant<T>::~corbaServant()
+{}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr_VC10.hpp b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr_VC10.hpp
new file mode 100644
index 00000000..de3ad260
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr_VC10.hpp
@@ -0,0 +1,111 @@
+// Interface CORBA server/servant classes.
+#ifndef CORBASRVR_HPP
+#define CORBASRVR_HPP
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "massaiCorba/corbaorb.h"
+#include "massaiCorba/corbasrvrbase.h"
+#include "massaiCorba/corbacfg.h"
+#include <string>
+
+template<class T> class corbaChildServant: public massaiCorba::corbaChildServantBase
+{
+  public:
+    corbaChildServant(T& servant, const char* pszServantName);
+   ~corbaChildServant();
+
+  private:
+    T* servant;
+
+    virtual PortableServer::Servant getServant();
+    virtual PortableServer::POA_ptr getPOA();
+    virtual std::string getIOR(CORBA::ORB_ptr orb);
+};
+
+/** Template class for the implementation of (extended) CORBA servants that
+   provides the functionality for connected clients.
+*/
+template<class T> class corbaServantEx: public massaiCorba::corbaServantExBase
+{
+  public:
+    /** This constructor reads the port from the configuration.
+        \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b (host:)port
+
+        @param lThreads - The number of concurrent threads for this servant
+        @param servant - The servant class that implements the servants functionality
+        @param pszServantName - The name of the servant
+     */
+    corbaServantEx(long lThreads, T& servant, const char* pszServantName = "");
+
+    /** Class constructor
+        @param lThreads - The number of concurrent threads for this servant
+        @param servant - The servant class that implements the servants functionality
+        @param pszServantName - The name of the servant
+        @param port - The port to which the ORB is listening to
+     */
+    corbaServantEx(long lThreads, T& servant, const char* pszServantName, long port);
+
+    /** Class constructor
+        @param lThreads - The number of concurrent threads for this servant
+        @param servant - The servant class that implements the servants functionality
+        @param pszServantName - The name of the servant
+        @param interface - The interface to which the ORB is listening
+        @param port - The port to which the ORB is listening to
+     */
+    corbaServantEx
+    (
+      long lThreads,
+      T& servant,
+      const char* pszServantName,
+      const char* pszInterface,
+      long port
+    );
+
+    /** Class constructor
+        @param lThreads - The number of concurrent threads for this servant
+        @param servant - The servant class that implements the servants functionality
+        @param pszServantName - The name of the servant
+        @param port - The port to which the ORB is listening to
+        @param pszHostname_in_ior - Use that CORBA option
+     */
+    corbaServantEx
+    (
+      long lThreads,
+      T& servant,
+      const char* pszServantName,
+      long port,
+      const char* pszHostname_in_ior
+    );
+
+    /** Class destructor */
+    ~corbaServantEx();
+
+  private:
+    T *servant;
+
+    virtual PortableServer::Servant getServant();
+    virtual PortableServer::POA_ptr getPOA();
+    virtual std::string getIOR(CORBA::ORB_ptr orb);
+};
+
+/** Template class for the implementation of CORBA servants that
+    provides the functionality for connected clients.
+*/
+template<class T> class corbaServant : public corbaServantEx<T>
+{
+  public:
+    corbaServant(T& servant, const char* pszServantName = "");
+    /** Class constructor
+        @param servant - The servant class that implements the servants functionality
+        @param pszServantName - The name of the servant
+        @param port - The port to which the ORB is listening to
+     */
+    corbaServant(T& servant, const char* pszServantName, long port);
+    /** Class destructor */
+   ~corbaServant();
+};
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr_VC6.h b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr_VC6.h
new file mode 100644
index 00000000..9413d316
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/generic/massaiCorba/corbasrvr_VC6.h
@@ -0,0 +1,410 @@
+/**
+ *  @file      corbasrvr.h
+ *
+ *  @brief     Header file for CORBA server/servant classes.
+ *
+ *  @date      16.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ *
+ ************************************************************************/
+
+#ifndef CORBASRVR_H
+#define CORBASRVR_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "massaiCorba/corbaorb.h"
+#include "massaiCorba/corbaorbEx.h"
+#include "massaiCorba/corbacfg.h"
+#include <string>
+
+#if defined (_MICO_)
+
+#error Use MICO for clients only !!!
+
+#endif
+
+template<class T> class corbaChildServant
+{
+private:
+
+    T *servant;
+
+    CORBA::Object_var            obj;
+    PortableServer::ObjectId_var objID;
+
+    //char szServantName[256];
+    //char szIOR[1024];
+    std::string m_ior;
+    std::string m_servantName;
+
+public:
+
+    const char *ior() { return(m_ior.c_str()); }
+
+    long activate(CORBA::ORB_ptr orb, PortableServer::POA_ptr poa)
+    {
+      long rc = 0;
+
+      if((m_servantName.size() > 0) && servant)
+      {
+        objID = PortableServer::string_to_ObjectId(m_servantName.c_str());
+
+        poa->activate_object_with_id(objID,servant);
+
+#if defined(_ORBACUS_)
+
+        PortableServer::ObjectId_var bindingObjID;
+
+        bindingObjID = PortableServer::string_to_ObjectId(m_servantName.c_str());
+
+        CORBA::Object_var bootManagerObj = orb->resolve_initial_references("BootManager");
+
+        OB::BootManager_var bootManager = OB::BootManager::_narrow(bootManagerObj);
+
+        bootManager->add_binding(bindingObjID,servant->_this());
+
+#elif defined(_TAO_)
+
+        // Turn your object reference into an IOR string
+
+        CORBA::String_var ior = orb->object_to_string(servant->_this());
+
+        // Get a reference to the IOR Table
+
+        CORBA::Object_var tableObj = orb->resolve_initial_references("IORTable");
+
+        IORTable::Table_var table = IORTable::Table::_narrow(tableObj.in());
+
+        // Bind your stringified IOR in the IOR Table
+
+        table->bind(m_servantName.c_str(), ior.in());
+
+        // save IOR ...
+
+        //strcpy(szIOR,ior.in());
+        m_ior= ior.in();
+#endif
+      }
+      else
+        rc = -1;
+
+      return(rc);
+    }
+
+
+    long remove(CORBA::ORB_ptr orb)
+    {
+#if defined(_TAO_)
+
+       // Get a reference to the IOR Table
+
+       CORBA::Object_var tableObj = orb->resolve_initial_references("IORTable");
+
+       IORTable::Table_var table = IORTable::Table::_narrow(tableObj.in());
+
+       // Bind your stringified IOR in the IOR Table
+
+       try
+       {
+         table->unbind(m_servantName.c_str());
+       }
+       catch(CORBA::SystemException& e)
+       {
+         TRACE(HERE_5,"CORBA Exception: %s",e._message());
+       }
+       catch(CORBA::UserException& e)
+       {
+         TRACE(HERE_5,"CORBA UserException: %s",e._message());
+       }
+       catch(exception& e)
+       {
+         TRACE(HERE_5,"Exception: %s",e.what());
+       }
+       catch(...)
+       {
+         TRACE(HERE_5,"unknown exception");
+       }
+       return 0;
+#else
+        return -1;
+#endif
+    }
+
+    corbaChildServant(T& servant, const char *pszServantName)
+    {
+      // initialize & set defaults
+
+      //*szServantName = '\0';
+      //*szIOR         = '\0';
+
+      this->servant = &servant;
+
+      if(pszServantName)
+      {
+        //strcpy(szServantName,pszServantName);
+        m_servantName= pszServantName;
+      }
+    }
+
+   ~corbaChildServant()
+    {
+       PortableServer::POA_var p;
+
+       TRACE(HERE_8,">> ~corbaChildServant()");
+       try
+       {
+         p = servant->_default_POA();
+         p->deactivate_object(objID);
+       }
+       catch(CORBA::SystemException& e)
+       {
+         TRACE(HERE_5,"CORBA Exception: %s",e._message());
+       }
+       catch(CORBA::UserException& e)
+       {
+         TRACE(HERE_5,"CORBA UserException: %s",e._message());
+       }
+       catch(exception& e)
+       {
+         TRACE(HERE_5,"Exception: %s",e.what());
+       }
+       catch(...)
+       {
+         TRACE(HERE_5,"unknown exception");
+       }
+       TRACE(HERE_8,"<< ~corbaChildServant()");
+    }
+};
+
+/** Template class for the implementation of (extended) CORBA servants that
+ *  provides the functionality for connected clients.
+ */
+
+template<class T> class corbaServantEx : public corbaOrbEx
+{
+protected:
+
+    T *servant;
+
+    CORBA::Object_var       obj;
+    PortableServer::POA_var poa;
+
+    PortableServer::ObjectId_var objID;
+
+    std::string m_ior;
+
+    long createServant(const char *pszServantName)
+    {
+        long rc = 0;
+
+        if(!pszServantName || !*pszServantName)
+          return(-1);
+
+        createRootPOA();
+
+        poa = createPOA(pszServantName);
+
+        objID = PortableServer::string_to_ObjectId(pszServantName);
+
+        poa->activate_object_with_id(objID,servant);
+
+#if defined(_ORBACUS_)
+
+        PortableServer::ObjectId_var bindingObjID;
+
+        bindingObjID = PortableServer::string_to_ObjectId(pszServantName);
+
+        CORBA::Object_var bootManagerObj = orb()->resolve_initial_references("BootManager");
+
+        OB::BootManager_var bootManager = OB::BootManager::_narrow(bootManagerObj);
+
+        bootManager->add_binding(bindingObjID,servant->_this());
+
+#elif defined(_TAO_)
+
+        // Turn your object reference into an IOR string
+
+        CORBA::String_var ior = orb()->object_to_string(servant->_this());
+
+        // Get a reference to the IOR Table
+
+        CORBA::Object_var tableObj = orb()->resolve_initial_references("IORTable");
+
+        IORTable::Table_var table = IORTable::Table::_narrow(tableObj.in());
+
+        // Bind your stringified IOR in the IOR Table
+
+        table->bind(pszServantName,ior.in());
+
+#endif
+        // execute ORB(s)...
+
+        start();
+
+        // ... and activate POA(s)
+
+        return(activateServer());
+    }
+
+public:
+
+    // adds a new child servant to the POA structure
+
+    long addServant(const void *childServant)
+    {
+        if(childServant)
+          return(((corbaChildServant<T> *)childServant)->activate(orb(), servant->_default_POA()));
+        else
+          return(-1);
+    }
+
+
+    // removes a child servant out of the POA structure
+
+    long removeServant(const void *childServant)
+    {
+        if(childServant)
+          return(((corbaChildServant<T> *)childServant)->remove(orb()));
+        else
+          return(-1);
+    }
+
+
+    /** Returns the IOR of this object */
+
+    const char *ior()
+    {
+      if(m_ior.size() == 0)
+      {
+        CORBA::String_var ior_= orb()->object_to_string(servant->_this());
+        m_ior= ior_.in();
+      }
+      return m_ior.c_str();
+    }
+
+    /** This constructor reads the port from the configuration.
+        \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b (host:)port
+
+        @param lThreads - The number of concurrent threads for this servant
+        @param servant - The servant class that implements the servants functionality
+        @param pszServantName - The name of the servant
+     */
+
+    corbaServantEx(const long lThreads, T& servant, const char *pszServantName = "")
+     : corbaOrbEx(getConfigHost(pszServantName).c_str(), getConfigPort(pszServantName),lThreads)
+    {
+      long err;
+
+      this->servant = &servant;
+      err = createServant(pszServantName);
+    }
+
+    /** Class constructor
+        @param lThreads - The number of concurrent threads for this servant
+        @param servant - The servant class that implements the servants functionality
+        @param pszServantName - The name of the servant
+        @param port - The port to which the ORB is listening to
+     */
+
+    corbaServantEx(const long lThreads, T& servant, const char *pszServantName, const long port)
+      : corbaOrbEx(port,lThreads)
+    {
+      long err;
+
+      this->servant = &servant;
+      err = createServant(pszServantName);
+    }
+
+    /** Class constructor
+        @param lThreads - The number of concurrent threads for this servant
+        @param servant - The servant class that implements the servants functionality
+        @param pszServantName - The name of the servant
+        @param interface - The interface to which the ORB is listening
+        @param port - The port to which the ORB is listening to
+     */
+
+    corbaServantEx( const long lThreads, T& servant, 
+				    const char *pszServantName, const char *pSzInterface, const long port)
+      : corbaOrbEx( pSzInterface, port, lThreads )
+    {
+      long err;
+
+      this->servant = &servant;
+      err = createServant(pszServantName);
+    }
+
+    /** Class constructor
+        @param lThreads - The number of concurrent threads for this servant
+        @param servant - The servant class that implements the servants functionality
+        @param pszServantName - The name of the servant
+        @param port - The port to which the ORB is listening to
+        @param pszHostname_in_ior - Use that CORBA option
+     */
+
+    corbaServantEx(const long lThreads, T& servant, const char *pszServantName,
+                   const long port, const char *pszHostname_in_ior)
+      : corbaOrbEx(port,lThreads,pszHostname_in_ior)
+    {
+      long err;
+
+      this->servant = &servant;
+      err = createServant(pszServantName);
+    }
+
+
+    /** Class destructor */
+
+   ~corbaServantEx()
+   {
+       PortableServer::POA_var      p;
+       PortableServer::ObjectId_var id;
+
+       try
+       {
+         p  = servant->_default_POA();
+         id = p->servant_to_id(servant);
+
+         p->deactivate_object(id);
+       }
+       catch(...) { }
+
+       try
+       {
+         if(!CORBA::is_nil(poa))
+           poa->destroy(false,false);
+       }
+       catch(...) { }
+   }
+};
+
+/** Template class for the implementation of CORBA servants that
+ *  provides the functionality for connected clients.
+ */
+
+template<class T> class corbaServant : public corbaServantEx <T>
+{
+public:
+
+    corbaServant(T& servant, const char *pszServantName = "")
+     : corbaServantEx <T> (1,servant,pszServantName) { }
+
+    /** Class constructor
+        @param servant - The servant class that implements the servants functionality
+        @param pszServantName - The name of the servant
+        @param port - The port to which the ORB is listening to
+     */
+
+    corbaServant(T& servant, const char *pszServantName, const long port)
+     : corbaServantEx <T> (1,servant,pszServantName,port) { }
+
+    /** Class destructor */
+
+   ~corbaServant() { }
+};
+
+
+#endif //CORBASRVR_H
diff --git a/SelfServiceCommon/Interfaces/inc/corbaorbEx.h b/SelfServiceCommon/Interfaces/inc/corbaorbEx.h
new file mode 100644
index 00000000..b5ec1e80
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/corbaorbEx.h
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES) 
+#pragma message("including: " __FILE__) 
+#endif 
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER) 
+#error "corbaorbEx.h" is deprecated, use "massaiCorba/corbaorbEx.h" instead. 
+#else 
+// #pragma message ("Warning: \"corbaorbEx.h\" is deprecated, use \"massaiCorba/corbaorbEx.h\" instead.") 
+#include "massaiCorba/corbaorbEx.h" 
+#endif 
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbacfg.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbacfg.h
index 74d76037..f97996cd 100644
--- a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbacfg.h
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbacfg.h
@@ -1,26 +1,5 @@
-/**
- *  @file      corbacfg.h
- *
- *  @brief     exports for config access
- *
- *  @date      16.12.2003
- *
- *  @author    Materna Information & Communications (AGe)
- *
- ************************************************************************/
-
-#ifndef CORBACFG_H
-#define CORBACFG_H
-
-#ifdef  SHOW_INCLUDE_FILES
-#pragma message("including: " __FILE__)
+#if defined(_COMPILER_VERSION_VC6)
+#include "massaiCorba/corbacfg_vc6.h"
+#else
+#include "massaiCorba/corbacfg_vc10.h"
 #endif
-
-#include <string>
-
-// exported functions
-long getConfigPort(const char* ServantName);
-std::string getConfigHost(const char* ServantName);
-long getConfigInvocationTimeout(const char* ServantName);
-
-#endif //CORBACFG_H
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbacfg_vc10.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbacfg_vc10.h
new file mode 100644
index 00000000..74d76037
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbacfg_vc10.h
@@ -0,0 +1,26 @@
+/**
+ *  @file      corbacfg.h
+ *
+ *  @brief     exports for config access
+ *
+ *  @date      16.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ *
+ ************************************************************************/
+
+#ifndef CORBACFG_H
+#define CORBACFG_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include <string>
+
+// exported functions
+long getConfigPort(const char* ServantName);
+std::string getConfigHost(const char* ServantName);
+long getConfigInvocationTimeout(const char* ServantName);
+
+#endif //CORBACFG_H
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbacfg_vc6.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbacfg_vc6.h
new file mode 100644
index 00000000..871cfd55
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbacfg_vc6.h
@@ -0,0 +1,35 @@
+/**
+ *  @file      corbacfg.h
+ *
+ *  @brief     exports for config access
+ *
+ *  @date      16.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ *
+ ************************************************************************/
+
+#ifndef CORBACFG_H
+#define CORBACFG_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include <string>
+
+#define CORBA_INVOCATION_TIMEOUT_CFG_LOCATION   "CORBA.InvocationTimeout"
+#define CORBA_INVOCATION_TIMEOUT_DEFAULT        (60 * 1000) // [in msec]
+#define CORBA_CONNECTION_TIMEOUT_DEFAULT        (15 * 1000) // [in msec]
+
+// exported functions
+
+long getConfigPort( char const * ServantName );
+
+std::string getConfigHost( char const * ServantName );
+
+#if defined(_TAO_1_4_) || defined (_TAO_1_5_) || defined (_TAO_2_0_)
+long getConfigInvocationTimeout( char const * ServantName );
+#endif // _TAO_1_4_
+
+#endif //CORBACFG_H
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaclntbase.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaclntbase.h
index 55123b8b..59efa79e 100644
--- a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaclntbase.h
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaclntbase.h
@@ -1,87 +1,3 @@
-// base classes for CORBA client template class
-
-#ifndef CORBACLNTBASE_H
-#define CORBACLNTBASE_H
-
-#ifdef  SHOW_INCLUDE_FILES
-#pragma message("including: " __FILE__)
+#if !defined(_COMPILER_VERSION_VC6)
+#include "massaiCorba/corbaclntbase_vc10.h"
 #endif
-
-#include "massaiCorba/orbIncDefs.h"
-#include "massaiCorba/corbaorb.h"
-#include "massaiCorba/corbapoll.h"
-#include <string>
-
-namespace massaiCorba
-{
-  class corbaClientBase: public corbaOrb, public corbaPoll
-  {
-    public:
-      /** Returns the IOR of this object */
-      const char* ior();
-
-    protected:
-      corbaClientBase();
-
-      /** init client
-          @param pszIOR_or_ServantName - Valid CORBA IOR or CORBALOC address
-
-          @note If the given parameter does not specify a valid IOR or CORBALOC address
-                the host address and port is read from the configuration. This allows
-                to contact servants via its names only.
-
-                \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b host:port
-      */
-      void init
-      (
-        const char* pszIOR_or_ServantName,
-        long invocationTimeout,
-        AutoPolling autopoll
-      );
-
-      /** init client
-          @param pszInitialService - CORBA initial service, like Naming Service to connect to
-          @param pszIOR - CORBA IOR to connect to
-          @attention Not yet implememted
-      */
-      void init
-      (
-        const char* pszInitialService,
-        const char* pszIOR,
-        long invocationTimeout,
-        AutoPolling autopoll
-      );
-
-      /** init client
-          @param pszHost - IP address of the remote host to connect to
-          @param port - The port on the remote host to connect to
-          @param pszServant - Name of the remote servant to connect to
-      */
-      void init
-      (
-        const char* pszHost,
-        long port,
-        const char* pszServant,
-        long invocationTimeout,
-        AutoPolling autopoll
-      );
-
-      void startProcessing
-      (
-        const std::string& servantName,
-        bool doConnect,
-        bool local,
-        AutoPolling autopoll
-      );
-      void initCallbackClient();
-      void setTimeout(long invocationTimeout);
-
-    private:
-      CORBA::Object_var obj;
-      std::string m_ior;
-      long connect();
-      virtual void narrow(CORBA::Object_var obj) = 0;
-  };
-}
-#endif
-
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaclntbase_vc10.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaclntbase_vc10.h
new file mode 100644
index 00000000..55123b8b
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaclntbase_vc10.h
@@ -0,0 +1,87 @@
+// base classes for CORBA client template class
+
+#ifndef CORBACLNTBASE_H
+#define CORBACLNTBASE_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "massaiCorba/orbIncDefs.h"
+#include "massaiCorba/corbaorb.h"
+#include "massaiCorba/corbapoll.h"
+#include <string>
+
+namespace massaiCorba
+{
+  class corbaClientBase: public corbaOrb, public corbaPoll
+  {
+    public:
+      /** Returns the IOR of this object */
+      const char* ior();
+
+    protected:
+      corbaClientBase();
+
+      /** init client
+          @param pszIOR_or_ServantName - Valid CORBA IOR or CORBALOC address
+
+          @note If the given parameter does not specify a valid IOR or CORBALOC address
+                the host address and port is read from the configuration. This allows
+                to contact servants via its names only.
+
+                \li Configuration item = \b [[MASSAI]] \b [COMPONENTS] \b "pszServantName" = \b host:port
+      */
+      void init
+      (
+        const char* pszIOR_or_ServantName,
+        long invocationTimeout,
+        AutoPolling autopoll
+      );
+
+      /** init client
+          @param pszInitialService - CORBA initial service, like Naming Service to connect to
+          @param pszIOR - CORBA IOR to connect to
+          @attention Not yet implememted
+      */
+      void init
+      (
+        const char* pszInitialService,
+        const char* pszIOR,
+        long invocationTimeout,
+        AutoPolling autopoll
+      );
+
+      /** init client
+          @param pszHost - IP address of the remote host to connect to
+          @param port - The port on the remote host to connect to
+          @param pszServant - Name of the remote servant to connect to
+      */
+      void init
+      (
+        const char* pszHost,
+        long port,
+        const char* pszServant,
+        long invocationTimeout,
+        AutoPolling autopoll
+      );
+
+      void startProcessing
+      (
+        const std::string& servantName,
+        bool doConnect,
+        bool local,
+        AutoPolling autopoll
+      );
+      void initCallbackClient();
+      void setTimeout(long invocationTimeout);
+
+    private:
+      CORBA::Object_var obj;
+      std::string m_ior;
+      long connect();
+      virtual void narrow(CORBA::Object_var obj) = 0;
+  };
+}
+#endif
+
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorb.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorb.h
index 45eaeb5e..d075bff6 100644
--- a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorb.h
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorb.h
@@ -1,70 +1,5 @@
-//---------------------------------------------------------------------------
-//
-//  file:       corbaOrb.h
-//
-//  purpose:    Header file for CORBA orb class.
-//
-//  date:       20.11.2001
-//
-//  author:     Dr. Materna GmbH (AGe)
-//
-//---------------------------------------------------------------------------
-
-#ifndef CORBAORB_H
-#define CORBAORB_H
-
-#ifdef  SHOW_INCLUDE_FILES
-#pragma message("including: " __FILE__)
-#endif
-
-#include "massaiCorba/orbIncDefs.h"
-#include <string>
-
-namespace massaiCorba
-{
-  /** Implementation of the base class for all CORBA clients and servers */
-  class corbaOrb
-  {
-    public:
-      /** Returns a pointer to the ORB */
-      CORBA::ORB_ptr orb();
-
-      /** Class constructor for CORBA server applications
-          @param hostname  - Specifies a host address for the ORB to listen on, this
-                                may be necessary if the host machine has multiple IP-adresses
-          @param port - Specifies a fixed port for the ORB to listen to
-          @param lThreads - The number of threads for this servant
-          @param pszHostname_in_ior - hostname to use in ior
-      */
-      corbaOrb(const std::string& hostname, long port, long lThreads, const std::string& hostname_in_ior);
-
-      /** class destructor */
-      ~corbaOrb();
-
-    protected:
-      /** Helper function for derived classes */
-      bool createObject(const std::string& IOR, CORBA::Object_var& obj, bool& local, std::string& name);
-
-      /** Helper function for derived classes */
-      bool createObject(const std::string& host, long port, const std::string& servant, CORBA::Object_var& obj, bool& local, std::string& name);
-
-      /** Helper function for derived classes */
-      void createRootPOA();
-
-      /** Helper function for derived classes */
-      PortableServer::POA *createPOA (const char *pszServantName);
-
-      /** Helper function for derived classes */
-      bool activateCallback();
-
-      /** Helper function for derived classes */
-      bool activateServer();
-
-    private:
-      CORBA::ORB_var                  _orb;
-      PortableServer::POA_var         rootPoa;
-      PortableServer::POAManager_var  poaManager;
-  };
-}
-
+#if defined(_COMPILER_VERSION_VC6)
+#include "massaiCorba/corbaorb_vc6.h"
+#else
+#include "massaiCorba/corbaorb_vc10.h"
 #endif
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorbEx.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorbEx.h
new file mode 100644
index 00000000..fa4477bc
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorbEx.h
@@ -0,0 +1,3 @@
+#if defined(_COMPILER_VERSION_VC6)
+#include "massaiCorba/corbaorbEx_vc6.h"
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorbEx_vc6.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorbEx_vc6.h
new file mode 100644
index 00000000..4ece4559
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorbEx_vc6.h
@@ -0,0 +1,129 @@
+/**
+ *  @file      corbaorbEx.h
+ *
+ *  @brief     Definition for extended ORB classes
+ *
+ *  @date      19.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ *
+ ************************************************************************/
+
+#ifndef CORBAORBEX_H
+#define CORBAORBEX_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "massaiCorba/orbIncDefs.h"
+
+class threadPool;
+
+/** Implementation of the base class for all CORBA servers.
+    This implementation now provides thread pools to support scalable servers.
+*/
+
+class corbaOrbEx
+{
+private:
+
+    CORBA::ORB_var                 _orb;
+    CORBA::ORB_var                 _orbSrvr;
+
+    CORBA::Object_var               poaObj;
+    PortableServer::POA_var         rootPoa;
+    PortableServer::POAManager_var  poaManager;
+    CORBA::PolicyList               policies;
+
+    char        szOrbName  [256];
+
+    char        szHostName [256];
+    char        szIORName  [256];
+    long        lPort;
+    long        lWorkers;
+
+    threadPool *workers;
+
+    long        createOrb();
+
+    void initialize(const char * pszHostName, long port, long lThreads, const char *pszHostname_in_ior);
+
+protected:
+
+    /** Helper function for derived classes */
+
+    long createObject(const char *pszIOR, CORBA::Object_var& obj);
+
+    /** Helper function for derived classes */
+
+    long createObject(const char *pszHost, long port, const char* pszServant, CORBA::Object_var& obj);
+
+    /** Helper function for derived classes */
+
+    char *bindingID(const char *pszServantName);
+
+    /** Helper function for derived classes */
+
+    void createRootPOA();
+
+    /** Helper function for derived classes */
+
+    PortableServer::POA *createPOA (const char *pszServantName);
+
+    /** Helper function for derived classes */
+
+    long activateCallback();
+
+    /** Helper function for derived classes */
+
+    long activateServer();
+
+public:
+
+    /** Starts execution of the ORB worker thread(s) */
+
+    void start();
+
+    /** Returns a pointer to the ORB */
+
+    CORBA::ORB_ptr orb();
+
+
+    /** Class constructor for CORBA server applications
+     */
+
+    corbaOrbEx();
+
+    /** Class constructor for CORBA server applications
+     *  @param port - Specifies a fixed port for the ORB to listen to
+        @param lThreads - The number of threads for this servant
+     */
+
+    corbaOrbEx(long port, long lThreads);
+
+
+    /** Class constructor for CORBA server applications
+     *  @param port - Specifies a fixed port for the ORB to listen to
+        @param lThreads - The number of threads for this servant
+        @param pszHostname_in_ior - hostname to use in ior
+     */
+
+    corbaOrbEx(long port, long lThreads, const char *pszHostname_in_ior);
+
+
+    /** Class constructor for CORBA server applications
+     *  @param pszHostName  - Specifies a host address for the ORB to listen on, this
+     *                        may be necessary if the host machine has multiple IP-adresses
+     *  @param port         - Specifies a fixed port for the ORB to listen to
+        @param lThreads - The number of threads for this servant
+     */
+
+    corbaOrbEx(const char * pszHostName, long port, long lThreads);
+
+    /** class destructor */
+
+   ~corbaOrbEx();
+};
+
+#endif //CORBACLNT_H
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorb_vc10.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorb_vc10.h
new file mode 100644
index 00000000..45eaeb5e
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorb_vc10.h
@@ -0,0 +1,70 @@
+//---------------------------------------------------------------------------
+//
+//  file:       corbaOrb.h
+//
+//  purpose:    Header file for CORBA orb class.
+//
+//  date:       20.11.2001
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+#ifndef CORBAORB_H
+#define CORBAORB_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "massaiCorba/orbIncDefs.h"
+#include <string>
+
+namespace massaiCorba
+{
+  /** Implementation of the base class for all CORBA clients and servers */
+  class corbaOrb
+  {
+    public:
+      /** Returns a pointer to the ORB */
+      CORBA::ORB_ptr orb();
+
+      /** Class constructor for CORBA server applications
+          @param hostname  - Specifies a host address for the ORB to listen on, this
+                                may be necessary if the host machine has multiple IP-adresses
+          @param port - Specifies a fixed port for the ORB to listen to
+          @param lThreads - The number of threads for this servant
+          @param pszHostname_in_ior - hostname to use in ior
+      */
+      corbaOrb(const std::string& hostname, long port, long lThreads, const std::string& hostname_in_ior);
+
+      /** class destructor */
+      ~corbaOrb();
+
+    protected:
+      /** Helper function for derived classes */
+      bool createObject(const std::string& IOR, CORBA::Object_var& obj, bool& local, std::string& name);
+
+      /** Helper function for derived classes */
+      bool createObject(const std::string& host, long port, const std::string& servant, CORBA::Object_var& obj, bool& local, std::string& name);
+
+      /** Helper function for derived classes */
+      void createRootPOA();
+
+      /** Helper function for derived classes */
+      PortableServer::POA *createPOA (const char *pszServantName);
+
+      /** Helper function for derived classes */
+      bool activateCallback();
+
+      /** Helper function for derived classes */
+      bool activateServer();
+
+    private:
+      CORBA::ORB_var                  _orb;
+      PortableServer::POA_var         rootPoa;
+      PortableServer::POAManager_var  poaManager;
+  };
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorb_vc6.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorb_vc6.h
new file mode 100644
index 00000000..a2cd215b
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbaorb_vc6.h
@@ -0,0 +1,106 @@
+//---------------------------------------------------------------------------
+//
+//  file:       corbaOrb.h
+//
+//  purpose:    Header file for CORBA orb class.
+//
+//  date:       20.11.2001
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+#ifndef CORBAORB_H
+#define CORBAORB_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "massaiCorba/orbIncDefs.h"
+#include "massaidll/mThreadEx.h"
+#include <string>
+
+/** Implementation of the base class for all CORBA clients and servers */
+
+class corbaOrb
+{
+private:
+
+    CORBA::ORB_var                 _orb;
+    CORBA::Object_var               poaObj;
+    PortableServer::POA_var         rootPoa;
+    PortableServer::POAManager_var  poaManager;
+    CORBA::PolicyList               policies;
+
+    bool fServer;
+
+
+    void init(const char * pszHostName, long port, bool client);
+
+protected:
+
+    /** Helper function for derived classes */
+
+    long createObject(const char *pszIOR, CORBA::Object_var& obj);
+    long createObject(const char *pszIOR, CORBA::Object_var& obj, bool& local, std::string& name);
+
+    /** Helper function for derived classes */
+
+    long createObject(const char *pszHost, long port, const char* pszServant, CORBA::Object_var& obj);
+    long createObject(const char *pszHost, long port, const char* pszServant, CORBA::Object_var& obj, bool& local, std::string& name);
+
+    /** Helper function for derived classes */
+
+    char *bindingID(const char *pszServantName);
+
+    /** Helper function for derived classes */
+
+    void createRootPOA();
+
+    /** Helper function for derived classes */
+
+    PortableServer::POA *createPOA (const char *pszServantName);
+
+    /** Helper function for derived classes */
+
+    long activateCallback();
+
+    /** Helper function for derived classes */
+
+    long activateServer();
+
+public:
+
+    /** Starts execution of the ORB */
+
+    void run();
+
+    /** Returns a pointer to the ORB */
+
+    CORBA::ORB_ptr orb();
+
+    /** Class constructor for CORBA client only applicatons */
+
+    corbaOrb();
+
+    /** Class constructor for CORBA server applications
+     *  @param port - Specifies a fixed port for the ORB to listen to
+     */
+
+    corbaOrb(long port);
+
+    /** Class constructor for CORBA server applications
+     *  @param pszHostName  - Specifies a host address for the ORB to listen on, this
+     *                        may be necessary if the host machine has multiple IP-adresses
+     *  @param port         - Specifies a fixed port for the ORB to listen to
+     */
+
+    corbaOrb(const char * pszHostName, long port);
+
+    /** class destructor */
+
+   ~corbaOrb();
+};
+
+#endif //CORBACLNT_H
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbapoll.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbapoll.h
index 028346d1..d0ea0944 100644
--- a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbapoll.h
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbapoll.h
@@ -1,54 +1,5 @@
-// CORBA polling
-
-#ifndef CORBAPOLL_H
-#define CORBAPOLL_H
-
-#ifdef  SHOW_INCLUDE_FILES
-#pragma message("including: " __FILE__)
-#endif
-
-#include "tools/pImplPtr.h"
-#include <string>
-
-enum AutoPolling
-{
-  AUTO_POLL_OFF,              // do not start polling automatically for non-local servants if not enabled by CORBA_AUTOPOLL_ENABLE environment parameter
-                              // do not start polling automatically for local     servants (hostname = "localhost" or "127.0.0.1")
-  AUTO_POLL_NON_LOCAL,        // do not start polling automatically for local     servants (hostname = "localhost" or "127.0.0.1")
-                              // do     start polling automatically for non-local servants if not disabled by CORBA_AUTOPOLL_DISABLE environment parameter
-  AUTO_POLL_ON,               // do     start polling automatically for all       servants if not disabled by CORBA_AUTOPOLL_DISABLE environment parameter
-  AUTO_POLL_NON_LOCAL_FORCE,  // do not start polling automatically for local     servants (hostname = "localhost" or "127.0.0.1")
-                              // do     start polling automatically for non-local servants ignore CORBA_AUTOPOLL_DISABLE environment parameter
-  AUTO_POLL_ON_FORCE,         // do     start polling automatically for all       servants ignore CORBA_AUTOPOLL_DISABLE environment parameter
-};
-
-class corbaPoll
-{
-  public:
-    corbaPoll();
-    virtual ~corbaPoll();
-
-    /* send ping to the servant, implemented in corbaClient */
-    virtual bool poll();
-    /* callback function called from polling thread, when polling failed, can be owerwritten by interested clients */
-    virtual void pollingFailed();
-
-    /* start polling with default timeout
-      if CORBA_AUTOPOLL_DISABLE is set in the environment nothing is done
-      if CORBA_AUTOPOLL_TIMEOUT is set in the environment the value (in ms) is used for poll timeout (default is 1 minute)
-    */
-    void startAutoPolling(bool local, AutoPolling autopoll);
-    /* start polling explicit */
-    void startPolling(long pollTimeout);
-    /* stop polling */
-    void stopPolling();
-    /* store servant name/ior */
-    void pollingName(const std::string& name);
-
-  private:
-    pImplPtr<class corbaPollImpl> m_pImpl;
-    corbaPoll(const corbaPoll& assign);
-    corbaPoll& operator=(const corbaPoll& assign);
-};
-
+#if defined(_COMPILER_VERSION_VC6)
+#include "massaiCorba/corbapoll_vc6.h"
+#else
+#include "massaiCorba/corbapoll_vc10.h"
 #endif
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbapoll_vc10.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbapoll_vc10.h
new file mode 100644
index 00000000..028346d1
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbapoll_vc10.h
@@ -0,0 +1,54 @@
+// CORBA polling
+
+#ifndef CORBAPOLL_H
+#define CORBAPOLL_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "tools/pImplPtr.h"
+#include <string>
+
+enum AutoPolling
+{
+  AUTO_POLL_OFF,              // do not start polling automatically for non-local servants if not enabled by CORBA_AUTOPOLL_ENABLE environment parameter
+                              // do not start polling automatically for local     servants (hostname = "localhost" or "127.0.0.1")
+  AUTO_POLL_NON_LOCAL,        // do not start polling automatically for local     servants (hostname = "localhost" or "127.0.0.1")
+                              // do     start polling automatically for non-local servants if not disabled by CORBA_AUTOPOLL_DISABLE environment parameter
+  AUTO_POLL_ON,               // do     start polling automatically for all       servants if not disabled by CORBA_AUTOPOLL_DISABLE environment parameter
+  AUTO_POLL_NON_LOCAL_FORCE,  // do not start polling automatically for local     servants (hostname = "localhost" or "127.0.0.1")
+                              // do     start polling automatically for non-local servants ignore CORBA_AUTOPOLL_DISABLE environment parameter
+  AUTO_POLL_ON_FORCE,         // do     start polling automatically for all       servants ignore CORBA_AUTOPOLL_DISABLE environment parameter
+};
+
+class corbaPoll
+{
+  public:
+    corbaPoll();
+    virtual ~corbaPoll();
+
+    /* send ping to the servant, implemented in corbaClient */
+    virtual bool poll();
+    /* callback function called from polling thread, when polling failed, can be owerwritten by interested clients */
+    virtual void pollingFailed();
+
+    /* start polling with default timeout
+      if CORBA_AUTOPOLL_DISABLE is set in the environment nothing is done
+      if CORBA_AUTOPOLL_TIMEOUT is set in the environment the value (in ms) is used for poll timeout (default is 1 minute)
+    */
+    void startAutoPolling(bool local, AutoPolling autopoll);
+    /* start polling explicit */
+    void startPolling(long pollTimeout);
+    /* stop polling */
+    void stopPolling();
+    /* store servant name/ior */
+    void pollingName(const std::string& name);
+
+  private:
+    pImplPtr<class corbaPollImpl> m_pImpl;
+    corbaPoll(const corbaPoll& assign);
+    corbaPoll& operator=(const corbaPoll& assign);
+};
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbapoll_vc6.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbapoll_vc6.h
new file mode 100644
index 00000000..d1b2f133
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbapoll_vc6.h
@@ -0,0 +1,60 @@
+//---------------------------------------------------------------------------
+//
+//  file:       corbapoll.h
+//
+//  purpose:    Header file for CORBA polling class.
+//
+//---------------------------------------------------------------------------
+
+#ifndef CORBAPOLL_H
+#define CORBAPOLL_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "tools/pImplPtr.h"
+#include <string>
+
+enum AutoPolling
+{
+  AUTO_POLL_OFF,              // do not start polling automatically for non-local servants if not enabled by CORBA_AUTOPOLL_ENABLE environment parameter
+                              // do not start polling automatically for local     servants (hostname = "localhost" or "127.0.0.1")
+  AUTO_POLL_NON_LOCAL,        // do not start polling automatically for local     servants (hostname = "localhost" or "127.0.0.1")
+                              // do     start polling automatically for non-local servants if not disabled by CORBA_AUTOPOLL_DISABLE environment parameter
+  AUTO_POLL_ON,               // do     start polling automatically for all       servants if not disabled by CORBA_AUTOPOLL_DISABLE environment parameter
+  AUTO_POLL_NON_LOCAL_FORCE,  // do not start polling automatically for local     servants (hostname = "localhost" or "127.0.0.1")
+                              // do     start polling automatically for non-local servants ignore CORBA_AUTOPOLL_DISABLE environment parameter
+  AUTO_POLL_ON_FORCE,         // do     start polling automatically for all       servants ignore CORBA_AUTOPOLL_DISABLE environment parameter
+};
+
+class corbaPoll
+{
+  public:
+    corbaPoll();
+    virtual ~corbaPoll();
+
+    /* send ping to the servant, implemented in corbaClient */
+    virtual bool poll();
+    /* callback function called from polling thread, when polling failed, can be owerwritten by interested clients */
+    virtual void pollingFailed();
+
+    /* start polling with default timeout
+      if CORBA_AUTOPOLL_DISABLE is set in the environment nothing is done
+      if CORBA_AUTOPOLL_TIMEOUT is set in the environment the value (in ms) is used for poll timeout (default is 1 minute)
+    */
+    void startAutoPolling(bool local, AutoPolling autopoll);
+    /* start polling explicit */
+    void startPolling(long pollTimeout);
+    /* stop polling */
+    void stopPolling();
+    /* store servant name/ior */
+    void pollingName(const std::string& name);
+
+  private:
+    pImplPtr<class corbaPollImpl> m_pImpl;
+    corbaPoll(const corbaPoll& assign);
+    corbaPoll& operator=(const corbaPoll& assign);
+};
+
+#endif // CORBAPOLL_H
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbasrvrbase.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbasrvrbase.h
index bb523cfe..a1f97bbf 100644
--- a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbasrvrbase.h
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbasrvrbase.h
@@ -1,97 +1,3 @@
-// base classes for CORBA servant template class
-
-#ifndef CORBASRVRBASE_H
-#define CORBASRVRBASE_H
-
-#ifdef  SHOW_INCLUDE_FILES
-#pragma message("including: " __FILE__)
+#if !defined(_COMPILER_VERSION_VC6)
+#include "massaiCorba/corbasrvrbase_vc10.h"
 #endif
-
-#include "massaiCorba/corbaorb.h"
-#include <string>
-
-namespace massaiCorba
-{
-  class corbaServantBase
-  {
-    public:
-      corbaServantBase();
-      ~corbaServantBase();
-
-      /** Returns the IOR of this object */
-      const char* ior();
-
-    protected:
-      virtual PortableServer::Servant getServant() = 0;
-      virtual PortableServer::POA_ptr getPOA() = 0;
-      virtual std::string getIOR(CORBA::ORB_ptr orb) = 0;
-
-      bool hasServant();
-      void activate(const std::string& pszServantName, CORBA::ORB_ptr orb, PortableServer::POA_ptr poa);
-      void deactivate();
-
-    private:
-      CORBA::Object_var            obj;
-      PortableServer::ObjectId_var objID;
-      std::string m_ior;
-  };
-
-  class corbaChildServantBase: public corbaServantBase
-  {
-    public:
-      corbaChildServantBase(const char* pszServantName);
-      virtual ~corbaChildServantBase();
-      bool activate(CORBA::ORB_ptr orb, PortableServer::POA_ptr poa);
-      bool remove(CORBA::ORB_ptr orb);
-
-    private:
-      std::string m_servantName;
-
-  };
-
-  class corbaServantExBase: public corbaServantBase, public corbaOrb
-  {
-    public:
-      /** Class constructor for CORBA server applications
-       */
-      corbaServantExBase();
-
-      ~corbaServantExBase();
-
-      /** Class constructor for CORBA server applications
-       *  @param port - Specifies a fixed port for the ORB to listen to
-          @param lThreads - The number of threads for this servant
-       */
-      corbaServantExBase(long port, long lThreads);
-
-      /** Class constructor for CORBA server applications
-       *  @param port - Specifies a fixed port for the ORB to listen to
-          @param lThreads - The number of threads for this servant
-          @param pszHostname_in_ior - hostname to use in ior
-       */
-      corbaServantExBase(long port, long lThreads, const char* pszHostname_in_ior);
-
-      /** Class constructor for CORBA server applications
-       *  @param pszHostName  - Specifies a host address for the ORB to listen on, this
-       *                        may be necessary if the host machine has multiple IP-adresses
-       *  @param port         - Specifies a fixed port for the ORB to listen to
-          @param lThreads - The number of threads for this servant
-       */
-      corbaServantExBase(const char* pszHostName, long port, long lThreads);
-
-      // adds a new child servant to the POA structure
-      bool addServant(corbaChildServantBase* childServant);
-      // removes a child servant out of the POA structure
-      bool removeServant(corbaChildServantBase* childServant);
-
-    protected:
-      PortableServer::POA_var poa;
-
-      bool createServant(const char *pszServantName);
-      void cleanup();
-
-  };
-}
-
-#endif
-
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/corbasrvrbase_vc10.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbasrvrbase_vc10.h
new file mode 100644
index 00000000..bb523cfe
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/corbasrvrbase_vc10.h
@@ -0,0 +1,97 @@
+// base classes for CORBA servant template class
+
+#ifndef CORBASRVRBASE_H
+#define CORBASRVRBASE_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "massaiCorba/corbaorb.h"
+#include <string>
+
+namespace massaiCorba
+{
+  class corbaServantBase
+  {
+    public:
+      corbaServantBase();
+      ~corbaServantBase();
+
+      /** Returns the IOR of this object */
+      const char* ior();
+
+    protected:
+      virtual PortableServer::Servant getServant() = 0;
+      virtual PortableServer::POA_ptr getPOA() = 0;
+      virtual std::string getIOR(CORBA::ORB_ptr orb) = 0;
+
+      bool hasServant();
+      void activate(const std::string& pszServantName, CORBA::ORB_ptr orb, PortableServer::POA_ptr poa);
+      void deactivate();
+
+    private:
+      CORBA::Object_var            obj;
+      PortableServer::ObjectId_var objID;
+      std::string m_ior;
+  };
+
+  class corbaChildServantBase: public corbaServantBase
+  {
+    public:
+      corbaChildServantBase(const char* pszServantName);
+      virtual ~corbaChildServantBase();
+      bool activate(CORBA::ORB_ptr orb, PortableServer::POA_ptr poa);
+      bool remove(CORBA::ORB_ptr orb);
+
+    private:
+      std::string m_servantName;
+
+  };
+
+  class corbaServantExBase: public corbaServantBase, public corbaOrb
+  {
+    public:
+      /** Class constructor for CORBA server applications
+       */
+      corbaServantExBase();
+
+      ~corbaServantExBase();
+
+      /** Class constructor for CORBA server applications
+       *  @param port - Specifies a fixed port for the ORB to listen to
+          @param lThreads - The number of threads for this servant
+       */
+      corbaServantExBase(long port, long lThreads);
+
+      /** Class constructor for CORBA server applications
+       *  @param port - Specifies a fixed port for the ORB to listen to
+          @param lThreads - The number of threads for this servant
+          @param pszHostname_in_ior - hostname to use in ior
+       */
+      corbaServantExBase(long port, long lThreads, const char* pszHostname_in_ior);
+
+      /** Class constructor for CORBA server applications
+       *  @param pszHostName  - Specifies a host address for the ORB to listen on, this
+       *                        may be necessary if the host machine has multiple IP-adresses
+       *  @param port         - Specifies a fixed port for the ORB to listen to
+          @param lThreads - The number of threads for this servant
+       */
+      corbaServantExBase(const char* pszHostName, long port, long lThreads);
+
+      // adds a new child servant to the POA structure
+      bool addServant(corbaChildServantBase* childServant);
+      // removes a child servant out of the POA structure
+      bool removeServant(corbaChildServantBase* childServant);
+
+    protected:
+      PortableServer::POA_var poa;
+
+      bool createServant(const char *pszServantName);
+      void cleanup();
+
+  };
+}
+
+#endif
+
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/iorparser.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/iorparser.h
index a783aae4..ebf90d48 100644
--- a/SelfServiceCommon/Interfaces/inc/massaiCorba/iorparser.h
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/iorparser.h
@@ -1,159 +1,5 @@
-/**
- *  @file      iorparser.h
- *
- *  @brief     IOR parser definition
- *
- *  @date      21.10.2005
- *
- *  @author    Materna Information & Communications (AGe)
- *
- ************************************************************************/
-
-// ior-handler.h,v 1.4 1999/12/14 15:44:50 schmidt Exp
-
-// ============================================================================
-//
-// = LIBRARY
-//    TAO/utils/IOR-parser
-//
-// = FILENAME
-//    ior-handler.h
-//
-// = DESCRIPTION
-//    Provides the definition of a class that parses real (valid) IORs.
-//
-// = AUTHORS
-//    Priya Narasimhan <priya@lambda.ece.ucsb.edu>
-//
-// ============================================================================
-
-#ifndef __IORPARSER_H__
-#define __IORPARSER_H__
-#ifdef SHOW_INCLUDE_FILES
-#pragma message("including: " __FILE__)
+#if defined(_COMPILER_VERSION_VC6)
+#include "massaiCorba/iorparser_vc6.h"
+#else
+#include "massaiCorba/iorparser_vc10.h"
 #endif
-
-// Maximum length of the stringified IOR, the type_id, and the
-// object_key and hostname fields. Tentatively assigned.
-
-#define MAX_IOR_LEN         600
-#define MAX_IOR_FIELD_LEN   200
-#define MAX_TYPE_ID_LEN     100
-#define MAX_OBJ_KEY_LEN     100
-#define MAX_HOSTNAME_LEN     64
-
-struct IOR
-{
-    // = TITLE
-    //     This is the useful information obtained from parsing an IOR.
-    //
-    // = DESCRIPTION
-    //     This structure assumes that the profile_id is
-    //     TAG_INTERNET_IOP and that there is only one TaggedProfile in
-    //     the IOR.
-
-    unsigned long typeIdLen;
-    // The length of the type_id field of the IOR
-
-    char typeId[MAX_TYPE_ID_LEN];
-    // The string in the type_id field of the IOR
-
-    char idlInterface[MAX_TYPE_ID_LEN];
-    // The IDL interface of the server that published the IOR (can be extracted
-    // from the type_id field)
-
-    unsigned long profileBodyLen;
-    // The length of the body of the profile field of the IOR
-
-    unsigned long hostLen;
-    // The length of the hostname embedded in the IOR
-
-    char HostName[MAX_HOSTNAME_LEN];
-    // The server's hostname embedded in the IOR
-
-    unsigned long portNum;
-    // The server's port number embedded in the IOR
-
-    unsigned long objectKeyLen;
-    // The length of the object_key field of the IOR
-
-    char objectKey[MAX_OBJ_KEY_LEN];
-    // The object_key field of the IOR
-};
-
-class iorParser
-{
-    // = TITLE
-    //     This is the class that takes in a real (valid) IOR and
-    //     parses it.
-    //
-    // = DESCRIPTION
-    //     This class prints out the useful information in the
-    //     IORs generated by VisiBroker, Orbix and TAO
-
-private:
-
-    long  err;
-    char  szErr[512];
-    char  szInf[1024];
-
-    char stringIOR[MAX_IOR_LEN];
-    // Holds the stringified IOR during parsing
-
-    struct IOR parsedIOR;
-    // Holds the parsed IOR
-
-    char *getIdlInterface (char *typeId, int *validTypeId);
-    // Extracts the IDL interface from the type_id field in the IOR
-
-    void interpretIor (char *thisIor, struct IOR *thisIorInfo);
-    // The main IOR parsing routine
-
-    int hexChar2int (char thisChar);
-    // Converts a pair of hexadecimal-encoded characters in the stringified
-    // IOR into their integer value
-
-    unsigned long getOctet8Field (char *readPtr, int *hexCharsRead);
-    // Interpret the next 8 octets into an unsigned long
-
-    unsigned long getOctet4Field (char *readPtr, int *hexCharsRead);
-    // Interpret the next 4 octets into an unsigned long
-
-    unsigned long getOctet2Field (char *readPtr, int *hexCharsRead);
-    // Interpret the next 2 octets into an unsigned long
-
-    void skipSpaceIfAny (char *readPtr, int *hexCharsRead);
-    // Skip the space character encountered while parsing the IOR
-
-    void skipNullOctets (char *readPtr, int *hexCharsRead, int expectingStr);
-    // Skip the null octets encountered while parsing the IOR
-
-    int findIfVisiIor (char *readPtr, int *hexCharsRead);
-    // Finds out if VisiBroker generated this IOR
-
-    char getCharacter (char *readPtr, int *offset);
-    // Extracts a single character from the IOR
-
-    char *getString (char *readPtr, int givenLen);
-    // Extracts a character string of a given length from the IOR
-
-public:
-
-    void readIorFromFile (char *filename);
-
-    char *typeId()    { return(parsedIOR.typeId); }
-    char *hostName()  { return(parsedIOR.HostName); }
-    long  hostPort()  { return(parsedIOR.portNum); }
-
-    long  error()     { return(err); }
-    char *errorText() { return(szErr); }
-    char *infoText()  { return(szInf); }
-
-    long parse (char *pszIOR = "");
-
-    iorParser (char *pszIOR);
-
-    iorParser ();
-};
-
-#endif /* __IORPARSER_H__ */
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/iorparser_vc10.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/iorparser_vc10.h
new file mode 100644
index 00000000..a783aae4
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/iorparser_vc10.h
@@ -0,0 +1,159 @@
+/**
+ *  @file      iorparser.h
+ *
+ *  @brief     IOR parser definition
+ *
+ *  @date      21.10.2005
+ *
+ *  @author    Materna Information & Communications (AGe)
+ *
+ ************************************************************************/
+
+// ior-handler.h,v 1.4 1999/12/14 15:44:50 schmidt Exp
+
+// ============================================================================
+//
+// = LIBRARY
+//    TAO/utils/IOR-parser
+//
+// = FILENAME
+//    ior-handler.h
+//
+// = DESCRIPTION
+//    Provides the definition of a class that parses real (valid) IORs.
+//
+// = AUTHORS
+//    Priya Narasimhan <priya@lambda.ece.ucsb.edu>
+//
+// ============================================================================
+
+#ifndef __IORPARSER_H__
+#define __IORPARSER_H__
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+// Maximum length of the stringified IOR, the type_id, and the
+// object_key and hostname fields. Tentatively assigned.
+
+#define MAX_IOR_LEN         600
+#define MAX_IOR_FIELD_LEN   200
+#define MAX_TYPE_ID_LEN     100
+#define MAX_OBJ_KEY_LEN     100
+#define MAX_HOSTNAME_LEN     64
+
+struct IOR
+{
+    // = TITLE
+    //     This is the useful information obtained from parsing an IOR.
+    //
+    // = DESCRIPTION
+    //     This structure assumes that the profile_id is
+    //     TAG_INTERNET_IOP and that there is only one TaggedProfile in
+    //     the IOR.
+
+    unsigned long typeIdLen;
+    // The length of the type_id field of the IOR
+
+    char typeId[MAX_TYPE_ID_LEN];
+    // The string in the type_id field of the IOR
+
+    char idlInterface[MAX_TYPE_ID_LEN];
+    // The IDL interface of the server that published the IOR (can be extracted
+    // from the type_id field)
+
+    unsigned long profileBodyLen;
+    // The length of the body of the profile field of the IOR
+
+    unsigned long hostLen;
+    // The length of the hostname embedded in the IOR
+
+    char HostName[MAX_HOSTNAME_LEN];
+    // The server's hostname embedded in the IOR
+
+    unsigned long portNum;
+    // The server's port number embedded in the IOR
+
+    unsigned long objectKeyLen;
+    // The length of the object_key field of the IOR
+
+    char objectKey[MAX_OBJ_KEY_LEN];
+    // The object_key field of the IOR
+};
+
+class iorParser
+{
+    // = TITLE
+    //     This is the class that takes in a real (valid) IOR and
+    //     parses it.
+    //
+    // = DESCRIPTION
+    //     This class prints out the useful information in the
+    //     IORs generated by VisiBroker, Orbix and TAO
+
+private:
+
+    long  err;
+    char  szErr[512];
+    char  szInf[1024];
+
+    char stringIOR[MAX_IOR_LEN];
+    // Holds the stringified IOR during parsing
+
+    struct IOR parsedIOR;
+    // Holds the parsed IOR
+
+    char *getIdlInterface (char *typeId, int *validTypeId);
+    // Extracts the IDL interface from the type_id field in the IOR
+
+    void interpretIor (char *thisIor, struct IOR *thisIorInfo);
+    // The main IOR parsing routine
+
+    int hexChar2int (char thisChar);
+    // Converts a pair of hexadecimal-encoded characters in the stringified
+    // IOR into their integer value
+
+    unsigned long getOctet8Field (char *readPtr, int *hexCharsRead);
+    // Interpret the next 8 octets into an unsigned long
+
+    unsigned long getOctet4Field (char *readPtr, int *hexCharsRead);
+    // Interpret the next 4 octets into an unsigned long
+
+    unsigned long getOctet2Field (char *readPtr, int *hexCharsRead);
+    // Interpret the next 2 octets into an unsigned long
+
+    void skipSpaceIfAny (char *readPtr, int *hexCharsRead);
+    // Skip the space character encountered while parsing the IOR
+
+    void skipNullOctets (char *readPtr, int *hexCharsRead, int expectingStr);
+    // Skip the null octets encountered while parsing the IOR
+
+    int findIfVisiIor (char *readPtr, int *hexCharsRead);
+    // Finds out if VisiBroker generated this IOR
+
+    char getCharacter (char *readPtr, int *offset);
+    // Extracts a single character from the IOR
+
+    char *getString (char *readPtr, int givenLen);
+    // Extracts a character string of a given length from the IOR
+
+public:
+
+    void readIorFromFile (char *filename);
+
+    char *typeId()    { return(parsedIOR.typeId); }
+    char *hostName()  { return(parsedIOR.HostName); }
+    long  hostPort()  { return(parsedIOR.portNum); }
+
+    long  error()     { return(err); }
+    char *errorText() { return(szErr); }
+    char *infoText()  { return(szInf); }
+
+    long parse (char *pszIOR = "");
+
+    iorParser (char *pszIOR);
+
+    iorParser ();
+};
+
+#endif /* __IORPARSER_H__ */
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/iorparser_vc6.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/iorparser_vc6.h
new file mode 100644
index 00000000..a783aae4
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/iorparser_vc6.h
@@ -0,0 +1,159 @@
+/**
+ *  @file      iorparser.h
+ *
+ *  @brief     IOR parser definition
+ *
+ *  @date      21.10.2005
+ *
+ *  @author    Materna Information & Communications (AGe)
+ *
+ ************************************************************************/
+
+// ior-handler.h,v 1.4 1999/12/14 15:44:50 schmidt Exp
+
+// ============================================================================
+//
+// = LIBRARY
+//    TAO/utils/IOR-parser
+//
+// = FILENAME
+//    ior-handler.h
+//
+// = DESCRIPTION
+//    Provides the definition of a class that parses real (valid) IORs.
+//
+// = AUTHORS
+//    Priya Narasimhan <priya@lambda.ece.ucsb.edu>
+//
+// ============================================================================
+
+#ifndef __IORPARSER_H__
+#define __IORPARSER_H__
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+// Maximum length of the stringified IOR, the type_id, and the
+// object_key and hostname fields. Tentatively assigned.
+
+#define MAX_IOR_LEN         600
+#define MAX_IOR_FIELD_LEN   200
+#define MAX_TYPE_ID_LEN     100
+#define MAX_OBJ_KEY_LEN     100
+#define MAX_HOSTNAME_LEN     64
+
+struct IOR
+{
+    // = TITLE
+    //     This is the useful information obtained from parsing an IOR.
+    //
+    // = DESCRIPTION
+    //     This structure assumes that the profile_id is
+    //     TAG_INTERNET_IOP and that there is only one TaggedProfile in
+    //     the IOR.
+
+    unsigned long typeIdLen;
+    // The length of the type_id field of the IOR
+
+    char typeId[MAX_TYPE_ID_LEN];
+    // The string in the type_id field of the IOR
+
+    char idlInterface[MAX_TYPE_ID_LEN];
+    // The IDL interface of the server that published the IOR (can be extracted
+    // from the type_id field)
+
+    unsigned long profileBodyLen;
+    // The length of the body of the profile field of the IOR
+
+    unsigned long hostLen;
+    // The length of the hostname embedded in the IOR
+
+    char HostName[MAX_HOSTNAME_LEN];
+    // The server's hostname embedded in the IOR
+
+    unsigned long portNum;
+    // The server's port number embedded in the IOR
+
+    unsigned long objectKeyLen;
+    // The length of the object_key field of the IOR
+
+    char objectKey[MAX_OBJ_KEY_LEN];
+    // The object_key field of the IOR
+};
+
+class iorParser
+{
+    // = TITLE
+    //     This is the class that takes in a real (valid) IOR and
+    //     parses it.
+    //
+    // = DESCRIPTION
+    //     This class prints out the useful information in the
+    //     IORs generated by VisiBroker, Orbix and TAO
+
+private:
+
+    long  err;
+    char  szErr[512];
+    char  szInf[1024];
+
+    char stringIOR[MAX_IOR_LEN];
+    // Holds the stringified IOR during parsing
+
+    struct IOR parsedIOR;
+    // Holds the parsed IOR
+
+    char *getIdlInterface (char *typeId, int *validTypeId);
+    // Extracts the IDL interface from the type_id field in the IOR
+
+    void interpretIor (char *thisIor, struct IOR *thisIorInfo);
+    // The main IOR parsing routine
+
+    int hexChar2int (char thisChar);
+    // Converts a pair of hexadecimal-encoded characters in the stringified
+    // IOR into their integer value
+
+    unsigned long getOctet8Field (char *readPtr, int *hexCharsRead);
+    // Interpret the next 8 octets into an unsigned long
+
+    unsigned long getOctet4Field (char *readPtr, int *hexCharsRead);
+    // Interpret the next 4 octets into an unsigned long
+
+    unsigned long getOctet2Field (char *readPtr, int *hexCharsRead);
+    // Interpret the next 2 octets into an unsigned long
+
+    void skipSpaceIfAny (char *readPtr, int *hexCharsRead);
+    // Skip the space character encountered while parsing the IOR
+
+    void skipNullOctets (char *readPtr, int *hexCharsRead, int expectingStr);
+    // Skip the null octets encountered while parsing the IOR
+
+    int findIfVisiIor (char *readPtr, int *hexCharsRead);
+    // Finds out if VisiBroker generated this IOR
+
+    char getCharacter (char *readPtr, int *offset);
+    // Extracts a single character from the IOR
+
+    char *getString (char *readPtr, int givenLen);
+    // Extracts a character string of a given length from the IOR
+
+public:
+
+    void readIorFromFile (char *filename);
+
+    char *typeId()    { return(parsedIOR.typeId); }
+    char *hostName()  { return(parsedIOR.HostName); }
+    long  hostPort()  { return(parsedIOR.portNum); }
+
+    long  error()     { return(err); }
+    char *errorText() { return(szErr); }
+    char *infoText()  { return(szInf); }
+
+    long parse (char *pszIOR = "");
+
+    iorParser (char *pszIOR);
+
+    iorParser ();
+};
+
+#endif /* __IORPARSER_H__ */
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/orbIncDefs.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/orbIncDefs.h
index 2a9925c6..a39a7fe4 100644
--- a/SelfServiceCommon/Interfaces/inc/massaiCorba/orbIncDefs.h
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/orbIncDefs.h
@@ -1,66 +1,5 @@
-/**
- *  @file      orbIncDefs.h
- *
- *  @brief     include the appropriate header files for different orbs
- *
- *  @date      16.12.2003
- *
- *  @author    Materna Information & Communications (AGe)
- *
- ************************************************************************/
-
-#ifndef ORBINCDEFS_H
-#define ORBINCDEFS_H
-
-#ifdef  SHOW_INCLUDE_FILES
-#pragma message("including: " __FILE__)
-#endif
-
-// prevent using old winsock.h -> includes winsock2.h instead
-
-#ifdef _COMPILER_VERSION_VC6
-#define _WIN32_WINNT 0x0400
-#endif
-
-#if defined(_TAO_)
-
-#include "tao/corba.h"
-
-#if defined (_TAO_1_2_) || defined (_TAO_1_4_)
-#include "tao/portableserver/poa.h"
-#else
-#include "tao/portableserver/PortableServer.h"
-#include "ace/String_Base.h"
-#endif
-
-#include "tao/IORTable/IORTable.h"
-
-// seems that ORBACUS defines this, but TAO doesn't !!
-
-typedef unsigned char byte;
-
-#define _message() _info().c_str()
-
-using namespace CORBA;
-
+#if defined(_COMPILER_VERSION_VC6)
+#include "massaiCorba/orbIncDefs_vc6.h"
 #else
-
-#error Please specify the -D_TAO_ in your compiler flags
-
+#include "massaiCorba/orbIncDefs_vc10.h"
 #endif
-
-
-/** RoundTrip Timeout initialization for both corbaOrb and corbaOrbEx
-  */
-#define CORBA_TIMEOUT_MAX  0x7FFFFFFF // in ms (24days 20hours 31minutes 23seconds 647milliseconds)
-
-void SetInvocationTimeout
-(
-  ORB_ptr  orb_ptr,            ///< the CORBA ORB
-  long     lTimeoutInMSec,     ///< timeout in milliseconds
-  bool     bForCurrentThread   ///< true: for thread, false: for ORB
-);
-void ClearInvocationTimeout(CORBA::ORB_ptr orb_ptr, bool bForCurrentThread);
-long GetInvocationTimeout(CORBA::ORB_ptr orb_ptr, bool bForCurrentThread);
-
-#endif //ORBINCDEFS_H
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/orbIncDefs_vc10.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/orbIncDefs_vc10.h
new file mode 100644
index 00000000..2a9925c6
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/orbIncDefs_vc10.h
@@ -0,0 +1,66 @@
+/**
+ *  @file      orbIncDefs.h
+ *
+ *  @brief     include the appropriate header files for different orbs
+ *
+ *  @date      16.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ *
+ ************************************************************************/
+
+#ifndef ORBINCDEFS_H
+#define ORBINCDEFS_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+// prevent using old winsock.h -> includes winsock2.h instead
+
+#ifdef _COMPILER_VERSION_VC6
+#define _WIN32_WINNT 0x0400
+#endif
+
+#if defined(_TAO_)
+
+#include "tao/corba.h"
+
+#if defined (_TAO_1_2_) || defined (_TAO_1_4_)
+#include "tao/portableserver/poa.h"
+#else
+#include "tao/portableserver/PortableServer.h"
+#include "ace/String_Base.h"
+#endif
+
+#include "tao/IORTable/IORTable.h"
+
+// seems that ORBACUS defines this, but TAO doesn't !!
+
+typedef unsigned char byte;
+
+#define _message() _info().c_str()
+
+using namespace CORBA;
+
+#else
+
+#error Please specify the -D_TAO_ in your compiler flags
+
+#endif
+
+
+/** RoundTrip Timeout initialization for both corbaOrb and corbaOrbEx
+  */
+#define CORBA_TIMEOUT_MAX  0x7FFFFFFF // in ms (24days 20hours 31minutes 23seconds 647milliseconds)
+
+void SetInvocationTimeout
+(
+  ORB_ptr  orb_ptr,            ///< the CORBA ORB
+  long     lTimeoutInMSec,     ///< timeout in milliseconds
+  bool     bForCurrentThread   ///< true: for thread, false: for ORB
+);
+void ClearInvocationTimeout(CORBA::ORB_ptr orb_ptr, bool bForCurrentThread);
+long GetInvocationTimeout(CORBA::ORB_ptr orb_ptr, bool bForCurrentThread);
+
+#endif //ORBINCDEFS_H
diff --git a/SelfServiceCommon/Interfaces/inc/massaiCorba/orbIncDefs_vc6.h b/SelfServiceCommon/Interfaces/inc/massaiCorba/orbIncDefs_vc6.h
new file mode 100644
index 00000000..184bdfdb
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/massaiCorba/orbIncDefs_vc6.h
@@ -0,0 +1,94 @@
+/**
+ *  @file      orbIncDefs.h
+ *
+ *  @brief     include the appropriate header files for different orbs
+ *
+ *  @date      16.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ *
+ ************************************************************************/
+
+#ifndef ORBINCDEFS_H
+#define ORBINCDEFS_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+// prevent using old winsock.h -> includes winsock2.h instead
+
+#ifdef _COMPILER_VERSION_VC6
+#define _WIN32_WINNT 0x0400
+#endif
+
+#if defined(_TAO_)
+
+
+#if defined (_TAO_1_4_)
+    // nie, nie INLINE wollen, sonst viele unresolved externals
+    // #define ACE_NO_INLINE //doesn't work with Tao 1.2
+#endif
+
+#include "tao/corba.h"
+
+#if defined (_TAO_1_2_) || defined (_TAO_1_4_) 
+#include "tao/portableserver/poa.h"
+#else
+#include "tao/portableserver/PortableServer.h"
+#include "ace/String_Base.h"
+#endif
+
+
+#include "tao/IORTable/IORTable.h"
+
+// seems that ORBACUS defines this, but TAO doesn't !!
+
+typedef unsigned char byte;
+
+#define _message() _info().c_str()
+
+using namespace CORBA;
+
+#if defined(_TAO_1_4_) || defined(_TAO_1_5_) || defined (_TAO_2_0_)
+/** RoundTrip Timeout initialization for both corbaOrb and corbaOrbEx
+  */
+#define CORBA_TIMEOUT_MAX  0x7FFFFFFF // in ms (24days 20hours 31minutes 23seconds 647milliseconds)
+
+void SetInvocationTimeout(  ORB_ptr  orb_ptr,            ///< the CORBA ORB
+                            long     lTimeoutInMSec,     ///< timeout in milliseconds
+                            bool     bForCurrentThread   ///< true: for thread, false: for ORB
+                         );
+void ClearInvocationTimeout( CORBA::ORB_ptr  orb_ptr, bool bForCurrentThread);
+long GetInvocationTimeout( CORBA::ORB_ptr  orb_ptr, bool bForCurrentThread);
+
+#endif // _TAO_1_4_
+
+#elif defined(_ORBACUS_)
+
+#include "OB/CORBA.h"
+#include "OB/Properties.h"
+#include "OB\CORBAClient.h"
+#include "OB\POAInterface.h"
+#include "OB\BootManager.h"
+#include "OB\ORB_init.h"
+#include "OB\OBORB.h"
+
+#define _message() _to_string()
+
+using namespace CORBA;
+
+#elif defined(_MICO_)
+
+#include <windows.h>
+#include "CORBA.h"
+
+#define _message() _repoid ()
+
+#else
+
+#error Please specify the -D_TAO_ or -D_ORBACUS_ or -D_MICO_ in your compiler flags
+
+#endif
+
+#endif //ORBINCDEFS_H
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/inc/localclnt_def.h b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/inc/localclnt_def.h
new file mode 100644
index 00000000..aace85f6
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/inc/localclnt_def.h
@@ -0,0 +1,9 @@
+#define FILE_VER_BIN     1,0,0,0
+#define FILE_VER_STR     "FileVersion", "1.0.0.0\0"
+
+#define FILEDESCRIPTION  "FileDescription"  ,"Corba Testclient\0"
+#define INTERNALNAME     "InternalName"     ,"Testclient\0"
+#define LEGALTRADEMARKS  "LegalTrademarks"  ,"\0"
+#define ORIGINALFILENAME "OriginalFilename" ,"testclnt.exe\0"
+
+
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/inc/localsrv_def.h b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/inc/localsrv_def.h
new file mode 100644
index 00000000..8b75f4c0
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/inc/localsrv_def.h
@@ -0,0 +1,9 @@
+#define FILE_VER_BIN     1,0,0,0
+#define FILE_VER_STR     "FileVersion", "1.0.0.0\0"
+
+#define FILEDESCRIPTION  "FileDescription"  ,"Corba Test Servant\0"
+#define INTERNALNAME     "InternalName"     ,"Testservant\0"
+#define LEGALTRADEMARKS  "LegalTrademarks"  ,"\0"
+#define ORIGINALFILENAME "OriginalFilename" ,"testsrvr.exe\0"
+
+
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/inc/massaiCORBA_def.h b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/inc/massaiCORBA_def.h
new file mode 100644
index 00000000..d233c538
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/inc/massaiCORBA_def.h
@@ -0,0 +1,108 @@
+/**
+ *  @file      massaiCORBA_def.h
+ *
+ *  @brief     Version file
+ *
+ *  @date      09.05.2006
+ *
+ *  @author    Materna Information & Communications (MaM)
+ *
+ ************************************************************************/
+
+/*! \page massaicorbalib Massai CORBA library - Release Notes
+ *
+ *  @version 1.0.6.17
+ *
+ *  \section change1 Change history
+ *
+ *  \date 09.06.2011 \li V1.0.6.17
+ *                   \li GiT, rollback of previous change
+ *
+ *  \date 09.06.2011 \li V1.0.6.16
+ *                   \li GiT, modification: changed orb connection handler behaviour to RW
+ *                            TAO description : RW selects a strategy that simply blocks in recv() when waiting for a response from the server
+ *                                              instead of waiting in the Reactor using the Leader/Followers pattern.
+ *                            This change should prevent nested upcalls.
+ *                       To change the behaviour back to the old strategy set the environment variable
+ *                       STANDARD_ORB_WAIT_STRATEGY
+ *                   \li QA-Tests: All platform modules including the connection to applications are affected, a thorough integration test is needed
+ *
+ *  \date 21.04.2011 \li V1.0.6.15
+ *                   \li SteT, enhancement, added trace to corbaorb
+ *
+ *  \date 28.10.2009 \li V1.0.6.14
+ *                   \li SteT Mantis 11665: deactivate CorbaPoll (per default)
+ *
+ *     per default the corbaClient is created with the parameter AUTO_POLL_OFF
+ *     this behaviour can be changed with environment setting:
+ *        use CORBA_AUTOPOLL_ENABLE to enabling the polling for non local connections
+ *
+ *  \date 28.04.2009 \li V1.0.6.13
+ *                   \li SteT bugfix: use killClientOrb when starting new Servant to avoid LOCATION_FORWARD from servant port to client port
+ *
+ *  \date 04.12.2008 \li V1.0.6.12
+ *                   \li SteT Mantis 6871: correct CorbaPoll Tracelevel
+ *
+ *  \date 04.09.2008 \li V1.0.6.11
+ *                   \li SteT EDB 28111: Invalid Pointer Read / Free Memory Read in CorbaPoll
+ *
+ *
+ *  \date 17.07.2008 \li V1.0.6.10
+ *                   \li SteT Change: corbaClient sends KeepAlive requests
+ *
+ *   corbaClient is derived from corbaPoll and the default behaviour of corbaClient ist changed:
+ *
+ *     per default the corbaClient is created with the parameter AUTO_POLL_NON_LOCAL
+ *     if the servant is not obvious on the same machine, the client send every minute a LocateRequest message to the servant
+ *
+ *     the behaviour can be changed with the autopoll parameter in the constructor
+ *     and with environment setting:
+ *        use CORBA_AUTOPOLL_DISABLE to disable the polling
+ *        use CORBA_AUTOPOLL_TIMEOUT to set the polling timeout (in ms)
+ *
+ *   a new corbaClient constructor is added for callback-listener set by remote (the KeepAlive mechanism is not used if the listener is used without the corbaClient)
+ *
+ *
+ *  \date 12.11.2007 \li V1.0.6.9
+ *                   \li SteT Bugfix unresolved external of CfgXMgrB (ACE_NO_INLINE removed)
+ *
+ *  \date 25.07.2007 \li V1.0.6.8
+ *                   \li SteT EDB 26866: the classes corbaClient, corbaServantEx stores the ior and releases the memory used
+ *                   \li     the method ior() returns const char* (was char*)
+ *                   \li     the caller is not responsible for releasing the returned buffer any more
+ *
+ *  \date 20.06.2007 \li V1.0.6.7
+ *                   \li SteT EDB 27607: wrong constructor results in access violation
+ *
+ *  \date 20.06.2007 \li V1.0.6.6
+ *                   \li SteT EDB 27562: Pure virtual function call, after removeServant
+ *
+ *  \date 30.05.2007 \li V1.0.6.5
+ *                   \li feature - hostname_in_ior can be set from external. PtM
+ *
+ *  \date 17.01.2007 \li V1.0.6.4 MaM
+ *                   \li MaM EDB 27073: mCorba / mDisplay: kein CORBA Roundtrip TO bei Fremdplattform
+ *
+ *  \date 09.08.2006 \li V1.0.6.3 SteT
+ *                   \li SteT EDB 26406: Erweiterung der massaiCORBA Funktionalitt um ClearRTTimeout
+ *
+ *
+ *  \date 09.08.2006 \li V1.0.6.2 SteT
+ *                   \li RoundTrip Timeout wird jetzt initial ORB weit gesetzt
+ *
+ *  \date 04.07.2006 \li V1.0.6.1 BrN
+ *                   \li TAO 1.4 mit Connection Timeout
+ *
+ *  \date 08.05.2006 \li V1.0.6.0 MaM
+ *                   \li TAO 1.4 mit RoundTrip Timeout
+ *
+ */
+
+// #define FILE_VER_BIN     1,0,6,17
+// #define FILE_VER_STR     "FileVersion", "1.0.6.17\0"
+
+// #define FILEDESCRIPTION  "FileDescription"  ,"Massai CORBA library\0"
+// #define INTERNALNAME     "InternalName"     ,MassaiCORBA"\0"
+// #define LEGALTRADEMARKS  "LegalTrademarks"  ,"\0"
+// #define ORIGINALFILENAME "OriginalFilename" ,"mCorba.lib\0"
+
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/inc/tracedef.h b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/inc/tracedef.h
new file mode 100644
index 00000000..8131e309
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/inc/tracedef.h
@@ -0,0 +1,31 @@
+//---------------------------------------------------------------------------
+//
+//  file:       tracedef.h
+//
+//  purpose:    trace makro definitions
+//
+//  date:       15.09.00, 12:11
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+#define COMPLETE message("to be completed: "  __FILE__)
+
+// for easier traces --------------------------------------------------------
+
+#define _HERE  255,__FILE__,__LINE__     // unconditional trace
+
+#define _HERE_1  1,__FILE__,__LINE__     // level 1 trace (high)
+#define _HERE_2  2,__FILE__,__LINE__
+#define _HERE_3  3,__FILE__,__LINE__
+#define _HERE_4  4,__FILE__,__LINE__
+#define _HERE_5  5,__FILE__,__LINE__
+#define _HERE_6  6,__FILE__,__LINE__
+#define _HERE_7  7,__FILE__,__LINE__
+#define _HERE_8  8,__FILE__,__LINE__
+#define _HERE_9  9,__FILE__,__LINE__     // level 9 trace (low)
+
+void trace   (long lLevel,char *pszFile,long lLine,char *pszFormat, ...);
+void dump    (long lLevel,char *pszFile,long lLine,char *pData,long lLen);
+long setLevel(long level);
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/res/FileVersionClnt.rc b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/res/FileVersionClnt.rc
new file mode 100644
index 00000000..045e8350
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/res/FileVersionClnt.rc
@@ -0,0 +1,108 @@
+//Microsoft Developer Studio generated resource script.
+//
+// #include "resource.h"
+#include "Global_def.h"
+#include "localclnt_def.h"
+
+#define APSTUDIO_READONLY_SYMBOLS
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 2 resource.
+//
+#include "afxres.h"
+
+/////////////////////////////////////////////////////////////////////////////
+#undef APSTUDIO_READONLY_SYMBOLS
+
+/////////////////////////////////////////////////////////////////////////////
+// German (Germany) resources
+
+#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_DEU)
+#ifdef _WIN32
+LANGUAGE LANG_GERMAN, SUBLANG_GERMAN
+#pragma code_page(1252)
+#endif //_WIN32
+
+#ifndef _MAC
+/////////////////////////////////////////////////////////////////////////////
+//
+// Version
+//
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION FILE_VER_BIN
+ PRODUCTVERSION PRODUCT_VER_BIN
+ FILEFLAGSMASK 0x3fL
+#ifdef _DEBUG
+ FILEFLAGS 0x1L
+#else
+ FILEFLAGS 0x0L
+#endif
+ FILEOS 0x40004L
+ FILETYPE 0x2L
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040704b0"
+        BEGIN
+            VALUE COMPANY
+			VALUE FILEDESCRIPTION
+			VALUE FILE_VER_STR
+			VALUE INTERNALNAME
+			VALUE COPYRIGHT
+			VALUE LEGALTRADEMARKS
+			VALUE ORIGINALFILENAME
+			VALUE PRODUCT
+            VALUE PRODUCT_VER_STR 
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x407, 1200
+    END
+END
+
+#endif    // !_MAC
+
+
+#ifdef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// TEXTINCLUDE
+//
+
+1 TEXTINCLUDE DISCARDABLE
+BEGIN
+    "resource.h\0"
+END
+
+2 TEXTINCLUDE DISCARDABLE
+BEGIN
+    "#include ""afxres.h""\r\n"
+    "\0"
+END
+
+3 TEXTINCLUDE DISCARDABLE
+BEGIN
+    "\r\n"
+    "\0"
+END
+
+#endif    // APSTUDIO_INVOKED
+
+#endif    // German (Germany) resources
+/////////////////////////////////////////////////////////////////////////////
+
+
+
+#ifndef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 3 resource.
+//
+
+
+/////////////////////////////////////////////////////////////////////////////
+#endif    // not APSTUDIO_INVOKED
+
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/res/FileVersionSrv.rc b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/res/FileVersionSrv.rc
new file mode 100644
index 00000000..6ac3853c
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/res/FileVersionSrv.rc
@@ -0,0 +1,108 @@
+//Microsoft Developer Studio generated resource script.
+//
+// #include "resource.h"
+#include "Global_def.h"
+#include "localsrv_def.h"
+
+#define APSTUDIO_READONLY_SYMBOLS
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 2 resource.
+//
+#include "afxres.h"
+
+/////////////////////////////////////////////////////////////////////////////
+#undef APSTUDIO_READONLY_SYMBOLS
+
+/////////////////////////////////////////////////////////////////////////////
+// German (Germany) resources
+
+#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_DEU)
+#ifdef _WIN32
+LANGUAGE LANG_GERMAN, SUBLANG_GERMAN
+#pragma code_page(1252)
+#endif //_WIN32
+
+#ifndef _MAC
+/////////////////////////////////////////////////////////////////////////////
+//
+// Version
+//
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION FILE_VER_BIN
+ PRODUCTVERSION PRODUCT_VER_BIN
+ FILEFLAGSMASK 0x3fL
+#ifdef _DEBUG
+ FILEFLAGS 0x1L
+#else
+ FILEFLAGS 0x0L
+#endif
+ FILEOS 0x40004L
+ FILETYPE 0x2L
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040704b0"
+        BEGIN
+            VALUE COMPANY
+			VALUE FILEDESCRIPTION
+			VALUE FILE_VER_STR
+			VALUE INTERNALNAME
+			VALUE COPYRIGHT
+			VALUE LEGALTRADEMARKS
+			VALUE ORIGINALFILENAME
+			VALUE PRODUCT
+            VALUE PRODUCT_VER_STR 
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x407, 1200
+    END
+END
+
+#endif    // !_MAC
+
+
+#ifdef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// TEXTINCLUDE
+//
+
+1 TEXTINCLUDE DISCARDABLE
+BEGIN
+    "resource.h\0"
+END
+
+2 TEXTINCLUDE DISCARDABLE
+BEGIN
+    "#include ""afxres.h""\r\n"
+    "\0"
+END
+
+3 TEXTINCLUDE DISCARDABLE
+BEGIN
+    "\r\n"
+    "\0"
+END
+
+#endif    // APSTUDIO_INVOKED
+
+#endif    // German (Germany) resources
+/////////////////////////////////////////////////////////////////////////////
+
+
+
+#ifndef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 3 resource.
+//
+
+
+/////////////////////////////////////////////////////////////////////////////
+#endif    // not APSTUDIO_INVOKED
+
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/Realtime.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/Realtime.cpp
new file mode 100644
index 00000000..99355490
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/Realtime.cpp
@@ -0,0 +1,209 @@
+/**
+ *
+ * SYSTEM             MASSAI
+ * \n subsystem       massaiCORBA
+ *
+ *
+ * \file    Realtime.cpp
+ * \version 1.0
+ * \date    13.04.2006
+ *
+ * \author  Martin Mazikowski MaM
+ * \n       Materna GmbH Information & Communications
+ * \n       Vosskuhle 37, 44141 Dortmund, Germany
+ *
+ *          Copyright (c) 2006. All rights reserved.
+ *
+ *
+ * \brief   Tools for coping with CORBA Messaging
+ * \n	    This module is based on the CORBA Realtime functions for MMSC.
+ * \n   	TAO 1.4 only!
+ *
+ *
+ * \version  *      1.0 MaM  13.04.2006    initial coding
+ */
+/* ----------------- system includes ----------------- */
+
+#if defined(_TAO_1_4_)  || defined(_TAO_1_5_) || defined (_TAO_2_0_)
+
+/* ----------------- global includes ----------------- */
+#include "tao/Messaging/Messaging.h"
+#include "massaiCorba/corbaorb.h"
+#include "massaiCorba/corbacfg.h"
+
+/* ----------------- local includes  ----------------- */
+#include "tracedef.h"
+
+/* ----------------- defines         ----------------- */
+
+/* ----------------- macros          ----------------- */
+
+/* ----------------- static data     ----------------- */
+static const long TimeoutBase = 10000;//TimeT has 100 nanosecond resolution
+
+/* ----------------- exported data     --------------- */
+
+/* ----------------- external data   ----------------- */
+
+/* ----------------- prototypes       ---------------- */
+
+/* ----------------- static functions  --------------- */
+
+/* ----------------- exported functions  ------------ */
+
+
+
+void SetInvocationTimeout(  CORBA::ORB_ptr  orb_ptr,            ///< the CORBA ORB
+                            long            lTimeoutInMSec,     ///< timeout in milliseconds
+                            bool            bForCurrentThread   ///< true: for thread, false: for ORB
+                         )
+{
+  if(lTimeoutInMSec < 0)
+  {
+    ClearInvocationTimeout(orb_ptr, bForCurrentThread);
+  }
+  else
+  {
+    try
+    {
+        CORBA::PolicyManager_var policy_manager;
+        CORBA::PolicyList     policy_list;
+
+        if(!bForCurrentThread)
+        {
+            // get the ORBPolicyManager object
+            CORBA::Object_var object = orb_ptr->resolve_initial_references( "ORBPolicyManager");
+
+            policy_manager =    CORBA::PolicyManager::_narrow (object.in());
+
+        }
+        else
+        {
+            // get the PolicyCurrent object
+            CORBA::Object_var  object = orb_ptr->resolve_initial_references ( "PolicyCurrent");
+            policy_manager =     CORBA::PolicyCurrent::_narrow (object.in());
+        }
+
+        // disable all default policies
+        policy_list.length (0);
+        policy_manager->set_policy_overrides( policy_list, CORBA::SET_OVERRIDE );
+
+        policy_list.length (2);
+
+        // set the RelativeRoundtripTimeout policy
+        CORBA::Any  object_timeout;
+        TimeBase::TimeT timeout = static_cast<TimeBase::TimeT>(lTimeoutInMSec) * TimeoutBase;
+        object_timeout <<= timeout;
+        policy_list[0] = orb_ptr->create_policy ( Messaging::RELATIVE_RT_TIMEOUT_POLICY_TYPE,
+                                                  object_timeout );
+        // set the ConnectionTimeout policy
+        CORBA::Any conn_timeout;
+		    TimeBase::TimeT c_timeout = CORBA_CONNECTION_TIMEOUT_DEFAULT*TimeoutBase;
+		    conn_timeout <<= c_timeout;
+        policy_list[1] = orb_ptr->create_policy ( TAO::CONNECTION_TIMEOUT_POLICY_TYPE, conn_timeout);
+
+
+        policy_manager->set_policy_overrides ( policy_list, CORBA::SET_OVERRIDE );
+    }
+    catch(const CORBA::Exception& ex)
+    {
+        trace(_HERE,"ORB: SetInvocationTimeout: %s",ex._message());
+    }
+    catch(std::exception& ex)
+    {
+        trace(_HERE,"ORB: SetInvocationTimeout: %s",ex.what());
+    }
+    catch(...)
+    {
+        trace(_HERE,"ORB: SetInvocationTimeout failed: other error");
+    }
+  }
+}
+
+void ClearInvocationTimeout(CORBA::ORB_ptr  orb_ptr, bool bForCurrentThread)
+{
+    try
+    {
+        CORBA::PolicyManager_var policy_manager;
+        CORBA::PolicyList        policy_list;
+
+        if(!bForCurrentThread)
+        {
+            // get the ORBPolicyManager object
+            CORBA::Object_var object = orb_ptr->resolve_initial_references("ORBPolicyManager");
+            policy_manager = CORBA::PolicyManager::_narrow(object.in());
+        }
+        else
+        {
+            // get the PolicyCurrent object
+            CORBA::Object_var object = orb_ptr->resolve_initial_references("PolicyCurrent");
+            policy_manager = CORBA::PolicyCurrent::_narrow(object.in());
+        }
+
+        policy_list.length(0);
+        policy_manager->set_policy_overrides(policy_list, CORBA::SET_OVERRIDE);
+   }
+   catch(const CORBA::Exception& ex)
+   {
+       trace(_HERE, "ORB: ClearInvocationTimeout: %s", ex._message());
+   }
+   catch(std::exception& ex)
+   {
+       trace(_HERE, "ORB: ClearInvocationTimeout: %s", ex.what());
+   }
+   catch(...)
+   {
+       trace(_HERE, "ORB: ClearInvocationTimeout failed: other error");
+   }
+}
+
+long GetInvocationTimeout(CORBA::ORB_ptr  orb_ptr, bool bForCurrentThread)
+{
+    try
+    {
+        CORBA::PolicyTypeSeq     policy_Type;
+        CORBA::PolicyManager_var policy_manager;
+        CORBA::PolicyList_var    policy_listp;
+
+        if(!bForCurrentThread)
+        {
+            // get the ORBPolicyManager object
+            CORBA::Object_var object = orb_ptr->resolve_initial_references("ORBPolicyManager");
+            policy_manager = CORBA::PolicyManager::_narrow(object.in());
+        }
+        else
+        {
+            // get the PolicyCurrent object
+            CORBA::Object_var object = orb_ptr->resolve_initial_references("PolicyCurrent");
+            policy_manager = CORBA::PolicyCurrent::_narrow(object.in());
+        }
+
+        policy_Type.length(1);
+        policy_Type[0] = Messaging::RELATIVE_RT_TIMEOUT_POLICY_TYPE;
+
+        policy_listp = policy_manager->get_policy_overrides(policy_Type);
+
+        if(policy_listp->length() > 0)
+        {
+            Messaging::RelativeRoundtripTimeoutPolicy_var m;
+            m = Messaging::RelativeRoundtripTimeoutPolicy::_narrow((*policy_listp)[0]);
+
+            TimeBase::TimeT timeout = m->relative_expiry();
+            return static_cast<long>(timeout/10000);
+        }
+   }
+   catch(const CORBA::Exception& ex)
+   {
+       trace(_HERE, "ORB: GetInvocationTimeout: %s", ex._message());
+   }
+   catch(std::exception& ex)
+   {
+       trace(_HERE, "ORB: GetInvocationTimeout: %s", ex.what());
+   }
+   catch(...)
+   {
+       trace(_HERE, "ORB: GetInvocationTimeout failed: other error");
+   }
+   return -1;
+}
+#endif // defined _TAO_1_4_
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbacfg.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbacfg.cpp
new file mode 100644
index 00000000..c2be9cef
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbacfg.cpp
@@ -0,0 +1,259 @@
+//---------------------------------------------------------------------------
+//
+//  file:       corbacfg.cpp
+//
+//  purpose:    config functionality
+//
+//  date:       27.11.2001, 13:09
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include "cfgclnt/nConfigText.hpp"
+#include "cfgclnt/nConfigNumber.hpp"
+#include "massaiCorba/corbacfg.h"
+#include "limits.h"
+#include "tracedef.h"
+
+// base configuration class
+
+class mCorbaCfg : public nConfig::gcText
+{
+
+   /** This method is called, when the configuration subsystem needs to
+    *  create a new confuguration item.
+    */
+
+   void create
+      (
+         char const * & Rights,
+         char const * & Explanation,
+         char const * & Default
+      )
+   {
+      Rights = "rwl";
+      Explanation = "TCP/IP address and/or TCP/IP Port of"
+                    " the CORBA-Servant to connect.\n"
+                    "SYNTAX: [host:]port";
+      Default = "127.0.0.1:00000";
+   }
+
+public:
+
+   /** Constructor */
+   mCorbaCfg
+      (
+         char const * Item,
+         char const * User
+      ) :
+      nConfig::gcText( Item, User )
+   {
+   }
+
+private:
+
+   mCorbaCfg();
+
+};
+
+//---------------------------------------------------------------------------
+//
+//  function:   long getConfigPort(const char *pszServantName)
+//
+//  purpose:    try to get servant's port from configuration
+//
+//  date:       27.11.2001, 13:23
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long getConfigPort(const char *pszServantName)
+{
+char  szTmp [256];
+char *pStr;
+long  lPort;
+
+    if(pszServantName)
+    {
+      sprintf(szTmp,"CORBA.SERVANTS.%s",pszServantName);
+
+      mCorbaCfg port(szTmp,"massaiCorba");
+
+      if(port.get())
+      {
+        strcpy(szTmp,port.get());
+
+        if((pStr = strchr(szTmp,':')) != NULL)
+          lPort = atol(++pStr);
+        else
+          lPort = atol(szTmp);
+
+        if(!lPort)
+        {
+          static char exception_buffer[256];
+          sprintf
+            (
+              exception_buffer,
+              "ERROR: The TCP/IP port for CORBA.SERVANTS.%s is ZERO.",
+              pszServantName
+            );
+          //
+          // JK: Throwing a pointer to C string is not exactly good.
+          // A more sophisticated solution would however affect existing
+          // applications -> we better do not touch the interface.
+          // See also Mantis ticket 0009468.
+          //
+          throw(exception_buffer);
+        }
+
+        trace(_HERE,"port for servant %s = %d",pszServantName,lPort);
+
+        return(lPort);
+      }
+      else
+        return(-1);
+    }
+    else
+      return(-1);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   std::string getConfigHost(const char *pszServantName)
+//
+//  purpose:    try to get servant's host address from config
+//
+//  date:       27.11.2001, 13:23
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+std::string getConfigHost(const char *pszServantName)
+{
+char szTmp [256];
+char   *pStr;
+
+    *szTmp = '\0';
+
+    if(pszServantName)
+    {
+      sprintf(szTmp,"CORBA.SERVANTS.%s",pszServantName);
+
+      mCorbaCfg host(szTmp,"massaiCorba");
+
+      if(host.get())
+      {
+        strcpy(szTmp,host.get());
+
+        if((pStr = strchr(szTmp,':')) != NULL)
+          *pStr = '\0';
+        else
+          strcpy(szTmp,"127.0.0.1");
+      }
+    }
+
+    trace(_HERE,"host address for servant %s = %s",pszServantName,szTmp);
+    std::string r( szTmp, strlen(szTmp) );
+    return r;
+}
+
+
+
+
+#if defined (_TAO_1_4_)  || defined(_TAO_1_5_) || defined(_TAO_2_0_)
+
+// base configuration class for CORBA_InvocationTimeout
+
+class mCorbaCfgTO : public nConfig::gcNumber
+{
+
+   /** This method is called, when the configuration subsystem needs to
+    *  create a new confuguration item.
+    */
+
+   void create( char const * &      Rights,
+                char const * &      Explanation,
+                long &              Default,
+                long &              Min,
+                long &              Max
+              )
+   {
+      Rights = "rwl";
+      Explanation = "CORBA Invocation Timeout for Client/Servant"
+                    " in ms.\n"
+                    "SYNTAX: CORBA_InvocationTimeout";
+      Default = CORBA_INVOCATION_TIMEOUT_DEFAULT;
+      Min     = 0;
+      Max     = LONG_MAX;
+   }
+
+public:
+
+   /** Constructor */
+   mCorbaCfgTO
+      (
+         char const * Item,
+         char const * User
+      ) :
+      nConfig::gcNumber( Item, User )
+   {
+   }
+
+private:
+
+   mCorbaCfgTO();
+
+};
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   long getConfigInvocationTimeout(const char *pszServantName)
+//
+//  purpose:    try to get servant's CORBA Invocation Timout (in ms)
+//              from the configuration.
+//
+//  date:       18.04.2006
+//
+//  author:     Materna Information & Communications (MaM)
+//
+//---------------------------------------------------------------------------
+
+long getConfigInvocationTimeout(const char *pszServantName)
+{
+char  szTmp [256];
+
+    if(pszServantName)
+    {
+      sprintf
+         (
+            szTmp, "%s.%s",
+            CORBA_INVOCATION_TIMEOUT_CFG_LOCATION,
+            pszServantName
+         );
+
+      try
+      {
+
+        mCorbaCfgTO Timeout(szTmp,"massaiCorba");
+        return( Timeout.get());
+      }
+      catch(...)
+      {
+          // MaM 17.01.2007 EDB 27073
+          // in case of error do not return -1!
+          // -1 causes clearing all CORBA Roundtrip TO in
+          // setConfigInvocationTimeout
+          return CORBA_INVOCATION_TIMEOUT_DEFAULT;
+      };
+    }
+    else
+      // MaM see above
+      //
+      return CORBA_INVOCATION_TIMEOUT_DEFAULT;
+}
+
+#endif // _TAO_1_4_
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbaclnt.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbaclnt.cpp
new file mode 100644
index 00000000..eebe3e39
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbaclnt.cpp
@@ -0,0 +1,14 @@
+//---------------------------------------------------------------------------
+//
+//  file:       corbaclnt.cpp
+//
+//  purpose:    CORBA client basics
+//
+//  date:       26.10.99, 11:17
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include "massaiCorba/corbaclnt.h"
+
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbaorb.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbaorb.cpp
new file mode 100644
index 00000000..a11f31df
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbaorb.cpp
@@ -0,0 +1,875 @@
+//---------------------------------------------------------------------------
+//
+//  file:       corbaorb.cpp
+//
+//  purpose:    ORB class and helper functions implementation
+//
+//  date:       20.11.2001, 16:23
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include "tracedef.h"
+#include "massaiCorba/corbaorb.h"
+#include "massaiCorba/corbacfg.h"
+
+
+namespace
+{
+  void enableTAO_Logging(int& argc, char **argv)
+  {
+    argv[argc++] = "-ORBDebug";
+
+    argv[argc++] = "-ORBDebugLevel";
+    argv[argc++] = "10";
+
+    argv[argc++] = "-ORBVerboseLogging";
+    argv[argc++] = "2";
+  }
+}
+
+
+// simple singleton class
+
+static CORBA::ORB_var _orbClnt = NULL;
+static CORBA::ORB_var _orbSrvr = NULL;
+
+class orbClntSingleton : public mThreadEx
+{
+private:
+
+    long function();
+
+public:
+
+     orbClntSingleton() { };
+
+    ~orbClntSingleton();
+};
+
+class orbSrvrSingleton : public mThreadEx
+{
+private:
+
+    long function();
+
+public:
+
+     orbSrvrSingleton() { };
+
+    ~orbSrvrSingleton();
+};
+
+// max. two ORBs per process
+
+static orbClntSingleton clntSingleton;
+static orbSrvrSingleton srvrSingleton;
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        CORBA::ORB_var clientOrb()
+ *
+ *  @brief     retuen reference to client orb (internal use only)
+ *
+ *  @date      02.01.2004
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+CORBA::ORB_var clientOrb()
+{
+    return(_orbClnt);
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        void killClientOrb()
+ *
+ *  @brief     kills the client orb (internal use only)
+ *
+ *  @date      02.01.2004
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+void killClientOrb()
+{
+    if(!CORBA::is_nil(_orbClnt))
+    {
+      try
+      {
+        _orbClnt->shutdown(0);  // returns threads from run() method.
+      }
+      catch(...) { }
+
+      try
+      {
+        _orbClnt->destroy(); // destroy the ORB
+      }
+      catch(...) { }
+
+
+      _orbClnt = NULL;
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   static char *getHostName()
+//
+//  purpose:    get the TCPIP name of this machine
+//
+//  date:       03.12.2001, 13:27
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+static char *getHostName()
+{
+static char szTmp[256];
+
+    gethostname(szTmp,sizeof(szTmp));
+
+    return(szTmp);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long orbSrvrSingleton::function()
+//
+//  purpose:    thread function that runs the ORB
+//
+//  date:       21.11.2001, 09:26
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long orbSrvrSingleton::function()
+{
+    //trace(_HERE,"orbSrvrSingleton::function() ...");
+
+    _orbSrvr->run();
+
+    //trace(_HERE,"orbSrvrSingleton::function(), end.");
+
+    return(-1);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long orbClntSingleton::function()
+//
+//  purpose:    thread function that runs the ORB
+//
+//  date:       21.11.2001, 09:26
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long orbClntSingleton::function()
+{
+    //trace(_HERE,"orbClntSingleton::function() ...");
+
+    try { if(_orbClnt) _orbClnt->run(); } catch (...) {};
+
+    //trace(_HERE,"orbClntSingleton::function(), end.");
+
+    return(-1);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   orbClntSingleton::~orbClntSingleton()
+//
+//  purpose:    class destructor
+//
+//  date:       24.01.2002, 16:32
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+orbClntSingleton::~orbClntSingleton()
+{
+    if(!CORBA::is_nil(_orbClnt))
+    {
+      try
+      {
+        _orbClnt->shutdown(false);  // returns from run() method.
+      }
+      catch(...) { }
+
+      try
+      {
+
+#if defined (_ORBACUS_)
+
+        mThreadEx::killWait();
+
+#else
+
+        mThreadEx::kill();
+
+#endif
+
+        _orbClnt->destroy(); // destroy the ORB
+        _orbClnt = NULL;
+      }
+      catch(...) { }
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   orbSrvrSingleton::~orbSrvrSingleton()
+//
+//  purpose:    class destructor
+//
+//  date:       24.01.2002, 16:32
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+orbSrvrSingleton::~orbSrvrSingleton()
+{
+    if(!CORBA::is_nil(_orbSrvr))
+    {
+      try
+      {
+        _orbSrvr->shutdown(false);  // returns from run() method.
+      }
+      catch(...) { }
+
+      try
+      {
+
+#if defined (_ORBACUS_)
+
+        mThreadEx::killWait();
+
+#else
+
+        mThreadEx::kill();
+
+#endif
+
+        _orbSrvr->destroy(); // destroy the ORB
+        _orbSrvr = NULL;
+      }
+      catch(...) { }
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   char *corbaOrb::bindingID(const char *pszServantName)
+//
+//  purpose:    create a binding name that works for all ORBs
+//
+//  date:       22.11.2001, 15:10
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+char *corbaOrb::bindingID(const char *pszServantName)
+{
+static char szBindingName[1024];
+
+    *szBindingName = '\0';
+
+    if(pszServantName)
+    {
+#if defined(_MICO_)
+
+      sprintf(szBindingName,"massai.materna.com/POA_%s/%s",pszServantName,pszServantName);
+
+#else
+
+      sprintf(szBindingName,"%s",pszServantName);
+
+#endif
+    }
+
+    return(szBindingName);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   CORBA::ORB_ptr corbaOrb::orb()
+//
+//  purpose:    returns pointer to orb
+//
+//  date:       24.01.2002, 16:27
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+CORBA::ORB_ptr corbaOrb::orb()
+{
+    return(_orb);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void corbaOrb::createRootPOA()
+//
+//  purpose:    helper for servants and clients
+//
+//  date:       22.11.2001, 09:12
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void corbaOrb::createRootPOA()
+{
+    poaObj  = _orb->resolve_initial_references("RootPOA");
+    rootPoa = PortableServer::POA::_narrow(poaObj);
+
+    // Get a reference to the POA manager
+
+    poaManager = rootPoa->the_POAManager();
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   PortableServer::POA *corbaOrb::createPOA(const char *pszServantName)
+//
+//  purpose:    create a new POA with standard policies
+//
+//  date:       22.11.2001, 09:38
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+PortableServer::POA *corbaOrb::createPOA(const char *pszServantName)
+{
+char szPoaName[512];
+
+    policies.length(3);
+
+    policies[0]= rootPoa->create_lifespan_policy(PortableServer::PERSISTENT);
+    policies[1]= rootPoa->create_id_assignment_policy(PortableServer::USER_ID);
+    policies[2]= rootPoa->create_implicit_activation_policy(PortableServer::NO_IMPLICIT_ACTIVATION);
+
+    if(pszServantName)
+      sprintf(szPoaName,"POA_%s",pszServantName);
+    else
+      sprintf(szPoaName,"POA_%08x",this);
+
+    return(rootPoa->create_POA(szPoaName,poaManager,policies));
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long corbaOrb::activateCallback()
+//
+//  purpose:    simply activate the POA manager to have callback facilities
+//
+//  date:       22.11.2001, 09:13
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long corbaOrb::activateCallback()
+{
+    // just do the same as for normal servers
+
+    return(activateServer());
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long corbaOrb::activateServer()
+//
+//  purpose:    simply activate the POA manager to enable callees
+//
+//  date:       22.11.2001, 09:23
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long corbaOrb::activateServer()
+{
+long rc = 0;
+
+   try
+   {
+     // activate the POA
+
+     poaManager->activate();
+   }
+   catch(CORBA::SystemException & e)
+   {
+     trace(_HERE,"ORB: activateServer failure: %s",e._message());
+
+     rc = -1;
+   }
+
+   return(rc);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void corbaOrb::run()
+//
+//  purpose:    start the thread
+//
+//  date:       21.11.2001, 10:03
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void corbaOrb::run()
+{
+    if(fServer)
+    {
+      srvrSingleton.run();
+    }
+    else
+    {
+      clntSingleton.run();
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   corbaOrb::corbaOrb()
+//
+//  purpose:    class constructor for clients
+//
+//  date:       21.11.2001, 09:26
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+corbaOrb::corbaOrb()
+{
+int    argc= 0;
+char  *argv[20];
+long   port = 0;
+char   szArgs1[256];
+
+    argv[argc++] = "exefile";
+
+    if(CORBA::is_nil(_orbClnt) && CORBA::is_nil(_orbSrvr))
+    {
+#if defined (_ORBACUS_)
+
+       OB::Properties_var defProps = OB::Properties::getDefaultProperties();
+       OB::Properties_var props    = new OB::Properties( defProps );
+
+       #if defined(NUMERIC_ORB)
+
+       props->setProperty("ooc.orb.oa.numeric","true");
+
+       #endif
+
+       _orbClnt = OBCORBA::ORB_init(argc,argv,props);
+
+        fServer = false;
+
+       _orb = _orbClnt;
+#elif defined(_TAO_)
+#if defined(_TAO_1_5_)
+       argv[argc++] = "-ORBKeepalive";
+       argv[argc++] = "1";
+#endif
+
+       if(getenv("ORBENDPOINT_PORT"))
+       {
+         port = atoi(getenv("ORBENDPOINT_PORT"));
+       }
+
+       if(getenv("TAO_ENABLE_LOGGING"))
+       {
+         enableTAO_Logging(argc, argv);
+       }
+       if(port > 0)
+       {
+         sprintf(szArgs1,"iiop://:%d",port); // bind TAO-ORB to this port
+
+         if(getenv("TAO_NUMERIC_ORB"))
+         {
+           argv[argc++] = "-ORBEndpoint";
+           argv[argc++] = szArgs1;
+           argv[argc++] = "-ORBDottedDecimalAddresses";
+           argv[argc++] = "1";
+         }
+         else
+         {
+           argv[argc++] = "-ORBEndpoint";
+           argv[argc++] = szArgs1;
+         }
+
+         // if we already have a client ORB running, kill him !!
+         killClientOrb();
+
+         // create the new ORB ...
+
+        trace(_HERE,"binding new srv ORB to [%s]", szArgs1);
+
+         _orbSrvr = CORBA::ORB_init(argc,argv);
+
+         fServer = true;
+
+         _orb = _orbSrvr;
+       } else
+       {
+         if(getenv("TAO_NUMERIC_ORB"))
+         {
+           argv[argc++] = "-ORBDottedDecimalAddresses";
+           argv[argc++] = "1";
+        }
+
+        trace(_HERE,"binding new clnt ORB");
+
+         _orbClnt = CORBA::ORB_init(argc,argv);
+
+         fServer = false;
+
+         _orb = _orbClnt;
+       }
+#if defined (_TAO_1_4_)  || defined(_TAO_1_5_)
+
+       long lto = -1;
+       if(getenv("CORBA_INVOCATION_TIMEOUT"))
+       {
+           lto = atoi(getenv("CORBA_INVOCATION_TIMEOUT"));
+       }
+       if( lto > 0)
+           SetInvocationTimeout( _orb, lto, false);
+       else
+           SetInvocationTimeout( _orb, CORBA_INVOCATION_TIMEOUT_DEFAULT, false);
+#endif // _TAO_1_4_
+
+#elif defined(_MICO_)
+
+       _orbClnt = CORBA::ORB_init(argc,argv,"mico-local-orb");
+
+        fServer = false;
+
+       _orb = _orbClnt;
+
+#endif
+    } else
+    {
+      if(!CORBA::is_nil(_orbClnt))
+      {
+        fServer = false;
+
+        _orb = _orbClnt;
+      }
+
+      if(!CORBA::is_nil(_orbSrvr))
+      {
+        fServer = true;
+
+        _orb = _orbSrvr;
+      }
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   corbaOrb::corbaOrb(long port)
+//
+//  purpose:    class constructor for servants
+//
+//  date:       21.11.2001, 09:26
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+corbaOrb::corbaOrb(long port)
+{
+int    argc;
+char  *argv[20];
+char   szArgs1[256];
+
+    argc    = 0;
+    argv[argc++] = "exefile";
+
+    if(CORBA::is_nil(_orbSrvr))
+    {
+#if defined (_ORBACUS_)
+
+       OB::Properties_var defProps = OB::Properties::getDefaultProperties();
+       OB::Properties_var props    = new OB::Properties( defProps );
+
+       #if defined(NUMERIC_ORB)
+
+       props->setProperty("ooc.orb.oa.numeric","true");
+
+       #endif
+
+       if(port > 0)
+       {
+         sprintf(szArgs1,"%d",port);
+         props->setProperty("ooc.orb.oa.port", szArgs1 );
+       }
+
+       _orbSrvr = OBCORBA::ORB_init(argc,argv,props);
+
+#elif defined(_TAO_)
+
+#if defined(_TAO_1_5_)
+       argv[argc++] = "-ORBKeepalive";
+       argv[argc++] = "1";
+#endif
+       if(getenv("TAO_ENABLE_LOGGING"))
+       {
+         enableTAO_Logging(argc, argv);
+       }
+       if(port <= 0)
+       {
+         if(getenv("ORBENDPOINT_PORT"))
+         {
+           port = atoi(getenv("ORBENDPOINT_PORT"));
+         }
+       }
+
+       if(port > 0)
+       {
+         sprintf(szArgs1,"iiop://:%d",port); // bind TAO-ORB to this port
+
+         if(getenv("TAO_NUMERIC_ORB"))
+         {
+           argv[argc++] = "-ORBEndpoint";
+           argv[argc++] = szArgs1;
+           argv[argc++] = "-ORBDottedDecimalAddresses";
+           argv[argc++] = "1";
+
+         }
+         else
+         {
+           argv[argc++] = "-ORBEndpoint";
+           argv[argc++] = szArgs1;
+         }
+       }
+
+       // if we already have a client ORB running, kill him !!
+       killClientOrb();
+
+       // create the new ORB ...
+
+       trace(_HERE,"binding new srv ORB to [%s]", szArgs1);
+
+       _orbSrvr = CORBA::ORB_init(argc,argv);
+
+#if defined (_TAO_1_4_)  || defined(_TAO_1_5_)
+       long lto = -1;
+       if(getenv("CORBA_INVOCATION_TIMEOUT"))
+       {
+           lto = atoi(getenv("CORBA_INVOCATION_TIMEOUT"));
+       }
+       if( lto > 0)
+           SetInvocationTimeout( _orbSrvr, lto, false);
+       else
+           SetInvocationTimeout( _orbSrvr, CORBA_INVOCATION_TIMEOUT_DEFAULT, false);
+#endif //_TAO_1_4_
+
+#elif defined(_MICO_)
+
+       if(port > 0)
+       {
+         sprintf(szArgs1,"inet:%s:%d",getHostName(),port); // bind MICO-ORB to this port
+         sprintf(szArgs2,"%s","massai.materna.com");
+
+         argv[argc++] = "-ORBIIOPAddr";
+         argv[argc++] = szArgs1;
+         argv[argc++] = "-POAImplName";
+         argv[argc++] = szArgs2;
+       }
+
+       _orbSrvr = CORBA::ORB_init(argc,argv,"mico-local-orb");
+
+#endif
+    }
+
+    fServer = true;
+
+   _orb = _orbSrvr;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   corbaOrb::corbaOrb(const char * pszHostName, long port)
+//
+//  purpose:    class constructor for servants
+//
+//  date:       21.11.2001, 09:26
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+corbaOrb::corbaOrb(const char * pszHostName, long port)
+{
+  init(pszHostName, port, false);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   corbaOrb::init(const char * pszHostName, long port)
+//
+//  purpose:    initialize corbaOrb
+//
+//  date:       26.07.2007
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+void corbaOrb::init(const char * pszHostName, long port, bool client)
+{
+int    argc;
+char  *argv[20];
+char   szArgs1[256];
+
+    argc    = 0;
+    argv[argc++] = "exefile";
+
+    if(CORBA::is_nil(_orbSrvr))
+    {
+#if defined (_ORBACUS_)
+
+       OB::Properties_var defProps = OB::Properties::getDefaultProperties();
+       OB::Properties_var props    = new OB::Properties( defProps );
+
+       #if defined(NUMERIC_ORB)
+
+       props->setProperty("ooc.orb.oa.numeric","true");
+
+       #endif
+
+       if(port > 0)
+       {
+         sprintf(szArgs1,"%d",port);
+         props->setProperty("ooc.orb.oa.port", szArgs1 );
+       }
+
+       _orbSrvr = OBCORBA::ORB_init(argc,argv,props);
+
+#elif defined(_TAO_)
+
+#if defined(_TAO_1_5_)
+       argv[argc++] = "-ORBKeepalive";
+       argv[argc++] = "1";
+#endif
+
+       if(getenv("TAO_ENABLE_LOGGING"))
+       {
+         enableTAO_Logging(argc, argv);
+       }
+       if(port <= 0)
+       {
+         if(getenv("ORBENDPOINT_PORT"))
+         {
+           port = atoi(getenv("ORBENDPOINT_PORT"));
+         }
+       }
+
+       if(port > 0)
+       {
+         if(pszHostName && *pszHostName && (strcmp(pszHostName, "127.0.0.1") != 0))
+         {
+           // bind TAO-ORB to the specified port and the specified hostname
+           sprintf(szArgs1,"iiop://%s:%d", pszHostName, port);
+         }
+         else
+         {
+           // bind TAO-ORB to the port and the hostname of this machine
+           // sprintf(szArgs1,"iiop://%s:%d",getHostName(),port);
+           sprintf(szArgs1,"iiop://:%d", port);
+         }
+
+         if(getenv("TAO_NUMERIC_ORB"))
+         {
+           argv[argc++] = "-ORBEndpoint";
+           argv[argc++] = szArgs1;
+           argv[argc++] = "-ORBDottedDecimalAddresses";
+           argv[argc++] = "1";
+         }
+         else
+         {
+           argv[argc++] = "-ORBEndpoint";
+           argv[argc++] = szArgs1;
+         }
+       }
+
+       killClientOrb();
+
+       // create the new ORB ...
+
+       trace(_HERE,"binding new srv ORB to [%s]", szArgs1);
+
+       _orbSrvr = CORBA::ORB_init(argc,argv);
+
+#if defined (_TAO_1_4_)  || defined(_TAO_1_5_)
+       long lto = -1;
+       if(getenv("CORBA_INVOCATION_TIMEOUT"))
+       {
+           lto = atoi(getenv("CORBA_INVOCATION_TIMEOUT"));
+       }
+       if( lto > 0)
+           SetInvocationTimeout( _orbSrvr, lto, false);
+       else
+           SetInvocationTimeout( _orbSrvr, CORBA_INVOCATION_TIMEOUT_DEFAULT, false);
+#endif // _TAO_1_4_
+
+#elif defined(_MICO_)
+
+       if(port > 0)
+       {
+         sprintf(szArgs1,"inet:%s:%d",getHostName(),port); // bind MICO-ORB to this port
+         sprintf(szArgs2,"%s","massai.materna.com");
+
+         argv[argc++] = "-ORBIIOPAddr";
+         argv[argc++] = szArgs1;
+         argv[argc++] = "-POAImplName";
+         argv[argc++] = szArgs2;
+       }
+
+       _orbSrvr = CORBA::ORB_init(argc,argv,"mico-local-orb");
+
+#endif
+    }
+
+    fServer = true;
+
+   _orb = _orbSrvr;
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   corbaOrb::~corbaOrb()
+//
+//  purpose:    class destructor
+//
+//  date:       21.11.2001, 09:26
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+corbaOrb::~corbaOrb()
+{
+    if(!CORBA::is_nil(_orb))
+      _orb = NULL;
+}
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbaorbEx.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbaorbEx.cpp
new file mode 100644
index 00000000..37ec4669
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbaorbEx.cpp
@@ -0,0 +1,716 @@
+/**
+ *  @file      corbaorbEx.cpp
+ *
+ *  @brief     Extensions for servants hosting lots of clients
+ *
+ *  @date      19.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ *
+ ************************************************************************/
+
+#include <list>
+
+#include "massaiCorba/corbaorbEx.h"
+#include "massaiCorba/corbacfg.h"
+#include "massaidll/mThreadEx.h"
+#include "tracedef.h"
+#include "systools/mSysException.hpp"
+
+extern void killClientOrb();
+
+namespace
+{
+  mThreadMutex sem;
+
+  void enableTAO_Logging(int& argc, char **argv)
+  {
+    argv[argc++] = "-ORBDebug";
+
+    argv[argc++] = "-ORBDebugLevel";
+    argv[argc++] = "10";
+
+    argv[argc++] = "-ORBVerboseLogging";
+    argv[argc++] = "2";
+  }
+
+  //---------------------------------------------------------------------------
+  //
+  //  function:   static char *getHostName()
+  //
+  //  purpose:    get the TCPIP name of this machine
+  //
+  //  date:       03.12.2001, 13:27
+  //
+  //  author:     Materna Information & Communications (AGe)
+  //
+  //---------------------------------------------------------------------------
+
+  static char *getHostName()
+  {
+    static char szTmp[256];
+
+    memset(szTmp,0,sizeof(szTmp));
+
+    gethostname(szTmp,sizeof(szTmp) -1);
+
+    if(!*szTmp)
+    {
+      WSADATA wsaData;
+      WORD    wVersionRequested = MAKEWORD(1,1);
+
+      WSAStartup(wVersionRequested,&wsaData);
+
+      gethostname(szTmp,sizeof(szTmp));
+    }
+
+    return(szTmp);
+  }
+
+  struct orbInterface { CORBA::ORB *orb; char szIF[256]; };
+
+  class orbList
+  {
+    private:
+
+      std::list<orbInterface *> oList;
+
+    public:
+
+      long addOrb(CORBA::ORB_var o, char *pszInterface)
+      {
+        orbInterface *p  = NULL;
+        long          rc = 0;
+
+          if(!pszInterface || !o.in())
+            return(-1);
+
+          p = (orbInterface*) malloc(sizeof(orbInterface));
+
+          if(p)
+          {
+            // setup struct members
+
+            strcpy(p->szIF,pszInterface);
+            p->orb = o.in();
+
+            // and add to end of list
+
+            mThreadAutoMutex protect(&sem);
+            oList.push_back(p);
+          }
+          else
+            rc = -2;
+
+          trace(_HERE,"current number of ORBs: %d",oList.size());
+
+          return(rc);
+      }
+
+      CORBA::ORB *findOrb(char *pszInterface)
+      {
+        std::list<orbInterface *>::iterator i;
+
+        CORBA::ORB *o = NULL;
+        bool fFound;
+
+          mThreadAutoMutex protect(&sem);
+
+          for(fFound = false, i = oList.begin(); !fFound && i != oList.end(); i++)
+          {
+            if(!strcmp((*i)->szIF,pszInterface))
+            {
+              fFound = true;
+              o = (*i)->orb;
+            }
+          }
+
+          return(o);
+      }
+
+     ~orbList()
+      {
+        std::list<orbInterface *>::iterator i;
+
+        orbInterface *p  = NULL;
+
+          mThreadAutoMutex protect(&sem);
+
+          while(!oList.empty())
+          {
+            i = oList.begin();
+
+            p = (*i);
+
+            free(p);
+
+            oList.erase(i);
+          }
+      }
+  };
+
+  long lOrbCnt = 0;
+  orbList _orbs;
+}
+
+
+
+class threadPool : public mThreadEx
+{
+private:
+
+    CORBA::ORB_var orb;
+
+    long function()
+    {
+       if(orb.in())
+       {
+          mSysException::standardException Guard;
+          try
+          {
+            orb->run();
+          }
+          catch(CORBA::SystemException & e)
+          {
+            trace(_HERE,"ORB: terminated due to CORBA::SystemException: %s",e._message());
+          }
+          catch(std::exception& e)
+          {
+            trace(_HERE,"ORB: terminated due to Exception: %s",e.what());
+          }
+          catch(char *szException)
+          {
+            trace(_HERE,"ORB: terminated due to Exception: %s",szException);
+          }
+          catch(...)
+          {
+            trace(_HERE,"ORB: terminated due to unknown exception.");
+          }
+       }
+
+       return(-1);
+    }
+
+public:
+
+    threadPool(CORBA::ORB_var o, long lThreads) : mThreadEx(lThreads)
+    {
+       orb = o;
+    }
+};
+
+
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long corbaOrbEx::createOrb()
+ *
+ *  @brief     creates an orb with specific properties
+ *
+ *  @date      08.01.2004
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long corbaOrbEx::createOrb()
+{
+    long rc;
+    int         argc;
+    char       *argv       [20];
+    char        szArgs1    [256];
+
+
+    killClientOrb();
+
+    ++lOrbCnt;
+
+    if(CORBA::is_nil(_orbSrvr))
+    {
+      argc    = 0;
+      argv[argc++] = "exefile";
+
+#if defined(_TAO_1_5_)
+       argv[argc++] = "-ORBKeepalive";
+       argv[argc++] = "1";
+#endif
+
+      if(getenv("TAO_ENABLE_LOGGING"))
+      {
+        enableTAO_Logging(argc, argv);
+      }
+      // provide different orb names if we have more than one orb in one process !!!
+
+      sprintf(szOrbName,"ORB$%04x$%d",GetCurrentThreadId(),lOrbCnt);
+
+      if(lPort > 0)
+      {
+        if(*szHostName && (strcmp(szHostName, "127.0.0.1") != 0))
+        {
+          // bind TAO-ORB to the specified port and the specified hostname
+
+          sprintf(szArgs1,"iiop://%s:%d", szHostName, lPort);
+        }
+        else
+        {
+          // bind TAO-ORB to the port and the hostname of this machine
+
+          //sprintf(szArgs1,"iiop://%s:%d",getHostName(),lPort);
+          if (strlen(szIORName)>0)
+            sprintf(szArgs1,"iiop://:%d/hostname_in_ior=%s", lPort,szIORName);
+          else
+            sprintf(szArgs1,"iiop://:%d", lPort);
+
+          //strcpy(szHostName, "0.0.0.0");
+          //strcpy(szHostName,getHostName());
+
+          // trace(_HERE,"getHostName() = %s",szHostName);
+        }
+
+        if(getenv("TAO_NUMERIC_ORB"))
+        {
+          trace(_HERE,"TAO_NUMERIC_ORB is set in the environment.");
+
+          argv[argc++] = "-ORBEndpoint";
+          argv[argc++] = szArgs1;
+          argv[argc++] = "-ORBDottedDecimalAddresses";
+          argv[argc++] = "1";
+        }
+        else
+        {
+          argv[argc++] = "-ORBEndpoint";
+          argv[argc++] = szArgs1;
+        }
+      }
+
+      // check if we already have an orb for this interface
+
+      _orb = _orbs.findOrb(szArgs1);
+
+      if(!_orb.in())
+      {
+        // create the new ORB ...
+
+        for(long i = 0; i < argc; i++)
+          trace(_HERE,"argv[%d] = %s",i,argv[i]);
+
+        trace(_HERE,"binding new ORB [%s] to [%s]",szOrbName,szArgs1);
+
+        _orb = CORBA::ORB_init(argc,argv,szOrbName);
+
+#if defined (_TAO_1_4_)
+        long lto = -1;
+        if(getenv("CORBA_INVOCATION_TIMEOUT"))
+        {
+            lto = atoi(getenv("CORBA_INVOCATION_TIMEOUT"));
+        }
+        if( lto > 0)
+            SetInvocationTimeout( _orb, lto, false);
+        else
+            SetInvocationTimeout( _orb, CORBA_INVOCATION_TIMEOUT_DEFAULT, false);
+#endif // _TAO_1_4_
+
+        trace(_HERE,"new ORB [%s] bound to [%s]",szOrbName,szArgs1);
+
+        _orbs.addOrb(_orb,szArgs1);
+
+      }
+      else
+        trace(_HERE,"ORB [%s] already bound to [%s]",szOrbName,szArgs1);
+
+      _orbSrvr = _orb;
+
+      rc = 0;
+    }
+    else
+      rc = 1;
+
+    return(rc);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   char *corbaOrbEx::bindingID(const char *pszServantName)
+//
+//  purpose:    create a binding name that works for all ORBs
+//
+//  date:       22.11.2001, 15:10
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+char *corbaOrbEx::bindingID(const char *pszServantName)
+{
+static char szBindingName[1024];
+
+    *szBindingName = '\0';
+
+    if(pszServantName)
+    {
+#if defined(_MICO_)
+
+      sprintf(szBindingName,"massai.materna.com/POA_%s/%s",pszServantName,pszServantName);
+
+#else
+
+      sprintf(szBindingName,"%s",pszServantName);
+
+#endif
+    }
+
+    return(szBindingName);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   CORBA::ORB_ptr corbaOrbEx::orb()
+//
+//  purpose:    returns pointer to orb
+//
+//  date:       24.01.2002, 16:27
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+CORBA::ORB_ptr corbaOrbEx::orb()
+{
+    return(_orb);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void corbaOrbEx::createRootPOA()
+//
+//  purpose:    helper for servants and clients
+//
+//  date:       22.11.2001, 09:12
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void corbaOrbEx::createRootPOA()
+{
+    if(!CORBA::is_nil(_orb))
+    {
+      poaObj  = _orb->resolve_initial_references("RootPOA");
+      rootPoa = PortableServer::POA::_narrow(poaObj);
+
+      // Get a reference to the POA manager
+
+      poaManager = rootPoa->the_POAManager();
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   PortableServer::POA *corbaOrbEx::createPOA(const char *pszServantName)
+//
+//  purpose:    create a new POA with standard policies
+//
+//  date:       22.11.2001, 09:38
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+PortableServer::POA *corbaOrbEx::createPOA(const char *pszServantName)
+{
+char szPoaName[512];
+
+    policies.length(3);
+
+    policies[0]= rootPoa->create_lifespan_policy(PortableServer::PERSISTENT);
+    policies[1]= rootPoa->create_id_assignment_policy(PortableServer::USER_ID);
+    policies[2]= rootPoa->create_implicit_activation_policy(PortableServer::NO_IMPLICIT_ACTIVATION);
+
+    if(pszServantName)
+      sprintf(szPoaName,"POA_%s",pszServantName);
+    else
+      sprintf(szPoaName,"POA_%08x",this);
+
+    trace(_HERE,"new POA: %s",szPoaName);
+
+    try
+    {
+      return(rootPoa->create_POA(szPoaName,poaManager,policies));
+    }
+    catch(CORBA::SystemException & e)
+    {
+      trace(_HERE,"CORBA::SystemException: %s",e._message());
+    }
+    catch(...)
+    {
+      trace(_HERE,"POA: %s not created.",szPoaName);
+    }
+
+    return(NULL);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long corbaOrbEx::activateCallback()
+//
+//  purpose:    simply activate the POA manager to have callback facilities
+//
+//  date:       22.11.2001, 09:13
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long corbaOrbEx::activateCallback()
+{
+    // just do the same as for normal servers
+
+    return(activateServer());
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long corbaOrbEx::activateServer()
+//
+//  purpose:    simply activate the POA manager to enable callees
+//
+//  date:       22.11.2001, 09:23
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long corbaOrbEx::activateServer()
+{
+long rc = 0;
+
+   try
+   {
+     // activate the POA
+
+     poaManager->activate();
+   }
+   catch(CORBA::SystemException & e)
+   {
+     trace(_HERE,"CORBA::SystemException: %s",e._message());
+
+     rc = -1;
+   }
+
+   return(rc);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void corbaOrbEx::run()
+//
+//  purpose:    start the thread(s)
+//
+//  date:       21.11.2001, 10:03
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void corbaOrbEx::start()
+{
+    if(workers)
+    {
+      trace(_HERE,"starting worker %d thread(s) for %s ...",lWorkers,szOrbName);
+
+      //trace(_HERE,"starting worker %d threads for %s, 0x%08lx, 0x%08lx ...",
+      //            lWorkers,szOrbName,&workers,workers);
+
+      workers->run();
+    }
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   void corbaOrbEx::initialize(const char * pszHostName, long port, long lThreads, const char *pszHostname_in_ior)
+//
+//  purpose:    initializes corbaOrbEx, use once in constructor
+//
+//  date:       26.06.2007
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+void corbaOrbEx::initialize(const char * pszHostName, long port, long lThreads, const char *pszHostname_in_ior)
+{
+long rc = 0;
+
+    _orb     = NULL;
+    _orbSrvr = NULL;
+    workers  = NULL;
+
+    lPort    = port;
+    lWorkers = lThreads;
+
+    if (pszHostname_in_ior)
+      strcpy(szIORName, pszHostname_in_ior);
+    else
+      strcpy(szIORName, "");
+
+    if(pszHostName)
+      strcpy(szHostName,pszHostName);
+    else
+      strcpy(szHostName, "");
+
+    rc = createOrb();
+
+    workers = new threadPool(_orbSrvr,lThreads);
+
+    //trace(_HERE,"worker threads, 0x%08lx, 0x%08lx ...",&workers,workers);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   corbaOrbEx::corbaOrbEx()
+//
+//  purpose:    class constructor for servants
+//
+//  date:       09.08.2007
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+corbaOrbEx::corbaOrbEx()
+{
+    long port = 0;
+    if(getenv("ORBENDPOINT_PORT"))
+    {
+      port = atoi(getenv("ORBENDPOINT_PORT"));
+    }
+    initialize("", port, 1, "");
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   corbaOrbEx::corbaOrbEx(long port, long lThreads, const char *pszHostname_in_ior)
+//
+//  purpose:    class constructor for servants
+//
+//  date:       30.05.2007
+//
+//  author:     Materna Information & Communications (PtM)
+//
+//---------------------------------------------------------------------------
+
+corbaOrbEx::corbaOrbEx(long port, long lThreads, const char *pszHostname_in_ior)
+{
+    initialize("", port, lThreads, pszHostname_in_ior);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   corbaOrbEx::corbaOrbEx(long port)
+//
+//  purpose:    class constructor for servants
+//
+//  date:       21.11.2001, 09:26
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+corbaOrbEx::corbaOrbEx(long port, long lThreads)
+{
+    initialize("", port, lThreads, "");
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   corbaOrbEx::corbaOrbEx(const char * pszHostName, long port)
+//
+//  purpose:    class constructor for servants
+//
+//  date:       21.11.2001, 09:26
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+corbaOrbEx::corbaOrbEx(const char *pszHostName, long port, long lThreads)
+{
+    initialize(pszHostName, port, lThreads, "");
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   corbaOrbEx::~corbaOrbEx()
+//
+//  purpose:    class destructor
+//
+//  date:       21.11.2001, 09:26
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+corbaOrbEx::~corbaOrbEx()
+{
+    if(!CORBA::is_nil(_orb))
+    {
+      try
+      {
+        _orb->shutdown(0);  // returns threads from run() method.
+      }
+      catch(...) { }
+
+      try
+      {
+        _orb->destroy(); // destroy the ORB
+      }
+      catch(...) { }
+    }
+
+    if(workers)
+    {
+      // wait for worker threads to terminate
+
+      workers->wait();
+
+      delete workers;
+    }
+
+    _orb = NULL;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbaorbcfg.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbaorbcfg.cpp
new file mode 100644
index 00000000..d948eb70
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbaorbcfg.cpp
@@ -0,0 +1,174 @@
+//---------------------------------------------------------------------------
+//
+//  file:       corbaorbcfg.cpp
+//
+//  purpose:    split of CFGMGR part
+//
+//  date:       19.02.2002, 16:13
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include "massaiCorba/corbaorb.h"
+#include "massaiCorba/corbacfg.h"
+#include "tracedef.h"
+
+//---------------------------------------------------------------------------
+//
+//  function:   static char *getHostName()
+//
+//  purpose:    get the TCPIP name of this machine
+//
+//  date:       03.12.2001, 13:27
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+static char *getHostName()
+{
+static char szTmp[256];
+
+    gethostname(szTmp,sizeof(szTmp));
+
+    return(szTmp);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long corbaOrb::createObject(const char *pszIOR,
+//                                          CORBA::Object_var& obj)
+//
+//  purpose:    helper function for clients/servants
+//
+//  date:       21.11.2001, 16:02
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long corbaOrb::createObject(const char *pszIOR,CORBA::Object_var& obj)
+{
+  bool local;
+  std::string name;
+  return createObject(pszIOR, obj, local, name);
+}
+
+long corbaOrb::createObject(const char *pszIOR, CORBA::Object_var& obj, bool& local, std::string& name)
+{
+char szIOR [1024];
+char szTmp [1024];
+char szHost[256];
+long rc = 0;
+local= false;
+
+    if(pszIOR)
+    {
+      strcpy(szTmp,pszIOR);
+      strlwr(szTmp);
+
+      if(strstr(szTmp,"corbaloc:") != szTmp && strstr(szTmp,"ior:") != szTmp)
+      {
+        // servant name only ?? -> build corbaloc ior
+
+        strcpy(szHost,getConfigHost(pszIOR).c_str());
+        strlwr(szHost);
+
+        if(!strcmp(szHost,"localhost") || !strcmp(szHost,"127.0.0.1"))
+        {
+          // use the IP host name instead of localhost or 127.0.0.1
+          local= true;
+          strcpy(szHost,getHostName());
+        }
+
+        sprintf(szIOR,"corbaloc:iiop:%s:%5d/%s",szHost,getConfigPort(pszIOR),pszIOR);
+      }
+      else
+        strcpy(szIOR,pszIOR);
+
+      name= szIOR;
+      obj = orb()->string_to_object(szIOR);
+
+      if(CORBA::is_nil(obj))
+        rc = -1;
+    }
+    else
+      rc = -1;
+
+    return(rc);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long corbaOrb::createObject(const char *pszHost,
+//                                          long port,
+//                                          const char* pszServant,
+//                                          CORBA::Object_var& obj)
+//
+//  purpose:    helper function for clients/servants
+//
+//  date:       21.11.2001, 16:02
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long corbaOrb::createObject(const char *pszHost,
+                            long port,
+                            const char* pszServant,
+                            CORBA::Object_var& obj)
+{
+  bool local;
+  std::string name;
+  return createObject(pszHost, port, pszServant, obj, local, name);
+}
+
+long corbaOrb::createObject(const char *pszHost,
+                            long port,
+                            const char* pszServant,
+                            CORBA::Object_var& obj,
+                            bool& local,
+                            std::string& name)
+{
+char szIOR [1024];
+char szHost[256];
+long rc = 0;
+local= false;
+
+    if(port > 0 && pszServant)
+    {
+      if(pszHost && !*pszHost)
+      {
+        local= true;
+        sprintf(szIOR,"corbaloc:iiop:%s:%5d/%s",getHostName(),port,pszServant);
+      }
+      else
+      {
+        strcpy(szHost,pszHost);
+        strlwr(szHost);
+
+        if(!strcmp(szHost,"localhost") || !strcmp(szHost,"127.0.0.1"))
+        {
+          // use the IP host name instead of localhost or 127.0.0.1
+
+          local= true;
+          strcpy(szHost,getHostName());
+          pszHost = szHost;
+        }
+
+        sprintf(szIOR,"corbaloc:iiop:%s:%5d/%s",pszHost,port,pszServant);
+      }
+
+      name= szIOR;
+      obj = orb()->string_to_object(szIOR);
+
+      if(CORBA::is_nil(obj))
+        rc = -1;
+    }
+    else
+      rc =  -1;
+
+    return(rc);
+}
+
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbapoll.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbapoll.cpp
new file mode 100644
index 00000000..c5a2dc08
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbapoll.cpp
@@ -0,0 +1,227 @@
+//---------------------------------------------------------------------------
+//
+//  file:       corbapoll.cpp
+//
+//  purpose:    ORB class and helper functions implementation
+//
+//---------------------------------------------------------------------------
+
+#include "systools/mSysThread.hpp"
+#include "systools/mEventSem.hpp"
+#include "massaiCorba/corbapoll.h"
+#include "massaiCorba/orbIncDefs.h"
+#include "tracedef.h"
+
+#define CORBA_AUTOPOLL_TIMEOUT 60000
+namespace
+{
+  int global_id= 0;
+}
+
+class corbaPollImpl: public mSysThread::thread
+{
+  public:
+    corbaPollImpl();
+    ~corbaPollImpl();
+    void startPolling(corbaPoll* owner, long pollTimeout);
+    void stopPolling();
+    void stopThread();
+    void pollingName(const std::string& name);
+    std::string getName() const;
+  private:
+    void function();
+    corbaPoll* m_owner;
+    long m_pollTimeout;
+    bool m_poll;
+    bool m_started;
+    Materna::MSSD::eventSemaphore m_stop;
+    std::string m_name;
+    int m_id;
+};
+
+corbaPollImpl::corbaPollImpl():
+  mSysThread::thread(0),
+  m_owner(0),
+  m_pollTimeout(0),
+  m_poll(false),
+  m_started(false),
+  m_stop(),
+  m_name(),
+  m_id(global_id++)
+{
+}
+corbaPollImpl::~corbaPollImpl()
+{}
+void corbaPollImpl::startPolling(corbaPoll* owner, long pollTimeout)
+{
+  if(owner)
+  {
+    m_pollTimeout= pollTimeout;
+    m_poll= true;
+    if(!m_started)
+    {
+      trace(_HERE_7,"startThread... %d", m_id);
+      m_owner= owner;
+      m_started= true;
+      //run();
+      start();
+      trace(_HERE_7,"startThread done %d", m_id);
+    }
+  }
+}
+void corbaPollImpl::stopPolling()
+{
+  m_poll= false;
+}
+void corbaPollImpl::stopThread()
+{
+  trace(_HERE_7,"stopThread... %d", m_id);
+  m_started= false;
+  m_stop.post();
+  long rc= waitTerminated();
+  trace(_HERE_7,"stopThread done %d %d", m_id, rc);
+}
+void corbaPollImpl::function()
+{
+  try
+  {
+    while(m_started)
+    {
+      trace(_HERE_7,"polling...%d", m_id);
+      try
+      {
+        if(m_poll)
+        {
+          bool alive= false;
+          try
+          {
+            trace(_HERE_9,"(%.200s) poll...", m_name.c_str());
+            if(m_owner)
+              alive= m_owner->poll();
+            trace(_HERE_9,"(%.200s) poll.", m_name.c_str());
+          }
+          catch(CORBA::SystemException & e)
+          {
+            trace(_HERE,"(%.200s) polling failed: %s", m_name.c_str(), e._message());
+          }
+          if(!alive)
+          {
+            trace(_HERE_5,"(%.200s) polling failed.", m_name.c_str());
+            try
+            {
+              if(m_owner)
+                m_owner->pollingFailed();
+            }
+            catch(...)
+            {
+              trace(_HERE,"(%.200s) pollingFailed failed", m_name.c_str());
+            }
+          }
+          m_stop.wait(m_pollTimeout);
+          m_stop.reset();
+        }
+        else
+        {
+          trace(_HERE_7,"(%.200s) do not poll.", m_name.c_str());
+          m_stop.wait();
+          m_stop.reset();
+        }
+      }
+      catch(...)
+      {
+        trace(_HERE,"(%.200s) polling failed", m_name.c_str());
+        m_stop.wait(m_pollTimeout);
+        m_stop.reset();
+      }
+    }
+  }
+  catch(...)
+  {}
+  trace(_HERE_7,"polling done %d", m_id);
+  // return -1;
+}
+void corbaPollImpl::pollingName(const std::string& name)
+{
+  m_name= name;
+}
+std::string corbaPollImpl::getName() const
+{
+  return m_name;
+}
+
+
+
+corbaPoll::corbaPoll():
+  m_pImpl(new corbaPollImpl)
+{}
+corbaPoll::~corbaPoll()
+{
+  try
+  {
+    m_pImpl->stopThread();
+  }
+  catch(...)
+  {
+    try
+    {
+      trace(_HERE,"(%.200s) stopThread failed", m_pImpl->getName().c_str());
+    }
+    catch(...) {}
+  }
+}
+
+bool corbaPoll::poll()
+{
+  return false;
+}
+void corbaPoll::pollingFailed()
+{}
+
+void corbaPoll::startPolling(long pollTimeout)
+{
+  if(pollTimeout < 100)
+    pollTimeout= 100;
+  m_pImpl->startPolling(this, pollTimeout);
+}
+void corbaPoll::startAutoPolling(bool local, AutoPolling autopoll)
+{
+  if(autopoll == AUTO_POLL_OFF && !getenv("CORBA_AUTOPOLL_ENABLE"))
+  {
+    trace(_HERE_7,"(%.200s) automatic poll not selected", m_pImpl->getName().c_str());
+  }
+  else if(local && !(autopoll == AUTO_POLL_ON || autopoll == AUTO_POLL_ON_FORCE))
+  {
+    trace(_HERE_7,"(%.200s) automatic not for local servant", m_pImpl->getName().c_str());
+  }
+  else if(getenv("CORBA_AUTOPOLL_DISABLE") && !(autopoll == AUTO_POLL_NON_LOCAL_FORCE || autopoll == AUTO_POLL_ON_FORCE))
+  {
+    trace(_HERE_7,"(%.200s) automatic poll disabled", m_pImpl->getName().c_str());
+  }
+  else
+  {
+    trace(_HERE,"(%.200s) automatic poll enabled", m_pImpl->getName().c_str());
+    char* pszPollTimeout= getenv("CORBA_AUTOPOLL_TIMEOUT");
+    if(pszPollTimeout)
+    {
+      startPolling(atoi(pszPollTimeout));
+    }
+    else
+    {
+      startPolling(CORBA_AUTOPOLL_TIMEOUT);
+    }
+  }
+}
+void corbaPoll::stopPolling()
+{
+  m_pImpl->stopPolling();
+}
+void corbaPoll::pollingName(const std::string& name)
+{
+  m_pImpl->pollingName(name);
+}
+
+
+
+// intentionally not implemented, do not copy this class
+// corbaPoll::corbaPoll(const corbaPoll& assign);
+// corbaPoll& corbaPoll::operator=(const corbaPoll& assign);
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbasrvr.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbasrvr.cpp
new file mode 100644
index 00000000..d03868c4
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/corbasrvr.cpp
@@ -0,0 +1,13 @@
+//---------------------------------------------------------------------------
+//
+//  file:       corbasrvr.cpp
+//
+//  purpose:    CORBA server/servant basics
+//
+//  date:       26.10.99, 11:17
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include "massaiCorba/corbasrvr.h"
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/iorparser.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/iorparser.cpp
new file mode 100644
index 00000000..76509902
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/iorparser.cpp
@@ -0,0 +1,583 @@
+/**
+ *  @file      iorparser.cpp
+ *
+ *  @brief     IOR parser implementation
+ *
+ *  @date      21.10.2005
+ *
+ *  @author    Materna Information & Communications (AGe)
+ *
+ ************************************************************************/
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+#include "massaiCorba/iorparser.h"
+
+int iorParser::hexChar2int (char thisChar)
+{
+  switch (tolower(thisChar))
+    {
+    case '0': return (0);
+    case '1': return (1);
+    case '2': return (2);
+    case '3': return (3);
+    case '4': return (4);
+    case '5': return (5);
+    case '6': return (6);
+    case '7': return (7);
+    case '8': return (8);
+    case '9': return (9);
+    case 'a': return (10);
+    case 'b': return (11);
+    case 'c': return (12);
+    case 'd': return (13);
+    case 'e': return (14);
+    case 'f': return (15);
+    }
+
+  return -1;
+}
+
+unsigned long iorParser::getOctet8Field (char *readPtr, int *hexCharsRead)
+{
+  char octet8Holder[8];
+  unsigned long value;
+  int i;
+
+  for (i = 0; i < 8; i++)
+    octet8Holder[i] = * (readPtr + i);
+
+  *hexCharsRead = 8;
+
+  value = 16*hexChar2int (octet8Holder[6]) + hexChar2int (octet8Holder[7]);
+  return (value);
+}
+
+unsigned long iorParser::getOctet4Field (char *readPtr, int *hexCharsRead)
+{
+  char octet4Holder[4];
+  unsigned long value;
+  int i;
+
+  for (i = 0; i < 4; i++)
+    octet4Holder[i] = * (readPtr + i);
+
+  *hexCharsRead = 4;
+
+  // On a little endian platform, the LSB is first and the MSB is next
+  //value = 16*16*16* hexChar2int (octet4Holder[2]) + 256* hexChar2int (octet4Holder[3]) + 16* hexChar2int (octet4Holder[0]) + hexChar2int (octet4Holder[1]);
+
+  value = 16*16*16* hexChar2int (octet4Holder[0]) + 256* hexChar2int (octet4Holder[1]) + 16* hexChar2int (octet4Holder[2]) + hexChar2int (octet4Holder[3]);
+
+  return (value);
+}
+
+unsigned long iorParser::getOctet2Field (char *readPtr, int *hexCharsRead)
+{
+  char octet2Holder[2];
+  unsigned long value;
+  int i;
+
+  for (i = 0; i < 2; i++)
+    octet2Holder[i] = * (readPtr + i);
+
+  *hexCharsRead = 2;
+
+  value = 16 * hexChar2int (octet2Holder[0]) +  hexChar2int (octet2Holder[1]);
+  return (value);
+}
+
+void iorParser::skipSpaceIfAny(char *readPtr, int *hexCharsRead)
+{
+  char nullOctet[2];
+  int offset;
+
+  *hexCharsRead = 0;
+  offset = 0;
+
+  // Some ORBs tend to insert a single space character, ie, ASCII
+  // equivalent 20, at the end of certain fields in the IOR. Use
+  // skipSpaceIfAny() with care since in certain cases, it might
+  // actually represent an unsigned long.
+
+  nullOctet[0] = *(readPtr + offset);
+  nullOctet[1] = *(readPtr + offset + 1);
+
+  if ((nullOctet[0] == '2') && (nullOctet[1] == '0'))
+    offset += 2;
+
+  *hexCharsRead = offset;
+}
+
+void iorParser::skipNullOctets (char *readPtr, int *hexCharsRead, int expectingStr)
+{
+  char nullOctet[4];
+  int offset;
+
+  *hexCharsRead = 0;
+  offset = 0;
+
+  // There sometimes occurs a null padding of 2 octets after strings
+  // such as the type_id in order to ensure even number of octets.
+
+  while (1)
+    {
+      nullOctet[0] = *(readPtr + offset);
+      nullOctet[1] = *(readPtr + offset + 1);
+      nullOctet[2] = *(readPtr + offset + 2);
+      nullOctet[3] = *(readPtr + offset + 3);
+
+      // Some ORBs tend to pad the IORs with double space characters,
+      // ie., 2020 in ASCII equivalent
+
+      if ((nullOctet[0] == '2') && (nullOctet[1] == '0') &&
+          (nullOctet[2] == '2') && (nullOctet[3] == '0'))
+        {
+          offset += 4;
+          continue;
+        }
+
+      if ((nullOctet[0] == '0') && (nullOctet[1] == '0'))
+        offset += 2;
+      else
+        if ((expectingStr) && (hexChar2int(nullOctet[0]) >= 8))
+          offset += 2;
+        else
+          break;
+    }
+
+  *hexCharsRead = offset;
+}
+
+int iorParser::findIfVisiIor(char *readPtr, int *hexCharsRead)
+{
+  int offset;
+  int hasVisiPreamble = 0;
+
+  *hexCharsRead = 0;
+  offset = 0;
+
+  if ((getCharacter(readPtr, &offset) == 'P') &&
+      (getCharacter(readPtr, &offset) == 'M') &&
+      (getCharacter(readPtr, &offset) == 'C'))
+    {
+      hasVisiPreamble = 1;
+      *hexCharsRead = offset;
+    }
+
+  return (hasVisiPreamble);
+}
+
+char iorParser::getCharacter (char *readPtr, int *offset)
+{
+  char octetPair[2];
+  int intEquiv;
+
+  octetPair[0] = *(readPtr + *offset);
+  octetPair[1] = *(readPtr + *offset + 1);
+
+  intEquiv = 16 * hexChar2int(octetPair[0]) + hexChar2int(octetPair[1]);
+  *offset += 2;
+
+  return ((char) intEquiv);
+}
+
+char *iorParser::getString (char *readPtr, int givenLen)
+{
+  static char parsedStr[MAX_IOR_FIELD_LEN];
+  char octetPair[2];
+  char parsedOctetPair[2];
+  char *p;
+  int intEquiv;
+  int i = 0;
+  int j = 0;
+
+  // i indexes hexChars while j indexes octet pairs
+
+  p = parsedStr;
+
+  while (i <= (givenLen - 2))
+    {
+      octetPair[0] = * (readPtr + i);
+      octetPair[1] = * (readPtr + i + 1);
+
+      intEquiv = 16 * hexChar2int (octetPair[0]) + hexChar2int (octetPair[1]);
+
+      if(intEquiv == 0 || intEquiv > 127)
+        intEquiv = '.';
+
+      sprintf (parsedOctetPair, "%c", (char) intEquiv);
+      parsedStr[j] = parsedOctetPair[0];
+      j ++;
+
+      i += 2;
+    }
+
+  parsedStr[j-1] = '\0';
+
+  return (parsedStr);
+}
+
+void iorParser::interpretIor (char *thisIor, struct IOR *thisIorInfo)
+{
+  int numCharsToSkip;
+  int validTypeId = 0;
+  int isVisiIor = 0;
+  int ulongValue;
+  int n = 0;
+
+  // Skip the prefix "IOR:"
+  int numHexCharsRead = 4;
+
+  // Type ID must be at least 4 bytes in length since type_id is prefixed
+  // by the string "IDL:"
+  int validTypeIdLen = 0;
+
+  while (!validTypeIdLen)
+    {
+      skipNullOctets((char *)(thisIor + numHexCharsRead), &numCharsToSkip, 1);
+      numHexCharsRead += numCharsToSkip;
+
+      // Read the length of the type_id field
+      ulongValue = getOctet2Field((char *)(thisIor + numHexCharsRead),
+                                  &numCharsToSkip);
+
+      if (ulongValue == 0)
+        {
+          err = -14;
+          sprintf(szErr,"type_id len seems to be 0");
+        }
+
+      numHexCharsRead += numCharsToSkip;
+
+      if (ulongValue > 4)
+        {
+          validTypeIdLen = 1;
+          thisIorInfo->typeIdLen = ulongValue;
+        }
+
+      skipNullOctets((char *)(thisIor + numHexCharsRead), &numCharsToSkip, 1);
+      numHexCharsRead += numCharsToSkip;
+
+      // Read the Type ID
+      strncpy (thisIorInfo->typeId, getString((char *)(thisIor + numHexCharsRead), 2 * thisIorInfo->typeIdLen), thisIorInfo->typeIdLen);
+
+      // Confirm that this is a valid TypeId by looking for the IDL
+      // interface. Additionally, the IDL interface could be extracted
+      // and used for other purposes.
+      getIdlInterface(thisIorInfo->typeId, &validTypeId);
+
+      if (!validTypeId)
+        {
+          validTypeIdLen = 0;
+          numHexCharsRead -= numCharsToSkip;
+        }
+    }
+
+  numHexCharsRead += 2 * thisIorInfo->typeIdLen;
+
+  n += sprintf(szInf +n,"TypeId       : %s (%d bytes)\n", thisIorInfo->typeId, thisIorInfo->typeIdLen);
+
+  skipNullOctets((char *)(thisIor + numHexCharsRead), &numCharsToSkip, 0);
+  numHexCharsRead += numCharsToSkip;
+
+  // Read the 4 octets, which should equal 1 (numTaggedProfiles = 1)
+  // for a single-component profile.
+  ulongValue = getOctet2Field((char *)(thisIor + numHexCharsRead),
+                              &numCharsToSkip);
+
+  if (ulongValue != 1)
+    {
+      err = -13;
+      sprintf(szErr,"numTaggedProfiles = %d", ulongValue);
+    }
+
+  numHexCharsRead += numCharsToSkip;
+
+  // Read the 4 octets, which should equal 0 (TAG_INTERNET_IOP = 0)
+  ulongValue = getOctet8Field((char *)(thisIor + numHexCharsRead),
+                              &numCharsToSkip);
+
+  if (ulongValue != 0)
+    {
+      err = -12;
+      sprintf(szErr,"TAG_INTERNET_IOP != 0");
+    }
+
+  numHexCharsRead += numCharsToSkip;
+
+  skipNullOctets((char *)(thisIor + numHexCharsRead), &numCharsToSkip, 0);
+  numHexCharsRead += numCharsToSkip;
+
+  // Read the 4 octets, which represent the length of the ProfileBody
+  ulongValue = getOctet2Field((char *)(thisIor + numHexCharsRead),
+                              &numCharsToSkip);
+
+  if (ulongValue == 0)
+    {
+      err = -11;
+      sprintf(szErr,"ProfileBody len equals 0");
+    }
+
+  numHexCharsRead += numCharsToSkip;
+  thisIorInfo->profileBodyLen = ulongValue;
+
+  //n += sprintf(szInf +n,"TAG_INTERNET_IOP Profile (%d bytes):\n",ulongValue);
+
+  skipNullOctets((char *)(thisIor + numHexCharsRead), &numCharsToSkip, 1);
+  numHexCharsRead += numCharsToSkip;
+
+  // Read the 4 octets, which represent the IIOP version number = 1
+  // Read the major number of the IIOP Version (should be 1)
+  ulongValue = getOctet2Field((char *)(thisIor + numHexCharsRead),&numCharsToSkip);
+
+  if (ulongValue != 1)
+    {
+      err = -10;
+      sprintf(szErr,"IIOP major version != 1");
+    }
+
+  numHexCharsRead += numCharsToSkip;
+  n += sprintf(szInf +n,"IIOP Version: %d.",ulongValue);
+
+  // Read the minor number of the IIOP Version (can be 0 or 1)
+  ulongValue = getOctet2Field((char *)(thisIor + numHexCharsRead),
+                              &numCharsToSkip);
+
+  numHexCharsRead += numCharsToSkip;
+  n += sprintf(szInf +n,"%d\n",ulongValue);
+
+  skipSpaceIfAny((char *)(thisIor + numHexCharsRead), &numCharsToSkip);
+  numHexCharsRead += numCharsToSkip;
+  skipNullOctets((char *)(thisIor + numHexCharsRead), &numCharsToSkip, 0);
+  numHexCharsRead += numCharsToSkip;
+
+  // Read the 2 octets, which represent the length of the hostname
+  ulongValue = getOctet2Field((char *)(thisIor + numHexCharsRead), &numCharsToSkip);
+
+  if (ulongValue == 0)
+    {
+      err = -9;
+      sprintf(szErr,"hostLen equals 0");
+    }
+
+  numHexCharsRead += numCharsToSkip;
+  thisIorInfo->hostLen = ulongValue;
+  skipNullOctets((char *)(thisIor + numHexCharsRead), &numCharsToSkip, 1);
+  numHexCharsRead += numCharsToSkip;
+
+  // Read the hostname and store it
+
+  strncpy (thisIorInfo->HostName, getString((char *)(thisIor + numHexCharsRead), 2 * thisIorInfo->hostLen), thisIorInfo->hostLen);
+  numHexCharsRead += 2 * thisIorInfo->hostLen;
+
+  n += sprintf(szInf +n,"HostName    : %s (%d bytes)\n", thisIorInfo->HostName, thisIorInfo->hostLen);
+
+  skipNullOctets((char *)(thisIor + numHexCharsRead), &numCharsToSkip, 0);
+  numHexCharsRead += numCharsToSkip;
+
+  // Read the port number and store it
+  ulongValue = getOctet4Field((char *)(thisIor + numHexCharsRead),
+                              &numCharsToSkip);
+
+  if (ulongValue == 0)
+    {
+      err = -8;
+      sprintf(szErr,"port number equals 0");
+    }
+
+  numHexCharsRead += numCharsToSkip;
+  thisIorInfo->portNum = ulongValue;
+
+  n += sprintf(szInf +n,"Port Number : %d\n", thisIorInfo->portNum);
+
+  skipNullOctets((char *)(thisIor + numHexCharsRead), &numCharsToSkip, 0);
+  numHexCharsRead += numCharsToSkip;
+
+  // Read the object key length
+  ulongValue = getOctet2Field((char *)(thisIor + numHexCharsRead),
+                              &numCharsToSkip);
+
+  if (ulongValue == 0)
+    {
+      err = -7;
+      sprintf(szErr,"objectKeyLen equals 0");
+    }
+
+  numHexCharsRead += numCharsToSkip;
+  thisIorInfo->objectKeyLen = ulongValue;
+
+  skipNullOctets((char *)(thisIor + numHexCharsRead), &numCharsToSkip, 1);
+  numHexCharsRead += numCharsToSkip;
+
+  // VisiBroker tends to insert the preamble "PMC" (=> Post Modern
+  // Computing), before the "real" object key actually starts. Identify
+  // if this is the case.
+  isVisiIor = findIfVisiIor((char *)(thisIor + numHexCharsRead),
+                            &numCharsToSkip);
+  if (isVisiIor)
+    {
+      numHexCharsRead += numCharsToSkip;
+      skipNullOctets((char *)(thisIor + numHexCharsRead), &numCharsToSkip, 0);
+      numHexCharsRead += numCharsToSkip;
+
+      n += sprintf(szInf +n,"ObjectKey   : PMC");
+
+      skipNullOctets((char *)(thisIor + numHexCharsRead), &numCharsToSkip, 0);
+      numHexCharsRead += numCharsToSkip;
+
+      // Read the real object key length and then the real object key
+      ulongValue = getOctet2Field((char *)(thisIor + numHexCharsRead),
+                                  &numCharsToSkip);
+
+      if (ulongValue == 0)
+        {
+          err = -6;
+          sprintf(szErr,"VisiBroker IOR - real objectKeyLen equals 0");
+        }
+
+      numHexCharsRead += numCharsToSkip;
+
+      strncpy (thisIorInfo->objectKey, getString((char *)(thisIor + numHexCharsRead), 2 * ulongValue), ulongValue);
+
+      numHexCharsRead += 2 * ulongValue;
+
+      n += sprintf(szInf +n,"%s", thisIorInfo->objectKey);
+
+      skipNullOctets((char *)(thisIor + numHexCharsRead), &numCharsToSkip, 1);
+      numHexCharsRead += numCharsToSkip;
+
+      // Read the object name length and then the object name
+      ulongValue = getOctet2Field((char *)(thisIor + numHexCharsRead),
+                                  &numCharsToSkip);
+
+      if (ulongValue == 0)
+        {
+          sprintf(szErr,"[No object name] (%d bytes)",thisIorInfo->objectKeyLen);
+        }
+
+      numHexCharsRead += numCharsToSkip;
+
+      strncpy (thisIorInfo->objectKey, getString((char *)(thisIor + numHexCharsRead), 2 * ulongValue), ulongValue);
+
+      numHexCharsRead += 2 * ulongValue;
+
+      n += sprintf(szInf +n,"object name : %s (%d bytes)\n\n", thisIorInfo->objectKey, thisIorInfo->objectKeyLen);
+    }
+
+  else
+    {
+      // Non-VisiBroker IOR - Read the object_key and store it
+
+      strncpy (thisIorInfo->objectKey, getString((char *)(thisIor + numHexCharsRead), 2 * thisIorInfo->objectKeyLen), thisIorInfo->objectKeyLen);
+
+      numHexCharsRead += 2 * thisIorInfo->objectKeyLen;
+
+      n += sprintf(szInf +n,"ObjectKey   : %s (%d bytes)\n\n", thisIorInfo->objectKey, thisIorInfo->objectKeyLen);
+    }
+}
+
+
+char *iorParser::getIdlInterface (char *typeId, int *validTypeId)
+{
+  static char idlInterface[MAX_TYPE_ID_LEN];
+  int lenInterface;
+
+  // A sample type_id for an IDL interface name "EchoTests" is
+  // IDL:EchoTests:1.0 => the trick is to isolate the parts between
+  // the two colons.
+  if ((*typeId != 'I') && (*(typeId+1) != 'D') && (*(typeId+2) != 'L'))
+    {
+      *validTypeId = 0;
+      return ((char *)typeId);
+    }
+
+  char *readStart = strchr(typeId, ':');
+
+  if (readStart == NULL)
+    readStart = strchr(typeId, '/');
+
+  if (readStart == NULL)
+    {
+      err = -4;
+      sprintf(szErr,"getIdlInterface: type_id contains no starting :\n");
+    }
+
+  char *readEnd = strrchr (typeId, ':');
+
+  if (readEnd == NULL)
+     readEnd = readStart + strlen(readStart);
+
+  if (readEnd == NULL)
+    {
+      err = -3;
+      sprintf(szErr,"getIdlInterface: type_id contains no ending:");
+    }
+
+  // Now, count the number of bytes between the two colons.
+  lenInterface = readEnd - readStart - 1;
+
+  // Copy the IDL interface part of the type_id.
+  strncpy ((char *)idlInterface, readStart+1, lenInterface);
+  idlInterface[lenInterface] = '\0';
+
+  *validTypeId = 1;
+  return (char *) idlInterface;
+}
+
+void iorParser::readIorFromFile (char *filename)
+{
+  FILE *fp = fopen (filename, "r");
+
+  // Read the real IOR from the file REAL_IOR_FILE.
+  if (fp == NULL)
+    {
+      err = -2;
+      sprintf(szErr,"Unable to open file");
+    }
+
+  fscanf (fp, "%s", stringIOR);
+  fclose (fp);
+
+  interpretIor (stringIOR, &parsedIOR);
+}
+
+long iorParser::parse(char *pszIOR)
+{
+    memset(&parsedIOR,0,sizeof(parsedIOR));
+    err   = 0;
+   *szErr = '\0';
+   *szInf = '\0';
+
+    if(*pszIOR)
+    {
+      try        { interpretIor(pszIOR,&parsedIOR); }
+      catch(...) { err = -1; strcpy(szErr,"Exception in IOR parsing"); }
+    }
+    else
+    {
+      err = -1;
+      strcpy(szErr,"IOR input is empty.");
+    }
+
+    return(0);
+}
+
+iorParser::iorParser(char *pszIOR)
+{
+    if(pszIOR)
+      parse(pszIOR);
+}
+
+iorParser::iorParser()
+{
+    err   = 0;
+   *szErr = '\0';
+   *szInf = '\0';
+
+    memset(&parsedIOR,0,sizeof(parsedIOR));
+}
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/trace.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/trace.cpp
new file mode 100644
index 00000000..a7e694ea
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/src/trace.cpp
@@ -0,0 +1,251 @@
+//---------------------------------------------------------------------------
+//
+//  file:       trace.cpp
+//
+//  purpose:    trace functionality for the CUSS interface
+//
+//  date:       12.04.2001, 12:41
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//  history:
+//  02.08.2001 ts dump characters > 127 as 2 hex-digits
+//
+//
+//---------------------------------------------------------------------------
+
+#include <iostream>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <time.h>
+#include <sys/types.h>
+#include <sys/timeb.h>
+#include <windows.h>
+
+#include "tracedef.h"
+
+#define MAX_TRACE_BUF (1024L * 32L)
+
+static int traceLevel = 0;
+
+//---------------------------------------------------------------------------
+//
+//  function:   long setLevel(long level)
+//
+//  purpose:    set new trace level and return the old one
+//
+//  date:       12.04.2001, 12:46
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long setLevel(long level)
+{
+long oldLevel = traceLevel;
+
+    if(level >= 0)
+    {
+      traceLevel = level;
+      return(oldLevel);
+    }
+    else
+      return(-1);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void trace(long lLevel,char *pszFile,long sLine,char *pszFormat, ...)
+//
+//  purpose:    trace function
+//
+//  date:       12.04.2001, 12:47
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void trace(long lLevel,char *pszFile,long sLine,char *pszFormat, ...)
+{
+long     rc = 0;
+long     ulLen;
+long     ulDump;
+long     ulTmp;
+char     *pTmp;
+char     *pArg;
+char     *pStr;
+char      szFile[256];
+
+va_list       arg_ptr;
+time_t        ltime;
+struct  tm   *today;
+struct _timeb tstruct;
+
+    if(lLevel <= traceLevel || lLevel == 255)
+    {
+
+      time(&ltime);
+      _ftime(&tstruct);
+
+      today = localtime(&ltime);
+
+      if((pTmp = (char*) malloc(MAX_TRACE_BUF)) == NULL)
+        return;
+
+      /* write traces with date and time */
+
+      memset(pTmp,0,MAX_TRACE_BUF);
+
+      ulLen = ulTmp = 0;
+
+      ulLen += sprintf(pTmp + ulLen,"%02d%02d %02d%02d:%02d.%02d ",
+                                    today->tm_mday,
+                                    today->tm_mon,
+                                    today->tm_hour,
+                                    today->tm_min,
+                                    today->tm_sec,
+                                    tstruct.millitm /10);
+
+      /* check given arguments */
+
+      if(pszFile && pszFormat)
+      {
+        strcpy(szFile,pszFile);
+
+        // cut path from file name
+
+        if((pStr = strrchr(szFile,'\\')) != NULL)
+          strcpy(szFile,pStr +1);
+
+        // cut file name extension
+
+        if((pStr = strrchr(szFile,'.')) != NULL)
+          *pStr = '\0';
+
+        ulLen += sprintf(pTmp + ulLen,"%-16s(%4d): ",szFile,sLine);
+
+        if(*pszFormat == '%' && *(pszFormat +1) == 'T')
+        {
+          // comes from mTrace.dump() -> copy only !!
+
+          va_start(arg_ptr,pszFormat);
+
+          // get pointer to first argument
+
+          pArg = (char *)va_arg(arg_ptr,char*);
+
+          // get length of dump
+
+          ulDump = (long) va_arg(arg_ptr,long);
+
+          /* copy to buffer */
+
+          strcpy(pTmp + ulLen,pArg);
+
+          ulLen += ulDump;
+
+          va_end(arg_ptr);
+        }
+        else
+        {
+          /* get pointer to first argument */
+
+          va_start(arg_ptr,pszFormat);
+
+          /* print into buffer */
+
+          ulLen += vsprintf(pTmp + ulLen,pszFormat,arg_ptr);
+
+          va_end(arg_ptr);
+        }
+
+        ulLen += sprintf(pTmp + ulLen,"\n");
+      }
+      else
+        ulLen = sprintf(pTmp,"<< INVALID TRACE >>");
+
+      *(pTmp + ulLen) = '\0';
+
+      if(ulTmp)
+      {
+        OutputDebugString((char *)(pTmp + ulTmp));
+      }
+      else
+      {
+        OutputDebugString((char *)pTmp);
+      }
+
+      free(pTmp);
+    }
+
+    return;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void dump(long lLevel,char *pszFile,long sLine,char *pData,long usLen)
+//
+//  purpose:    dump function (using trace function)
+//
+//  date:       12.04.2001, 12:47
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void dump(long lLevel,char *pszFile,long sLine,char *pData,long usLen)
+{
+long   i,j;
+long   rc;
+char  *pTmp;
+long   ulSize;
+
+    if(lLevel <= traceLevel || lLevel == 255)
+    {
+      ulSize = ((usLen >> 4) +1) * 80;
+
+      if(!pData || !usLen || ulSize > MAX_TRACE_BUF -128)
+        return;
+
+      if((pTmp = (char*) malloc(ulSize)) == NULL) // XXX
+        return;
+
+      rc = sprintf(pTmp,"%c",'\n');
+
+      for(i = 0; i < usLen; i += 16)
+      {
+        rc += sprintf(pTmp +rc,"[%04x,%04d] ",i,i);
+
+        for(j = 0; j < 16 && (i+j) < usLen; j++)
+        {
+          if(j == 8)
+            rc += sprintf(pTmp + rc,"- %02x ",(unsigned char)(pData)[i+j]);
+          else
+            rc += sprintf(pTmp + rc,"%02x ",(unsigned char)(pData[i+j]));
+        }
+
+        while(j < 16)
+        {
+          if(j == 8)
+            rc += sprintf(pTmp + rc,"     ");
+          else
+            rc += sprintf(pTmp + rc,"   ");
+
+          j++;
+        }
+
+        for(j = 0; j < 16 && (i+j) < usLen; j++)
+          rc += sprintf(pTmp + rc,"%c",(pData[i+j] >= ' ') ? pData[i+j]: '.');
+
+        rc += sprintf(pTmp + rc,"\n");
+      }
+
+      trace(lLevel,pszFile,sLine,"%T",pTmp,rc);
+
+      free(pTmp);
+    }
+
+    return;
+}
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/static/makefile.mak b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/static/makefile.mak
new file mode 100644
index 00000000..6603a3d3
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/static/makefile.mak
@@ -0,0 +1,34 @@
+######################################################################
+#
+# /vob/SelfServiceCommon/Massai/cpp/MassaiCorba/makefile.mak
+#
+######################################################################
+
+!include $(BUILDROOT)\Build\cpp\makefile.common.mak
+
+MY_CFLAGS = \
+    -Gi -GR -G5 -Gy \
+    -DTAO_AS_STATIC_LIBS -DACE_AS_STATIC_LIBS \
+    -I$(P_INC) \
+    $(INC_ACETAO) \
+    $(INC_INTERFACES)
+
+MY_RCFLAGS = \
+    -I$(P_INC)
+
+
+MY_LIB1 = $(LIB_DST_MCORBAS)
+
+MY_LIB1_OBJS = \
+    $(_OBJ)\corbacfg.obj \
+    $(_OBJ)\corbaclnt.obj \
+    $(_OBJ)\corbaorb.obj \
+    $(_OBJ)\corbaorbcfg.obj \
+    $(_OBJ)\corbaorbEx.obj \
+    $(_OBJ)\corbasrvr.obj \
+    $(_OBJ)\iorparser.obj \
+    $(_OBJ)\Realtime.obj \
+    $(_OBJ)\trace.obj \
+    $(_OBJ)\corbapoll.obj
+
+!include $(BUILDROOT)\Build\cpp\makefile.rules.mak
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/idl/makefile.mak b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/idl/makefile.mak
new file mode 100644
index 00000000..1cf4143a
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/idl/makefile.mak
@@ -0,0 +1,12 @@
+######################################################################
+#
+# /vob/SelfServiceCommon/Massai/idl/Massai/makefile.mak
+#
+######################################################################
+
+!include $(BUILDROOT)\Build\cpp\makefile.common.mak
+
+MY_GEN_CPPS = \
+    $(_GEN)\test.cpp 
+    
+!include $(BUILDROOT)\Build\cpp\makefile.rules.mak
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/idl/test.idl b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/idl/test.idl
new file mode 100644
index 00000000..5c7b93d4
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/idl/test.idl
@@ -0,0 +1,29 @@
+module CorbaTest
+{
+    struct mString
+    {
+      string in1;
+      string in2;
+    };
+
+    interface callback
+    {
+      void callClient();
+    };
+
+    interface test
+    {
+      long doit();
+      long say(in string ms);
+      long setListener(in callback li);
+      long rmvListener(in callback li);
+    };
+
+    interface hello
+    {
+        long say(in mString ms);
+
+        long setListener(in callback li);
+        long rmvListener(in callback li);
+    };
+};
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/makefile.mak b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/makefile.mak
new file mode 100644
index 00000000..3925b1ba
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/makefile.mak
@@ -0,0 +1,134 @@
+######################################################################
+#
+# /vob/SelfServiceCommon/Massai/cpp/StatisticsService/makefile.mak
+#
+######################################################################
+
+!include $(BUILDROOT)\Build\cpp\makefile.common.mak
+
+MY_CFLAGS = \
+    -Gi -GR \
+    -DCHECKED_NARROW  \
+    $(INC_INTERFACES) \
+    $(INC_ACETAO)
+
+STDUSERLIBS = \
+    $(LIB_MASSAI) \
+    $(LIB_MCORBA) \
+    $(LIB_MCFGCLNT) \
+    $(LIB_TRACE)
+
+STDLINKLIBS = \
+    $(SYS_ACETAO)
+
+######################################################################
+
+MY_BIN1 = \
+    $(_BIN)\tclt.exe
+
+MY_BIN1_OBJS = \
+    $(_OBJ)\tclt.obj \
+    $(_OBJ)\test_skel.obj \
+    $(_OBJ)\test.obj
+    
+MY_BIN1_USER_LIBS = \
+    $(STDUSERLIBS)
+
+MY_BIN1_LINKLIBS = \
+    $(STDLINKLIBS)
+
+######################################################################
+
+MY_BIN2 = \
+    $(_BIN)\tsrv.exe
+
+MY_BIN2_OBJS = \
+    $(_OBJ)\tsrv.obj \
+    $(_OBJ)\test_skel.obj \
+    $(_OBJ)\test.obj
+
+MY_BIN2_USER_LIBS = \
+    $(STDUSERLIBS)
+
+MY_BIN2_LINKLIBS = \
+    $(STDLINKLIBS)
+
+######################################################################
+
+MY_BIN3 = \
+    $(_BIN)\testclnt.exe
+
+MY_BIN3_OBJS = \
+    $(_OBJ)\testclnt.obj \
+    $(_OBJ)\test_skel.obj \
+    $(_OBJ)\test.obj
+    
+MY_BIN3_USER_LIBS = \
+    $(STDUSERLIBS)
+
+MY_BIN3_LINKLIBS = \
+    $(STDLINKLIBS)
+
+######################################################################
+
+MY_BIN4 = \
+    $(_BIN)\testsrvr.exe
+
+MY_BIN4_OBJS = \
+    $(_OBJ)\testsrvr.obj \
+    $(_OBJ)\test_skel.obj \
+    $(_OBJ)\test.obj
+
+MY_BIN4_USER_LIBS = \
+    $(STDUSERLIBS)
+
+MY_BIN4_LINKLIBS = \
+    $(STDLINKLIBS)
+
+######################################################################
+
+MY_BIN5 = \
+    $(_BIN)\stclt.exe
+
+MY_BIN5_OBJS = \
+    $(_OBJ)\stclt.obj \
+    $(_OBJ)\test_skel.obj \
+    $(_OBJ)\test.obj
+    
+MY_BIN5_LINKLIBS = \
+    $(SYS_ACETAO) 
+
+######################################################################
+
+MY_BIN6 = \
+    $(_BIN)\cbclt.exe
+
+MY_BIN6_OBJS = \
+    $(_OBJ)\cbclt.obj \
+    $(_OBJ)\test_skel.obj \
+    $(_OBJ)\test.obj
+
+MY_BIN6_USER_LIBS = \
+    $(STDUSERLIBS)
+
+MY_BIN6_LINKLIBS = \
+    $(STDLINKLIBS)
+
+######################################################################
+
+MY_BIN7 = \
+    $(_BIN)\cbsrv.exe
+
+MY_BIN7_OBJS = \
+    $(_OBJ)\cbsrv.obj \
+    $(_OBJ)\test_skel.obj \
+    $(_OBJ)\test.obj
+
+MY_BIN7_USER_LIBS = \
+    $(STDUSERLIBS)
+
+MY_BIN7_LINKLIBS = \
+    $(STDLINKLIBS)
+    
+######################################################################
+!include $(BUILDROOT)\Build\cpp\makefile.rules.mak
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/cbclt.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/cbclt.cpp
new file mode 100644
index 00000000..2781dc9d
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/cbclt.cpp
@@ -0,0 +1,105 @@
+//---------------------------------------------------------------------------
+//
+//  file:       cbclt.cpp
+//
+//  purpose:
+//
+//  date:       25.07.2007
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+#include "massaiCorba/corbaclnt.h"
+#include "test.h"
+#include "test_skel.h"
+
+#include <iostream>
+#include <windows.h>
+
+using namespace CorbaTest;
+
+class TestServant : public POA_CorbaTest::callback
+{
+  public:
+    void callClient()
+    {
+       std::cout << ".";
+    }
+};
+
+
+int main(int argc, char** argv)
+{
+  char* host;
+  if(argc > 1)
+    host= argv[1];
+  else
+    host= "127.0.0.1";
+  for(;;)
+  {
+    try
+    {
+      std::cout << std::endl << "connect..." << std::endl;
+      TestServant myCBServant;
+      callback_var listener= myCBServant._this();
+      corbaCallbackClient<hello> clt(host, 30000, "TestServant");
+      hello* proxy= clt.proxy();
+      if(proxy != 0)
+      {
+        std::cout << "connect done." << std::endl;
+        try
+        {
+          proxy->setListener(listener);
+        }
+        catch(const CORBA::Exception& ex)
+        {
+          std::cout << std::endl << "setListener: " << ex._message() << std::endl;
+        }
+        catch(...)
+        {
+          std::cout << std::endl << "setListener: unknown exception" << std::endl;
+        }
+        try
+        {
+          CorbaTest::mString x;
+          x.in1 = CORBA::string_dup("in1");
+          x.in2 = CORBA::string_dup("in2");
+          proxy->say(x);
+        }
+        catch(const CORBA::Exception& ex)
+        {
+          std::cout << std::endl << "say: " << ex._message() << std::endl;
+        }
+        catch(...)
+        {
+          std::cout << std::endl << "say: unknown exception" << std::endl;
+        }
+        try
+        {
+          proxy->rmvListener(listener);
+        }
+        catch(const CORBA::Exception& ex)
+        {
+          std::cout << std::endl << "rmvListener: " << ex._message() << std::endl;
+        }
+        catch(...)
+        {
+          std::cout << std::endl << "rmvListener: unknown exception" << std::endl;
+        }
+        std::cout << ",";
+        //Sleep(1000);
+      }
+    }
+    catch(const CORBA::Exception& ex)
+    {
+      std::cout << std::endl << "connect: " << ex._message() << std::endl;
+    }
+    catch(...)
+    {
+      std::cout << std::endl << "connect: unknown exception" << std::endl;
+    }
+    //Sleep(1000);
+  }
+  return 0;
+}
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/cbsrv.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/cbsrv.cpp
new file mode 100644
index 00000000..3d530281
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/cbsrv.cpp
@@ -0,0 +1,70 @@
+//---------------------------------------------------------------------------
+//
+//  file:       cbsrv.cpp
+//
+//  purpose:
+//
+//  date:       25.07.2007
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+#include "massaiCorba/corbasrvr.h"
+#include "test_skel.h"
+
+#include <iostream>
+#include <windows.h>
+
+using namespace CorbaTest;
+
+class testServant : public POA_CorbaTest::hello
+{
+  public:
+    CORBA::Long  say(const struct CorbaTest::mString& x)
+    {
+      if(!CORBA::is_nil(listener))
+      {
+        listener->callClient();
+      }
+      return 0;
+    }
+    CORBA::Long  setListener(callback_ptr li)
+    {
+      listener= li->_duplicate(li);
+      return 0;
+    }
+    CORBA::Long  rmvListener(callback_ptr li)
+    {
+      CORBA::release(listener);
+      listener= 0;
+      return 0;
+    }
+  private:
+    CorbaTest::callback_ptr listener;
+
+};
+
+int main(int argc, char** argv)
+{
+  try
+  {
+    std::cout << std::endl << "create servant..." << std::endl;
+    testServant srvnt;
+    corbaServantEx<testServant> corbaSrvnt(10, srvnt, "TestServant", 30000);
+    //std::cout << "create servant done." << corbaSrvnt.ior("TestServant") << std::endl;
+    for(;;)
+    {
+      Sleep(20000);
+    }
+  }
+  catch(const CORBA::Exception& ex)
+  {
+    std::cout << std::endl << ex._message() << std::endl;
+  }
+  catch(...)
+  {
+    std::cout << std::endl << "unknown exception" << std::endl;
+  }
+  return 0;
+}
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/stclt.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/stclt.cpp
new file mode 100644
index 00000000..4e8097fb
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/stclt.cpp
@@ -0,0 +1,25 @@
+#include "test.h"
+#include <iostream>
+#include <windows.h>
+
+int main (int argc, char *argv[])
+{
+  try
+  {
+    CORBA::ORB_var orb = CORBA::ORB_init (argc, argv);
+    for(;;)
+    {
+      CORBA::Object_var tmp = orb->string_to_object("corbaloc:iiop:isengart:30000/TestServant");
+      CorbaTest::test_var hello = CorbaTest::test::_narrow(tmp.in ());
+      std::cout << ",";
+      // hello->doit ();
+    }
+    orb->destroy ();
+  }
+  catch (const CORBA::Exception& ex)
+  {
+    ex._tao_print_exception ("Exception caught:");
+    return 1;
+  }
+  return 0;
+}
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/tclt.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/tclt.cpp
new file mode 100644
index 00000000..16b153a2
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/tclt.cpp
@@ -0,0 +1,108 @@
+//---------------------------------------------------------------------------
+//
+//  file:       tclt.cpp
+//
+//  purpose:
+//
+//  date:       12.04.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+#include "massaiCorba/corbaclnt.h"
+#include "test.h"
+#include "test_skel.h"
+
+#include <iostream>
+#include <windows.h>
+
+using namespace CorbaTest;
+
+long setLevel(long level);
+
+
+class testServant : public POA_CorbaTest::callback
+{
+public:
+
+    int j;
+    void callClient()
+    {
+       j++;
+       if(j%32 == 0)
+         std::cout << ":";
+    }
+};
+
+int main(int argc, char** argv)
+{
+  setLevel(9);
+  char* host;
+  if(argc > 1)
+    host= argv[1];
+  else
+    host= "127.0.0.1";
+  //corbaClient<test> cltd(host, 30000, "TestServant");
+  //test* proxyd= cltd.proxy();
+
+  for(;;)
+  {
+    int i;
+    try
+    {
+      std::cout << std::endl << "connect..." << std::endl;
+      corbaCallbackClient<test> clt(host, 30000, "TestServant");
+      //corbaClient<test> clt(host, 30000, "TestServant");
+      test* proxy= clt.proxy();
+      testServant  servant; // callback servant
+      if(proxy != 0)
+      {
+        std::cout << "connect done." << std::endl;
+        try
+        {
+          callback_var myservant= servant._this();
+          proxy->setListener(myservant);
+          //for(;;)
+          {
+            //proxy->setListener(myservant);
+            //proxy->setListener(servant._this()); // memory leak
+            CORBA::String_var s = CORBA::string_dup("Hello");
+            proxy->say(s);
+//            CORBA::PolicyList_var inconsistent_policies;
+//            proxy->_validate_connection(inconsistent_policies);
+/*
+      CORBA::PolicyList_out inconsistent_policies
+      ACE_ENV_ARG_DECL_WITH_DEFAULTS);
+*/
+
+            //proxy->say(s);
+            i++;
+            if(i%32 ==  0)
+              std::cout << ",";
+            Sleep(1);
+          }
+          //proxy->rmvListener(myservant);
+        }
+        catch(const CORBA::Exception& ex)
+        {
+          std::cout << std::endl << "doit: " << ex._message() << std::endl;
+        }
+        catch(...)
+        {
+          std::cout << std::endl << "doit: unknown exception" << std::endl;
+        }
+      }
+    }
+    catch(const CORBA::Exception& ex)
+    {
+      std::cout << std::endl << "connect: " << ex._message() << std::endl;
+    }
+    catch(...)
+    {
+      std::cout << std::endl << "connect: unknown exception" << std::endl;
+    }
+    Sleep(1);
+  }
+  return 0;
+}
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/testclnt.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/testclnt.cpp
new file mode 100644
index 00000000..b3d27208
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/testclnt.cpp
@@ -0,0 +1,190 @@
+//---------------------------------------------------------------------------
+//
+//  file:       testclnt.cpp
+//
+//  purpose:
+//
+//  date:       21.11.2001, 11:35
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include <conio.h>
+
+#include "massaiCorba/corbasrvr.h"
+#include "massaiCorba/corbaclnt.h"
+#include "massaiCorba/corbacfg.h"
+
+#include "test.h"
+
+#if !defined(_MICO_)
+#include "test_skel.h"
+#endif
+
+
+
+#define MCORBA
+#define TEST_HELLO
+#define TEST_DOIT
+
+using namespace CorbaTest;
+
+class testServant : public POA_CorbaTest::callback
+{
+public:
+
+    void callClient()
+    {
+       printf("server calls client, tid = 0x%0x\n",GetCurrentThreadId());
+    }
+};
+
+int main(int argc, char** argv)
+{
+#ifdef MCORBA
+
+char  *host   = "127.0.0.1";
+char  *sName1 = "corbaTest1";
+char  *sName2 = "corbaTest2";
+long   port1  = 30001;
+long   port2  = 30002;
+
+hello *p1;
+test  *p2;
+
+testServant  servant; // callback servant
+callback_var li;      // listener to pass to server (TAO smart pointer)
+
+CorbaTest::mString x;
+
+    printf("connecting to: corbaloc:iiop:%s:%d/%s\n\n",host,port1,sName1);
+    printf("connecting to: corbaloc:iiop:%s:%d/%s\n\n",host,port2,sName2);
+
+    // get the proxies
+
+    while(!_kbhit())
+    {
+      // create callback- & normal client
+
+#ifdef TEST_HELLO
+      corbaCallbackClient <hello> clnt1(host,port1,sName1);
+
+      if((p1 = clnt1.proxy()) != NULL)
+      {
+        try
+        {
+          // prepare the string to pass
+
+          CORBA::String_var s1 = CORBA::string_dup("first what ??");
+          CORBA::String_var s2 = CORBA::string_dup("second what ??");
+
+          // x.in1 = s1;
+          // x.in2 = s2;
+
+          x.in1 = CORBA::string_dup("first what ??");
+          x.in2 = CORBA::string_dup("second what ??");
+
+          // set the listener to pass on to server
+          li = servant._this();
+
+          // call server with listener
+          p1->setListener(li);
+
+          // call server with string var
+          p1->say(x);
+
+          // call server (again) with listener
+          p1->rmvListener(li);
+
+        }
+        catch(const CORBA::Exception& cex)
+        {
+            std::cerr << cex._message() << std::endl;
+        }
+        catch(exception& ex)
+        {
+            std::cerr << ex.what() << std::endl;
+        }
+        catch(...)
+        {
+            std::cerr << "other exception" << std::endl;
+        }
+      }
+#endif // TEST_HELLO
+
+#ifdef TEST_DOIT
+      corbaClient <test> clnt2(host,port2,sName2);
+
+#if defined (_TAO_1_4_)
+      long lTO = getConfigInvocationTimeout( "TestClient2");
+      SetInvocationTimeout( clnt2.orb(), lTO, true);
+#endif // _TAO_1_4_
+
+      if((p2 = clnt2.proxy()) != NULL)
+      {
+        try
+        {
+          // call second servant on the server
+
+          std::cout << "block servant now for Client Timeout test..." << std::endl;
+          Sleep( 2000);
+          p2->doit();
+        }
+        catch( CORBA::TIMEOUT $timeout)
+        {
+            std::cerr << "timeout occured" << std::endl;
+        }
+        catch(...) {}
+      }
+
+#endif // TEST_DOIT
+
+    }
+
+#else // MCORBA
+
+    CORBA::ORB_var orb;
+
+    try
+    {
+      orb = CORBA::ORB_init(argc, argv);
+
+
+      while(!_kbhit())
+      {
+        CORBA::Object_var obj = orb->string_to_object("corbaloc:iiop:mazze:30002/corbaTest2");
+
+        obj->_is_a ("IDL:CorbaTest/test:1.0");
+
+        //test_var  ptest = test::_unchecked_narrow(obj);
+
+        test_var  ptest = test::_narrow(obj);
+
+        //ptest->doit();
+
+        //CORBA::release(obj);
+        //CORBA::release(ptest);
+      }
+    }
+    catch(const CORBA::Exception& ex)
+    {
+        std::cerr << ex._message() << std::endl;
+    }
+
+    if(!CORBA::is_nil(orb))
+    {
+      try
+      {
+        orb->destroy();
+      }
+      catch(const CORBA::Exception& ex)
+      {
+        std::cerr << ex._message() << std::endl;
+      }
+    }
+
+#endif // MCORBA
+
+    return 0;
+}
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/testsrvr.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/testsrvr.cpp
new file mode 100644
index 00000000..359d7d89
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/testsrvr.cpp
@@ -0,0 +1,318 @@
+//---------------------------------------------------------------------------
+//
+//  file:       testsvr.cpp
+//
+//  purpose:
+//
+//  date:       21.11.2001, 11:35
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include <iostream>
+#include <list>
+
+#include <stdio.h>
+#include <conio.h>
+
+#include "massaiCorba/corbasrvr.h"
+#include "massaiCorba/corbacfg.h"
+
+#include "test.h"
+
+#if !defined(_MICO_)
+#include "test_skel.h"
+#endif
+
+#define MCORBA
+
+
+#define SERVANTNAME  "corbaTest"
+#define SERVANTNAME1 "corbaTest1"
+#define SERVANTNAME2 "corbaTest2"
+
+using namespace CorbaTest;
+
+long i = 0;
+
+class testServant1 : public POA_CorbaTest::hello
+{
+private:
+    CorbaTest::callback_ptr p_li;
+
+public:
+    CorbaTest::callback_ptr getListener()
+    {
+        return p_li;
+    }
+
+
+    CORBA::Long setListener(CorbaTest::callback_ptr li)
+    {
+      if(li)
+      {
+        printf("tid = 0x%0x, client sets listener\n",GetCurrentThreadId());
+        p_li = li->_duplicate(li);
+
+        try
+        {
+            p_li->callClient();
+        }
+        catch( CORBA::TIMEOUT $timeout)
+        {
+            printf( "timeout occured\n");
+        }
+        catch(const CORBA::Exception& cex)
+        {
+            printf( "%s\n", cex._message());
+        }
+        catch(exception& ex)
+        {
+            printf( "%s\n", ex.what());
+        }
+        catch(...)
+        {
+            printf( "other exception\n");
+        }
+      }
+
+      return(0);
+    }
+
+    CORBA::Long rmvListener(CorbaTest::callback_ptr li)
+    {
+      if(li)
+      {
+        printf("tid = 0x%0x, client removes listener\n",GetCurrentThreadId());
+
+        p_li->callClient();
+      }
+
+      return(0);
+    }
+
+    CORBA::Long say(const struct CorbaTest::mString& x)
+    {
+      printf("tid = 0x%0x, client says: %s, %s, %d\n",GetCurrentThreadId(),x.in1,x.in2,++i);
+
+again:
+        try
+        {
+            printf( "block clnt now for Listener Timeout test...\n");
+            Sleep( 2000);
+            printf( "go\n");
+
+            p_li->callClient();
+        }
+        catch( CORBA::TIMEOUT $timeout)
+        {
+            printf( "timeout occured\n");
+            Sleep( 300);
+            goto again;
+        }
+        catch(const CORBA::Exception& cex)
+        {
+            printf( "%s\n", cex._message());
+        }
+        catch(exception& ex)
+        {
+            printf( "%s\n", ex.what());
+        }
+        catch(...)
+        {
+            printf( "other exception\n");
+        }
+      return(0);
+    }
+};
+
+/*
+class testServant2 : public POA_CorbaTest::Test
+{
+public:
+
+    CORBA::Long doit()
+    {
+      printf("tid = 0x%0x, client called doit()\n",GetCurrentThreadId());
+
+      return(0);
+    }
+};
+*/
+
+int main(int argc, char** argv)
+{
+#ifdef MCORBA
+
+char szTmp[256];
+
+/*
+    p = CORBA::string_dup("");
+
+    ::gethostname(szTmp,sizeof(szTmp));
+
+    printf("hostname = %s\n", szTmp);
+
+    while(!_kbhit());
+*/
+
+long lThreads;
+
+long port1 = 30001;
+long port2 = 30002;
+
+
+    {
+      testServant1 srvntClass1;
+
+      printf("servant = [corbaloc:iiop:127.0.0.1:%d/%s]\n",port1,SERVANTNAME1);
+
+      lThreads = 50;
+
+      corbaServantEx <testServant1> srvnt1(lThreads,srvntClass1,SERVANTNAME1,port1);
+#if defined (_TAO_1_4_)
+
+      long lTO = getConfigInvocationTimeout( "TestServant1");
+      SetInvocationTimeout( srvnt1.orb(), lTO, false);
+#endif // _TAO_1_4_
+
+      printf("ior = \n%s\n\n",srvnt1.ior());
+
+      //testServant2 srvntClass2;
+
+      // printf("servant = [corbaloc:iiop:127.0.0.1:%d/%s]\n",port2,SERVANTNAME2);
+
+      //corbaServant <testServant2> srvnt2(srvntClass2,SERVANTNAME2,port2);
+#if defined (_TAO_1_4_)
+      //lTO = getConfigInvocationTimeout( "TestServant2");
+      //SetInvocationTimeout( srvnt2.orb(), lTO, true);
+#endif // _TAO_1_4_
+
+
+      //printf("ior = \n%s\n\n",srvnt2.ior());
+
+      while(getchar() != 'q')
+      {
+        Sleep(10);
+      }
+    }
+
+    printf("DONE, please press any key\n");
+
+    gets(szTmp);
+
+#else // MCORBA
+
+int    _argc;
+char  *_argv[10];
+
+char   szArgs1[256];
+char   szArgs2[256];
+
+CORBA::ORB_var                  orb;
+CORBA::Object_var               poaObj;
+CORBA::PolicyList               policies;
+
+PortableServer::POA_var         rootPoa;
+PortableServer::POAManager_var  poaManager;
+PortableServer::ObjectId_var    objID;
+PortableServer::POA_var         poa;
+
+    _argc    = 1;
+    _argv[0] = "exefile";
+
+    sprintf(szArgs1,"-ORBEndpoint");
+    sprintf(szArgs2,"iiop://localhost:30000"); // bind TAO-ORB to this port
+
+    _argc    = 3;
+
+    _argv[1] = szArgs1;
+    _argv[2] = szArgs2;
+
+    char szPoaName[512];
+
+    orb = CORBA::ORB_init(_argc, _argv);
+
+    //
+    // Resolve Root POA
+    //
+
+    poaObj = orb -> resolve_initial_references("RootPOA");
+    rootPoa = PortableServer::POA::_narrow(poaObj);
+
+    //
+    // Get a reference to the POA manager
+    //
+
+    poaManager = rootPoa->the_POAManager();
+
+    // create new POA
+
+    policies.length(3);
+
+    policies[0]= rootPoa->create_lifespan_policy(PortableServer::PERSISTENT);
+    policies[1]= rootPoa->create_id_assignment_policy(PortableServer::USER_ID);
+    policies[2]= rootPoa->create_implicit_activation_policy(PortableServer::NO_IMPLICIT_ACTIVATION);
+
+    sprintf(szPoaName,"POA_%s",SERVANTNAME);
+
+    poa = rootPoa->create_POA(szPoaName,poaManager,policies);
+
+    //
+    // Create implementation object
+    //
+
+    testServant* helloImpl = new testServant();
+
+    PortableServer::ServantBase_var servant = helloImpl;
+
+    hello_var phello = helloImpl->_this();
+
+    //
+    //  Activate the NAMED servant
+    //
+
+    objID = PortableServer::string_to_ObjectId(SERVANTNAME);
+
+    poa->activate_object_with_id(objID,helloImpl);
+
+    // Turn your object reference into an IOR string
+
+    CORBA::String_var ior = orb->object_to_string(helloImpl->_this());
+
+    // Get a reference to the IOR Table
+
+    CORBA::Object_var tableObj = orb->resolve_initial_references("IORTable");
+
+    IORTable::Table_var table = IORTable::Table::_narrow(tableObj.in());
+
+    // Bind your stringified IOR in the IOR Table
+
+    table->bind(SERVANTNAME,ior.in());
+
+    //
+    // Run implementation
+    //
+
+    poaManager->activate();
+    orb->run();
+
+    if(!CORBA::is_nil(orb))
+    {
+      try
+      {
+        orb->destroy();
+      }
+      catch(const CORBA::Exception& ex)
+      {
+        cout << ex._message() << endl;
+
+        printf("%s",ex._message());
+      }
+    }
+
+#endif // MCORBA
+
+    return 0;
+}
diff --git a/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/tsrv.cpp b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/tsrv.cpp
new file mode 100644
index 00000000..7b4aa934
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/MassaiCorba_VC6/test/src/tsrv.cpp
@@ -0,0 +1,118 @@
+//---------------------------------------------------------------------------
+//
+//  file:       tsrv.cpp
+//
+//  purpose:
+//
+//  date:       14.04.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+#include "massaiCorba/corbasrvr.h"
+#include "test_skel.h"
+#include "massaiCorba/corbaclnt.h"
+
+#include <iostream>
+#include <windows.h>
+
+using namespace CorbaTest;
+
+//CorbaTest::callback_ptr p_li;  // memory leak
+CorbaTest::callback_var p_li;
+class testServant : public POA_CorbaTest::test
+{
+  public:
+    int count_doit;
+    int count_say;
+    testServant() : clnt(0)
+    {}
+    CORBA::Long doit()
+    {
+      count_doit++;
+      if(count_doit%32 == 0)
+        std::cout << ".";
+      return(0);
+    }
+    CORBA::Long say(const char* s)
+    {
+      count_say++;
+      if(count_say%32 == 0)
+        std::cout << ",";
+      if(clnt && clnt->proxy())
+      {
+        clnt->proxy()->callClient();
+        clnt->proxy()->callClient();
+        std::cout << "#";
+      }
+/*
+      if(p_li)
+      {
+        p_li->callClient();
+        p_li->callClient();
+        std::cout << "#";
+      }
+*/
+      return(0);
+    }
+    CORBA::Long setListener(CorbaTest::callback_ptr li)
+    {
+      if(li)
+      {
+//        p_li = li->_duplicate(li);
+        if(clnt)
+        {
+          delete clnt;
+          clnt= 0;
+        }
+        clnt= new corbaClient<CorbaTest::callback>(li);
+      }
+      return(0);
+    }
+    CORBA::Long rmvListener(CorbaTest::callback_ptr li)
+    {
+//      p_li= 0;
+      if(clnt)
+      {
+        delete clnt;
+        clnt= 0;
+      }
+      return(0);
+    }
+
+  private:
+    corbaClient<CorbaTest::callback>* clnt;
+};
+
+int main(int argc, char** argv)
+{
+  try
+  {
+    std::cout << std::endl << "create servant..." << std::endl;
+    testServant srvnt;
+    corbaServantEx<testServant> corbaSrvnt(10, srvnt, "TestServant", 30000);
+    //std::cout << "create servant done." << corbaSrvnt.ior("TestServant") << std::endl;
+    int i;
+    for(;;)
+    {
+      Sleep(100);
+      if(p_li)
+      {
+        p_li->callClient();
+        i++;
+        if(i%32 == 0)
+          std::cout << ":";
+      }
+    }
+  }
+  catch(const CORBA::Exception& ex)
+  {
+    std::cout << std::endl << ex._message() << std::endl;
+  }
+  catch(...)
+  {
+    std::cout << std::endl << "unknown exception" << std::endl;
+  }
+  return 0;
+}
-- 
2.41.0.windows.1

