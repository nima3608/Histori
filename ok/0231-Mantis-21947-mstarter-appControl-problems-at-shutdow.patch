From c75b6827f259b7322d13a64d22bedbeb7ab48c11 Mon Sep 17 00:00:00 2001
From: tstegema <tstegema@90b65887-3827-0410-9a23-83215b262276>
Date: Tue, 3 Jan 2012 15:39:34 +0000
Subject: [PATCH 0231/1077] Mantis 21947: mstarter, appControl problems at
 shutdown

git-svn-id: svn://localhost/SelfServiceCommon/trunk@281 90b65887-3827-0410-9a23-83215b262276
---
 .../Interfaces/inc/Tools/ResetTime.h          |   52 +
 .../Interfaces/inc/Tools/TraceCallback.h      |  113 ++
 .../Interfaces/inc/Tools/TraceClient.h        |   79 -
 .../Interfaces/inc/Tools/TraceDelegate.h      |   76 +-
 .../Interfaces/inc/Tools/TraceFormatCB.h      |   62 +
 .../Interfaces/inc/Tools/TraceHandle.h        |   78 -
 .../Interfaces/inc/Tools/TraceInterface.h     |   74 -
 .../Interfaces/inc/Tools/TraceLocal.h         |  162 +-
 .../inc/Tools/TraceLocationDelegate.h         |  133 --
 .../Interfaces/inc/Tools/TraceSync.h          |   68 +-
 .../Interfaces/inc/Tools/TraceSystem.h        |   34 +
 .../Interfaces/inc/Tools/localtrace.h         |    5 -
 .../Interfaces/inc/systools/mEventSem.hpp     |   50 +-
 .../Interfaces/inc/systools/mMutexCS.h        |    3 +-
 .../Interfaces/inc/systools/mSysProcess.hpp   |  131 +-
 .../Interfaces/inc/systools/mSysProcessList.h |  133 ++
 .../inc/systools/mSysProcessTerminate.h       |   34 +
 .../Interfaces/inc/systools/mSysSynchronize.h |   95 ++
 .../Interfaces/inc/systools/mSysTime.h        |   39 +
 .../Interfaces/inc/systools/mSysWait.h        |   27 +
 .../Interfaces/inc/systools/mSysWindow.h      |   98 ++
 .../cpp/BillingService/inc/BillingS_def.h     |    8 +-
 .../Massai/cpp/BillingService/src/main.cpp    |   97 +-
 .../cpp/Controller/inc/control_common.h       |   24 +
 .../Massai/cpp/Controller/inc/mcontrol_def.h  |   12 +-
 .../Massai/cpp/Controller/inc/mstarter_args.h |   36 +
 .../cpp/Controller/inc/mstarter_config.h      |   65 +
 .../Massai/cpp/Controller/inc/mstarter_def.h  |   40 +-
 .../cpp/Controller/inc/mstarter_notify.h      |   40 +
 .../Massai/cpp/Controller/makefile.mak        |   46 +-
 .../Massai/cpp/Controller/src/mstarter.cpp    |   93 ++
 .../cpp/Controller/src/mstarter_args.cpp      |   70 +
 .../cpp/Controller/src/mstarter_config.cpp    |  511 ++++++
 .../cpp/Controller/src/mstarter_notify.cpp    |   98 ++
 .../Massai/cpp/Controller/src/serverwin.cpp   |   23 +
 .../Massai/cpp/Graphic/makefile.mak           |   10 +-
 .../cpp/MailService/inc/MailService_def.h     |   12 +-
 .../Massai/cpp/MailService/src/main.cpp       |  143 +-
 .../StatisticsService/inc/Statistics_def.h    |   10 +-
 .../Massai/cpp/StatisticsService/src/main.cpp |   89 +-
 .../Massai/cpp/Systools/inc/mSysErrorW32.h    |   24 +
 .../Systools/inc/mSysProcessIOCountersW32.h   |   44 +
 .../Massai/cpp/Systools/inc/mSysProcessW32.h  |   28 +
 .../cpp/Systools/inc/mSysSynchronizeW32.h     |   33 +
 .../Massai/cpp/Systools/inc/mSysTimeW32.h     |   21 +
 .../Massai/cpp/Systools/makefile.mak          |   14 +-
 .../cpp/Systools/src/TestSysProcess.cpp       |   11 +-
 .../Massai/cpp/Systools/src/mEventSemW32.cpp  |  178 +-
 .../Massai/cpp/Systools/src/mSysErrorW32.cpp  |   70 +
 .../cpp/Systools/src/mSysProcessListW32.cpp   | 1159 +++++++++++++
 .../Systools/src/mSysProcessTerminateW32.cpp  |  230 +++
 .../cpp/Systools/src/mSysProcessW32.cpp       | 1451 ++++++++++++-----
 .../cpp/Systools/src/mSysSynchronizeW32.cpp   |  856 ++++++++++
 .../Massai/cpp/Systools/src/mSysTimeW32.cpp   |   74 +
 .../Massai/cpp/Systools/src/mSysWindowW32.cpp |  499 ++++++
 .../Massai/cpp/Tools/makefile.mak             |   20 +-
 .../Massai/cpp/Tools/src/ResetTime.cpp        |  124 ++
 .../Massai/cpp/Tools/src/TraceCallback.cpp    |  130 ++
 .../Massai/cpp/Tools/src/TraceClient.cpp      |  107 --
 .../Massai/cpp/Tools/src/TraceDelegate.cpp    |  154 +-
 .../Massai/cpp/Tools/src/TraceFormatCB.cpp    |  178 ++
 .../Massai/cpp/Tools/src/TraceHandle.cpp      |  108 --
 .../Massai/cpp/Tools/src/TraceInterface.cpp   |    4 -
 .../Massai/cpp/Tools/src/TraceLocal.cpp       |  237 +--
 .../cpp/Tools/src/TraceLocationDelegate.cpp   |  195 ---
 .../Massai/cpp/Tools/src/TraceSync.cpp        |  111 --
 .../Massai/cpp/Tools/src/TraceSystem.cpp      |   48 +
 .../Massai/cpp/Tools/src/localtrace.cpp       |  118 +-
 .../Massai/cpp/Trace/inc/TraceCmd.h           |    7 +-
 .../Massai/cpp/Trace/inc/TraceCmdQueue.h      |    4 +-
 .../Massai/cpp/Trace/inc/TraceConfig.h        |    3 +-
 .../Massai/cpp/Trace/inc/TraceFormat.h        |   14 +-
 .../Massai/cpp/Trace/inc/TraceSession.h       |   17 +-
 .../Massai/cpp/Trace/inc/TraceSystem.h        |   12 -
 .../Massai/cpp/Trace/src/TraceCmd.cpp         |    4 +-
 .../Massai/cpp/Trace/src/TraceCmdQueue.cpp    |    4 +-
 .../Massai/cpp/Trace/src/TraceConfig.cpp      |    5 +-
 .../Massai/cpp/Trace/src/TraceFormat.cpp      |  198 +--
 .../Massai/cpp/Trace/src/TraceProcessor.cpp   |    2 -
 .../Massai/cpp/Trace/src/TraceSession.cpp     |   56 +-
 .../Massai/cpp/Trace/src/TraceSystem.cpp      |   15 -
 .../Massai/cpp/Trace/src/TraceTrace.cpp       |   27 +-
 .../Massai/idl/Massai/appcontrol.idl          |   39 +-
 83 files changed, 6865 insertions(+), 2741 deletions(-)
 create mode 100644 SelfServiceCommon/Interfaces/inc/Tools/ResetTime.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/Tools/TraceCallback.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/Tools/TraceFormatCB.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/Tools/TraceSystem.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/systools/mSysProcessList.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/systools/mSysProcessTerminate.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/systools/mSysSynchronize.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/systools/mSysTime.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/systools/mSysWait.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/systools/mSysWindow.h
 create mode 100644 SelfServiceCommon/Massai/cpp/Controller/inc/control_common.h
 create mode 100644 SelfServiceCommon/Massai/cpp/Controller/inc/mstarter_args.h
 create mode 100644 SelfServiceCommon/Massai/cpp/Controller/inc/mstarter_config.h
 create mode 100644 SelfServiceCommon/Massai/cpp/Controller/inc/mstarter_notify.h
 create mode 100644 SelfServiceCommon/Massai/cpp/Controller/src/mstarter.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Controller/src/mstarter_args.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Controller/src/mstarter_config.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Controller/src/mstarter_notify.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Systools/inc/mSysErrorW32.h
 create mode 100644 SelfServiceCommon/Massai/cpp/Systools/inc/mSysProcessIOCountersW32.h
 create mode 100644 SelfServiceCommon/Massai/cpp/Systools/inc/mSysProcessW32.h
 create mode 100644 SelfServiceCommon/Massai/cpp/Systools/inc/mSysSynchronizeW32.h
 create mode 100644 SelfServiceCommon/Massai/cpp/Systools/inc/mSysTimeW32.h
 create mode 100644 SelfServiceCommon/Massai/cpp/Systools/src/mSysErrorW32.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Systools/src/mSysProcessListW32.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Systools/src/mSysProcessTerminateW32.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Systools/src/mSysSynchronizeW32.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Systools/src/mSysTimeW32.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Systools/src/mSysWindowW32.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Tools/src/ResetTime.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Tools/src/TraceCallback.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Tools/src/TraceFormatCB.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Tools/src/TraceSystem.cpp

diff --git a/SelfServiceCommon/Interfaces/inc/Tools/ResetTime.h b/SelfServiceCommon/Interfaces/inc/Tools/ResetTime.h
new file mode 100644
index 00000000..d454798f
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/Tools/ResetTime.h
@@ -0,0 +1,52 @@
+//---------------------------------------------------------------------------
+//
+//  file:       ResetTime.h
+//
+//  purpose:    handle error and reset
+//
+//---------------------------------------------------------------------------
+#ifndef RESET_TIME_H_INCLUDED
+#define RESET_TIME_H_INCLUDED
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "tools/TraceInterface.h"
+#include <string>
+
+namespace mReset
+{
+  typedef unsigned long Time; // in ms
+
+  /*
+    calculate time for resetting
+      resetTime(n) = time between error and reset, for the nth reset
+      min <= resetTime(n) <= max
+      resetTime(0)= min
+      resetTime(n+1)=
+        min; if time since last error > recover
+        max; if resetTime(n)*2 > max
+        resetTime(n)*2; else
+  */
+  class ResetTime
+  {
+    public:
+      ResetTime(MASSAI::trace::TraceInterface& trc, const std::string& name,
+        Time min, Time max, Time recover);
+      ~ResetTime();
+      void setError();
+      void resetError();
+      bool hasError() const;
+      Time getResetTime() const;
+    private:
+      std::string m_name;
+      Time m_min;
+      Time m_max;
+      Time m_recover;
+      bool m_hasError;
+      Time m_errorTimestamp;
+      Time m_resetTime;
+      MASSAI::trace::TraceInterface& m_trc;
+  };
+}
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/Tools/TraceCallback.h b/SelfServiceCommon/Interfaces/inc/Tools/TraceCallback.h
new file mode 100644
index 00000000..7af78f17
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/Tools/TraceCallback.h
@@ -0,0 +1,113 @@
+//---------------------------------------------------------------------------
+//
+//  file:       TraceCallback.h
+//
+//  purpose:    interface for traceing
+//
+//  date:       01.12.2011
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef TRACECALLBACK_H_INCLUDED
+#define TRACECALLBACK_H_INCLUDED
+
+#include "Tools/TraceInterface.h"
+#include "Tools/TraceFormatCB.h"
+
+namespace MASSAI
+{
+  namespace trace
+  {
+    class TraceCallback: public TraceInterface
+    {
+      public:
+        TraceCallback(const char* pszApplication, Callback& callback);
+        virtual ~TraceCallback();
+        /*
+        ---------------------------------------------------------------------------
+           Trace Text
+        ---------------------------------------------------------------------------
+        */
+        virtual void writeTraceText
+        (
+           long lTraceLevel,
+           const char* pszFile,
+           short  sLine,
+           const char* pszFunction,
+           const char* pszText
+        ) const;
+        /*
+        ---------------------------------------------------------------------------
+           Trace Dump
+        ---------------------------------------------------------------------------
+        */
+        virtual void dumpTrace
+        (
+           long lTraceLevel,
+           const char* pszFile,
+           short  sLine,
+           const char* pszFunction,
+           long lDumpSize,
+           const char* pDump
+        ) const;
+        /*
+        ---------------------------------------------------------------------------
+          Start new files
+        ---------------------------------------------------------------------------
+        */
+        virtual void startNewTraceFile(long lTraceLevel) const;
+        /*
+        ---------------------------------------------------------------------------
+           Trace Text
+        ---------------------------------------------------------------------------
+        */
+        virtual void writeTraceTextForTopic
+        (
+           const char* pszTopic,
+           const char* pszFile,
+           short  sLine,
+           const char* pszFunction,
+           const char* pszText
+        ) const;
+        /*
+        ---------------------------------------------------------------------------
+           Trace Dump
+        ---------------------------------------------------------------------------
+        */
+        virtual void dumpTraceForTopic
+        (
+           const char* pszTopic,
+           const char* pszFile,
+           short  sLine,
+           const char* pszFunction,
+           long lDumpSize,
+           const char* pDump
+        ) const;
+        /*
+        ---------------------------------------------------------------------------
+          Start new files
+        ---------------------------------------------------------------------------
+        */
+        virtual void startNewTraceFileForTopic(const char* pszTopic) const;
+        /*
+        ---------------------------------------------------------------------------
+           move file
+        ---------------------------------------------------------------------------
+        */
+        virtual void moveTrace
+        (
+           const char* pszPath
+        ) const;
+
+      private:
+        TraceFormatCB m_format;
+    };
+  }
+}
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/Tools/TraceClient.h b/SelfServiceCommon/Interfaces/inc/Tools/TraceClient.h
index 3a66087d..91d04f19 100644
--- a/SelfServiceCommon/Interfaces/inc/Tools/TraceClient.h
+++ b/SelfServiceCommon/Interfaces/inc/Tools/TraceClient.h
@@ -11,7 +11,6 @@
 //  history:
 //---------------------------------------------------------------------------
 
-
 #if defined(SHOW_INCLUDE_FILES)
 #pragma message("including: " __FILE__)
 #endif
@@ -44,8 +43,6 @@ namespace MASSAI
            const char* pszFunction,
            const char* pszText
         ) const;
-
-
         /*
         ---------------------------------------------------------------------------
            Trace Dump
@@ -60,7 +57,6 @@ namespace MASSAI
            long lDumpSize,
            const char* pDump
         ) const;
-
         /*
         ---------------------------------------------------------------------------
           Start new files
@@ -68,8 +64,6 @@ namespace MASSAI
         ---------------------------------------------------------------------------
         */
         virtual void startNewTraceFile(long lTraceLevel) const;
-
-
         /*
         ---------------------------------------------------------------------------
            Trace Text
@@ -84,9 +78,6 @@ namespace MASSAI
            const char* pszFunction,
            const char* pszText
         ) const;
-
-
-
         /*
         ---------------------------------------------------------------------------
            Trace Dump
@@ -101,7 +92,6 @@ namespace MASSAI
            long lDumpSize,
            const char* pDump
         ) const;
-
         /*
         ---------------------------------------------------------------------------
           Start new files
@@ -109,85 +99,16 @@ namespace MASSAI
         ---------------------------------------------------------------------------
         */
         virtual void startNewTraceFileForTopic(const char* pszTopic) const;
-
-
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace encypted
-        ---------------------------------------------------------------------------
-        */
-        virtual void cryptTrace
-        (
-           long lTraceLevel,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long lDumpSize,
-           const char* pDump
-        ) const;
-
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace encypted
-        ---------------------------------------------------------------------------
-        */
-        virtual void cryptTraceForTopic
-        (
-           const char* pszTopic,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long lDumpSize,
-           const char* pDump
-        ) const;
-
-
         /*
         ---------------------------------------------------------------------------
            move file
         ---------------------------------------------------------------------------
         */
-
         virtual void moveTrace
         (
            const char* pszPath
         ) const;
 
-
-
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace credit card track
-        ---------------------------------------------------------------------------
-        */
-        virtual void traceTrack
-        (
-           long lTraceLevel,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long trackid,
-           const char* pszTrack
-        ) const;
-
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace credit card track
-        ---------------------------------------------------------------------------
-        */
-        virtual void traceTrackForTopic
-        (
-           const char* pszTopic,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long trackid,
-           const char* pszTrack
-        ) const;
       private:
         bool m_close;
     };
diff --git a/SelfServiceCommon/Interfaces/inc/Tools/TraceDelegate.h b/SelfServiceCommon/Interfaces/inc/Tools/TraceDelegate.h
index 52b2eb45..9809156e 100644
--- a/SelfServiceCommon/Interfaces/inc/Tools/TraceDelegate.h
+++ b/SelfServiceCommon/Interfaces/inc/Tools/TraceDelegate.h
@@ -11,14 +11,16 @@
 //  history:
 //---------------------------------------------------------------------------
 
-
 #if defined(SHOW_INCLUDE_FILES)
 #pragma message("including: " __FILE__)
 #endif
 #ifndef TRACEDELEGATE_H_INCLUDED
 #define TRACEDELEGATE_H_INCLUDED
 
+#pragma warning (disable: 4786)
+
 #include "Tools/TraceInterface.h"
+#include <list>
 
 namespace MASSAI
 {
@@ -28,7 +30,10 @@ namespace MASSAI
     {
       public:
         TraceDelegate(const TraceInterface* pDelegate);
+        TraceDelegate();
         ~TraceDelegate();
+        void addTrace(const TraceInterface* pDelegate);
+
         /*
         ---------------------------------------------------------------------------
            Trace Text
@@ -43,7 +48,6 @@ namespace MASSAI
            const char* pszFunction,
            const char* pszText
         ) const;
-
         /*
         ---------------------------------------------------------------------------
            Trace Dump
@@ -58,7 +62,6 @@ namespace MASSAI
            long lDumpSize,
            const char* pDump
         ) const;
-
         /*
         ---------------------------------------------------------------------------
           Start new files
@@ -66,7 +69,6 @@ namespace MASSAI
         ---------------------------------------------------------------------------
         */
         void startNewTraceFile(long lTraceLevel) const;
-
         /*
         ---------------------------------------------------------------------------
            Trace Text
@@ -81,7 +83,6 @@ namespace MASSAI
            const char* pszFunction,
            const char* pszText
         ) const;
-
         /*
         ---------------------------------------------------------------------------
            Trace Dump
@@ -96,7 +97,6 @@ namespace MASSAI
            long lDumpSize,
            const char* pDump
         ) const;
-
         /*
         ---------------------------------------------------------------------------
           Start new files
@@ -104,79 +104,19 @@ namespace MASSAI
         ---------------------------------------------------------------------------
         */
         void startNewTraceFileForTopic(const char* pszTopic) const;
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace encypted
-        ---------------------------------------------------------------------------
-        */
-        void cryptTrace
-        (
-           long lTraceLevel,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long lDumpSize,
-           const char* pDump
-        ) const;
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace encypted
-        ---------------------------------------------------------------------------
-        */
-        void cryptTraceForTopic
-        (
-           const char* pszTopic,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long lDumpSize,
-           const char* pDump
-        ) const;
-
         /*
         ---------------------------------------------------------------------------
            move file
         ---------------------------------------------------------------------------
         */
-
         void moveTrace
         (
            const char* pszPath
         ) const;
 
-        /*
-        ---------------------------------------------------------------------------
-           Trace credit card track
-        ---------------------------------------------------------------------------
-        */
-        void traceTrack
-        (
-           long lTraceLevel,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long trackid,
-           const char* pszTrack
-        ) const;
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace credit card track
-        ---------------------------------------------------------------------------
-        */
-        void traceTrackForTopic
-        (
-           const char* pszTopic,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long trackid,
-           const char* pszTrack
-        ) const;
       private:
-        const TraceInterface* m_pDelegate;
+        typedef std::list<const TraceInterface*> TraceList;
+        TraceList m_delegate;
     };
   }
 }
diff --git a/SelfServiceCommon/Interfaces/inc/Tools/TraceFormatCB.h b/SelfServiceCommon/Interfaces/inc/Tools/TraceFormatCB.h
new file mode 100644
index 00000000..827d3e20
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/Tools/TraceFormatCB.h
@@ -0,0 +1,62 @@
+//---------------------------------------------------------------------------
+//
+//  file:       TraceFormat.h
+//
+//  purpose:    interface for traceing
+//
+//  date:       01.12.2011
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef TRACEFORMATCB_H_INCLUDED
+#define TRACEFORMATCB_H_INCLUDED
+
+#include <string>
+#include <stdlib.h>
+#include "systools/mSysTime.h"
+
+namespace MASSAI
+{
+  namespace trace
+  {
+    class Callback
+    {
+      public:
+        virtual ~Callback();
+        virtual void traceLine(const std::string& head, const std::string& data) const = 0;
+    };
+    typedef long ThreadId;
+    class TraceFormatCB
+    {
+      public:
+        TraceFormatCB(Callback& callback);
+        ~TraceFormatCB();
+        void text(ThreadId threadId, const mSysTime::Timestamp& timestamp,
+          long traceLevel, const std::string& topic, const std::string& file, long line,
+          const std::string& function, const std::string& data) const;
+        void dump(ThreadId threadId, const mSysTime::Timestamp& timestamp,
+          long traceLevel, const std::string& topic, const std::string& file, long line,
+          const std::string& function, const std::string& data) const;
+        void text(long traceLevel, const char* topic, const char* file, long line,
+          const char* function, const char* data) const;
+        void dump(long traceLevel, const char* topic, const char* file, long line,
+          const char* function, size_t size, const char* data) const;
+        void text(ThreadId threadId, const mSysTime::Timestamp& timestamp,
+          long traceLevel, const char* topic, const char* file, long line,
+          const char* function, const char* data) const;
+        void dump(ThreadId threadId, const mSysTime::Timestamp& timestamp,
+          long traceLevel, const char* topic, const char* file, long line,
+          const char* function, size_t size, const char* data) const;
+
+      private:
+        Callback& m_callback;
+    };
+  }
+}
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/Tools/TraceHandle.h b/SelfServiceCommon/Interfaces/inc/Tools/TraceHandle.h
index d52ad339..1367a105 100644
--- a/SelfServiceCommon/Interfaces/inc/Tools/TraceHandle.h
+++ b/SelfServiceCommon/Interfaces/inc/Tools/TraceHandle.h
@@ -11,7 +11,6 @@
 //  history:
 //---------------------------------------------------------------------------
 
-
 #if defined(SHOW_INCLUDE_FILES)
 #pragma message("including: " __FILE__)
 #endif
@@ -44,8 +43,6 @@ namespace MASSAI
            const char* pszFunction,
            const char* pszText
         ) const;
-
-
         /*
         ---------------------------------------------------------------------------
            Trace Dump
@@ -60,7 +57,6 @@ namespace MASSAI
            long lDumpSize,
            const char* pDump
         ) const;
-
         /*
         ---------------------------------------------------------------------------
           Start new files
@@ -68,8 +64,6 @@ namespace MASSAI
         ---------------------------------------------------------------------------
         */
         virtual void startNewTraceFile(long lTraceLevel) const;
-
-
         /*
         ---------------------------------------------------------------------------
            Trace Text
@@ -84,8 +78,6 @@ namespace MASSAI
            const char* pszFunction,
            const char* pszText
         ) const;
-
-
         /*
         ---------------------------------------------------------------------------
            Trace Dump
@@ -100,7 +92,6 @@ namespace MASSAI
            long lDumpSize,
            const char* pDump
         ) const;
-
         /*
         ---------------------------------------------------------------------------
           Start new files
@@ -108,85 +99,16 @@ namespace MASSAI
         ---------------------------------------------------------------------------
         */
         virtual void startNewTraceFileForTopic(const char* pszTopic) const;
-
-
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace encypted
-        ---------------------------------------------------------------------------
-        */
-        virtual void cryptTrace
-        (
-           long lTraceLevel,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long lDumpSize,
-           const char* pDump
-        ) const;
-
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace encypted
-        ---------------------------------------------------------------------------
-        */
-        virtual void cryptTraceForTopic
-        (
-           const char* pszTopic,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long lDumpSize,
-           const char* pDump
-        ) const;
-
-
         /*
         ---------------------------------------------------------------------------
            move file
         ---------------------------------------------------------------------------
         */
-
         virtual void moveTrace
         (
            const char* pszPath
         ) const;
 
-
-
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace credit card track
-        ---------------------------------------------------------------------------
-        */
-        virtual void traceTrack
-        (
-           long lTraceLevel,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long trackid,
-           const char* pszTrack
-        ) const;
-
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace credit card track
-        ---------------------------------------------------------------------------
-        */
-        virtual void traceTrackForTopic
-        (
-           const char* pszTopic,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long trackid,
-           const char* pszTrack
-        ) const;
       private:
         int m_handle;
         bool m_close;
diff --git a/SelfServiceCommon/Interfaces/inc/Tools/TraceInterface.h b/SelfServiceCommon/Interfaces/inc/Tools/TraceInterface.h
index d33298cb..77f24315 100644
--- a/SelfServiceCommon/Interfaces/inc/Tools/TraceInterface.h
+++ b/SelfServiceCommon/Interfaces/inc/Tools/TraceInterface.h
@@ -11,7 +11,6 @@
 //  history:
 //---------------------------------------------------------------------------
 
-
 #if defined(SHOW_INCLUDE_FILES)
 #pragma message("including: " __FILE__)
 #endif
@@ -32,7 +31,6 @@ namespace MASSAI
         /*
         ---------------------------------------------------------------------------
            Trace Text
-
         ---------------------------------------------------------------------------
         */
         virtual void writeTraceText
@@ -43,7 +41,6 @@ namespace MASSAI
            const char* pszFunction,
            const char* pszText
         ) const = 0;
-
         /*
         ---------------------------------------------------------------------------
            Trace Text
@@ -59,7 +56,6 @@ namespace MASSAI
           const char* pszFormat,
           ...
         ) const;
-
         /*
         ---------------------------------------------------------------------------
            Trace Dump
@@ -74,19 +70,15 @@ namespace MASSAI
            long lDumpSize,
            const char* pDump
         ) const = 0;
-
         /*
         ---------------------------------------------------------------------------
           Start new files
-
         ---------------------------------------------------------------------------
         */
         virtual void startNewTraceFile(long lTraceLevel) const= 0;
-
         /*
         ---------------------------------------------------------------------------
            Trace Text
-
         ---------------------------------------------------------------------------
         */
         virtual void writeTraceTextForTopic
@@ -97,7 +89,6 @@ namespace MASSAI
            const char* pszFunction,
            const char* pszText
         ) const = 0;
-
         /*
         ---------------------------------------------------------------------------
            Trace Text
@@ -113,7 +104,6 @@ namespace MASSAI
           const char* pszFormat,
           ...
         ) const;
-
         /*
         ---------------------------------------------------------------------------
            Trace Dump
@@ -128,85 +118,21 @@ namespace MASSAI
            long lDumpSize,
            const char* pDump
         ) const = 0;
-
         /*
         ---------------------------------------------------------------------------
           Start new files
-
         ---------------------------------------------------------------------------
         */
         virtual void startNewTraceFileForTopic(const char* pszTopic) const = 0;
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace encypted
-        ---------------------------------------------------------------------------
-        */
-        virtual void cryptTrace
-        (
-           long lTraceLevel,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long lDumpSize,
-           const char* pDump
-        ) const = 0;
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace encypted
-        ---------------------------------------------------------------------------
-        */
-        virtual void cryptTraceForTopic
-        (
-           const char* pszTopic,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long lDumpSize,
-           const char* pDump
-        ) const = 0;
-
         /*
         ---------------------------------------------------------------------------
            move file
         ---------------------------------------------------------------------------
         */
-
         virtual void moveTrace
         (
            const char* pszPath
         ) const = 0;
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace credit card track
-        ---------------------------------------------------------------------------
-        */
-        virtual void traceTrack
-        (
-           long lTraceLevel,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long trackid,
-           const char* pszTrack
-        ) const = 0;
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace credit card track
-        ---------------------------------------------------------------------------
-        */
-        virtual void traceTrackForTopic
-        (
-           const char* pszTopic,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long trackid,
-           const char* pszTrack
-        ) const = 0;
     };
   }
 }
diff --git a/SelfServiceCommon/Interfaces/inc/Tools/TraceLocal.h b/SelfServiceCommon/Interfaces/inc/Tools/TraceLocal.h
index 4e29e145..d14f99cd 100644
--- a/SelfServiceCommon/Interfaces/inc/Tools/TraceLocal.h
+++ b/SelfServiceCommon/Interfaces/inc/Tools/TraceLocal.h
@@ -11,181 +11,23 @@
 //  history:
 //---------------------------------------------------------------------------
 
-
 #if defined(SHOW_INCLUDE_FILES)
 #pragma message("including: " __FILE__)
 #endif
 #ifndef TRACELOCAL_H_INCLUDED
 #define TRACELOCAL_H_INCLUDED
 
-#include "Tools/TraceInterface.h"
+#include "Tools/TraceCallback.h"
 
 namespace MASSAI
 {
   namespace trace
   {
-    class TraceLocal: public TraceInterface
+    class TraceLocal: public TraceCallback
     {
       public:
         TraceLocal(const char* pszApplication);
         virtual ~TraceLocal();
-        /*
-        ---------------------------------------------------------------------------
-           Trace Text
-
-        ---------------------------------------------------------------------------
-        */
-        virtual void writeTraceText
-        (
-           long lTraceLevel,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           const char* pszText
-        ) const;
-
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace Dump
-        ---------------------------------------------------------------------------
-        */
-        virtual void dumpTrace
-        (
-           long lTraceLevel,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long lDumpSize,
-           const char* pDump
-        ) const;
-
-        /*
-        ---------------------------------------------------------------------------
-          Start new files
-
-        ---------------------------------------------------------------------------
-        */
-        virtual void startNewTraceFile(long lTraceLevel) const;
-
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace Text
-
-        ---------------------------------------------------------------------------
-        */
-        virtual void writeTraceTextForTopic
-        (
-           const char* pszTopic,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           const char* pszText
-        ) const;
-
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace Dump
-        ---------------------------------------------------------------------------
-        */
-        virtual void dumpTraceForTopic
-        (
-           const char* pszTopic,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long lDumpSize,
-           const char* pDump
-        ) const;
-
-        /*
-        ---------------------------------------------------------------------------
-          Start new files
-
-        ---------------------------------------------------------------------------
-        */
-        virtual void startNewTraceFileForTopic(const char* pszTopic) const;
-
-
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace encypted
-        ---------------------------------------------------------------------------
-        */
-        virtual void cryptTrace
-        (
-           long lTraceLevel,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long lDumpSize,
-           const char* pDump
-        ) const;
-
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace encypted
-        ---------------------------------------------------------------------------
-        */
-        virtual void cryptTraceForTopic
-        (
-           const char* pszTopic,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long lDumpSize,
-           const char* pDump
-        ) const;
-
-
-        /*
-        ---------------------------------------------------------------------------
-           move file
-        ---------------------------------------------------------------------------
-        */
-
-        virtual void moveTrace
-        (
-           const char* pszPath
-        ) const;
-
-
-
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace credit card track
-        ---------------------------------------------------------------------------
-        */
-        virtual void traceTrack
-        (
-           long lTraceLevel,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long trackid,
-           const char* pszTrack
-        ) const;
-
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace credit card track
-        ---------------------------------------------------------------------------
-        */
-        virtual void traceTrackForTopic
-        (
-           const char* pszTopic,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long trackid,
-           const char* pszTrack
-        ) const;
     };
   }
 }
diff --git a/SelfServiceCommon/Interfaces/inc/Tools/TraceLocationDelegate.h b/SelfServiceCommon/Interfaces/inc/Tools/TraceLocationDelegate.h
index 0ca7d3f8..6e4af7e2 100644
--- a/SelfServiceCommon/Interfaces/inc/Tools/TraceLocationDelegate.h
+++ b/SelfServiceCommon/Interfaces/inc/Tools/TraceLocationDelegate.h
@@ -11,7 +11,6 @@
 //  history:
 //---------------------------------------------------------------------------
 
-
 #if defined(SHOW_INCLUDE_FILES)
 #pragma message("including: " __FILE__)
 #endif
@@ -35,7 +34,6 @@ namespace MASSAI
           const char* pszFunction
         );
         ~TraceLocationDelegate();
-
         /*
         ---------------------------------------------------------------------------
            Trace Text
@@ -48,7 +46,6 @@ namespace MASSAI
           const char* pszFormat,
           ...
         ) const;
-
         /*
         ---------------------------------------------------------------------------
            Trace Text
@@ -61,11 +58,9 @@ namespace MASSAI
           const char* pszFormat,
           ...
         ) const;
-
         /*
         ---------------------------------------------------------------------------
            Trace Text
-
         ---------------------------------------------------------------------------
         */
         void writeTraceText
@@ -73,7 +68,6 @@ namespace MASSAI
            long lTraceLevel,
            const char* pszText
         ) const;
-
         /*
         ---------------------------------------------------------------------------
            Trace Dump
@@ -85,19 +79,15 @@ namespace MASSAI
            long lDumpSize,
            const char* pDump
         ) const;
-
         /*
         ---------------------------------------------------------------------------
           Start new files
-
         ---------------------------------------------------------------------------
         */
         void startNewTraceFile(long lTraceLevel) const;
-
         /*
         ---------------------------------------------------------------------------
            Trace Text
-
         ---------------------------------------------------------------------------
         */
         void writeTraceTextForTopic
@@ -105,7 +95,6 @@ namespace MASSAI
            const char* pszTopic,
            const char* pszText
         ) const;
-
         /*
         ---------------------------------------------------------------------------
            Trace Dump
@@ -117,74 +106,22 @@ namespace MASSAI
            long lDumpSize,
            const char* pDump
         ) const;
-
         /*
         ---------------------------------------------------------------------------
           Start new files
-
         ---------------------------------------------------------------------------
         */
         void startNewTraceFileForTopic(const char* pszTopic) const;
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace encypted
-        ---------------------------------------------------------------------------
-        */
-        void cryptTrace
-        (
-           long lTraceLevel,
-           long lDumpSize,
-           const char* pDump
-        ) const;
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace encypted
-        ---------------------------------------------------------------------------
-        */
-        void cryptTraceForTopic
-        (
-           const char* pszTopic,
-           long lDumpSize,
-           const char* pDump
-        ) const;
-
         /*
         ---------------------------------------------------------------------------
            move file
         ---------------------------------------------------------------------------
         */
-
         void moveTrace
         (
            const char* pszPath
         ) const;
 
-        /*
-        ---------------------------------------------------------------------------
-           Trace credit card track
-        ---------------------------------------------------------------------------
-        */
-        void traceTrack
-        (
-           long lTraceLevel,
-           long trackid,
-           const char* pszTrack
-        ) const;
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace credit card track
-        ---------------------------------------------------------------------------
-        */
-        void traceTrackForTopic
-        (
-           const char* pszTopic,
-           long trackid,
-           const char* pszTrack
-        ) const;
-
         const TraceInterface* getDelegate() const;
         const char* getFile() const;
         short getLine() const;
@@ -196,13 +133,11 @@ namespace MASSAI
         short m_sLine;
         const char* m_pszFunction;
     };
-
     class TraceTopicDelegate
     {
       public:
         TraceTopicDelegate(const TraceInterface* pDelegate, const char* pszTopic);
         ~TraceTopicDelegate();
-
         /*
         ---------------------------------------------------------------------------
            Trace Text
@@ -217,11 +152,9 @@ namespace MASSAI
           const char* pszFormat,
           ...
         ) const;
-
         /*
         ---------------------------------------------------------------------------
            Trace Text
-
         ---------------------------------------------------------------------------
         */
         void writeTraceTextForTopic
@@ -231,7 +164,6 @@ namespace MASSAI
            const char* pszFunction,
            const char* pszText
         ) const;
-
         /*
         ---------------------------------------------------------------------------
            Trace Dump
@@ -245,55 +177,22 @@ namespace MASSAI
            long lDumpSize,
            const char* pDump
         ) const;
-
         /*
         ---------------------------------------------------------------------------
           Start new files
-
         ---------------------------------------------------------------------------
         */
         void startNewTraceFileForTopic() const;
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace encypted
-        ---------------------------------------------------------------------------
-        */
-        void cryptTraceForTopic
-        (
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long lDumpSize,
-           const char* pDump
-        ) const;
-
         /*
         ---------------------------------------------------------------------------
            move file
         ---------------------------------------------------------------------------
         */
-
         void moveTrace
         (
            const char* pszPath
         ) const;
 
-        /*
-        ---------------------------------------------------------------------------
-           Trace credit card track
-        ---------------------------------------------------------------------------
-        */
-        void traceTrackForTopic
-        (
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long trackid,
-           const char* pszTrack
-        ) const;
-
-
         const TraceInterface* getDelegate() const;
         const char* getTopic() const;
 
@@ -301,8 +200,6 @@ namespace MASSAI
         const char* m_pszTopic;
         const TraceInterface* m_pDelegate;
     };
-
-
     class TraceLocationTopicDelegate
     {
       public:
@@ -327,7 +224,6 @@ namespace MASSAI
           const char* pszFunction
         );
         ~TraceLocationTopicDelegate();
-
         /*
         ---------------------------------------------------------------------------
            Trace Text
@@ -342,14 +238,12 @@ namespace MASSAI
         /*
         ---------------------------------------------------------------------------
            Trace Text
-
         ---------------------------------------------------------------------------
         */
         void writeTraceTextForTopic
         (
            const char* pszText
         ) const;
-
         /*
         ---------------------------------------------------------------------------
            Trace Dump
@@ -360,49 +254,22 @@ namespace MASSAI
            long lDumpSize,
            const char* pDump
         ) const;
-
         /*
         ---------------------------------------------------------------------------
           Start new files
-
         ---------------------------------------------------------------------------
         */
         void startNewTraceFileForTopic() const;
-
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace encypted
-        ---------------------------------------------------------------------------
-        */
-        void cryptTraceForTopic
-        (
-           long lDumpSize,
-           const char* pDump
-        ) const;
-
         /*
         ---------------------------------------------------------------------------
            move file
         ---------------------------------------------------------------------------
         */
-
         void moveTrace
         (
            const char* pszPath
         ) const;
 
-        /*
-        ---------------------------------------------------------------------------
-           Trace credit card track
-        ---------------------------------------------------------------------------
-        */
-        void traceTrackForTopic
-        (
-           long trackid,
-           const char* pszTrack
-        ) const;
-
         const TraceInterface* getDelegate() const;
         const char* getFile() const;
         short getLine() const;
diff --git a/SelfServiceCommon/Interfaces/inc/Tools/TraceSync.h b/SelfServiceCommon/Interfaces/inc/Tools/TraceSync.h
index 51dc049d..c96df431 100644
--- a/SelfServiceCommon/Interfaces/inc/Tools/TraceSync.h
+++ b/SelfServiceCommon/Interfaces/inc/Tools/TraceSync.h
@@ -44,8 +44,6 @@ namespace MASSAI
            const char* pszFunction,
            const char* pszText
         ) const;
-
-
         /*
         ---------------------------------------------------------------------------
            Trace Dump
@@ -60,7 +58,6 @@ namespace MASSAI
            long lDumpSize,
            const char* pDump
         ) const;
-
         /*
         ---------------------------------------------------------------------------
           Start new files
@@ -68,8 +65,6 @@ namespace MASSAI
         ---------------------------------------------------------------------------
         */
         void startNewTraceFile(long lTraceLevel) const;
-
-
         /*
         ---------------------------------------------------------------------------
            Trace Text
@@ -84,10 +79,6 @@ namespace MASSAI
            const char* pszFunction,
            const char* pszText
         ) const;
-
-
-
-
         /*
         ---------------------------------------------------------------------------
            Trace Dump
@@ -102,79 +93,21 @@ namespace MASSAI
            long lDumpSize,
            const char* pDump
         ) const;
-
         /*
         ---------------------------------------------------------------------------
           Start new files
-
         ---------------------------------------------------------------------------
         */
         void startNewTraceFileForTopic(const char* pszTopic) const;
-
-
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace encypted
-        ---------------------------------------------------------------------------
-        */
-        void cryptTrace
-        (
-           long lTraceLevel,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long lDumpSize,
-           const char* pDump
-        ) const;
-
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace encypted
-        ---------------------------------------------------------------------------
-        */
-        void cryptTraceForTopic
-        (
-           const char* pszTopic,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long lDumpSize,
-           const char* pDump
-        ) const;
-
-
         /*
         ---------------------------------------------------------------------------
            move file
         ---------------------------------------------------------------------------
         */
-
         void moveTrace
         (
            const char* pszPath
         ) const;
-
-
-
-
-        /*
-        ---------------------------------------------------------------------------
-           Trace credit card track
-        ---------------------------------------------------------------------------
-        */
-        void traceTrack
-        (
-           long lTraceLevel,
-           const char* pszFile,
-           short  sLine,
-           const char* pszFunction,
-           long trackid,
-           const char* pszTrack
-        ) const;
-
-
         /*
         ---------------------------------------------------------------------------
            Trace credit card track
@@ -189,6 +122,7 @@ namespace MASSAI
            long trackid,
            const char* pszTrack
         ) const;
+
       private:
         MASSAI::trace::TraceInterface& m_delegate;
         mutable Materna::MSSD::mutexSemaphore m_access;
diff --git a/SelfServiceCommon/Interfaces/inc/Tools/TraceSystem.h b/SelfServiceCommon/Interfaces/inc/Tools/TraceSystem.h
new file mode 100644
index 00000000..0a4ab7d2
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/Tools/TraceSystem.h
@@ -0,0 +1,34 @@
+//---------------------------------------------------------------------------
+//
+//  file:       TraceSystem.h
+//
+//  purpose:    interface for traceing
+//
+//  date:       15.12.2010
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef TRACESYSTEM_H_INCLUDED
+#define TRACESYSTEM_H_INCLUDED
+
+#include "Tools/TraceCallback.h"
+
+namespace MASSAI
+{
+  namespace trace
+  {
+    class TraceSystem: public TraceCallback
+    {
+      public:
+        TraceSystem(const char* pszApplication);
+        virtual ~TraceSystem();
+    };
+  }
+}
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/Tools/localtrace.h b/SelfServiceCommon/Interfaces/inc/Tools/localtrace.h
index d077d662..558e9439 100644
--- a/SelfServiceCommon/Interfaces/inc/Tools/localtrace.h
+++ b/SelfServiceCommon/Interfaces/inc/Tools/localtrace.h
@@ -6,10 +6,6 @@
 
 #include "trc/tracedef.h"
 
-#ifndef __FUNCTION__ 
-#define __FUNCTION__ ""
-#endif
-
 namespace MASSAI
 {
   namespace localtrace
@@ -23,6 +19,5 @@ namespace MASSAI
     void dumpTraceForTopic(const char* pszTopic, const char* pszFile, short sLine, const char* pszFunction, long lDumpSize, const char* pDump);
     void closeTrace();
   }
-
 }
 #endif
diff --git a/SelfServiceCommon/Interfaces/inc/systools/mEventSem.hpp b/SelfServiceCommon/Interfaces/inc/systools/mEventSem.hpp
index 194e5ebc..664bf074 100644
--- a/SelfServiceCommon/Interfaces/inc/systools/mEventSem.hpp
+++ b/SelfServiceCommon/Interfaces/inc/systools/mEventSem.hpp
@@ -18,6 +18,7 @@
 #endif
 
 #include <exception>
+#include "systools/mSysWait.h"
 #pragma warning( disable: 4290 )
 
 
@@ -51,17 +52,35 @@ namespace Materna
 
 
 
+      /**
+       *
+       * define nameing of the semaphore
+       *
+      **/
+      enum SemaphoreName
+      {
+        SEM_GLOBAL_NAME,  // use global namespace
+        SEM_LOCAL_NAME,   // use local namespace
+        SEM_RAW_NAME,     // use name as is
+      };
+      /**
+       *
+       * define creation of the semaphore
+       *
+      **/
+      enum SemaphoreCreation
+      {
+        SEM_CREATE,
+        SEM_OPEN,
+      };
       /**
        *
        * Event semaphore class.
        *
       **/
-      class eventSemaphore
+      class eventSemaphore: public mSysSynchronize::WaitObject
       {
 
-         //! Handle
-         eventSemaphore_Handle * M_Handle;
-
       public:
 
          /**
@@ -90,6 +109,17 @@ namespace Materna
          **/
          eventSemaphore(bool global, char const * Name );
 
+         /**
+          *
+          * Named constructor, allow global semaphore, allow
+          *
+          * @param Name:        The name for the named event.
+          * @param nameing:     namespace for the semaphore
+          * @param create:      create/open the semaphore
+          *
+         **/
+         eventSemaphore(SemaphoreCreation create, SemaphoreName nameing, char const* Name);
+
          /**
           *
           * Destructor
@@ -143,7 +173,19 @@ namespace Materna
          int check()
             throw( eventSemaphore_Exception );
 
+         /**
+          *
+          * get internal event representation
+          *
+          * @return                internal event representation
+          *
+         **/
+         virtual const mSysSynchronize::Internal& getInternal() const;
+
       private:
+         //! Handle
+         eventSemaphore_Handle * M_Handle;
+
 
          /**
           *
diff --git a/SelfServiceCommon/Interfaces/inc/systools/mMutexCS.h b/SelfServiceCommon/Interfaces/inc/systools/mMutexCS.h
index 806643f1..4b630311 100644
--- a/SelfServiceCommon/Interfaces/inc/systools/mMutexCS.h
+++ b/SelfServiceCommon/Interfaces/inc/systools/mMutexCS.h
@@ -1,7 +1,7 @@
 /**
  **************************************************************************
  *
- * @file mMutexCS.hpp
+ * @file mMutexCS.h
  *
  * Contains class Materna::MSSD::Mutex definition.
  *
@@ -35,5 +35,4 @@ namespace Materna
   }
 }
 
-
 #endif
diff --git a/SelfServiceCommon/Interfaces/inc/systools/mSysProcess.hpp b/SelfServiceCommon/Interfaces/inc/systools/mSysProcess.hpp
index e5505c47..b6f805c8 100644
--- a/SelfServiceCommon/Interfaces/inc/systools/mSysProcess.hpp
+++ b/SelfServiceCommon/Interfaces/inc/systools/mSysProcess.hpp
@@ -17,12 +17,23 @@
 #pragma message("including: " __FILE__)
 #endif
 
+#pragma warning(disable:4786)
+
 #include "tools/pImplPtr.h"
 #include "systools/threadException.hpp"
+#include "systools/mSysWait.h"
+#include <string>
+#include <map>
 
 
 namespace mSysProcess
 {
+   /**
+    *  System environment variables
+    *
+   **/
+
+   typedef std::map<std::string, std::string> Environment;
 
 
    /**
@@ -68,16 +79,17 @@ namespace mSysProcess
       STATUS_UNKNOWN,           //!< Initial value, never used!
       STATUS_FAILED,            //!< Process creation failed.
       STATUS_RUNNING,           //!< Process running.
-      STATUS_TERMINATED         //!< Process has terminated.
+      STATUS_TERMINATED,        //!< Process has terminated.
    };
 
 
+
    /**
     *
     * Control a child process.
     *
    **/
-   class child
+   class child: public mSysSynchronize::WaitObject
    {
 
    public:
@@ -141,6 +153,69 @@ namespace mSysProcess
       **/
       virtual child & waitForTermination( unsigned Seconds ) = 0;
 
+      /**
+       *
+       * get process information (status, exit code, ...)
+       *
+       * @return                formatted process information.
+       *
+      **/
+      virtual std::string getProcessInformation() const = 0;
+
+      /**
+       *
+       * get process information (status, process id, ...)
+       *
+       * @return                formatted process information.
+       *
+      **/
+      virtual std::string getProcessId() const = 0;
+
+      /**
+       *
+       * close std in (for closing)
+       *
+       * @return                A reference to this object.
+       *
+      **/
+      virtual child & closeStdIn() = 0;
+
+      /**
+       *
+       * send break to the child process
+       *
+       * @return                true on success
+       *
+      **/
+      virtual bool sendBreak() = 0;
+
+      /**
+       *
+       * send Ctrl-C to the child process
+       *
+       * @return                true on success
+       *
+      **/
+      virtual bool sendCtrlC() = 0;
+
+      /**
+       *
+       * hard termination of the process (avoid this)
+       *
+       * @return                A reference to this object.
+       *
+      **/
+      virtual child & kill() = 0;
+
+      /**
+       *
+       * get internal process representation
+       *
+       * @return                internal process representation
+       *
+      **/
+      class Internal;
+      virtual const Internal& getId() const= 0;
    };
 
 
@@ -275,6 +350,58 @@ namespace mSysProcess
       **/
       parent & setWorkDirectory( char const * Directory );
 
+      /**
+       *
+       * Set the optional environment parameter.
+       *
+       * @param environment:    The environment
+       *
+       * @return                A reference to this object.
+       *
+      **/
+      parent& setEnvironment(const Environment& environment);
+
+      /**
+       *
+       * Set the optional window title parameter
+       *
+       * @param title:          The title of the window of the process
+       *
+       * @return                A reference to this object.
+       *
+      **/
+      parent& setWindowTitle(const char* title);
+
+      /**
+       *
+       * Set the optional desktop parameter
+       *
+       * @param desktop:        The desktop of the process
+       *
+       * @return                A reference to this object.
+       *
+      **/
+      parent& setDesktop(const char* desktop);
+
+      /**
+       *
+       * use the console of the parent process
+       *
+       * @return                A reference to this object.
+       *
+      **/
+      parent& setReuseConsole();
+
+      /**
+       *
+       * start process as new process group
+       *
+       * @return                A reference to this object.
+       *
+      **/
+      parent& setNewProcessGroup();
+
+
    private:
 
       //! Copy constructor - intentionally not implemented.
diff --git a/SelfServiceCommon/Interfaces/inc/systools/mSysProcessList.h b/SelfServiceCommon/Interfaces/inc/systools/mSysProcessList.h
new file mode 100644
index 00000000..62e499bf
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/systools/mSysProcessList.h
@@ -0,0 +1,133 @@
+/**
+ * control list of child processes
+**/
+
+#ifndef MSYSPROCESSLIST_H_INCLUDED
+#define MSYSPROCESSLIST_H_INCLUDED
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "systools/mSysProcess.hpp"
+#include "tools/TraceInterface.h"
+#include "tools/pImplPtr.h"
+#include "tools/ResetTime.h"
+#include "systools/mSysWindow.h"
+#include <list>
+
+
+namespace mSysProcess
+{
+  enum Show
+  {
+    SHOW,
+    HIDE,
+    MINIMIZED
+  };
+  /*
+    settings for a process
+  */
+  class ProcessProperties
+  {
+    public:
+      ProcessProperties();
+      bool operator<(const ProcessProperties& cmp) const;
+      std::string group;
+      std::string commandLine;
+      std::string workingDir;
+      std::string windowTitle;
+      std::string windowClass;
+      std::string desktop;
+      Show show;
+      long timeout;
+  };
+  typedef std::list<ProcessProperties> PropertyList;
+
+  /*
+    settings for Watchdog
+  */
+  class WatchdogSettings
+  {
+    public:
+      /*
+        wait for termination
+      */
+      unsigned long waitTimeout;
+      /*
+        watchdog timeout: adaptive time parameter
+      */
+      bool useWatchDog;
+      unsigned long resetMin;
+      unsigned long resetMax;
+      unsigned long resetRecover;
+  };
+
+  /*
+    settings for ProcessList
+  */
+  class ProcessListSettings
+  {
+    public:
+      virtual ~ProcessListSettings();
+      virtual PropertyList getProcessList() const= 0;
+  };
+
+  /*
+    watch ProcessList actions
+  */
+  class ProcessListCallback
+  {
+    public:
+      ProcessListCallback();
+      virtual ~ProcessListCallback();
+      virtual void start(const PropertyList& processes)= 0;
+      virtual void started(const ProcessProperties& process)= 0;
+      virtual void terminated(const ProcessProperties& process)= 0;
+  };
+  /*
+    control list of child processes
+  */
+  class ProcessList
+  {
+    public:
+      ProcessList(MASSAI::trace::TraceInterface& trc, const WatchdogSettings& settings);
+      ~ProcessList();
+      void setListener(ProcessListCallback* pListener);
+      void start(ProcessListSettings* settings);
+      void stop();
+      void checkProcessList();
+
+      class Impl;
+
+    private:
+      ProcessList(const ProcessList&);
+      ProcessList& operator=(const ProcessList&);
+
+      pImplPtr<Impl> m_pImpl;
+  };
+  /*
+    control list of child processes
+  */
+  class ApplicationList
+  {
+    public:
+      ApplicationList(MASSAI::trace::TraceInterface& trc, const WatchdogSettings& settings);
+      ~ApplicationList();
+      void start(const PropertyList& processes);
+      void stop(const std::string& group);
+      void stopAll();
+      mSysWindow::WindowList findWinByTitleClassName(const std::string& group);
+      mSysWindow::WindowList findVisibleWin(const std::string& group);
+      mReset::Time checkForTerminatedProcesses();
+
+      class Impl;
+
+    private:
+      ApplicationList(const ApplicationList&);
+      ApplicationList& operator=(const ApplicationList&);
+
+      pImplPtr<Impl> m_pImpl;
+  };
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/systools/mSysProcessTerminate.h b/SelfServiceCommon/Interfaces/inc/systools/mSysProcessTerminate.h
new file mode 100644
index 00000000..28665d41
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/systools/mSysProcessTerminate.h
@@ -0,0 +1,34 @@
+/**
+ * control shutdown of current process
+**/
+
+#ifndef MSYSPROCESSTERMINATE_H_INCLUDED
+#define MSYSPROCESSTERMINATE_H_INCLUDED
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "systools/mEventSem.hpp"
+#include "tools/TraceInterface.h"
+#include <memory>
+
+namespace mSysProcessTerminate
+{
+  /*
+    register for early, in-between or late
+    notification at system shutdown
+  */
+  enum ShutdownPriority
+  {
+    SHUTDOWN_EARLY,
+    SHUTDOWN_NORMAL,
+    SHUTDOWN_LATE,
+  };
+  /*
+    register for notification at system shutdown
+  */
+  void setShutdownHook(ShutdownPriority priority, Materna::MSSD::eventSemaphore* pEvent, MASSAI::trace::TraceInterface* pTrc);
+  void resetShutdownHook();
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/systools/mSysSynchronize.h b/SelfServiceCommon/Interfaces/inc/systools/mSysSynchronize.h
new file mode 100644
index 00000000..2c996b8d
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/systools/mSysSynchronize.h
@@ -0,0 +1,95 @@
+/**
+ * wait for multiple objects
+**/
+
+#ifndef MSYSSYNCHRONIZE_H_INCLUDED
+#define MSYSSYNCHRONIZE_H_INCLUDED
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "tools/TraceInterface.h"
+#include "tools/pImplPtr.h"
+#include "systools/mSysWait.h"
+
+#include <stdlib.h>
+
+namespace mSysSynchronize
+{
+  /*
+   *  callback for notification
+   */
+  class WaitNotification: public WaitObject
+  {
+    public:
+      WaitNotification();
+      virtual ~WaitNotification();
+      virtual void notify()= 0;
+  };
+
+  /*
+   *  callback for notification
+   */
+  class WaitListener
+  {
+    public:
+      WaitListener();
+      virtual ~WaitListener();
+      // notification is signaled
+      virtual void notify(WaitNotification* pNotification);
+      // notification was not signaled, when Synchronize object is destroyed
+      virtual void cleanup(WaitNotification* pNotification);
+  };
+
+  /*
+   *  wait for multiple WaitNotifications
+   */
+  class Synchronize
+  {
+    public:
+      Synchronize(MASSAI::trace::TraceInterface& trc);
+      ~Synchronize();
+
+      void setListener(WaitListener* pListener);
+      void add(WaitNotification* pNotification);
+      void remove(WaitNotification* pNotification);
+
+      // start listening thread, do not block
+      void startWait();
+      void cancelWait();
+
+      class Impl;
+
+    private:
+      Synchronize(const Synchronize&);
+      Synchronize& operator=(const Synchronize&);
+
+      pImplPtr<Impl> m_pImpl;
+  };
+
+  /*
+   *  wait for multiple WaitNotifications, upto 64 elements
+   */
+  class SimpleSynchronize
+  {
+    public:
+      SimpleSynchronize(MASSAI::trace::TraceInterface& trc);
+      ~SimpleSynchronize();
+
+      void add(WaitObject* pWait);
+      void remove(WaitObject* pWait);
+
+      // blocking wait
+      void wait(unsigned long time_ms);
+
+      class Impl;
+
+    private:
+      SimpleSynchronize(const SimpleSynchronize&);
+      SimpleSynchronize& operator=(const SimpleSynchronize&);
+
+      pImplPtr<Impl> m_pImpl;
+  };
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/systools/mSysTime.h b/SelfServiceCommon/Interfaces/inc/systools/mSysTime.h
new file mode 100644
index 00000000..7b0b099c
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/systools/mSysTime.h
@@ -0,0 +1,39 @@
+/**
+ * time; current time, system up time, sleep
+**/
+#ifndef MSYSTIME_H_INCLUDED
+#define MSYSTIME_H_INCLUDED
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+namespace mSysTime
+{
+  class Timestamp {
+    public:
+      int year;
+      int month;
+      int dayOfWeek;
+      int day;
+      int hour;
+      int minute;
+      int second;
+      int milliseconds;
+  };
+  class Duration
+  {
+    public:
+      int days;
+      int hours;
+      int minutes;
+      int seconds;
+      int milliseconds;
+  };
+  Timestamp getTimestamp();
+  unsigned long getUpTime();
+  Duration getDuration(unsigned long time_ms);
+  void sleep(unsigned long time_ms);
+}
+
+#endif
+
diff --git a/SelfServiceCommon/Interfaces/inc/systools/mSysWait.h b/SelfServiceCommon/Interfaces/inc/systools/mSysWait.h
new file mode 100644
index 00000000..1c75327f
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/systools/mSysWait.h
@@ -0,0 +1,27 @@
+/**
+ * wait for multiple objectes see systools/mSysSynchonize.h
+**/
+
+#ifndef MSYSWAIT_H_INCLUDED
+#define MSYSWAIT_H_INCLUDED
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+namespace mSysSynchronize
+{
+  /*
+   *  Internal data for synchronization
+   */
+  class Internal;
+
+  class WaitObject
+  {
+    public:
+      WaitObject();
+      virtual ~WaitObject();
+      virtual const Internal& getInternal() const = 0;
+  };
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/systools/mSysWindow.h b/SelfServiceCommon/Interfaces/inc/systools/mSysWindow.h
new file mode 100644
index 00000000..cb16bb89
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/systools/mSysWindow.h
@@ -0,0 +1,98 @@
+/**
+ * control windows of other processes
+**/
+
+#ifndef MSYSWINDOW_H_INCLUDED
+#define MSYSWINDOW_H_INCLUDED
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "systools/mSysProcess.hpp"
+#include "boost/shared_ptr.hpp"
+#include "tools/TraceInterface.h"
+#include <set>
+#include <list>
+#include <string>
+
+namespace mSysWindow
+{
+  /*
+   * control a window
+   */
+  class Window
+  {
+    public:
+      virtual ~Window();
+      virtual void activate()= 0;
+      virtual void show()= 0;
+      virtual void hide()= 0;
+      virtual void close()= 0;
+      virtual bool isVisible()= 0;
+      virtual bool isActive()= 0;
+      virtual std::string getTitle()= 0;
+      virtual std::string getClass()= 0;
+  };
+  /*
+   *  process (window owner)
+   */
+  class Process
+  {
+    public:
+      Process();
+      virtual ~Process();
+      virtual mSysProcess::child* getProcess()= 0;
+      virtual std::string getDesktop()= 0;
+      virtual bool match(Window& window)= 0;
+  };
+
+  typedef std::set<Process*> ProcessSet;
+  /*
+   * define a windows search
+   *   use desktop, processid
+   */
+  class WindowSearchData
+  {
+    public:
+      WindowSearchData();
+      ProcessSet processSet;
+      bool useProcessId;
+      bool useProcessDesktop;
+      std::string desktop;
+      bool useDesktop;
+  };
+  /*
+   *  user defined check
+   *    for windows search
+   */
+  class WindowSearchMatch
+  {
+    public:
+      virtual ~WindowSearchMatch();
+      virtual bool match(Window& window, Process* pProcess)= 0;
+  };
+
+  typedef boost::shared_ptr<Window> WindowPtr;
+  typedef std::list<WindowPtr> WindowList;
+
+  /*
+   * invoke windows search
+   */
+  class WindowSearch
+  {
+    public:
+      WindowSearch(const WindowSearchData& data, WindowSearchMatch& match,
+        MASSAI::trace::TraceInterface& trc);
+      ~WindowSearch();
+      void search();
+      const WindowList& getList() const;
+      WindowList& getList();
+
+      class Impl;
+
+    private:
+      pImplPtr<Impl> m_pImpl;
+  };
+}
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/BillingService/inc/BillingS_def.h b/SelfServiceCommon/Massai/cpp/BillingService/inc/BillingS_def.h
index 7810431a..8b686c42 100644
--- a/SelfServiceCommon/Massai/cpp/BillingService/inc/BillingS_def.h
+++ b/SelfServiceCommon/Massai/cpp/BillingService/inc/BillingS_def.h
@@ -1,6 +1,10 @@
 /*! \page billingservice Billing Service - Release Notes
  *
  *
+ *  \date 16.12.2011 \li V1.0.0.5
+ *                   \li SteT Mantis 0021947: mstarter: problems at shutdown
+ *                       shutdown on SIGBREAK, ignore CTRL_LOGOFF_EVENT
+ *
  *  \date 27.04.2006 \li V 1.0.0.4
  *                   \li SteT EDB 26755: BillingService parsed die Antwort vom GPP nicht
  *
@@ -13,8 +17,8 @@
  *
  */
 
-#define FILE_VER_BIN     1,0,0,4
-#define FILE_VER_STR     "FileVersion", "1.0.0.4\0"
+#define FILE_VER_BIN     1,0,0,5
+#define FILE_VER_STR     "FileVersion", "1.0.0.5\0"
 
 #define FILEDESCRIPTION  "FileDescription"  ,"Billing Service\0"
 #define INTERNALNAME     "InternalName"     ,"Billing Service\0"
diff --git a/SelfServiceCommon/Massai/cpp/BillingService/src/main.cpp b/SelfServiceCommon/Massai/cpp/BillingService/src/main.cpp
index 79d7a89b..74de57c1 100644
--- a/SelfServiceCommon/Massai/cpp/BillingService/src/main.cpp
+++ b/SelfServiceCommon/Massai/cpp/BillingService/src/main.cpp
@@ -9,74 +9,27 @@
 //---------------------------------------------------------------------------
 
 #include "massaidll/massai.hpp"
-#include "systools/eventSem.hpp"
+#include "systools/mEventSem.hpp"
 
 #include <winsock2.h>
-#include <signal.h>
 #include <iostream>
 
 #include "server.h"
 #include "trc/trace.h"
 #include "tools/log.h"
 #include "massaiCorba/corbasrvr.h"
+#include "systools/mEventSem.hpp"
+#include "systools/mSysProcessTerminate.h"
+#include "tools/TraceClient.h"
 
+using MASSAI::trace::TraceClient;
+using Materna::MSSD::eventSemaphore;
 
 extern char *getOutputPath();
 
-static eventSemaphore sem;
 
 static TCHAR szAppName[] = TEXT ("BillingInterface") ;
-static char szTmp[30];
 
-/*---------------------------------------------------------------------------
-
- FUNCTION:  VOID exitHandler(INT iSignal)
-
- COMMENTS:  Signal handler
-
- DATE:      04/11/97 - 11:58:33
-
- AUTHOR:    Dr. Materna GmbH   (AGe)
-
----------------------------------------------------------------------------*/
-
-static void exitHandler(int iSignal)
-{
-
-    switch(iSignal)
-    {
-    case SIGABRT:   strcpy(szTmp,"SIGABRT");  break;
-    case SIGBREAK:  strcpy(szTmp,"SIGBREAK"); break;
-    case SIGTERM:   strcpy(szTmp,"SIGTERM");  break;
-    case SIGINT:    strcpy(szTmp,"SIGINT");   break;
-
-    case SIGFPE:    strcpy(szTmp,"SIGFPE");   break;
-    case SIGSEGV:   strcpy(szTmp,"SIGSEGV");  break;
-    case SIGILL:    strcpy(szTmp,"SIGILL");   break;
-    }
-
-    switch(iSignal)
-    {
-    case SIGBREAK:
-      break;
-    default:
-      sem.post();
-    }
-
-    return;
-}
-
-void RegisterHandler()
-{
-    signal(SIGABRT, exitHandler);
-    signal(SIGBREAK,exitHandler);
-    signal(SIGTERM, exitHandler);
-    signal(SIGINT,  exitHandler);
-
-    signal(SIGSEGV, exitHandler);
-    signal(SIGILL,  exitHandler);
-    signal(SIGFPE,  exitHandler);
-}
 
 //---------------------------------------------------------------------------
 //
@@ -92,44 +45,40 @@ void RegisterHandler()
 
 int main(int argc, char** argv)
 {
+  TraceClient trc;
+  eventSemaphore sem;
   try
   {
     corbaServant<BillingServiceServant>* pServant= 0;
-
     openTrace("Billing");
-
-    strcpy(szTmp,"NOSIG");
-
-    RegisterHandler();
+    mSysProcessTerminate::setShutdownHook(mSysProcessTerminate::SHUTDOWN_LATE, &sem, &trc);
+    try
     {
-      try
-      {
-        BillingServiceServant billing;
-
-        TRACE(HERE_5,"BillingService started ...");
+      BillingServiceServant billing;
 
-        corbaServant<BillingServiceServant> srvnt (billing, "BillingService");
+      TRACE(HERE_5,"BillingService started ...");
 
-        std::cout << "output path = " << getOutputPath() << std::endl;
-        std::cout << "useLocalHost = " << KioskId::useLocalHost() << std::endl;
+      corbaServant<BillingServiceServant> srvnt (billing, "BillingService");
 
-        sem.wait();
-      }
-      catch(char *se)
-      {
-        TRACE(HERE_1,"(%.1000s)",se);
-        std::cout << se << std::endl;
-      }
+      std::cout << "output path = " << getOutputPath() << std::endl;
+      std::cout << "useLocalHost = " << KioskId::useLocalHost() << std::endl;
 
+      sem.wait();
       TRACE(HERE_1,"BillingService terminating");
     }
-
+    catch(char *se)
+    {
+      TRACE(HERE_1,"(%.1000s)",se);
+      std::cout << se << std::endl;
+    }
     TRACE(HERE_1,"BillingService terminated.");
   }
   catch(...)
   {
     std::cout << "Cannot create servant" << std::endl;
   }
+  mSysProcessTerminate::resetShutdownHook();
+  closeTrace();
 
   return(0);
 }
diff --git a/SelfServiceCommon/Massai/cpp/Controller/inc/control_common.h b/SelfServiceCommon/Massai/cpp/Controller/inc/control_common.h
new file mode 100644
index 00000000..b3c65e3c
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Controller/inc/control_common.h
@@ -0,0 +1,24 @@
+//---------------------------------------------------------------------------
+//
+//  file:       control_common.h
+//
+//  purpose:    common defines for mstarter/mcontrol
+//
+//---------------------------------------------------------------------------
+#ifndef CONTROL_COMMON_H_INCLUDED
+#define CONTROL_COMMON_H_INCLUDED
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include <windows.h>
+
+namespace mControl
+{
+  const char* mcontrolWindowClass = "MassaiController";
+  enum Consts {
+    WM_MCONTROL_PROGRESS = WM_USER + 10,
+  };
+}
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Controller/inc/mcontrol_def.h b/SelfServiceCommon/Massai/cpp/Controller/inc/mcontrol_def.h
index cf46fcac..3487ad73 100644
--- a/SelfServiceCommon/Massai/cpp/Controller/inc/mcontrol_def.h
+++ b/SelfServiceCommon/Massai/cpp/Controller/inc/mcontrol_def.h
@@ -12,12 +12,16 @@
 
 /*! \page mControl.exe - platform startup, starts mudpate.exe, mstarter.exe; servant for systemControl interface
  *
- *  @version 1.0.1.8
+ *  @version 1.0.2.0
  *
  *  \section change1 Change history
  *
+ *  \date 16.12.2011 \li V1.0.2.0
+ *                   \li SteT Mantis 0021947: mstarter: problems at shutdown
+ *                   progress bar: progress is calculated by mstarter
+ *
  *  \date 17.11.2011 \li V1.0.1.8
- *                   \li GiT: Mantis0021563: SelfServiceCommon Controller changes for VC10 compatibilty 
+ *                   \li GiT: Mantis0021563: SelfServiceCommon Controller changes for VC10 compatibilty
  *
  *  \date 17.11.2011 \li V1.0.1.7
  *                   \li JK: Mantis0021539: mcontrol not responding
@@ -178,8 +182,8 @@
 #define IDI_ICON1 101
 #define IDI_ICON2 102
 
-#define FILE_VER_BIN     1,0,1,8
-#define FILE_VER_STR     "FileVersion", "1.0.1.8\0"
+#define FILE_VER_BIN     1,0,2,0
+#define FILE_VER_STR     "FileVersion", "1.0.2.0\0"
 
 #define FILEDESCRIPTION  "FileDescription"  ,"mcontrol\0"
 #define INTERNALNAME     "InternalName"     ,"mcontrol\0"
diff --git a/SelfServiceCommon/Massai/cpp/Controller/inc/mstarter_args.h b/SelfServiceCommon/Massai/cpp/Controller/inc/mstarter_args.h
new file mode 100644
index 00000000..33184988
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Controller/inc/mstarter_args.h
@@ -0,0 +1,36 @@
+//---------------------------------------------------------------------------
+//
+//  file:       mstarter_args.h
+//
+//  purpose:    arguments for mstarter
+//
+//---------------------------------------------------------------------------
+#ifndef MSTARTER_ARGS_H_INCLUDED
+#define MSTARTER_ARGS_H_INCLUDED
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include <string>
+
+namespace mStarter
+{
+  /*
+    command line arguments for mstarter
+  */
+  class Arguments
+  {
+    public:
+      bool isServer;
+      bool createConfiguration;
+      int watchDogTimeout;
+      std::string stopSemaphore;
+      bool help;
+  };
+  /*
+    extract arguments from commandline
+  */
+  Arguments readArguments(int argc, const char** argv);
+}
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Controller/inc/mstarter_config.h b/SelfServiceCommon/Massai/cpp/Controller/inc/mstarter_config.h
new file mode 100644
index 00000000..a51ad945
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Controller/inc/mstarter_config.h
@@ -0,0 +1,65 @@
+//---------------------------------------------------------------------------
+//
+//  file:       mstarter_config.h
+//
+//  purpose:    configuration items for mstarter
+//
+//---------------------------------------------------------------------------
+#ifndef MSTARTER_CONFIG_H_INCLUDED
+#define MSTARTER_CONFIG_H_INCLUDED
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#pragma warning(disable:4786)
+
+#include "systools/mSysProcessList.h"
+#include "tools/TraceInterface.h"
+#include "systools/mMutexCS.h"
+
+#include <string>
+#include <memory>
+
+namespace mStarter
+{
+  /*
+    configuration items for mstarter
+  */
+  class ConfigHardwareList;
+  class ConfigSoftwareList;
+  class ConfigListenOnChange;
+  class ConfigExecList;
+  class ConfigTimeout;
+
+  class Config: public mSysProcess::ProcessListSettings
+  {
+    public:
+      Config(MASSAI::trace::TraceInterface& trc, bool serverMode, int watchDog);
+      ~Config();
+
+      void setListener(mSysProcess::ProcessList* pListener);
+      bool isServer() const;
+      virtual mSysProcess::PropertyList getProcessList() const;
+      mSysProcess::WatchdogSettings getWatchdogSettings() const;
+      virtual void valueChanged(const std::string& item);
+
+    private:
+      typedef std::auto_ptr<ConfigHardwareList> ConfigHardwareListPtr;
+      typedef std::auto_ptr<ConfigSoftwareList> ConfigSoftwareListPtr;
+      typedef std::auto_ptr<ConfigListenOnChange> ConfigListenOnChangePtr;
+      typedef std::auto_ptr<ConfigExecList> ConfigExecListPtr;
+      typedef std::auto_ptr<ConfigTimeout> ConfigTimeoutPtr;
+
+      MASSAI::trace::TraceInterface& m_trc;
+      bool m_server;
+      int m_watchDog;
+      Materna::MSSD::Mutex m_accessListener;
+      mSysProcess::ProcessList* m_pListener;
+      ConfigHardwareListPtr m_hardwareList;
+      ConfigSoftwareListPtr m_softwareList;
+      ConfigListenOnChangePtr m_listenOnChange;
+      ConfigExecListPtr m_execList;
+      ConfigTimeoutPtr m_timeout;
+  };
+}
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Controller/inc/mstarter_def.h b/SelfServiceCommon/Massai/cpp/Controller/inc/mstarter_def.h
index 5e207698..7dd32d05 100644
--- a/SelfServiceCommon/Massai/cpp/Controller/inc/mstarter_def.h
+++ b/SelfServiceCommon/Massai/cpp/Controller/inc/mstarter_def.h
@@ -12,12 +12,44 @@
 
 /*! \page massaistarter mStarter - Release Notes
  *
- *  @version 1.1.0.7
+ *  @version 1.1.1.0
  *
  *  \section change1 Change history
  *
+ *  \date 16.12.2011 \li V1.1.1.0
+ *                   \li SteT Mantis 0021947: mstarter: problems at shutdown
+ *
+ *     fixed problems in mstarter:
+ *           - listenOnChange can be activated without restarting mstarter:
+ *              listen on items:
+ *                SERVICES.STARTER.listenOnConfigChange
+ *                PLATFORM.HARDWARE.Devices
+ *                PLATFORM.SOFTWARE.Services
+ *                PLATFORM.EXEC.*
+ *           - listenOnChange works for processes without configured WND
+ *               send ctrl-break to console applications (console ist started as new process group)
+ *               first close visible windows and then all windows for process without option WND
+ *           - option WNDCLASS added for PLATFORM.EXEC.* items to find process main window by class
+ *           - mstarter arguments changed:
+ *               WatchDog-Timeout must be set with ":"
+ *               semaphore name is optional, if not set mstarter waits for ctrl-c, ctrl-break
+ *               mstarter.exe [<StopSemaphoreName>][-server][-cfg][-watchDog:<ms>]
+ *                 StopSemaphoreName: name of event semaphore, posted to stop
+ *                 server: start in server mode
+ *                 cfg: create configuraton items
+ *                 watchdog: timeout for restart of processes; -1 deactivates restart
+ *           - watchdog:
+ *                process are watched all the time
+ *                more information of a process are printed at process terminated
+ *           - shutdown:
+ *                when all processes are terminated, mstarter terminated
+ *                mstarter can be stopped while starting processes
+ *           - progress bar:
+ *                progress is calculated by mstarter; depends on mcontrol V1.0.2.0
+ *
+ *
  *  \date 17.11.2011 \li V1.1.0.8
- *                   \li GiT: Mantis0021563: SelfServiceCommon Controller changes for VC10 compatibilty 
+ *                   \li GiT: Mantis0021563: SelfServiceCommon Controller changes for VC10 compatibilty
  *
  *  \date 12.09.2011 \li V 1.1.0.7
  *                   \li GiT: Mantis0014919: placeholder for system paths
@@ -88,8 +120,8 @@
 #define IDI_ICON1 101
 #define IDI_ICON2 102
 
-#define FILE_VER_BIN     1,1,0,8
-#define FILE_VER_STR     "FileVersion", "1.1.0.8\0"
+#define FILE_VER_BIN     1,1,1,0
+#define FILE_VER_STR     "FileVersion", "1.1.1.0\0"
 
 #define FILEDESCRIPTION  "FileDescription"  ,"mstarter\0"
 #define INTERNALNAME     "InternalName"     ,"mstarter\0"
diff --git a/SelfServiceCommon/Massai/cpp/Controller/inc/mstarter_notify.h b/SelfServiceCommon/Massai/cpp/Controller/inc/mstarter_notify.h
new file mode 100644
index 00000000..5d9b9a17
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Controller/inc/mstarter_notify.h
@@ -0,0 +1,40 @@
+//---------------------------------------------------------------------------
+//
+//  file:       mstarter_notify.h
+//
+//  purpose:    mstarter sends windows messages to mcontrol
+//
+//---------------------------------------------------------------------------
+#ifndef MSTARTER_NOTIFY_H_INCLUDED
+#define MSTARTER_NOTIFY_H_INCLUDED
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "systools/mSysProcessList.h"
+#include "tools/TraceInterface.h"
+
+namespace mStarter
+{
+  /*
+    command line arguments for mstarter
+  */
+  class Notifier: public mSysProcess::ProcessListCallback
+  {
+    public:
+      Notifier(MASSAI::trace::TraceInterface& trc);
+      virtual ~Notifier();
+      virtual void start(const mSysProcess::PropertyList& processes);
+      virtual void started(const mSysProcess::ProcessProperties& process);
+      virtual void terminated(const mSysProcess::ProcessProperties& process);
+
+    private:
+      void notify();
+
+      int m_processCount;
+      int m_started;
+      MASSAI::trace::TraceInterface& m_trc;
+  };
+}
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Controller/makefile.mak b/SelfServiceCommon/Massai/cpp/Controller/makefile.mak
index fac9f83b..2ce37554 100644
--- a/SelfServiceCommon/Massai/cpp/Controller/makefile.mak
+++ b/SelfServiceCommon/Massai/cpp/Controller/makefile.mak
@@ -67,27 +67,6 @@ MY_BIN1_GEN_DIRS = \
 
 ######################################################################
 
-MY_BIN2 = \
-    $(_BIN)\mStarter.exe
-
-MY_BIN2_RES = \
-    $(_OBJ)\mstarter.res
-
-MY_BIN2_OBJS = \
-    $(_OBJ)\starter.obj
-
-MY_BIN2_USER_LIBS = \
-    $(LIB_TEXT) \
-    $(STDUSERLIBS)
-
-MY_BIN2_LINKLIBS = \
-    $(STDLINKLIBS)
-
-MY_BIN2_LDFLAGS = \
-    -subsystem:console
-
-######################################################################
-
 MY_BIN3 = \
     $(_BIN)\mControlClient.exe
 
@@ -112,4 +91,29 @@ MY_BIN3_GEN_DIRS = \
 
 ######################################################################
 
+MY_BIN4 = \
+    $(_BIN)\mStarter.exe
+
+MY_BIN4_RES = \
+    $(_OBJ)\mstarter.res
+
+MY_BIN4_OBJS = \
+    $(_OBJ)\mstarter.obj\
+    $(_OBJ)\mstarter_config.obj\
+    $(_OBJ)\mstarter_notify.obj\
+    $(_OBJ)\mstarter_args.obj
+
+MY_BIN4_USER_LIBS = \
+    $(LIB_TEXT) \
+    $(LIB_SYSTOOLS) \
+    $(LIB_TOOLS) \
+    $(STDUSERLIBS)
+
+MY_BIN4_LINKLIBS = \
+    $(STDLINKLIBS)
+
+MY_BIN4_LDFLAGS = \
+    -subsystem:console
+
+######################################################################
 !include $(BUILDROOT)\Build\cpp\makefile.rules.mak
diff --git a/SelfServiceCommon/Massai/cpp/Controller/src/mstarter.cpp b/SelfServiceCommon/Massai/cpp/Controller/src/mstarter.cpp
new file mode 100644
index 00000000..22d32cd9
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Controller/src/mstarter.cpp
@@ -0,0 +1,93 @@
+#include "mstarter_args.h"
+#include "mstarter_config.h"
+#include "mstarter_notify.h"
+#include "systools/mEventSem.hpp"
+#include "systools/mSysException.hpp"
+#include "systools/mSysProcessTerminate.h"
+#include "systools/mSysProcessList.h"
+#include "tools/TraceClient.h"
+#include "trc/trace.h"
+#include "mcontrol_def.h"
+
+#include <iostream>
+
+using MASSAI::trace::TraceClient;
+using mSysException::standardException;
+using mSysProcess::ProcessList;
+
+using namespace Materna::MSSD;
+using namespace mStarter;
+
+namespace
+{
+  void log(long level, const char* file, short line, const char* function, const char* text)
+  {
+    writeTraceText(level, file, line, function, text);
+    std::cout << text << std::endl;
+  }
+}
+
+int main(int argc, const char** argv)
+{
+  standardException guard;
+  eventSemaphore terminate;
+  TraceClient trc;
+  try
+  {
+    openTrace("mStarter");
+    writeTrace(HERE, "Version (%d.%d.%d.%d, %s, %s)",
+      FILE_VER_BIN,
+      __DATE__,
+      __TIME__);
+
+    mSysProcessTerminate::setShutdownHook(mSysProcessTerminate::SHUTDOWN_LATE, &terminate, &trc);
+    Arguments args= readArguments(argc, argv);
+    Notifier notifyMControl(trc);
+    Config config(trc, args.isServer, args.watchDogTimeout);
+    ProcessList processList(trc, config.getWatchdogSettings());
+    config.setListener(&processList);
+    processList.setListener(&notifyMControl);
+
+    if(args.help)
+    {}
+    else if(args.createConfiguration)
+    {
+      log(BasicRuntime_HERE, "create configuration");
+      config.getProcessList();
+    }
+    else
+    {
+      processList.start(&config);
+      if(args.stopSemaphore.size() > 0)
+      {
+        eventSemaphore sem(SEM_OPEN, SEM_RAW_NAME, args.stopSemaphore.c_str());
+        log(BasicRuntime_HERE, "wait for semaphore");
+        sem.wait();
+      }
+      else
+      {
+        log(BasicRuntime_HERE, "wait for ctrl-c");
+        terminate.wait();
+      }
+      log(BasicRuntime_HERE, "terminating...");
+      config.setListener(0);
+      processList.stop();
+      log(BasicRuntime_HERE, "terminating done.");
+    }
+  }
+  catch(const eventSemaphore_Exception&)
+  {
+    log(MajorError_HERE, "open semaphore failed");
+  }
+  catch(const std::exception& x)
+  {
+    log(MajorError_HERE, x.what());
+  }
+  catch(...)
+  {
+    log(MajorError_HERE, "unknown exception");
+  }
+  mSysProcessTerminate::resetShutdownHook();
+  closeTrace();
+  return 0;
+}
diff --git a/SelfServiceCommon/Massai/cpp/Controller/src/mstarter_args.cpp b/SelfServiceCommon/Massai/cpp/Controller/src/mstarter_args.cpp
new file mode 100644
index 00000000..488964a5
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Controller/src/mstarter_args.cpp
@@ -0,0 +1,70 @@
+//---------------------------------------------------------------------------
+//
+//  file:       mstarter_args.cpp
+//
+//  purpose:    arguments for mstarter
+//
+//---------------------------------------------------------------------------
+
+#include "mstarter_args.h"
+#include "text/mArgScan.hpp"
+#include "trc/trace.h"
+
+#include <iostream>
+
+namespace
+{
+  enum Consts
+  {
+    DEFAULT_WATCHDOG_POLLTIME= 1000,
+  };
+
+  void ignoredArgument(const char* argument)
+  {
+    writeTrace(BasicRuntime_HERE, "argument: %s ignored", argument);
+  }
+  void usage(int argc, const char** argv)
+  {
+    std::cout << "Usage: " << argv[0] << " <StopSemaphoreName> [-server][-cfg][-watchdog:<timeout>] " << std::endl;
+    std::cout << "StopSemaphoreName: name of event semaphore, posted to stop " << argv[0] << std::endl;
+    std::cout << "server: start in server mode" << std::endl;
+    std::cout << "cfg: create configuraton items" << std::endl;
+    std::cout << "watchdog: timeout for restart of processes; -1 deactivates restart" << std::endl;
+  }
+  const char* boolText(bool val)
+  {
+    return val?"true":"false";
+  }
+}
+
+namespace mStarter
+{
+  Arguments readArguments(int argc, const char** argv)
+  {
+    Arguments result;
+    argScan args(argc, argv);
+    args.tellIgnored(ignoredArgument);
+    result.isServer=            args.option("SERVER") != 0;
+    result.createConfiguration= args.option("CFG") != 0;
+    result.watchDogTimeout=     args.optionInteger("WATCHDOG", DEFAULT_WATCHDOG_POLLTIME);
+    result.help=                args.help() != 0;
+    const char* pszSemaphore=   args.argument(1);
+    if(pszSemaphore)
+    {
+      result.stopSemaphore = pszSemaphore;
+    }
+    if(result.help)
+    {
+      usage(argc, argv);
+    }
+    writeTrace(BasicRuntime_HERE,
+      "hlp(%s) srv(%s) cfg(%s) watchdog(%d) sem(%s)",
+      boolText(result.help),
+      boolText(result.isServer),
+      boolText(result.createConfiguration),
+      result.watchDogTimeout,
+      result.stopSemaphore.c_str()
+    );
+    return result;
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/Controller/src/mstarter_config.cpp b/SelfServiceCommon/Massai/cpp/Controller/src/mstarter_config.cpp
new file mode 100644
index 00000000..22671a67
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Controller/src/mstarter_config.cpp
@@ -0,0 +1,511 @@
+//---------------------------------------------------------------------------
+//
+//  file:       mstarter_config.cpp
+//
+//  purpose:    configuration items for mstarter
+//
+//---------------------------------------------------------------------------
+
+#include "mstarter_config.h"
+#include "cfgclnt/nConfigSelection.hpp"
+#include "cfgclnt/nConfigNumber.hpp"
+#include "cfgclnt/nConfigTextList.hpp"
+#include "cfgclnt/nConfigBasicTextList.hpp"
+#include "boost/shared_ptr.hpp"
+#include "boost/regex.hpp"
+#include "text/cEnvSubst.hpp"
+#include "systools/mAutoMutexCS.h"
+#include "trc/trace.h"
+#include <map>
+
+
+using boost::smatch;
+using boost::regex_search;
+using boost::regex;
+using boost::regbase;
+using nConfig::gclTextList;
+using nConfig::gclSelection;
+using nConfig::gcNumber;
+using nConfig::selection;
+using mSysProcess::ProcessProperties;
+using mSysProcess::ProcessList;
+using mSysProcess::PropertyList;
+using namespace mStarter;
+using mSysProcess::WatchdogSettings;
+using Materna::MSSD::Mutex;
+using Materna::MSSD::AutoMutexCS;
+
+namespace
+{
+  const std::string hardwareItem=       "PLATFORM.HARDWARE.Devices";
+  const std::string softwareItem=       "PLATFORM.SOFTWARE.Services";
+  const std::string timeoutItem=        "PLATFORM.TIMEOUTS.WaitForProcessTermination";
+  const std::string execSection=        "PLATFORM.EXEC.";
+  const std::string listenOnChangeItem= "SERVICES.STARTER.listenOnConfigChange";
+  const std::string platformItem=       "Platform";
+  const std::string configUser=         "mstarter";
+  const selection boolSelection[]= {selection(0, "no", ""), selection(1, "yes", "")};
+  const regex option_pattern
+  (
+    "WND *= *\"([^\"]+)\""
+    "|WNDCLASS *= *\"([^\"]+)\""
+    "|CWD *= *\"([^\"]+)\""
+    "|(?:SHOW *= *(YES)|(NO)|(HIDE)|(MINIMIZED))"
+    "|(?:WAIT *= *([0-9]+)|(terminate))"
+    "|(SHOW)",
+    regbase::normal | regbase::icase
+  );
+  enum OptionIndex
+  {
+    OPT_TITLE= 1,
+    OPT_CLASS,
+    OPT_WORKING_DIR,
+    OPT_SHOW_YES,
+    OPT_SHOW_NO,
+    OPT_SHOW_HIDE,
+    OPT_SHOW_MINIMIZED,
+    OPT_WAIT,
+    OPT_TERMINATE,
+    OPT_SHOW_SHOW,
+  };
+
+  typedef std::list<std::string> TextList;
+  /*
+    base class for config items
+  */
+  class ConfigItemBase
+  {
+    public:
+      ConfigItemBase(const std::string& item);
+      void configChanged();
+      bool isServer() const;
+      void setConfig(Config* config);
+      Config* getConfig() const;
+    private:
+      Config* m_config;
+      std::string m_item;
+  };
+  /*
+    config item exec
+  */
+  class ConfigExec: public ConfigItemBase, public gclTextList
+  {
+    public:
+      ConfigExec(const std::string& item);
+      TextList getValue() const;
+      virtual void valueChanged();
+    private:
+      void create(const char const*& rights, const char*& explanation, TextList& defaultValue, long& max);
+  };
+  typedef boost::shared_ptr<ConfigExec> ConfigExecPtr;
+  typedef std::map<std::string, ConfigExecPtr> ExecMap;
+
+  /*
+    base class for config items
+  */
+  ConfigItemBase::ConfigItemBase(const std::string& item):
+    m_item(item)
+  {}
+  void ConfigItemBase::configChanged()
+  {
+    m_config->valueChanged(m_item);
+  }
+  bool ConfigItemBase::isServer() const
+  {
+    return m_config->isServer();
+  }
+  Config* ConfigItemBase::getConfig() const
+  {
+    return m_config;
+  }
+  void ConfigItemBase::setConfig(Config* config)
+  {
+    m_config= config;
+  }
+
+  /*
+    config item exec
+  */
+  ConfigExec::ConfigExec(const std::string& item):
+    ConfigItemBase(item),
+    gclTextList(item.c_str(), configUser.c_str())
+  {}
+  TextList ConfigExec::getValue() const
+  {
+    return get();
+  }
+  void ConfigExec::valueChanged()
+  {
+    configChanged();
+  }
+  void ConfigExec::create(const char*& rights, const char*& explanation, TextList& defaultValue, long& max)
+  {
+    rights = "rwl";
+    max= 9000;
+    explanation =
+      "List of executables depending on Hardware Devices and Software Services.\n"
+      "Example: c:\\massai-1.0\\program.exe param1 param2 ...; [options]\n"
+      "  quote the parameters with \", if a parameter contains \\ or \","
+      " or if the path of the executables contains a space\n"
+      "    Example: c:\\massai-1.0\\program.exe \"param1 param2 ...\"; [options]\n"
+      "  change the delimiter if ; is used in the options\n"
+      "    Example: : c:\\massai-1.0\\program.exe param1 param2 ...: [options]\n"
+      "Options: (please separate all options by comma or blank)\n"
+      "wnd = \"window name\" - specifies the window name of the process used for process shutdown.\n"
+      "wndclass = \"window class\" - specifies the window class of the process used for process shutdown.\n"
+      "cwd = \"current working directory\" - sets the current working directory for the created process.\n"
+      "wait = [milliseconds | terminate] - MILLISECONDS specifies a pause"
+      " after creating the process, TERMINATE waits until the process terminates.\n"
+      "show = [yes | no | hide | minimized] - specifies how the process window is shown"
+      "The following substitution environment variables are supported:"
+      "$PROGRAMFILES, $SYSTEMROOT, $SYSTEMDRIVE";
+  }
+  void extractExec(const std::string& input, char delimiter, std::string& commandLine, std::string& options)
+  {
+    std::string::size_type pos= input.rfind(delimiter);
+    if(pos != std::string::npos)
+    {
+      commandLine= std::string(input, 0, pos);
+      options= std::string(input, pos + 1, input.size() - pos - 1);
+    }
+    else
+    {
+      commandLine= input;
+    }
+  }
+  ProcessProperties getProperties(const std::string& group, const std::string& input)
+  {
+    ProcessProperties result;
+    result.group= group;
+    std::string options;
+    if(input.size() > 1 && input[0] > ' ' && input[1] == ' ')
+    {
+      extractExec(std::string(input, 2, input.size() - 2), input[0], result.commandLine, options);
+    }
+    else
+    {
+      extractExec(input, ';', result.commandLine, options);
+    }
+    if(options.size() > 0)
+    {
+      smatch parsed;
+      std::string::const_iterator position= options.begin();
+      std::string::const_iterator end= options.end();
+      while(regex_search(position, end, parsed, option_pattern))
+      {
+        if(parsed[OPT_TITLE].matched)                // WND="([^"]+)"
+        {
+          result.windowTitle = parsed[OPT_TITLE];
+        }
+        else if(parsed[OPT_CLASS].matched)           // WNDCLASS="([^"]+)"
+        {
+          result.windowClass= parsed[OPT_CLASS];
+        }
+        else if(parsed[OPT_WORKING_DIR].matched)     // CWD="([^"]+)"
+        {
+          result.workingDir= parsed[OPT_WORKING_DIR];
+        }
+        else if(parsed[OPT_SHOW_YES].matched         // SHOW=(YES)
+          || parsed[OPT_SHOW_SHOW].matched)          // (SHOW)
+        {
+          result.show = mSysProcess::SHOW;
+        }
+        else if(parsed[OPT_SHOW_NO].matched          // SHOW=(NO)
+         ||parsed[OPT_SHOW_HIDE].matched)            // SHOW=(HIDE)
+        {
+          result.show = mSysProcess::HIDE;
+        }
+        else if(parsed[OPT_SHOW_MINIMIZED].matched)  // SHOW=(MINIMIZED)
+        {
+          result.show = mSysProcess::MINIMIZED;
+        }
+        else if(parsed[OPT_TERMINATE].matched)       // WAIT=(terminate)
+        {
+          result.timeout= -1;
+        }
+        else if(parsed[OPT_WAIT].matched)            // WAIT=([0-9]+)
+        {
+          result.timeout= atol(std::string(parsed[OPT_WAIT]).c_str());
+        }
+        position= parsed[0].second;
+      }
+    }
+    return result;
+  }
+}
+
+namespace mStarter
+{
+  /*
+    config item hardware list
+  */
+  class ConfigHardwareList: public ConfigItemBase, public gclTextList
+  {
+    public:
+      ConfigHardwareList();
+      void appendTo(TextList& items) const;
+      virtual void valueChanged();
+    private:
+      void create(const char*& rights, const char*& explanation, TextList& defaultValue, long& max);
+  };
+  /*
+    config item software list
+  */
+  class ConfigSoftwareList: public ConfigItemBase, public gclTextList
+  {
+    public:
+      ConfigSoftwareList();
+      void appendTo(TextList& items) const;
+      virtual void valueChanged();
+    private:
+      void create(const char*& rights, const char*& explanation, TextList& defaultValue, long& max);
+  };
+  /*
+    config item listen on change
+  */
+  class ConfigListenOnChange: public ConfigItemBase, public gclSelection
+  {
+    public:
+      ConfigListenOnChange();
+      bool getValue() const;
+      virtual void valueChanged();
+    private:
+      void create(const char*& rights, const char*& explanation,
+        long& defaultIndex, const selection*& begin, const selection*& end);
+  };
+  /*
+    config items termination timeout
+  */
+  class ConfigTimeout: public ConfigItemBase, public nConfig::gcNumber
+  {
+    public:
+      ConfigTimeout();
+      int getValue() const;
+    private:
+      void create(const char*& rights, const char*& explanation, long& defaultValue, long& min, long& max);
+  };
+  /*
+    config items exec
+  */
+  class ConfigExecList: public ConfigItemBase
+  {
+    public:
+      ConfigExecList();
+      TextList getValue(const std::string& item);
+    private:
+      ExecMap m_execMap;
+      CEnvSubst m_substituteEnv;
+  };
+  /*
+    config item hardware list
+  */
+  ConfigHardwareList::ConfigHardwareList():
+    ConfigItemBase(hardwareItem),
+    gclTextList(hardwareItem.c_str(), configUser.c_str())
+  {}
+  void ConfigHardwareList::appendTo(TextList& items) const
+  {
+    TextList list= get();
+    items.insert(items.end(), list.begin(), list.end());
+  }
+  void ConfigHardwareList::create(const char*& rights, const char*& explanation, TextList& defaultValue, long& max)
+  {
+    rights = "rwl";
+    explanation = "List of platform hardware devices.";
+    max= 1023;
+    if(isServer())
+    {
+      defaultValue.push_back("ATB");
+      defaultValue.push_back("BTP");
+      defaultValue.push_back("CRD");
+      defaultValue.push_back("SEL");
+    }
+  }
+  void ConfigHardwareList::valueChanged()
+  {
+    configChanged();
+  }
+  /*
+    config item software list
+  */
+  ConfigSoftwareList::ConfigSoftwareList():
+    ConfigItemBase(softwareItem),
+    gclTextList(softwareItem.c_str(), configUser.c_str())
+  {}
+  void ConfigSoftwareList::appendTo(TextList& items) const
+  {
+    TextList list= get();
+    items.insert(items.end(), list.begin(), list.end());
+  }
+  void ConfigSoftwareList::create(const char*& rights, const char*& explanation, TextList& defaultValue, long& max)
+  {
+    rights = "rwl";
+    explanation = "List of platform software services.";
+    max= 1023;
+    if(isServer())
+    {
+      defaultValue.push_back("LOGGING");
+      defaultValue.push_back("BILLING");
+      defaultValue.push_back("STATISTICS");
+      defaultValue.push_back("ABLSCTRL");
+    }
+    else
+    {
+      defaultValue.push_back("LOG");
+    }
+  }
+  void ConfigSoftwareList::valueChanged()
+  {
+    configChanged();
+  }
+  /*
+    config item listen on change
+  */
+  ConfigListenOnChange::ConfigListenOnChange():
+    ConfigItemBase(listenOnChangeItem),
+    gclSelection(listenOnChangeItem.c_str(), configUser.c_str())
+  {}
+  bool ConfigListenOnChange::getValue() const
+  {
+    return getIndex() == 1;
+  }
+  void ConfigListenOnChange::create(const char const*& rights, const char*& explanation,
+    long& defaultIndex, const selection*& begin, const selection*& end)
+  {
+    rights = "rwl";
+    explanation = "Should the starter listen on the hardware and software component std::list \r\n"
+                  "and start or stop the modified processes";
+    defaultIndex= 0; // no
+    begin = boolSelection;
+    end = boolSelection + sizeof(boolSelection)/sizeof(*boolSelection);
+  }
+  void ConfigListenOnChange::valueChanged()
+  {
+    configChanged();
+  }
+  /*
+    config items termination timeout
+  */
+  ConfigTimeout::ConfigTimeout():
+    ConfigItemBase(timeoutItem),
+    gcNumber(timeoutItem.c_str(), configUser.c_str())
+  {}
+  int ConfigTimeout::getValue() const
+  {
+    return get();
+  }
+  void ConfigTimeout::create(const char*& rights, const char*& explanation,
+    long& defaultValue, long& min, long& max)
+  {
+    rights = "rwl";
+    explanation = "Specifies how long to wait (in seconds) after platform shutdown notification.";
+    defaultValue = 30;
+    min = 0;
+    max = 3600;
+  }
+  /*
+    config items exec
+  */
+  ConfigExecList::ConfigExecList():
+    ConfigItemBase(execSection),
+    m_execMap(),
+    m_substituteEnv()
+  {
+    m_substituteEnv.SetBaseEnvVars();
+  }
+  TextList ConfigExecList::getValue(const std::string& item)
+  {
+    ExecMap::iterator it= m_execMap.find(item);
+    if(it == m_execMap.end())
+    {
+      ConfigExecPtr ptr= ConfigExecPtr(new ConfigExec(execSection + item));
+      ptr->setConfig(getConfig());
+      it= m_execMap.insert(ExecMap::value_type(item, ptr)).first;
+    }
+    return m_substituteEnv.substEnvList(it->second->getValue());
+  }
+  /*
+    access configuration items for mstarter
+  */
+  Config::Config(MASSAI::trace::TraceInterface& trc, bool serverMode, int watchDog):
+    m_trc(trc),
+    m_server(serverMode),
+    m_watchDog(watchDog),
+    m_accessListener(),
+    m_pListener(0),
+    m_hardwareList(ConfigHardwareListPtr(new ConfigHardwareList())),
+    m_softwareList(ConfigSoftwareListPtr(new ConfigSoftwareList())),
+    m_listenOnChange(ConfigListenOnChangePtr(new ConfigListenOnChange())),
+    m_execList(ConfigExecListPtr(new ConfigExecList())),
+    m_timeout(ConfigTimeoutPtr(new ConfigTimeout()))
+  {
+    m_hardwareList->setConfig(this);
+    m_softwareList->setConfig(this);
+    m_listenOnChange->setConfig(this);
+    m_execList->setConfig(this);
+    m_timeout->setConfig(this);
+  }
+  void Config::setListener(mSysProcess::ProcessList* pListener)
+  {
+    AutoMutexCS mx(m_accessListener);
+    m_pListener = pListener;
+  }
+  Config::~Config()
+  {}
+  PropertyList Config::getProcessList() const
+  {
+    TextList components;
+    m_softwareList->appendTo(components);
+    components.push_back("Platform");
+    m_hardwareList->appendTo(components);
+
+    PropertyList result;
+    TextList::const_iterator it = components.begin();
+    TextList::const_iterator end = components.end();
+    for(; it != end; it++)
+    {
+      const std::string& component = *it;
+      TextList exec= m_execList->getValue(component);
+      TextList::const_iterator it2 = exec.begin();
+      TextList::const_iterator end2 = exec.end();
+      for(; it2 != end2; it2++)
+      {
+        result.push_back(getProperties(component, (*it2)));
+      }
+    }
+    return result;
+  }
+  WatchdogSettings Config::getWatchdogSettings() const
+  {
+    WatchdogSettings result;
+    result.waitTimeout = m_timeout->getValue() * 1000;
+    result.useWatchDog = m_watchDog > 0;
+    if(result.useWatchDog)
+    {
+      result.resetMin     = m_watchDog;
+      result.resetMax     = m_watchDog * 256;
+      result.resetRecover = m_watchDog * 256;
+    }
+    else
+    {
+      result.resetMin     = -1;
+      result.resetMax     = -1;
+      result.resetRecover = -1;
+    }
+
+    return result;
+  }
+  void Config::valueChanged(const std::string& item)
+  {
+    m_trc.writeTrace(BasicRuntime_HERE, "valueChanged (%s)", item.c_str());
+    AutoMutexCS mx(m_accessListener);
+    if(m_listenOnChange->getValue() && m_pListener)
+    {
+      m_pListener->checkProcessList();
+    }
+  }
+  bool Config::isServer() const
+  {
+    return m_server;
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/Controller/src/mstarter_notify.cpp b/SelfServiceCommon/Massai/cpp/Controller/src/mstarter_notify.cpp
new file mode 100644
index 00000000..65e32c43
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Controller/src/mstarter_notify.cpp
@@ -0,0 +1,98 @@
+//---------------------------------------------------------------------------
+//
+//  file:       mstarter_notify.cpp
+//
+//  purpose:    mstarter sends windows messages to mcontrol
+//
+//---------------------------------------------------------------------------
+#include "mstarter_notify.h"
+#include "control_common.h"
+#include <windows.h>
+
+using mSysProcess::ProcessProperties;
+using mSysProcess::PropertyList;
+using mSysProcess::ProcessListCallback;
+using MASSAI::trace::TraceInterface;
+
+namespace
+{
+  HWND mcontrol_hwnd = 0;
+  std::string getErrorText(unsigned long errorCode)
+  {
+    std::string result;
+    LPVOID buf;
+    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
+      | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
+      NULL, errorCode & 0xFFFF, 0, reinterpret_cast<LPTSTR>(&buf), 0, NULL);
+    if(buf != 0)
+    {
+      result= reinterpret_cast<const char*>(buf);
+    }
+    LocalFree(buf);
+    return result;
+  }
+  void notifyMControl(TraceInterface& trc, int started, int total)
+  {
+    if(!mcontrol_hwnd)
+    {
+      mcontrol_hwnd = FindWindow(0, mControl::mcontrolWindowClass);
+      if(!mcontrol_hwnd)
+      {
+        unsigned long code = GetLastError();
+        if(code != 0)
+        {
+          trc.writeTrace(MajorError_HERE, "FindWindow failed: (%d), (%s)", code, getErrorText(code).c_str());
+        }
+      }
+    }
+    if(mcontrol_hwnd)
+    {
+      if(!PostMessage(mcontrol_hwnd, mControl::WM_MCONTROL_PROGRESS, total, started))
+      {
+        unsigned long code = GetLastError();
+        trc.writeTrace(MajorError_HERE, "PostMessage failed: (%d), (%s)", code, getErrorText(code).c_str());
+      }
+    }
+  }
+}
+
+namespace mStarter
+{
+  /*
+    command line arguments for mstarter
+  */
+  Notifier::Notifier(TraceInterface& trc):
+    m_processCount(0),
+    m_started(0),
+    m_trc(trc)
+  {}
+  Notifier::~Notifier()
+  {}
+  void Notifier::start(const PropertyList& processes)
+  {
+    if(processes.size() > 0)
+    {
+      m_processCount= processes.size();
+      notify();
+    }
+  }
+  void Notifier::started(const ProcessProperties& process)
+  {
+    m_started++;
+    notify();
+  }
+  void Notifier::terminated(const ProcessProperties& process)
+  {
+    m_started--;
+    if(process.timeout < 0)
+    {
+      m_processCount--;
+    }
+    notify();
+  }
+  void Notifier::notify()
+  {
+    m_trc.writeTrace(BasicRuntime_HERE, "Started: (%d)/(%d)", m_started, m_processCount);
+    notifyMControl(m_trc, m_started, m_processCount);
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/Controller/src/serverwin.cpp b/SelfServiceCommon/Massai/cpp/Controller/src/serverwin.cpp
index 601cdace..70e9d668 100644
--- a/SelfServiceCommon/Massai/cpp/Controller/src/serverwin.cpp
+++ b/SelfServiceCommon/Massai/cpp/Controller/src/serverwin.cpp
@@ -32,6 +32,8 @@
 #include "systools/mEventSem.hpp"
 #include "systools/mSysProcess.hpp"
 
+#include "control_common.h"
+
 #include <commctrl.h>
 #include <list>
 #include <dbt.h>
@@ -53,6 +55,8 @@
 
 static HANDLE  hSem     = NULL;
 
+using namespace mControl;
+
 
 /**
  *
@@ -925,6 +929,25 @@ INITCOMMONCONTROLSEX iccex;
           return(0);
           break;
 
+     case WM_MCONTROL_PROGRESS:
+          TRACE(SecondaryRuntime_HERE,"WndProc WM_MCONTROL_PROGRESS");
+          if(wParam)
+          {
+            lAllProcesses = wParam;
+          }
+          lCurrentProcesses = lParam;
+          TRACE(HERE_9,"Processbar: all = %d, current = %d", lAllProcesses, lCurrentProcesses);
+          if(lAllProcesses)
+          {
+            flTmp = (float)lCurrentProcesses/(float)lAllProcesses;
+            lCurrLoadPercent = (long)(flTmp *100);
+            SendMessage(hwndLoad,PBM_SETPOS,lCurrLoadPercent,0);
+            UpdateWindow(hwndLoad);
+            if(serverMode() && lParam >= 0 && lCurrLoadPercent >= 100)
+              ShowWindow(hwnd,SW_MINIMIZE);
+          }
+          return(0);
+
      case WM_START_DELAY_TIMER:
           TRACE(SecondaryRuntime_HERE,"WndProc WM_START_DELAY_TIMER");
           if(fInitialStart!=-1)
diff --git a/SelfServiceCommon/Massai/cpp/Graphic/makefile.mak b/SelfServiceCommon/Massai/cpp/Graphic/makefile.mak
index 1144dabb..684c85e3 100644
--- a/SelfServiceCommon/Massai/cpp/Graphic/makefile.mak
+++ b/SelfServiceCommon/Massai/cpp/Graphic/makefile.mak
@@ -28,7 +28,7 @@ MY_LIB1_OBJS =          $(_OBJ)\local_def.obj \
 
 MY_BIN1 =               $(_BIN)\TestBarcode128.exe
 
-MY_BIN1_USER_LIBS =     $(LIB_GRAPHIC) $(LIB_TEXT) $(LIB_TOOLS)
+MY_BIN1_USER_LIBS =     $(LIB_GRAPHIC) $(LIB_TEXT) $(LIB_TOOLS) $(LIB_SYSTOOLS)
 
 MY_BIN1_OBJS =          $(_OBJ)\TestBarcode128.obj
 
@@ -36,7 +36,7 @@ MY_BIN1_OBJS =          $(_OBJ)\TestBarcode128.obj
 
 MY_BIN2 =               $(_BIN)\TestBarcode39.exe
 
-MY_BIN2_USER_LIBS =     $(LIB_GRAPHIC) $(LIB_TEXT) $(LIB_TOOLS)
+MY_BIN2_USER_LIBS =     $(LIB_GRAPHIC) $(LIB_TEXT) $(LIB_TOOLS) $(LIB_SYSTOOLS)
 
 MY_BIN2_OBJS =          $(_OBJ)\TestBarcode39.obj
 
@@ -44,7 +44,7 @@ MY_BIN2_OBJS =          $(_OBJ)\TestBarcode39.obj
 
 MY_BIN3 =               $(_BIN)\TestBarcodeIndustrial2of5.exe
 
-MY_BIN3_USER_LIBS =     $(LIB_GRAPHIC) $(LIB_TEXT) $(LIB_TOOLS)
+MY_BIN3_USER_LIBS =     $(LIB_GRAPHIC) $(LIB_TEXT) $(LIB_TOOLS) $(LIB_SYSTOOLS)
 
 MY_BIN3_OBJS =          $(_OBJ)\TestBarcodeIndustrial2of5.obj
 
@@ -52,7 +52,7 @@ MY_BIN3_OBJS =          $(_OBJ)\TestBarcodeIndustrial2of5.obj
 
 MY_BIN4 =               $(_BIN)\TestBarcodeInterleaved2of5.exe
 
-MY_BIN4_USER_LIBS =     $(LIB_GRAPHIC) $(LIB_TEXT) $(LIB_TOOLS)
+MY_BIN4_USER_LIBS =     $(LIB_GRAPHIC) $(LIB_TEXT) $(LIB_TOOLS) $(LIB_SYSTOOLS)
 
 MY_BIN4_OBJS =          $(_OBJ)\TestBarcodeInterleaved2of5.obj
 
@@ -60,7 +60,7 @@ MY_BIN4_OBJS =          $(_OBJ)\TestBarcodeInterleaved2of5.obj
 
 MY_BIN5 =               $(_BIN)\TestBarcodePDF417.exe
 
-MY_BIN5_USER_LIBS =     $(LIB_GRAPHIC) $(LIB_TEXT) $(LIB_TOOLS)
+MY_BIN5_USER_LIBS =     $(LIB_GRAPHIC) $(LIB_TEXT) $(LIB_TOOLS) $(LIB_SYSTOOLS)
 
 MY_BIN5_OBJS =          $(_OBJ)\TestBarcodePDF417.obj
 
diff --git a/SelfServiceCommon/Massai/cpp/MailService/inc/MailService_def.h b/SelfServiceCommon/Massai/cpp/MailService/inc/MailService_def.h
index d5f7b822..ac2def83 100644
--- a/SelfServiceCommon/Massai/cpp/MailService/inc/MailService_def.h
+++ b/SelfServiceCommon/Massai/cpp/MailService/inc/MailService_def.h
@@ -1,11 +1,15 @@
 /*! \page mailservice MailService - Release Notes
  *
- *  @version 1.0.0.5
+ *  @version 1.0.0.7
  *
  *  \section change1 Change history
  *
+ *  \date 16.12.2011 \li V1.0.0.7
+ *                   \li SteT Mantis 0021947: mstarter: problems at shutdown
+ *                       shutdown on SIGBREAK, ignore CTRL_LOGOFF_EVENT
+ *
  *  \date 17.11.2011 \li V 1.0.0.6
- *                   \li  Mantis 0021572: SelfServiceCommon MailService changes for VC10 compatibilty 
+ *                   \li  Mantis 0021572: SelfServiceCommon MailService changes for VC10 compatibilty
  *
  *  \date 04.12.2008 \li V 1.0.0.5
  *                   \li  Mailservice submits the time in the footer of the mail. (PtM)
@@ -28,8 +32,8 @@
  *                   \li Start release notes (PtM)
  */
 
-#define FILE_VER_BIN     1,0,0,5
-#define FILE_VER_STR     "FileVersion", "1.0.0.5\0"
+#define FILE_VER_BIN     1,0,0,7
+#define FILE_VER_STR     "FileVersion", "1.0.0.7\0"
 
 #define FILEDESCRIPTION  "FileDescription"  ,"MailService\0"
 #define INTERNALNAME     "InternalName"     ,"MailService\0"
diff --git a/SelfServiceCommon/Massai/cpp/MailService/src/main.cpp b/SelfServiceCommon/Massai/cpp/MailService/src/main.cpp
index 4ff7be66..1e8fc83b 100644
--- a/SelfServiceCommon/Massai/cpp/MailService/src/main.cpp
+++ b/SelfServiceCommon/Massai/cpp/MailService/src/main.cpp
@@ -8,6 +8,7 @@
 
 #include <signal.h>
 #include <iostream>
+#include "systools/mEventSem.hpp"
 
 #include "massaidll/massai.hpp"
 #include "massaiCorba/corbasrvr.h"
@@ -16,72 +17,14 @@
 #include "trc/trace.h"
 #include "config.h"
 
-extern char *getOutputPath();
-
-static char szTmp[30];
-
-static bool fDone = false;
-
-/*---------------------------------------------------------------------------
-
- FUNCTION:  VOID exitHandler(INT iSignal)
-
- COMMENTS:  Signal handler
-
- DATE:      04/11/97 - 11:58:33
-
- AUTHOR:    Dr. Materna GmbH   (AGe)
-
----------------------------------------------------------------------------*/
-
-static void exitHandler(int iSignal)
-{
-    switch(iSignal)
-    {
-    case SIGABRT:   strcpy(szTmp,"SIGABRT");  break;
-    case SIGBREAK:  strcpy(szTmp,"SIGBREAK"); break;
-    case SIGTERM:   strcpy(szTmp,"SIGTERM");  break;
-    case SIGINT:    strcpy(szTmp,"SIGINT");   break;
-
-    case SIGFPE:    strcpy(szTmp,"SIGFPE");   break;
-    case SIGSEGV:   strcpy(szTmp,"SIGSEGV");  break;
-    case SIGILL:    strcpy(szTmp,"SIGILL");   break;
-    }
-
-    switch(iSignal)
-    {
-    case SIGBREAK:
-      break;
-    default:
-      fDone = true;
-    }
+#include "systools/mSysProcessTerminate.h"
+#include "tools/TraceClient.h"
 
-    return;
-}
+using MASSAI::trace::TraceClient;
+using Materna::MSSD::eventSemaphore;
 
-//---------------------------------------------------------------------------
-//
-//  function:   void registerHandler()
-//
-//  purpose:    register all signal handlers
-//
-//  date:       03.12.2002, 14:12
-//
-//  author:     Materna Information & Communications (AGe)
-//
-//---------------------------------------------------------------------------
+extern char *getOutputPath();
 
-void registerHandler()
-{
-    signal(SIGABRT, exitHandler);
-    signal(SIGBREAK,exitHandler);
-    signal(SIGTERM, exitHandler);
-    signal(SIGINT,  exitHandler);
-
-    signal(SIGSEGV, exitHandler);
-    signal(SIGILL,  exitHandler);
-    signal(SIGFPE,  exitHandler);
-}
 
 //---------------------------------------------------------------------------
 //
@@ -97,55 +40,57 @@ void registerHandler()
 
 int main(int argc, char** argv)
 {
-    openTrace("MailService");
-    if(argc >= 2)
+  TraceClient trc;
+  eventSemaphore terminate;
+  openTrace("MailService");
+  if(argc >= 2)
+  {
+    if(!strcmp("-cfg",strlwr(argv[argc -1])))
     {
-      if(!strcmp("-cfg",strlwr(argv[argc -1])))
-      {
-        printf("doing configuration ...\n");
-
-        config cfg;
+      printf("doing configuration ...\n");
 
-        cfg.mailServer();
-        cfg.sender();
-        cfg.recipients();
-        cfg.copies();
-        cfg.blackedCopies();
-        cfg.userName();
-        cfg.passWord();
+      config cfg;
+      cfg.mailServer();
+      cfg.sender();
+      cfg.recipients();
+      cfg.copies();
+      cfg.blackedCopies();
+      cfg.userName();
+      cfg.passWord();
 
-        printf("doing configuration, done.\n");
+      printf("doing configuration, done.\n");
 
-        return(0);
-      }
+      return(0);
     }
+  }
 
-    registerHandler();
+  mSysProcessTerminate::setShutdownHook(mSysProcessTerminate::SHUTDOWN_NORMAL, &terminate, &trc);
 
-    try
-    {
-      MailServiceServant mailing;
+  try
+  {
+    MailServiceServant mailing;
 
-      TRACE(HERE,"MailService started ...");
+    TRACE(HERE,"MailService started ...");
 
-      corbaServant<MailServiceServant> srvnt (mailing, "MailService");
+    corbaServant<MailServiceServant> srvnt (mailing, "MailService");
 
-      mailing.startProcessing();
-      while(!fDone)
-        OS_Sleep(100);
-      mailing.stopProcessing();
-    }
-    catch(char *se)
-    {
-      TRACE(HERE,"%s",se);
-      std::cout << se << std::endl;
-    }
+    mailing.startProcessing();
+    terminate.wait();
+    TRACE(HERE,"MailService terminating");
+    mailing.stopProcessing();
+  }
+  catch(char *se)
+  {
+    TRACE(HERE,"%s",se);
+    std::cout << se << std::endl;
+  }
 
-    TRACE(HERE,"MailService terminated.");
+  TRACE(HERE,"MailService terminated.");
 
-    closeTrace();
+  mSysProcessTerminate::resetShutdownHook();
+  closeTrace();
 
-    return(0);
+  return(0);
 }
 
 
diff --git a/SelfServiceCommon/Massai/cpp/StatisticsService/inc/Statistics_def.h b/SelfServiceCommon/Massai/cpp/StatisticsService/inc/Statistics_def.h
index 62d90b4e..dbaeaff2 100644
--- a/SelfServiceCommon/Massai/cpp/StatisticsService/inc/Statistics_def.h
+++ b/SelfServiceCommon/Massai/cpp/StatisticsService/inc/Statistics_def.h
@@ -1,5 +1,5 @@
-#define FILE_VER_BIN     1,0,1,2
-#define FILE_VER_STR     "FileVersion", "1.0.1.2\0"
+#define FILE_VER_BIN     1,0,1,3
+#define FILE_VER_STR     "FileVersion", "1.0.1.3\0"
 
 #define FILEDESCRIPTION  "FileDescription"  ,"Statistics Service\0"
 #define INTERNALNAME     "InternalName"     ,"Statistics\0"
@@ -9,9 +9,13 @@
 
 
 /*! \page statisticsservice Statistics Service - Release Notes
+ *
+ *  \date 16.12.2011 \li V1.0.1.3
+ *                   \li SteT Mantis 0021947: mstarter: problems at shutdown
+ *                       shutdown on SIGBREAK, ignore CTRL_LOGOFF_EVENT
  *
  *  \date 17.11.2011 \li V 1.0.1.2
- *                   \li GiT: Mantis0021568: SelfServiceCommon StatisticsService changes for VC10 compatibilty 
+ *                   \li GiT: Mantis0021568: SelfServiceCommon StatisticsService changes for VC10 compatibilty
  *
  *  \date 12.04.2011 \li V 1.0.1.1
  *                   \li PtM: convert '"' -> '&quot;' to avoid values parsing problems
diff --git a/SelfServiceCommon/Massai/cpp/StatisticsService/src/main.cpp b/SelfServiceCommon/Massai/cpp/StatisticsService/src/main.cpp
index a02a961c..ddf260a9 100644
--- a/SelfServiceCommon/Massai/cpp/StatisticsService/src/main.cpp
+++ b/SelfServiceCommon/Massai/cpp/StatisticsService/src/main.cpp
@@ -18,61 +18,17 @@
 #include "trc/trace.h"
 #include "tools/log.h"
 #include "massaiCorba/corbasrvr.h"
-#include "systools/eventSem.hpp"
 #include "File.h"
 
+#include "systools/mEventSem.hpp"
+#include "systools/mSysProcessTerminate.h"
+#include "tools/TraceClient.h"
 
-static eventSemaphore sem;
+using MASSAI::trace::TraceClient;
+using Materna::MSSD::eventSemaphore;
 
 static TCHAR szAppName[] = TEXT ("StatisticsInterface") ;
-static char szTmp[30];
 
-/*---------------------------------------------------------------------------
-
- FUNCTION:  VOID exitHandler(INT iSignal)
-
- COMMENTS:  Signal handler
-
- DATE:      04/11/97 - 11:58:33
-
- AUTHOR:    Dr. Materna GmbH   (AGe)
-
----------------------------------------------------------------------------*/
-
-static void exitHandler(int iSignal)
-{
-  switch(iSignal)
-  {
-    case SIGABRT:   strcpy(szTmp,"SIGABRT");  break;
-    case SIGBREAK:  strcpy(szTmp,"SIGBREAK"); break;
-    case SIGTERM:   strcpy(szTmp,"SIGTERM");  break;
-    case SIGINT:    strcpy(szTmp,"SIGINT");   break;
-
-    case SIGFPE:    strcpy(szTmp,"SIGFPE");   break;
-    case SIGSEGV:   strcpy(szTmp,"SIGSEGV");  break;
-    case SIGILL:    strcpy(szTmp,"SIGILL");   break;
-  }
-
-  switch(iSignal)
-  {
-    case SIGBREAK:
-      break;
-    default:
-      sem.post();
-  }
-}
-
-void RegisterHandler()
-{
-  signal(SIGABRT,  exitHandler);
-  signal(SIGBREAK, exitHandler);
-  signal(SIGTERM,  exitHandler);
-  signal(SIGINT,   exitHandler);
-
-  signal(SIGSEGV,  exitHandler);
-  signal(SIGILL,   exitHandler);
-  signal(SIGFPE,   exitHandler);
-}
 
 //---------------------------------------------------------------------------
 //
@@ -88,41 +44,38 @@ void RegisterHandler()
 
 int main(int argc, char** argv)
 {
+  TraceClient trc;
+  eventSemaphore sem;
   try
   {
     openTrace("Statistics");
-
-    strcpy(szTmp,"NOSIG");
-
-    RegisterHandler();
+    mSysProcessTerminate::setShutdownHook(mSysProcessTerminate::SHUTDOWN_LATE, &sem, &trc);
+    try
     {
-      try
-      {
-        StatisticsServiceServant statistics;
+      StatisticsServiceServant statistics;
 
-        TRACE(HERE_5,"StatisticsService started ...");
+      TRACE(HERE_5,"StatisticsService started ...");
 
-        corbaServantEx <StatisticsServiceServant> pServant(10,statistics, "StatisticsService");
+      corbaServantEx <StatisticsServiceServant> pServant(10,statistics, "StatisticsService");
 
-        std::cout << "output path = " << readOutputPath().c_str() << std::endl;
-        std::cout << "output filename = " << readOutputFilename().c_str() << std::endl;
+      std::cout << "output path = " << readOutputPath().c_str() << std::endl;
+      std::cout << "output filename = " << readOutputFilename().c_str() << std::endl;
 
-        sem.wait();
-      }
-      catch(char *se)
-      {
-        TRACE(HERE_1,"(%.1000s)",se);
-        std::cout << se << std::endl;
-      }
+      sem.wait();
       TRACE(HERE_1,"StatisticsService terminating");
     }
-
+    catch(char *se)
+    {
+      TRACE(HERE_1,"(%.1000s)",se);
+      std::cout << se << std::endl;
+    }
     TRACE(HERE_1,"StatisticsService terminated.");
   }
   catch(...)
   {
     std::cout << "Cannot create servant" << std::endl;
   }
+  mSysProcessTerminate::resetShutdownHook();
   closeTrace();
 
   return 1;
diff --git a/SelfServiceCommon/Massai/cpp/Systools/inc/mSysErrorW32.h b/SelfServiceCommon/Massai/cpp/Systools/inc/mSysErrorW32.h
new file mode 100644
index 00000000..bd5db119
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Systools/inc/mSysErrorW32.h
@@ -0,0 +1,24 @@
+/**
+ * windows error codes
+**/
+
+#ifndef MSYSERRORW32_H_INCLUDED
+#define MSYSERRORW32_H_INCLUDED
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include <string>
+#include "tools/TraceInterface.h"
+
+namespace mSysError
+{
+  unsigned long getErrorCode();
+  std::string getErrorText(unsigned long errorCode);
+  bool isSystemError(unsigned long errorCode);
+  void traceLastError(MASSAI::trace::TraceInterface& trc,
+    long level, const char* file, short line, const char* function,
+    const char* where, unsigned long errorCode);
+}
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Systools/inc/mSysProcessIOCountersW32.h b/SelfServiceCommon/Massai/cpp/Systools/inc/mSysProcessIOCountersW32.h
new file mode 100644
index 00000000..a6df00b7
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Systools/inc/mSysProcessIOCountersW32.h
@@ -0,0 +1,44 @@
+/**
+ * read IOCounters (API missing in VC6)
+**/
+
+#ifndef MSYSPROCESSIOCOUNTERSW32_H_INCLUDED
+#define MSYSPROCESSIOCOUNTERSW32_H_INCLUDED
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include <windows.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct _IO_COUNTERS {
+  ULONGLONG ReadOperationCount;
+  ULONGLONG WriteOperationCount;
+  ULONGLONG OtherOperationCount;
+  ULONGLONG ReadTransferCount;
+  ULONGLONG WriteTransferCount;
+  ULONGLONG OtherTransferCount;
+} IO_COUNTERS;
+typedef IO_COUNTERS *PIO_COUNTERS;
+
+BOOL WINAPI GetProcessIoCounters(HANDLE hProcess, PIO_COUNTERS lpIoCounters)
+{
+  BOOL result= false;
+  typedef BOOL (WINAPI *GetProcessIoCountersPtr)(HANDLE, PIO_COUNTERS);
+  GetProcessIoCountersPtr func = reinterpret_cast<GetProcessIoCountersPtr>
+    (GetProcAddress(GetModuleHandle("kernel32"), "GetProcessIoCounters"));
+  if(func)
+  {
+    result= func(hProcess, lpIoCounters);
+  }
+  return result;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Systools/inc/mSysProcessW32.h b/SelfServiceCommon/Massai/cpp/Systools/inc/mSysProcessW32.h
new file mode 100644
index 00000000..2d6a752f
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Systools/inc/mSysProcessW32.h
@@ -0,0 +1,28 @@
+/**
+ **************************************************************************
+ *
+ * @file mSysProcessW32.h
+ *
+ **************************************************************************
+**/
+#ifndef MSYSPROCESSW32_H_INCLUDED
+#define MSYSPROCESSW32_H_INCLUDED
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "sysTools/mSysProcess.hpp"
+#include "mSysSynchronizeW32.h"
+#include <windows.h>
+
+namespace mSysProcess
+{
+  class child::Internal: public mSysSynchronize::Internal
+  {
+    public:
+      Internal();
+      DWORD  id;
+  };
+}
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Systools/inc/mSysSynchronizeW32.h b/SelfServiceCommon/Massai/cpp/Systools/inc/mSysSynchronizeW32.h
new file mode 100644
index 00000000..354d5164
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Systools/inc/mSysSynchronizeW32.h
@@ -0,0 +1,33 @@
+/**
+ **************************************************************************
+ *
+ * @file mSysSynchronizeW32.h
+ *
+ **************************************************************************
+**/
+#ifndef MSYSSYNCHRONIZEW32_H_INCLUDED
+#define MSYSSYNCHRONIZEW32_H_INCLUDED
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "sysTools/mSysSynchronize.h"
+#include <windows.h>
+
+namespace mSysSynchronize
+{
+  /*
+   *  Internal data for synchronization
+   */
+  class Internal
+  {
+    public:
+      Internal();
+      Internal(HANDLE handle);
+      ~Internal();
+
+      HANDLE handle;
+  };
+}
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Systools/inc/mSysTimeW32.h b/SelfServiceCommon/Massai/cpp/Systools/inc/mSysTimeW32.h
new file mode 100644
index 00000000..2d5e4497
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Systools/inc/mSysTimeW32.h
@@ -0,0 +1,21 @@
+/**
+ * time, for internal use
+**/
+
+#ifndef MSYSTIMEW32_H_INCLUDED
+#define MSYSTIMEW32_H_INCLUDED
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "systools/mSysTime.h"
+#include <windows.h>
+
+namespace mSysTime
+{
+  Duration getDuration(const FILETIME& filetime);
+  Timestamp getTimestamp(const FILETIME& filetime);
+  Timestamp getTimestamp(const SYSTEMTIME& systemtime);
+}
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Systools/makefile.mak b/SelfServiceCommon/Massai/cpp/Systools/makefile.mak
index d1461181..bdff2729 100644
--- a/SelfServiceCommon/Massai/cpp/Systools/makefile.mak
+++ b/SelfServiceCommon/Massai/cpp/Systools/makefile.mak
@@ -8,7 +8,7 @@
 
 ######################################################################
 
-MY_CFLAGS =             $(MY_CFLAGS_2) $(INC_INTERFACES)
+MY_CFLAGS =             $(MY_CFLAGS_2) $(INC_INTERFACES) $(INC_BOOST) $(INC_PSAPI)
 
 MY_LIB1 =               $(LIB_SYSTOOLS)
 
@@ -18,10 +18,15 @@ MY_LIB1_OBJS =          $(_OBJ)\local_def.obj \
                         $(_OBJ)\mEventSemW32.obj \
                         $(_OBJ)\mMutexSemW32.obj \
                         $(_OBJ)\mSysDebugW32.obj \
+                        $(_OBJ)\mSysTimeW32.obj \
+                        $(_OBJ)\mSysErrorW32.obj \
                         $(_OBJ)\mSysExceptionW32.obj \
                         $(_OBJ)\mSysMain.obj \
                         $(_OBJ)\mSysMainTrace.obj \
+                        $(_OBJ)\mSysSynchronizeW32.obj \
                         $(_OBJ)\mSysProcessW32.obj \
+                        $(_OBJ)\mSysProcessListW32.obj \
+                        $(_OBJ)\mSysProcessTerminateW32.obj \
                         $(_OBJ)\mSysSignalW32.obj \
                         $(_OBJ)\mSysThreadW32.obj \
                         $(_OBJ)\nt_evsem.obj \
@@ -32,7 +37,8 @@ MY_LIB1_OBJS =          $(_OBJ)\local_def.obj \
                         $(_OBJ)\tRex.obj \
                         $(_OBJ)\tRexLookupComport.obj \
                         $(_OBJ)\Console.obj \
-                        $(_OBJ)\mMutexCSW32.obj
+                        $(_OBJ)\mMutexCSW32.obj \
+                        $(_OBJ)\mSysWindowW32.obj
 
 MY_LIB1_LIBS =          $(SYS_ADVAPI32)
 
@@ -40,7 +46,7 @@ MY_LIB1_LIBS =          $(SYS_ADVAPI32)
 
 MY_BIN1 =               $(_BIN)\TestSysProcess.exe
 
-MY_BIN1_USER_LIBS =     $(LIB_SYSTOOLS) $(LIB_TEXT)
+MY_BIN1_USER_LIBS =     $(LIB_SYSTOOLS) $(LIB_TOOLS) $(LIB_TEXT) $(LIB_PSAPI)
 
 MY_BIN1_OBJS =          $(_OBJ)\TestSysProcess.obj
 
@@ -52,7 +58,5 @@ MY_BIN2_USER_LIBS =     $(LIB_SYSTOOLS)
 
 MY_BIN2_OBJS =          $(_OBJ)\TestSysThread.obj
 
-
 ######################################################################
-
 !include $(BUILDROOT)\Build\cpp\makefile.rules.mak
diff --git a/SelfServiceCommon/Massai/cpp/Systools/src/TestSysProcess.cpp b/SelfServiceCommon/Massai/cpp/Systools/src/TestSysProcess.cpp
index 429657bd..f79ac7bf 100644
--- a/SelfServiceCommon/Massai/cpp/Systools/src/TestSysProcess.cpp
+++ b/SelfServiceCommon/Massai/cpp/Systools/src/TestSysProcess.cpp
@@ -12,7 +12,7 @@
  **************************************************************************
 **/
 
-#define USE_MYPROCESS_CLASS                     1
+#define USE_MYPROCESS_CLASS                     0
 #define USE_MYPROCESS_CLASS_FOR_SECONDS         10
 
 
@@ -138,7 +138,8 @@ public:
    stdinThread() :
       mSysThread::thread( &Xcept ),
       M_Active( true ),
-      M_Child( 0 )
+      M_Child( 0 ),
+      M_Handle(0)
    {
    }
 
@@ -210,10 +211,11 @@ public:
 
    ~myProcess()
    {
-      cout << "myProcess::~myProcess ..." << endl;
-      delete M_Child;
+      //cout << "myProcess::~myProcess ..." << endl;
+      //delete M_Child;
       cout << "myProcess::~myProcess 0" << endl;
       unsigned long Exit = M_Child->waitForTermination().getExitCode();
+      cout << M_Child->getProcessInformation() << endl;
       cout << "myProcess::~myProcess 1" << endl;
       delete M_StdinThread;
       cout << "myProcess::~myProcess 2" << endl;
@@ -309,6 +311,7 @@ int main( int argc, char **argv )
       StdinThread.start( *Child );
    unsigned long Exit = Child->waitForTermination().getExitCode();
    mSysThread::sleep( 100 );
+   cout << Child->getProcessInformation() << endl;
    cout << "main child exit=" << Exit << endl;
    // ---
 
diff --git a/SelfServiceCommon/Massai/cpp/Systools/src/mEventSemW32.cpp b/SelfServiceCommon/Massai/cpp/Systools/src/mEventSemW32.cpp
index 856d119e..5aa3cffe 100644
--- a/SelfServiceCommon/Massai/cpp/Systools/src/mEventSemW32.cpp
+++ b/SelfServiceCommon/Massai/cpp/Systools/src/mEventSemW32.cpp
@@ -20,109 +20,136 @@
 
 
 #include "systools/mEventSem.hpp"
+#include "mSysSynchronizeW32.h"
 
-#include "windows.h"
+#include <windows.h>
 #include <string>
 
+using mSysSynchronize::Internal;
+
+namespace
+{
+  bool isGlobalNameSpaceSupported()
+  {
+    bool useGlobalNamespace= false;
+    OSVERSIONINFO version;
+    version.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
+    if(GetVersionEx(&version))
+    {
+      if(version.dwMajorVersion >= 5)
+      {
+        useGlobalNamespace= true;
+      }
+    }
+    return useGlobalNamespace;
+  }
+  void initSecurityAttributes(SECURITY_ATTRIBUTES& secAtt, SECURITY_DESCRIPTOR& secDesc)
+  {
+    InitializeSecurityDescriptor(&secDesc, SECURITY_DESCRIPTOR_REVISION);
+    SetSecurityDescriptorDacl(&secDesc, TRUE, NULL, FALSE);
+    secAtt.nLength=sizeof(secAtt);
+    secAtt.lpSecurityDescriptor= &secDesc;
+    secAtt.bInheritHandle= FALSE;
+  }
+}
 
 
 namespace Materna
 {
    namespace MSSD
    {
+      class eventSemaphore_Handle: public Internal
+      {
+        public:
+          eventSemaphore_Handle();
+          explicit eventSemaphore_Handle(const char* Name);
+          eventSemaphore_Handle(bool global, const char* Name);
+          eventSemaphore_Handle(SemaphoreCreation create, SemaphoreName nameing,
+            char const* Name);
+          ~eventSemaphore_Handle();
+          HANDLE winH() const;
+        private:
+          void createEvent(SemaphoreCreation create, SemaphoreName nameing, const char* Name);
+      };
+
+      eventSemaphore_Handle::eventSemaphore_Handle()
+      {}
 
-      class eventSemaphore_Handle
+      eventSemaphore_Handle::eventSemaphore_Handle( char const * Name ) :
+         Internal( CreateEvent( 0, TRUE, FALSE, Name ) )
+      {}
+
+      eventSemaphore_Handle::eventSemaphore_Handle(bool global, const char* Name)
       {
+        createEvent(SEM_CREATE, global?SEM_GLOBAL_NAME:SEM_LOCAL_NAME, Name);
+      }
 
-         HANDLE M_Hdl;
-
-      public:
-
-         eventSemaphore_Handle();
-
-         explicit eventSemaphore_Handle( char const * Name ) :
-            M_Hdl( CreateEvent( 0, TRUE, FALSE, Name ) )
-         {
-         }
-
-         eventSemaphore_Handle(bool global, const char* Name)
-         {
-           bool useGlobalNamespace= false;
-
-           SECURITY_ATTRIBUTES secAtt;
-           SECURITY_DESCRIPTOR secDesc;
-
-           InitializeSecurityDescriptor(&secDesc, SECURITY_DESCRIPTOR_REVISION);
-           SetSecurityDescriptorDacl(&secDesc, TRUE, NULL, FALSE);
-           secAtt.nLength=sizeof(secAtt);
-           secAtt.lpSecurityDescriptor= &secDesc;
-           secAtt.bInheritHandle= FALSE;
-
-
-           OSVERSIONINFO version;
-           version.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
-           if(GetVersionEx(&version))
-           {
-             if(version.dwMajorVersion >= 5)
-             {
-               useGlobalNamespace= true;
-             }
-           }
-           if(useGlobalNamespace)
-           {
-             std::string name;
-             if(global)
-               name= "Global\\";
-             else
-               name= "Local\\";
-             name+= Name;
-             M_Hdl = CreateEvent(&secAtt, TRUE, FALSE, name.c_str());
-           }
-           else
-           {
-             M_Hdl = CreateEvent(&secAtt, TRUE, FALSE, Name);
-           }
-         }
-
-         ~eventSemaphore_Handle()
-         {
-            CloseHandle( M_Hdl );
-            M_Hdl = 0;
-         }
-
-         HANDLE winH() const
-         {
-            return M_Hdl;
-         }
+      eventSemaphore_Handle::eventSemaphore_Handle(SemaphoreCreation create, SemaphoreName nameing, char const * Name )
+      {
+        createEvent(create, nameing, Name);
+      }
 
-      };
+      eventSemaphore_Handle::~eventSemaphore_Handle()
+      {
+         CloseHandle( handle );
+         handle = 0;
+      }
 
+      HANDLE eventSemaphore_Handle::winH() const
+      {
+         return handle;
+      }
+      void eventSemaphore_Handle::createEvent(SemaphoreCreation create, SemaphoreName nameing, char const * Name)
+      {
+        std::string name;
+        if(nameing == SEM_RAW_NAME || !isGlobalNameSpaceSupported())
+        {
+          name= Name;
+        }
+        else if(nameing == SEM_GLOBAL_NAME)
+        {
+          name= "Global\\";
+          name+= Name;
+        }
+        else
+        {
+          name= "Local\\";
+          name+= Name;
+        }
+        if(create == SEM_CREATE)
+        {
+          SECURITY_ATTRIBUTES secAtt;
+          SECURITY_DESCRIPTOR secDesc;
+          initSecurityAttributes(secAtt, secDesc);
+          handle = CreateEvent(&secAtt, TRUE, FALSE, name.c_str());
+        }
+        else
+        {
+          handle = OpenEvent(SYNCHRONIZE|EVENT_MODIFY_STATE, false, name.c_str());
+        }
+      }
    }
 }
 
-
-
 using namespace Materna::MSSD;
 
 
 
 eventSemaphore::eventSemaphore() :
    M_Handle( new eventSemaphore_Handle( 0 ) )
-{
-}
-
-
+{}
 
 eventSemaphore::eventSemaphore( char const * Name ) :
    M_Handle( new eventSemaphore_Handle( Name ) )
-{
-}
+{}
 
 eventSemaphore::eventSemaphore(bool global, const char* Name):
   M_Handle(new eventSemaphore_Handle(global, Name))
-{
-}
+{}
 
+eventSemaphore::eventSemaphore(SemaphoreCreation create, SemaphoreName nameing, char const* Name):
+  M_Handle(new eventSemaphore_Handle(create, nameing, Name))
+{}
 
 
 eventSemaphore::~eventSemaphore()
@@ -206,6 +233,11 @@ void eventSemaphore::reset()
       throw eventSemaphore_Exception();
 }
 
+const Internal& eventSemaphore::getInternal() const
+{
+  return *M_Handle;
+}
+
 
 
 /**
diff --git a/SelfServiceCommon/Massai/cpp/Systools/src/mSysErrorW32.cpp b/SelfServiceCommon/Massai/cpp/Systools/src/mSysErrorW32.cpp
new file mode 100644
index 00000000..ee233319
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Systools/src/mSysErrorW32.cpp
@@ -0,0 +1,70 @@
+/**
+ * windows error codes
+**/
+#include "mSysErrorW32.h"
+#include <windows.h>
+
+namespace mSysError
+{
+  unsigned long getErrorCode()
+  {
+    return GetLastError();
+  }
+  std::string getErrorText(unsigned long errorCode)
+  {
+    std::string result;
+    if(errorCode != 0)
+    {
+      LPVOID buf;
+      FormatMessage
+      (
+        FORMAT_MESSAGE_ALLOCATE_BUFFER
+          | FORMAT_MESSAGE_FROM_SYSTEM
+          | FORMAT_MESSAGE_IGNORE_INSERTS,
+        0,
+        errorCode & 0xFFFF,
+        0,
+        reinterpret_cast<LPTSTR>(&buf),
+        0,
+        0
+      );
+      if(buf != 0)
+      {
+        result= reinterpret_cast<const char*>(buf);
+      }
+      LocalFree(buf);
+    }
+    return result;
+  }
+  bool isSystemError(unsigned long errorCode)
+  {
+    //   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
+    //   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
+    //  +---+-+-+-----------------------+-------------------------------+
+    //  |Sev|C|R|     Facility          |               Code            |
+    //  +---+-+-+-----------------------+-------------------------------+
+    //
+    //  where
+    //
+    //      Sev - is the severity code
+    //
+    //          00 - Success
+    //          01 - Informational
+    //          10 - Warning
+    //          11 - Error
+    //
+    //      C - is the Customer code flag
+    //
+
+    // check if severity code is Error and Customer flag is not set
+    return (errorCode & 0xE0000000) == 0xC0000000;
+  }
+  void traceLastError(MASSAI::trace::TraceInterface& trc,
+    long level, const char* file, short line, const char* function,
+    const char* where, unsigned long errorCode)
+  {
+    trc.writeTrace(level, file, line, function,
+      "(%.200s) failed: (%d), (%.1000s)",
+      where, errorCode, mSysError::getErrorText(errorCode).c_str());
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/Systools/src/mSysProcessListW32.cpp b/SelfServiceCommon/Massai/cpp/Systools/src/mSysProcessListW32.cpp
new file mode 100644
index 00000000..afebef45
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Systools/src/mSysProcessListW32.cpp
@@ -0,0 +1,1159 @@
+/**
+ * control list of child processes
+**/
+
+#pragma warning (disable: 4786)
+
+#include "systools/mSysProcessList.h"
+
+#include "boost/shared_ptr.hpp"
+#include "systools/mAutoMutexCS.h"
+#include "systools/mEventSem.hpp"
+#include "systools/mMutexCS.h"
+#include "systools/mSysException.hpp"
+#include "systools/mSysProcess.hpp"
+#include "systools/mSysSynchronize.h"
+#include "systools/mSysThread.hpp"
+#include "systools/mSysTime.h"
+#include "systools/mSysWindow.h"
+#include "tools/ResetTime.h"
+#include "tools/TraceInterface.h"
+#include "text/stoupper.h"
+#include "trc/trace.h"
+#include <memory>
+#include <set>
+#include <map>
+
+using MASSAI::trace::TraceInterface;
+using mReset::ResetTime;
+using mReset::Time;
+using mSysException::standardException;
+using mSysThread::thread;
+using mSysWindow::Window;
+using mSysWindow::WindowList;
+using mSysWindow::WindowPtr;
+using mSysWindow::WindowSearch;
+using mSysWindow::WindowSearchData;
+using mSysWindow::WindowSearchMatch;
+using mSysSynchronize::WaitNotification;
+using mSysSynchronize::WaitListener;
+using mSysSynchronize::Synchronize;
+using mSysSynchronize::SimpleSynchronize;
+using mSysSynchronize::Internal;
+
+using namespace Materna::MSSD;
+using namespace Materna::Stoupper;
+using namespace mSysProcess;
+
+namespace
+{
+  typedef std::set<ProcessProperties> PropertySet;
+
+  enum WindowSearchType
+  {
+    WND_TITLE_CLASS,
+    WND_VISIBLE,
+    WND_ALL,
+  };
+  /*
+    callback for Process notification
+  */
+  class Process;
+  class ProcessCallback
+  {
+    public:
+      ProcessCallback();
+      virtual ~ProcessCallback();
+      virtual void notify(Process& process)= 0;
+      virtual void match(Process& process)= 0;
+  };
+  /*
+    control child process
+  */
+  class Process:
+    public mSysWindow::Process,
+    public WaitNotification,
+    private callBack
+  {
+    public:
+      Process(ProcessCallback& cb, ProcessProperties properties,
+        TraceInterface& trc, const WatchdogSettings& settings);
+      virtual ~Process();
+      void start();
+      void setStopping();
+      void setWindowSearch(WindowSearchType search);
+      bool sendBreak();
+      bool sendCtrlC();
+      bool kill();
+      const ProcessProperties& getProperties() const;
+      virtual child* getProcess();
+      virtual std::string getDesktop();
+      virtual const Internal& getInternal() const;
+      virtual void notify();
+      virtual bool match(Window& window);
+      virtual void lineOut(const char* line) const;
+      Time getResetTime() const;
+      bool isStopped() const;
+      bool needsReset() const;
+
+    private:
+      typedef std::auto_ptr<child> ProcessPtr;
+      ProcessCallback& m_cb;
+      TraceInterface& m_trc;
+      ProcessPtr m_pProcess;
+      ProcessProperties m_properties;
+      ResetTime m_reset;
+      bool m_stopping;
+      bool m_watchDog;
+      WindowSearchType m_search;
+  };
+  typedef std::set<Process*> ProcessSet;
+  typedef boost::shared_ptr<Process> ProcessPtr;
+  typedef std::list<ProcessPtr> ProcessPtrList;
+
+  /*
+    control list of child processes
+  */
+  class ProcessListImpl:
+    private WaitListener,
+    private ProcessCallback
+  {
+    public:
+      ProcessListImpl(TraceInterface& trc, const WatchdogSettings& settings);
+      void setListener(ProcessListCallback* pListener);
+      ProcessListCallback* getListener();
+      TraceInterface& getTrc();
+
+      void startWatchdog();
+      void stopWatchdog();
+
+      Time checkTerminated();
+      void update(const PropertyList& propertyList);
+      void start(const PropertyList& propertyList);
+      void cancelStart();
+
+      virtual void notify(WaitNotification* pNotification);
+
+      WindowList searchWindows(WindowSearchType search, const std::string& group);
+      void stop(const std::string& group);
+
+    private:
+      virtual void notify(Process& process);
+      virtual void match(Process& process);
+
+      void stoppingProcesses(const ProcessSet& processSet);
+      WindowList searchWindows(WindowSearchType search, ProcessSet& processSet);
+      void closeWindows(const WindowList& winList);
+      void sendBreak(ProcessSet& processSet);
+      void sendCtrlC(ProcessSet& processSet);
+      void kill(const ProcessSet& processSet);
+      void wait(const ProcessSet& processSet);
+      void stop(const ProcessSet& processSet);
+      PropertySet getPropertySet(const PropertyList& list);
+      PropertySet getPropertySet(const ProcessPtrList& list);
+      PropertyList getDiff(const PropertyList& minuend, const ProcessPtrList& subtrahend);
+      ProcessSet getDiff(const ProcessPtrList& minuend, const PropertyList& subtrahend);
+      ProcessSet getProcessSet(const std::string& group);
+
+
+      ProcessListCallback* m_pListener;
+      eventSemaphore m_break;
+      bool m_stop;
+      Mutex m_accessListener;
+      ProcessPtrList m_processPtrList;
+      TraceInterface& m_trc;
+      Synchronize m_processWatchdog;
+      ProcessSet m_windowSearch;
+      WatchdogSettings m_settings;
+  };
+
+
+  /*
+    store windows of a process group (in ApplicationList)
+  */
+  typedef std::map<std::string, WindowList> WindowMap;
+
+  /*
+    state of ProcessList::Impl
+  */
+  enum State
+  {
+    INIT,
+    IDLE,
+    PROCESS,
+    STOPPING,
+    STOPPED,
+  };
+  std::string getStateText(State state)
+  {
+    switch(state)
+    {
+      case INIT:     return "init";
+      case IDLE:     return "idle";
+      case PROCESS:  return "process";
+      case STOPPING: return "stopping";
+      case STOPPED:  return "stopped";
+      default:       return "unknown";
+    }
+  }
+
+  /*
+    callback for Process notification
+  */
+  ProcessCallback::ProcessCallback()
+  {}
+  ProcessCallback::~ProcessCallback()
+  {}
+  /*
+   *  user defined check
+   *    for windows search
+   */
+  class WindowMatch: public WindowSearchMatch
+  {
+    public:
+      WindowMatch();
+      virtual ~WindowMatch();
+      virtual bool match(Window& window, mSysWindow::Process* pProcess);
+  };
+
+  std::string showText(Show show)
+  {
+    switch(show)
+    {
+      case SHOW:      return "show";
+      case HIDE:      return "hide";
+      case MINIMIZED: return "minimized";
+      default:        return "unknown";
+    }
+  }
+
+  /*
+    control child process
+  */
+  Process::Process(ProcessCallback& cb, ProcessProperties properties, TraceInterface& trc, const WatchdogSettings& settings):
+    m_cb(cb),
+    m_pProcess(),
+    m_properties(properties),
+    m_trc(trc),
+    m_reset(trc, m_properties.group, settings.resetMin, settings.resetMax, settings.resetRecover),
+    m_stopping(false),
+    m_watchDog(settings.useWatchDog),
+    m_search(WND_ALL)
+  {
+    start();
+  }
+  Process::~Process()
+  {}
+  child* Process::getProcess()
+  {
+    return m_pProcess.get();
+  }
+  std::string Process::getDesktop()
+  {
+    return m_properties.desktop;
+  }
+  const Internal& Process::getInternal() const
+  {
+    return m_pProcess.get()->getInternal();
+  }
+  void Process::notify()
+  {
+    m_trc.writeTrace(BasicRuntime_HERE,
+      "process terminated"
+      "\n#####################\n"
+      "terminated (%s)\n"
+      "%s\n"
+      "#####################",
+      m_properties.group.c_str(),
+      m_pProcess->getProcessInformation().c_str());
+    if(needsReset())
+    {
+      m_reset.setError();
+    }
+    m_cb.notify(*this);
+  }
+  Time Process::getResetTime() const
+  {
+    return m_reset.getResetTime();
+  }
+  void Process::lineOut(const char* line) const
+  {
+    m_trc.writeTraceText(MajorWarning_HERE, line);
+  }
+  bool Process::match(Window& window)
+  {
+    bool result = false;
+    if(m_pProcess->getStatus() == STATUS_RUNNING)
+    {
+      switch(m_search)
+      {
+        case WND_TITLE_CLASS:
+        {
+          if(m_properties.windowClass.size() > 0)
+          {
+            if(stoupper(window.getClass()) == stoupper(m_properties.windowClass))
+            {
+              if(m_properties.windowTitle.size() > 0)
+              {
+                std::string title = window.getTitle();
+                result = stoupper(title).find(stoupper(m_properties.windowTitle)) != std::string::npos;
+              }
+              else
+              {
+                result = true;
+              }
+            }
+          }
+          else if(m_properties.windowTitle.size() > 0)
+          {
+            std::string title = window.getTitle();
+            result = stoupper(title).find(stoupper(m_properties.windowTitle)) != std::string::npos;
+          }
+          break;
+        }
+        case WND_VISIBLE:
+        {
+          result = window.isVisible();
+          break;
+        }
+        case WND_ALL:
+        {
+          result = true;
+          break;
+        }
+      }
+    }
+    if(result)
+    {
+      m_trc.writeTrace(BasicRuntime_HERE, "found window WND(%s)\tWNDCLASS(%s)\tCOMP(%s)\tCMD(%s)",
+        window.getTitle().c_str(),
+        window.getClass().c_str(),
+        m_properties.group.c_str(),
+        m_properties.commandLine.c_str()
+      );
+      m_cb.match(*this);
+    }
+    return result;
+  }
+  void Process::start()
+  {
+    parent factory;
+    factory.setLogging(*this);
+    factory.setCommandline(m_properties.commandLine.c_str());
+    factory.setDesktop(m_properties.desktop.c_str());
+    factory.setNewProcessGroup();
+    factory.setReuseConsole();
+    if(m_properties.workingDir.size() > 0)
+    {
+      factory.setWorkDirectory(m_properties.workingDir.c_str());
+    }
+    switch(m_properties.show)
+    {
+      case HIDE:
+      {
+        factory.setHide();
+        break;
+      }
+      case MINIMIZED:
+      {
+        factory.setMinimized();
+        break;
+      }
+      // case SHOW:
+    }
+    m_reset.resetError();
+    m_pProcess = ProcessPtr(factory.newChild());
+    m_trc.writeTrace(BasicRuntime_HERE,
+      "process started\n"
+      "*********************\n"
+      "%s\n"
+      "COMP(%s)\n"
+      "CMD(%s)\n"
+      "DSK(%s)\n"
+      "WND(%s)\n"
+      "WNDCLASS(%s)\n"
+      "CWD(%s)\n"
+      "SHOW(%d)(%s)\n"
+      "WAIT(%d)\n"
+      "*********************",
+      m_pProcess->getProcessId().c_str(),
+      m_properties.group.c_str(),
+      m_properties.commandLine.c_str(),
+      m_properties.desktop.c_str(),
+      m_properties.windowTitle.c_str(),
+      m_properties.windowClass.c_str(),
+      m_properties.workingDir.c_str(),
+      m_properties.show, showText(m_properties.show).c_str(),
+      m_properties.timeout
+    );
+  }
+  void Process::setStopping()
+  {
+    m_stopping = true;
+  }
+  void Process::setWindowSearch(WindowSearchType search)
+  {
+    m_search = search;
+  }
+  bool Process::sendBreak()
+  {
+    bool result = true;
+    if(m_pProcess->getStatus() == STATUS_RUNNING)
+    {
+      m_trc.writeTrace(BasicRuntime_HERE,
+        "send break\t(%s)\tCOMP(%s)\tCMD(%s)",
+        m_pProcess->getProcessId().c_str(),
+        m_properties.group.c_str(),
+        m_properties.commandLine.c_str()
+      );
+      result = m_pProcess->sendBreak();
+    }
+    return result;
+  }
+  bool Process::sendCtrlC()
+  {
+    bool result = true;
+    if(m_pProcess->getStatus() == STATUS_RUNNING)
+    {
+      m_trc.writeTrace(BasicRuntime_HERE,
+        "send ctrl-c\t(%s)\tCOMP(%s)\tCMD(%s)",
+        m_pProcess->getProcessId().c_str(),
+        m_properties.group.c_str(),
+        m_properties.commandLine.c_str()
+      );
+      result = m_pProcess->sendCtrlC();
+    }
+    return result;
+  }
+  bool Process::kill()
+  {
+    bool result = true;
+    if(m_pProcess->getStatus() == STATUS_RUNNING)
+    {
+      m_trc.writeTrace(BasicRuntime_HERE,
+        "kill\t(%s)\tCOMP(%s)\tCMD(%s)",
+        m_pProcess->getProcessId().c_str(),
+        m_properties.group.c_str(),
+        m_properties.commandLine.c_str()
+      );
+      m_pProcess->kill();
+    }
+    return result;
+  }
+  bool Process::isStopped() const
+  {
+    return m_pProcess->getStatus() == STATUS_TERMINATED;
+  }
+  bool Process::needsReset() const
+  {
+    return m_watchDog && !m_stopping && isStopped();
+  }
+  const ProcessProperties& Process::getProperties() const
+  {
+    return m_properties;
+  }
+  /*
+   *  user defined check
+   *    for windows search
+   */
+  WindowMatch::WindowMatch()
+  {}
+  WindowMatch::~WindowMatch()
+  {}
+  bool WindowMatch::match(Window& window, mSysWindow::Process* pProcess)
+  {
+    bool result = false;
+    if(pProcess)
+    {
+      result = pProcess->match(window);
+    }
+    return result;
+  }
+  /*
+    control list of child processes
+  */
+  ProcessListImpl::ProcessListImpl(TraceInterface& trc, const WatchdogSettings& settings):
+    WaitListener(),
+    m_pListener(0),
+    m_break(),
+    m_stop(false),
+    m_accessListener(),
+    m_trc(trc),
+    m_processPtrList(),
+    m_processWatchdog(m_trc),
+    m_windowSearch(),
+    m_settings(settings)
+  {}
+  void ProcessListImpl::setListener(ProcessListCallback* pListener)
+  {
+    AutoMutexCS mx(m_accessListener);
+    m_pListener= pListener;
+  }
+  ProcessListCallback* ProcessListImpl::getListener()
+  {
+    AutoMutexCS mx(m_accessListener);
+    return m_pListener;
+  }
+  void ProcessListImpl::notify(WaitNotification* pNotification)
+  {
+    WaitListener::notify(pNotification);
+  }
+  void ProcessListImpl::notify(Process& process)
+  {
+    ProcessListCallback* pListener= getListener();
+    if(pListener)
+    {
+      pListener->terminated(process.getProperties());
+    }
+  }
+  void ProcessListImpl::cancelStart()
+  {
+    m_stop = true;
+    m_break.post();
+  }
+  void ProcessListImpl::startWatchdog()
+  {
+    m_processWatchdog.setListener(this);
+    m_processWatchdog.startWait();
+  }
+  void ProcessListImpl::stopWatchdog()
+  {
+    m_processWatchdog.cancelWait();
+  }
+  TraceInterface& ProcessListImpl::getTrc()
+  {
+    return m_trc;
+  }
+  void ProcessListImpl::start(const PropertyList& propertyList)
+  {
+    ProcessListCallback* pListener= getListener();
+    PropertyList::const_iterator it = propertyList.begin();
+    PropertyList::const_iterator end = propertyList.end();
+    for(; it != end && !m_stop; it++)
+    {
+      const ProcessProperties& prop = *it;
+      Process* process = new Process(*this, prop, m_trc, m_settings);
+      m_processPtrList.push_back(ProcessPtr(process));
+      if(pListener)
+      {
+        pListener->started(prop);
+      }
+      m_processWatchdog.add(process);
+      if(prop.timeout > 0)
+      {
+         m_trc.writeTrace(BasicRuntime_HERE,
+           "wait (%d) ms", prop.timeout);
+        m_break.wait(prop.timeout);
+      }
+      else if(prop.timeout < 0)
+      {
+        process->setStopping();
+        child* pProcess = process->getProcess();
+        if(pProcess && pProcess->getStatus() == STATUS_RUNNING)
+        {
+          m_trc.writeTrace(BasicRuntime_HERE,
+            "wait for\t(%s)\tCOMP(%s)\tCMD(%s)",
+            pProcess->getProcessId().c_str(),
+            prop.group.c_str(),
+            prop.commandLine.c_str()
+          );
+          SimpleSynchronize sync(m_trc);
+          sync.add(pProcess);
+          sync.add(&m_break);
+          sync.wait(m_settings.waitTimeout);
+        }
+      }
+    }
+  }
+  void ProcessListImpl::update(const PropertyList& propertyList)
+  {
+    ProcessSet oldProcessSet = getDiff(m_processPtrList, propertyList);
+    PropertyList newPropertyList = getDiff(propertyList, m_processPtrList);
+    stop(oldProcessSet);
+    start(newPropertyList);
+  }
+  Time ProcessListImpl::checkTerminated()
+  {
+    ProcessListCallback* pListener= getListener();
+    Time wait = 0;
+    ProcessPtrList::iterator it =  m_processPtrList.begin();
+    ProcessPtrList::iterator end =  m_processPtrList.end();
+    while(it != end && !m_stop)
+    {
+      ProcessPtrList::iterator next = it;
+      next++;
+      Process* process = (*it).get();
+      if(process->isStopped())
+      {
+        if(process->needsReset())
+        {
+          Time resetTime = process->getResetTime();
+          if(resetTime <= 0)
+          {
+            process->start();
+            if(pListener)
+            {
+              pListener->started(process->getProperties());
+            }
+            m_processWatchdog.add(process);
+          }
+          else if(wait <= 0 || resetTime < wait)
+          {
+            wait = resetTime;
+          }
+        }
+        else
+        {
+          m_processPtrList.erase(it);
+        }
+      }
+      it = next;
+    }
+    return wait;
+  }
+  void ProcessListImpl::closeWindows(const WindowList& winList)
+  {
+    if(winList.size() > 0)
+    {
+      WindowList::const_iterator it = winList.begin();
+      WindowList::const_iterator end = winList.end();
+      for(; it != end; it++)
+      {
+        (*it)->close();
+      }
+    }
+  }
+  void ProcessListImpl::stoppingProcesses(const ProcessSet& processSet)
+  {
+    ProcessSet::const_iterator it = processSet.begin();
+    ProcessSet::const_iterator end = processSet.end();
+    for(; it != end; it++)
+    {
+      (*it)->setStopping();
+    }
+  }
+  ProcessSet ProcessListImpl::getProcessSet(const std::string& group)
+  {
+    ProcessPtrList::iterator it =  m_processPtrList.begin();
+    ProcessPtrList::iterator end =  m_processPtrList.end();
+    ProcessSet result;
+    for(; it != end; it++)
+    {
+      Process* process = (*it).get();
+      if(process->getProperties().group == group)
+      {
+        result.insert(process);
+      }
+    }
+    return result;
+  }
+  WindowList ProcessListImpl::searchWindows(WindowSearchType search, const std::string& group)
+  {
+    return searchWindows(search, getProcessSet(group));
+  }
+  void ProcessListImpl::stop(const std::string& group)
+  {
+    stop(getProcessSet(group));
+  }
+
+  WindowList ProcessListImpl::searchWindows(WindowSearchType search, ProcessSet& processSet)
+  {
+    WindowSearchData data;
+    ProcessSet::const_iterator it = processSet.begin();
+    ProcessSet::const_iterator end = processSet.end();
+    for(; it != end; it++)
+    {
+      (*it)->setWindowSearch(search);
+      data.processSet.insert(*it);
+    }
+    m_windowSearch = processSet;
+    data.useProcessId = true;
+    data.useProcessDesktop = true;
+    WindowMatch windowMatch;
+    WindowSearch searchWindow(data, windowMatch, m_trc);
+    searchWindow.search();
+    processSet = m_windowSearch;
+    return searchWindow.getList();
+  }
+  void ProcessListImpl::sendBreak(ProcessSet& processSet)
+  {
+    ProcessSet::iterator it = processSet.begin();
+    ProcessSet::iterator end = processSet.end();
+    while(it != end)
+    {
+      ProcessSet::iterator next = it;
+      next++;
+      if((*it)->sendBreak())
+      {
+        processSet.erase(it);
+      }
+      it= next;
+    }
+  }
+  void ProcessListImpl::sendCtrlC(ProcessSet& processSet)
+  {
+    ProcessSet::iterator it = processSet.begin();
+    ProcessSet::iterator end = processSet.end();
+    while(it != end)
+    {
+      ProcessSet::iterator next = it;
+      next++;
+      if((*it)->sendCtrlC())
+      {
+        processSet.erase(it);
+      }
+      it= next;
+    }
+  }
+  void ProcessListImpl::kill(const ProcessSet& processSet)
+  {
+    ProcessSet::const_iterator it = processSet.begin();
+    ProcessSet::const_iterator end = processSet.end();
+    for(; it != end; it++)
+    {
+      (*it)->kill();
+    }
+  }
+  void ProcessListImpl::wait(const ProcessSet& processSet)
+  {
+    int terminationTime = m_settings.waitTimeout;
+    unsigned long start = mSysTime::getUpTime();
+    ProcessSet::const_iterator it = processSet.begin();
+    ProcessSet::const_iterator end = processSet.end();
+    for(; it != end; it++)
+    {
+      child* pProcess = (*it)->getProcess();
+      if(pProcess && pProcess->getStatus() == STATUS_RUNNING)
+      {
+        const ProcessProperties& prop = (*it)->getProperties();
+        m_trc.writeTrace(BasicRuntime_HERE,
+          "wait for\t(%s)\tCOMP(%s)\tCMD(%s)",
+          pProcess->getProcessId().c_str(),
+          prop.group.c_str(),
+          prop.commandLine.c_str()
+        );
+
+        unsigned long now = mSysTime::getUpTime();
+        int remain = terminationTime - (now - start);
+        if(remain <= 0)
+        {
+          break;
+        }
+        pProcess->waitForTermination(remain/1000);
+      }
+    }
+  }
+  void ProcessListImpl::match(Process& process)
+  {
+    m_windowSearch.erase(&process);
+  }
+  /*
+    - send WM_CLOSE to windows found by title/class
+    - send WM_CLOSE to visible windows of remaining processes
+    - send Ctrl-Break to remaining processes
+    - send WM_CLOSE to all windows of remaining processes
+    - wait for process termination
+
+    - send Ctrl-Break to remaining processes
+    - send WM_CLOSE to all windows of remaining processes
+    - wait for process termination
+
+    - call TerminateProcess for remaining processes
+    - wait for process termination
+  */
+  void ProcessListImpl::stop(const ProcessSet& processSet)
+  {
+    stoppingProcesses(processSet);
+    ProcessSet remain = processSet;
+    closeWindows(searchWindows(WND_TITLE_CLASS, remain));
+    closeWindows(searchWindows(WND_VISIBLE, remain));
+    sendBreak(remain);
+    closeWindows(searchWindows(WND_ALL, remain));
+    wait(processSet);
+
+    remain = processSet;
+    sendBreak(remain);
+    closeWindows(searchWindows(WND_ALL, remain));
+    wait(processSet);
+
+    kill(processSet);
+    wait(processSet);
+  }
+  PropertySet ProcessListImpl::getPropertySet(const PropertyList& list)
+  {
+    PropertySet result;
+    PropertyList::const_iterator it = list.begin();
+    PropertyList::const_iterator end = list.end();
+    for(; it != end; it++)
+    {
+      result.insert(*it);
+    }
+    return result;
+  }
+  PropertySet ProcessListImpl::getPropertySet(const ProcessPtrList& list)
+  {
+    PropertySet result;
+    ProcessPtrList::const_iterator it = list.begin();
+    ProcessPtrList::const_iterator end = list.end();
+    for(; it != end; it++)
+    {
+      result.insert((*it)->getProperties());
+    }
+    return result;
+  }
+  PropertyList ProcessListImpl::getDiff(const PropertyList& minuend, const ProcessPtrList& subtrahend)
+  {
+    PropertySet set = getPropertySet(subtrahend);
+    PropertyList result;
+    PropertyList::const_iterator it = minuend.begin();
+    PropertyList::const_iterator end = minuend.end();
+    for(; it != end; it++)
+    {
+      const ProcessProperties& prop = *it;
+      if(set.find(prop) == set.end())
+      {
+        result.push_back(prop);
+      }
+    }
+    return result;
+  }
+  ProcessSet ProcessListImpl::getDiff(const ProcessPtrList& minuend, const PropertyList& subtrahend)
+  {
+    PropertySet set = getPropertySet(subtrahend);
+    ProcessSet result;
+    ProcessPtrList::const_iterator it = minuend.begin();
+    ProcessPtrList::const_iterator end = minuend.end();
+    for(; it != end; it++)
+    {
+      const ProcessProperties& prop = (*it)->getProperties();
+      if(set.find(prop) == set.end())
+      {
+        result.insert((*it).get());
+      }
+    }
+    return result;
+  }
+}
+
+namespace mSysProcess
+{
+  /*
+    control list of child processes
+  */
+  class ProcessList::Impl:
+    private mSysThread::thread,
+    private ProcessListImpl
+  {
+    public:
+      ProcessList::Impl(TraceInterface& trc, const WatchdogSettings& settings);
+      void start(ProcessListSettings* pSettings);
+      void stop();
+      void checkProcessList();
+      void setListener(ProcessListCallback* pListener);
+
+    private:
+      virtual void function();
+      virtual void notify(WaitNotification* pNotification);
+
+      void setState(State state);
+      void stateChanged();
+      State getState();
+      void process();
+
+      ProcessListSettings* m_pSettings;
+      eventSemaphore m_event;
+      Mutex m_access;
+      State m_state;
+      bool m_settingsChanged;
+      bool m_processTerminated;
+      Time m_waitTime;
+  };
+  /*
+    control list of child processes
+  */
+  class ApplicationList::Impl:
+    private ProcessListImpl
+  {
+    public:
+      Impl(TraceInterface& trc, const WatchdogSettings& settings);
+      ~Impl();
+      void start(const PropertyList& processes);
+      void stop(const std::string& group);
+      void stopAll();
+      WindowList findWinByTitleClassName(const std::string& group);
+      WindowList findVisibleWin(const std::string& group);
+      Time checkForTerminatedProcesses();
+  };
+
+  /*
+    control list of child processes
+  */
+  ProcessList::Impl::Impl(TraceInterface& trc, const WatchdogSettings& settings):
+    thread(0),
+    ProcessListImpl(trc, settings),
+    m_pSettings(0),
+    m_event(),
+    m_access(),
+    m_state(INIT),
+    m_settingsChanged(true),
+    m_processTerminated(false),
+    m_waitTime(0)
+  {}
+  void ProcessList::Impl::setListener(ProcessListCallback* pListener)
+  {
+    ProcessListImpl::setListener(pListener);
+  }
+  void ProcessList::Impl::checkProcessList()
+  {
+    AutoMutexCS mx(m_access);
+    if(m_pSettings != 0)
+    {
+      setState(PROCESS);
+      m_settingsChanged = true;
+    }
+  }
+  void ProcessList::Impl::start(ProcessListSettings* pSettings)
+  {
+    m_pSettings = pSettings;
+    thread::start();
+  }
+  void ProcessList::Impl::stop()
+  {
+    cancelStart();
+    setState(STOPPING);
+    waitTerminated();
+  }
+  void ProcessList::Impl::notify(WaitNotification* pNotification)
+  {
+    ProcessListImpl::notify(pNotification);
+    AutoMutexCS mx(m_access);
+    setState(PROCESS);
+    m_processTerminated = true;
+  }
+  void ProcessList::Impl::function()
+  {
+    standardException guard;
+    try
+    {
+      startWatchdog();
+      setState(PROCESS);
+      State state = getState();
+      while(state != STOPPING)
+      {
+        if(state == PROCESS)
+        {
+          process();
+        }
+        else if(m_waitTime > 0)
+        {
+          getTrc().writeTrace(BasicRuntime_HERE, "wait: (%d)", m_waitTime);
+          m_event.wait(m_waitTime);
+          {
+            AutoMutexCS mx(m_access);
+            setState(PROCESS);
+            m_processTerminated = true;
+          }
+        }
+        else
+        {
+          getTrc().writeTraceText(BasicRuntime_HERE, "wait");
+          m_event.wait();
+        }
+        state = getState();
+      }
+      PropertyList emptyList;
+      update(emptyList);
+
+      stopWatchdog();
+      setState(STOPPED);
+    }
+    catch(std::exception& x)
+    {
+      getTrc().writeTraceText(MajorError_HERE, x.what());
+    }
+  }
+  void ProcessList::Impl::setState(State state)
+  {
+    AutoMutexCS mx(m_access);
+    if((m_state != STOPPED)
+      && (m_state != STOPPING || state == STOPPED))
+    {
+      m_state = state;
+      stateChanged();
+    }
+  }
+  void ProcessList::Impl::stateChanged()
+  {
+    AutoMutexCS mx(m_access);
+    m_event.post();
+    getTrc().writeTrace(SecondaryFrequent_HERE,
+      "processor state changed (%d, %s)",
+      m_state, getStateText(m_state).c_str());
+  }
+  State ProcessList::Impl::getState()
+  {
+    AutoMutexCS mx(m_access);
+    State state = m_state;
+    m_event.reset();
+    return state;
+  }
+  void ProcessList::Impl::process()
+  {
+    bool configChanged = false;
+    bool processTerminated = false;
+    {
+      AutoMutexCS mx(m_access);
+      configChanged = m_settingsChanged;
+      processTerminated = m_processTerminated;
+      m_settingsChanged = false;
+      m_processTerminated =  false;
+      setState(IDLE);
+    }
+    if(configChanged)
+    {
+      PropertyList newPropertyList = m_pSettings->getProcessList();
+      ProcessListCallback* pListener= getListener();
+      if(pListener)
+      {
+        pListener->start(newPropertyList);
+      }
+      update(newPropertyList);
+    }
+    if(processTerminated)
+    {
+      m_waitTime = checkTerminated();
+    }
+  }
+  /*
+    control list of child processes
+  */
+  ApplicationList::Impl::Impl(TraceInterface& trc, const WatchdogSettings& settings):
+    ProcessListImpl(trc, settings)
+  {
+    startWatchdog();
+  }
+  ApplicationList::Impl::~Impl()
+  {
+    stopWatchdog();
+  }
+  void ApplicationList::Impl::start(const PropertyList& processes)
+  {
+    ProcessListImpl::start(processes);
+  }
+  void ApplicationList::Impl::stop(const std::string& group)
+  {
+    ProcessListImpl::stop(group);
+  }
+  void ApplicationList::Impl::stopAll()
+  {
+    PropertyList emptyList;
+    update(emptyList);
+  }
+  Time ApplicationList::Impl::checkForTerminatedProcesses()
+  {
+    return checkTerminated();
+  }
+  WindowList ApplicationList::Impl::findWinByTitleClassName(const std::string& group)
+  {
+    return searchWindows(WND_TITLE_CLASS, group);
+  }
+  WindowList ApplicationList::Impl::findVisibleWin(const std::string& group)
+  {
+    return searchWindows(WND_VISIBLE, group);
+  }
+  /*
+    settings for a process
+  */
+  ProcessProperties::ProcessProperties():
+    group(),
+    commandLine(),
+    workingDir(),
+    windowTitle(),
+    windowClass(),
+    show(HIDE),
+    timeout(0),
+    desktop()
+  {}
+  bool ProcessProperties::operator<(const ProcessProperties& cmp) const
+  {
+    return group < cmp.group
+      || (group == cmp.group
+        && commandLine < cmp.commandLine
+         || (commandLine == cmp.commandLine
+           && (workingDir < cmp.workingDir
+             || (workingDir == cmp.workingDir
+               && (windowTitle < cmp.windowTitle
+                 || (windowTitle == cmp.windowTitle
+                   && (windowClass < cmp.windowClass
+                     || (windowClass == cmp.windowClass
+                       && (desktop < cmp.desktop
+                         || (desktop == cmp.desktop
+                             && (show < cmp.show)))))))))));
+  }
+  /*
+    settings for ProcessList
+  */
+  ProcessListSettings::~ProcessListSettings()
+  {}
+  /*
+    control list of child processes
+  */
+  ProcessList::ProcessList(TraceInterface& trc, const WatchdogSettings& settings):
+    m_pImpl(new Impl(trc, settings))
+  {}
+  ProcessList::~ProcessList()
+  {}
+  void ProcessList::start(ProcessListSettings* settings)
+  {
+    m_pImpl->start(settings);
+  }
+  void ProcessList::stop()
+  {
+    m_pImpl->stop();
+  }
+  void ProcessList::checkProcessList()
+  {
+    m_pImpl->checkProcessList();
+  }
+  void ProcessList::setListener(ProcessListCallback* pListener)
+  {
+    m_pImpl->setListener(pListener);
+  }
+  ProcessListCallback::ProcessListCallback()
+  {}
+  ProcessListCallback::~ProcessListCallback()
+  {}
+
+  /*
+    control list of child processes
+  */
+  ApplicationList::ApplicationList(TraceInterface& trc, const WatchdogSettings& settings):
+    m_pImpl(new Impl(trc, settings))
+  {}
+  ApplicationList::~ApplicationList()
+  {}
+  void ApplicationList::start(const PropertyList& processes)
+  {
+    m_pImpl->start(processes);
+  }
+  void ApplicationList::stop(const std::string& group)
+  {
+    m_pImpl->stop(group);
+  }
+  void ApplicationList::stopAll()
+  {
+    m_pImpl->stopAll();
+  }
+  Time ApplicationList::checkForTerminatedProcesses()
+  {
+    return m_pImpl->checkForTerminatedProcesses();
+  }
+  WindowList ApplicationList::findWinByTitleClassName(const std::string& group)
+  {
+    return m_pImpl->findWinByTitleClassName(group);
+  }
+  WindowList ApplicationList::findVisibleWin(const std::string& group)
+  {
+    return m_pImpl->findWinByTitleClassName(group);
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/Systools/src/mSysProcessTerminateW32.cpp b/SelfServiceCommon/Massai/cpp/Systools/src/mSysProcessTerminateW32.cpp
new file mode 100644
index 00000000..0e90e590
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Systools/src/mSysProcessTerminateW32.cpp
@@ -0,0 +1,230 @@
+/**
+ * control shutdown of current process
+**/
+
+#include "systools/mSysProcessTerminate.h"
+#include "mSysErrorW32.h"
+#include <windows.h>
+#include <signal.h>
+
+using MASSAI::trace::TraceInterface;
+using Materna::MSSD::eventSemaphore;
+using namespace mSysProcessTerminate;
+
+namespace
+{
+  typedef void (__cdecl *SignalHandler)(int);
+  /*
+    register for terminate event
+    event is posted if an event occurs
+  */
+  class TerminateData
+  {
+    public:
+      TerminateData(ShutdownPriority priority, eventSemaphore* pEvent, TraceInterface* pTrc);
+      ~TerminateData();
+      void registerForShutdown();
+      void cleanup();
+      void notify(const char* event);
+    private:
+      void setSignalHandler();
+      void resetSignalHandler();
+      void setCtrlHandler();
+      void resetCtrlHandler();
+      void setShutdownParameter();
+      void resetShutdownParameter();
+
+      TraceInterface* m_trc;
+      ShutdownPriority m_priority;
+      DWORD m_shutdownPriority;
+      DWORD m_shutdownFlags;
+      SignalHandler m_abrt;
+      SignalHandler m_term;
+      SignalHandler m_segv;
+      SignalHandler m_ill;
+      SignalHandler m_fpe;
+      eventSemaphore* m_pEvent;
+      const char* m_name;
+  };
+  TerminateData* pData= 0;
+
+  const char* getCTRLName(DWORD type)
+  {
+    switch(type)
+    {
+      case CTRL_BREAK_EVENT:     return "CTRL_BREAK";
+      case CTRL_C_EVENT:         return "CTRL_C";
+      case CTRL_CLOSE_EVENT:     return "CLOSE";
+      case CTRL_SHUTDOWN_EVENT:  return "SHUTDOWN";
+      case CTRL_LOGOFF_EVENT:    return "LOGOFF";
+      default:                   return "unknown ctrl event";
+    }
+  }
+  const char* getSignalName(int type)
+  {
+    switch(type)
+    {
+      case SIGABRT:  return "ABRT";
+      case SIGBREAK: return "BREAK";
+      case SIGTERM:  return "TERM";
+      case SIGINT:   return "INT";
+      case SIGFPE:   return "FPE";
+      case SIGSEGV:  return "SEGV";
+      case SIGILL:   return "ILL";
+      default:       return "unknown signal";
+    }
+  }
+  BOOL WINAPI ctrlHandler(DWORD type)
+  {
+    BOOL result = false; // not handled here, forward to other handler
+    switch(type)
+    {
+      case CTRL_BREAK_EVENT:
+      case CTRL_C_EVENT:
+      case CTRL_CLOSE_EVENT:
+      case CTRL_SHUTDOWN_EVENT:
+      {
+        const char* name= getCTRLName(type);
+        if(pData != 0)
+        {
+          pData->notify(name);
+        }
+        result = true; // handled here
+        break;
+      }
+      case CTRL_LOGOFF_EVENT:
+      default:
+        break;
+    }
+    return true;
+  }
+  void signalHandler(int code)
+  {
+    signal(code, signalHandler);
+    const char* name= getSignalName(code);
+    if(pData != 0)
+    {
+      pData->notify(name);
+    }
+  }
+  DWORD getPriority(ShutdownPriority priority)
+  {
+    switch(priority)
+    {
+      case SHUTDOWN_EARLY: return 0x380;
+      case SHUTDOWN_LATE:  return 0x180;
+      default:             return 0x280;
+    }
+  }
+  /*
+    register for terminate event
+    event is posted if an event occurs
+  */
+  TerminateData::TerminateData(ShutdownPriority priority, eventSemaphore* pEvent, TraceInterface* pTrc):
+    m_trc(pTrc),
+    m_priority(priority),
+    m_shutdownPriority(0),
+    m_shutdownFlags(0),
+    m_abrt(0),
+    m_term(0),
+    m_segv(0),
+    m_ill(0),
+    m_fpe(0),
+    m_pEvent(pEvent),
+    m_name("no signal")
+  {}
+  TerminateData::~TerminateData()
+  {}
+  void TerminateData::registerForShutdown()
+  {
+    setSignalHandler();
+    setCtrlHandler();
+    setShutdownParameter();
+  }
+  void TerminateData::cleanup()
+  {
+    resetSignalHandler();
+    resetCtrlHandler();
+    resetShutdownParameter();
+    m_trc->writeTrace(MajorError_HERE, "terminated by (%s)", m_name);
+  }
+  void TerminateData::notify(const char* event)
+  {
+    m_name= event;
+    m_pEvent->post();
+  }
+  void TerminateData::setSignalHandler()
+  {
+    // signal(SIGBREAK, signalHandler); // handled by ctrlHandler
+    // signal(SIGINT,   signalHandler); // handled by ctrlHandler
+    m_abrt = signal(SIGABRT, signalHandler);
+    m_term = signal(SIGTERM, signalHandler);
+    m_segv = signal(SIGSEGV, signalHandler);
+    m_ill  = signal(SIGILL,  signalHandler);
+    m_fpe  = signal(SIGFPE,  signalHandler);
+  }
+  void TerminateData::resetSignalHandler()
+  {
+    // signal(SIGBREAK, signalHandler); // handled by ctrlHandler
+    // signal(SIGINT,   signalHandler); // handled by ctrlHandler
+    signal(SIGABRT, m_abrt);
+    signal(SIGTERM, m_term);
+    signal(SIGSEGV, m_segv);
+    signal(SIGILL,  m_ill);
+    signal(SIGFPE,  m_fpe);
+  }
+  void TerminateData::setCtrlHandler()
+  {
+    if(!SetConsoleCtrlHandler(ctrlHandler, true))  // add handler
+    {
+      mSysError::traceLastError(*m_trc, MajorError_HERE, "SetConsoleCtrlHandler", mSysError::getErrorCode());
+    }
+  }
+  void TerminateData::resetCtrlHandler()
+  {
+    if(!SetConsoleCtrlHandler(ctrlHandler, false)) // remove handler
+    {
+      mSysError::traceLastError(*m_trc, MajorError_HERE, "SetConsoleCtrlHandler", mSysError::getErrorCode());
+    }
+  }
+  void TerminateData::setShutdownParameter()
+  {
+    if(!GetProcessShutdownParameters(&(m_shutdownPriority), &(m_shutdownFlags)))
+    {
+      mSysError::traceLastError(*m_trc, MajorError_HERE, "GetProcessShutdownParameters", mSysError::getErrorCode());
+      m_shutdownPriority = getPriority(SHUTDOWN_NORMAL);
+      m_shutdownFlags = 0;
+    }
+    if(!SetProcessShutdownParameters(getPriority(m_priority), m_shutdownFlags | SHUTDOWN_NORETRY))
+    {
+      mSysError::traceLastError(*m_trc, MajorError_HERE, "SetProcessShutdownParameters", mSysError::getErrorCode());
+    }
+  }
+  void TerminateData::resetShutdownParameter()
+  {
+    if(!SetProcessShutdownParameters(m_shutdownPriority, m_shutdownFlags))
+    {
+      mSysError::traceLastError(*m_trc, MajorError_HERE, "SetProcessShutdownParameters", mSysError::getErrorCode());
+    }
+  }
+}
+namespace mSysProcessTerminate
+{
+  void setShutdownHook(ShutdownPriority priority, eventSemaphore* pEvent, TraceInterface* pTrc)
+  {
+    if(pData == 0)
+    {
+      pData= new TerminateData(priority, pEvent, pTrc);
+      pData->registerForShutdown();
+    }
+  }
+  void resetShutdownHook()
+  {
+    if(pData != 0)
+    {
+      pData->cleanup();
+      delete pData;
+      pData= 0;
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/Systools/src/mSysProcessW32.cpp b/SelfServiceCommon/Massai/cpp/Systools/src/mSysProcessW32.cpp
index 81a86a0d..3d883ecc 100644
--- a/SelfServiceCommon/Massai/cpp/Systools/src/mSysProcessW32.cpp
+++ b/SelfServiceCommon/Massai/cpp/Systools/src/mSysProcessW32.cpp
@@ -12,21 +12,36 @@
  **************************************************************************
 **/
 
+#pragma warning (disable: 4786)
 #include "systools/mSysProcess.hpp"
 
+#include "mSysErrorW32.h"
+#include "mSysProcessW32.h"
+#include "mSysSynchronizeW32.h"
+#include "mSysTimeW32.h"
+#include "psapi.h"
 #include "systools/mSysThread.hpp"
 #include "systools/software_error.h"
+#include "tools/StringBuffer.h"
+
 #include <string>
+#include <sstream>
+#include <iomanip>
+#include <windows.h>
+
+#ifdef _MSC_VER
+#if _MSC_VER <= 1200 // 1200 == VC6
+#include "mSysProcessIOCountersW32.h"
+#endif
+#endif
+
 
-#include<windows.h>
 #pragma comment(lib, "User32.lib")
 
 
 
 namespace
 {
-
-
    /**
     *
     * Called upon windows function failure this will trace the last
@@ -61,463 +76,827 @@ namespace
       }
    }
 
-
-} // namespace
-
-
-
-/**
- *
- * Streaming stderr or stdout.
- *
-**/
-class fromChild :
-   public mSysThread::thread
-{
-
-
-   bool                                 M_Active;
-
-   std::string                          M_Buffer;
-
-   HANDLE                               M_HandleOutRead;
-
-   HANDLE                               M_HandleOutWrite;
-
-   mSysProcess::callBack const *        M_LineOut;
-
-   mSysProcess::callBack const *        M_Logging;
-
-   void function()
+   std::string getStatusText(mSysProcess::status status)
    {
-      char Buffer[1024];
-      while( M_Active )
-      {
-         DWORD BytesRead = 0;
-         if (
-            !ReadFile
-               (
-                  M_HandleOutRead,
-                  Buffer,
-                  sizeof(Buffer),
-                  &BytesRead,
-                  NULL
-               )
-            || !BytesRead
-            )
-         {
-            if( GetLastError() != ERROR_BROKEN_PIPE )
-               logLastError( M_Logging, "ReadFile" );
-            M_Active = false;
-         }
-         else
-         {
-            Buffer[BytesRead] = 0;
-            M_Buffer += Buffer;
-            unsigned Off = M_Buffer.find_first_of( "\r\n" );
-            while( Off != std::string::npos )
-            {
-               std::string Sub = M_Buffer.substr( 0 , Off );
-               if( Sub.size() )
-                  M_LineOut->lineOut( Sub.c_str() );
-               M_Buffer.erase( 0, Off + 1 );
-               Off = M_Buffer.find_first_of( "\r\n" );
-            }
-         }
-      }
+     switch(status)
+     {
+       case mSysProcess::STATUS_FAILED:      return "failed";
+       case mSysProcess::STATUS_RUNNING:     return "running";
+       case mSysProcess::STATUS_TERMINATED:  return "terminated";
+       default:                              return "unknown";
+     }
    }
-
-
-public:
-
-
-   explicit fromChild( threadException const * ThreadExeption ) :
-      mSysThread::thread( ThreadExeption ),
-      M_Active( false ),
-      M_Buffer(),
-      M_HandleOutRead( INVALID_HANDLE_VALUE ),
-      M_HandleOutWrite( INVALID_HANDLE_VALUE ),
-      M_LineOut( 0 ),
-      M_Logging( 0 )
+   std::ostream& operator<<(std::ostream& out, const mSysTime::Duration& duration)
    {
+     out << std::dec;
+     out << (duration.days*24 + duration.hours) << ":";
+     out << std::right << std::setfill('0');
+     out << std::setw(2) << duration.minutes << ":";
+     out << std::setw(2) << duration.seconds << ",";
+     out << std::setw(2) << duration.milliseconds;
+     return out;
    }
-
-
-   ~fromChild()
+   std::ostream& operator<<(std::ostream& out, const mSysTime::Timestamp& timestamp)
    {
-      try
-      {
-         if( M_Active )
-         {
-            M_Active = false;
-            //
-            // To force a return from ReadFile() in the thread function
-            // we write a dummy string.
-            // Just CloseHandle() will not work.
-            //
-            DWORD BytesWritten = 0;
-            if (
-               !WriteFile
-                  (
-                     M_HandleOutWrite,
-                     "~",
-                     1,
-                     &BytesWritten,
-                     NULL
-                  )
-                  || !BytesWritten
-               )
-            {
-               if( GetLastError() != ERROR_BROKEN_PIPE )
-                  logLastError( M_Logging, "WriteFile" );
-            }
-            //
-            waitTerminated();
-            CloseHandle( M_HandleOutWrite );
-         }
-      }
-      catch( ... )
-      {
-      }
+     out << std::dec;
+     out << std::right << std::setfill('0');
+     out << std::setw(2) << timestamp.day << ".";
+     out << std::setw(2) << timestamp.month << ".";
+     out << std::setw(4) << timestamp.year << " ";
+     out << std::setw(2) << timestamp.hour << ":";
+     out << std::setw(2) << timestamp.minute << ":";
+     out << std::setw(2) << timestamp.second << ",";
+     out << std::setw(2) << timestamp.milliseconds;
+     return out;
    }
-
-
-   HANDLE getHandle( mSysProcess::callBack const * LineOut )
+#ifdef _MSC_VER
+#if _MSC_VER <= 1200 // 1200 == VC6
+   std::ostream& operator<<(std::ostream& out, unsigned __int64 number)
    {
-      M_LineOut = LineOut;
-      SECURITY_ATTRIBUTES Sa;
-      Sa.nLength= sizeof(SECURITY_ATTRIBUTES);
-      Sa.lpSecurityDescriptor = NULL;
-      Sa.bInheritHandle = TRUE;
-      HANDLE HandleOutReadTmp;
-      // Create the child output pipe.
-      if( !CreatePipe( &HandleOutReadTmp, &M_HandleOutWrite, &Sa, 0 ) )
-         logLastError( M_Logging, "CreatePipe" );
-      if( !DuplicateHandle
-               (
-                  GetCurrentProcess(),
-                  HandleOutReadTmp,
-                  GetCurrentProcess(),
-                  &M_HandleOutRead, // Address of new handle.
-                  0,FALSE, // Make it uninheritable.
-                  DUPLICATE_SAME_ACCESS
-               ) )
-         logLastError( M_Logging, "DupliateHandle" );
-      if( !CloseHandle( HandleOutReadTmp ) )
-         logLastError( M_Logging, "CloseHandle" );
-      M_Active = true;
-      return M_HandleOutWrite;
+     char buffer[255];
+     _ui64toa(number, buffer, 10);
+     out << buffer;
+     return out;
    }
+#endif
+#endif
 
-
-   void setLogging( mSysProcess::callBack const & LineOut )
+   std::string getEnvironmentBlock(const mSysProcess::Environment& environment)
    {
-      M_Logging = &LineOut;
+     std::string result;
+     mSysProcess::Environment::const_iterator it = environment.begin();
+     mSysProcess::Environment::const_iterator end = environment.end();
+     int size= 1;
+     for(; it != end; it++)
+     {
+       size+= it->first.size() + it->second.size() + 2;
+     }
+     result.reserve(size);
+     it = environment.begin();
+     for(; it != end; it++)
+     {
+       result.append(it->first);
+       result.append("=");
+       result.append(it->second);
+       result.append(1, 0);
+     }
+     result.append(1, 0);
+     return result;
    }
 
 
-private:
-
-
-   //! Default constructor - intentionally not implemented.
-   fromChild();
-
-
-};
-
-
-
-/**
- *
- * Implementation class.
- *
-**/
-class myChild :
-   public mSysProcess::child
-{
-
-   fromChild                            M_ChildErr;
-
-   fromChild                            M_ChildOut;
-
-   std::string                          M_Commandline;
-
-   std::string                          M_Directory;
-
-   HANDLE                               M_HandleInRead;
-
-   HANDLE                               M_HandleInWrite;
-
-   HANDLE                               M_HandleProcess;
-
-   mSysProcess::callBack const *        M_Logging;
-
-   bool                                 M_Started;
-
-   mSysProcess::callBack const *        M_StdErr;
-
-   bool                                 M_StdIn;
-
-   mSysProcess::callBack const *        M_StdOut;
-
-
-
-public:
-
-
-   /**
-    *
-    * Constructor.
-    *
-   **/
-   myChild
+  /**
+   *
+   * Streaming stderr or stdout.
+   *
+  **/
+  class fromChild :
+     public mSysThread::thread
+  {
+    public:
+      explicit fromChild(threadException const * ThreadExeption);
+      ~fromChild();
+      HANDLE getHandle(mSysProcess::callBack const * LineOut);
+      void setLogging(mSysProcess::callBack const & LineOut);
+
+    private:
+      bool                           M_Active;
+      std::string                    M_Buffer;
+      HANDLE                         M_HandleOutRead;
+      HANDLE                         M_HandleOutWrite;
+      mSysProcess::callBack const *  M_LineOut;
+      mSysProcess::callBack const *  M_Logging;
+      void function();
+      //! Default constructor - intentionally not implemented.
+      fromChild();
+  };
+
+
+
+  /**
+   *
+   * class fromChild
+   * Streaming stderr or stdout.
+   *
+  **/
+  void fromChild::function()
+  {
+     char Buffer[1024];
+     while( M_Active )
+     {
+        DWORD BytesRead = 0;
+        if (
+           !ReadFile
+              (
+                 M_HandleOutRead,
+                 Buffer,
+                 sizeof(Buffer),
+                 &BytesRead,
+                 NULL
+              )
+           || !BytesRead
+           )
+        {
+           if( GetLastError() != ERROR_BROKEN_PIPE )
+              logLastError( M_Logging, "ReadFile" );
+           M_Active = false;
+        }
+        else
+        {
+           Buffer[BytesRead] = 0;
+           M_Buffer += Buffer;
+           unsigned Off = M_Buffer.find_first_of( "\r\n" );
+           while( Off != std::string::npos )
+           {
+              std::string Sub = M_Buffer.substr( 0 , Off );
+              if( Sub.size() )
+                 M_LineOut->lineOut( Sub.c_str() );
+              M_Buffer.erase( 0, Off + 1 );
+              Off = M_Buffer.find_first_of( "\r\n" );
+           }
+        }
+     }
+  }
+  fromChild::fromChild( threadException const * ThreadExeption ) :
+     mSysThread::thread( ThreadExeption ),
+     M_Active( false ),
+     M_Buffer(),
+     M_HandleOutRead( INVALID_HANDLE_VALUE ),
+     M_HandleOutWrite( INVALID_HANDLE_VALUE ),
+     M_LineOut( 0 ),
+     M_Logging( 0 )
+  {}
+  fromChild::~fromChild()
+  {
+     try
+     {
+        if( M_Active )
+        {
+           M_Active = false;
+           //
+           // To force a return from ReadFile() in the thread function
+           // we write a dummy string.
+           // Just CloseHandle() will not work.
+           //
+           DWORD BytesWritten = 0;
+           if (
+              !WriteFile
+                 (
+                    M_HandleOutWrite,
+                    "~",
+                    1,
+                    &BytesWritten,
+                    NULL
+                 )
+                 || !BytesWritten
+              )
+           {
+              if( GetLastError() != ERROR_BROKEN_PIPE )
+                 logLastError( M_Logging, "WriteFile" );
+           }
+           //
+           waitTerminated();
+           CloseHandle( M_HandleOutWrite );
+        }
+     }
+     catch( ... )
+     {
+     }
+  }
+
+
+  HANDLE fromChild::getHandle( mSysProcess::callBack const * LineOut )
+  {
+     M_LineOut = LineOut;
+     SECURITY_ATTRIBUTES Sa;
+     Sa.nLength= sizeof(SECURITY_ATTRIBUTES);
+     Sa.lpSecurityDescriptor = NULL;
+     Sa.bInheritHandle = TRUE;
+     HANDLE HandleOutReadTmp;
+     // Create the child output pipe.
+     if( !CreatePipe( &HandleOutReadTmp, &M_HandleOutWrite, &Sa, 0 ) )
+        logLastError( M_Logging, "CreatePipe" );
+     if( !DuplicateHandle
+              (
+                 GetCurrentProcess(),
+                 HandleOutReadTmp,
+                 GetCurrentProcess(),
+                 &M_HandleOutRead, // Address of new handle.
+                 0,FALSE, // Make it uninheritable.
+                 DUPLICATE_SAME_ACCESS
+              ) )
+        logLastError( M_Logging, "DupliateHandle" );
+     if( !CloseHandle( HandleOutReadTmp ) )
+        logLastError( M_Logging, "CloseHandle" );
+     M_Active = true;
+     return M_HandleOutWrite;
+  }
+
+
+  void fromChild::setLogging( mSysProcess::callBack const & LineOut )
+  {
+     M_Logging = &LineOut;
+  }
+
+
+
+  /**
+   *
+   * Control a child process.
+   *
+   * Implementation of child, see sysTools/mSysProcess.hpp
+   *
+  **/
+  class myChild: public mSysProcess::child
+  {
+    public:
+
+      myChild
       (
-         std::string const &            Commandline,
-         std::string const &            Directory,
-         bool                           Hide,
-         mSysProcess::callBack const *  Logging,
-         bool                           Minimized,
-         mSysProcess::callBack const *  StdErr,
-         bool                           StdIn,
-         mSysProcess::callBack const *  StdOut,
-         threadException const *        ThreadExeption
-      ) :
-      M_ChildErr( ThreadExeption ),
-      M_ChildOut( ThreadExeption ),
-      M_Commandline( Commandline ),
-      M_Directory( Directory ),
-      M_HandleInRead( INVALID_HANDLE_VALUE ),
-      M_HandleInWrite( INVALID_HANDLE_VALUE ),
-      M_HandleProcess( INVALID_HANDLE_VALUE ),
-      M_Logging( Logging ),
-      M_Started( false ),
-      M_StdErr( StdErr ),
-      M_StdIn( StdIn ),
-      M_StdOut( StdOut )
-   {
-      STARTUPINFO Si;
-
-      // Set up the start up info struct.
-      ZeroMemory( &Si, sizeof(STARTUPINFO) );
-      Si.cb = sizeof(STARTUPINFO);
-      Si.dwFlags = STARTF_USESTDHANDLES         // Use the hStd... flags
-                 | STARTF_USESHOWWINDOW;        // Use the wShowWindow flag
-      if( Hide )
-      {
-         Si.wShowWindow = SW_HIDE;
-      }
-      else if( Minimized )
-      {
-         Si.wShowWindow = SW_SHOWMINIMIZED;
-      }
-      else
-      {
-         Si.wShowWindow = SW_SHOW;
-      }
-
-      if( M_StdErr )
-      {
-         Si.hStdError = M_ChildErr.getHandle( M_StdErr );
-         M_ChildErr.start();
-      }
-      else
-      {
-         Si.hStdError = GetStdHandle( STD_ERROR_HANDLE );
-      }
-
-      if( M_StdIn )
-      {
-         SECURITY_ATTRIBUTES Sa;
-         Sa.nLength = sizeof(SECURITY_ATTRIBUTES);
-         Sa.lpSecurityDescriptor = NULL;
-         Sa.bInheritHandle = TRUE;
-         HANDLE HandleInWriteTmp;
-         if( !CreatePipe( &M_HandleInRead, &HandleInWriteTmp, &Sa, 0 ) )
-            logLastError( M_Logging, "CreatePipe");
-         if( !DuplicateHandle
-                  (
-                     GetCurrentProcess(),
-                     HandleInWriteTmp,
-                     GetCurrentProcess(),
-                     &M_HandleInWrite, // Address of new handle.
-                     0,FALSE, // Make it uninheritable.
-                     DUPLICATE_SAME_ACCESS
-                  ) )
-            logLastError( M_Logging, "DupliateHandle" );
-         if( !CloseHandle( HandleInWriteTmp ) )
-            logLastError( M_Logging, "CloseHandle" );
-         Si.hStdInput = M_HandleInRead;
-      }
-      else
-      {
-         Si.hStdInput = GetStdHandle( STD_INPUT_HANDLE );
-      }
-
-      if( M_StdOut )
-      {
-         Si.hStdOutput = M_ChildOut.getHandle( M_StdOut );
-         M_ChildOut.start();
-      }
-      else
-      {
-         Si.hStdOutput = GetStdHandle( STD_OUTPUT_HANDLE );
-      }
-
-      PROCESS_INFORMATION Pi;
-
-      // We need a non-const buffer!
-      unsigned const CmdSize = M_Commandline.size() + 1;
-      char * CmdLn = new char[CmdSize];
-      memcpy( CmdLn, M_Commandline.c_str(), CmdSize );
-      if (
-         !CreateProcess
-            (
-               NULL,                            // lpApplicationName
-               CmdLn,                           // lpCommandLine
-               NULL,                            // lpProcessAttribute
-               NULL,                            // lpThreadAttributes
-               TRUE,                            // bInheritHandles
-               CREATE_NEW_CONSOLE,              // dwCreationFlags
-               NULL,                            // lpEnvironment
-               M_Directory.size() ? M_Directory.c_str() : NULL,
-                                                // lpCurrentDirectory
-               &Si,                             // lpStartupInfo
-               &Pi                              // lpProcessInformation
-            )
-         )
-      {
-         logLastError( M_Logging, "CreateProcess" );
-      }
-      delete[] CmdLn;
-
-      M_HandleProcess = Pi.hProcess;
-      CloseHandle( Pi.hThread );
-      M_Started = true;
-   }
-
-
-   /**
-    *
-    * Destructor.
-    *
-   **/
-   ~myChild()
-   {
-      CloseHandle( M_HandleInRead );
-      CloseHandle( M_HandleInWrite );
-      CloseHandle( M_HandleProcess );
-   }
-
-
-   /**
-    *
-    * Implementation method.
-    * See the comment in mSysProcess.hpp" to the interface method.
-    *
-   **/
-   unsigned long getExitCode() const
-   {
-      DWORD XCode = 0;
-      if( M_Started )
-      {
-         if( !GetExitCodeProcess( M_HandleProcess, &XCode ) )
-         {
-            logLastError( M_Logging, "GetExitCodeProcess" );
-            return 0;
-         }
-      }
-      return XCode;
-   }
-
-
-   /**
-    *
-    * Implementation method.
-    * See the comment in mSysProcess.hpp" to the interface method.
-    *
-   **/
-   mSysProcess::status getStatus() const
-   {
-      if( M_Started )
+        std::string const &              Commandline,
+        std::string const &              Directory,
+        bool                             Hide,
+        mSysProcess::callBack const *    Logging,
+        bool                             Minimized,
+        mSysProcess::callBack const *    StdErr,
+        bool                             StdIn,
+        mSysProcess::callBack const *    StdOut,
+        threadException const *          ThreadExeption,
+        const mSysProcess::Environment&  Environment,
+        const std::string&               Title,
+        const std::string&               Desktop,
+        bool                             ReuseConsole,
+        bool                             NewProcessGroup
+      );
+      ~myChild();
+      unsigned long getExitCode() const;
+      mSysProcess::status getStatus() const;
+      mSysProcess::child& waitForTermination();
+      mSysProcess::child& waitForTermination(unsigned Seconds);
+      mSysProcess::child& stdIn(char const * Input);
+      mSysProcess::child& closeStdIn();
+      mSysProcess::child& kill();
+
+      bool sendBreak();
+      bool sendCtrlC();
+
+      std::string getProcessInformation() const;
+      std::string getProcessId() const;
+
+      const mSysSynchronize::Internal& getInternal() const;
+      const Internal& getId() const;
+
+      void printState(std::ostream& out, mSysProcess::status state) const;
+      void printTime(std::ostream& out, mSysProcess::status state) const;
+      void printCounters(std::ostream& out) const;
+      bool sendEvent(DWORD event);
+
+    private:
+      fromChild                        M_ChildErr;
+      fromChild                        M_ChildOut;
+      MASSAI::text::StringBuffer       M_Commandline;
+      std::string                      M_Directory;
+      HANDLE                           M_HandleInRead;
+      HANDLE                           M_HandleInWrite;
+      HANDLE                           M_HandleProcess;
+      mSysProcess::callBack const *    M_Logging;
+      bool                             M_Started;
+      mSysProcess::callBack const *    M_StdErr;
+      bool                             M_StdIn;
+      mSysProcess::callBack const *    M_StdOut;
+      DWORD                            M_ProcessId;
+      MASSAI::text::StringBuffer       M_Environment;
+      MASSAI::text::StringBuffer       M_Title;
+      MASSAI::text::StringBuffer       M_Desktop;
+      bool                             M_ReuseConsole;
+      bool                             M_NewProcessGroup;
+      child::Internal                  M_Internal;
+
+      myChild();
+      myChild( myChild const & );
+      myChild & operator=( myChild const & );
+  };
+
+
+
+  /**
+   * class myChild
+   * control child process, implementation of mSysProcess::child
+   *
+  **/
+  /**
+   *
+   * Constructor.
+   *
+  **/
+  myChild::myChild
+     (
+        std::string const &             Commandline,
+        std::string const &             Directory,
+        bool                            Hide,
+        mSysProcess::callBack const *   Logging,
+        bool                            Minimized,
+        mSysProcess::callBack const *   StdErr,
+        bool                            StdIn,
+        mSysProcess::callBack const *   StdOut,
+        threadException const *         ThreadExeption,
+        const mSysProcess::Environment& Environment,
+        const std::string&              Title,
+        const std::string&              Desktop,
+        bool                            ReuseConsole,
+        bool                            NewProcessGroup
+     ) :
+     M_ChildErr( ThreadExeption ),
+     M_ChildOut( ThreadExeption ),
+     M_Commandline( Commandline ),
+     M_Directory( Directory ),
+     M_HandleInRead( INVALID_HANDLE_VALUE ),
+     M_HandleInWrite( INVALID_HANDLE_VALUE ),
+     M_HandleProcess( INVALID_HANDLE_VALUE ),
+     M_Logging( Logging ),
+     M_Started( false ),
+     M_StdErr( StdErr ),
+     M_StdIn( StdIn ),
+     M_StdOut( StdOut ),
+     M_ProcessId(0),
+     M_Environment(getEnvironmentBlock(Environment)),
+     M_Title(Title),
+     M_Desktop(Desktop),
+     M_ReuseConsole(ReuseConsole),
+     M_NewProcessGroup(NewProcessGroup),
+     M_Internal()
+  {
+     STARTUPINFO Si;
+     bool inheritHandles= false;
+
+     // Set up the start up info struct.
+     ZeroMemory( &Si, sizeof(STARTUPINFO) );
+     Si.cb = sizeof(STARTUPINFO);
+     Si.dwFlags = STARTF_USESHOWWINDOW;        // Use the wShowWindow flag
+     if(M_StdIn || M_StdErr || M_StdOut)
+     {
+       Si.dwFlags |= STARTF_USESTDHANDLES;     // Use the hStd... flags
+       inheritHandles= true;
+     }
+     if( Hide )
+     {
+        Si.wShowWindow = SW_HIDE;
+     }
+     else if( Minimized )
+     {
+        Si.wShowWindow = SW_SHOWMINIMIZED;
+     }
+     else
+     {
+        Si.wShowWindow = SW_SHOW;
+     }
+
+     if( M_StdErr )
+     {
+        Si.hStdError = M_ChildErr.getHandle( M_StdErr );
+        M_ChildErr.start();
+     }
+     else if(inheritHandles)
+     {
+        Si.hStdError = GetStdHandle( STD_ERROR_HANDLE );
+     }
+     else
+     {
+        Si.hStdError = 0;
+     }
+
+     if( M_StdIn )
+     {
+        SECURITY_ATTRIBUTES Sa;
+        Sa.nLength = sizeof(SECURITY_ATTRIBUTES);
+        Sa.lpSecurityDescriptor = NULL;
+        Sa.bInheritHandle = TRUE;
+        HANDLE HandleInWriteTmp;
+        if( !CreatePipe( &M_HandleInRead, &HandleInWriteTmp, &Sa, 0 ) )
+           logLastError( M_Logging, "CreatePipe");
+        if( !DuplicateHandle
+                 (
+                    GetCurrentProcess(),
+                    HandleInWriteTmp,
+                    GetCurrentProcess(),
+                    &M_HandleInWrite, // Address of new handle.
+                    0,FALSE, // Make it uninheritable.
+                    DUPLICATE_SAME_ACCESS
+                 ) )
+           logLastError( M_Logging, "DupliateHandle" );
+        if( !CloseHandle( HandleInWriteTmp ) )
+           logLastError( M_Logging, "CloseHandle" );
+        Si.hStdInput = M_HandleInRead;
+     }
+     else if(inheritHandles)
+     {
+        Si.hStdInput = GetStdHandle( STD_INPUT_HANDLE );
+     }
+     else
+     {
+        Si.hStdInput = 0;
+     }
+
+     if( M_StdOut )
+     {
+        Si.hStdOutput = M_ChildOut.getHandle( M_StdOut );
+        M_ChildOut.start();
+     }
+     else if(inheritHandles)
+     {
+        Si.hStdOutput = GetStdHandle( STD_OUTPUT_HANDLE );
+     }
+     else
+     {
+        Si.hStdOutput = 0;
+     }
+
+
+     DWORD creationFlags= 0;
+     if(!M_ReuseConsole)
+     {
+       creationFlags |= CREATE_NEW_CONSOLE;
+       if(M_Title.size() > 0)
+       {
+         Si.lpTitle = M_Title.data();
+       }
+     }
+     else
+     {
+       M_Title= MASSAI::text::StringBuffer();
+     }
+     if(M_NewProcessGroup)
+     {
+       creationFlags |= CREATE_NEW_PROCESS_GROUP;
+     }
+
+
+
+     if(M_Desktop.size() > 0)
+     {
+       Si.lpDesktop = M_Desktop.data();
+     }
+     const char* directory= M_Directory.size() ? M_Directory.c_str() : NULL;
+     char* environment= Environment.size() ? M_Environment.data() : NULL;
+
+     PROCESS_INFORMATION Pi;
+     if (
+        !CreateProcess
+           (
+              NULL,                            // lpApplicationName
+              M_Commandline.data(),            // lpCommandLine
+              NULL,                            // lpProcessAttribute
+              NULL,                            // lpThreadAttributes
+              inheritHandles,                  // bInheritHandles
+              creationFlags,                   // dwCreationFlags
+              environment,                     // lpEnvironment
+              directory,                       // lpCurrentDirectory
+              &Si,                             // lpStartupInfo
+              &Pi                              // lpProcessInformation
+           )
+        )
+     {
+        logLastError( M_Logging, "CreateProcess" );
+        M_HandleProcess = INVALID_HANDLE_VALUE;
+        M_ProcessId = 0;
+     }
+     else
+     {
+       M_HandleProcess = Pi.hProcess;
+       M_ProcessId = Pi.dwProcessId;
+       M_Internal.handle= M_HandleProcess;
+       M_Internal.id= M_ProcessId;
+       CloseHandle( Pi.hThread );
+       M_Started = true;
+     }
+  }
+
+
+  /**
+   *
+   * Destructor.
+   *
+  **/
+  myChild::~myChild()
+  {
+     CloseHandle( M_HandleInRead );
+     CloseHandle( M_HandleInWrite );
+     CloseHandle( M_HandleProcess );
+  }
+
+
+  /**
+   *
+   * Implementation method.
+   * See the comment in mSysProcess.hpp" to the interface method.
+   *
+  **/
+  unsigned long myChild::getExitCode() const
+  {
+     DWORD XCode = 0;
+     if( M_Started )
+     {
+        if( !GetExitCodeProcess( M_HandleProcess, &XCode ) )
+        {
+           logLastError( M_Logging, "GetExitCodeProcess" );
+           return 0;
+        }
+     }
+     return XCode;
+  }
+
+
+  /**
+   *
+   * Implementation method.
+   * See the comment in mSysProcess.hpp" to the interface method.
+   *
+  **/
+  mSysProcess::status myChild::getStatus() const
+  {
+     if( M_Started )
+     {
+        DWORD result= WaitForSingleObject( M_HandleProcess, 0 );
+        if(result == WAIT_TIMEOUT)
+           return mSysProcess::STATUS_RUNNING;
+        else if(result == WAIT_OBJECT_0)
+           return mSysProcess::STATUS_TERMINATED;
+        else
+           return mSysProcess::STATUS_UNKNOWN;
+     }
+     else
+        return mSysProcess::STATUS_FAILED;
+  }
+
+
+  /**
+   *
+   * Implementation method.
+   * See the comment in mSysProcess.hpp" to the interface method.
+   *
+  **/
+  mSysProcess::child & myChild::waitForTermination()
+  {
+     WaitForSingleObject( M_HandleProcess, INFINITE );
+     return *this;
+  }
+
+
+  /**
+   *
+   * Implementation method.
+   * See the comment in mSysProcess.hpp" to the interface method.
+   *
+  **/
+  mSysProcess::child & myChild::waitForTermination( unsigned Seconds )
+  {
+     WaitForSingleObject( M_HandleProcess, 1000 * Seconds );
+     return *this;
+  }
+
+
+  /**
+   *
+   * Implementation method.
+   * See the comment in mSysProcess.hpp" to the interface method.
+   *
+  **/
+  mSysProcess::child & myChild::stdIn( char const * Input )
+  {
+     SOFTWARE_ERROR_THROW_IF_NOT( M_StdIn );
+     if( M_Logging )
+     {
+        std::string Str;
+        Str += "stdIn(";
+        Str += Input;
+        Str += ")";
+        M_Logging->lineOut( Str.c_str() );
+     }
+     DWORD nBytesWrote = 0;
+     if( !WriteFile
+              (
+                 M_HandleInWrite,
+                 Input, strlen(Input),
+                 &nBytesWrote, NULL
+              ) )
+     {
+        if( GetLastError() != ERROR_NO_DATA )
+           logLastError( M_Logging, "WriteFile" );
+     }
+     return *this;
+  }
+  /**
+   *
+   * Implementation method.
+   * See the comment in mSysProcess.hpp" to the interface method.
+   *
+  **/
+  mSysProcess::child & myChild::closeStdIn()
+  {
+    M_StdIn= false;
+    CloseHandle(M_HandleInWrite);
+    M_HandleInWrite= INVALID_HANDLE_VALUE;
+    return *this;
+  }
+  /**
+   *
+   * Implementation method.
+   * See the comment in mSysProcess.hpp" to the interface method.
+   *
+  **/
+  bool myChild::sendBreak()
+  {
+    return sendEvent(CTRL_BREAK_EVENT);
+  }
+  /**
+   *
+   * Implementation method.
+   * See the comment in mSysProcess.hpp" to the interface method.
+   *
+  **/
+  bool myChild::sendCtrlC()
+  {
+    return sendEvent(CTRL_C_EVENT);
+  }
+  /**
+   *
+   * send BREAK/CTRL-C to the process
+   *
+  **/
+  bool myChild::sendEvent(DWORD event)
+  {
+    bool result = true;
+    if(!GenerateConsoleCtrlEvent(event, M_ProcessId))
+    {
+      result = false;
+      logLastError( M_Logging, "GenerateConsoleCtrlEvent" );
+    }
+    return result;
+  }
+  /**
+   *
+   * Implementation method.
+   * See the comment in mSysProcess.hpp" to the interface method.
+   *
+  **/
+  mSysProcess::child& myChild::kill()
+  {
+    if(!TerminateProcess(M_HandleProcess, -1))
+    {
+      logLastError( M_Logging, "TerminateProcess" );
+    }
+    return *this;
+  }
+  /**
+   *
+   * write the process state to ostream
+   *
+  **/
+  void myChild::printState(std::ostream& out, mSysProcess::status state) const
+  {
+    if(state != mSysProcess::STATUS_RUNNING)
+    {
+      unsigned long exitCode= getExitCode();
+      out << "result\t";
+      out << exitCode << "\t";
+      out << std::hex << exitCode << "\t";
+      if(mSysError::isSystemError(exitCode))
       {
-         if( getExitCode() == STILL_ACTIVE )
-            return mSysProcess::STATUS_RUNNING;
-         else
-            return mSysProcess::STATUS_TERMINATED;
+        out << mSysError::getErrorText(exitCode).c_str();
       }
-      else
-         return mSysProcess::STATUS_UNKNOWN;
-   }
-
-
-   /**
-    *
-    * Implementation method.
-    * See the comment in mSysProcess.hpp" to the interface method.
-    *
-   **/
-   mSysProcess::child & waitForTermination()
-   {
-      WaitForSingleObject( M_HandleProcess, INFINITE );
-      return *this;
-   }
-
-
-   /**
-    *
-    * Implementation method.
-    * See the comment in mSysProcess.hpp" to the interface method.
-    *
-   **/
-   mSysProcess::child & waitForTermination( unsigned Seconds )
-   {
-      WaitForSingleObject( M_HandleProcess, 1000 * Seconds );
-      return *this;
-   }
-
-
-   /**
-    *
-    * Implementation method.
-    * See the comment in mSysProcess.hpp" to the interface method.
-    *
-   **/
-   mSysProcess::child & stdIn( char const * Input )
-   {
-      SOFTWARE_ERROR_THROW_IF_NOT( M_StdIn );
-      if( M_Logging )
+      out << std::endl;
+    }
+  }
+  /**
+   *
+   * write the process used time to ostream
+   *
+  **/
+  void myChild::printTime(std::ostream& out, mSysProcess::status state) const
+  {
+    FILETIME creation;
+    FILETIME exit;
+    FILETIME kernel;
+    FILETIME user;
+    if(GetProcessTimes(M_HandleProcess, &creation, &exit, &kernel, &user))
+    {
+      out << std::dec;
+      out << "user\t" << mSysTime::getDuration(user)      << "\t";
+      out << "kernel\t" << mSysTime::getDuration(kernel)    << std::endl;
+      out << "start\t" << mSysTime::getTimestamp(creation) << "\t";
+      if(state != mSysProcess::STATUS_RUNNING)
       {
-         std::string Str;
-         Str += "stdIn(";
-         Str += Input;
-         Str += ")";
-         M_Logging->lineOut( Str.c_str() );
+        out << "stop\t" << mSysTime::getTimestamp(exit);
       }
-      DWORD nBytesWrote = 0;
-      if( !WriteFile
-               (
-                  M_HandleInWrite,
-                  Input, strlen(Input),
-                  &nBytesWrote, NULL
-               ) )
-      {
-         if( GetLastError() != ERROR_NO_DATA )
-            logLastError( M_Logging, "WriteFile" );
-      }
-      return *this;
-   }
-
-
-private:
-
-
-   myChild();
-   myChild( myChild const & );
-   myChild & operator=( myChild const & );
-
-
-};
-
+      out << std::endl;
+    }
+    else
+    {
+      logLastError(M_Logging, "GetProcessTimes");
+    }
+  }
+  /**
+   *
+   * write the process resource counters to ostream
+   *
+  **/
+  void myChild::printCounters(std::ostream& out) const
+  {
+    IO_COUNTERS ioCounters;
+    if(GetProcessIoCounters(M_HandleProcess, &ioCounters))
+    {
+      out << std::dec;
+      out << "IO count(r/w/o)\t";
+      out << ioCounters.ReadOperationCount  << "\t";
+      out << ioCounters.WriteOperationCount << "\t";
+      out << ioCounters.OtherOperationCount << std::endl;
+      out << "IO byte (r/w/o)\t";
+      out << ioCounters.ReadTransferCount   << "\t";
+      out << ioCounters.WriteTransferCount  << "\t";
+      out << ioCounters.OtherTransferCount  << std::endl;
+    }
+    else
+    {
+      logLastError(M_Logging, "GetProcessIoCounters");
+    }
+    PROCESS_MEMORY_COUNTERS memoryCounters;
+    if(GetProcessMemoryInfo(M_HandleProcess, &memoryCounters, sizeof(memoryCounters)))
+    {
+      out << std::dec;
+      out << "page faults\t";
+      out << memoryCounters.PageFaultCount             << std::endl;
+      out << "current ws/paged/non paged/file\t";
+      out << memoryCounters.WorkingSetSize             << "\t";
+      out << memoryCounters.QuotaPagedPoolUsage        << "\t";
+      out << memoryCounters.QuotaNonPagedPoolUsage     << "\t";
+      out << memoryCounters.PagefileUsage              << std::endl;
+      out << "peak    ws/paged/non paged/file\t";
+      out << memoryCounters.PeakWorkingSetSize         << "\t";
+      out << memoryCounters.QuotaPeakPagedPoolUsage    << "\t";
+      out << memoryCounters.QuotaPeakNonPagedPoolUsage << "\t";
+      out << memoryCounters.PeakPagefileUsage          << std::endl;
+    }
+    else
+    {
+      logLastError(M_Logging, "GetProcessIoCounters");
+    }
+  }
+
+  /**
+   *
+   * write the process information to ostream
+   *
+  **/
+  std::string myChild::getProcessInformation() const
+  {
+    mSysProcess::status state= getStatus();
+    std::ostringstream out;
+    out << "Process\t" << M_ProcessId << std::endl;
+    out << M_Commandline.data() << std::endl;
+    out << getStatusText(state).c_str() << "\t" << state << std::endl;
+    if(state != mSysProcess::STATUS_FAILED)
+    {
+      printState(out, state);
+      printCounters(out);
+      printTime(out, state);
+    }
+    return out.str();
+  }
+
+  /**
+   *
+   * write the process id to ostream
+   *
+  **/
+  std::string myChild::getProcessId() const
+  {
+    mSysProcess::status state= getStatus();
+    std::ostringstream out;
+    out << "Process\t" << M_ProcessId << "\t" << getStatusText(state).c_str() << "\t" << state;
+    return out.str();
+  }
+
+  /**
+   *
+   * Implementation method.
+   * See the comment in mSysProcess.hpp" to the interface method.
+   *
+  **/
+  const mSysSynchronize::Internal& myChild::getInternal() const
+  {
+    return M_Internal;
+  }
+  /**
+   *
+   * Implementation method.
+   * See the comment in mSysProcess.hpp" to the interface method.
+   *
+  **/
+  const mSysProcess::child::Internal& myChild::getId() const
+  {
+    return M_Internal;
+  }
+}
 
 
 /**
@@ -564,6 +943,16 @@ class mSysProcess::parent::impl
 
    threadException const * const        M_ThreadExeption;
 
+   mSysProcess::Environment             M_Environment;
+
+   std::string                          M_Title;
+
+   std::string                          M_Desktop;
+
+   bool                                 M_ReuseConsole;
+
+   bool                                 M_NewProcessGroup;
+
 public:
 
 
@@ -584,7 +973,12 @@ public:
       M_StdErr( 0 ),
       M_StdIn( false ),
       M_StdOut( 0 ),
-      M_ThreadExeption( ThreadExeption )
+      M_ThreadExeption( ThreadExeption ),
+      M_Environment(),
+      M_Title(),
+      M_Desktop(),
+      M_ReuseConsole(false),
+      M_NewProcessGroup(false)
    {
    }
 
@@ -617,7 +1011,12 @@ public:
                         M_StdErr,
                         M_StdIn,
                         M_StdOut,
-                        M_ThreadExeption
+                        M_ThreadExeption,
+                        M_Environment,
+                        M_Title,
+                        M_Desktop,
+                        M_ReuseConsole,
+                        M_NewProcessGroup
                      );
    }
 
@@ -755,6 +1154,105 @@ public:
          M_Logging->lineOut( Str.c_str() );
       }
    }
+   /**
+    *
+    * Implementation method.
+    * See the comment in mSysProcess.hpp" to the interface method.
+    *
+   **/
+   void setEnvironment(const Environment& environment)
+   {
+      M_Environment = environment;
+      if( M_Logging )
+      {
+         std::string Str;
+         Str += "setEnvironment(\n";
+         Environment::const_iterator it = M_Environment.begin();
+         Environment::const_iterator end = M_Environment.end();
+         for(; it != end; it++)
+         {
+           Str += it->first;
+           Str += "=";
+           Str += it->second;
+           Str += "\n";
+         }
+         Str += ")";
+         M_Logging->lineOut( Str.c_str() );
+      }
+   }
+
+   /**
+    *
+    * Implementation method.
+    * See the comment in mSysProcess.hpp" to the interface method.
+    *
+   **/
+   void setWindowTitle(const char* title)
+   {
+     M_Title = title?title:"";
+     if( M_Logging )
+     {
+        std::string Str;
+        Str += "setWindowTitle(";
+        Str += M_Title;
+        Str += ")";
+        M_Logging->lineOut( Str.c_str() );
+     }
+   }
+
+   /**
+    *
+    * Implementation method.
+    * See the comment in mSysProcess.hpp" to the interface method.
+    *
+   **/
+   void setDesktop(const char* desktop)
+   {
+     M_Desktop = desktop?desktop:"";
+     if( M_Logging )
+     {
+        std::string Str;
+        Str += "setDesktop(";
+        Str += M_Desktop;
+        Str += ")";
+        M_Logging->lineOut( Str.c_str() );
+     }
+   }
+
+   /**
+    *
+    * Implementation method.
+    * See the comment in mSysProcess.hpp" to the interface method.
+    *
+   **/
+   void setReuseConsole()
+   {
+     M_ReuseConsole = true;
+     if( M_Logging )
+     {
+        std::string Str;
+        Str += "setReuseConsole()";
+        M_Logging->lineOut( Str.c_str() );
+     }
+   }
+   /**
+    *
+    * Implementation method.
+    * See the comment in mSysProcess.hpp" to the interface method.
+    *
+   **/
+   void setNewProcessGroup()
+   {
+     M_NewProcessGroup = true;
+     if( M_Logging )
+     {
+        std::string Str;
+        Str += "setNewProcessGroup()";
+        M_Logging->lineOut( Str.c_str() );
+     }
+   }
+
+
 
 
 private:
@@ -945,6 +1443,71 @@ mSysProcess::parent & mSysProcess::parent::setWorkDirectory
 }
 
 
+/**
+ *
+ * Class mSysProcess::parent method implementation
+ * - see "systools/mSysProcess.hpp".
+ *
+**/
+mSysProcess::parent& mSysProcess::parent::setEnvironment(const Environment& environment)
+{
+  M_Impl->setEnvironment(environment);
+  return *this;
+}
+
+/**
+ *
+ * Class mSysProcess::parent method implementation
+ * - see "systools/mSysProcess.hpp".
+ *
+**/
+mSysProcess::parent& mSysProcess::parent::setWindowTitle(const char* title)
+{
+  M_Impl->setWindowTitle(title);
+  return *this;
+}
+
+/**
+ *
+ * Class mSysProcess::parent method implementation
+ * - see "systools/mSysProcess.hpp".
+ *
+**/
+mSysProcess::parent& mSysProcess::parent::setDesktop(const char* desktop)
+{
+  M_Impl->setDesktop(desktop);
+  return *this;
+}
+
+/**
+ *
+ * Class mSysProcess::parent method implementation
+ * - see "systools/mSysProcess.hpp".
+ *
+**/
+mSysProcess::parent& mSysProcess::parent::setReuseConsole()
+{
+  M_Impl->setReuseConsole();
+  return *this;
+}
+
+/**
+ *
+ * Class mSysProcess::parent method implementation
+ * - see "systools/mSysProcess.hpp".
+ *
+**/
+mSysProcess::parent& mSysProcess::parent::setNewProcessGroup()
+{
+  M_Impl->setNewProcessGroup();
+  return *this;
+}
+
+
+mSysProcess::child::Internal::Internal():
+  id(0)
+{}
+
 
 /**
  **************************************************************************
diff --git a/SelfServiceCommon/Massai/cpp/Systools/src/mSysSynchronizeW32.cpp b/SelfServiceCommon/Massai/cpp/Systools/src/mSysSynchronizeW32.cpp
new file mode 100644
index 00000000..1dc7b3d3
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Systools/src/mSysSynchronizeW32.cpp
@@ -0,0 +1,856 @@
+/**
+ * wait for multiple objects
+**/
+
+#pragma warning(disable:4786)
+
+#include "systools/mSysSynchronize.h"
+#include "mSysSynchronizeW32.h"
+#include "mSysErrorW32.h"
+#include "sysTools/mAutoMutexCS.h"
+#include "sysTools/mEventSem.hpp"
+#include "sysTools/mSysThread.hpp"
+#include "sysTools/mSysException.hpp"
+#include "boost/shared_ptr.hpp"
+#include <list>
+#include <set>
+
+using Materna::MSSD::AutoMutexCS;
+using Materna::MSSD::Mutex;
+using Materna::MSSD::eventSemaphore;
+using Materna::MSSD::eventSemaphore_Handle;
+using mSysException::standardException;
+using MASSAI::trace::TraceInterface;
+using mSysThread::thread;
+using namespace mSysSynchronize;
+
+
+namespace
+{
+  /*
+   *    list of handles
+   */
+  typedef std::list<HANDLE> HandleList;
+  /*
+   *  class NotificationList
+   *    list of Notifications
+   */
+  typedef std::list<WaitNotification*> NotificationList;
+  /*
+   *  class WaitObjectSet
+   *    list of WaitObjects
+   */
+  typedef std::set<WaitObject*> WaitObjectSet;
+
+  /*
+   *  class ProcessingState
+   *    internal state of NotificationListProcessor
+   */
+  enum ProcessingState
+  {
+    INIT,      // Thread not started
+    IDLE,      // Thread started, but not waiting for notifications
+    WAITING,   // Thread started, waiting for notifcations
+    WAIT_IDLE, // Thread started, change from WAITING to IDLE
+    STOPPING,  // Thread is stopping
+    STOPPED,   // Thread is stopped
+  };
+
+  /*
+   *  class NotificationListProcessor
+   *    process list of notifications
+   */
+  class NotificationListProcessor: private thread
+  {
+    public:
+      NotificationListProcessor(TraceInterface& trc);
+      ~NotificationListProcessor();
+
+      void waitForNotifications();
+      void cancelWait();
+
+      bool addNotification(WaitNotification* pNotification);
+      bool removeNotification(WaitNotification* pNotification);
+
+    protected:
+      void setState(ProcessingState state);
+      void stateChanged();
+      ProcessingState getState();
+
+      Mutex& getMutex();
+      HANDLE getEventHandle();
+      NotificationList& getNotificationList();
+
+      virtual void doWait();
+      virtual void doIdle();
+      virtual void doWaitIdle();
+      virtual boolean canAddNotification(size_t size);
+
+    private:
+      void function();
+
+      TraceInterface& m_trc;
+      ProcessingState m_state;
+      Mutex m_access;
+      eventSemaphore m_event;
+      eventSemaphore m_finishEvent;
+      NotificationList m_notificationList;
+  };
+  /*
+   *  class NotificationProcessor
+   *    forward notifications to WaitListener
+   */
+  class NotificationProcessor: public NotificationListProcessor
+  {
+    public:
+      NotificationProcessor(TraceInterface& trc);
+      ~NotificationProcessor();
+
+      void setListener(WaitListener* pListener);
+      void cleanup(WaitNotification* pNotification);
+    private:
+      virtual void doWait();
+      virtual void doWaitIdle();
+      WaitNotification* getNotification();
+      WaitListener* getListener();
+      void notify(WaitListener* pListener, WaitNotification* pNotification);
+
+      TraceInterface& m_trc;
+      WaitListener* m_pListener;
+  };
+  /*
+   *  class NotificationWait
+   *    wait for a list of window handles (maximal MAXIMUM_WAIT_OBJECTS-1)
+   *    and forward notifications to NotificationProcessor
+   */
+  class NotificationWait: public NotificationListProcessor
+  {
+    public:
+      NotificationWait(TraceInterface& trc, NotificationProcessor& processor);
+      ~NotificationWait();
+
+    private:
+      virtual void doWait();
+      virtual void doWaitIdle();
+      virtual boolean canAddNotification(size_t size);
+
+      DWORD fillHandles(HANDLE* handle);
+      void notify(HANDLE handle);
+      void notifyInvalidHandles();
+      void checkNotificationIndividually();
+
+      TraceInterface& m_trc;
+
+      NotificationProcessor& m_processor;
+  };
+
+
+
+  std::string getStateText(ProcessingState state)
+  {
+    switch(state)
+    {
+      case INIT:      return "init";
+      case IDLE:      return "idle";
+      case WAITING:   return "waiting";
+      case WAIT_IDLE: return "wait_idle";
+      case STOPPING:  return "stopping";
+      case STOPPED:   return "stopped";
+      default:        return "unknown";
+    }
+  }
+
+  /*
+   *  class NotificationListProcessor
+   *    process list of notifications
+   */
+  NotificationListProcessor::NotificationListProcessor(TraceInterface& trc):
+    thread(0),
+    m_trc(trc),
+    m_state(INIT),
+    m_access(),
+    m_event(0),
+    m_notificationList(),
+    m_finishEvent()
+  {
+    m_trc.writeTrace(BasicRuntime_HERE, "processor started (%p)", this);
+  }
+  NotificationListProcessor::~NotificationListProcessor()
+  {
+    setState(STOPPING);
+    waitTerminated();
+    m_trc.writeTrace(BasicRuntime_HERE, "processor stopped (%p)", this);
+  }
+  void NotificationListProcessor::waitForNotifications()
+  {
+    AutoMutexCS mx(m_access);
+    ProcessingState state= getState();
+    setState(WAITING);
+    if(state == INIT)
+    {
+      start();
+    }
+  }
+  void NotificationListProcessor::cancelWait()
+  {
+    m_finishEvent.reset();
+    setState(WAIT_IDLE);
+    m_finishEvent.wait();
+  }
+  void NotificationListProcessor::setState(ProcessingState state)
+  {
+    AutoMutexCS mx(m_access);
+    if((m_state != STOPPED)
+      && (m_state != STOPPING || state == STOPPED))
+    {
+      m_state= state;
+    }
+    if(m_state == STOPPED || m_state == IDLE)
+    {
+      m_finishEvent.post();
+    }
+    stateChanged();
+  }
+  void NotificationListProcessor::stateChanged()
+  {
+    AutoMutexCS mx(m_access);
+    m_event.post();
+    m_trc.writeTrace(SecondaryFrequent_HERE,
+      "processor changed (%p) (%d, %s)",
+      this, m_state, getStateText(m_state).c_str());
+  }
+  ProcessingState NotificationListProcessor::getState()
+  {
+    AutoMutexCS mx(m_access);
+    ProcessingState state= m_state;
+    m_event.reset();
+    return state;
+  }
+  Mutex& NotificationListProcessor::getMutex()
+  {
+    return m_access;
+  }
+  HANDLE NotificationListProcessor::getEventHandle()
+  {
+    return m_event.getInternal().handle;
+  }
+  NotificationList& NotificationListProcessor::getNotificationList()
+  {
+    return m_notificationList;
+  }
+  void NotificationListProcessor::function()
+  {
+    standardException guard;
+    try
+    {
+      ProcessingState state= getState();
+      while(state != STOPPING)
+      {
+        switch(state)
+        {
+          case WAITING:   doWait();     break;
+          case WAIT_IDLE: doWaitIdle(); break;
+          default:        doIdle();     break;
+        }
+        state= getState();
+      }
+      setState(STOPPED);
+    }
+    catch(std::exception& x)
+    {
+      m_trc.writeTraceText(MajorError_HERE, x.what());
+    }
+  }
+  void NotificationListProcessor::doIdle()
+  {
+    WaitForSingleObject(getEventHandle(), INFINITE);
+  }
+  void NotificationListProcessor::doWait()
+  {
+    WaitForSingleObject(getEventHandle(), INFINITE);
+  }
+  void NotificationListProcessor::doWaitIdle()
+  {
+    setState(IDLE);
+  }
+  bool NotificationListProcessor::addNotification(WaitNotification* pNotification)
+  {
+    bool result= false;
+    AutoMutexCS mx(m_access);
+    if(canAddNotification(m_notificationList.size()))
+    {
+      m_trc.writeTrace(SecondaryFrequent_HERE,
+        "processor (%p): add notification (%p)",
+        this, pNotification);
+      m_notificationList.push_back(pNotification);
+      result= true;
+      stateChanged();
+    }
+    return result;
+  }
+  boolean NotificationListProcessor::canAddNotification(size_t size)
+  {
+    return true;
+  }
+  bool NotificationListProcessor::removeNotification(WaitNotification* pNotification)
+  {
+    bool result= false;
+    AutoMutexCS mx(m_access);
+    NotificationList::iterator it= m_notificationList.begin();
+    NotificationList::iterator end= m_notificationList.end();
+    for(; it != end; it++)
+    {
+      if((*it) == pNotification)
+      {
+        m_notificationList.erase(it);
+        stateChanged();
+        result= true;
+        break;
+      }
+    }
+    return result;
+  }
+  /*
+   *  class NotificationWait
+   *    wait for a list of window handles (maximal MAXIMUM_WAIT_OBJECTS-1)
+   *    and forward notifications to NotificationProcessor
+   */
+  NotificationWait::NotificationWait(TraceInterface& trc, NotificationProcessor& processor):
+    NotificationListProcessor(trc),
+    m_trc(trc),
+    m_processor(processor)
+  {}
+  NotificationWait::~NotificationWait()
+  {
+    NotificationList& notificationList= getNotificationList();
+    NotificationList::iterator it= notificationList.begin();
+    NotificationList::iterator end= notificationList.end();
+    for(; it != end; it++)
+    {
+      m_processor.cleanup(*it);
+    }
+  }
+  boolean NotificationWait::canAddNotification(size_t size)
+  {
+    return size < MAXIMUM_WAIT_OBJECTS-1;
+  }
+  void NotificationWait::doWait()
+  {
+    HANDLE handles[MAXIMUM_WAIT_OBJECTS];
+    DWORD count= fillHandles(handles);
+    DWORD result= WaitForMultipleObjects(count, handles, false, INFINITE);
+    int index= -1;
+    if(WAIT_OBJECT_0 <= result && result < WAIT_OBJECT_0 + MAXIMUM_WAIT_OBJECTS - 1)
+    {
+      index= result - WAIT_OBJECT_0;
+    }
+    else if(WAIT_ABANDONED_0 <= result && result < WAIT_ABANDONED_0 + MAXIMUM_WAIT_OBJECTS - 1)
+    {
+      index= result - WAIT_ABANDONED_0;
+    }
+    if(index == 0)
+    {}
+    else if(0 < index && index < count)
+    {
+      notify(handles[index]);
+    }
+    else
+    {
+      unsigned long errorCode= mSysError::getErrorCode();
+      m_trc.writeTrace(MajorError_HERE,
+        "WaitForMultipleObjects unexpected result: (%d) error: (%d: %s)",
+         result, errorCode, mSysError::getErrorText(errorCode).c_str());
+      Sleep(200); // unexpected error occured => wait to avoid high load if error not recovered
+      checkNotificationIndividually();
+    }
+  }
+  void NotificationWait::doWaitIdle()
+  {
+    checkNotificationIndividually();
+    NotificationListProcessor::doWaitIdle();
+  }
+  void NotificationWait::checkNotificationIndividually()
+  {
+    HandleList notified;
+    AutoMutexCS mx(getMutex());
+    {
+      HANDLE handles[1];
+      NotificationList& notificationList= getNotificationList();
+      NotificationList::iterator it= notificationList.begin();
+      NotificationList::iterator end= notificationList.end();
+      for(; it != end; it++)
+      {
+        DWORD result= WaitForMultipleObjects(1, handles, false, 0);
+        if(result == WAIT_OBJECT_0 || result == WAIT_ABANDONED_0)
+        {
+          notified.push_back(handles[0]);
+        }
+        else if(result != WAIT_TIMEOUT)
+        {
+          notified.push_back(handles[0]);
+          unsigned long errorCode= mSysError::getErrorCode();
+          m_trc.writeTrace(MajorError_HERE,
+            "WaitForMultipleObjects unexpected result: (%d) error: (%d: %s)",
+             result, errorCode, mSysError::getErrorText(errorCode).c_str());
+        }
+      }
+    }
+    {
+      HandleList::iterator it= notified.begin();
+      HandleList::iterator end= notified.end();
+      for(; it != end; it++)
+      {
+        notify(*it);
+      }
+    }
+  }
+  DWORD NotificationWait::fillHandles(HANDLE* handles)
+  {
+    AutoMutexCS mx(getMutex());
+    notifyInvalidHandles();
+    NotificationList& notificationList= getNotificationList();
+    NotificationList::iterator it= notificationList.begin();
+    NotificationList::iterator end= notificationList.end();
+    int i= 0;
+    handles[i++]= getEventHandle();
+    for(; it != end && i < MAXIMUM_WAIT_OBJECTS; it++)
+    {
+      WaitNotification* notification= (*it);
+      const Internal& internal= notification->getInternal();
+      HANDLE handle= internal.handle;
+      if(handle != INVALID_HANDLE_VALUE)
+      {
+        handles[i++]= handle;
+      }
+    }
+    return i;
+  }
+  void NotificationWait::notify(HANDLE handle)
+  {
+    AutoMutexCS mx(getMutex());
+    NotificationList& notificationList= getNotificationList();
+    NotificationList::iterator it= notificationList.begin();
+    NotificationList::iterator end= notificationList.end();
+    for(; it != end; it++)
+    {
+      WaitNotification* notification= (*it);
+      const Internal& internal= notification->getInternal();
+      if(internal.handle == handle)
+      {
+        WaitNotification* pNotification= *it;
+        notificationList.erase(it);
+        m_processor.addNotification(pNotification);
+        break;
+      }
+    }
+  }
+  void NotificationWait::notifyInvalidHandles()
+  {
+    AutoMutexCS mx(getMutex());
+    NotificationList& notificationList= getNotificationList();
+    NotificationList::iterator it= notificationList.begin();
+    NotificationList::iterator end= notificationList.end();
+    while(it != end)
+    {
+      NotificationList::iterator next= it;
+      next++;
+      WaitNotification* notification= (*it);
+      const Internal& internal= notification->getInternal();
+      if(internal.handle == INVALID_HANDLE_VALUE)
+      {
+        WaitNotification* pNotification= *it;
+        notificationList.erase(it);
+        m_processor.addNotification(pNotification);
+      }
+      it= next;
+    }
+  }
+
+  /*
+   *  class NotificationProcessor
+   *    forward notifications to WaitListener
+   */
+  NotificationProcessor::NotificationProcessor(TraceInterface& trc):
+    NotificationListProcessor(trc),
+    m_trc(trc),
+    m_pListener(0)
+  {}
+  NotificationProcessor::~NotificationProcessor()
+  {
+    NotificationList& notificationList= getNotificationList();
+    NotificationList::iterator it= notificationList.begin();
+    NotificationList::iterator end= notificationList.end();
+    for(; it != end; it++)
+    {
+      cleanup(*it);
+    }
+  }
+  void NotificationProcessor::setListener(WaitListener* pListener)
+  {
+    AutoMutexCS mx(getMutex());
+    m_pListener= pListener;
+    stateChanged();
+  }
+  void NotificationProcessor::cleanup(WaitNotification* pNotification)
+  {
+    AutoMutexCS mx(getMutex());
+    if(m_pListener)
+    {
+      m_pListener->cleanup(pNotification);
+    }
+  }
+  void NotificationProcessor::notify(WaitListener* pListener, WaitNotification* pNotification)
+  {
+    m_trc.writeTrace(SecondaryRuntime_HERE,
+      "processor (%p): notify notification (%p)",
+      this, pNotification);
+    try
+    {
+      pListener->notify(pNotification);
+    }
+    catch(...)
+    {
+      m_trc.writeTraceText(MajorError_HERE, "error in notify");
+      throw;
+    }
+  }
+  void NotificationProcessor::doWait()
+  {
+    WaitListener* pListener= getListener();
+    if(pListener != 0)
+    {
+      WaitNotification* pNotification= getNotification();
+      if(pNotification != 0)
+      {
+        notify(pListener, pNotification);
+      }
+      else
+      {
+        NotificationListProcessor::doWait();
+      }
+    }
+    else
+    {
+      NotificationListProcessor::doWait();
+    }
+  }
+  void NotificationProcessor::doWaitIdle()
+  {
+    WaitListener* pListener= getListener();
+    if(pListener != 0)
+    {
+      for(;;)
+      {
+        WaitNotification* pNotification= getNotification();
+        if(pNotification != 0)
+        {
+          notify(pListener, pNotification);
+        }
+        else
+        {
+          break;
+        }
+      }
+    }
+    NotificationListProcessor::doWaitIdle();
+  }
+  WaitNotification* NotificationProcessor::getNotification()
+  {
+    WaitNotification* result= 0;
+    AutoMutexCS mx(getMutex());
+    NotificationList& notificationList= getNotificationList();
+    if(notificationList.size() > 0)
+    {
+      result= notificationList.front();
+      notificationList.pop_front();
+    }
+    return result;
+  }
+  WaitListener* NotificationProcessor::getListener()
+  {
+    AutoMutexCS mx(getMutex());
+    return m_pListener;
+  }
+}
+namespace mSysSynchronize
+{
+  /*
+   *  wait for multiple WaitNotifications
+   */
+  class Synchronize::Impl
+  {
+    public:
+      Impl(MASSAI::trace::TraceInterface& trc);
+      ~Impl();
+
+      void setListener(WaitListener* pListener);
+      void add(WaitNotification* pNotification);
+      void remove(WaitNotification* pNotification);
+      size_t size();
+
+      void startWait(); // starts listening thread, does not block
+      void cancelWait();
+
+    private:
+      typedef boost::shared_ptr<NotificationWait> WaitPtr;
+      typedef std::list<WaitPtr> WaitList;
+
+      MASSAI::trace::TraceInterface& m_trc;
+      Materna::MSSD::Mutex m_access;
+
+      WaitList m_waitList;
+      NotificationProcessor* m_processor;
+      bool m_active;
+
+      Impl(const Impl&);
+      Impl& operator=(const Impl&);
+  };
+  /*
+   *  wait for multiple WaitNotifications, upto 64 elements
+   */
+  class SimpleSynchronize::Impl
+  {
+    public:
+      Impl(MASSAI::trace::TraceInterface& trc);
+      ~Impl();
+
+      void add(WaitObject* pWait);
+      void remove(WaitObject* pWait);
+
+      void wait(unsigned long time_ms); // blocking wait
+
+    private:
+      MASSAI::trace::TraceInterface& m_trc;
+      Materna::MSSD::Mutex m_access;
+      WaitObjectSet m_waitObjectSet;
+
+      Impl(const Impl&);
+      Impl& operator=(const Impl&);
+  };
+
+  /*
+   *  wait for multiple WaitNotifications
+   */
+  Synchronize::Impl::Impl(MASSAI::trace::TraceInterface& trc):
+    m_trc(trc),
+    m_access(),
+    m_waitList(),
+    m_processor(new NotificationProcessor(trc)),
+    m_active(false)
+  {}
+  Synchronize::Impl::~Impl()
+  {
+    AutoMutexCS mx(m_access);
+    m_waitList.clear();
+    delete m_processor;
+  }
+  void Synchronize::Impl::setListener(WaitListener* pListener)
+  {
+    AutoMutexCS mx(m_access);
+    m_processor->setListener(pListener);
+  }
+  void Synchronize::Impl::add(WaitNotification* pNotification)
+  {
+    AutoMutexCS mx(m_access);
+    bool added= false;
+    WaitList refuse;
+    WaitList::iterator it= m_waitList.begin();
+    WaitList::iterator end= m_waitList.end();
+    while(it != end)
+    {
+      if((*it)->addNotification(pNotification))
+      {
+        added= true;
+        break;
+      }
+      else
+      {
+        // NotificationWait is full
+        // => move it to the end of the list
+        WaitList::iterator next= it;
+        next++;
+        refuse.push_back(*it);
+        m_waitList.erase(it);
+        it= next;
+      }
+    }
+    if(!added)
+    {
+      NotificationWait* pHandler = new NotificationWait(m_trc, *m_processor);
+      pHandler->addNotification(pNotification);
+      m_waitList.push_back(WaitPtr(pHandler));
+      if(m_active)
+      {
+        pHandler->waitForNotifications();
+      }
+    }
+    // move full NotificationWait object to the end of the list
+    m_waitList.insert(m_waitList.end(), refuse.begin(), refuse.end());
+  }
+  void Synchronize::Impl::remove(WaitNotification* pNotification)
+  {
+    AutoMutexCS mx(m_access);
+    WaitList::iterator it= m_waitList.begin();
+    WaitList::iterator end= m_waitList.end();
+    for(; it != end; it++)
+    {
+      (*it)->removeNotification(pNotification);
+    }
+    m_processor->removeNotification(pNotification);
+  }
+  void Synchronize::Impl::startWait()
+  {
+    AutoMutexCS mx(m_access);
+    m_active= true;
+    WaitList::iterator it= m_waitList.begin();
+    WaitList::iterator end= m_waitList.end();
+    for(; it != end; it++)
+    {
+      (*it)->waitForNotifications();
+    }
+    m_processor->waitForNotifications();
+  }
+  void Synchronize::Impl::cancelWait()
+  {
+    AutoMutexCS mx(m_access);
+    m_active= false;
+    WaitList::iterator it= m_waitList.begin();
+    WaitList::iterator end= m_waitList.end();
+    for(; it != end; it++)
+    {
+      (*it)->cancelWait();
+    }
+    m_processor->cancelWait();
+  }
+  /*
+   *  wait for multiple WaitNotifications, upto 64 elements
+   */
+  SimpleSynchronize::Impl::Impl(MASSAI::trace::TraceInterface& trc):
+    m_trc(trc),
+    m_access(),
+    m_waitObjectSet()
+  {}
+  SimpleSynchronize::Impl::~Impl()
+  {}
+  void SimpleSynchronize::Impl::add(WaitObject* pWait)
+  {
+    AutoMutexCS mx(m_access);
+    m_waitObjectSet.insert(pWait);
+  }
+  void SimpleSynchronize::Impl::remove(WaitObject* pWait)
+  {
+    AutoMutexCS mx(m_access);
+    m_waitObjectSet.erase(pWait);
+  }
+  void SimpleSynchronize::Impl::wait(unsigned long time_ms)
+  {
+    HANDLE handles[MAXIMUM_WAIT_OBJECTS];
+    DWORD count= 0;
+    WaitObjectSet::iterator it= m_waitObjectSet.begin();
+    WaitObjectSet::iterator end= m_waitObjectSet.end();
+    for(; it != end && count < MAXIMUM_WAIT_OBJECTS; it++)
+    {
+      WaitObject* wait= (*it);
+      const Internal& internal= wait->getInternal();
+      HANDLE handle= internal.handle;
+      if(handle != INVALID_HANDLE_VALUE)
+      {
+        handles[count++]= handle;
+      }
+    }
+    DWORD result= WaitForMultipleObjects(count, handles, false, time_ms);
+    if(result == WAIT_FAILED)
+    {
+      unsigned long errorCode= mSysError::getErrorCode();
+      m_trc.writeTrace(MajorError_HERE,
+        "WaitForMultipleObjects unexpected result: (%d) error: (%d: %s)",
+         result, errorCode, mSysError::getErrorText(errorCode).c_str());
+    }
+  }
+  /*
+   *  Internal data for synchronization
+   */
+  Internal::Internal():
+    handle(INVALID_HANDLE_VALUE)
+  {}
+  Internal::Internal(HANDLE handle):
+    handle(handle)
+  {}
+  Internal::~Internal()
+  {}
+  WaitObject::WaitObject()
+  {}
+  WaitObject::~WaitObject()
+  {}
+  /*
+   *  callback for notification
+   */
+  WaitNotification::WaitNotification()
+  {}
+  WaitNotification::~WaitNotification()
+  {}
+  /*
+   *  callback for notification
+   */
+  WaitListener::WaitListener()
+  {}
+  WaitListener::~WaitListener()
+  {}
+  void WaitListener::notify(WaitNotification* pNotification)
+  {
+    if(pNotification)
+    {
+      pNotification->notify();
+    }
+  }
+  void WaitListener::cleanup(WaitNotification* pNotification)
+  {}
+  /*
+   *  wait for multiple WaitNotifications
+   */
+  Synchronize::Synchronize(MASSAI::trace::TraceInterface& trc):
+    m_pImpl(new Impl(trc))
+  {}
+  Synchronize::~Synchronize()
+  {}
+  void Synchronize::setListener(WaitListener* pListener)
+  {
+    m_pImpl->setListener(pListener);
+  }
+  void Synchronize::add(WaitNotification* pNotification)
+  {
+    m_pImpl->add(pNotification);
+  }
+  void Synchronize::remove(WaitNotification* pNotification)
+  {
+    m_pImpl->remove(pNotification);
+  }
+  void Synchronize::startWait()
+  {
+    m_pImpl->startWait();
+  }
+  void Synchronize::cancelWait()
+  {
+    m_pImpl->cancelWait();
+  }
+  /*
+   *  wait for multiple WaitNotifications, upto 64 elements
+   */
+  SimpleSynchronize::SimpleSynchronize(MASSAI::trace::TraceInterface& trc):
+    m_pImpl(new Impl(trc))
+  {}
+  SimpleSynchronize::~SimpleSynchronize()
+  {}
+  void SimpleSynchronize::add(WaitObject* pWait)
+  {
+    m_pImpl->add(pWait);
+  }
+  void SimpleSynchronize::remove(WaitObject* pWait)
+  {
+    m_pImpl->remove(pWait);
+  }
+  void SimpleSynchronize::wait(unsigned long time_ms)
+  {
+    m_pImpl->wait(time_ms);
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/Systools/src/mSysTimeW32.cpp b/SelfServiceCommon/Massai/cpp/Systools/src/mSysTimeW32.cpp
new file mode 100644
index 00000000..3c877bca
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Systools/src/mSysTimeW32.cpp
@@ -0,0 +1,74 @@
+/**
+ * time; current time, system up time, sleep
+**/
+#include "systools/mSysTime.h"
+#include "mSysTimeW32.h"
+
+#pragma warning(disable:4244)
+
+namespace mSysTime
+{
+  Timestamp getTimestamp()
+  {
+    SYSTEMTIME systemtime;
+    GetLocalTime(&systemtime);
+    return getTimestamp(systemtime);
+  }
+  Duration getDuration(unsigned long time_ms)
+  {
+    Duration result;
+    result.milliseconds= time_ms % 1000;
+    // milliseconds -> seconds;
+    time_ms/= 1000;
+    result.seconds= time_ms % 60;
+    // seconds -> minutes;
+    time_ms/= 60;
+    result.minutes= time_ms % 60;
+    // minutes -> hours;
+    time_ms/= 60;
+    result.hours= time_ms % 24;
+    // hours -> days;
+    time_ms/= 24;
+    result.days= time_ms;
+
+    return result;
+  }
+  Duration getDuration(const FILETIME& filetime)
+  {
+    LONGLONG time = filetime.dwHighDateTime;
+    time <<= 32;
+    time |= filetime.dwLowDateTime;
+
+    // 100 nano seconds -> milliseconds;
+    time/= 10000;
+    return getDuration(time);
+  }
+  Timestamp getTimestamp(const FILETIME& filetime)
+  {
+    // 100 nano seconds since 1.Janur 1601
+    SYSTEMTIME systemtime;
+    FileTimeToSystemTime(&filetime, &systemtime);
+    return getTimestamp(systemtime);
+  }
+  Timestamp getTimestamp(const SYSTEMTIME& systemtime)
+  {
+    Timestamp result;
+    result.year= systemtime.wYear;
+    result.month= systemtime.wMonth;
+    result.dayOfWeek= systemtime.wDayOfWeek;
+    result.day= systemtime.wDay;
+    result.hour= systemtime.wHour;
+    result.minute= systemtime.wMinute;
+    result.second= systemtime.wSecond;
+    result.milliseconds= systemtime.wMilliseconds;
+    return result;
+  }
+  unsigned long getUpTime()
+  {
+    return GetTickCount();
+  }
+  void sleep(unsigned long time_ms)
+  {
+    Sleep(time_ms);
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/Systools/src/mSysWindowW32.cpp b/SelfServiceCommon/Massai/cpp/Systools/src/mSysWindowW32.cpp
new file mode 100644
index 00000000..9d0a11ad
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Systools/src/mSysWindowW32.cpp
@@ -0,0 +1,499 @@
+/**
+ * control windows of other processes
+**/
+
+#pragma warning (disable:4786)
+#include "systools/mSysWindow.h"
+#include "mSysErrorW32.h"
+#include "mSysProcessW32.h"
+#include "tools/StringBuffer.h"
+#include <windows.h>
+#include <map>
+
+using namespace mSysWindow;
+using MASSAI::trace::TraceInterface;
+using mSysProcess::child;
+using MASSAI::text::StringBuffer;
+namespace
+{
+  /*
+   * control a window
+   */
+  class WindowW32: public Window
+  {
+    public:
+      WindowW32(HWND hwnd, const std::string& desktop, TraceInterface& trc);
+      virtual ~WindowW32();
+      virtual void activate();
+      virtual void show();
+      virtual void hide();
+      virtual void close();
+      virtual bool isVisible();
+      virtual bool isActive();
+      virtual std::string getTitle();
+      virtual std::string getClass();
+
+
+      DWORD getProcessId() const;
+    private:
+      void readTitle();
+      void readProcessId();
+      void traceLastError
+      (
+        long lTraceLevel,
+        const char* pszFile,
+        short sLine,
+        const char* pszFunction,
+        const char* where,
+        unsigned long errorCode
+      );
+      bool isMaximized();
+      void maximize();
+      bool isTopMost();
+      void setTopMost();
+
+      HWND m_hwnd;
+      DWORD m_processId;
+      DWORD m_threadId;
+      std::string m_title;
+      std::string m_desktop;
+      TraceInterface& m_trc;
+  };
+
+  enum CONSTS
+  {
+    TITLE_BUFFER_SIZE = 2048,
+    CLASS_BUFFER_SIZE = 2048,
+  };
+
+  typedef std::map<HWND, WindowW32> WindowMap;
+
+  /*
+   * control a window
+   */
+  WindowW32::WindowW32(HWND hwnd, const std::string& desktop, TraceInterface& trc):
+    m_hwnd(hwnd),
+    m_processId(0),
+    m_threadId(0),
+    m_title(),
+    m_desktop(desktop),
+    m_trc(trc)
+  {
+    readProcessId();
+  }
+  WindowW32::~WindowW32()
+  {}
+  void WindowW32::traceLastError
+  (
+    long lTraceLevel,
+    const char* pszFile,
+    short sLine,
+    const char* pszFunction,
+    const char* where,
+    unsigned long errorCode
+  )
+  {
+    m_trc.writeTrace(lTraceLevel, pszFile, sLine, pszFunction,
+      "(%.200s) failed: handle(%d) (%d), (%.1000s)",
+      where, m_hwnd, errorCode, mSysError::getErrorText(errorCode).c_str());
+  }
+  bool WindowW32::isMaximized()
+  {
+    WINDOWPLACEMENT placement;
+    placement.length = sizeof(WINDOWPLACEMENT);
+    bool result = false;
+    if(GetWindowPlacement(m_hwnd, &placement))
+    {
+      if(placement.showCmd == SW_SHOWMAXIMIZED)
+      {
+        result = true;
+      }
+    }
+    else
+    {
+      traceLastError(MinorError_HERE, "GetWindowPlacement", mSysError::getErrorCode());
+    }
+    return result;
+  }
+  void WindowW32::maximize()
+  {
+    ShowWindow(m_hwnd, SW_MAXIMIZE);
+  }
+  bool WindowW32::isTopMost()
+  {
+    return (GetWindowLong(m_hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST) != 0;
+  }
+  void WindowW32::setTopMost()
+  {
+    if(!SetWindowPos(m_hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE))
+    {
+      traceLastError(MinorError_HERE, "SetWindowPos", mSysError::getErrorCode());
+    }
+  }
+  void WindowW32::activate()
+  {
+    m_trc.writeTrace(BasicRuntime_HERE, "activate (%d)(%s)", m_hwnd, m_title.c_str());
+    if(m_threadId)
+    {
+      if(!BringWindowToTop(m_hwnd))
+      {
+        traceLastError(MinorError_HERE, "BringWindowToTop", mSysError::getErrorCode());
+      }
+      if(!SetForegroundWindow(m_hwnd))
+      {
+        traceLastError(MinorError_HERE, "SetForegroundWindow", mSysError::getErrorCode());
+      }
+    }
+  }
+  void WindowW32::show()
+  {
+    m_trc.writeTrace(BasicRuntime_HERE, "show (%d)(%s)", m_hwnd, m_title.c_str());
+    ShowWindow(m_hwnd, SW_SHOW);
+    if(!isTopMost())
+    {
+      setTopMost();
+    }
+  }
+  void WindowW32::hide()
+  {
+    m_trc.writeTrace(BasicRuntime_HERE, "hide (%d)(%s)", m_hwnd, m_title.c_str());
+    ShowWindow(m_hwnd, SW_HIDE);
+  }
+  void WindowW32::close()
+  {
+    m_trc.writeTrace(BasicRuntime_HERE, "close (%d)(%s)", m_hwnd, m_title.c_str());
+    if(PostMessage(m_hwnd, WM_CLOSE, 0, 0) == 0)
+    {
+      traceLastError(MinorError_HERE, "PostMessage", mSysError::getErrorCode());
+    }
+  }
+  DWORD WindowW32::getProcessId() const
+  {
+    return m_processId;
+  }
+  bool WindowW32::isVisible()
+  {
+    return IsWindowVisible(m_hwnd) != 0;
+  }
+  bool WindowW32::isActive()
+  {
+    return GetForegroundWindow() == m_hwnd;
+  }
+  std::string WindowW32::getClass()
+  {
+    char buffer[CLASS_BUFFER_SIZE];
+    // if the class name is empty GetClassName returns 0, but does not set the last error
+    // we must reset last error, or we get an error code of an other command
+    SetLastError(0);
+    if(GetClassName(m_hwnd, buffer, CLASS_BUFFER_SIZE) != 0)
+    {
+      buffer[CLASS_BUFFER_SIZE-1] = 0;
+    }
+    else
+    {
+      unsigned long errorCode = mSysError::getErrorCode();
+      if(errorCode != 0)
+      {
+        traceLastError(MinorError_HERE, "GetClassName", errorCode);
+      }
+    }
+    return buffer;
+  }
+  std::string WindowW32::getTitle()
+  {
+    std::string oldTitle = m_title;
+    readTitle();
+    if(oldTitle != m_title)
+    {
+      m_trc.writeTrace(SecondaryRuntime_HERE,
+        "found window: handle(%d), title(%s)",
+        m_hwnd, m_title.c_str());
+    }
+    return m_title;
+  }
+  void WindowW32::readTitle()
+  {
+    char buffer[TITLE_BUFFER_SIZE];
+    // if the title is empty GetWindowText returns 0, but does not set the last error
+    // we must reset last error, or we get an error code of an other command
+    SetLastError(0);
+    if(GetWindowText(m_hwnd, buffer, TITLE_BUFFER_SIZE) != 0)
+    {
+      buffer[TITLE_BUFFER_SIZE-1] = 0;
+      m_title = buffer;
+    }
+    else
+    {
+      unsigned long errorCode = mSysError::getErrorCode();
+      if(errorCode != 0)
+      {
+        traceLastError(MinorError_HERE, "GetWindowText", errorCode);
+      }
+    }
+  }
+  void WindowW32::readProcessId()
+  {
+    m_threadId = GetWindowThreadProcessId(m_hwnd, &m_processId);
+  }
+}
+namespace
+{
+  typedef std::map<DWORD, Process*> ProcessMap;
+  typedef std::set<std::string> DesktopSet;
+}
+
+namespace mSysWindow
+{
+  /*
+   * control a window
+   */
+  Window::~Window()
+  {}
+  /*
+   * class WindowSearch::Impl
+   *   invoke windows search
+   */
+  class WindowSearch::Impl
+  {
+    public:
+      Impl(const WindowSearchData& data, WindowSearchMatch& match,
+        MASSAI::trace::TraceInterface& trc);
+      ~Impl();
+      void search();
+      const WindowList& getList() const;
+      WindowList& getList();
+      BOOL found(HWND hwnd);
+      WindowW32& getWindow(HWND hwnd);
+
+    private:
+      void found(HWND hwnd, WindowW32& win, DWORD id, Process* pProcess);
+      void searchDesktop(const std::string& desktop);
+      void addProcess(Process* pProcess);
+      void addDesktop(Process* pProcess);
+
+      WindowSearchData m_data;
+      WindowSearchMatch& m_test;
+      WindowList m_match;
+      WindowMap m_found;
+      TraceInterface& m_trc;
+      ProcessMap m_processes;
+      DesktopSet m_desktopSet;
+      std::string m_desktop;
+  };
+}
+namespace
+{
+  BOOL CALLBACK windowSearchCallback(HWND hwnd, LPARAM lParam)
+  {
+    BOOL result = false;
+    WindowSearch::Impl* caller = reinterpret_cast<WindowSearch::Impl*>(lParam);
+    if(caller != 0)
+    {
+      result = caller->found(hwnd);
+    }
+    return result;
+  }
+}
+namespace mSysWindow
+{
+  /*
+   *  process (window owner)
+   */
+  Process::Process()
+  {}
+  Process::~Process()
+  {}
+
+  /*
+   * define a windows search
+   *   use desktop, title, processid
+   */
+  WindowSearchData::WindowSearchData():
+    processSet(),
+    useProcessId(false),
+    useProcessDesktop(false),
+    desktop(),
+    useDesktop(false)
+  {}
+  /*
+   *  user defined check
+   *    for windows search
+   */
+  WindowSearchMatch::~WindowSearchMatch()
+  {}
+
+  /*
+   * class WindowSearch::Impl
+   *   invoke windows search
+   */
+  WindowSearch::Impl::Impl(const WindowSearchData& data, WindowSearchMatch& match,
+    MASSAI::trace::TraceInterface& trc):
+    m_data(data),
+    m_test(match),
+    m_match(),
+    m_found(),
+    m_trc(trc),
+    m_processes(),
+    m_desktopSet()
+  {
+    if(m_data.useProcessId)
+    {
+      ProcessSet::const_iterator it= m_data.processSet.begin();
+      ProcessSet::const_iterator end= m_data.processSet.end();
+      for(; it != end; it++)
+      {
+        addProcess(*it);
+      }
+    }
+    if(m_data.useProcessDesktop)
+    {
+      ProcessSet::const_iterator it= m_data.processSet.begin();
+      ProcessSet::const_iterator end= m_data.processSet.end();
+      for(; it != end; it++)
+      {
+        addDesktop(*it);
+      }
+    }
+    if(m_data.useDesktop)
+    {
+      m_desktopSet.insert(m_data.desktop);
+    }
+  }
+  WindowSearch::Impl::~Impl()
+  {}
+  void WindowSearch::Impl::addProcess(Process* pProcess)
+  {
+    if(pProcess != 0)
+    {
+      child* pChild= pProcess->getProcess();
+      if(pChild != 0)
+      {
+        m_processes[pChild->getId().id]= pProcess;
+      }
+    }
+  }
+  void WindowSearch::Impl::addDesktop(Process* pProcess)
+  {
+    if(pProcess != 0)
+    {
+      m_desktopSet.insert(pProcess->getDesktop());
+    }
+  }
+  void WindowSearch::Impl::searchDesktop(const std::string& desktopName)
+  {
+    m_desktop = desktopName;
+    if(desktopName.size() > 0)
+    {
+      StringBuffer desk= StringBuffer(desktopName);
+      HDESK desktop = OpenDesktop(desk.data(), 0, false, DESKTOP_ENUMERATE | DESKTOP_READOBJECTS);
+      if(!desktop)
+      {
+        unsigned long errorCode = mSysError::getErrorCode();
+        m_trc.writeTrace(MinorError_HERE,
+          "OpenDesktop failed: desktop(%s); (%d), (%.1000s)",
+          desktopName.c_str(), errorCode, mSysError::getErrorText(errorCode).c_str());
+      }
+      EnumDesktopWindows(desktop, &windowSearchCallback, reinterpret_cast<LPARAM>(this));
+      if(!CloseDesktop(desktop))
+      {
+        unsigned long errorCode = mSysError::getErrorCode();
+        m_trc.writeTrace(MinorError_HERE,
+          "CloseDesktop failed: (%d), (%.1000s)",
+          errorCode, mSysError::getErrorText(errorCode).c_str());
+      }
+    }
+    else
+    {
+      EnumWindows(&windowSearchCallback, reinterpret_cast<LPARAM>(this));
+    }
+  }
+  void WindowSearch::Impl::search()
+  {
+    m_match.clear();
+    if(m_desktopSet.size() > 0)
+    {
+      DesktopSet::const_iterator it = m_desktopSet.begin();
+      DesktopSet::const_iterator end = m_desktopSet.end();
+      for(; it != end; it++)
+      {
+        searchDesktop(*it);
+      }
+    }
+    else
+    {
+      searchDesktop("");
+    }
+  }
+  const WindowList& WindowSearch::Impl::getList() const
+  {
+    return m_match;
+  }
+  WindowList& WindowSearch::Impl::getList()
+  {
+    return m_match;
+  }
+  WindowW32& WindowSearch::Impl::getWindow(HWND hwnd)
+  {
+    WindowMap::iterator it = m_found.find(hwnd);
+    if(it == m_found.end())
+    {
+      // add new WindowW32 in m_found and return the reference
+      return m_found.insert(WindowMap::value_type(hwnd, WindowW32(hwnd, m_desktop, m_trc))).first->second;
+    }
+    else
+    {
+      return it->second;
+    }
+  }
+  void WindowSearch::Impl::found(HWND hwnd, WindowW32& win, DWORD id, Process* pProcess)
+  {
+    if(m_test.match(win, pProcess))
+    {
+      m_match.push_back(WindowPtr(new WindowW32(win)));
+    }
+  }
+  BOOL WindowSearch::Impl::found(HWND hwnd)
+  {
+    WindowW32& win = getWindow(hwnd);
+    if(m_data.useProcessId)
+    {
+      ProcessMap::const_iterator it= m_processes.find(win.getProcessId());
+      if(it == m_processes.end())
+      {
+        found(hwnd, win, 0, 0);
+      }
+      else
+      {
+        found(hwnd, win, it->first, it->second);
+      }
+    }
+    else
+    {
+      found(hwnd, win, 0, 0);
+    }
+    return true;
+  }
+
+  /*
+   * class WindowSearch
+   *   invoke windows search
+   */
+  WindowSearch::WindowSearch(const WindowSearchData& data, WindowSearchMatch& match,
+    MASSAI::trace::TraceInterface& trc):
+    m_pImpl(new Impl(data, match, trc))
+  {}
+  WindowSearch::~WindowSearch()
+  {}
+  void WindowSearch::search()
+  {
+    m_pImpl->search();
+  }
+  const WindowList& WindowSearch::getList() const
+  {
+    return m_pImpl->getList();
+  }
+  WindowList& WindowSearch::getList()
+  {
+    return m_pImpl->getList();
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/Tools/makefile.mak b/SelfServiceCommon/Massai/cpp/Tools/makefile.mak
index 7be3189e..c1696b4f 100644
--- a/SelfServiceCommon/Massai/cpp/Tools/makefile.mak
+++ b/SelfServiceCommon/Massai/cpp/Tools/makefile.mak
@@ -23,6 +23,9 @@ MY_LIB1_OBJS =          $(_OBJ)\mHRTimerW32.obj \
                         $(_OBJ)\stringbuffer.obj \
                         $(_OBJ)\log.obj \
                         $(_OBJ)\TraceInterface.obj \
+                        $(_OBJ)\TraceFormatCB.obj \
+                        $(_OBJ)\TraceCallback.obj \
+                        $(_OBJ)\TraceSystem.obj \
                         $(_OBJ)\TraceDelegate.obj \
                         $(_OBJ)\TraceClient.obj \
                         $(_OBJ)\TraceHandle.obj \
@@ -33,7 +36,8 @@ MY_LIB1_OBJS =          $(_OBJ)\mHRTimerW32.obj \
                         $(_OBJ)\tracesMetaLFL.obj \
                         $(_OBJ)\tracesToFile.obj \
                         $(_OBJ)\tracesToLocal.obj \
-                        $(_OBJ)\tracesToTrc.obj
+                        $(_OBJ)\tracesToTrc.obj \
+                        $(_OBJ)\ResetTime.obj \
 
 ######################################################################
 
@@ -44,13 +48,13 @@ MY_BIN1_USER_LIBS =     $(LIB_TOOLS)
 MY_BIN1_OBJS =          $(_OBJ)\TestDateProperties.obj
 
 ######################################################################
-
-MY_BIN2 =               $(_BIN)\TestBitArray.exe
-
-MY_BIN2_USER_LIBS =     $(LIB_TOOLS)
-
-MY_BIN2_OBJS =          $(_OBJ)\TestBitArray.obj
-
+#
+#MY_BIN2 =               $(_BIN)\TestBitArray.exe
+#
+#MY_BIN2_USER_LIBS =     $(LIB_TOOLS) $(LIB_SYSTOOLS)
+#
+#MY_BIN2_OBJS =          $(_OBJ)\TestBitArray.obj
+#
 ######################################################################
 
 !include $(BUILDROOT)\Build\cpp\makefile.rules.mak
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/ResetTime.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/ResetTime.cpp
new file mode 100644
index 00000000..4b5ae811
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/ResetTime.cpp
@@ -0,0 +1,124 @@
+//---------------------------------------------------------------------------
+//
+//  file:       ResetTime.cpp
+//
+//  purpose:    handle error and reset
+//
+//---------------------------------------------------------------------------
+
+#include "tools/ResetTime.h"
+#include "systools/mSysTime.h"
+
+using namespace mReset;
+using MASSAI::trace::TraceInterface;
+using mSysTime::Duration;
+
+namespace
+{
+  Time currentTime()
+  {
+    return mSysTime::getUpTime();
+  }
+  void traceDuration(TraceInterface& trc,
+    long level, const char* file, short line, const char* function,
+    const std::string& name, const char* text, Time time)
+  {
+    Duration t = mSysTime::getDuration(time);
+    trc.writeTrace(level, file, line, function, "(%s) %s(%d:%02d:%02d,%02d)",
+      name.c_str(),
+      text,
+      t.days * 24 + t.hours,
+      t.minutes,
+      t.seconds,
+      t.milliseconds
+    );
+  }
+}
+
+namespace mReset
+{
+  /*
+    calculate time for resetting
+  */
+  ResetTime::ResetTime(TraceInterface& trc, const std::string& name,
+    Time min, Time max, Time recover):
+    m_name(name),
+    m_min(min),
+    m_max(max),
+    m_recover(recover),
+    m_hasError(false),
+    m_errorTimestamp(0),
+    m_trc(trc),
+    m_resetTime(0)
+  {
+    if(m_min == 0)
+    {
+      m_min= 1;
+    }
+    if(m_max * 2 < m_max)  // check for overflow
+    {
+      m_max/= 2;
+    }
+  }
+  ResetTime::~ResetTime()
+  {}
+  void ResetTime::setError()
+  {
+    if(!m_hasError)
+    {
+      if(m_resetTime != 0)
+      {
+        Time now = currentTime();
+        if((now - m_errorTimestamp) > m_recover + m_resetTime)
+        {
+          m_resetTime = 0;
+        }
+      }
+      if(m_resetTime < m_min)
+      {
+        m_resetTime = m_min;
+      }
+      else
+      {
+        m_resetTime *= 2;
+        if(m_resetTime > m_max)
+        {
+          m_resetTime = m_max;
+        }
+      }
+      m_hasError = true;
+      m_errorTimestamp = currentTime();
+      traceDuration(m_trc, MinorWarning_HERE,
+        m_name, "error occured, reset in ", m_resetTime);
+    }
+  }
+  void ResetTime::resetError()
+  {
+    m_hasError = false;
+  }
+  bool ResetTime::hasError() const
+  {
+    return m_hasError;
+  }
+  Time ResetTime::getResetTime() const
+  {
+    long result= m_max;
+    if(m_hasError)
+    {
+      Time now = currentTime();
+      result = m_resetTime - (now - m_errorTimestamp);
+      if(result < 0)
+      {
+        result = 0;
+        m_trc.writeTrace(MinorWarning_HERE, "(%s) reset now", m_name.c_str());
+      }
+      else
+      {
+        traceDuration(m_trc, MinorWarning_HERE,
+          m_name, "next reset in ", result);
+      }
+    }
+    return result;
+  }
+}
+
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/TraceCallback.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/TraceCallback.cpp
new file mode 100644
index 00000000..9d5156ad
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/TraceCallback.cpp
@@ -0,0 +1,130 @@
+//---------------------------------------------------------------------------
+//
+//  file:       TraceCallback.cpp
+//
+//  purpose:    interface for traceing
+//
+//  date:       01.12.2011
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#include "Tools/TraceCallback.h"
+
+namespace
+{
+  const char* TOPIC= "TRACE";
+  const char* NEWFILE= "----------------------------------------------------------";
+}
+
+namespace MASSAI
+{
+  namespace trace
+  {
+    TraceCallback::TraceCallback(const char* pszApplication, Callback& callback):
+      m_format(callback)
+    {
+      writeTraceForTopic(TOPIC, TOPIC_HERE, "--- Trace Init --- (%s)", pszApplication);
+    }
+    TraceCallback::~TraceCallback()
+    {
+      writeTraceTextForTopic(TOPIC, TOPIC_HERE, "--- Trace Close ---");
+    }
+    /*
+    ---------------------------------------------------------------------------
+       Trace Text
+    ---------------------------------------------------------------------------
+    */
+    void TraceCallback::writeTraceText
+    (
+       long lTraceLevel,
+       const char* pszFile,
+       short  sLine,
+       const char* pszFunction,
+       const char* pszText
+    ) const
+    {
+      m_format.text(lTraceLevel, 0, pszFile, sLine, pszFunction, pszText);
+    }
+    /*
+    ---------------------------------------------------------------------------
+       Trace Dump
+    ---------------------------------------------------------------------------
+    */
+    void TraceCallback::dumpTrace
+    (
+       long lTraceLevel,
+       const char* pszFile,
+       short  sLine,
+       const char* pszFunction,
+       long lDumpSize,
+       const char* pDump
+    ) const
+    {
+      m_format.dump(lTraceLevel, 0, pszFile, sLine, pszFunction, lDumpSize, pDump);
+    }
+    /*
+    ---------------------------------------------------------------------------
+      Start new files
+    ---------------------------------------------------------------------------
+    */
+    void TraceCallback::startNewTraceFile(long lTraceLevel) const
+    {
+      writeTraceText(lTraceLevel, TOPIC_HERE, NEWFILE);
+    }
+    /*
+    ---------------------------------------------------------------------------
+       Trace Text
+    ---------------------------------------------------------------------------
+    */
+    void TraceCallback::writeTraceTextForTopic
+    (
+       const char* pszTopic,
+       const char* pszFile,
+       short  sLine,
+       const char* pszFunction,
+       const char* pszText
+    ) const
+    {
+      m_format.text(-1, pszTopic, pszFile, sLine, pszFunction, pszText);
+    }
+    /*
+    ---------------------------------------------------------------------------
+       Trace Dump
+    ---------------------------------------------------------------------------
+    */
+    void TraceCallback::dumpTraceForTopic
+    (
+       const char* pszTopic,
+       const char* pszFile,
+       short  sLine,
+       const char* pszFunction,
+       long lDumpSize,
+       const char* pDump
+    ) const
+    {
+      m_format.dump(-1, pszTopic, pszFile, sLine, pszFunction, lDumpSize, pDump);
+    }
+    /*
+    ---------------------------------------------------------------------------
+      Start new files
+    ---------------------------------------------------------------------------
+    */
+    void TraceCallback::startNewTraceFileForTopic(const char* pszTopic) const
+    {
+      writeTraceTextForTopic(pszTopic, TOPIC_HERE, NEWFILE);
+    }
+    /*
+    ---------------------------------------------------------------------------
+       move file
+    ---------------------------------------------------------------------------
+    */
+    void TraceCallback::moveTrace
+    (
+       const char* pszPath
+    ) const
+    {}
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/TraceClient.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/TraceClient.cpp
index 1eed7202..734c69db 100644
--- a/SelfServiceCommon/Massai/cpp/Tools/src/TraceClient.cpp
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/TraceClient.cpp
@@ -11,7 +11,6 @@
 //  history:
 //---------------------------------------------------------------------------
 
-
 #include "Tools/TraceClient.h"
 #include "Tools/TraceInterface.h"
 #include "trc/TraceClt.h"
@@ -28,7 +27,6 @@ namespace MASSAI
     {
       ::openTrace(pszApplication);
     }
-
     TraceClient::~TraceClient()
     {
       if(m_close)
@@ -39,7 +37,6 @@ namespace MASSAI
     /*
     ---------------------------------------------------------------------------
        Trace Text
-
     ---------------------------------------------------------------------------
     */
     void TraceClient::writeTraceText
@@ -53,8 +50,6 @@ namespace MASSAI
     {
       ::writeTraceText(lTraceLevel, pszFile, sLine, pszFunction, pszText);
     }
-
-
     /*
     ---------------------------------------------------------------------------
        Trace Dump
@@ -72,25 +67,18 @@ namespace MASSAI
     {
       ::dumpTrace(lTraceLevel, pszFile, sLine, pszFunction, lDumpSize, pDump);
     }
-
-
     /*
     ---------------------------------------------------------------------------
       Start new files
-
     ---------------------------------------------------------------------------
     */
     void TraceClient::startNewTraceFile(long lTraceLevel) const
     {
       ::startNewTraceFile(lTraceLevel);
     }
-
-
-
     /*
     ---------------------------------------------------------------------------
        Trace Text
-
     ---------------------------------------------------------------------------
     */
     void TraceClient::writeTraceTextForTopic
@@ -104,11 +92,6 @@ namespace MASSAI
     {
       ::writeTraceTextForTopic(pszTopic, pszFile, sLine, pszFunction, pszText);
     }
-
-
-
-
-
     /*
     ---------------------------------------------------------------------------
        Trace Dump
@@ -126,68 +109,20 @@ namespace MASSAI
     {
       ::dumpTraceForTopic(pszTopic, pszFile, sLine, pszFunction, lDumpSize, pDump);
     }
-
-
     /*
     ---------------------------------------------------------------------------
       Start new files
-
     ---------------------------------------------------------------------------
     */
     void TraceClient::startNewTraceFileForTopic(const char* pszTopic) const
     {
       ::startNewTraceFileForTopic(pszTopic);
     }
-
-
-
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace encypted
-    ---------------------------------------------------------------------------
-    */
-    void TraceClient::cryptTrace
-    (
-       long lTraceLevel,
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       long lDumpSize,
-       const char* pDump
-    ) const
-    {
-      ::cryptTrace(lTraceLevel, pszFile, sLine, pszFunction, lDumpSize, pDump);
-    }
-
-
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace encypted
-    ---------------------------------------------------------------------------
-    */
-    void TraceClient::cryptTraceForTopic
-    (
-       const char* pszTopic,
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       long lDumpSize,
-       const char* pDump
-    ) const
-    {
-      ::cryptTraceForTopic(pszTopic, pszFile, sLine, pszFunction, lDumpSize, pDump);
-    }
-
-
-
     /*
     ---------------------------------------------------------------------------
        move file
     ---------------------------------------------------------------------------
     */
-
     void TraceClient::moveTrace
     (
        const char* pszPath
@@ -195,47 +130,5 @@ namespace MASSAI
     {
       ::moveTrace(pszPath);
     }
-
-
-
-
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace credit card track
-    ---------------------------------------------------------------------------
-    */
-    void TraceClient::traceTrack
-    (
-       long lTraceLevel,
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       long trackid,
-       const char* pszTrack
-    ) const
-    {
-      ::traceTrack(lTraceLevel, pszFile, sLine, pszFunction, trackid, pszTrack);
-    }
-
-
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace credit card track
-    ---------------------------------------------------------------------------
-    */
-    void TraceClient::traceTrackForTopic
-    (
-       const char* pszTopic,
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       long trackid,
-       const char* pszTrack
-    ) const
-    {
-      ::traceTrackForTopic(pszTopic, pszFile, sLine, pszFunction, trackid, pszTrack);
-    }
   }
 }
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/TraceDelegate.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/TraceDelegate.cpp
index 4a55cf03..60ea17fc 100644
--- a/SelfServiceCommon/Massai/cpp/Tools/src/TraceDelegate.cpp
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/TraceDelegate.cpp
@@ -11,7 +11,6 @@
 //  history:
 //---------------------------------------------------------------------------
 
-
 #include "Tools/TraceDelegate.h"
 #include "Tools/TraceInterface.h"
 
@@ -19,16 +18,27 @@ namespace MASSAI
 {
   namespace trace
   {
-    TraceDelegate::TraceDelegate(const TraceInterface* pDelegate):
-      m_pDelegate(pDelegate)
+    TraceDelegate::TraceDelegate():
+      m_delegate()
     {}
+    TraceDelegate::TraceDelegate(const TraceInterface* pDelegate):
+      m_delegate()
+    {
+      addTrace(pDelegate);
+    }
     TraceDelegate::~TraceDelegate()
     {}
+    void TraceDelegate::addTrace(const TraceInterface* pDelegate)
+    {
+      if(pDelegate)
+      {
+        m_delegate.push_back(pDelegate);
+      }
+    }
 
     /*
     ---------------------------------------------------------------------------
        Trace Text
-
     ---------------------------------------------------------------------------
     */
     void TraceDelegate::writeTraceText
@@ -40,12 +50,13 @@ namespace MASSAI
        const char* pszText
     ) const
     {
-      if(m_pDelegate)
+      TraceList::const_iterator it= m_delegate.begin();
+      TraceList::const_iterator end= m_delegate.end();
+      for(; it != end; it++)
       {
-        m_pDelegate->writeTraceText(lTraceLevel, pszFile, sLine, pszFunction, pszText);
+        (*it)->writeTraceText(lTraceLevel, pszFile, sLine, pszFunction, pszText);
       }
     }
-
     /*
     ---------------------------------------------------------------------------
        Trace Dump
@@ -61,30 +72,30 @@ namespace MASSAI
        const char* pDump
     ) const
     {
-      if(m_pDelegate)
+      TraceList::const_iterator it= m_delegate.begin();
+      TraceList::const_iterator end= m_delegate.end();
+      for(; it != end; it++)
       {
-        m_pDelegate->dumpTrace(lTraceLevel, pszFile, sLine, pszFunction, lDumpSize, pDump);
+        (*it)->dumpTrace(lTraceLevel, pszFile, sLine, pszFunction, lDumpSize, pDump);
       }
     }
-
     /*
     ---------------------------------------------------------------------------
       Start new files
-
     ---------------------------------------------------------------------------
     */
     void TraceDelegate::startNewTraceFile(long lTraceLevel) const
     {
-      if(m_pDelegate)
+      TraceList::const_iterator it= m_delegate.begin();
+      TraceList::const_iterator end= m_delegate.end();
+      for(; it != end; it++)
       {
-        m_pDelegate->startNewTraceFile(lTraceLevel);
+        (*it)->startNewTraceFile(lTraceLevel);
       }
     }
-
     /*
     ---------------------------------------------------------------------------
        Trace Text
-
     ---------------------------------------------------------------------------
     */
     void TraceDelegate::writeTraceTextForTopic
@@ -96,12 +107,13 @@ namespace MASSAI
        const char* pszText
     ) const
     {
-      if(m_pDelegate)
+      TraceList::const_iterator it= m_delegate.begin();
+      TraceList::const_iterator end= m_delegate.end();
+      for(; it != end; it++)
       {
-        m_pDelegate->writeTraceTextForTopic(pszTopic, pszFile, sLine, pszFunction, pszText);
+        (*it)->writeTraceTextForTopic(pszTopic, pszFile, sLine, pszFunction, pszText);
       }
     }
-
     /*
     ---------------------------------------------------------------------------
        Trace Dump
@@ -117,124 +129,42 @@ namespace MASSAI
        const char* pDump
     ) const
     {
-      if(m_pDelegate)
+      TraceList::const_iterator it= m_delegate.begin();
+      TraceList::const_iterator end= m_delegate.end();
+      for(; it != end; it++)
       {
-        m_pDelegate->dumpTraceForTopic(pszTopic, pszFile, sLine, pszFunction, lDumpSize, pDump);
+        (*it)->dumpTraceForTopic(pszTopic, pszFile, sLine, pszFunction, lDumpSize, pDump);
       }
     }
-
     /*
     ---------------------------------------------------------------------------
       Start new files
-
     ---------------------------------------------------------------------------
     */
     void TraceDelegate::startNewTraceFileForTopic(const char* pszTopic) const
     {
-      if(m_pDelegate)
-      {
-        m_pDelegate->startNewTraceFileForTopic(pszTopic);
-      }
-    }
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace encypted
-    ---------------------------------------------------------------------------
-    */
-    void TraceDelegate::cryptTrace
-    (
-       long lTraceLevel,
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       long lDumpSize,
-       const char* pDump
-    ) const
-    {
-      if(m_pDelegate)
-      {
-        m_pDelegate->cryptTrace(lTraceLevel, pszFile, sLine, pszFunction, lDumpSize, pDump);
-      }
-    }
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace encypted
-    ---------------------------------------------------------------------------
-    */
-    void TraceDelegate::cryptTraceForTopic
-    (
-       const char* pszTopic,
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       long lDumpSize,
-       const char* pDump
-    ) const
-    {
-      if(m_pDelegate)
+      TraceList::const_iterator it= m_delegate.begin();
+      TraceList::const_iterator end= m_delegate.end();
+      for(; it != end; it++)
       {
-        m_pDelegate->cryptTraceForTopic(pszTopic, pszFile, sLine, pszFunction, lDumpSize, pDump);
+        (*it)->startNewTraceFileForTopic(pszTopic);
       }
     }
-
     /*
     ---------------------------------------------------------------------------
        move file
     ---------------------------------------------------------------------------
     */
-
     void TraceDelegate::moveTrace
     (
        const char* pszPath
     ) const
     {
-      if(m_pDelegate)
-      {
-        m_pDelegate->moveTrace(pszPath);
-      }
-    }
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace credit card track
-    ---------------------------------------------------------------------------
-    */
-    void TraceDelegate::traceTrack
-    (
-       long lTraceLevel,
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       long trackid,
-       const char* pszTrack
-    ) const
-    {
-      if(m_pDelegate)
-      {
-        m_pDelegate->traceTrack(lTraceLevel, pszFile, sLine, pszFunction, trackid, pszTrack);
-      }
-    }
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace credit card track
-    ---------------------------------------------------------------------------
-    */
-    void TraceDelegate::traceTrackForTopic
-    (
-       const char* pszTopic,
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       long trackid,
-       const char* pszTrack
-    ) const
-    {
-      if(m_pDelegate)
+      TraceList::const_iterator it= m_delegate.begin();
+      TraceList::const_iterator end= m_delegate.end();
+      for(; it != end; it++)
       {
-        m_pDelegate->traceTrackForTopic(pszTopic, pszFile, sLine, pszFunction, trackid, pszTrack);
+        (*it)->moveTrace(pszPath);
       }
     }
   }
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/TraceFormatCB.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/TraceFormatCB.cpp
new file mode 100644
index 00000000..cbb80570
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/TraceFormatCB.cpp
@@ -0,0 +1,178 @@
+//---------------------------------------------------------------------------
+//
+//  file:       TraceFormatCB.cpp
+//
+//  purpose:    interface for traceing
+//
+//  date:       01.12.2011
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#include "Tools/TraceFormatCB.h"
+#include <sstream>
+#include <iostream>
+#include <iomanip>
+#include <windows.h>
+#include <stdlib.h>
+
+using namespace MASSAI::trace;
+
+namespace
+{
+  const char* truncate(const char* pszFile)
+  {
+    const char* result = strrchr(pszFile, '\\');
+    if(result == 0)
+    {
+      result = pszFile;
+    }
+    else
+    {
+      result++;
+    }
+    return result;
+  }
+  void head(std::ostream& out, ThreadId threadId, const mSysTime::Timestamp& timestamp,
+    long traceLevel, const char* topic, const char* file, long line,
+    const char* function)
+  {
+    const char* fileTruncated= truncate(file);
+    // date time threadid tracelevel/topic file line
+    char buffer[100];
+    sprintf(buffer, "%02d.%02d.%04d\t%02d:%02d:%02d,%03d\t%02d\t",
+      timestamp.day, timestamp.month, timestamp.year,
+      timestamp.hour, timestamp.minute, timestamp.second,
+      timestamp.milliseconds,
+      threadId);
+    out << buffer;
+
+    // tracelevel/topic
+    if(traceLevel != -1)
+    {
+      out << std::right << std::setfill('0') << std::dec;
+      out << std::setw(1) << traceLevel;
+    }
+    else if(topic != "")
+    {
+      out << std::left << std::setfill(' ');
+      out << std::setw(8) << topic;
+    }
+    out << "\t";
+    // file
+    out << std::left << std::setfill(' ');
+    out << std::setw(20) << fileTruncated << "\t";
+    // line
+    out << std::right << std::setfill('0') << std::dec;
+    out << "(" << std::setw(4) << line << ")\t";
+  }
+  void dumptoCB(Callback& cb, ThreadId threadId, const mSysTime::Timestamp& timestamp,
+    long traceLevel, const char* topic, const char* file, long line,
+    const char* function, size_t size, const char* pData)
+  {
+    std::ostringstream out;
+    head(out, threadId, timestamp, traceLevel, topic, file, line, function);
+    cb.traceLine(out.str(), "");
+
+    const unsigned char* puData= reinterpret_cast<const unsigned char*>(pData);
+    for(size_t i = 0; i < size; i += 16)
+    {
+      char head[100];
+      sprintf(head, "D\t\t%05d\t%05X\t", i, i);
+      char buffer[100];
+      char* it= buffer;
+      long j= 0;
+      for(j = 0; j < 16 && (i+j) < size; j++)
+      {
+        if(j == 8)
+        {
+          it+= sprintf(it, "- "); // delimiter
+        }
+        it+= sprintf(it, "%02X ", static_cast<int>(puData[i+j]));
+      }
+      while(j < 16) // less than 16 character
+      {
+        if(j == 8)
+        {
+        it+= sprintf(it, "  "); // add two spaces for delimiter
+        }
+        it+= sprintf(it, "   "); // add three spaces for every character
+        j++;
+      }
+      it+= sprintf(it, "\t\t");
+      for(j = 0; j < 16 && (i+j) < size; j++)
+      {
+        *it++= ((pData[i+j] >= ' ') ? pData[i+j] : '.');
+      }
+      *it++= 0;
+      cb.traceLine(head, buffer);
+    }
+  }
+
+  const char* nn(const char* data)
+  {
+    return data?data:"";
+  }
+}
+
+
+namespace MASSAI
+{
+  namespace trace
+  {
+    Callback::~Callback()
+    {}
+    TraceFormatCB::TraceFormatCB(Callback& callback):
+      m_callback(callback)
+    {}
+    TraceFormatCB::~TraceFormatCB()
+    {}
+    void TraceFormatCB::text(ThreadId threadId, const mSysTime::Timestamp& timestamp,
+      long traceLevel, const std::string& topic, const std::string& file, long line,
+      const std::string& function, const std::string& data) const
+    {
+      std::ostringstream out;
+      head(out, threadId, timestamp, traceLevel, topic.c_str(), file.c_str(), line, function.c_str());
+      m_callback.traceLine(out.str(), data);
+    }
+    void TraceFormatCB::dump(ThreadId threadId, const mSysTime::Timestamp& timestamp,
+      long traceLevel, const std::string& topic, const std::string& file, long line,
+      const std::string& function, const std::string& data) const
+    {
+      dumptoCB(m_callback, threadId, timestamp,
+        traceLevel, topic.c_str(), file.c_str(), line, function.c_str(), data.size(), data.data());
+    }
+    void TraceFormatCB::text(long traceLevel, const char* topic, const char* file, long line,
+      const char* function, const char* data) const
+    {
+      std::ostringstream out;
+      head(out, GetCurrentThreadId(), mSysTime::getTimestamp(),
+        traceLevel, nn(topic), nn(file), line, nn(function));
+      m_callback.traceLine(out.str(), nn(data));
+    }
+    void TraceFormatCB::dump(long traceLevel, const char* topic, const char* file, long line,
+      const char* function, size_t size, const char* data) const
+    {
+      dumptoCB(m_callback, GetCurrentThreadId(), mSysTime::getTimestamp(),
+        traceLevel, nn(topic), nn(file), line, nn(function), size, data);
+    }
+    void TraceFormatCB::text(ThreadId threadId, const mSysTime::Timestamp& timestamp,
+      long traceLevel, const char* topic, const char* file, long line,
+      const char* function, const char* data) const
+    {
+      std::ostringstream out;
+      head(out, threadId, timestamp,
+        traceLevel, nn(topic), nn(file), line, nn(function));
+      m_callback.traceLine(out.str(), nn(data));
+    }
+    void TraceFormatCB::dump(ThreadId threadId, const mSysTime::Timestamp& timestamp,
+      long traceLevel, const char* topic, const char* file, long line,
+      const char* function, size_t size, const char* data) const
+    {
+      dumptoCB(m_callback, threadId, timestamp,
+        traceLevel, nn(topic), nn(file), line, nn(function), size, data);
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/TraceHandle.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/TraceHandle.cpp
index ef497085..cca97369 100644
--- a/SelfServiceCommon/Massai/cpp/Tools/src/TraceHandle.cpp
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/TraceHandle.cpp
@@ -11,7 +11,6 @@
 //  history:
 //---------------------------------------------------------------------------
 
-
 #include "Tools/TraceHandle.h"
 #include "Tools/TraceInterface.h"
 #include "trc/TrcHdlClt.h"
@@ -29,7 +28,6 @@ namespace MASSAI
     {
       m_handle= ::openTrace(pszApplication);
     }
-
     TraceHandle::~TraceHandle()
     {
       if(m_close)
@@ -40,7 +38,6 @@ namespace MASSAI
     /*
     ---------------------------------------------------------------------------
        Trace Text
-
     ---------------------------------------------------------------------------
     */
     void TraceHandle::writeTraceText
@@ -54,8 +51,6 @@ namespace MASSAI
     {
       ::writeTraceText(m_handle, lTraceLevel, pszFile, sLine, pszFunction, pszText);
     }
-
-
     /*
     ---------------------------------------------------------------------------
        Trace Dump
@@ -73,25 +68,18 @@ namespace MASSAI
     {
       ::dumpTrace(m_handle, lTraceLevel, pszFile, sLine, pszFunction, lDumpSize, pDump);
     }
-
-
     /*
     ---------------------------------------------------------------------------
       Start new files
-
     ---------------------------------------------------------------------------
     */
     void TraceHandle::startNewTraceFile(long lTraceLevel) const
     {
       ::startNewTraceFile(m_handle, lTraceLevel);
     }
-
-
-
     /*
     ---------------------------------------------------------------------------
        Trace Text
-
     ---------------------------------------------------------------------------
     */
     void TraceHandle::writeTraceTextForTopic
@@ -105,11 +93,6 @@ namespace MASSAI
     {
       ::writeTraceTextForTopic(m_handle, pszTopic, pszFile, sLine, pszFunction, pszText);
     }
-
-
-
-
-
     /*
     ---------------------------------------------------------------------------
        Trace Dump
@@ -127,68 +110,20 @@ namespace MASSAI
     {
       ::dumpTraceForTopic(m_handle, pszTopic, pszFile, sLine, pszFunction, lDumpSize, pDump);
     }
-
-
     /*
     ---------------------------------------------------------------------------
       Start new files
-
     ---------------------------------------------------------------------------
     */
     void TraceHandle::startNewTraceFileForTopic(const char* pszTopic) const
     {
       ::startNewTraceFileForTopic(m_handle, pszTopic);
     }
-
-
-
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace encypted
-    ---------------------------------------------------------------------------
-    */
-    void TraceHandle::cryptTrace
-    (
-       long lTraceLevel,
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       long lDumpSize,
-       const char* pDump
-    ) const
-    {
-      ::cryptTrace(m_handle, lTraceLevel, pszFile, sLine, pszFunction, lDumpSize, pDump);
-    }
-
-
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace encypted
-    ---------------------------------------------------------------------------
-    */
-    void TraceHandle::cryptTraceForTopic
-    (
-       const char* pszTopic,
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       long lDumpSize,
-       const char* pDump
-    ) const
-    {
-      ::cryptTraceForTopic(m_handle, pszTopic, pszFile, sLine, pszFunction, lDumpSize, pDump);
-    }
-
-
-
     /*
     ---------------------------------------------------------------------------
        move file
     ---------------------------------------------------------------------------
     */
-
     void TraceHandle::moveTrace
     (
        const char* pszPath
@@ -196,48 +131,5 @@ namespace MASSAI
     {
       ::moveTrace(m_handle, pszPath);
     }
-
-
-
-
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace credit card track
-    ---------------------------------------------------------------------------
-    */
-    void TraceHandle::traceTrack
-    (
-       long lTraceLevel,
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       long trackid,
-       const char* pszTrack
-    ) const
-    {
-      ::traceTrack(m_handle, lTraceLevel, pszFile, sLine, pszFunction, trackid, pszTrack);
-    }
-
-
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace credit card track
-    ---------------------------------------------------------------------------
-    */
-    void TraceHandle::traceTrackForTopic
-    (
-       const char* pszTopic,
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       long trackid,
-       const char* pszTrack
-    ) const
-    {
-      ::traceTrackForTopic(m_handle, pszTopic, pszFile, sLine, pszFunction, trackid, pszTrack);
-    }
-
   }
 }
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/TraceInterface.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/TraceInterface.cpp
index f0e2307c..eaefc1ae 100644
--- a/SelfServiceCommon/Massai/cpp/Tools/src/TraceInterface.cpp
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/TraceInterface.cpp
@@ -24,8 +24,6 @@ namespace
     BUFFERSIZE= 4096
   };
 }
-
-
 namespace MASSAI
 {
   namespace trace
@@ -34,7 +32,6 @@ namespace MASSAI
     {}
     TraceInterface::~TraceInterface()
     {}
-
     /*
     ---------------------------------------------------------------------------
        Trace Text
@@ -59,7 +56,6 @@ namespace MASSAI
       writeTraceText(lTraceLevel, pszFile, sLine, pszFunction, buffer);
       va_end(arg_ptr);
     }
-
     /*
     ---------------------------------------------------------------------------
        Trace Text
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/TraceLocal.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/TraceLocal.cpp
index 7169e84d..5a8a3093 100644
--- a/SelfServiceCommon/Massai/cpp/Tools/src/TraceLocal.cpp
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/TraceLocal.cpp
@@ -11,225 +11,38 @@
 //  history:
 //---------------------------------------------------------------------------
 
-
 #include "Tools/TraceLocal.h"
-#include "Tools/localtrace.h"
-
-
+#include <iostream>
 
-namespace MASSAI
+namespace
 {
-  namespace trace
+  class LocalTrace: public MASSAI::trace::Callback
   {
-    TraceLocal::TraceLocal(const char* pszApplication)
+    public:
+      virtual void traceLine(const std::string& head, const std::string& data) const
+      {
+        std::cout << head << data << std::endl;
+      }
+  };
+  LocalTrace* pTrace= 0;
+  LocalTrace* getLocalTrace()
+  {
+    if(pTrace == 0)
     {
-      MASSAI::localtrace::openTrace(pszApplication);
+      pTrace= new LocalTrace();
     }
+    return pTrace;
+  }
+}
 
+namespace MASSAI
+{
+  namespace trace
+  {
+    TraceLocal::TraceLocal(const char* pszApplication):
+      TraceCallback(pszApplication, *getLocalTrace())
+    {}
     TraceLocal::~TraceLocal()
-    {
-      MASSAI::localtrace::closeTrace();
-    }
-    /*
-    ---------------------------------------------------------------------------
-       Trace Text
-
-    ---------------------------------------------------------------------------
-    */
-    void TraceLocal::writeTraceText
-    (
-       long lTraceLevel,
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       const char* pszText
-    ) const
-    {
-      MASSAI::localtrace::writeTraceText(lTraceLevel, pszFile, sLine, pszFunction, pszText);
-    }
-
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace Dump
-    ---------------------------------------------------------------------------
-    */
-    void TraceLocal::dumpTrace
-    (
-       long lTraceLevel,
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       long lDumpSize,
-       const char* pDump
-    ) const
-    {
-      MASSAI::localtrace::dumpTrace(lTraceLevel, pszFile, sLine, pszFunction, lDumpSize, pDump);
-    }
-
-
-    /*
-    ---------------------------------------------------------------------------
-      Start new files
-
-    ---------------------------------------------------------------------------
-    */
-    void TraceLocal::startNewTraceFile(long lTraceLevel) const
-    {
-      // MASSAI::localtrace::startNewTraceFile(lTraceLevel);
-    }
-
-
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace Text
-
-    ---------------------------------------------------------------------------
-    */
-    void TraceLocal::writeTraceTextForTopic
-    (
-       const char* pszTopic,
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       const char* pszText
-    ) const
-    {
-      MASSAI::localtrace::writeTraceTextForTopic(pszTopic, pszFile, sLine, pszFunction, pszText);
-    }
-
-
-
-
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace Dump
-    ---------------------------------------------------------------------------
-    */
-    void TraceLocal::dumpTraceForTopic
-    (
-       const char* pszTopic,
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       long lDumpSize,
-       const char* pDump
-    ) const
-    {
-      MASSAI::localtrace::dumpTraceForTopic(pszTopic, pszFile, sLine, pszFunction, lDumpSize, pDump);
-    }
-
-
-    /*
-    ---------------------------------------------------------------------------
-      Start new files
-
-    ---------------------------------------------------------------------------
-    */
-    void TraceLocal::startNewTraceFileForTopic(const char* pszTopic) const
-    {
-      // MASSAI::localtrace::startNewTraceFileForTopic(pszTopic);
-    }
-
-
-
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace encypted
-    ---------------------------------------------------------------------------
-    */
-    void TraceLocal::cryptTrace
-    (
-       long lTraceLevel,
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       long lDumpSize,
-       const char* pDump
-    ) const
-    {
-      // MASSAI::localtrace::cryptTrace(lTraceLevel, pszFile, sLine, pszFunction, lDumpSize, pDump);
-    }
-
-
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace encypted
-    ---------------------------------------------------------------------------
-    */
-    void TraceLocal::cryptTraceForTopic
-    (
-       const char* pszTopic,
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       long lDumpSize,
-       const char* pDump
-    ) const
-    {
-      // MASSAI::localtrace::cryptTraceForTopic(pszTopic, pszFile, sLine, pszFunction, lDumpSize, pDump);
-    }
-
-
-
-    /*
-    ---------------------------------------------------------------------------
-       move file
-    ---------------------------------------------------------------------------
-    */
-
-    void TraceLocal::moveTrace
-    (
-       const char* pszPath
-    ) const
-    {
-      // MASSAI::localtrace::moveTrace(pszPath);
-    }
-
-
-
-
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace credit card track
-    ---------------------------------------------------------------------------
-    */
-    void TraceLocal::traceTrack
-    (
-       long lTraceLevel,
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       long trackid,
-       const char* pszTrack
-    ) const
-    {
-      // MASSAI::localtrace::traceTrack(lTraceLevel, pszFile, sLine, pszFunction, trackid, pszTrack);
-    }
-
-
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace credit card track
-    ---------------------------------------------------------------------------
-    */
-    void TraceLocal::traceTrackForTopic
-    (
-       const char* pszTopic,
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       long trackid,
-       const char* pszTrack
-    ) const
-    {
-      // MASSAI::localtrace::traceTrackForTopic(pszTopic, pszFile, sLine, pszFunction, trackid, pszTrack);
-    }
+    {}
   }
 }
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/TraceLocationDelegate.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/TraceLocationDelegate.cpp
index 180bbc75..93153216 100644
--- a/SelfServiceCommon/Massai/cpp/Tools/src/TraceLocationDelegate.cpp
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/TraceLocationDelegate.cpp
@@ -11,7 +11,6 @@
 //  history:
 //---------------------------------------------------------------------------
 
-
 #include "Tools/TraceLocationDelegate.h"
 #include "Tools/TraceInterface.h"
 #include <stdarg.h>
@@ -25,8 +24,6 @@ namespace
   };
 }
 
-
-
 namespace MASSAI
 {
   namespace trace
@@ -45,8 +42,6 @@ namespace MASSAI
     {}
     TraceLocationDelegate::~TraceLocationDelegate()
     {}
-
-
     /*
     ---------------------------------------------------------------------------
        Trace Text
@@ -70,9 +65,7 @@ namespace MASSAI
         m_pDelegate->writeTraceText(lTraceLevel, m_pszFile, m_sLine, m_pszFunction, buffer);
       }
       va_end(arg_ptr);
-
     }
-
     /*
     ---------------------------------------------------------------------------
        Trace Text
@@ -97,11 +90,9 @@ namespace MASSAI
       }
       va_end(arg_ptr);
     }
-
     /*
     ---------------------------------------------------------------------------
        Trace Text
-
     ---------------------------------------------------------------------------
     */
     void TraceLocationDelegate::writeTraceText
@@ -115,7 +106,6 @@ namespace MASSAI
         m_pDelegate->writeTraceText(lTraceLevel, m_pszFile, m_sLine, m_pszFunction, pszText);
       }
     }
-
     /*
     ---------------------------------------------------------------------------
        Trace Dump
@@ -133,11 +123,9 @@ namespace MASSAI
         m_pDelegate->dumpTrace(lTraceLevel, m_pszFile, m_sLine, m_pszFunction, lDumpSize, pDump);
       }
     }
-
     /*
     ---------------------------------------------------------------------------
       Start new files
-
     ---------------------------------------------------------------------------
     */
     void TraceLocationDelegate::startNewTraceFile(long lTraceLevel) const
@@ -147,11 +135,9 @@ namespace MASSAI
         m_pDelegate->startNewTraceFile(lTraceLevel);
       }
     }
-
     /*
     ---------------------------------------------------------------------------
        Trace Text
-
     ---------------------------------------------------------------------------
     */
     void TraceLocationDelegate::writeTraceTextForTopic
@@ -165,7 +151,6 @@ namespace MASSAI
         m_pDelegate->writeTraceTextForTopic(pszTopic, m_pszFile, m_sLine, m_pszFunction, pszText);
       }
     }
-
     /*
     ---------------------------------------------------------------------------
        Trace Dump
@@ -183,11 +168,9 @@ namespace MASSAI
         m_pDelegate->dumpTraceForTopic(pszTopic, m_pszFile, m_sLine, m_pszFunction, lDumpSize, pDump);
       }
     }
-
     /*
     ---------------------------------------------------------------------------
       Start new files
-
     ---------------------------------------------------------------------------
     */
     void TraceLocationDelegate::startNewTraceFileForTopic(const char* pszTopic) const
@@ -197,49 +180,11 @@ namespace MASSAI
         m_pDelegate->startNewTraceFileForTopic(pszTopic);
       }
     }
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace encypted
-    ---------------------------------------------------------------------------
-    */
-    void TraceLocationDelegate::cryptTrace
-    (
-       long lTraceLevel,
-       long lDumpSize,
-       const char* pDump
-    ) const
-    {
-      if(m_pDelegate)
-      {
-        m_pDelegate->cryptTrace(lTraceLevel, m_pszFile, m_sLine, m_pszFunction, lDumpSize, pDump);
-      }
-    }
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace encypted
-    ---------------------------------------------------------------------------
-    */
-    void TraceLocationDelegate::cryptTraceForTopic
-    (
-       const char* pszTopic,
-       long lDumpSize,
-       const char* pDump
-    ) const
-    {
-      if(m_pDelegate)
-      {
-        m_pDelegate->cryptTraceForTopic(pszTopic, m_pszFile, m_sLine, m_pszFunction, lDumpSize, pDump);
-      }
-    }
-
     /*
     ---------------------------------------------------------------------------
        move file
     ---------------------------------------------------------------------------
     */
-
     void TraceLocationDelegate::moveTrace
     (
        const char* pszPath
@@ -250,43 +195,6 @@ namespace MASSAI
         m_pDelegate->moveTrace(pszPath);
       }
     }
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace credit card track
-    ---------------------------------------------------------------------------
-    */
-    void TraceLocationDelegate::traceTrack
-    (
-       long lTraceLevel,
-       long trackid,
-       const char* pszTrack
-    ) const
-    {
-      if(m_pDelegate)
-      {
-        m_pDelegate->traceTrack(lTraceLevel, m_pszFile, m_sLine, m_pszFunction, trackid, pszTrack);
-      }
-    }
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace credit card track
-    ---------------------------------------------------------------------------
-    */
-    void TraceLocationDelegate::traceTrackForTopic
-    (
-       const char* pszTopic,
-       long trackid,
-       const char* pszTrack
-    ) const
-    {
-      if(m_pDelegate)
-      {
-        m_pDelegate->traceTrackForTopic(pszTopic, m_pszFile, m_sLine, m_pszFunction, trackid, pszTrack);
-      }
-    }
-
     const TraceInterface* TraceLocationDelegate::getDelegate() const
     {
       return m_pDelegate;
@@ -303,17 +211,12 @@ namespace MASSAI
     {
       return m_pszFunction;
     }
-
-
-
     TraceTopicDelegate::TraceTopicDelegate(const TraceInterface* pDelegate, const char* pszTopic):
       m_pDelegate(pDelegate),
       m_pszTopic(pszTopic)
     {}
     TraceTopicDelegate::~TraceTopicDelegate()
     {}
-
-
     /*
     ---------------------------------------------------------------------------
        Trace Text
@@ -340,11 +243,9 @@ namespace MASSAI
       }
       va_end(arg_ptr);
     }
-
     /*
     ---------------------------------------------------------------------------
        Trace Text
-
     ---------------------------------------------------------------------------
     */
     void TraceTopicDelegate::writeTraceTextForTopic
@@ -360,7 +261,6 @@ namespace MASSAI
         m_pDelegate->writeTraceTextForTopic(m_pszTopic, pszFile, sLine, pszFunction, pszText);
       }
     }
-
     /*
     ---------------------------------------------------------------------------
        Trace Dump
@@ -380,11 +280,9 @@ namespace MASSAI
         m_pDelegate->dumpTraceForTopic(m_pszTopic, pszFile, sLine, pszFunction, lDumpSize, pDump);
       }
     }
-
     /*
     ---------------------------------------------------------------------------
       Start new files
-
     ---------------------------------------------------------------------------
     */
     void TraceTopicDelegate::startNewTraceFileForTopic() const
@@ -394,33 +292,11 @@ namespace MASSAI
         m_pDelegate->startNewTraceFileForTopic(m_pszTopic);
       }
     }
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace encypted
-    ---------------------------------------------------------------------------
-    */
-    void TraceTopicDelegate::cryptTraceForTopic
-    (
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       long lDumpSize,
-       const char* pDump
-    ) const
-    {
-      if(m_pDelegate)
-      {
-        m_pDelegate->cryptTraceForTopic(m_pszTopic, pszFile, sLine, pszFunction, lDumpSize, pDump);
-      }
-    }
-
     /*
     ---------------------------------------------------------------------------
        move file
     ---------------------------------------------------------------------------
     */
-
     void TraceTopicDelegate::moveTrace
     (
        const char* pszPath
@@ -431,39 +307,14 @@ namespace MASSAI
         m_pDelegate->moveTrace(pszPath);
       }
     }
-
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace credit card track
-    ---------------------------------------------------------------------------
-    */
-    void TraceTopicDelegate::traceTrackForTopic
-    (
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       long trackid,
-       const char* pszTrack
-    ) const
-    {
-      if(m_pDelegate)
-      {
-        m_pDelegate->traceTrackForTopic(m_pszTopic, pszFile, sLine, pszFunction, trackid, pszTrack);
-      }
-    }
-
     const TraceInterface* TraceTopicDelegate::getDelegate() const
     {
       return m_pDelegate;
     }
-
     const char* TraceTopicDelegate::getTopic() const
     {
       return m_pszTopic;
     }
-
-
     TraceLocationTopicDelegate::TraceLocationTopicDelegate
     (
       const TraceTopicDelegate& delegate,
@@ -477,7 +328,6 @@ namespace MASSAI
       m_sLine(sLine),
       m_pszFunction(pszFunction)
     {}
-
     TraceLocationTopicDelegate::TraceLocationTopicDelegate
     (
       const TraceLocationDelegate& delegate,
@@ -489,7 +339,6 @@ namespace MASSAI
       m_sLine(delegate.getLine()),
       m_pszFunction(delegate.getFunction())
     {}
-
     TraceLocationTopicDelegate::TraceLocationTopicDelegate
     (
       const TraceInterface* pDelegate,
@@ -506,8 +355,6 @@ namespace MASSAI
     {}
     TraceLocationTopicDelegate::~TraceLocationTopicDelegate()
     {}
-
-
     /*
     ---------------------------------------------------------------------------
        Trace Text
@@ -531,12 +378,9 @@ namespace MASSAI
       }
       va_end(arg_ptr);
     }
-
-
     /*
     ---------------------------------------------------------------------------
        Trace Text
-
     ---------------------------------------------------------------------------
     */
     void TraceLocationTopicDelegate::writeTraceTextForTopic
@@ -549,7 +393,6 @@ namespace MASSAI
         m_pDelegate->writeTraceTextForTopic(m_pszTopic, m_pszFile, m_sLine, m_pszFunction, pszText);
       }
     }
-
     /*
     ---------------------------------------------------------------------------
        Trace Dump
@@ -566,11 +409,9 @@ namespace MASSAI
         m_pDelegate->dumpTraceForTopic(m_pszTopic, m_pszFile, m_sLine, m_pszFunction, lDumpSize, pDump);
       }
     }
-
     /*
     ---------------------------------------------------------------------------
       Start new files
-
     ---------------------------------------------------------------------------
     */
     void TraceLocationTopicDelegate::startNewTraceFileForTopic() const
@@ -580,30 +421,11 @@ namespace MASSAI
         m_pDelegate->startNewTraceFileForTopic(m_pszTopic);
       }
     }
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace encypted
-    ---------------------------------------------------------------------------
-    */
-    void TraceLocationTopicDelegate::cryptTraceForTopic
-    (
-       long lDumpSize,
-       const char* pDump
-    ) const
-    {
-      if(m_pDelegate)
-      {
-        m_pDelegate->cryptTraceForTopic(m_pszTopic, m_pszFile, m_sLine, m_pszFunction, lDumpSize, pDump);
-      }
-    }
-
     /*
     ---------------------------------------------------------------------------
        move file
     ---------------------------------------------------------------------------
     */
-
     void TraceLocationTopicDelegate::moveTrace
     (
        const char* pszPath
@@ -614,23 +436,6 @@ namespace MASSAI
         m_pDelegate->moveTrace(pszPath);
       }
     }
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace credit card track
-    ---------------------------------------------------------------------------
-    */
-    void TraceLocationTopicDelegate::traceTrackForTopic
-    (
-       long trackid,
-       const char* pszTrack
-    ) const
-    {
-      if(m_pDelegate)
-      {
-        m_pDelegate->traceTrackForTopic(m_pszTopic, m_pszFile, m_sLine, m_pszFunction, trackid, pszTrack);
-      }
-    }
     const TraceInterface* TraceLocationTopicDelegate::getDelegate() const
     {
       return m_pDelegate;
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/TraceSync.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/TraceSync.cpp
index facfd283..cc4e812b 100644
--- a/SelfServiceCommon/Massai/cpp/Tools/src/TraceSync.cpp
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/TraceSync.cpp
@@ -11,7 +11,6 @@
 //  history:
 //---------------------------------------------------------------------------
 
-
 #include "Tools/TraceSync.h"
 #include "Tools/TraceInterface.h"
 #include "systools/mAutoMutex.hpp"
@@ -28,7 +27,6 @@ namespace MASSAI
     /*
     ---------------------------------------------------------------------------
        Trace Text
-
     ---------------------------------------------------------------------------
     */
     void TraceSync::writeTraceText
@@ -43,8 +41,6 @@ namespace MASSAI
       Materna::MSSD::autoMutex mx(m_access);
       m_delegate.writeTraceText(lTraceLevel, pszFile, sLine, pszFunction, pszText);
     }
-
-
     /*
     ---------------------------------------------------------------------------
        Trace Dump
@@ -63,12 +59,9 @@ namespace MASSAI
       Materna::MSSD::autoMutex mx(m_access);
       m_delegate.dumpTrace(lTraceLevel, pszFile, sLine, pszFunction, lDumpSize, pDump);
     }
-
-
     /*
     ---------------------------------------------------------------------------
       Start new files
-
     ---------------------------------------------------------------------------
     */
     void TraceSync::startNewTraceFile(long lTraceLevel) const
@@ -76,13 +69,9 @@ namespace MASSAI
       Materna::MSSD::autoMutex mx(m_access);
       m_delegate.startNewTraceFile(lTraceLevel);
     }
-
-
-
     /*
     ---------------------------------------------------------------------------
        Trace Text
-
     ---------------------------------------------------------------------------
     */
     void TraceSync::writeTraceTextForTopic
@@ -97,11 +86,6 @@ namespace MASSAI
       Materna::MSSD::autoMutex mx(m_access);
       m_delegate.writeTraceTextForTopic(pszTopic, pszFile, sLine, pszFunction, pszText);
     }
-
-
-
-
-
     /*
     ---------------------------------------------------------------------------
        Trace Dump
@@ -120,12 +104,9 @@ namespace MASSAI
       Materna::MSSD::autoMutex mx(m_access);
       m_delegate.dumpTraceForTopic(pszTopic, pszFile, sLine, pszFunction, lDumpSize, pDump);
     }
-
-
     /*
     ---------------------------------------------------------------------------
       Start new files
-
     ---------------------------------------------------------------------------
     */
     void TraceSync::startNewTraceFileForTopic(const char* pszTopic) const
@@ -133,58 +114,11 @@ namespace MASSAI
       Materna::MSSD::autoMutex mx(m_access);
       m_delegate.startNewTraceFileForTopic(pszTopic);
     }
-
-
-
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace encypted
-    ---------------------------------------------------------------------------
-    */
-    void TraceSync::cryptTrace
-    (
-       long lTraceLevel,
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       long lDumpSize,
-       const char* pDump
-    ) const
-    {
-      Materna::MSSD::autoMutex mx(m_access);
-      m_delegate.cryptTrace(lTraceLevel, pszFile, sLine, pszFunction, lDumpSize, pDump);
-    }
-
-
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace encypted
-    ---------------------------------------------------------------------------
-    */
-    void TraceSync::cryptTraceForTopic
-    (
-       const char* pszTopic,
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       long lDumpSize,
-       const char* pDump
-    ) const
-    {
-      Materna::MSSD::autoMutex mx(m_access);
-      m_delegate.cryptTraceForTopic(pszTopic, pszFile, sLine, pszFunction, lDumpSize, pDump);
-    }
-
-
-
     /*
     ---------------------------------------------------------------------------
        move file
     ---------------------------------------------------------------------------
     */
-
     void TraceSync::moveTrace
     (
        const char* pszPath
@@ -193,50 +127,5 @@ namespace MASSAI
       Materna::MSSD::autoMutex mx(m_access);
       m_delegate.moveTrace(pszPath);
     }
-
-
-
-
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace credit card track
-    ---------------------------------------------------------------------------
-    */
-    void TraceSync::traceTrack
-    (
-       long lTraceLevel,
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       long trackid,
-       const char* pszTrack
-    ) const
-    {
-      Materna::MSSD::autoMutex mx(m_access);
-      m_delegate.traceTrack(lTraceLevel, pszFile, sLine, pszFunction, trackid, pszTrack);
-    }
-
-
-
-    /*
-    ---------------------------------------------------------------------------
-       Trace credit card track
-    ---------------------------------------------------------------------------
-    */
-    void TraceSync::traceTrackForTopic
-    (
-       const char* pszTopic,
-       const char* pszFile,
-       short  sLine,
-       const char* pszFunction,
-       long trackid,
-       const char* pszTrack
-    ) const
-    {
-      Materna::MSSD::autoMutex mx(m_access);
-        m_delegate.traceTrackForTopic(pszTopic, pszFile, sLine, pszFunction, trackid, pszTrack);
-    }
-
   }
 }
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/TraceSystem.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/TraceSystem.cpp
new file mode 100644
index 00000000..37f8830d
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/TraceSystem.cpp
@@ -0,0 +1,48 @@
+//---------------------------------------------------------------------------
+//
+//  file:       TraceSystem.cpp
+//
+//  purpose:    interface for traceing
+//
+//  date:       02.12.2011
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#include "Tools/TraceSystem.h"
+#include <windows.h>
+
+namespace
+{
+  class SystemTrace: public MASSAI::trace::Callback
+  {
+    public:
+      virtual void traceLine(const std::string& head, const std::string& data) const
+      {
+        OutputDebugString((head+data).c_str());
+      }
+  };
+  SystemTrace* pTrace= 0;
+  SystemTrace* getSystemTrace()
+  {
+    if(pTrace == 0)
+    {
+      pTrace= new SystemTrace();
+    }
+    return pTrace;
+  }
+}
+
+namespace MASSAI
+{
+  namespace trace
+  {
+    TraceSystem::TraceSystem(const char* pszApplication):
+      TraceCallback(pszApplication, *getSystemTrace())
+    {}
+    TraceSystem::~TraceSystem()
+    {}
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/localtrace.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/localtrace.cpp
index 5abb78fa..6fe7d4a5 100644
--- a/SelfServiceCommon/Massai/cpp/Tools/src/localtrace.cpp
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/localtrace.cpp
@@ -1,76 +1,30 @@
-#include <windows.h>
 #include <stdio.h>
+#include <stdarg.h>
 #include "Tools/localtrace.h"
+#include "Tools/TraceFormatCB.h"
 
 namespace
 {
-  const char* formatFile(const char* pszFile)
+  class LocalTraceLine: public MASSAI::trace::Callback
   {
-    const char* result = strrchr(pszFile, '\\');
-    if(result == 0)
-    {
-      result = pszFile;
-    }
-    else
-    {
-      result++;
-    }
-    return result;
-  }
-
-  void printHeader(long lTraceLevel, const char* pszFile, short sLine)
-  {
-    SYSTEMTIME now;
-    GetLocalTime(&now);
-    DWORD tid = GetCurrentThreadId();
-    printf("\n");
-    printf("%02d.%02d.%04d %02d:%02d:%02d.%03d ", now.wDay, now.wMonth, now.wYear, now.wHour, now.wMinute, now.wSecond, now.wMilliseconds);
-    printf("[%04x] ", tid);
-    printf("%d ", lTraceLevel);
-    printf("%11.11s(%03d): ", formatFile(pszFile), sLine);
-  }
-  void printHeader(const char* pszTopic, const char* pszFile, short sLine)
-  {
-    SYSTEMTIME now;
-    GetLocalTime(&now);
-    DWORD tid = GetCurrentThreadId();
-    printf("\n");
-    printf("%02d.%02d.%04d %02d:%02d:%02d.%03d ", now.wDay, now.wMonth, now.wYear, now.wHour, now.wMinute, now.wSecond, now.wMilliseconds);
-    printf("[%04x] ", tid);
-    printf("% 10s ", pszTopic);
-    printf("%11.11s(%03d): ", formatFile(pszFile), sLine);
-  }
-  void printDump(long lDumpSize, const char* pDump)
-  {
-    long i;
-    for(i = 0; i < lDumpSize; i += 16)
-    {
-      printf("[%04x,%04d] ", i, i);
-      long j;
-      for(j = 0; j < 16 && (i+j) < lDumpSize; j++)
+    public:
+      void traceLine(const std::string& head, const std::string& data) const
       {
-        if(j == 8)
-        {
-          printf("- ");
-        }
-        printf("%02x ",((unsigned char*)pDump)[i+j]);
+        printf("%s%s\n", head.c_str(), data.c_str());
       }
-
-      while(j < 16)
+  };
+  class LocalTrace: public MASSAI::trace::Callback
+  {
+    public:
+      void traceLine(const std::string& head, const std::string& data) const
       {
-        if(j == 8)
-          printf("     ");
-        else
-          printf("   ");
-        j++;
+        printf("%s%s", head.c_str(), data.c_str());
       }
-
-      for(j = 0; j < 16 && (i+j) < lDumpSize; j++)
-        printf("%c", (pDump[i+j] >= ' ') ? pDump[i+j]: '.');
-
-      printf("\n");
-    }
-  }
+  };
+  LocalTrace localTrace;
+  LocalTraceLine localTraceLine;
+  MASSAI::trace::TraceFormatCB format(localTrace);
+  MASSAI::trace::TraceFormatCB formatLine(localTraceLine);
 }
 
 namespace MASSAI
@@ -85,48 +39,42 @@ namespace MASSAI
     {
       wrtTrace(MajorError_HERE, "--- Trace Close ---");
     }
-
     void writeTraceText(long lTraceLevel, const char* pszFile, short sLine, const char* pszFunction, const char* pszText)
     {
-      printHeader(lTraceLevel, pszFile, sLine);
-      printf("%s", pszText);
+      format.text(lTraceLevel, 0, pszFile, sLine, pszFunction, "");
+      printf("%s\n", pszText);
     }
-
     void wrtTrace(long lTraceLevel, const char* pszFile, short sLine, const char* pszFunction, const char* pszFormat, ...)
     {
-      va_list   arg_ptr;
-      va_start( arg_ptr, pszFormat);
-
-      printHeader(lTraceLevel, pszFile, sLine);
+      va_list arg_ptr;
+      va_start(arg_ptr, pszFormat);
+      format.text(lTraceLevel, 0, pszFile, sLine, pszFunction, "");
       vprintf(pszFormat, arg_ptr);
-      va_end( arg_ptr);
+      printf("\n");
+      va_end(arg_ptr);
     }
-
     void dumpTrace(long lTraceLevel, const char* pszFile, short sLine, const char* pszFunction, long lDumpSize, const char* pDump)
     {
-      printHeader(lTraceLevel, pszFile, sLine);
-      printf("\n");
-      printDump(lDumpSize, pDump);
+      formatLine.dump(lTraceLevel, 0, pszFile, sLine, pszFunction, lDumpSize, pDump);
     }
     void writeTraceTextForTopic(const char* pszTopic, const char* pszFile, short sLine, const char* pszFunction, const char* pszText)
     {
-      printHeader(pszTopic, pszFile, sLine);
-      printf("%s", pszText);
+      format.text(-1, pszTopic, pszFile, sLine, pszFunction, "");
+      printf("%s\n", pszText);
     }
     void wrtTraceForTopic(const char* pszTopic, const char* pszFile, short sLine, const char* pszFunction, const char* pszFormat, ...)
     {
-      va_list   arg_ptr;
-      va_start( arg_ptr, pszFormat);
+      va_list arg_ptr;
+      va_start(arg_ptr, pszFormat);
 
-      printHeader(pszTopic, pszFile, sLine);
+      format.text(-1, pszTopic, pszFile, sLine, pszFunction, "");
       vprintf(pszFormat, arg_ptr);
-      va_end( arg_ptr);
+      printf("\n");
+      va_end(arg_ptr);
     }
     void dumpTraceForTopic(const char* pszTopic, const char* pszFile, short sLine, const char* pszFunction, long lDumpSize, const char* pDump)
     {
-      printHeader(pszTopic, pszFile, sLine);
-      printf("\n");
-      printDump(lDumpSize, pDump);
+      formatLine.dump(-1, pszTopic, pszFile, sLine, pszFunction, lDumpSize, pDump);
     }
   }
 }
diff --git a/SelfServiceCommon/Massai/cpp/Trace/inc/TraceCmd.h b/SelfServiceCommon/Massai/cpp/Trace/inc/TraceCmd.h
index 78b3fd88..4cd66d08 100644
--- a/SelfServiceCommon/Massai/cpp/Trace/inc/TraceCmd.h
+++ b/SelfServiceCommon/Massai/cpp/Trace/inc/TraceCmd.h
@@ -21,7 +21,8 @@
 #pragma warning(disable:4786)
 
 #include <string>
-#include "systools\mEventSem.hpp"
+#include "systools/mEventSem.hpp"
+#include "systools/mSysTime.h"
 #include "TraceSystem.h"
 
 namespace MASSAI
@@ -57,7 +58,7 @@ namespace MASSAI
           long dataSize);
         TraceCmd(Command cmd, int hdl, TraceSession* pSession);
         TraceCmd(Command cmd, int hdl, Materna::MSSD::eventSemaphore* pEvent);
-        TraceCmd(Command cmd, Timestamp ts);
+        TraceCmd(Command cmd, mSysTime::Timestamp ts);
 
         void init(const char* pData, long dataSize);
 
@@ -72,7 +73,7 @@ namespace MASSAI
         std::string function;
         std::string topic;
         std::string data;
-        Timestamp timestamp;
+        mSysTime::Timestamp timestamp;
         TraceSession* pSession;
         Materna::MSSD::eventSemaphore* pEvent;
     };
diff --git a/SelfServiceCommon/Massai/cpp/Trace/inc/TraceCmdQueue.h b/SelfServiceCommon/Massai/cpp/Trace/inc/TraceCmdQueue.h
index 58d4b2f5..e6ae8a8c 100644
--- a/SelfServiceCommon/Massai/cpp/Trace/inc/TraceCmdQueue.h
+++ b/SelfServiceCommon/Massai/cpp/Trace/inc/TraceCmdQueue.h
@@ -24,6 +24,8 @@
 #include "systools/matThread.hpp"
 #include "systools/mEventSem.hpp"
 #include "systools/mMutexCS.h"
+#include "systools/mSysTime.h"
+
 
 #include <list>
 
@@ -57,7 +59,7 @@ namespace MASSAI
         bool m_stop;
         bool m_started;
         int m_waitCount;
-        Timestamp m_currentday;
+        mSysTime::Timestamp m_currentday;
         TraceProcessor& m_processor;
 
     };
diff --git a/SelfServiceCommon/Massai/cpp/Trace/inc/TraceConfig.h b/SelfServiceCommon/Massai/cpp/Trace/inc/TraceConfig.h
index eb3090d3..7fc45fe7 100644
--- a/SelfServiceCommon/Massai/cpp/Trace/inc/TraceConfig.h
+++ b/SelfServiceCommon/Massai/cpp/Trace/inc/TraceConfig.h
@@ -24,6 +24,7 @@
 #include "TraceEnvConfig.h"
 #include "boost/filesystem/path.hpp"
 #include "boost/shared_ptr.hpp"
+#include "systools/mSysTime.h"
 #include <string>
 #include <map>
 
@@ -93,7 +94,7 @@ namespace MASSAI
         void setHandle(int hdl);
         void setSessionPath(const std::string& path);
 
-        boost::filesystem::path getBackupPath(const boost::filesystem::path& base, const Timestamp& ts);
+        boost::filesystem::path getBackupPath(const boost::filesystem::path& base, const mSysTime::Timestamp& ts);
         std::string getNewFilename();
         boost::filesystem::path getFullPath() const;
         long getFileSizeLimit() const;
diff --git a/SelfServiceCommon/Massai/cpp/Trace/inc/TraceFormat.h b/SelfServiceCommon/Massai/cpp/Trace/inc/TraceFormat.h
index 015dbf7d..5b0e706e 100644
--- a/SelfServiceCommon/Massai/cpp/Trace/inc/TraceFormat.h
+++ b/SelfServiceCommon/Massai/cpp/Trace/inc/TraceFormat.h
@@ -21,6 +21,7 @@
 #pragma warning(disable:4786)
 
 #include "TraceSystem.h"
+#include "systools/mSysTime.h"
 #include <ostream>
 #include <string>
 
@@ -34,17 +35,8 @@ namespace MASSAI
         TraceFormat();
         ~TraceFormat();
         std::string filename(const std::string& sessionId,
-          ProcessId processId, const Timestamp& timestamp);
-        std::string backupPath(const Timestamp& timestamp);
-        void head(std::ostream& out, ThreadId threadId, const Timestamp& timestamp,
-          long traceLevel, const std::string& topic, const std::string& file, long line,
-          const std::string& function);
-        void text(std::ostream& out, ThreadId threadId, const Timestamp& timestamp,
-          long traceLevel, const std::string& topic, const std::string& file, long line,
-          const std::string& function, const std::string& data);
-        void dump(std::ostream& out, ThreadId threadId, const Timestamp& timestamp,
-          long traceLevel, const std::string& topic, const std::string& file, long line,
-          const std::string& function, const std::string& data);
+          ProcessId processId, const mSysTime::Timestamp& timestamp);
+        std::string backupPath(const mSysTime::Timestamp& timestamp);
     };
     TraceFormat& getTraceFormat();
   }
diff --git a/SelfServiceCommon/Massai/cpp/Trace/inc/TraceSession.h b/SelfServiceCommon/Massai/cpp/Trace/inc/TraceSession.h
index 594ff3ed..aef3a897 100644
--- a/SelfServiceCommon/Massai/cpp/Trace/inc/TraceSession.h
+++ b/SelfServiceCommon/Massai/cpp/Trace/inc/TraceSession.h
@@ -23,16 +23,27 @@
 #include "TraceConfig.h"
 #include "TraceSystem.h"
 #include "boost/filesystem/path.hpp"
+#include "Tools/TraceFormatCB.h"
 #include <string>
 #include <ostream>
 #include <memory>
 
-
 namespace MASSAI
 {
   namespace trace
   {
     class TraceCmd;
+    class TraceCallback: public Callback
+    {
+      public:
+        TraceCallback();
+        virtual ~TraceCallback();
+        virtual void traceLine(const std::string& head, const std::string& data) const;
+        void setOut(std::ostream* pOut);
+
+      private:
+        std::ostream* m_pOut;
+    };
     class TraceSession
     {
       public:
@@ -45,11 +56,14 @@ namespace MASSAI
         const std::string& getSessionId() const;
         void setSessionId(const std::string& sessionId);
         void setHandle(int hdl);
+        void traceLine(const std::string& out) const;
       private:
         TraceConfig m_config;
         boost::filesystem::path m_path; // path for current trace file
         std::string m_filename;
         std::auto_ptr<std::ostream> m_pOut;
+        TraceCallback m_callback;
+        TraceFormatCB m_format;
 
         void move();
         void openFile();
@@ -62,7 +76,6 @@ namespace MASSAI
         void changeLevel(const TraceCmd& cmd);
         void changeTopic(const TraceCmd& cmd, bool isActive);
         void changeDirectory(const TraceCmd& cmd);
-
     };
   }
 }
diff --git a/SelfServiceCommon/Massai/cpp/Trace/inc/TraceSystem.h b/SelfServiceCommon/Massai/cpp/Trace/inc/TraceSystem.h
index 42134189..3fae1b8d 100644
--- a/SelfServiceCommon/Massai/cpp/Trace/inc/TraceSystem.h
+++ b/SelfServiceCommon/Massai/cpp/Trace/inc/TraceSystem.h
@@ -28,21 +28,9 @@ namespace MASSAI
   {
     typedef long ProcessId;
     typedef long ThreadId;
-    class Timestamp {
-      public:
-        int year;
-        int month;
-        int dayOfWeek;
-        int day;
-        int hour;
-        int minute;
-        int second;
-        int milliseconds;
-    };
 
     ThreadId getThreadId();
     ProcessId getProcessId();
-    Timestamp getTimestamp();
     boost::filesystem::path getBasePath();
     void sysTrace(const std::string& text);
     void sleep(long milliseconds);
diff --git a/SelfServiceCommon/Massai/cpp/Trace/src/TraceCmd.cpp b/SelfServiceCommon/Massai/cpp/Trace/src/TraceCmd.cpp
index 10b18578..1a7f9d2a 100644
--- a/SelfServiceCommon/Massai/cpp/Trace/src/TraceCmd.cpp
+++ b/SelfServiceCommon/Massai/cpp/Trace/src/TraceCmd.cpp
@@ -84,7 +84,7 @@ namespace MASSAI
     {
       init(0, 0);
     }
-    TraceCmd::TraceCmd(Command cmd, Timestamp ts):
+    TraceCmd::TraceCmd(Command cmd, mSysTime::Timestamp ts):
       cmd(cmd),
       traceLevel(-1),
       line(0),
@@ -102,7 +102,7 @@ namespace MASSAI
 
     void TraceCmd::init(const char* pData, long dataSize)
     {
-      timestamp= getTimestamp();
+      timestamp= mSysTime::getTimestamp();
       threadId= getThreadId();
       if(pData)
       {
diff --git a/SelfServiceCommon/Massai/cpp/Trace/src/TraceCmdQueue.cpp b/SelfServiceCommon/Massai/cpp/Trace/src/TraceCmdQueue.cpp
index 8deab93d..2852a963 100644
--- a/SelfServiceCommon/Massai/cpp/Trace/src/TraceCmdQueue.cpp
+++ b/SelfServiceCommon/Massai/cpp/Trace/src/TraceCmdQueue.cpp
@@ -162,12 +162,12 @@ namespace MASSAI
     }
     void TraceCmdQueue::initNewDay()
     {
-      m_currentday= getTimestamp();
+      m_currentday= mSysTime::getTimestamp();
     }
     TraceCmd* TraceCmdQueue::getNewDay()
     {
       TraceCmd* result= 0;
-      Timestamp now= getTimestamp();
+      mSysTime::Timestamp now= mSysTime::getTimestamp();
       if(m_currentday.year != now.year
         || m_currentday.month != now.month
         || m_currentday.day != now.day)
diff --git a/SelfServiceCommon/Massai/cpp/Trace/src/TraceConfig.cpp b/SelfServiceCommon/Massai/cpp/Trace/src/TraceConfig.cpp
index 8331ab50..0ce6cb27 100644
--- a/SelfServiceCommon/Massai/cpp/Trace/src/TraceConfig.cpp
+++ b/SelfServiceCommon/Massai/cpp/Trace/src/TraceConfig.cpp
@@ -19,6 +19,7 @@
 #include "TraceSrvConfig.h"
 #include "trc/tracedef.h"
 #include "boost/filesystem/path.hpp"
+#include "systools/mSysTime.h"
 #include <sstream>
 #include <stdlib.h>
 
@@ -129,7 +130,7 @@ namespace MASSAI
     }
     std::string TraceCommonConfig::getFilename(const std::string& sessionId)
     {
-      Timestamp timestamp= getTimestamp();
+      mSysTime::Timestamp timestamp= mSysTime::getTimestamp();
       TraceFormat& fmt= getTraceFormat();
       return fmt.filename(sessionId, m_processId, timestamp);
     }
@@ -188,7 +189,7 @@ namespace MASSAI
       }
       return result;
     }
-    fs::path TraceConfig::getBackupPath(const fs::path& base, const Timestamp& ts)
+    fs::path TraceConfig::getBackupPath(const fs::path& base, const mSysTime::Timestamp& ts)
     {
       fs::path result= base;
       try
diff --git a/SelfServiceCommon/Massai/cpp/Trace/src/TraceFormat.cpp b/SelfServiceCommon/Massai/cpp/Trace/src/TraceFormat.cpp
index 0862dbd9..c9ec1670 100644
--- a/SelfServiceCommon/Massai/cpp/Trace/src/TraceFormat.cpp
+++ b/SelfServiceCommon/Massai/cpp/Trace/src/TraceFormat.cpp
@@ -49,14 +49,14 @@ namespace MASSAI
     {}
     TraceFormat::~TraceFormat()
     {}
-    std::string TraceFormat::backupPath(const Timestamp& timestamp)
+    std::string TraceFormat::backupPath(const mSysTime::Timestamp& timestamp)
     {
       char buffer[100];
       sprintf(buffer, "%04d/%02d/%02d", timestamp.year, timestamp.month, timestamp.day);
       return buffer;
     }
     std::string TraceFormat::filename(const std::string& sessionId,
-      ProcessId processId, const Timestamp& timestamp)
+      ProcessId processId, const mSysTime::Timestamp& timestamp)
     {
       std::string result= sessionId;
       char buffer[100];
@@ -68,92 +68,6 @@ namespace MASSAI
       result += buffer;
       return result;
     }
-    void TraceFormat::head(std::ostream& out, ThreadId threadId, const Timestamp& timestamp,
-      long traceLevel, const std::string& topic, const std::string& file, long line,
-      const std::string& function)
-    {
-      std::string fileTruncated= truncate(file);
-      // date time threadid tracelevel/topic file line
-
-      // date
-      char buffer[100];
-      sprintf(buffer, "%02d.%02d.%04d\t%02d:%02d:%02d,%03d\t%02d\t",
-        timestamp.day, timestamp.month, timestamp.year,
-        timestamp.hour, timestamp.minute, timestamp.second,
-        timestamp.milliseconds,
-        threadId);
-      out << buffer;
-
-      // tracelevel/topic
-      if(traceLevel != -1)
-      {
-        out << std::right << std::setfill('0') << std::dec;
-        out << std::setw(1) << traceLevel;
-      }
-      else if(topic != "")
-      {
-        out << std::left << std::setfill(' ');
-        out << std::setw(8) << topic.c_str();
-      }
-      out << "\t";
-      // file
-      out << std::left << std::setfill(' ');
-      out << std::setw(20) << fileTruncated.c_str() << "\t";
-      // line
-      out << std::right << std::setfill('0') << std::dec;
-      out << "(" << std::setw(4) << line << ")\t";
-    }
-    void TraceFormat::text(std::ostream& out, ThreadId threadId, const Timestamp& timestamp,
-      long traceLevel, const std::string& topic, const std::string& file, long line,
-      const std::string& function, const std::string& data)
-    {
-      head(out, threadId, timestamp, traceLevel, topic, file, line, function);
-      out << data << std::endl;
-    }
-
-    // printf ist effizienter als ostream
-    void TraceFormat::dump(std::ostream& out, ThreadId threadId, const Timestamp& timestamp,
-      long traceLevel, const std::string& topic, const std::string& file, long line,
-      const std::string& function, const std::string& data)
-    {
-      head(out, threadId, timestamp, traceLevel, topic, file, line, function);
-      out << std::endl;
-      const char* pData= data.data();
-      const unsigned char* puData= reinterpret_cast<const unsigned char*>(pData);
-      long size= data.size();
-      out << std::uppercase;
-      for(long i = 0; i < size; i += 16)
-      {
-        char buffer[100];
-        char* it= buffer;
-        it+= sprintf(it, "D\t\t%05d\t%05X\t", i, i);
-        long j= 0;
-        for(j = 0; j < 16 && (i+j) < size; j++)
-        {
-          if(j == 8)
-          {
-            it+= sprintf(it, "- "); // delimiter
-          }
-          it+= sprintf(it, "%02X ", static_cast<int>(puData[i+j]));
-        }
-        while(j < 16) // less than 16 character
-        {
-          if(j == 8)
-          {
-          it+= sprintf(it, "  "); // add two spaces for delimiter
-          }
-          it+= sprintf(it, "   "); // add three spaces for every character
-          j++;
-        }
-        it+= sprintf(it, "\t\t");
-        for(j = 0; j < 16 && (i+j) < size; j++)
-        {
-          *it++= ((pData[i+j] >= ' ') ? pData[i+j] : '.');
-        }
-        *it++= 0;
-        out << buffer << std::endl;
-      }
-    }
     TraceFormat& getTraceFormat()
     {
       if(pFormat == 0)
@@ -162,113 +76,5 @@ namespace MASSAI
       }
       return *pFormat;
     }
-/*
-
-    void TraceFormat::backupPath(std::ostream& out, const Timestamp& timestamp)
-    {
-      out << std::right << std::setfill('0') << std::dec;
-      out << std::setw(4) << timestamp.year << "/";
-      out << std::setw(2) << timestamp.month << "/";
-      out << std::setw(2) << timestamp.day;
-    }
-    void TraceFormat::filename(std::ostream& out, const std::string& sessionId,
-      ProcessId processId, const Timestamp& timestamp)
-    {
-      out << sessionId << "_";
-      out << std::right << std::setfill('0') << std::dec;
-      out << std::setw(4) << processId << "_";
-      // date
-      out << std::setw(4) << timestamp.year;
-      out << std::setw(2) << timestamp.month;
-      out << std::setw(2) << timestamp.day << "_";
-      // time
-      out << std::setw(2) << timestamp.hour;
-      out << std::setw(2) << timestamp.minute;
-      out << std::setw(2) << timestamp.second << "_";
-      out << std::setw(3) << timestamp.milliseconds;
-      out << ".trc";
-    }
-    void TraceFormat::head(std::ostream& out, ThreadId threadId, const Timestamp& timestamp,
-      long traceLevel, const std::string& topic, const std::string& file, long line,
-      const std::string& function)
-    {
-      std::string file= truncate(file);
-      // date time threadid tracelevel/topic file line
-
-      // date
-      out << std::right << std::setfill('0') << std::dec;
-      out << std::setw(2) << timestamp.day << ".";
-      out << std::setw(2) << timestamp.month << ".";
-      out << std::setw(4) << timestamp.year << "\t";
-      // time
-      out << std::setw(2) << timestamp.hour << ":";
-      out << std::setw(2) << timestamp.minute << ":";
-      out << std::setw(2) << timestamp.second << ",";
-      out << std::setw(3) << timestamp.milliseconds << "\t";
-      // threadid
-      out << std::setw(4) << threadId << "\t";
-      // tracelevel/topic
-      if(traceLevel != -1)
-      {
-        out << std::right << std::setfill('0') << std::dec;
-        out << std::setw(1) << traceLevel;
-      }
-      else if(topic != 0)
-      {
-        out << std::left << std::setfill(' ');
-        out << std::setw(8) << topic;
-      }
-      out << "\t";
-      // file
-      out << std::left << std::setfill(' ');
-      out << std::setw(20) << file.c_str() << "\t";
-      // line
-      out << std::right << std::setfill('0') << std::dec;
-      out << "(" << std::setw(4) << line << ")\t";
-    }
-    void TraceFormat::dump(std::ostream& out, ThreadId threadId, const Timestamp& timestamp,
-      long traceLevel, const std::string& topic, const std::string& file, long line,
-      const std::string& function, const std::string& pData, long size)
-    {
-      head(out, threadId, timestamp, traceLevel, topic, file, line, function);
-      out << std::endl;
-      const unsigned char* puData= reinterpret_cast<const unsigned char*>(pData);
-      out << std::uppercase;
-      for(long i = 0; i < size; i += 16)
-      {
-        out << std::right << std::setfill('0');
-        out << "D\t\t";
-        out << std::dec << std::setw(5) << i;
-        out << "\t";
-        out << std::hex << std::setw(5) << i;
-        out << "\t";
-        long j= 0;
-        out << std::hex;
-        for(j = 0; j < 16 && (i+j) < size; j++)
-        {
-          if(j == 8)
-          {
-            out << "- "; // delimiter
-          }
-          out << std::setw(2) << static_cast<int>(puData[i+j]) << " ";
-        }
-        while(j < 16) // less than 16 character
-        {
-          if(j == 8)
-          {
-            out << "  "; // add two spaces for delimiter
-          }
-          out << "   "; // add three spaces for every character
-          j++;
-        }
-        out << "\t\t";
-        for(j = 0; j < 16 && (i+j) < size; j++)
-        {
-          out << ((pData[i+j] >= ' ') ? pData[i+j] : '.');
-        }
-        out << std::endl;
-      }
-    }
-*/
   }
 }
diff --git a/SelfServiceCommon/Massai/cpp/Trace/src/TraceProcessor.cpp b/SelfServiceCommon/Massai/cpp/Trace/src/TraceProcessor.cpp
index dbdb77c8..95d67ea4 100644
--- a/SelfServiceCommon/Massai/cpp/Trace/src/TraceProcessor.cpp
+++ b/SelfServiceCommon/Massai/cpp/Trace/src/TraceProcessor.cpp
@@ -11,13 +11,11 @@
 //  history:
 //---------------------------------------------------------------------------
 
-
 #pragma warning(disable:4786)
 
 #include "TraceProcessor.h"
 #include "TraceCmd.h"
 
-
 namespace MASSAI
 {
   namespace trace
diff --git a/SelfServiceCommon/Massai/cpp/Trace/src/TraceSession.cpp b/SelfServiceCommon/Massai/cpp/Trace/src/TraceSession.cpp
index 075275e2..5b642927 100644
--- a/SelfServiceCommon/Massai/cpp/Trace/src/TraceSession.cpp
+++ b/SelfServiceCommon/Massai/cpp/Trace/src/TraceSession.cpp
@@ -11,7 +11,6 @@
 //  history:
 //---------------------------------------------------------------------------
 
-
 #pragma warning(disable:4786)
 
 #include "TraceSession.h"
@@ -29,11 +28,8 @@
 
 namespace fs = boost::filesystem;
 
-
-
 namespace
 {
-
   int normalize_ch(int c)
   {
     switch(c)
@@ -70,17 +66,37 @@ namespace
     std::transform(result.begin(), result.end(), result.begin(), normalize_ch);
     return result;
   }
+  const char* TOPIC= "TRACE";
 }
 
 namespace MASSAI
 {
   namespace trace
   {
+    TraceCallback::TraceCallback():
+      m_pOut(0)
+    {}
+    TraceCallback::~TraceCallback()
+    {}
+    void TraceCallback::traceLine(const std::string& head, const std::string& data) const
+    {
+      if(m_pOut != 0)
+      {
+        (*m_pOut) << head << data << std::endl;
+      }
+    }
+    void TraceCallback::setOut(std::ostream* pOut)
+    {
+      m_pOut= pOut;
+    }
+
     TraceSession::TraceSession(TraceCommonConfig& config):
       m_config(config),
       m_pOut(),
       m_path(),
-      m_filename()
+      m_filename(),
+      m_callback(),
+      m_format(m_callback)
     {}
     TraceSession::~TraceSession()
     {}
@@ -101,13 +117,15 @@ namespace MASSAI
       {
         MASSAI::trace::tracetrace(MinorWarning_HERE, "open file: (%.1000s)", ex.what());
       }
-      getTraceFormat().text(getOut(), getThreadId(), getTimestamp(), -1, "TRACE", TOPIC_HERE, "init");
+      m_format.text(-1, TOPIC, TOPIC_HERE, "--- Trace Init ---");
     }
     void TraceSession::close()
     {
       try
       {
+        m_format.text(-1, TOPIC, TOPIC_HERE, "--- Trace Close ---");
         m_pOut= std::auto_ptr<std::ostream>();
+        m_callback.setOut(m_pOut.get());
       }
       catch(std::exception& ex)
       {
@@ -118,23 +136,24 @@ namespace MASSAI
     {
       try
       {
-        fs::path backup= m_config.getBackupPath(m_path, getTimestamp());
+        fs::path backup= m_config.getBackupPath(m_path, mSysTime::getTimestamp());
         fs::create_directories(backup);
         fs::path file= backup / m_filename;
         m_pOut= std::auto_ptr<std::ostream>(new std::ofstream(file.native_file_string().c_str(),
           std::ios_base::out | std::ios_base::app));
+        m_callback.setOut(m_pOut.get());
       }
       catch(std::exception& ex)
       {
         MASSAI::trace::tracetrace(MinorWarning_HERE, "open file: (%.1000s)", ex.what());
       }
     }
-
     void TraceSession::move()
     {
       try
       {
         m_pOut= std::auto_ptr<std::ostream>();
+        m_callback.setOut(m_pOut.get());
         fs::path newPath= m_config.getFullPath();
         fs::create_directories(newPath);
         fs::path source= m_path / m_filename;
@@ -225,7 +244,6 @@ namespace MASSAI
       std::ostream* pOut= m_pOut.get();
       if(pOut != 0)
       {
-        // pOut->seekp(-1, std::ios::end);
         if(pOut->tellp() > m_config.getFileSizeLimit())
         {
           close();
@@ -256,16 +274,12 @@ namespace MASSAI
     }
     void TraceSession::text(const TraceCmd& cmd)
     {
-      std::ostream& out= getOut();
-      TraceFormat& fmt= getTraceFormat();
-      fmt.text(out, cmd.threadIndex, cmd.timestamp, cmd.traceLevel,
+      m_format.text(cmd.threadIndex, cmd.timestamp, cmd.traceLevel,
         cmd.topic, cmd.file, cmd.line, cmd.function, cmd.data);
     }
     void TraceSession::dump(const TraceCmd& cmd)
     {
-      std::ostream& out= getOut();
-      TraceFormat& fmt= getTraceFormat();
-      fmt.dump(out, cmd.threadIndex, cmd.timestamp, cmd.traceLevel,
+      m_format.dump(cmd.threadIndex, cmd.timestamp, cmd.traceLevel,
         cmd.topic, cmd.file, cmd.line, cmd.function, cmd.data);
     }
     void TraceSession::cooked(const TraceCmd& cmd)
@@ -275,20 +289,16 @@ namespace MASSAI
     }
     void TraceSession::newFile(const TraceCmd& cmd)
     {
-      std::ostream& out= getOut();
-      TraceFormat& fmt= getTraceFormat();
-      fmt.text(out, cmd.threadIndex, cmd.timestamp, cmd.traceLevel,
+      m_format.text(cmd.threadIndex, cmd.timestamp, cmd.traceLevel,
         cmd.topic, cmd.file, cmd.line, cmd.function, "start new file");
       close();
       open();
     }
     void TraceSession::move(const TraceCmd& cmd)
     {
-      std::ostream& out= getOut();
-      TraceFormat& fmt= getTraceFormat();
       std::string trace= "moveFile: ";
       trace += cmd.data;
-      fmt.text(out, cmd.threadIndex, cmd.timestamp, -1, "TRACE", cmd.file,
+      m_format.text(cmd.threadIndex, cmd.timestamp, -1, TOPIC, cmd.file,
         cmd.line, cmd.function, trace);
       try
       {
@@ -310,11 +320,9 @@ namespace MASSAI
     }
     void TraceSession::changeDirectory(const TraceCmd& cmd)
     {
-      std::ostream& out= getOut();
-      TraceFormat& fmt= getTraceFormat();
       std::string trace= "TraceDirectory changed: ";
       trace += cmd.data;
-      fmt.text(out, cmd.threadIndex, cmd.timestamp, -1, "TRACE", cmd.file,
+      m_format.text(cmd.threadIndex, cmd.timestamp, -1, TOPIC, cmd.file,
         cmd.line, cmd.function, trace);
       try
       {
diff --git a/SelfServiceCommon/Massai/cpp/Trace/src/TraceSystem.cpp b/SelfServiceCommon/Massai/cpp/Trace/src/TraceSystem.cpp
index 07df0940..039042bf 100644
--- a/SelfServiceCommon/Massai/cpp/Trace/src/TraceSystem.cpp
+++ b/SelfServiceCommon/Massai/cpp/Trace/src/TraceSystem.cpp
@@ -53,21 +53,6 @@ namespace MASSAI
     {
       return GetCurrentThreadId();
     }
-    Timestamp getTimestamp()
-    {
-      SYSTEMTIME systemtime;
-      GetLocalTime(&systemtime);
-      Timestamp result;
-      result.year= systemtime.wYear;
-      result.month= systemtime.wMonth;
-      result.dayOfWeek= systemtime.wDayOfWeek;
-      result.day= systemtime.wDay;
-      result.hour= systemtime.wHour;
-      result.minute= systemtime.wMinute;
-      result.second= systemtime.wSecond;
-      result.milliseconds= systemtime.wMilliseconds;
-      return result;
-    }
     fs::path getBasePath()
     {
       fs::path result;
diff --git a/SelfServiceCommon/Massai/cpp/Trace/src/TraceTrace.cpp b/SelfServiceCommon/Massai/cpp/Trace/src/TraceTrace.cpp
index e465993e..183c4bcf 100644
--- a/SelfServiceCommon/Massai/cpp/Trace/src/TraceTrace.cpp
+++ b/SelfServiceCommon/Massai/cpp/Trace/src/TraceTrace.cpp
@@ -11,14 +11,30 @@
 //  history:
 //---------------------------------------------------------------------------
 
-
 #include "TraceTrace.h"
 #include "TraceFormat.h"
 #include "TraceSystem.h"
+#include "Tools/TraceFormatCB.h"
 
 #include <sstream>
 #include <stdarg.h>
 
+using namespace MASSAI::trace;
+
+namespace
+{
+  class SysTraceCB: public Callback
+  {
+    public:
+      virtual void traceLine(const std::string& head, const std::string& data) const
+      {
+        sysTrace((head + data).c_str());
+      }
+  };
+  SysTraceCB sysTraceCB;
+  MASSAI::trace::TraceFormatCB sysFormat(sysTraceCB);
+}
+
 namespace MASSAI
 {
   namespace trace
@@ -26,13 +42,7 @@ namespace MASSAI
     void tracetraceText(long level, const char* pszFile, long line,
       const char* pszFunction, const char* pszData)
     {
-      Timestamp timestamp= getTimestamp();
-      ThreadId threadId= getThreadId();
-      std::ostringstream out;
-      TraceFormat& format= getTraceFormat();
-      format.text(out, threadId, timestamp, level, "", pszFile?pszFile:"",
-        line, pszFunction?pszFunction:"", pszData);
-      sysTrace(out.str());
+      sysFormat.text(level, "", pszFile, line, pszFunction, pszData);
     }
     void tracetrace(long level, const char* pszFile, long line,
       const char* pszFunction, const char* pszFormat, ...)
@@ -45,6 +55,5 @@ namespace MASSAI
       va_end(arg_ptr);
       tracetraceText(level, pszFile, line, pszFunction, buffer);
     }
-
   }
 }
diff --git a/SelfServiceCommon/Massai/idl/Massai/appcontrol.idl b/SelfServiceCommon/Massai/idl/Massai/appcontrol.idl
index de9a4d98..7a162d57 100644
--- a/SelfServiceCommon/Massai/idl/Massai/appcontrol.idl
+++ b/SelfServiceCommon/Massai/idl/Massai/appcontrol.idl
@@ -40,28 +40,15 @@ module appControl
       RES_DEFAULT
     };
 
-    /** Data type for screen messages. */
-
-    typedef resolutions screenData;
-
     /** Defines the application data that is passed by the ApplicationManager to this device
      *  @note The cmdLine must be given as EXECUTABLE.EXE params: param1 param2 ...
      */
 
     struct application
     {
-      string appName;   /**< The application name as internally handeled by the ApplicationManager*/
-      string cmdLine;   /**< The commandline for the application to start within the newly created dektop */
-    };
-
-    struct avParams
-    {
-      string appID;
-      long   avID;
-      long   x;
-      long   y;
-      long   cx;
-      long   cy;
+      string appName;     /**< The application name as internally handeled by the ApplicationManager*/
+      string cmdLine;     /**< The commandline for the application to start within the newly created dektop */
+      long switchTimeout; /**< timeout in ms; wait time before switching back to main, when process is started */
     };
 
     /** Commands accepted by this device */
@@ -74,23 +61,9 @@ module appControl
       CMD_KILLALL,        /**< terminates all applications and closes the associated desktops */
       CMD_SWITCHMAIN,     /**< Switches to the main desktop */
       CMD_SHOW,           /**< Switches to a specific desktop, but doesn't activate it (debug mode)*/
-      CMD_SET_RESOLUTION, /**< Set a screen resolution */
-
-      CMD_AV_SETUP,
-      CMD_AV_PLAY,
-      CMD_AV_LOOP,
-      CMD_AV_STOP,
-      CMD_AV_REWIND,
-      CMD_AV_VOLUME,
-      CMD_AV_HIDE,
-      CMD_AV_SHOW
+      CMD_SET_RESOLUTION  /**< Set a screen resolution */
     };
 
-    /** Data type for desktop name list. */
-
-    typedef string name;
-    typedef sequence<name> desktopNameList;
-
     /** All device components inherit from the generic DeviceComponents interface */
 
     interface Handler : DeviceComponents::Generic
@@ -98,10 +71,6 @@ module appControl
       /** returns the current screen resolution */
 
       resolutions currentResolution();
-
-      /** resturn the list of current used desktops */
-
-      desktopNameList currentDesktops();
     };
 };
 
-- 
2.41.0.windows.1

