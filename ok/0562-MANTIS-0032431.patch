From 4946e3954700991f8a4da7ec9fe33c44190bf439 Mon Sep 17 00:00:00 2001
From: motten <motten@90b65887-3827-0410-9a23-83215b262276>
Date: Mon, 19 Jan 2015 12:43:37 +0000
Subject: [PATCH 0562/1000] MANTIS 0032431 -correct start of mStarter -right
 configure for TRACE

git-svn-id: svn://localhost/SelfServiceCommon/trunk@812 90b65887-3827-0410-9a23-83215b262276
---
 .../Massai/cpp/mControl/inc/mControl_config.h |  67 +--
 .../cpp/mControl/inc/mControl_process.h       |   3 +-
 .../cpp/mControl/inc/mControl_servant.h       |  17 +-
 .../Massai/cpp/mControl/inc/mControl_tools.h  |  14 +-
 .../Massai/cpp/mControl/inc/mControl_worker.h |  14 +-
 .../Massai/cpp/mControl/inc/mcontrol_def.h    |   1 +
 .../cpp/mControl/src/mControl_config.cpp      |  49 +-
 .../cpp/mControl/src/mControl_dialog.cpp      |   2 +-
 .../Massai/cpp/mControl/src/mControl_main.cpp | 510 +++++++++---------
 .../cpp/mControl/src/mControl_process.cpp     |   4 -
 .../cpp/mControl/src/mControl_reboot.cpp      |  16 +-
 .../cpp/mControl/src/mControl_scheduler.cpp   |  20 +-
 .../cpp/mControl/src/mControl_servant.cpp     | 367 ++++++-------
 .../cpp/mControl/src/mControl_tools.cpp       |  65 +--
 .../cpp/mControl/src/mControl_worker.cpp      | 238 ++++----
 15 files changed, 668 insertions(+), 719 deletions(-)

diff --git a/SelfServiceCommon/Massai/cpp/mControl/inc/mControl_config.h b/SelfServiceCommon/Massai/cpp/mControl/inc/mControl_config.h
index e2cbecc9..a471d86b 100644
--- a/SelfServiceCommon/Massai/cpp/mControl/inc/mControl_config.h
+++ b/SelfServiceCommon/Massai/cpp/mControl/inc/mControl_config.h
@@ -30,6 +30,7 @@
 #include "systools/mEventSem.hpp"
 #include "massaidll\BASE_OS.h"
 #include "trc/trace.h"
+#include "tools/TraceClient.h"
 
 //Poco includes
 #include "poco\ThreadPool.h"
@@ -45,27 +46,27 @@ namespace mControl
     class GlobalConfig
     {
     private:
-        bool                    m_serverMode;
-        bool                    m_noLog;
-        bool                    m_noSNMP;
-        bool                    m_portableMCC;
-        bool                    m_isRunningAsUserShell;
-        bool                    m_started;
-        bool                    m_terminate;
-
-        long                    m_allProcesses;
-        long                    m_currentProcesses;
-        long                    m_currLoadPercent;
+        bool                            m_serverMode;
+        bool                            m_noLog;
+        bool                            m_noSNMP;
+        bool                            m_portableMCC;
+        bool                            m_isRunningAsUserShell;
+        bool                            m_started;
+        bool                            m_terminate;
+
+        long                            m_allProcesses;
+        long                            m_currentProcesses;
+        long                            m_currLoadPercent;
         
-        Poco::ThreadPool        m_threadPool;
+        Poco::ThreadPool                m_threadPool;
 
-        alert*                  m_alert;
+        alert*                          m_alert;
 
-        CEnvSubst               m_EnvS;
+        CEnvSubst                       m_EnvS;
 
-        Poco::NotificationQueue m_queue;
-        Worker*                 m_worker;
-        std::list<long>         m_progressProcessList;
+        Poco::NotificationQueue         m_queue;
+        Worker*                         m_worker;
+        std::list<long>                 m_progressProcessList;
 
 
     public:
@@ -84,22 +85,22 @@ namespace mControl
         /**
         * Attribut getter Methods
         */
-        bool                        serverMode(){ return m_serverMode; }
-        bool                        noLogActive(){ return m_noLog; }
-        bool                        noSNMPActive(){ return m_noSNMP; }
-        bool                        noPortableMCCActive(){ return m_portableMCC; }
-        bool                        isRunningAsUserShell(){ return m_isRunningAsUserShell; }
-        bool                        isStarted(){ return m_started; }
-        bool                        isTerminated(){ return m_terminate; }
-        long                        getCurrentProcesses(){ return m_currentProcesses; }
-        long                        getCurrLoadPercent(){ return m_currLoadPercent; }
-        long                        getAllProcesses(){ return m_allProcesses; }
-        alert*                      getAlert(){ return m_alert; }
-        Poco::ThreadPool&           getThreadPool(){ return m_threadPool; }
-        CEnvSubst&                  getEnvS(){ return m_EnvS; }
-        Poco::NotificationQueue&    getQueue(){ return m_queue; }
-        Worker*                     getWorker(){ return m_worker; }
-        std::list<long>&            getProgressProcessList(){ return m_progressProcessList; }
+        bool                            serverMode(){ return m_serverMode; }
+        bool                            noLogActive(){ return m_noLog; }
+        bool                            noSNMPActive(){ return m_noSNMP; }
+        bool                            noPortableMCCActive(){ return m_portableMCC; }
+        bool                            isRunningAsUserShell(){ return m_isRunningAsUserShell; }
+        bool                            isStarted(){ return m_started; }
+        bool                            isTerminated(){ return m_terminate; }
+        long                            getCurrentProcesses(){ return m_currentProcesses; }
+        long                            getCurrLoadPercent(){ return m_currLoadPercent; }
+        long                            getAllProcesses(){ return m_allProcesses; }
+        alert*                          getAlert(){ return m_alert; }
+        Poco::ThreadPool&               getThreadPool(){ return m_threadPool; }
+        CEnvSubst&                      getEnvS(){ return m_EnvS; }
+        Poco::NotificationQueue&        getQueue(){ return m_queue; }
+        Worker*                         getWorker(){ return m_worker; }
+        std::list<long>&                getProgressProcessList(){ return m_progressProcessList; }
 
     
         /**
diff --git a/SelfServiceCommon/Massai/cpp/mControl/inc/mControl_process.h b/SelfServiceCommon/Massai/cpp/mControl/inc/mControl_process.h
index 675e4f93..d724dcbf 100644
--- a/SelfServiceCommon/Massai/cpp/mControl/inc/mControl_process.h
+++ b/SelfServiceCommon/Massai/cpp/mControl/inc/mControl_process.h
@@ -35,7 +35,7 @@ namespace mControl
     private:
        std::string const                m_appName;
        std::string const                m_streamName;
-       
+
 
     public:
         /**
@@ -45,7 +45,6 @@ namespace mControl
         **/
         ProcessCallback( std::string AppName, std::string sName);
 
-        ~ProcessCallback();
 
         /**
         *   Traces the given Line
diff --git a/SelfServiceCommon/Massai/cpp/mControl/inc/mControl_servant.h b/SelfServiceCommon/Massai/cpp/mControl/inc/mControl_servant.h
index ef635651..89b07895 100644
--- a/SelfServiceCommon/Massai/cpp/mControl/inc/mControl_servant.h
+++ b/SelfServiceCommon/Massai/cpp/mControl/inc/mControl_servant.h
@@ -13,9 +13,12 @@
 #ifndef MCONTROL_SERVANT_H
 #define MCONTROL_SERVANT_H
 
+//Project includes
+#include "..\inc\mControl_logging.h"
+
 //MATERNA includes
 #include "massaiCorba/orbIncDefs.h"
-#include "systools\mSysProcessTree.h"
+#include "systools/mSysProcessTree.h"
 
 #include "controller.h"
 #include "controller_skel.h"
@@ -63,10 +66,10 @@ namespace mControl
         std::string getRebootFileName();
 
 
-        //---------------------------------------------------------------------------
-        //  controller::kioskControl interface Methods
-        //
-        //  definded in controller.idl
+    //---------------------------------------------------------------------------
+    //  controller::kioskControl interface Methods
+    //
+    //  definded in controller.idl
 
         /**
         *   Get a list of all current existings processes.
@@ -203,8 +206,8 @@ namespace mControl
         */
         CORBA::Long setSystemTime(const char *dateTime);
          
-        // END interface Methods
-        //----------------------------------------------------------------------------
+    // END interface Methods
+    //----------------------------------------------------------------------------
     };
 }
 #endif
diff --git a/SelfServiceCommon/Massai/cpp/mControl/inc/mControl_tools.h b/SelfServiceCommon/Massai/cpp/mControl/inc/mControl_tools.h
index 6d825434..a7c41f5b 100644
--- a/SelfServiceCommon/Massai/cpp/mControl/inc/mControl_tools.h
+++ b/SelfServiceCommon/Massai/cpp/mControl/inc/mControl_tools.h
@@ -62,13 +62,13 @@ namespace mControl
         /**
         *   gets a bool and returns "TRUE" or "FALSE"
         */
-        static char const * boolToChar( bool in );
+        static std::string boolToString( bool in );
 
 
         /**
         *   gets a bool and returns "YES" or "NO"
         */
-        static char const * noYes(bool f);
+        static std::string noYes(bool f);
 
 
         /**
@@ -124,18 +124,10 @@ namespace mControl
         static long getDayOfWeekAsNumber(std::string sDay);
         
 
-        /**
-        *   Traces the current working-directory  
-        *
-        *   @return: successfull execution
-        */
-        static int traceCurrentDir();
-
-
         /**
         *   waits for a service to be started
         */
-        static long waitForService( char const * serviceName, long lTimeout);
+        static long waitForService( std::string serviceName, long lTimeout);
 
         
         /**
diff --git a/SelfServiceCommon/Massai/cpp/mControl/inc/mControl_worker.h b/SelfServiceCommon/Massai/cpp/mControl/inc/mControl_worker.h
index 533c5327..70dab140 100644
--- a/SelfServiceCommon/Massai/cpp/mControl/inc/mControl_worker.h
+++ b/SelfServiceCommon/Massai/cpp/mControl/inc/mControl_worker.h
@@ -43,6 +43,8 @@ namespace mControl
 
         mSysProcess::child *        m_processStarter;
 
+        HANDLE                      m_stop_sem_handle;
+
 
     public:
         /**
@@ -81,19 +83,19 @@ namespace mControl
         *   replacement for the standard system() command,
         *   this one doesn't pop up any windows
         */
-        long mSystem( char const * cmd, char const * purpose );
+        long startProcess( std::string cmd );
 
 
         /**
         *   Starts mUpdate.exe & waits for it's termination
         */
-        long startUpdate();
+        long startMUpdate();
 
 
         /**
         *   create a public semaphor and start all progs via mStater.exe
         */
-        long startAll();
+        long startMStarter();
 
 
         /**
@@ -131,6 +133,12 @@ namespace mControl
         *   at the first call watch for loggingservice semaphore
         */
         void waitInitialForLoggingService();
+
+
+        /**
+        *
+        */
+        void signalStop();
     };
 }
 
diff --git a/SelfServiceCommon/Massai/cpp/mControl/inc/mcontrol_def.h b/SelfServiceCommon/Massai/cpp/mControl/inc/mcontrol_def.h
index e14f59f7..3f8f2abe 100644
--- a/SelfServiceCommon/Massai/cpp/mControl/inc/mcontrol_def.h
+++ b/SelfServiceCommon/Massai/cpp/mControl/inc/mcontrol_def.h
@@ -53,6 +53,7 @@
     #define WM_MASSAISTART_SCHEDULER  (WM_USER + 7)
 
     #define WM_MCONTROL_PROGRESS      (WM_USER + 10)
+    #define WM_MCONTROL_SHUTDOWN      (WM_USER + 11)
     #define WM_START_DELAY_TIMER      (WM_USER + 101)
     
     //Other msg's
diff --git a/SelfServiceCommon/Massai/cpp/mControl/src/mControl_config.cpp b/SelfServiceCommon/Massai/cpp/mControl/src/mControl_config.cpp
index 8b9b9425..2c669172 100644
--- a/SelfServiceCommon/Massai/cpp/mControl/src/mControl_config.cpp
+++ b/SelfServiceCommon/Massai/cpp/mControl/src/mControl_config.cpp
@@ -63,7 +63,7 @@ namespace mControl
 
     void GlobalConfig::setTerminated(bool ter)
     {
-        TRACE(HERE,"setTerminated[ %s ]", Tools::boolToChar(ter));
+        TRACE(HERE,"setTerminated[ %s ]", Tools::boolToString(ter).c_str());
         m_terminate = ter; 
     }
 
@@ -118,8 +118,6 @@ namespace mControl
     {
         DWORD myStyle = WS_POPUP;
 
-        TRACE(HERE,"check serverMode: %d ", this->getConfig().serverMode() );
-
         if(! (this->getConfig().serverMode()) )
         {
             myStyle |= WS_EX_TOPMOST;
@@ -238,7 +236,7 @@ namespace mControl
         }
         if(!this->m_hbmMain)
         {
-            TRACE(HERE,"ERROR initializing hbmMain");
+            TRACE(MajorError_HERE,"ERROR initializing hbmMain");
         }
                 
 
@@ -315,11 +313,11 @@ namespace mControl
         this->setHBitMapInfo1( Dialog::CreateBitmapObjectFromDibFile (hdc,".\\mcontrol_small_ds.bmp") );
         if(!this->getHBitMapInfo1())
         {
-            TRACE(HERE,".\\mcontrol_small_ds.bmp not found");
+            TRACE(MajorError_HERE,".\\mcontrol_small_ds.bmp not found");
         }
         if(!Dialog::CreateBitmapObjectFromDibFile (hdc,".\\mcontrol_small_ds.bmp"))
         {
-            TRACE(HERE,".\\mcontrol_small_ds.bmp creation failed");
+            TRACE(MajorError_HERE,".\\mcontrol_small_ds.bmp creation failed");
         }
 
         BITMAP tmpBmp;
@@ -360,7 +358,7 @@ namespace mControl
         this->setHBitMapInfo2( Dialog::CreateBitmapObjectFromDibFile (hdc,".\\mcontrol_small_su.bmp") );
         if(!this->getHBitMapInfo2())
         {
-            TRACE(HERE,".\\mcontrol_small_su.bmp not found");
+            TRACE(MajorError_HERE,".\\mcontrol_small_su.bmp not found");
         }
 
         BITMAP tmpBmp1;
@@ -448,7 +446,7 @@ namespace mControl
 
                 if (!InitCommonControlsEx(&iccex))
                 {
-                    TRACE(HERE,"Error initializing CommonControls ");
+                    TRACE(MajorError_HERE,"Error initializing CommonControls ");
                 }
                 
                 /**
@@ -534,7 +532,7 @@ namespace mControl
                     worker->execSysCmdsShutdown();
                 }
                 else
-                    TRACE(HERE,"ERROR: no worker available");
+                    TRACE(MajorError_HERE,"ERROR: no worker available");
                 
 
                 if(m_globalConfig.getAlert()) 
@@ -580,9 +578,38 @@ namespace mControl
                 {
                     m_globalConfig.setAllProcesses( wParam );
                 }
-                m_globalConfig.setCurrentProcesses( lParam );
+                if(lParam)
+                {
+                    m_globalConfig.setCurrentProcesses( lParam );
+                }
+                
+                if(m_globalConfig.getAllProcesses())
+                {
+                    m_globalConfig.setCurrLoadPercent( (long)( (float)m_globalConfig.getCurrentProcesses()/(float)m_globalConfig.getAllProcesses() ) *100);
+                    
+                    SendMessage(m_hWndLoad,PBM_SETPOS,m_globalConfig.getCurrLoadPercent(),0);
+                    
+                    UpdateWindow(m_hWndLoad);
+                    
+                    if(this->m_globalConfig.serverMode() && lParam >= 0 && m_globalConfig.getCurrLoadPercent() >= 100)
+                        ShowWindow(hWnd,SW_MINIMIZE);
+                }
+            }
+            break;
+
+        case WM_MCONTROL_SHUTDOWN:
+            {
+                TRACE(HERE,"WM_MCONTROL_SHUTDOWN");
+                
+                if(wParam)
+                {
+                    m_globalConfig.setAllProcesses( wParam );
+                }
+                if(lParam)
+                {
+                    m_globalConfig.setCurrentProcesses( lParam );
+                }
                 
-                TRACE(HERE,"Processbar: all = %d, current = %d", m_globalConfig.getAllProcesses(), m_globalConfig.getCurrentProcesses() );
                 if(m_globalConfig.getAllProcesses())
                 {
                     m_globalConfig.setCurrLoadPercent( (long)( (float)m_globalConfig.getCurrentProcesses()/(float)m_globalConfig.getAllProcesses() ) *100);
diff --git a/SelfServiceCommon/Massai/cpp/mControl/src/mControl_dialog.cpp b/SelfServiceCommon/Massai/cpp/mControl/src/mControl_dialog.cpp
index 89af7cb6..ba17ab7d 100644
--- a/SelfServiceCommon/Massai/cpp/mControl/src/mControl_dialog.cpp
+++ b/SelfServiceCommon/Massai/cpp/mControl/src/mControl_dialog.cpp
@@ -124,7 +124,7 @@ namespace mControl
 
         if(!pBmpFileHeader)
         {
-            TRACE(HERE,"pBmpFileHeader is NULL");
+            TRACE(MinorError_HERE,"pBmpFileHeader is NULL");
             CloseHandle (hFile);
             return(NULL);
         }
diff --git a/SelfServiceCommon/Massai/cpp/mControl/src/mControl_main.cpp b/SelfServiceCommon/Massai/cpp/mControl/src/mControl_main.cpp
index 50cffcd1..6fca9009 100644
--- a/SelfServiceCommon/Massai/cpp/mControl/src/mControl_main.cpp
+++ b/SelfServiceCommon/Massai/cpp/mControl/src/mControl_main.cpp
@@ -31,6 +31,7 @@
 #include "trc/trace.h"
 
 #include "systools/matDaemon.h"
+#include "systools/mSysProcessTerminate.h"
 
 //Poco includes
 #include "Poco/TaskManager.h"
@@ -42,11 +43,16 @@ using namespace std;
 using Poco::Runnable;
 using Poco::AutoPtr;
 using Poco::NotificationQueue;
+using MASSAI::trace::TraceClient;
+using Materna::MSSD::eventSemaphore;
+using Materna::MSSD::eventSemaphore_Exception;
+
 
 /*TODO:
 -check all path variables for MAX_PATH
 -check all TRACEs
 -check TraceClient
+-main in teile kappseln
 */
 
 
@@ -55,54 +61,39 @@ HINSTANCE globalHInstance;
 GlobalConfig* globalConfig = new GlobalConfig();
 
 
+//*******************************************************************************************************
+//  global Method prototype's used to capsule mDaemon_main
+//
 
+/**
+*   Creates an global Event 'massaiController' to communicate with mStarter
+*/
+HANDLE createInGlobalNamespace();
 
 
-//---------------------------------------------------------------------------
-//
-//  function:   void exitHandler(int iSignal)
-//
-//  purpose:    signal handler
-//
-//  date:       21.08.2001, 15:43
-//
-//  author:     Materna Information & Communications (AGe)
-//
-//---------------------------------------------------------------------------
-void exitHandler(int iSignal)
-{
-    char szTmp[30];
+/**
+*   Checks and traces the parameter given by argScan.
+*/
+long traceArgsParameter(argScan& args);
 
-    TRACE(HERE,">> exitHandler");
-    switch(iSignal)
-    {
-    case SIGABRT:   strcpy(szTmp,"SIGABRT");  break;
-    case SIGBREAK:  strcpy(szTmp,"SIGBREAK"); break;
-    case SIGTERM:   strcpy(szTmp,"SIGTERM");  break;
-    case SIGINT:    strcpy(szTmp,"SIGINT");   break;
-
-    case SIGFPE:    strcpy(szTmp,"SIGFPE");   break;
-    case SIGSEGV:   strcpy(szTmp,"SIGSEGV");  break;
-    case SIGILL:    strcpy(szTmp,"SIGILL");   break;
-    }
-    printf("\nSIGNAL: %s\n\n",szTmp);
-    TRACE(HERE,"SIGNAL: %s",szTmp);
 
-    TRACE(HERE,"<< exitHandler");
-}
+/**
+*   set's the global variable globalConfig.
+*/
+void setGlobalConfigByArgs(argScan& args);
 
 
-//---------------------------------------------------------------------------
-//
-//  function:   int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPreInst, char *szCmdLine, int iCmdShow)
-//
-//  purpose:    Standard windows program entry
-//
-//  date:       19.08.2014
-//
-//  author:     Materna Information & Communications (MOt)
+
+//*******************************************************************************************************
+//  main Method's
 //
-//---------------------------------------------------------------------------
+
+
+/**
+*   Standard windows program entry
+*
+*   @param hInst:
+*/
 int WINAPI WinMain ( HINSTANCE hInst, HINSTANCE, char * cmdline, int )
 {
     openTrace("New_mControl");
@@ -131,7 +122,10 @@ int WINAPI WinMain ( HINSTANCE hInst, HINSTANCE, char * cmdline, int )
 }
 
 
-
+/**
+*   global main-Method
+*
+*/
 int mDaemon_main( int argc, char const * const * argv )
 {
     TRACE(HERE,"entering mDaemon_main...");
@@ -139,45 +133,33 @@ int mDaemon_main( int argc, char const * const * argv )
     /********************************
     *   create Dialog object and start to build the window
     */
-    argScan         args( argc, argv );
-   
-    long            rc = 0;
-    long            lWait = 60000;
-    long            lDelay = -1;
+    argScan         args        ( argc, argv );
+    
+    Dialog          mainDialog  (globalConfig->getQueue(), globalHInstance, *globalConfig);
 
-    bool            useGlobalNamespace = false;
+    Worker          worker      (globalConfig->getQueue(), *globalConfig, mainDialog);
 
-    HANDLE          isRunning;
+    long            rc                  = 0;
+    long            lWait               = 60000;
+    long            lDelay              = -1;
 
-    OSVERSIONINFO   version;
+    bool            useGlobalNamespace  = false;
 
-    std::string     userDir;
+    DWORD           myStyle             = WS_POPUP;
 
-    DWORD           myStyle = WS_POPUP;
+    HANDLE          isRunning;
 
-    Dialog          mainDialog  = Dialog(globalConfig->getQueue(), globalHInstance, *globalConfig);
+    std::string     userDir;
 
-    Worker          worker(globalConfig->getQueue(), *globalConfig, mainDialog);
-    globalConfig->setWorker(&worker); 
-    
+    eventSemaphore  terminate;
     
-    
-    //******************************************************************************************
-    //*  Signals for ctrl (// needed! otherwise a ctrl-break leeds to exit(0)!!!)
-    //******************************************************************************************
-    TRACE(HERE,"call signal-handler...");
-
-    //TODO: other signal hanlder. see mSysProcessTerminate.h and appControl_main.cpp for implementation
-    signal(SIGABRT, exitHandler);
-    signal(SIGBREAK,exitHandler);
-    signal(SIGTERM, exitHandler);
-    signal(SIGINT,  exitHandler);
-    signal(SIGSEGV, exitHandler);
-    signal(SIGILL,  exitHandler);
-    signal(SIGFPE,  exitHandler);
-
+    TraceClient     trc;
 
 
+    mSysProcessTerminate::setShutdownHook(mSysProcessTerminate::SHUTDOWN_LATE, &terminate, &trc);
+    
+    globalConfig->setWorker(&worker); 
+    
 
     //******************************************************************************************
     //*  init-delay
@@ -186,180 +168,32 @@ int mDaemon_main( int argc, char const * const * argv )
     mDaemon_indInitializing(60000);
 
 
-
     //******************************************************************************************
     //  try create within the global name space, so that this program also
     //  on terminal server services runs only once 08.01.2004 (AGe)
     //******************************************************************************************
-    TRACE(HERE,"try create within the global name space...");
-    version.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
-    if(GetVersionEx (&version))
-    {
-        useGlobalNamespace = 5 <= version.dwMajorVersion;
-    }
-
-    //TODO: weiterhin nutzen?
-    isRunning = CreateEventA(NULL,FALSE,TRUE,useGlobalNamespace?"Global\\massaiController":"massaiController");
-
-    if((GetLastError() == ERROR_ALREADY_EXISTS) || (isRunning == 0))
-    {
-        char szMsg[512];
-
-        sprintf(szMsg,"MASSAI is already active.\n\n"
-                    "You can't have more than one instance on one machine. (%d)", GetLastError());
-
-        MessageBox(NULL,TEXT(szMsg),TEXT(szClassName),MB_ICONERROR) ;
-
-        exit(-1);
-    }
-
-
+    isRunning = ::createInGlobalNamespace();
 
 
     //******************************************************************************************
     //  trace the args parameter
     //******************************************************************************************
-    lDelay = args.optionInteger( "DELAYBEFORESTART", -1 );
-    if( ( lDelay != -1 ) )
-    {
-        TRACE(HERE,"%s found option [delaybeforestart], delay = %d\n",Tools::timeStamp().c_str(),lDelay);
-    }
-
-    if( args.option( "ENABLEPORTABLEMCC" ) )
-    {
-        globalConfig->setPortableMCC(true);
-        TRACE(HERE,"%s found option [enableportablemcc], removable device check for mcc enabled\n",Tools::timeStamp().c_str());
-    }
-
-    lWait = args.optionInteger( "WAIT", -1 );
-    if( lWait != -1 )
-    {
-        TRACE(HERE,"%s found option [wait], to = %d\n",Tools::timeStamp().c_str(),lWait);
-    }
-    else
-    {
-        TRACE(HERE,"%s found option [wait], to = <infinite>\n",Tools::timeStamp().c_str());
-    }
-
-    char const * const szService = args.option( "SERVICE" );
-    if( szService)
-    {
-        TRACE(HERE,"%s found option [service], name = %s\n", Tools::timeStamp().c_str(),szService);
-
-        rc = Tools::waitForService(szService,lWait);
-    }
-
-    if( args.help() )
-    {
-        MessageBox
-        (
-            NULL,
-            TEXT
-            (
-                "USAGE:\tmControl "
-                "{ -help |\n\t\t-normal <params> |\n"
-                "\t\t-install [-param:\"<params>\"] |\n"
-                "\t\t-deinstall }\n\n"
-                "<params>: [-delaybeforestart:seconds]"
-                " [-wait[:timeout]]\n\t[-service:<servicename>]"
-                " [-server][-usershell]\n\t[-nolog] [-nosnmp]\n\n"
-                "-delaybeforestart\n\tSet delay in seconds to wait"
-                " before startup\n"
-                "-wait\tSet timeout in ms for initial waiting for"
-                " dependencies,\n\t- default is 60000\n"
-                "\t- wait forever, if no timeout is given\n"
-                "-service\tSet dependency\n"
-                "-server\tRun in server mode, default is kiosk mode\n"
-                "-usershell\tRun as windows user shell, default is not run as user shell\n"
-                "-enableportablemcc\n\tEnables the detection of"
-                " a mcc on removable devices\n"
-                "-nolog\tEvent logging disabled\n"
-                "-nosnmp\tFor event logging use logservice instead of"
-                " massaisnmp,\n\tdo not send start platform event"
-            ),
-            szClassName,
-            MB_ICONEXCLAMATION
-        );
-        exit( 0 );
-    }
-
-
-
-    if(rc != 0)
-    {
-        TRACE(HERE,"ERROR: Service <massaiConfig>not running...");
-
-        MessageBox
-        (
-            NULL,
-            TEXT
-            (
-                "ERROR: Service <massaiConfig> not running.\n\nPlease"
-                " start massai configuration- and trace services first."
-            ),
-            szClassName,
-            MB_ICONERROR
-        );
-        exit( -2 );
-    }
-
-    TRACE(HERE,"set Base environment variables...");
-    globalConfig->getEnvS().SetBaseEnvVars();
+    lDelay = ::traceArgsParameter(args);
 
 
     //******************************************************************************************
-    //  handle the args parameter
+    //  set Base environment variables
     //******************************************************************************************
+    TRACE(HERE,"set Base environment variables...");
+    globalConfig->getEnvS().SetBaseEnvVars();
+    TRACE(HERE,"set Base environment variables(), done.\n");
+    
+    
     try
     {
-        TRACE(HERE,"handle the args parameter...");
-
-        if( args.option( "SERVER" ) || mDaemon_isService() )
-            globalConfig->setServerMode(true);
+        ::setGlobalConfigByArgs(args);
         
 
-        if( args.option( "NOLOG" ) )
-            globalConfig->setNoLog(true);
-        
-
-        if( args.option( "NOSNMP" ) )
-            globalConfig->setNoSNMP(true);
-          
-
-        if(args.option("USERSHELL"))
-        {
-            globalConfig->setRunningAsUserShell(true);
-       
-        }
-
-        if(globalConfig->noLogActive())
-        {
-            // A noSNMP parameter is ignored.
-            TRACE
-            (
-                HERE,
-                "%s started (server mode = %s, as service = %s, noLOG = %s) ...",
-                szClassName,
-                Tools::boolToChar( globalConfig->serverMode() ),
-                Tools::boolToChar( mDaemon_isService() != 0 ),
-                Tools::boolToChar( globalConfig->noLogActive() )
-            );
-        }
-        else
-        {
-            TRACE
-            (
-                HERE,
-                "%s started with parameter: server mode =[%s], as service =[%s], noLOG =[%s] noNSMP = [%s], userShell =[%s] ...",
-                szClassName,
-                Tools::boolToChar( globalConfig->serverMode() ),
-                Tools::boolToChar( mDaemon_isService() != 0 ),
-                Tools::boolToChar( globalConfig->noLogActive() ),
-                Tools::boolToChar( globalConfig->noSNMPActive() ),
-                Tools::boolToChar( globalConfig->isRunningAsUserShell() )
-            );
-        }
-
         //TODO: auslagern
         TRACE(HERE,"FileVersion of '.DLL' Files") ;
         Tools::printInfoAboutFiles ("..\\dll\\*.dll") ;
@@ -368,13 +202,10 @@ int mDaemon_main( int argc, char const * const * argv )
 
         
         if((rc = Tools::setWorkingDir()) != 0)
-            TRACE(HERE,"Failed to set working directory, rc = %d",rc);
-        
+            TRACE(MajorError_HERE,"Failed to set working directory, rc = %d",rc);
 
-        //******************************************************************************************
-        //  initialize the main components and delay start
-        //******************************************************************************************
-        TRACE(HERE,"initialize the main components...");
+
+        TRACE(HERE,"----------------------------------------initialize and start the main components----------------------------------------");
 
         mainDialog.initWindow();
 
@@ -385,7 +216,7 @@ int mDaemon_main( int argc, char const * const * argv )
 
         mDaemon_indReady(0);
 
-        //start a Delay Timer, so that the touch interface is initiated without complications
+        //start a Delay Timer, to make certain that the touch interface is initiated without complications
         PostMessage(mainDialog.getWindowConfig().getHwnd(),WM_START_DELAY_TIMER, lDelay, 0);
 
         
@@ -399,12 +230,13 @@ int mDaemon_main( int argc, char const * const * argv )
         //******************************************************************************************
         //  initialize and starting servant, scheduler and rebooter 
         //******************************************************************************************      
+        //servant
         MControlServant servant(globalConfig->getQueue());
 
         corbaServantEx <MControlServant> corbaServant (1, servant, "massaiKioskControl", 19998);
 
 
-        //start rebooter
+        //rebooter
         KioskReboot     rebooter ( globalConfig->getQueue(), *globalConfig, &servant);     
         
         // but start only if not in server mode !!!
@@ -417,11 +249,11 @@ int mDaemon_main( int argc, char const * const * argv )
         if(Tools::loadHostsFile() == -99)
         {
             //Configuration not started
-            TRACE(HERE,"ERROR: Configuration not started");
+            TRACE(MajorError_HERE,"ERROR: Configuration not started");
             //return -1;
         }
 
-        //start scheduler
+        //scheduler
         Scheduler   scheduler(globalConfig->getQueue(), *globalConfig);
 
         globalConfig->getThreadPool().start( scheduler );
@@ -442,28 +274,34 @@ int mDaemon_main( int argc, char const * const * argv )
 
         //TODO: check if delay at shut-down is caused by this mehtod
         globalConfig->getThreadPool().stopAll();
+
+        //TODO: don't wait to infinite: terminate.wait();
+    }
+    catch(const Materna::MSSD::eventSemaphore_Exception&)
+    {
+        TRACE(MajorError_HERE, "open semaphore failed");
     }
     catch( std::exception & X )
     {
-        char const * se = X.what();
-        TRACE( HERE, "%s", se );
+        TRACE( MajorError_HERE, "%s", X.what() );
         SendMessage(mainDialog.getWindowConfig().getHwnd(),WM_CLOSE,0,0);   
     }
     catch( char * se )
     {
-        TRACE( HERE, "%s", se );
+        TRACE( MajorError_HERE, "%s", se );
         SendMessage(mainDialog.getWindowConfig().getHwnd(),WM_CLOSE,0,0);
     }
     catch(...)
     {
-        char const * se = "unknown exception";
-        TRACE( HERE, "%s", se );
+        std::string se = "unknown exception";
+        TRACE( MajorError_HERE, "%s", se.c_str() );
         SendMessage(mainDialog.getWindowConfig().getHwnd(),WM_CLOSE,0,0);
     }   
 
     TRACE(HERE,"%s terminated.", szClassName);
     CloseHandle(isRunning);
-
+    mSysProcessTerminate::resetShutdownHook();
+    closeTrace();
     return 0;
 }
 
@@ -520,4 +358,190 @@ char const * mDaemon_name()
 void mDaemon_stop()
 {
     SendMessage(globalConfig->getWorker()->getDialog().getWindowConfig().getHwnd(),WM_CLOSE,0,0);
+}
+
+
+//*******************************************************************************************************
+//   implementation of global prototypes
+//
+
+HANDLE createInGlobalNamespace()
+{
+    TRACE(HERE,"Try create within the global name space...");
+
+    OSVERSIONINFO   version;
+    bool            useGlobalNamespace = false;
+
+    version.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
+    if(GetVersionEx (&version))
+    {
+        useGlobalNamespace = 5 <= version.dwMajorVersion;
+    }
+
+
+    HANDLE isRunning = CreateEventA(NULL,FALSE,TRUE,useGlobalNamespace?"Global\\massaiController":"massaiController");
+
+    if((GetLastError() == ERROR_ALREADY_EXISTS) || (isRunning == 0))
+    {
+        std::stringstream sMsgStream("");
+        
+        sMsgStream << "MASSAI is already active.\n\nYou can't have more than one instance on one machine."
+                    << "ErrorCode [" << GetLastError() << "]";
+
+        MessageBox(NULL,TEXT(sMsgStream.str().c_str()),TEXT(szClassName),MB_ICONERROR) ;
+
+        exit(-1);
+    }
+
+    TRACE(HERE,"Try create within the global name space, done.");
+
+    return isRunning;
+}
+
+
+long traceArgsParameter(argScan& args)
+{
+    long lWait  = 0;
+    long lDelay = 0;
+    long rc     = 0;
+    
+    lDelay = args.optionInteger( "DELAYBEFORESTART", -1 );
+    if( ( lDelay != -1 ) )
+    {
+        TRACE(HERE,"%s found option [delaybeforestart], delay = %d\n",Tools::timeStamp().c_str(),lDelay);
+    }
+
+    if( args.option( "ENABLEPORTABLEMCC" ) )
+    {
+        globalConfig->setPortableMCC(true);
+        TRACE(HERE,"%s found option [enableportablemcc], removable device check for mcc enabled\n",Tools::timeStamp().c_str());
+    }
+
+    lWait = args.optionInteger( "WAIT", -1 );
+    if( lWait != -1 )
+    {
+        TRACE(HERE,"%s found option [wait], to = %d\n",Tools::timeStamp().c_str(),lWait);
+    }
+    else
+    {
+        TRACE(HERE,"%s found option [wait], to = <infinite>\n",Tools::timeStamp().c_str());
+    }
+
+    string sServiceName ( args.option( "SERVICE" ) );
+    if( sServiceName != "" )
+    {
+        TRACE(HERE,"%s found option [service], name = %s\n", Tools::timeStamp().c_str(),sServiceName.c_str());
+
+        rc = Tools::waitForService(sServiceName,lWait);
+    }
+
+    if( args.help() )
+    {
+        MessageBox
+        (
+            NULL,
+            TEXT
+            (
+                "USAGE:\tmControl "
+                "{ -help |\n\t\t-normal <params> |\n"
+                "\t\t-install [-param:\"<params>\"] |\n"
+                "\t\t-deinstall }\n\n"
+                "<params>: [-delaybeforestart:seconds]"
+                " [-wait[:timeout]]\n\t[-service:<servicename>]"
+                " [-server][-usershell]\n\t[-nolog] [-nosnmp]\n\n"
+                "-delaybeforestart\n\tSet delay in seconds to wait"
+                " before startup\n"
+                "-wait\tSet timeout in ms for initial waiting for"
+                " dependencies,\n\t- default is 60000\n"
+                "\t- wait forever, if no timeout is given\n"
+                "-service\tSet dependency\n"
+                "-server\tRun in server mode, default is kiosk mode\n"
+                "-usershell\tRun as windows user shell, default is not run as user shell\n"
+                "-enableportablemcc\n\tEnables the detection of"
+                " a mcc on removable devices\n"
+                "-nolog\tEvent logging disabled\n"
+                "-nosnmp\tFor event logging use logservice instead of"
+                " massaisnmp,\n\tdo not send start platform event"
+            ),
+            szClassName,
+            MB_ICONEXCLAMATION
+        );
+        exit( 0 );
+    }
+
+    if(rc != 0)
+    {
+        TRACE(HERE,"ERROR: Service <massaiConfig>not running...");
+
+        MessageBox
+        (
+            NULL,
+            TEXT
+            (
+                "ERROR: Service <massaiConfig> not running.\n\nPlease"
+                " start massai configuration- and trace services first."
+            ),
+            szClassName,
+            MB_ICONERROR
+        );
+        exit( -2 );
+    }
+
+    return lDelay;
+}
+
+
+void setGlobalConfigByArgs(argScan& args)
+{
+    TRACE(HERE,"Initialize global Config-Oject by args...");
+
+    long rc = 0;
+
+    if( args.option( "SERVER" ) || mDaemon_isService() )
+        globalConfig->setServerMode(true);
+        
+
+    if( args.option( "NOLOG" ) )
+        globalConfig->setNoLog(true);
+        
+
+    if( args.option( "NOSNMP" ) )
+        globalConfig->setNoSNMP(true);
+          
+
+    if(args.option("USERSHELL"))
+    {
+        globalConfig->setRunningAsUserShell(true);
+       
+    }
+
+    if(globalConfig->noLogActive())
+    {
+        // A noSNMP parameter is ignored.
+        TRACE
+        (
+            HERE,
+            "%s started (server mode = %s, as service = %s, noLOG = %s) ...",
+            szClassName,
+            Tools::boolToString( globalConfig->serverMode() ).c_str(),
+            Tools::boolToString( mDaemon_isService() != 0 ).c_str(),
+            Tools::boolToString( globalConfig->noLogActive() ).c_str()
+        );
+    }
+    else
+    {
+        TRACE
+        (
+            HERE,
+            "%s started with parameter: server mode =[%s], as service =[%s], noLOG =[%s] noNSMP = [%s], userShell =[%s] ...",
+            szClassName,
+            Tools::boolToString( globalConfig->serverMode() ).c_str(),
+            Tools::boolToString( mDaemon_isService() != 0 ).c_str(),
+            Tools::boolToString( globalConfig->noLogActive() ).c_str(),
+            Tools::boolToString( globalConfig->noSNMPActive() ).c_str(),
+            Tools::boolToString( globalConfig->isRunningAsUserShell() ).c_str()
+        );
+    }
+
+    TRACE(HERE,"Initialize global Config-Oject by args, done.\n");
 }
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/mControl/src/mControl_process.cpp b/SelfServiceCommon/Massai/cpp/mControl/src/mControl_process.cpp
index f62d747b..09c56a41 100644
--- a/SelfServiceCommon/Massai/cpp/mControl/src/mControl_process.cpp
+++ b/SelfServiceCommon/Massai/cpp/mControl/src/mControl_process.cpp
@@ -32,10 +32,6 @@ namespace mControl
     {
     }
 
-    ProcessCallback::~ProcessCallback()
-    {
-    }
-
 
     void ProcessCallback::lineOut( char const * Line ) const
     {           
diff --git a/SelfServiceCommon/Massai/cpp/mControl/src/mControl_reboot.cpp b/SelfServiceCommon/Massai/cpp/mControl/src/mControl_reboot.cpp
index 1990abbd..6d6318a2 100644
--- a/SelfServiceCommon/Massai/cpp/mControl/src/mControl_reboot.cpp
+++ b/SelfServiceCommon/Massai/cpp/mControl/src/mControl_reboot.cpp
@@ -49,7 +49,7 @@ namespace mControl
         }
         catch (nConfig::exception ce)
         {
-           TRACE(HERE,"Config Exception: config service not yet ready, started ??");
+           TRACE(MajorError_HERE,"Config Exception: config service not yet ready, started ??");
         }
     }
 
@@ -72,7 +72,7 @@ namespace mControl
         //wait for config service to be ready
         while( m_cfgRebootTime && !m_cfgRebootTime->get() )
         {
-            TRACE(HERE,"config service not yet ready, started ??");
+            TRACE(MajorError_HERE,"config service not yet ready, started ??");
 
             delete(m_cfgRebootTime);
 
@@ -123,12 +123,12 @@ namespace mControl
             }
             else
             {
-                TRACE(HERE,"ERROR: configuration of reboot-time is in wrong format");
+                TRACE(MajorError_HERE,"ERROR: configuration of reboot-time is in wrong format");
                 TRACE(HERE,"timeConfiguration.size() = [%d]", timeConfiguration.size() );
             }
         }
         else
-            TRACE(HERE,"Reboot Time has been deleted from configuration.");   
+            TRACE(MajorError_HERE,"Reboot Time has been deleted from configuration.");   
 
         
         TRACE(  BasicRuntime_HERE, 
@@ -175,10 +175,10 @@ namespace mControl
                 }
                 else
                 {
-                    TRACE(HERE,"FAILED to reboot kiosk, rc = [%d] sleep for a minute",rc);
+                    TRACE(MajorError_HERE,"FAILED to reboot kiosk, rc = [%d] sleep for a minute.",rc);
 
                     //TODO: sleep a minute, correct the time
-                    mSysTime::sleep( 30000 );
+                    mSysTime::sleep( 60000 );
                 }
             }
             else
@@ -237,13 +237,13 @@ namespace mControl
             }
             else
             {
-                TRACE(HERE,"ERROR: configuration of reboot-date is in wrong format");
+                TRACE(MajorError_HERE,"ERROR: configuration of reboot-date is in wrong format");
                 TRACE(HERE,"dateConfiguration.size() = [%d]", dateConfiguration.size() );
             }
         }
         else
         {
-            TRACE(HERE,"Reboot Time has been deleted from configuration.");
+            TRACE(MajorError_HERE,"Reboot Time has been deleted from configuration.");
         }
     }
 }
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/mControl/src/mControl_scheduler.cpp b/SelfServiceCommon/Massai/cpp/mControl/src/mControl_scheduler.cpp
index cb4d822a..e3eb7f31 100644
--- a/SelfServiceCommon/Massai/cpp/mControl/src/mControl_scheduler.cpp
+++ b/SelfServiceCommon/Massai/cpp/mControl/src/mControl_scheduler.cpp
@@ -58,7 +58,7 @@ namespace mControl
                     day = stoi (scheduleFrequency);
                 }
                 catch (const std::invalid_argument& ia) {
-                    TRACE(HERE, "ERROR: invalid argument exception [%s]",ia.what() );
+                    TRACE(MajorError_HERE, "ERROR: invalid argument exception [%s]",ia.what() );
                     day = 0;
                 } 
 
@@ -69,7 +69,7 @@ namespace mControl
             }
         }
 
-        TRACE( HERE,"new ScheduledTask, Time[%d:%d], Command[%s]",
+        TRACE( BasicRuntime_HERE,"new ScheduledTask, Time[%d:%d], Command[%s]",
             m_executionTime.hours(), 
             m_executionTime.minutes(), 
             m_cmd 
@@ -173,7 +173,7 @@ namespace mControl
                 );
             }
             else
-                TRACE(HERE,"ERROR: System-Command with more than 2 configure Parameters");
+                TRACE(MajorError_HERE,"ERROR: System-Command with more than 2 configure Parameters");
 
             
             if( newTaskPointer != NULL )
@@ -181,7 +181,7 @@ namespace mControl
                 m_taskList.push_back(newTaskPointer);
             }
             else
-                TRACE(HERE,"ERROR: nullpointer at newTaskPointer");
+                TRACE(MajorError_HERE,"ERROR: nullpointer at newTaskPointer");
 
             newTaskPointer = NULL;
         }
@@ -252,8 +252,8 @@ namespace mControl
                                     (*taskIterator)->getHour(),
                                     (*taskIterator)->getMinute());
 
-                        rc = m_globalConfig.getWorker()->mSystem((*taskIterator)->getCmd().c_str(),"scheduled");
-                        TRACE(HERE,"call to mSystem, rc=[%d]", rc);
+                        rc = m_globalConfig.getWorker()->startProcess((*taskIterator)->getCmd());
+                        TRACE(HERE,"call to startProcess, rc=[%d]", rc);
                     }
                 }
             }
@@ -285,8 +285,8 @@ namespace mControl
                                     (*taskIterator)->getHour(),
                                     (*taskIterator)->getMinute());
 
-                        rc = m_globalConfig.getWorker()->mSystem((*taskIterator)->getCmd().c_str(),"scheduled");
-                        TRACE(HERE,"call to mSystem, rc=[%d]", rc);
+                        rc = m_globalConfig.getWorker()->startProcess( (*taskIterator)->getCmd() );
+                        TRACE(HERE,"call to startProcess, rc=[%d]", rc);
                     }
                 }
             }
@@ -312,8 +312,8 @@ namespace mControl
                                         (*taskIterator)->getHour(),
                                         (*taskIterator)->getMinute());;
 
-                        rc = m_globalConfig.getWorker()->mSystem((*taskIterator)->getCmd().c_str(),"scheduled");
-                        TRACE(HERE,"call to mSystem, rc=[%d]", rc);
+                        rc = m_globalConfig.getWorker()->startProcess( (*taskIterator)->getCmd() );
+                        TRACE(HERE,"call to startProcess, rc=[%d]", rc);
                     }
                 }
             }
diff --git a/SelfServiceCommon/Massai/cpp/mControl/src/mControl_servant.cpp b/SelfServiceCommon/Massai/cpp/mControl/src/mControl_servant.cpp
index 9d8e2ba1..1b63618e 100644
--- a/SelfServiceCommon/Massai/cpp/mControl/src/mControl_servant.cpp
+++ b/SelfServiceCommon/Massai/cpp/mControl/src/mControl_servant.cpp
@@ -14,7 +14,6 @@
 
 //Project includes
 #include "..\inc\mControl_servant.h"
-#include "..\inc\mControl_logging.h"
 #include "..\inc\mControl_tools.h"
 
 //MATERNA includes
@@ -55,9 +54,9 @@ namespace mControl
                 (
                 HERE,
                 "shutdownOS(fReboot = %s, fForced = %s): Kiosk busy: %s",
-                Tools::noYes(fReboot),
-                Tools::noYes(fForced),
-                Tools::noYes(m_kioskBusy)
+                Tools::noYes(fReboot).c_str(),
+                Tools::noYes(fForced).c_str(),
+                Tools::noYes(m_kioskBusy).c_str()
                 );
 
             long rc = 0;
@@ -85,177 +84,56 @@ namespace mControl
         }
         catch( ... )
         {
-            TRACE( HERE,"shutdownOS - exception rc = -1" );
+            TRACE( MajorError_HERE,"shutdownOS - exception rc = -1" );
             return -1;
         }
 
     }
 
-    /*
-    //TODO: delete, not used anymore
-    std::string MControlServant::getRebootFileName()
-    {
-        TRACE(HERE,"getRebootFilename() ...");
-
-        std::string userDir;
-        try
-        {
-            TCHAR app_path[MAX_PATH] = {0};
-            if(SHGetSpecialFolderPath(NULL, app_path, CSIDL_LOCAL_APPDATA, FALSE))
-            {
-                PathAddBackslash(reinterpret_cast<LPTSTR>(app_path));
-                std::string buf(app_path); buf.append("materna");
-                if(PathIsDirectory(buf.c_str()))
-                {
-                    PathAppend(app_path,"materna\\");
-                }
-                buf.assign(app_path); buf.append("MIPS");
-                if(PathIsDirectory(buf.c_str()))
-                {
-                    PathAppend(app_path,"MIPS\\");
-                }
-                userDir.assign(app_path).append(REBOOT_FILE_NAME);
-            } else
-                userDir.assign(".\\"REBOOT_FILE_NAME);
-        }
-        catch(...)
-        {
-          userDir.assign(".\\"REBOOT_FILE_NAME);
-        }
-        return userDir;
-    }*/
-
-
-    
-    
-
-
+       
     /***************************************************************************
     *   controller::kioskControl interface Methods implementation
     **/
-    //TODO: -get the information of the process in the for-loop
-    Controller::processList * MControlServant::queryProcessList()
-    {
-        TRACE(HERE,"queryProcessList() ...");
-
-        Controller::processList_var controllerPList;
-        CORBA::ULong i;
-
-        TraceLocal trc("MControlServant_queryProcessList");
-        Logging log(trc);
-        ProcessTree* processTree = createProcessTree(trc);
-
-        
-        //processList processTree;
-        //process    *pp;
+//Platform commands
+   
 
-        try
-        {
-            // allocate new sequence
-
-            controllerPList = new Controller::processList;
-
-            // set the length of the unbound sequence
-          
-            controllerPList->length(processTree->processes().size());
-            ProcessNodeList list = processTree->processes();
-
-            ProcessNodeList::const_iterator it = list.begin();
-            ProcessNodeList::const_iterator end = list.end();
-            for(i=0; i < controllerPList->length(), it != end; i++, it++)
-            {
-                const ProcessNode* node = *it;
-                child* process = node->getProcess(&log);
-
-                //controllerPList[i].name    = CORBA::string_dup(pp->szName);
-                //controllerPList[i].path    = CORBA::string_dup(pp->szPath);
-                //controllerPList[i].pid     = pp->pid;
-                //controllerPList[i].ppid    = pp->ppid;
-                //controllerPList[i].memory  = pp->memory;
-                //controllerPList[i].vMemory = pp->vmemory;
-                //controllerPList[i].usage   = pp->usage;
-                
-               delete process;
-            }
-
-            return(controllerPList._retn());
-            
-          /*
-           // allocate new sequence
-
-          rl = new Controller::processList;
-
-          // set the length of the unbound sequence
-
-          rl->length(pl.noOfProcesses());
-
-          pp = pl.pListFirst();
-
-          // fill up sequence with actual values
-
-          for(i = 0; pp && i < controllerPList->length(); i++)
-          {
-            controllerPList[i].name    = CORBA::string_dup(pp->szName);
-            controllerPList[i].path    = CORBA::string_dup(pp->szPath);
-            controllerPList[i].pid     = pp->pid;
-            controllerPList[i].ppid    = pp->ppid;
-            controllerPList[i].memory  = pp->memory;
-            controllerPList[i].vMemory = pp->vmemory;
-            controllerPList[i].usage   = pp->usage;
-
-            pp = processTree.pListNext();
-          }
-
-          return(controllerPList._retn());
-          */
-        }
-        catch(CORBA::SystemException& e)
-        {
-          TRACE(HERE,"CORBA::Exception: %s",e._info());
 
-          return(NULL);
-        }
-        catch( std::exception& e)
-        {
-          TRACE(HERE,"Exception: %s",e.what());
+    //TODO: check-mechanism for notification
+    CORBA::Long MControlServant::startPlatform()
+    {
+        TRACE(HERE,"startPlatform() ...");
+        long rc = 0;
 
-          return(NULL);
-        }
-        catch(...)
-        {
-          TRACE(HERE,"Unknown Exception");
+        /*rc=*/m_notificationQueue.enqueueNotification( new MControlNotification("WM_MASSAISTART_REMOTE", SERVANT_ID, WM_MASSAISTART_REMOTE) );
 
-          return(NULL);
-        }
+        TRACE(HERE,"requested platform start, rc = %d",rc);
+        return(rc);
     }
-
-
-    //TODO: implement with new Process-lib
-    CORBA::Long MControlServant::killProcess(CORBA::Long pid)
+    
+    
+    //TODO: check-mechanism for notification
+    CORBA::Long MControlServant::forcedRestartPlatform()
     {
-        TRACE(HERE,"killProcess(...) ...");
+        TRACE(HERE,"forcedRestartPlatform() ...");
         long rc = 0;
+        
+        m_kioskBusy = false;
 
-        // Get a handle to the process.
-        HANDLE hProcess = OpenProcess(PROCESS_TERMINATE,false,pid);
+        /*rc=*/m_notificationQueue.enqueueNotification( new MControlNotification("WM_MASSAISTOP_REMOTE", SERVANT_ID, WM_MASSAISTOP_REMOTE) );
 
-        if(!TerminateProcess(hProcess,0))
-        {
-            rc = GetLastError();
-            TRACE(HERE,"failed to kill process %d, rc = %d",pid, rc);
-        }
-        else
-            TRACE(HERE,"process %d killed",pid);
+        TRACE(HERE,"requested forced platform restart, stop rc = %d",rc);
 
-        CloseHandle(hProcess);
-        return(rc);
+        /*rc=*/m_notificationQueue.enqueueNotification( new MControlNotification("WM_MASSAISTART_REMOTE", SERVANT_ID, WM_MASSAISTART_REMOTE) );
+
+        TRACE(HERE,"requested forced platform restart, start rc = %d",rc);
+        return rc;
     }
 
 
     //TODO: check-mechanism for notification
     CORBA::Long MControlServant::shutdownPlatform()
     {
-        TRACE(HERE,"shutdownPlatform(): Kiosk busy: %s",Tools::noYes(m_kioskBusy));
+        TRACE(HERE,"shutdownPlatform(): Kiosk busy: %s",Tools::noYes(m_kioskBusy).c_str());
         long rc = 0;
 
         if(m_kioskBusy)
@@ -270,18 +148,21 @@ namespace mControl
 
 
     //TODO: check-mechanism for notification
-    CORBA::Long MControlServant::startPlatform()
+    CORBA::Long MControlServant::forcedShutdownPlatform()
     {
-        TRACE(HERE,"startPlatform() ...");
-        long rc = 0;
+        TRACE(HERE,"forcedShutdownPlatform() ...");
+        long rc;
 
-        /*rc=*/m_notificationQueue.enqueueNotification( new MControlNotification("WM_MASSAISTART_REMOTE", SERVANT_ID, WM_MASSAISTART_REMOTE) );
+        m_kioskBusy = false;
 
-        TRACE(HERE,"requested platform start, rc = %d",rc);
+        /*rc=*/m_notificationQueue.enqueueNotification( new MControlNotification("WM_MASSAISTOP_REMOTE", SERVANT_ID, WM_MASSAISTOP_REMOTE) );
+
+        TRACE(HERE,"requested forced platform shutdown, rc = %d",rc);
         return(rc);
     }
 
 
+//Kiosk Commands
     CORBA::Long MControlServant::rebootKiosk()
     {
         TRACE(HERE,"rebootKiosk() ...");
@@ -302,6 +183,22 @@ namespace mControl
     }
 
 
+    CORBA::Long MControlServant::forcedRebootKiosk()
+    {
+        TRACE(HERE,"forcedRebootKiosk() ...");
+
+        long rc;
+
+        m_kioskBusy = false;
+
+        rc = shutdownOS(true,true);
+
+        TRACE(HERE,"forced kiosk reboot, rc = %d",rc);
+
+        return(rc);
+    }
+
+
     CORBA::Long MControlServant::shutdownKiosk()
     {
         TRACE(HERE,"shutdownKiosk() ...");
@@ -322,74 +219,133 @@ namespace mControl
     }
 
 
-    //TODO: check-mechanism for notification
-    CORBA::Long MControlServant::forcedShutdownPlatform()
+    CORBA::Long MControlServant::forcedShutdownKiosk()
     {
-        TRACE(HERE,"forcedShutdownPlatform() ...");
+        TRACE(HERE,"forcedShutdownKiosk() ...");
+
         long rc;
 
         m_kioskBusy = false;
 
-        /*rc=*/m_notificationQueue.enqueueNotification( new MControlNotification("WM_MASSAISTOP_REMOTE", SERVANT_ID, WM_MASSAISTOP_REMOTE) );
+        rc = shutdownOS(false,true);
 
-        TRACE(HERE,"requested forced platform shutdown, rc = %d",rc);
+        TRACE(HERE,"forced kiosk shutdown, rc = %d",rc);
         return(rc);
     }
 
 
-    //TODO: check-mechanism for notification
-    CORBA::Long MControlServant::forcedRestartPlatform()
+//General commands
+     //TODO: -get the information of the process in the for-loop
+    Controller::processList * MControlServant::queryProcessList()
     {
-        TRACE(HERE,"forcedRestartPlatform() ...");
-        long rc = 0;
-        
-        m_kioskBusy = false;
+        TRACE(HERE,"queryProcessList() ...");
 
-        /*rc=*/m_notificationQueue.enqueueNotification( new MControlNotification("WM_MASSAISTOP_REMOTE", SERVANT_ID, WM_MASSAISTOP_REMOTE) );
+        Controller::processList_var controllerPList;
 
-        TRACE(HERE,"requested forced platform restart, stop rc = %d",rc);
+        TraceLocal trc("MControlServant_queryProcessList");
+        Logging log(trc);
+        ProcessTree* processTree = createProcessTree(trc);
 
-        /*rc=*/m_notificationQueue.enqueueNotification( new MControlNotification("WM_MASSAISTART_REMOTE", SERVANT_ID, WM_MASSAISTART_REMOTE) );
+        try
+        {
+            // allocate new sequence
+            controllerPList = new Controller::processList;
 
-        TRACE(HERE,"requested forced platform restart, start rc = %d",rc);
-        return rc;
-    }
+            // set the length of the unbound sequence
+            controllerPList->length(processTree->processes().size());
+            
+            ProcessNodeList list (processTree->processes());
 
+            ProcessNodeList::const_iterator it  = list.begin();
+            ProcessNodeList::const_iterator end = list.end();
+         
+            int i;
+            TRACE(SecondaryRuntime_HERE, "size of ProcessList: [%d]", processTree->processes().size() );
+            for(i=0; it != end; i++, it++)
+            {
+                const ProcessNode* node = *it;
+                child* process = node->getProcess(&log);
 
+                if( process )
+                {
+                    //TRACE(HERE,"%d)    PID[%s], PName[%s]", i, process->getProcessId().c_str() , process->getProgram().c_str() );
+                
+                    /* Definitino for processList variables in controller_skel.h
+                    ::TAO::String_Manager name
+                    ::TAO::String_Manager path
+                    ::CORBA::Long pid
+                    ::CORBA::Long ppid
+                    ::CORBA::Long memory
+                    ::CORBA::Long vMemory
+                    ::CORBA::Long usage
+                    */
+
+                    /*
+                    controllerPList[i].name    = CORBA::string_dup( process->getProgram().c_str() );
+                    controllerPList[i].path    = CORBA::string_dup( "default" );
+                    controllerPList[i].pid     = stol( process->getProcessId() );
+                    controllerPList[i].ppid    = stol( process->getParentProcessId() );
+                    controllerPList[i].memory  = process->getProcessMemoryUsage(); 
+                    controllerPList[i].vMemory = process->getProcessMemoryUsage();
+                    controllerPList[i].usage   = process->getProcessIoUsage();  
+                    */
+                }
+                else
+                {
+                    TRACE(MinorError_HERE, "ERROR: no process pointer!");
+                } 
 
-    CORBA::Long MControlServant::forcedRebootKiosk()
-    {
-        TRACE(HERE,"forcedRebootKiosk() ...");
+                delete process;
+            }
 
-        long rc;
+            delete processTree;
 
-        m_kioskBusy = false;
+            return(controllerPList._retn());
+            
+        }
+        catch(CORBA::SystemException& e)
+        {
+          TRACE(MajorError_HERE,"CORBA::Exception: %s",e._info());
 
-        rc = shutdownOS(true,true);
+          return(NULL);
+        }
+        catch( std::exception& e)
+        {
+          TRACE(HERE,"Exception: %s",e.what());
 
-        TRACE(HERE,"forced kiosk reboot, rc = %d",rc);
+          return(NULL);
+        }
+        catch(...)
+        {
+          TRACE(MajorError_HERE,"Unknown Exception");
 
-        return(rc);
+          return(NULL);
+        }
     }
 
 
-
-    CORBA::Long MControlServant::forcedShutdownKiosk()
+    //TODO: implement with new Process-lib
+    CORBA::Long MControlServant::killProcess(CORBA::Long pid)
     {
-        TRACE(HERE,"forcedShutdownKiosk() ...");
-
-        long rc;
+        TRACE(HERE,"killProcess(...) ...");
+        long rc = 0;
 
-        m_kioskBusy = false;
+        // Get a handle to the process.
+        HANDLE hProcess = OpenProcess(PROCESS_TERMINATE,false,pid);
 
-        rc = shutdownOS(false,true);
+        if(!TerminateProcess(hProcess,0))
+        {
+            rc = GetLastError();
+            TRACE(MajorError_HERE,"failed to kill process %d, rc = %d",pid, rc);
+        }
+        else
+            TRACE(HERE,"process %d killed",pid);
 
-        TRACE(HERE,"forced kiosk shutdown, rc = %d",rc);
+        CloseHandle(hProcess);
         return(rc);
     }
 
 
-    
     //TODO: implement loadHostsFile()
     CORBA::Long MControlServant::reloadHostsFile()
     {
@@ -403,13 +359,15 @@ namespace mControl
     {
         m_kioskBusy = (busy == 0)?FALSE:TRUE;
 
-        TRACE(HERE,"Kiosk busy: %s",Tools::noYes(m_kioskBusy));
+        TRACE(HERE,"Kiosk busy: %s",Tools::noYes(m_kioskBusy).c_str());
     }
     
 
     char *MControlServant::lastRebootTime()
     {
-        cfgStr* cfgRebootDate;
+        TRACE(HERE,"lastRebootTime() ...");
+
+        cfgStr* cfgRebootDate = new cfgStr(RTIME_ITEM);;
         string lastRebootTime;
 
         if( cfgRebootDate == NULL )
@@ -425,31 +383,6 @@ namespace mControl
             TRACE(MajorError_HERE, "ERROR: No Reboot-Time available!");
             return (CORBA::string_dup(""));
         }
-
-        /*
-        FILE *fp;
-        mDate date;
-        mTime time;
-
-        char szDateTime[256];
-
-        strcpy(szDateTime,"reboot time not available");
-
-        fp = fopen(getRebootFileName().c_str(),"rb");
-
-        if(fp)
-        {
-          fread(&date,sizeof(mDate),1,fp);
-          fread(&time,sizeof(mTime),1,fp);
-
-          sprintf(szDateTime,"%02d.%02d.%04d-%02d:%02d",
-                             date.dayOfMonth(),date.monthOfYear(),date.year(),
-                             time.hours(),time.minutes());
-          fclose(fp);
-        }
-
-        return(CORBA::string_dup(szDateTime));
-        */
     }
 
 
diff --git a/SelfServiceCommon/Massai/cpp/mControl/src/mControl_tools.cpp b/SelfServiceCommon/Massai/cpp/mControl/src/mControl_tools.cpp
index 2342340c..fa9ec4f5 100644
--- a/SelfServiceCommon/Massai/cpp/mControl/src/mControl_tools.cpp
+++ b/SelfServiceCommon/Massai/cpp/mControl/src/mControl_tools.cpp
@@ -48,19 +48,18 @@ namespace mControl
     }
 
 
-    char const * Tools::boolToChar( bool in )
+    std::string Tools::boolToString( bool in )
     {
         return in ? "true" : "false";
     }
 
 
-    char const * Tools::noYes(bool f)
+    std::string Tools::noYes(bool f)
     {
         return f ? "YES" : "NO";
     }
     
 
-    //TODO: char* replace
     string Tools::getWorkingDir()
     {
         char szPath[MAX_PATH];
@@ -75,10 +74,6 @@ namespace mControl
         {
             unsigned found = sPath.find_last_of("/\\");
             sPath = sPath.substr(0,found);
-            /*TODO: erase
-            char* pTmp = strrchr(szPath, '\\');
-            if(pTmp) *pTmp = '\0';
-            */
         }
         else
         {
@@ -90,7 +85,6 @@ namespace mControl
     }
 
 
-    //TODO: char* replace
     long Tools::setWorkingDir()
     {
         // TODO: check if "A" is right
@@ -101,24 +95,9 @@ namespace mControl
     }
 
 
-    int Tools::traceCurrentDir()
-    {
-        char cCurrentPath[FILENAME_MAX];
-
-        if (!GetCurrentDir(cCurrentPath, sizeof(cCurrentPath)))
-        {
-            return errno;
-        }
-
-        cCurrentPath[sizeof(cCurrentPath) - 1] = '\0'; /* not really required */
-
-        TRACE(HERE,"The current working directory is: %s", cCurrentPath);
-    }
-
-
     boost::posix_time::time_duration Tools::getActualSystemTime()  
     {
-        time_t t = time(0);   // get time now
+        time_t t = time(0);   
         struct tm * now = localtime( & t );
 
         boost::posix_time::time_duration today( now->tm_hour,now->tm_min,now->tm_sec,0 );
@@ -129,7 +108,7 @@ namespace mControl
 
     boost::gregorian::date Tools::getActualSystemDate()  
     {
-        time_t t = time(0);   // get time now
+        time_t t = time(0);  
         struct tm * now = localtime( & t );
 
         boost::gregorian::date actualDate( (now->tm_year + 1900), (now->tm_mon + 1), (now->tm_mday) );
@@ -228,14 +207,13 @@ namespace mControl
     }
 
 
-    //TODO: char* replace, OpenService replace
-    long Tools::waitForService( char const * serviceName, long lTimeout)
+    long Tools::waitForService( std::string serviceName, long lTimeout)
     {
         long lTo  = 1000;
         long lCnt = 0;
         long rc   = 0;
 
-        if(!serviceName || !*serviceName)
+        if( serviceName == "" )
             return(-1);
 
         if(lTimeout >= 0)
@@ -247,7 +225,7 @@ namespace mControl
 
         if(hSC == 0)
         {
-            TRACE(HERE,"%s OpenSCManager() failed, rc = %d\n", Tools::timeStamp().c_str(), GetLastError());
+            TRACE(MajorError_HERE,"%s OpenSCManager() failed, rc = %d\n", Tools::timeStamp().c_str(), GetLastError());
             return(-2);
         }
 
@@ -255,7 +233,7 @@ namespace mControl
 
         if(lTimeout >= 0)
         {
-            TRACE(HERE, "%s waiting for service [%s], to = %d\n", Tools::timeStamp().c_str(), serviceName, lTimeout * lTo);
+            TRACE(HERE, "%s waiting for service [%s], to = %d\n", Tools::timeStamp().c_str(), serviceName.c_str(), lTimeout * lTo);
         } 
         else
         {
@@ -264,7 +242,7 @@ namespace mControl
 
         while( !fServiceRunning && ( lCnt <= lTimeout ) )
         {
-            SC_HANDLE hService = OpenService(hSC, serviceName, SERVICE_QUERY_STATUS);
+            SC_HANDLE hService = OpenService(hSC, serviceName.c_str(), SERVICE_QUERY_STATUS);
 
             if(hService)
             {
@@ -278,13 +256,13 @@ namespace mControl
                             fServiceRunning = true;
                         else
                         {
-                            Sleep(lTo);
+                            mSysTime::sleep( lTo );
                             if(lTimeout >= 0) lCnt++;
                         }
                     }
                     else
                     {
-                        Sleep(lTo);
+                        mSysTime::sleep( lTo );
                         if(lTimeout >= 0) 
                             lCnt++;
                     }
@@ -296,7 +274,7 @@ namespace mControl
 
             if( !fServiceRunning )
             {
-                Sleep(lTo);
+                mSysTime::sleep( lTo );
                 if(lTimeout >= 0) lCnt++;
             }
 
@@ -307,7 +285,7 @@ namespace mControl
         if(!fServiceRunning || lCnt > lTimeout)
             rc = -3;
 
-        TRACE(HERE, "%s waiting for service [%s], rc = %d\n", Tools::timeStamp().c_str(), serviceName, rc);
+        TRACE(HERE, "%s waiting for service [%s], rc = %d\n", Tools::timeStamp().c_str(), serviceName.c_str(), rc);
 
         return(rc);
     }
@@ -424,10 +402,9 @@ namespace mControl
     }
 
 
-    //TODO: replace process handle
     long Tools::shutdownOS_Now(bool fReboot)
     {
-       TRACE(HERE,"shutdownOS_Now(fReboot = %s) ...", Tools::noYes(fReboot));
+       TRACE(HERE,"shutdownOS_Now(fReboot = %s) ...", Tools::noYes(fReboot).c_str());
        long rc = 0;
        try
        {
@@ -437,7 +414,7 @@ namespace mControl
           if( !OpenProcessToken( hProcess,TOKEN_WRITE,&hToken ) )
           {
              rc = GetLastError();
-             TRACE( HERE, "OpenProcessToken() failed, rc = %d", rc );
+             TRACE( MajorError_HERE, "OpenProcessToken() failed, rc = %d", rc );
           }
           else
           {
@@ -452,7 +429,7 @@ namespace mControl
                 )
              {
                 rc = GetLastError();
-                TRACE( HERE, "LookupPrivilegeValue() failed, rc = %d", rc );
+                TRACE( MajorError_HERE, "LookupPrivilegeValue() failed, rc = %d", rc );
              }
              else
              {
@@ -475,7 +452,7 @@ namespace mControl
                    rc = GetLastError();
                    TRACE
                       (
-                         HERE, "AdjustTokenPrivileges() failed, rc = %d",
+                         MajorError_HERE, "AdjustTokenPrivileges() failed, rc = %d",
                          rc
                       );
                 }
@@ -495,7 +472,7 @@ namespace mControl
                       rc = GetLastError();
                       TRACE
                          (
-                            HERE,
+                            MajorError_HERE,
                             "InitiateSystemShutdown() failed, rc = %d",
                             rc
                          );
@@ -506,13 +483,13 @@ namespace mControl
        }
        catch( ... )
        {
-          TRACE(HERE,"shutdownOS_Now exception");
+          TRACE(MajorError_HERE, "shutdownOS_Now exception");
           rc = -1;
        }
        if(rc)
-          TRACE(HERE,"shutdownOS_Now failed, rc = %d",rc);
+          TRACE(MajorError_HERE, "shutdownOS_Now failed, rc = %d",rc);
        else
-          TRACE(HERE,"shutdownOS_Now.");
+          TRACE(HERE, "shutdownOS_Now.");
        return(rc);
     }
 
diff --git a/SelfServiceCommon/Massai/cpp/mControl/src/mControl_worker.cpp b/SelfServiceCommon/Massai/cpp/mControl/src/mControl_worker.cpp
index 998ba7c4..f0b1127f 100644
--- a/SelfServiceCommon/Massai/cpp/mControl/src/mControl_worker.cpp
+++ b/SelfServiceCommon/Massai/cpp/mControl/src/mControl_worker.cpp
@@ -14,6 +14,7 @@
 #include "..\inc\mControl_worker.h"
 #include "..\inc\mControl_notification.h"
 #include "..\inc\mControl_tools.h"
+#include "..\inc\mControl_process.h"
 
 //Windows includes
 #include <Commctrl.h>
@@ -37,7 +38,8 @@ namespace mControl
         m_dialog(dialog),
         m_shutDownCommands(NULL),
         m_startUpCommands(NULL),
-        m_processStarter(NULL)
+        m_processStarter(NULL),
+        m_stop_sem_handle( NULL )
     {
     }
 
@@ -164,7 +166,7 @@ namespace mControl
                                             TEXT("Please use the service control to stop the platform."),
                                             TEXT("Massai - isService"),
                                             MB_ICONEXCLAMATION | MB_OK);
-                                TRACE(HERE,"shutdown - blocked cause mDaemon_isService");
+                                TRACE(MinorWarning_HERE,"shutdown - blocked cause mDaemon_isService");
                             }
                             else if(!m_globalConfig.serverMode() && (GetKeyState(VK_CONTROL) & 0xffff0000) && (GetKeyState(VK_SHIFT) & 0xffff0000))
                             {
@@ -184,7 +186,7 @@ namespace mControl
                                         worker->execSysCmdsShutdown();
                                     }
                                     else
-                                        TRACE(HERE,"ERROR: no worker available");
+                                        TRACE(MajorError_HERE,"ERROR: no worker available");
 
                                     //TODO: wieder einbinden
                                     //rc = Tools::shutdownOS_Now(true);
@@ -215,7 +217,7 @@ namespace mControl
                     
                     default:
                         {
-                            TRACE(HERE,"ERROR: unknown command [ %d ]", cmd);
+                            TRACE(MajorError_HERE,"ERROR: unknown command [ %d ]", cmd);
                         }
                         break;
                     }               
@@ -227,7 +229,7 @@ namespace mControl
 
     void Worker::execSysCmdsShutdown()
     {
-        TRACE( HERE, "execSysCmdsShutdown ..." );
+        TRACE( HERE, "execSysCmdsShutdown()..." );
 
         if (m_shutDownCommands == NULL)
             m_shutDownCommands = new cfgListSysCommands ("PLATFORM.SHUTDOWN.SystemCommands");
@@ -235,59 +237,54 @@ namespace mControl
         list<string> cmdlist = m_globalConfig.getEnvS().substEnvList(m_shutDownCommands->get());
         int index = 1;
         
-        for( list<string>::iterator i = cmdlist.begin(); i != cmdlist.end(); i++)
+        for( list<string>::iterator sCmdIterator = cmdlist.begin(); sCmdIterator != cmdlist.end(); sCmdIterator++)
         {
-            std::ostringstream oss;
-            oss << "execSysCmdsShutdown#" << index++;
-            
-            long const rc = mSystem( (*i).c_str(), oss.str().c_str() );
-
-            TRACE(HERE,"executed sys command [%s], rc = %d",(*i).c_str(),rc);
+            long const rc = startProcess( (*sCmdIterator) );
+            TRACE(HERE,"executed sys command [%s], rc = %d",(*sCmdIterator).c_str(),rc);
         }
 
-        TRACE( HERE, "execSysCmdsShutdown." );
+        TRACE( HERE, "execSysCmdsShutdown, done.\n" );
     }
 
 
     void Worker::execSysCmdsStartup()
     {
-        TRACE( HERE, "execSysCmdsStartup ..." );
+        TRACE( HERE, "execSysCmdsStartup()..." );
         if (m_startUpCommands==NULL)
             m_startUpCommands = new cfgListSysCommands ("PLATFORM.STARTUP.SystemCommands");
        
         list<string> cmdlist = m_globalConfig.getEnvS().substEnvList(m_startUpCommands->get());
         int index( 1 );
-        for( list<string>::iterator i = cmdlist.begin(); i != cmdlist.end(); i++)
+        for( list<string>::iterator sCmdIterator = cmdlist.begin(); sCmdIterator != cmdlist.end(); sCmdIterator++)
         {
-            std::ostringstream oss;
-            oss << "execSysCmdsStartup#" << index++;
-
-            long const rc = mSystem( (*i).c_str(), oss.str().c_str() );
-            TRACE(HERE,"executed sys command [%s], rc = %d",(*i).c_str(),rc);
+            long const rc = startProcess( (*sCmdIterator) );
+            TRACE(HERE,"executed sys command [%s], rc = %d",(*sCmdIterator).c_str(),rc);
         }
-        TRACE( HERE, "execSysCmdsStartup." );
+        TRACE( HERE, "execSysCmdsStartup, done.\n" );
     }
 
 
-    long Worker::mSystem( char const * cmd, char const * purpose )
+    long Worker::startProcess( std::string cmd)
     {
-       std::string task( "cmd.exe /X /C \"" );
-       task += cmd;
-       task += "\"";
-       TRACE( HERE, "mSystem(%s)", task.c_str() );
-       mSysProcess::parent localParent;
-       localParent.setCommandline( task.c_str() );
-
-       mSysProcess::child * newProcess = localParent.newChild();
+        std::string task( "cmd.exe /X /C \"" );
+        task += cmd;
+        task += "\"";
+        TRACE( HERE, "startProcess(%s)", task.c_str() );
+        mSysProcess::parent localParent;
+        localParent.setCommandline( task.c_str() );
+
+        mSysProcess::child * newProcess = localParent.newChild();
        
-       m_processListMonitor.add( newProcess );
+        m_processListMonitor.add( newProcess );
 
-       return 1;
+        return 1;
     }
 
 
-    long Worker::startUpdate()
+    long Worker::startMUpdate()
     {
+        TRACE(HERE,"startMUpdate()...");
+
         char                szPath[MAX_PATH];
 
         //Check if "A" is correct
@@ -321,6 +318,8 @@ namespace mControl
             .setCommandline( commandLine.str().c_str() );
 
         std::auto_ptr<mSysProcess::child> Child( Update.newChild() );
+
+        TRACE(HERE,"startMUpdate(), done.\n");
         return Child
                 ->waitForTermination( 600 ) // Something went terrible wrong,
                                             // when not done after 600 secs.
@@ -328,22 +327,14 @@ namespace mControl
     }
 
 
-    long Worker::startAll()
+    long Worker::startMStarter()
     {
-        TRACE(HERE,"startAll...");
+        TRACE(HERE,"startMStarter()...");
 
-        STARTUPINFO         si;
         char                szPath[MAX_PATH];
 
         m_processStarter = NULL;
 
-        memset(&si,0,sizeof(STARTUPINFO));
-
-        si.cb           = sizeof(STARTUPINFO);
-        si.dwFlags      = STARTF_USESHOWWINDOW;
-        si.wShowWindow  = SW_SHOWMINIMIZED;
-        //si.wShowWindow = SW_HIDE;
-
         //TODO: check if "A" is correct
         GetModuleFileNameA(0,szPath,sizeof(szPath));
         std::string sPath (szPath);
@@ -355,25 +346,46 @@ namespace mControl
 
         if(m_globalConfig.serverMode() && mDaemon_isService())
         {
-            commandLine << sPath << "\\" << STARTER_NAME << " -server -service";
+            commandLine << sPath << "\\" << STARTER_NAME << " " << SEM_NAME << " -server -service";
         }
         else if(m_globalConfig.serverMode())
         {
-            commandLine << sPath << "\\" << STARTER_NAME << " -server"; 
+            commandLine << sPath << "\\" << STARTER_NAME << " " << SEM_NAME << " -server"; 
         }
         else
         {
-            commandLine << sPath << "\\" << STARTER_NAME;
+            commandLine << sPath << "\\" << STARTER_NAME << " " << SEM_NAME;
         }
 
-        mSysProcess::parent localParent;
         TRACE(HERE,"starting mStarter with commadLine =[%s]", commandLine.str() );
 
+        if( SEM_NAME )
+        {
+            m_stop_sem_handle =
+            CreateEventA
+                (
+                    NULL,                 // lpEventAttributes
+                    true,                 // bManualReset
+                    false,                // bInitialState
+                    SEM_NAME              // lpName
+                );
+            if( !m_stop_sem_handle )
+            {
+                return 1;
+            }
+            ResetEvent( m_stop_sem_handle );
+        }
+
+        ProcessCallback m_stdErr(STARTER_NAME, "STDERR" );
+        
+        mSysProcess::parent localParent;
+
         localParent.setCommandline( commandLine.str().c_str() );
+        localParent.setHide();
         
         m_processStarter = localParent.newChild();
 
-        TRACE(HERE,"startAll.");
+        TRACE(HERE,"startMStarter(), done.\n");
 
         if( m_processStarter->getStatus() != mSysProcess::STATUS_FAILED )
             return 0;
@@ -397,71 +409,23 @@ namespace mControl
         {
             if(m_processStarter)
             {
-                TRACE(HERE,"running processes: size=[%d]", m_globalConfig.getProgressProcessList().size());
-
-                TRACE(HERE,"send Ctrl-C to mStarter, success[%s]", Tools::boolToChar(m_processStarter->sendCtrlC()));
+                TRACE(HERE,"send signalStop to mStarter");
+                this->signalStop();
 
                 while( m_processStarter->getStatus() == mSysProcess::STATUS_RUNNING )
-                {
-                    TRACE(HERE,"mStarter is still running ...");
-                    TRACE(HERE,"send Ctrl-C to mStarter, success[%s]", Tools::boolToChar(m_processStarter->sendCtrlC()));
-
-                    TRACE(HERE,"running processes: size=[%d]", m_globalConfig.getProgressProcessList().size());
-
-                    m_globalConfig.getProgressProcessList();
-
-                    /*
-                    for(processIterator = m_globalConfig.getProgressProcessList().begin(); processIterator != m_globalConfig.getProgressProcessList().end() && m_globalConfig.getProgressProcessList().size(); nexProcessIt = processIterator++)
-                    {
-                        try
-                        {
-                            TRACE(HERE,"MSTARTER: check process: %d, n = %d",(*processIterator), m_globalConfig.getProgressProcessList().size());
-
-                            hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,FALSE,(*processIterator));
-
-                            if(hProcess)
-                            {
-                                if((GetExitCodeProcess(hProcess,(unsigned long *) &lExitCode)) && lExitCode != STILL_ACTIVE)
-                                {
-                                    m_globalConfig.setCurrentProcesses( m_globalConfig.getCurrentProcesses() - 1);
-
-                                    m_globalConfig.setCurrLoadPercent( (long)( ( (float)m_globalConfig.getCurrentProcesses()/(float)m_globalConfig.getAllProcesses() )*100) );
-
-                                    SendMessage(m_dialog.getWindowConfig().getHwndLoad(),PBM_SETPOS,m_globalConfig.getCurrLoadPercent(),0);
-
-                                    UpdateWindow(m_dialog.getWindowConfig().getHwndLoad());
-
-                                    if(m_globalConfig.getProgressProcessList().size() > 0)
-                                        m_globalConfig.getProgressProcessList().erase(nexProcessIt);
-                                }
-
-                                // close this handle always !!
-                                CloseHandle(hProcess);
-                            }
-                        }
-                        catch( ... ) 
-                        {
-                            TRACE(HERE,"ERROR: failed to check process");
-                        }
-                    }
-                    */
+                {            
+                    int wait = 10;
+                    mSysTime::sleep(wait);
 
                     while(PeekMessage(&msg,NULL,0,0,PM_REMOVE))
                         DispatchMessage(&msg);
 
-                    int wait = 10;
-                    TRACE(HERE,"waitForStarterTermination sleep for [%d]ms", wait);
-                    mSysTime::sleep(wait);
+                    this->signalStop();
                 }
 
                 SendMessage(m_dialog.getWindowConfig().getHwndLoad(),PBM_SETPOS,0,0);
                 UpdateWindow(m_dialog.getWindowConfig().getHwndLoad());
 
-                TRACE(HERE,"waiting for starter termination, done.");
-
-                //TODO: check if right
-                m_processStarter->kill();
-
                 delete m_processStarter;
 
                 m_processStarter = NULL;
@@ -469,9 +433,9 @@ namespace mControl
         }
         catch( ... ) 
         {
-            TRACE(HERE,"ERROR: waitForStarterTermination");
+            TRACE(MajorError_HERE,"ERROR: waitForStarterTermination");
         }
-        TRACE(HERE,"waitForStarterTermination.");
+        TRACE(HERE,"waitForStarterTermination, done.\n");
     }
 
 
@@ -484,25 +448,27 @@ namespace mControl
         // request from remote !!
         if(!m_globalConfig.isStarted())
         {
-            SendMessage(m_dialog.getWindowConfig().getHwndLoad(),PBM_SETBARCOLOR,0,0x00008000);
-
             this->sendAlert(ALERT_E_START_REMOTE);
-
             m_globalConfig.setStarted( true );
+            
+            SendMessage(m_dialog.getWindowConfig().getHwndLoad(),PBM_SETBARCOLOR,0,0x00008000);
+            UpdateWindow(m_dialog.getWindowConfig().getHwndLoad());
 
+            // TODO: start update service previous to all other tasks ...
+            /*
             ShowWindow(m_dialog.getWindowConfig().getHwndInfo2(),SW_SHOW);
             UpdateWindow(m_dialog.getWindowConfig().getHwndInfo2());
-            UpdateWindow(m_dialog.getWindowConfig().getHwndLoad());
 
-            // start update service previous to all other tasks ...
-            rc = startUpdate();
+            rc = startMUpdate();
 
             ShowWindow(m_dialog.getWindowConfig().getHwndInfo2(),SW_HIDE);
             UpdateWindow(m_dialog.getWindowConfig().getHwndInfo2());
- 
+
             if(rc == REBOOT_KIOSK)
             {
-                TRACE(HERE,"update service requested kiosk reboot (from startUpdate), rc = %d",rc);
+                TRACE(HERE,"update service requested kiosk reboot, rc = %d",rc);
+
+                this->sendAlert(ALERT_E_REBOOT_UPDATE);
 
                 //TODO: wieder einbinden
                 //rc = Tools::shutdownOS_Now(true);
@@ -511,12 +477,13 @@ namespace mControl
                 PostQuitMessage(0);
                 return 0;
             }
+            */
 
             // execute system commands before starting platform
             execSysCmdsStartup();
-            rc = startAll();
+            rc = startMStarter();
 
-            TRACE(HERE,"call to startAll returns with rc=%d",rc);
+            TRACE(HERE,"call to startMStarter returns with rc=%d",rc);
 
             if(!rc)
             {
@@ -529,27 +496,32 @@ namespace mControl
         else
             rc = -1;
         
+        TRACE(HERE,"massasiStartRemote(), done.\n");
         return rc;
     }
 
 
     long Worker::massaiStartScheduler()
     {
+        TRACE(HERE,"massaiStartScheduler()...");
+
         long rc;
+
         if(!m_globalConfig.isStarted())
         {
-            TRACE(HERE,"scheduler requested START");
             this->sendAlert(ALERT_E_START_SCHEDULED);
-            
-            ShowWindow(m_dialog.getWindowConfig().getHwndInfo2(),SW_SHOW);
+            m_globalConfig.setStarted( true );
 
             SendMessage(m_dialog.getWindowConfig().getHwndLoad(),PBM_SETBARCOLOR,0,0x00008000);
+            UpdateWindow(m_dialog.getWindowConfig().getHwndLoad());
 
+            // TODO: start update service previous to all other tasks ...
+            /*
+            ShowWindow(m_dialog.getWindowConfig().getHwndInfo2(),SW_SHOW);
             UpdateWindow(m_dialog.getWindowConfig().getHwndInfo2());
-            UpdateWindow(m_dialog.getWindowConfig().getHwndLoad());
+            
 
-            // start update service previous to all other tasks ...
-            rc = startUpdate();
+            rc = startMUpdate();
 
             ShowWindow(m_dialog.getWindowConfig().getHwndInfo2(),SW_HIDE);
             UpdateWindow(m_dialog.getWindowConfig().getHwndInfo2());
@@ -567,11 +539,12 @@ namespace mControl
                 PostQuitMessage(0);
                 return 0;
             }
+            */
 
             // execute system commands before starting platform
             execSysCmdsStartup();
 
-            rc = startAll();
+            rc = startMStarter();
             if( rc )
             {
                 std::stringstream sMsg ("");
@@ -595,6 +568,8 @@ namespace mControl
             if( m_processStarter->getStatus() == mSysProcess::STATUS_TERMINATED )
                 TRACE(HERE,"mStarter terminated");
         }
+
+        TRACE(HERE,"massaiStartScheduler(), done.\n");
         return 0;
     }
 
@@ -608,12 +583,12 @@ namespace mControl
         catch( alertException & e )
         {
             m_globalConfig.setAlert( NULL );
-            TRACE(HERE,"(create)alertException: %s",e.toString().c_str());
+            TRACE(MajorError_HERE,"(create)alertException: %s",e.toString().c_str());
         }
         catch( ... )
         {
             m_globalConfig.setAlert( NULL );
-            TRACE(HERE,"(create)alertException (unknown)");
+            TRACE(MajorError_HERE,"(create)alertException (unknown)");
         }
 
     } 
@@ -693,6 +668,8 @@ namespace mControl
 
     void Worker::waitInitialForLoggingService()
     {
+        TRACE(HERE,"waitInitialForLoggingService...");
+
         static bool init= false;
         if(!init)
         {
@@ -713,10 +690,21 @@ namespace mControl
             {
                 TRACE(HERE,"waitInitialForLoggingService failed: unknown exception");
             }
-
-            TRACE(HERE,"waitInitialForLoggingService done.");
             createAlert();
         }
         init= true;
+
+        TRACE(HERE,"waitInitialForLoggingService(), done.\n");
+    }
+
+
+    void Worker::signalStop()
+    {
+        if( m_stop_sem_handle )
+        {
+            SetEvent( m_stop_sem_handle );
+            CloseHandle( m_stop_sem_handle );
+            m_stop_sem_handle = NULL;
+        }
     }
 }
\ No newline at end of file
-- 
2.41.0.windows.1

