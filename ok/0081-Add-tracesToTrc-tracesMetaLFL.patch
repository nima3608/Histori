From b30ec6f16fc42d30117797ca0fd11f17a511a644 Mon Sep 17 00:00:00 2001
From: jkreierh <jkreierh@90b65887-3827-0410-9a23-83215b262276>
Date: Tue, 4 Jan 2011 16:36:26 +0000
Subject: [PATCH 0081/1076] Add "tracesToTrc" "tracesMetaLFL"

git-svn-id: svn://localhost/SelfServiceCommon/trunk@102 90b65887-3827-0410-9a23-83215b262276
---
 .../Interfaces/inc/Tools/tracesToTrc.hpp      | 105 ++++
 .../Massai/cpp/CfgXMgrB/src/traceLocal.cpp    |   6 +-
 .../Massai/cpp/Tools/makefile.mak             |   4 +-
 .../Massai/cpp/Tools/src/tracesMetaLFL.cpp    |  88 +++
 .../Massai/cpp/Tools/src/tracesToTrc.cpp      | 509 ++++++++++++++++++
 5 files changed, 707 insertions(+), 5 deletions(-)
 create mode 100644 SelfServiceCommon/Interfaces/inc/Tools/tracesToTrc.hpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Tools/src/tracesMetaLFL.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Tools/src/tracesToTrc.cpp

diff --git a/SelfServiceCommon/Interfaces/inc/Tools/tracesToTrc.hpp b/SelfServiceCommon/Interfaces/inc/Tools/tracesToTrc.hpp
new file mode 100644
index 00000000..aeb14e35
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/Tools/tracesToTrc.hpp
@@ -0,0 +1,105 @@
+/**
+ **************************************************************************
+ *
+ * @file tracesToTrc.hpp
+ *
+ * Class tracesToTrc::writer definition.
+ *
+ * Purpose of that class is to use the existing trace server
+ * infrastructure to write trace statements generated by the trace stream
+ * macros as defined in "tracesMac.hpp" and the stream class as defined
+ * in "traces.hpp".
+ *
+ * @author Juergen Kreierhoff
+ *
+ * Copyright (c) 2011 MATERNA Information & Communications
+ *
+ **************************************************************************
+**/
+#ifndef TRACESTOTRC_HPP
+#define TRACESTOTRC_HPP
+
+
+#include "traces.hpp"
+
+
+namespace tracesToTrc
+{
+
+   /**
+    *
+    * Trace writer implementation. By overloading the "writer" interface
+    * class it defines and implements the write() and currentLevel()
+    * methods.
+    *
+   **/
+   class writer : public traces::writer
+   {
+
+      //! Implementation class.
+      class impl;
+
+      //! Implementation object reference.
+      impl * const      M_Impl;
+
+      /**
+       *
+       * Implements virtual base class method.
+       *
+      **/
+      traces::level currentLevel() const;
+
+      /**
+       *
+       * Implements virtual base class method.
+       *
+      **/
+      void write
+         (
+            traces::meta const &        Meta,
+            char const *                Text
+         );
+
+   public:
+
+      /**
+       *
+       * Constructor.
+       *
+       * @param Name:           The application name, used for
+       *                        the traces configuration.
+       *
+      **/
+      explicit writer( char const * Name );
+
+      /**
+       *
+       * Destructor.
+       *
+      **/
+      virtual ~writer() throw();
+
+   private:
+
+      //! Default constructor - intentionally not implemented.
+      writer();
+
+      //! Copy constructor - intentionally not implemented.
+      writer( writer const & Src );
+
+      //! Assignment - intentionally not implemented.
+      writer& operator=( writer const & Src );
+
+   };
+
+} // namespace tracesToTrc
+
+
+#endif // #ifndef TRACESTOTRC_HPP
+/**
+ **************************************************************************
+ *
+ * End of file
+ *
+ **************************************************************************
+**/
diff --git a/SelfServiceCommon/Massai/cpp/CfgXMgrB/src/traceLocal.cpp b/SelfServiceCommon/Massai/cpp/CfgXMgrB/src/traceLocal.cpp
index 2b63d83d..62da11d4 100644
--- a/SelfServiceCommon/Massai/cpp/CfgXMgrB/src/traceLocal.cpp
+++ b/SelfServiceCommon/Massai/cpp/CfgXMgrB/src/traceLocal.cpp
@@ -77,7 +77,7 @@ namespace
 
 
 
-long _stdcall writeTrace
+void _stdcall writeTrace
 (
    long Level,
    char const *, short, char const *,
@@ -110,14 +110,13 @@ long _stdcall writeTrace
          << std::endl;
       X.release();
    }
-   return 0;
 }
 
 
 
 
 
-long _stdcall writeTraceText
+void _stdcall writeTraceText
 (
    long Level,
    char const *, short, char const *,
@@ -145,7 +144,6 @@ long _stdcall writeTraceText
          << std::endl;
       X.release();
    }
-   return 0;
 }
 
 
diff --git a/SelfServiceCommon/Massai/cpp/Tools/makefile.mak b/SelfServiceCommon/Massai/cpp/Tools/makefile.mak
index 66a9ae2c..4501e7ee 100644
--- a/SelfServiceCommon/Massai/cpp/Tools/makefile.mak
+++ b/SelfServiceCommon/Massai/cpp/Tools/makefile.mak
@@ -25,7 +25,9 @@ MY_LIB1_OBJS =          $(_OBJ)\mHRTimerW32.obj \
                         $(_OBJ)\TraceInterface.obj \
                         $(_OBJ)\TraceDelegate.obj \
                         $(_OBJ)\TraceClient.obj \
-                        $(_OBJ)\TraceHandle.obj
+                        $(_OBJ)\TraceHandle.obj \
+                        $(_OBJ)\tracesMetaLFL.obj \
+                        $(_OBJ)\tracesToTrc.obj
 
 ######################################################################
 
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/tracesMetaLFL.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/tracesMetaLFL.cpp
new file mode 100644
index 00000000..3c123a0e
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/tracesMetaLFL.cpp
@@ -0,0 +1,88 @@
+/**
+ **************************************************************************
+ *
+ * @file tracesMetaLFL.cpp
+ *
+ * Implement traces::metaLFL constructor.
+ *
+ * The class traces::metaLFL defines an application default for the
+ * format of traces::meta information as it will be written into a trace
+ * file.
+ *
+ * @author Juergen Kreierhoff
+ *
+ * Copyright (c) 2011 MATERNA Information & Communications
+ *
+ **************************************************************************
+**/
+
+#include "tracesMac.hpp"
+
+
+
+namespace
+{
+
+
+   /**
+    *
+    * Create a trace header from FILE and LINE data.
+    *
+    * @param F:         Filename from __FILE__ macro.
+    *
+    * @param L:         Source line from __LINE__ macro.
+    *
+    * @return:          A pretty trace line header.
+    *
+   **/
+   std::string makeFL( char const * F, int L )
+   {
+      std::string File( F );
+      // Strip path info
+      std::string::size_type const Slash = File.find_last_of( "\\" );
+      if( Slash != std::string::npos )
+         File = File.substr( Slash + 1 );
+      // Strip extension
+      std::string::size_type const Dot = File.find_last_of( "." );
+      if( Slash != std::string::npos )
+         File = File.substr( 0, Dot );
+      //
+      std::ostringstream R;
+      R << File << "(" << L << "):";
+      // To align trace data fill with spaces to get a min size of 30.
+      int Ind = 30 - static_cast<int>( R.str().size() );
+      while( --Ind >= 0 ) R << " ";
+      return R.str();
+   }
+
+
+}
+
+
+
+/**
+ *
+ * Traces macro class constructor.
+ *
+ * @param Lvl:          The trace level to meet for this statement.
+ *
+ * @param Fil:          The source file name.
+ *
+ * @param Lin:          The line number in the source file.
+ *
+**/
+traces::metaLFL::metaLFL( traces::level Lvl, char const * Fil, int Lin ) :
+   M_Level( Lvl ),
+   M_Formatted( makeFL( Fil, Lin ) )
+{
+}
+
+
+
+/**
+ **************************************************************************
+ *
+ * End of file
+ *
+ **************************************************************************
+**/
diff --git a/SelfServiceCommon/Massai/cpp/Tools/src/tracesToTrc.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/tracesToTrc.cpp
new file mode 100644
index 00000000..98c422c3
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Tools/src/tracesToTrc.cpp
@@ -0,0 +1,509 @@
+/**
+ **************************************************************************
+ *
+ * @file tracesToTrc.cpp
+ *
+ * Implements class tracesToTrc::writer.
+ *
+ * @author Juergen Kreierhoff
+ *
+ * Copyright (c) 2011 MATERNA Information & Communications
+ *
+ **************************************************************************
+**/
+#include "Tools/tracesToTrc.hpp"
+
+#include "mAutoMutex.hpp"
+#include "nConfigCache.hpp"
+#include "nConfigNumber.hpp"
+#include "nConfigSelection.hpp"
+#include "nConfigText.hpp"
+#include "Tools/tracesMac.hpp"
+#include "TrcHdlClt.h"
+#include "Tools/TraceHandle.h"
+
+#include <iostream>
+#include <string>
+
+// For SYSTEMTIME
+#include <windows.h>
+
+
+
+namespace
+{
+
+
+   MASSAI::trace::TraceHandle * L_TraceHandle = 0;
+
+
+   /**
+    *
+    * List of possible trace level selections.
+    *
+   **/
+   nConfig::selection const CfgTraceLevelValues[] =
+   {
+      nConfig::selection( 0, "Level 0", "No traces (lowest level)" ),
+      nConfig::selection( 1, "Level 1", "Major error" ),
+      nConfig::selection( 2, "Level 2", "Minor error" ),
+      nConfig::selection( 3, "Level 3", "Major warning" ),
+      nConfig::selection( 4, "Level 4", "Minor warning" ),
+      nConfig::selection( 5, "Level 5", "Basic runtime" ),
+      nConfig::selection( 6, "Level 6", "Basic process" ),
+      nConfig::selection( 7, "Level 7", "Secondary runtime" ),
+      nConfig::selection( 8, "Level 8",
+         "Secondary frequent (highest level, show all)" )
+   };
+
+
+   /**
+    *
+    * Tracelevel configuration class.
+    *
+   **/
+   class cfgTraceLevel :
+      public nConfig::cache<traces::level,nConfig::gclSelection>
+   {
+
+      traces::level uncached()
+      {
+         switch( getIndex() )
+         {
+         default:
+         case 0: return traces::Lvl_None;
+         case 1: return traces::Lvl_MajorError;
+         case 2: return traces::Lvl_MinorError;
+         case 3: return  traces::Lvl_MajorWarning;
+         case 4: return  traces::Lvl_MinorWarning;
+         case 5: return  traces::Lvl_BasicRuntime;
+         case 6: return  traces::Lvl_BasicProcess;
+         case 7: return  traces::Lvl_SecondaryRuntime;
+         case 8: return  traces::Lvl_SecondaryFrequent;
+         }
+      }
+
+   protected:
+
+     /**
+      *
+      * This method is called, when the configuration subsystem needs
+      * to create a new configuration item.
+      *
+     **/
+      void create
+           (
+              char const * &               Rights,
+              char const * &               Explanation,
+              long &                       DefaultNdx,
+              nConfig::selection const * & Begin,
+              nConfig::selection const * & End
+           )
+      {
+         Rights = 0;         // Use the default
+         Explanation = "Select the amount of trace entries to be written.";
+         DefaultNdx = 5; // Basic runtime
+         Begin = CfgTraceLevelValues;
+         End = CfgTraceLevelValues
+             + sizeof(CfgTraceLevelValues)/sizeof(nConfig::selection);
+      }
+
+   public:
+
+      cfgTraceLevel
+         (
+            std::string const & L_ConfigClientName,
+            std::string const & Item
+         ) :
+         nConfig::cache<traces::level,nConfig::gclSelection>
+         (
+            Item.c_str(),
+            L_ConfigClientName.c_str()
+         )
+      {
+      }
+
+   private:
+
+      cfgTraceLevel();
+
+   };
+
+
+   /**
+    *
+    * Trace file maximum size configuration class.
+    *
+   **/
+   class cfgTraceMaxFilesize :
+      public nConfig::cache<unsigned int,nConfig::gclNumber>
+   {
+
+      //! Called by nConfig::cache template to get the value.
+      unsigned int uncached()
+      {
+         return static_cast<unsigned int>( get() );
+      }
+
+   protected:
+
+      //! Called by the configuration client library to create the item.
+      void create
+         (
+            char const * & Rights,
+            char const * & Explanation,
+            long &         Def,
+            long &         Min,
+            long &         Max
+         )
+      {
+         Rights = "rwl";
+         Explanation = "Enter the maximum size in bytes, to which a trace"
+                       " file may grow before it is closed and a new trace"
+                       " file is used. Please note: Values below 1000 will"
+                       " not be accepted.";
+         Def = 10000000;        // Default to 10MB.
+         Min = 1000;            // A ridiculous minimum.
+         Max = LONG_MAX;
+      }
+
+   public:
+
+      //! Constructor.
+      cfgTraceMaxFilesize
+         (
+            std::string const & L_ConfigClientName,
+            std::string const & Item
+         ) :
+         nConfig::cache<unsigned int,nConfig::gclNumber>
+         (
+            Item.c_str(),
+            L_ConfigClientName.c_str()
+         )
+      {
+      }
+
+   private:
+
+      //! Default constructor - intentionally not implemented.
+      cfgTraceMaxFilesize();
+
+   };
+
+
+   /**
+    *
+    * Trace path configuration class.
+    *
+   **/
+   class cfgTracePath :
+      public nConfig::cache<std::string,nConfig::gclText>
+   {
+
+      //! Called by nConfig::cache template to get the value.
+      std::string uncached()
+      {
+         return get();
+      }
+
+   protected:
+
+      //! Called by the configuration client library to create the item.
+      void create
+         (
+            char const * & Rights,
+            char const * & Explanation,
+            char const * & Def
+         )
+      {
+         Rights = "rwl";
+         Explanation = "Enter the root path for traces. Trace files will"
+                       " be created here or in subdirectories.";
+         Def = "trc";
+      }
+
+   public:
+
+      //! Constructor.
+      cfgTracePath
+         (
+            std::string const & L_ConfigClientName,
+            std::string const & Item
+         ) :
+         nConfig::cache<std::string,nConfig::gclText>
+         (
+            Item.c_str(),
+            L_ConfigClientName.c_str()
+         )
+      {
+      }
+
+   private:
+
+      //! Default constructor - intentionally not implemented.
+      cfgTracePath();
+
+   };
+
+
+   /**
+    *
+    * List of possible trace level selections.
+    *
+   **/
+   nConfig::selection const CfgTraceToConsole[] =
+   {
+      nConfig::selection( 0, "No", "Quiescent console" ),
+      nConfig::selection( 1, "Yes", "Duplicate trace output to console" )
+   };
+
+
+   /**
+    *
+    * Tracelevel configuration class.
+    *
+   **/
+   class cfgTraceToConsole :
+      public nConfig::cache<bool,nConfig::gclSelection>
+   {
+
+      bool uncached()
+      {
+         switch( getIndex() )
+         {
+         default:
+         case 0: return false;
+         case 1: return true;
+         }
+      }
+
+   protected:
+
+     /**
+      *
+      * This method is called, when the configuration subsystem needs
+      * to create a new configuration item.
+      *
+     **/
+      void create
+           (
+              char const * &               Rights,
+              char const * &               Explanation,
+              long &                       DefaultNdx,
+              nConfig::selection const * & Begin,
+              nConfig::selection const * & End
+           )
+      {
+         Rights = 0;         // Use the default
+         Explanation = "Shall traces be written to the console too?";
+         DefaultNdx = 0; // No
+         Begin = CfgTraceToConsole;
+         End = CfgTraceToConsole
+             + sizeof(CfgTraceToConsole)/sizeof(nConfig::selection);
+      }
+
+   public:
+
+      cfgTraceToConsole
+         (
+            std::string const & L_ConfigClientName,
+            std::string const & Item
+         ) :
+         nConfig::cache<bool,nConfig::gclSelection>
+         (
+            Item.c_str(),
+            L_ConfigClientName.c_str()
+         )
+      {
+      }
+
+   private:
+
+      cfgTraceToConsole();
+
+   };
+
+
+}
+
+
+
+MASSAI::trace::TraceInterface * getTraceInterface()
+{
+   return L_TraceHandle;
+}
+
+
+
+/**
+ *
+ * Writer implementation class.
+ *
+**/
+class tracesToTrc::writer::impl
+{
+
+   //! Holds the complete configuration path prefix.
+   std::string const                    M_APrefix;
+
+   Materna::MSSD::mutexSemaphore        M_Mutex;
+
+   //! Trace level configuration object.
+   cfgTraceLevel                        M_TraceLevel;
+
+   //! Trace file size maximum configuration object.
+   cfgTraceMaxFilesize                  M_TraceMaxFilesize;
+
+   //! Trace path configuration object.
+   cfgTracePath                         M_TracePath;
+
+   //! Trace to console configuration object.
+   cfgTraceToConsole                    M_TraceToConsole;
+
+   trcHandle                            M_TrcHdl;
+
+public:
+
+   //! Constructor.
+   explicit impl( char const * Name ) :
+      M_APrefix
+         (
+            std::string( Name ) + ".Trace control."
+         ),
+      M_Mutex(),
+      M_TraceLevel( Name, M_APrefix + "Tracelevel" ),
+      M_TraceMaxFilesize( Name, M_APrefix + "File size maximum" ),
+      M_TracePath( Name, M_APrefix + "File path" ),
+      M_TraceToConsole( Name, M_APrefix + "To console" ),
+      M_TrcHdl( openTrace( Name ) )
+   {
+      if( !L_TraceHandle )
+      {
+         L_TraceHandle = new MASSAI::trace::TraceHandle( M_TrcHdl );
+      }
+   }
+
+   ~impl()
+   {
+      try
+      {
+         delete L_TraceHandle;
+         L_TraceHandle = 0;
+         closeTrace( M_TrcHdl );
+      }
+      catch( ... )
+      {
+      }
+   }
+
+   //! Implementation class method - like interface class method.
+   traces::level currentLevel()
+   {
+      return M_TraceLevel.cached();
+   }
+
+   //! Implementation class method - like interface class method.
+   void write( char const * Entry ) throw()
+   {
+      try
+      {
+         //
+         SYSTEMTIME T;
+         GetLocalTime( &T );
+         char Timestamp[32];
+         sprintf
+            (
+               Timestamp, "%02d.%02d.%04d %02d:%02d:%02d.%02d ",
+               T.wDay, T.wMonth, T.wYear,
+               T.wHour, T.wMinute, T.wSecond, T.wMilliseconds / 10
+            );
+         //
+         std::string AllEntry = Timestamp;
+         AllEntry += Entry;
+         //
+         if( M_TraceToConsole.cached() )
+         {
+            // Do not re-enter.
+            Materna::MSSD::autoMutex AutoMutex( M_Mutex );
+            std::cout << AllEntry << std::endl;
+         }
+         writeTraceCooked( M_TrcHdl, AllEntry.c_str() );
+      }
+      catch( ... )
+      {
+      }
+   }
+
+private:
+
+   //! Default constructor - intentionally not implemented.
+   impl();
+
+   //! Copy constructor - intentionally not implemented.
+   impl( impl const & Src );
+
+   //! Assignment - intentionally not implemented.
+   impl & operator=( impl const & Src );
+
+};
+
+
+
+// Method implementation - see "gciTrace.hpp"
+traces::level tracesToTrc::writer::currentLevel() const
+{
+   return M_Impl->currentLevel();
+}
+
+
+
+// Method implementation, see "tracesToTrc.hpp".
+void tracesToTrc::writer::write
+   (
+      traces::meta const &      Meta,
+      char const *              Text
+   )
+{
+   // Source-file-line information
+   std::string TraceBuffer = Meta.getFormatted();
+   // Trace entry
+   TraceBuffer += Text;
+   M_Impl->write( TraceBuffer.c_str() );
+}
+
+
+
+// Method implementation, see "tracesToTrc.hpp".
+tracesToTrc::writer::writer
+   (
+      char const *              Filename
+   ) :
+   M_Impl( new impl( Filename ) )
+{
+}
+
+
+
+// Method implementation, see "tracesToTrc.hpp".
+tracesToTrc::writer::~writer() throw()
+{
+   try
+   {
+      delete M_Impl;
+   }
+   catch( ... )
+   {
+   }
+}
+
+
+
+
+
+/**
+ **************************************************************************
+ *
+ * End of file
+ *
+ **************************************************************************
+**/
-- 
2.41.0.windows.1

