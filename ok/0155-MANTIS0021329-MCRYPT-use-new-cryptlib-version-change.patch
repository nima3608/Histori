From 5a0039897336fd8fc8a028940f4ae8a6ad267a03 Mon Sep 17 00:00:00 2001
From: tgeisler <tgeisler@90b65887-3827-0410-9a23-83215b262276>
Date: Fri, 21 Oct 2011 14:57:42 +0000
Subject: [PATCH 0155/1076] MANTIS0021329: MCRYPT use new cryptlib version +
 changes for VC10 compatibilty Crypto++ Library 5.6.1

git-svn-id: svn://localhost/SelfServiceCommon/trunk@196 90b65887-3827-0410-9a23-83215b262276
---
 SelfServiceCommon/Massai/cpp/Mcrypt/inc/aes.h |   16 +
 .../Massai/cpp/Mcrypt/inc/algebra.h           |  560 +-
 .../Massai/cpp/Mcrypt/inc/algparam.h          |  723 +-
 .../Massai/cpp/Mcrypt/inc/argnames.h          |  135 +-
 SelfServiceCommon/Massai/cpp/Mcrypt/inc/asn.h |  715 +-
 .../Massai/cpp/Mcrypt/inc/basecode.h          |  168 +-
 .../Massai/cpp/Mcrypt/inc/config.h            |  709 +-
 SelfServiceCommon/Massai/cpp/Mcrypt/inc/cpu.h |  345 +
 .../Massai/cpp/Mcrypt/inc/cryptlib.h          | 3219 +++----
 .../Massai/cpp/Mcrypt/inc/default.h           |  209 +-
 SelfServiceCommon/Massai/cpp/Mcrypt/inc/des.h |  277 +-
 .../Massai/cpp/Mcrypt/inc/eprecomp.h          |  144 +-
 .../Massai/cpp/Mcrypt/inc/files.h             |  207 +-
 .../Massai/cpp/Mcrypt/inc/filters.h           | 1498 +--
 .../Massai/cpp/Mcrypt/inc/fips140.h           |  106 +-
 .../Massai/cpp/Mcrypt/inc/fltrimpl.h          |  109 +-
 SelfServiceCommon/Massai/cpp/Mcrypt/inc/hex.h |   72 +-
 .../Massai/cpp/Mcrypt/inc/hmac.h              |  180 +-
 .../Massai/cpp/Mcrypt/inc/integer.h           |  859 +-
 .../Massai/cpp/Mcrypt/inc/iterhash.h          |  227 +-
 .../Massai/cpp/Mcrypt/inc/misc.h              | 1970 ++--
 .../Massai/cpp/Mcrypt/inc/modarith.h          |  307 +-
 .../Massai/cpp/Mcrypt/inc/modes.h             |  792 +-
 .../Massai/cpp/Mcrypt/inc/modexppc.h          |   66 +-
 .../Massai/cpp/Mcrypt/inc/mqueue.h            |  198 +-
 .../Massai/cpp/Mcrypt/inc/nbtheory.h          |  274 +-
 .../Massai/cpp/Mcrypt/inc/oids.h              |  235 +-
 .../Massai/cpp/Mcrypt/inc/osrng.h             |  156 +
 SelfServiceCommon/Massai/cpp/Mcrypt/inc/pch.h |   21 +
 .../Massai/cpp/Mcrypt/inc/pubkey.h            | 3386 ++++---
 .../Massai/cpp/Mcrypt/inc/queue.h             |  271 +-
 .../Massai/cpp/Mcrypt/inc/randpool.h          |   33 +
 .../Massai/cpp/Mcrypt/inc/rijndael.h          |   68 +
 SelfServiceCommon/Massai/cpp/Mcrypt/inc/rng.h |   77 +
 .../Massai/cpp/Mcrypt/inc/secblock.h          |  852 +-
 .../Massai/cpp/Mcrypt/inc/seckey.h            |  458 +-
 SelfServiceCommon/Massai/cpp/Mcrypt/inc/sha.h |  135 +-
 .../Massai/cpp/Mcrypt/inc/simple.h            |  439 +-
 .../Massai/cpp/Mcrypt/inc/smartptr.h          |  438 +-
 .../Massai/cpp/Mcrypt/inc/stdcpp.h            |   41 +
 .../Massai/cpp/Mcrypt/inc/strciphr.h          |  594 +-
 .../Massai/cpp/Mcrypt/inc/trdlocal.h          |   44 +
 .../Massai/cpp/Mcrypt/inc/words.h             |  206 +-
 .../Massai/cpp/Mcrypt/makefile.mak            |    3 +-
 .../Massai/cpp/Mcrypt/src/algebra.cpp         |  680 +-
 .../Massai/cpp/Mcrypt/src/algparam.cpp        |   85 +-
 .../Massai/cpp/Mcrypt/src/basecode.cpp        |  466 +-
 .../Massai/cpp/Mcrypt/src/cpu.cpp             |  199 +
 .../Massai/cpp/Mcrypt/src/cryptlib.cpp        | 1518 +--
 .../Massai/cpp/Mcrypt/src/default.cpp         |  516 +-
 .../Massai/cpp/Mcrypt/src/des.cpp             |  913 +-
 .../Massai/cpp/Mcrypt/src/dessp.cpp           |  185 +-
 .../Massai/cpp/Mcrypt/src/eprecomp.cpp        |  219 +-
 .../Massai/cpp/Mcrypt/src/files.cpp           |  445 +-
 .../Massai/cpp/Mcrypt/src/filters.cpp         | 2017 ++--
 .../Massai/cpp/Mcrypt/src/hex.cpp             |   76 +-
 .../Massai/cpp/Mcrypt/src/integer.cpp         | 8239 +++++++++--------
 .../Massai/cpp/Mcrypt/src/iterhash.cpp        |  282 +-
 .../Massai/cpp/Mcrypt/src/misc.cpp            |  270 +-
 .../Massai/cpp/Mcrypt/src/modes.cpp           |  511 +-
 .../Massai/cpp/Mcrypt/src/mqueue.cpp          |  356 +-
 .../Massai/cpp/Mcrypt/src/osrng.cpp           |  171 +
 .../Massai/cpp/Mcrypt/src/pch.cpp             |    1 +
 .../Massai/cpp/Mcrypt/src/queue.cpp           | 1083 +--
 .../Massai/cpp/Mcrypt/src/randpool.cpp        |   63 +
 .../Massai/cpp/Mcrypt/src/rijndael.cpp        | 1257 +++
 .../Massai/cpp/Mcrypt/src/rng.cpp             |  155 +
 .../Massai/cpp/Mcrypt/src/sha.cpp             | 1177 ++-
 .../Massai/cpp/Mcrypt/src/strciphr.cpp        |  440 +-
 .../Massai/cpp/Mcrypt/src/trdlocal.cpp        |   73 +
 70 files changed, 24250 insertions(+), 18689 deletions(-)
 create mode 100644 SelfServiceCommon/Massai/cpp/Mcrypt/inc/aes.h
 create mode 100644 SelfServiceCommon/Massai/cpp/Mcrypt/inc/cpu.h
 create mode 100644 SelfServiceCommon/Massai/cpp/Mcrypt/inc/osrng.h
 create mode 100644 SelfServiceCommon/Massai/cpp/Mcrypt/inc/pch.h
 create mode 100644 SelfServiceCommon/Massai/cpp/Mcrypt/inc/randpool.h
 create mode 100644 SelfServiceCommon/Massai/cpp/Mcrypt/inc/rijndael.h
 create mode 100644 SelfServiceCommon/Massai/cpp/Mcrypt/inc/rng.h
 create mode 100644 SelfServiceCommon/Massai/cpp/Mcrypt/inc/stdcpp.h
 create mode 100644 SelfServiceCommon/Massai/cpp/Mcrypt/inc/trdlocal.h
 create mode 100644 SelfServiceCommon/Massai/cpp/Mcrypt/src/cpu.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Mcrypt/src/osrng.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Mcrypt/src/pch.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Mcrypt/src/randpool.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Mcrypt/src/rijndael.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Mcrypt/src/rng.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Mcrypt/src/trdlocal.cpp

diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/aes.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/aes.h
new file mode 100644
index 00000000..00875425
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/aes.h
@@ -0,0 +1,16 @@
+#ifndef CRYPTOPP_AES_H
+#define CRYPTOPP_AES_H
+
+#include "rijndael.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+//! <a href="http://www.cryptolounge.org/wiki/AES">AES</a> winner, announced on 10/2/2000
+DOCUMENTED_TYPEDEF(Rijndael, AES);
+
+typedef RijndaelEncryption AESEncryption;
+typedef RijndaelDecryption AESDecryption;
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/algebra.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/algebra.h
index cc417f2b..13038bd8 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/algebra.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/algebra.h
@@ -1,275 +1,285 @@
-#ifndef CRYPTOPP_ALGEBRA_H
-#define CRYPTOPP_ALGEBRA_H
-
-#include "config.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-class Integer;
-
-// "const Element&" returned by member functions are references
-// to internal data members. Since each object may have only
-// one such data member for holding results, the following code
-// will produce incorrect results:
-// abcd = group.Add(group.Add(a,b), group.Add(c,d));
-// But this should be fine:
-// abcd = group.Add(a, group.Add(b, group.Add(c,d));
-
-//! Abstract Group
-template <class T> class AbstractGroup
-{
-public:
-	typedef T Element;
-
-	virtual ~AbstractGroup() {}
-
-	virtual bool Equal(const Element &a, const Element &b) const =0;
-	virtual const Element& Identity() const =0;
-	virtual const Element& Add(const Element &a, const Element &b) const =0;
-	virtual const Element& Inverse(const Element &a) const =0;
-	virtual bool InversionIsFast() const {return false;}
-
-	virtual const Element& Double(const Element &a) const;
-	virtual const Element& Subtract(const Element &a, const Element &b) const;
-	virtual Element& Accumulate(Element &a, const Element &b) const;
-	virtual Element& Reduce(Element &a, const Element &b) const;
-
-	virtual Element ScalarMultiply(const Element &a, const Integer &e) const;
-	virtual Element CascadeScalarMultiply(const Element &x, const Integer &e1, const Element &y, const Integer &e2) const;
-
-	virtual void SimultaneousMultiply(Element *results, const Element &base, const Integer *exponents, unsigned int exponentsCount) const;
-};
-
-//! Abstract Ring
-template <class T> class AbstractRing : public AbstractGroup<T>
-{
-public:
-	typedef T Element;
-
-	AbstractRing() {m_mg.m_pRing = this;}
-	AbstractRing(const AbstractRing &source) {m_mg.m_pRing = this;}
-	AbstractRing& operator=(const AbstractRing &source) {return *this;}
-
-	virtual bool IsUnit(const Element &a) const =0;
-	virtual const Element& MultiplicativeIdentity() const =0;
-	virtual const Element& Multiply(const Element &a, const Element &b) const =0;
-	virtual const Element& MultiplicativeInverse(const Element &a) const =0;
-
-	virtual const Element& Square(const Element &a) const;
-	virtual const Element& Divide(const Element &a, const Element &b) const;
-
-	virtual Element Exponentiate(const Element &a, const Integer &e) const;
-	virtual Element CascadeExponentiate(const Element &x, const Integer &e1, const Element &y, const Integer &e2) const;
-
-	virtual void SimultaneousExponentiate(Element *results, const Element &base, const Integer *exponents, unsigned int exponentsCount) const;
-
-	virtual const AbstractGroup<T>& MultiplicativeGroup() const
-		{return m_mg;}
-
-private:
-	class MultiplicativeGroupT : public AbstractGroup<T>
-	{
-	public:
-		const AbstractRing<T>& GetRing() const
-			{return *m_pRing;}
-
-		bool Equal(const Element &a, const Element &b) const
-			{return GetRing().Equal(a, b);}
-
-		const Element& Identity() const
-			{return GetRing().MultiplicativeIdentity();}
-
-		const Element& Add(const Element &a, const Element &b) const
-			{return GetRing().Multiply(a, b);}
-
-		Element& Accumulate(Element &a, const Element &b) const
-			{return a = GetRing().Multiply(a, b);}
-
-		const Element& Inverse(const Element &a) const
-			{return GetRing().MultiplicativeInverse(a);}
-
-		const Element& Subtract(const Element &a, const Element &b) const
-			{return GetRing().Divide(a, b);}
-
-		Element& Reduce(Element &a, const Element &b) const
-			{return a = GetRing().Divide(a, b);}
-
-		const Element& Double(const Element &a) const
-			{return GetRing().Square(a);}
-
-		Element ScalarMultiply(const Element &a, const Integer &e) const
-			{return GetRing().Exponentiate(a, e);}
-
-		Element CascadeScalarMultiply(const Element &x, const Integer &e1, const Element &y, const Integer &e2) const
-			{return GetRing().CascadeExponentiate(x, e1, y, e2);}
-
-		void SimultaneousMultiply(Element *results, const Element &base, const Integer *exponents, unsigned int exponentsCount) const
-			{GetRing().SimultaneousExponentiate(results, base, exponents, exponentsCount);}
-
-		const AbstractRing<T> *m_pRing;
-	};
-
-	MultiplicativeGroupT m_mg;
-};
-
-// ********************************************************
-
-//! Base and Exponent
-template <class T, class E = Integer>
-struct BaseAndExponent
-{
-public:
-	BaseAndExponent() {}
-	BaseAndExponent(const T &base, const E &exponent) : base(base), exponent(exponent) {}
-	bool operator<(const BaseAndExponent<T, E> &rhs) const {return exponent < rhs.exponent;}
-	T base;
-	E exponent;
-};
-
-// VC60 workaround: incomplete member template support
-template <class Element, class Iterator>
-	Element GeneralCascadeMultiplication(const AbstractGroup<Element> &group, Iterator begin, Iterator end);
-template <class Element, class Iterator>
-	Element GeneralCascadeExponentiation(const AbstractRing<Element> &ring, Iterator begin, Iterator end);
-
-// ********************************************************
-
-//! Abstract Euclidean Domain
-template <class T> class AbstractEuclideanDomain : public AbstractRing<T>
-{
-public:
-	typedef T Element;
-
-	virtual void DivisionAlgorithm(Element &r, Element &q, const Element &a, const Element &d) const =0;
-
-	virtual const Element& Mod(const Element &a, const Element &b) const =0;
-	virtual const Element& Gcd(const Element &a, const Element &b) const;
-
-protected:
-	mutable Element result;
-};
-
-// ********************************************************
-
-//! EuclideanDomainOf
-template <class T> class EuclideanDomainOf : public AbstractEuclideanDomain<T>
-{
-public:
-	typedef T Element;
-
-	EuclideanDomainOf() {}
-
-	bool Equal(const Element &a, const Element &b) const
-		{return a==b;}
-
-	const Element& Identity() const
-		{return Element::Zero();}
-
-	const Element& Add(const Element &a, const Element &b) const
-		{return result = a+b;}
-
-	Element& Accumulate(Element &a, const Element &b) const
-		{return a+=b;}
-
-	const Element& Inverse(const Element &a) const
-		{return result = -a;}
-
-	const Element& Subtract(const Element &a, const Element &b) const
-		{return result = a-b;}
-
-	Element& Reduce(Element &a, const Element &b) const
-		{return a-=b;}
-
-	const Element& Double(const Element &a) const
-		{return result = a.Doubled();}
-
-	const Element& MultiplicativeIdentity() const
-		{return Element::One();}
-
-	const Element& Multiply(const Element &a, const Element &b) const
-		{return result = a*b;}
-
-	const Element& Square(const Element &a) const
-		{return result = a.Squared();}
-
-	bool IsUnit(const Element &a) const
-		{return a.IsUnit();}
-
-	const Element& MultiplicativeInverse(const Element &a) const
-		{return result = a.MultiplicativeInverse();}
-
-	const Element& Divide(const Element &a, const Element &b) const
-		{return result = a/b;}
-
-	const Element& Mod(const Element &a, const Element &b) const
-		{return result = a%b;}
-
-	void DivisionAlgorithm(Element &r, Element &q, const Element &a, const Element &d) const
-		{Element::Divide(r, q, a, d);}
-
-private:
-	mutable Element result;
-};
-
-//! Quotient Ring
-template <class T> class QuotientRing : public AbstractRing<typename T::Element>
-{
-public:
-	typedef T EuclideanDomain;
-	typedef typename T::Element Element;
-
-	QuotientRing(const EuclideanDomain &domain, const Element &modulus)
-		: m_domain(domain), m_modulus(modulus) {}
-
-	const EuclideanDomain & GetDomain() const
-		{return m_domain;}
-
-	const Element& GetModulus() const
-		{return m_modulus;}
-
-	bool Equal(const Element &a, const Element &b) const
-		{return m_domain.Equal(m_domain.Mod(m_domain.Subtract(a, b), m_modulus), m_domain.Identity());}
-
-	const Element& Identity() const
-		{return m_domain.Identity();}
-
-	const Element& Add(const Element &a, const Element &b) const
-		{return m_domain.Add(a, b);}
-
-	Element& Accumulate(Element &a, const Element &b) const
-		{return m_domain.Accumulate(a, b);}
-
-	const Element& Inverse(const Element &a) const
-		{return m_domain.Inverse(a);}
-
-	const Element& Subtract(const Element &a, const Element &b) const
-		{return m_domain.Subtract(a, b);}
-
-	Element& Reduce(Element &a, const Element &b) const
-		{return m_domain.Reduce(a, b);}
-
-	const Element& Double(const Element &a) const
-		{return m_domain.Double(a);}
-
-	bool IsUnit(const Element &a) const
-		{return m_domain.IsUnit(m_domain.Gcd(a, m_modulus));}
-
-	const Element& MultiplicativeIdentity() const
-		{return m_domain.MultiplicativeIdentity();}
-
-	const Element& Multiply(const Element &a, const Element &b) const
-		{return m_domain.Mod(m_domain.Multiply(a, b), m_modulus);}
-
-	const Element& Square(const Element &a) const
-		{return m_domain.Mod(m_domain.Square(a), m_modulus);}
-
-	const Element& MultiplicativeInverse(const Element &a) const;
-
-protected:
-	EuclideanDomain m_domain;
-	Element m_modulus;
-};
-
-NAMESPACE_END
-
-#endif
+#ifndef CRYPTOPP_ALGEBRA_H
+#define CRYPTOPP_ALGEBRA_H
+
+#include "config.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+class Integer;
+
+// "const Element&" returned by member functions are references
+// to internal data members. Since each object may have only
+// one such data member for holding results, the following code
+// will produce incorrect results:
+// abcd = group.Add(group.Add(a,b), group.Add(c,d));
+// But this should be fine:
+// abcd = group.Add(a, group.Add(b, group.Add(c,d));
+
+//! Abstract Group
+template <class T> class CRYPTOPP_NO_VTABLE AbstractGroup
+{
+public:
+	typedef T Element;
+
+	virtual ~AbstractGroup() {}
+
+	virtual bool Equal(const Element &a, const Element &b) const =0;
+	virtual const Element& Identity() const =0;
+	virtual const Element& Add(const Element &a, const Element &b) const =0;
+	virtual const Element& Inverse(const Element &a) const =0;
+	virtual bool InversionIsFast() const {return false;}
+
+	virtual const Element& Double(const Element &a) const;
+	virtual const Element& Subtract(const Element &a, const Element &b) const;
+	virtual Element& Accumulate(Element &a, const Element &b) const;
+	virtual Element& Reduce(Element &a, const Element &b) const;
+
+	virtual Element ScalarMultiply(const Element &a, const Integer &e) const;
+	virtual Element CascadeScalarMultiply(const Element &x, const Integer &e1, const Element &y, const Integer &e2) const;
+
+	virtual void SimultaneousMultiply(Element *results, const Element &base, const Integer *exponents, unsigned int exponentsCount) const;
+};
+
+//! Abstract Ring
+template <class T> class CRYPTOPP_NO_VTABLE AbstractRing : public AbstractGroup<T>
+{
+public:
+	typedef T Element;
+
+	AbstractRing() {m_mg.m_pRing = this;}
+	AbstractRing(const AbstractRing &source) {m_mg.m_pRing = this;}
+	AbstractRing& operator=(const AbstractRing &source) {return *this;}
+
+	virtual bool IsUnit(const Element &a) const =0;
+	virtual const Element& MultiplicativeIdentity() const =0;
+	virtual const Element& Multiply(const Element &a, const Element &b) const =0;
+	virtual const Element& MultiplicativeInverse(const Element &a) const =0;
+
+	virtual const Element& Square(const Element &a) const;
+	virtual const Element& Divide(const Element &a, const Element &b) const;
+
+	virtual Element Exponentiate(const Element &a, const Integer &e) const;
+	virtual Element CascadeExponentiate(const Element &x, const Integer &e1, const Element &y, const Integer &e2) const;
+
+	virtual void SimultaneousExponentiate(Element *results, const Element &base, const Integer *exponents, unsigned int exponentsCount) const;
+
+	virtual const AbstractGroup<T>& MultiplicativeGroup() const
+		{return m_mg;}
+
+private:
+	class MultiplicativeGroupT : public AbstractGroup<T>
+	{
+	public:
+		const AbstractRing<T>& GetRing() const
+			{return *m_pRing;}
+
+		bool Equal(const Element &a, const Element &b) const
+			{return GetRing().Equal(a, b);}
+
+		const Element& Identity() const
+			{return GetRing().MultiplicativeIdentity();}
+
+		const Element& Add(const Element &a, const Element &b) const
+			{return GetRing().Multiply(a, b);}
+
+		Element& Accumulate(Element &a, const Element &b) const
+			{return a = GetRing().Multiply(a, b);}
+
+		const Element& Inverse(const Element &a) const
+			{return GetRing().MultiplicativeInverse(a);}
+
+		const Element& Subtract(const Element &a, const Element &b) const
+			{return GetRing().Divide(a, b);}
+
+		Element& Reduce(Element &a, const Element &b) const
+			{return a = GetRing().Divide(a, b);}
+
+		const Element& Double(const Element &a) const
+			{return GetRing().Square(a);}
+
+		Element ScalarMultiply(const Element &a, const Integer &e) const
+			{return GetRing().Exponentiate(a, e);}
+
+		Element CascadeScalarMultiply(const Element &x, const Integer &e1, const Element &y, const Integer &e2) const
+			{return GetRing().CascadeExponentiate(x, e1, y, e2);}
+
+		void SimultaneousMultiply(Element *results, const Element &base, const Integer *exponents, unsigned int exponentsCount) const
+			{GetRing().SimultaneousExponentiate(results, base, exponents, exponentsCount);}
+
+		const AbstractRing<T> *m_pRing;
+	};
+
+	MultiplicativeGroupT m_mg;
+};
+
+// ********************************************************
+
+//! Base and Exponent
+template <class T, class E = Integer>
+struct BaseAndExponent
+{
+public:
+	BaseAndExponent() {}
+	BaseAndExponent(const T &base, const E &exponent) : base(base), exponent(exponent) {}
+	bool operator<(const BaseAndExponent<T, E> &rhs) const {return exponent < rhs.exponent;}
+	T base;
+	E exponent;
+};
+
+// VC60 workaround: incomplete member template support
+template <class Element, class Iterator>
+	Element GeneralCascadeMultiplication(const AbstractGroup<Element> &group, Iterator begin, Iterator end);
+template <class Element, class Iterator>
+	Element GeneralCascadeExponentiation(const AbstractRing<Element> &ring, Iterator begin, Iterator end);
+
+// ********************************************************
+
+//! Abstract Euclidean Domain
+template <class T> class CRYPTOPP_NO_VTABLE AbstractEuclideanDomain : public AbstractRing<T>
+{
+public:
+	typedef T Element;
+
+	virtual void DivisionAlgorithm(Element &r, Element &q, const Element &a, const Element &d) const =0;
+
+	virtual const Element& Mod(const Element &a, const Element &b) const =0;
+	virtual const Element& Gcd(const Element &a, const Element &b) const;
+
+protected:
+	mutable Element result;
+};
+
+// ********************************************************
+
+//! EuclideanDomainOf
+template <class T> class EuclideanDomainOf : public AbstractEuclideanDomain<T>
+{
+public:
+	typedef T Element;
+
+	EuclideanDomainOf() {}
+
+	bool Equal(const Element &a, const Element &b) const
+		{return a==b;}
+
+	const Element& Identity() const
+		{return Element::Zero();}
+
+	const Element& Add(const Element &a, const Element &b) const
+		{return result = a+b;}
+
+	Element& Accumulate(Element &a, const Element &b) const
+		{return a+=b;}
+
+	const Element& Inverse(const Element &a) const
+		{return result = -a;}
+
+	const Element& Subtract(const Element &a, const Element &b) const
+		{return result = a-b;}
+
+	Element& Reduce(Element &a, const Element &b) const
+		{return a-=b;}
+
+	const Element& Double(const Element &a) const
+		{return result = a.Doubled();}
+
+	const Element& MultiplicativeIdentity() const
+		{return Element::One();}
+
+	const Element& Multiply(const Element &a, const Element &b) const
+		{return result = a*b;}
+
+	const Element& Square(const Element &a) const
+		{return result = a.Squared();}
+
+	bool IsUnit(const Element &a) const
+		{return a.IsUnit();}
+
+	const Element& MultiplicativeInverse(const Element &a) const
+		{return result = a.MultiplicativeInverse();}
+
+	const Element& Divide(const Element &a, const Element &b) const
+		{return result = a/b;}
+
+	const Element& Mod(const Element &a, const Element &b) const
+		{return result = a%b;}
+
+	void DivisionAlgorithm(Element &r, Element &q, const Element &a, const Element &d) const
+		{Element::Divide(r, q, a, d);}
+
+	bool operator==(const EuclideanDomainOf<T> &rhs) const
+		{return true;}
+
+private:
+	mutable Element result;
+};
+
+//! Quotient Ring
+template <class T> class QuotientRing : public AbstractRing<typename T::Element>
+{
+public:
+	typedef T EuclideanDomain;
+	typedef typename T::Element Element;
+
+	QuotientRing(const EuclideanDomain &domain, const Element &modulus)
+		: m_domain(domain), m_modulus(modulus) {}
+
+	const EuclideanDomain & GetDomain() const
+		{return m_domain;}
+
+	const Element& GetModulus() const
+		{return m_modulus;}
+
+	bool Equal(const Element &a, const Element &b) const
+		{return m_domain.Equal(m_domain.Mod(m_domain.Subtract(a, b), m_modulus), m_domain.Identity());}
+
+	const Element& Identity() const
+		{return m_domain.Identity();}
+
+	const Element& Add(const Element &a, const Element &b) const
+		{return m_domain.Add(a, b);}
+
+	Element& Accumulate(Element &a, const Element &b) const
+		{return m_domain.Accumulate(a, b);}
+
+	const Element& Inverse(const Element &a) const
+		{return m_domain.Inverse(a);}
+
+	const Element& Subtract(const Element &a, const Element &b) const
+		{return m_domain.Subtract(a, b);}
+
+	Element& Reduce(Element &a, const Element &b) const
+		{return m_domain.Reduce(a, b);}
+
+	const Element& Double(const Element &a) const
+		{return m_domain.Double(a);}
+
+	bool IsUnit(const Element &a) const
+		{return m_domain.IsUnit(m_domain.Gcd(a, m_modulus));}
+
+	const Element& MultiplicativeIdentity() const
+		{return m_domain.MultiplicativeIdentity();}
+
+	const Element& Multiply(const Element &a, const Element &b) const
+		{return m_domain.Mod(m_domain.Multiply(a, b), m_modulus);}
+
+	const Element& Square(const Element &a) const
+		{return m_domain.Mod(m_domain.Square(a), m_modulus);}
+
+	const Element& MultiplicativeInverse(const Element &a) const;
+
+	bool operator==(const QuotientRing<T> &rhs) const
+		{return m_domain == rhs.m_domain && m_modulus == rhs.m_modulus;}
+
+protected:
+	EuclideanDomain m_domain;
+	Element m_modulus;
+};
+
+NAMESPACE_END
+
+#ifdef CRYPTOPP_MANUALLY_INSTANTIATE_TEMPLATES
+#include "algebra.cpp"
+#endif
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/algparam.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/algparam.h
index 0a541a42..ea5129c2 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/algparam.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/algparam.h
@@ -1,325 +1,398 @@
-#ifndef CRYPTOPP_ALGPARAM_H
-#define CRYPTOPP_ALGPARAM_H
-
-#include "cryptlib.h"
-#include "smartptr.h"
-#include "secblock.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-//! used to pass byte array input as part of a NameValuePairs object
-/*! the deepCopy option is used when the NameValuePairs object can't
-	keep a copy of the data available */
-class ConstByteArrayParameter
-{
-public:
-	ConstByteArrayParameter(const char *data = NULL, bool deepCopy = false)
-	{
-		Assign((const byte *)data, data ? strlen(data) : 0, deepCopy);
-	}
-	ConstByteArrayParameter(const byte *data, unsigned int size, bool deepCopy = false)
-	{
-		Assign(data, size, deepCopy);
-	}
-	template <class T> ConstByteArrayParameter(const T &string, bool deepCopy = false)
-	{
-		CRYPTOPP_COMPILE_ASSERT(sizeof(string[0])==1);
-		Assign((const byte *)string.data(), string.size(), deepCopy);
-	}
-
-	void Assign(const byte *data, unsigned int size, bool deepCopy)
-	{
-		if (deepCopy)
-			m_block.Assign(data, size);
-		else
-		{
-			m_data = data;
-			m_size = size;
-		}
-		m_deepCopy = deepCopy;
-	}
-
-	const byte *begin() const {return m_deepCopy ? m_block.begin() : m_data;}
-	const byte *end() const {return m_deepCopy ? m_block.end() : m_data + m_size;}
-	unsigned int size() const {return m_deepCopy ? m_block.size() : m_size;}
-
-private:
-	bool m_deepCopy;
-	const byte *m_data;
-	unsigned int m_size;
-	SecByteBlock m_block;
-};
-
-class ByteArrayParameter
-{
-public:
-	ByteArrayParameter(byte *data = NULL, unsigned int size = 0)
-		: m_data(data), m_size(size) {}
-	ByteArrayParameter(SecByteBlock &block)
-		: m_data(block.begin()), m_size(block.size()) {}
-
-	byte *begin() const {return m_data;}
-	byte *end() const {return m_data + m_size;}
-	unsigned int size() const {return m_size;}
-
-private:
-	byte *m_data;
-	unsigned int m_size;
-};
-
-class CombinedNameValuePairs : public NameValuePairs
-{
-public:
-	CombinedNameValuePairs(const NameValuePairs &pairs1, const NameValuePairs &pairs2)
-		: m_pairs1(pairs1), m_pairs2(pairs2) {}
-
-	bool GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const
-	{
-		if (strcmp(name, "ValueNames") == 0)
-			return m_pairs1.GetVoidValue(name, valueType, pValue) && m_pairs2.GetVoidValue(name, valueType, pValue);
-		else
-			return m_pairs1.GetVoidValue(name, valueType, pValue) || m_pairs2.GetVoidValue(name, valueType, pValue);
-	}
-
-	const NameValuePairs &m_pairs1, &m_pairs2;
-};
-
-template <class T, class BASE>
-class GetValueHelperClass
-{
-public:
-	GetValueHelperClass(const T *pObject, const char *name, const std::type_info &valueType, void *pValue, const NameValuePairs *searchFirst)
-		: m_pObject(pObject), m_name(name), m_valueType(&valueType), m_pValue(pValue), m_found(false), m_getValueNames(false)
-	{
-		if (strcmp(m_name, "ValueNames") == 0)
-		{
-			m_found = m_getValueNames = true;
-			NameValuePairs::ThrowIfTypeMismatch(m_name, typeid(std::string), *m_valueType);
-			if (searchFirst)
-				searchFirst->GetVoidValue(m_name, valueType, pValue);
-			if (typeid(T) != typeid(BASE))
-				pObject->BASE::GetVoidValue(m_name, valueType, pValue);
-			((*reinterpret_cast<std::string *>(m_pValue) += "ThisPointer:") += typeid(T).name()) += ';';
-		}
-
-		if (!m_found && strncmp(m_name, "ThisPointer:", 12) == 0 && strcmp(m_name+12, typeid(T).name()) == 0)
-		{
-			NameValuePairs::ThrowIfTypeMismatch(m_name, typeid(T *), *m_valueType);
-			*reinterpret_cast<const T **>(pValue) = pObject;
-			m_found = true;
-			return;
-		}
-
-		if (!m_found && searchFirst)
-			m_found = searchFirst->GetVoidValue(m_name, valueType, pValue);
-		
-		if (!m_found && typeid(T) != typeid(BASE))
-			m_found = pObject->BASE::GetVoidValue(m_name, valueType, pValue);
-	}
-
-	operator bool() const {return m_found;}
-
-	template <class R>
-	GetValueHelperClass<T,BASE> & operator()(const char *name, const R & (T::*pm)() const)
-	{
-		if (m_getValueNames)
-			(*reinterpret_cast<std::string *>(m_pValue) += name) += ";";
-		if (!m_found && strcmp(name, m_name) == 0)
-		{
-			NameValuePairs::ThrowIfTypeMismatch(name, typeid(R), *m_valueType);
-			*reinterpret_cast<R *>(m_pValue) = (m_pObject->*pm)();
-			m_found = true;
-		}
-		return *this;
-	}
-
-	GetValueHelperClass<T,BASE> &Assignable()
-	{
-		if (m_getValueNames)
-			((*reinterpret_cast<std::string *>(m_pValue) += "ThisObject:") += typeid(T).name()) += ';';
-		if (!m_found && strncmp(m_name, "ThisObject:", 11) == 0 && strcmp(m_name+11, typeid(T).name()) == 0)
-		{
-			NameValuePairs::ThrowIfTypeMismatch(m_name, typeid(T), *m_valueType);
-			*reinterpret_cast<T *>(m_pValue) = *m_pObject;
-			m_found = true;
-		}
-		return *this;
-	}
-
-private:
-	const T *m_pObject;
-	const char *m_name;
-	const std::type_info *m_valueType;
-	void *m_pValue;
-	bool m_found, m_getValueNames;
-};
-
-template <class BASE, class T>
-GetValueHelperClass<T, BASE> GetValueHelper(const T *pObject, const char *name, const std::type_info &valueType, void *pValue, const NameValuePairs *searchFirst=NULL, BASE *dummy=NULL)
-{
-	return GetValueHelperClass<T, BASE>(pObject, name, valueType, pValue, searchFirst);
-}
-
-template <class T>
-GetValueHelperClass<T, T> GetValueHelper(const T *pObject, const char *name, const std::type_info &valueType, void *pValue, const NameValuePairs *searchFirst=NULL)
-{
-	return GetValueHelperClass<T, T>(pObject, name, valueType, pValue, searchFirst);
-}
-
-// ********************************************************
-
-template <class R>
-R Hack_DefaultValueFromConstReferenceType(const R &)
-{
-	return R();
-}
-
-template <class R>
-bool Hack_GetValueIntoConstReference(const NameValuePairs &source, const char *name, const R &value)
-{
-	return source.GetValue(name, const_cast<R &>(value));
-}
-
-template <class T, class BASE>
-class AssignFromHelperClass
-{
-public:
-	AssignFromHelperClass(T *pObject, const NameValuePairs &source)
-		: m_pObject(pObject), m_source(source), m_done(false)
-	{
-		if (source.GetThisObject(*pObject))
-			m_done = true;
-		else if (typeid(BASE) != typeid(T))
-			pObject->BASE::AssignFrom(source);
-	}
-
-	template <class R>
-	AssignFromHelperClass & operator()(const char *name, void (T::*pm)(R))	// VC60 workaround: "const R &" here causes compiler error
-	{
-		if (!m_done)
-		{
-			R value = Hack_DefaultValueFromConstReferenceType(reinterpret_cast<R>(*(int *)NULL));
-			if (!Hack_GetValueIntoConstReference(m_source, name, value))
-				throw InvalidArgument(std::string(typeid(T).name()) + ": Missing required parameter '" + name + "'");
-			(m_pObject->*pm)(value);
-		}
-		return *this;
-	}
-
-	template <class R, class S>
-	AssignFromHelperClass & operator()(const char *name1, const char *name2, void (T::*pm)(R, S))	// VC60 workaround: "const R &" here causes compiler error
-	{
-		if (!m_done)
-		{
-			R value1 = Hack_DefaultValueFromConstReferenceType(reinterpret_cast<R>(*(int *)NULL));
-			if (!Hack_GetValueIntoConstReference(m_source, name1, value1))
-				throw InvalidArgument(std::string(typeid(T).name()) + ": Missing required parameter '" + name1 + "'");
-			S value2 = Hack_DefaultValueFromConstReferenceType(reinterpret_cast<S>(*(int *)NULL));
-			if (!Hack_GetValueIntoConstReference(m_source, name2, value2))
-				throw InvalidArgument(std::string(typeid(T).name()) + ": Missing required parameter '" + name2 + "'");
-			(m_pObject->*pm)(value1, value2);
-		}
-		return *this;
-	}
-
-private:
-	T *m_pObject;
-	const NameValuePairs &m_source;
-	bool m_done;
-};
-
-template <class BASE, class T>
-AssignFromHelperClass<T, BASE> AssignFromHelper(T *pObject, const NameValuePairs &source, BASE *dummy=NULL)
-{
-	return AssignFromHelperClass<T, BASE>(pObject, source);
-}
-
-template <class T>
-AssignFromHelperClass<T, T> AssignFromHelper(T *pObject, const NameValuePairs &source)
-{
-	return AssignFromHelperClass<T, T>(pObject, source);
-}
-
-// ********************************************************
-
-// This should allow the linker to discard Integer code if not needed.
-extern bool (*AssignIntToInteger)(const std::type_info &valueType, void *pInteger, const void *pInt);
-
-const std::type_info & IntegerTypeId();
-
-template <class BASE, class T>
-class AlgorithmParameters : public NameValuePairs
-{
-public:
-	AlgorithmParameters(const BASE &base, const char *name, const T &value)
-		: m_base(base), m_name(name), m_value(value)
-#ifndef NDEBUG
-		, m_used(false)
-#endif
-	{}
-
-#ifndef NDEBUG
-	AlgorithmParameters(const AlgorithmParameters &copy)
-		: m_base(copy.m_base), m_name(copy.m_name), m_value(copy.m_value), m_used(false)
-	{
-		copy.m_used = true;
-	}
-
-	// TODO: revisit after implementing some tracing mechanism, this won't work because of exceptions
-//	~AlgorithmParameters() {assert(m_used);}	// use assert here because we don't want to throw out of a destructor
-#endif
-
-	template <class R>
-	AlgorithmParameters<AlgorithmParameters<BASE,T>, R> operator()(const char *name, const R &value) const
-	{
-		return AlgorithmParameters<AlgorithmParameters<BASE,T>, R>(*this, name, value);
-	}
-
-	bool GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const
-	{
-		if (strcmp(name, "ValueNames") == 0)
-		{
-			ThrowIfTypeMismatch(name, typeid(std::string), valueType);
-			m_base.GetVoidValue(name, valueType, pValue);
-			(*reinterpret_cast<std::string *>(pValue) += m_name) += ";";
-			return true;
-		}
-		else if (strcmp(name, m_name) == 0)
-		{
-			// special case for retrieving an Integer parameter when an int was passed in
-			if (!(AssignIntToInteger != NULL && typeid(T) == typeid(int) && AssignIntToInteger(valueType, pValue, &m_value)))
-			{
-				ThrowIfTypeMismatch(name, typeid(T), valueType);
-				*reinterpret_cast<T *>(pValue) = m_value;
-			}
-#ifndef NDEBUG
-			m_used = true;
-#endif
-			return true;
-		}
-		else
-			return m_base.GetVoidValue(name, valueType, pValue);
-	}
-
-private:
-	BASE m_base;
-	const char *m_name;
-	T m_value;
-#ifndef NDEBUG
-	mutable bool m_used;
-#endif
-};
-
-template <class T>
-AlgorithmParameters<NullNameValuePairs,T> MakeParameters(const char *name, const T &value)
-{
-	return AlgorithmParameters<NullNameValuePairs,T>(g_nullNameValuePairs, name, value);
-}
-
-#define CRYPTOPP_GET_FUNCTION_ENTRY(name)		(Name::name(), &ThisClass::Get##name)
-#define CRYPTOPP_SET_FUNCTION_ENTRY(name)		(Name::name(), &ThisClass::Set##name)
-#define CRYPTOPP_SET_FUNCTION_ENTRY2(name1, name2)	(Name::name1(), Name::name2(), &ThisClass::Set##name1##And##name2)
-
-NAMESPACE_END
-
-#endif
+#ifndef CRYPTOPP_ALGPARAM_H
+#define CRYPTOPP_ALGPARAM_H
+
+#include "cryptlib.h"
+#include "smartptr.h"
+#include "secblock.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+//! used to pass byte array input as part of a NameValuePairs object
+/*! the deepCopy option is used when the NameValuePairs object can't
+	keep a copy of the data available */
+class ConstByteArrayParameter
+{
+public:
+	ConstByteArrayParameter(const char *data = NULL, bool deepCopy = false)
+	{
+		Assign((const byte *)data, data ? strlen(data) : 0, deepCopy);
+	}
+	ConstByteArrayParameter(const byte *data, size_t size, bool deepCopy = false)
+	{
+		Assign(data, size, deepCopy);
+	}
+	template <class T> ConstByteArrayParameter(const T &string, bool deepCopy = false)
+	{
+        CRYPTOPP_COMPILE_ASSERT(sizeof(CPP_TYPENAME T::value_type) == 1);
+		Assign((const byte *)string.data(), string.size(), deepCopy);
+	}
+
+	void Assign(const byte *data, size_t size, bool deepCopy)
+	{
+		if (deepCopy)
+			m_block.Assign(data, size);
+		else
+		{
+			m_data = data;
+			m_size = size;
+		}
+		m_deepCopy = deepCopy;
+	}
+
+	const byte *begin() const {return m_deepCopy ? m_block.begin() : m_data;}
+	const byte *end() const {return m_deepCopy ? m_block.end() : m_data + m_size;}
+	size_t size() const {return m_deepCopy ? m_block.size() : m_size;}
+
+private:
+	bool m_deepCopy;
+	const byte *m_data;
+	size_t m_size;
+	SecByteBlock m_block;
+};
+
+class ByteArrayParameter
+{
+public:
+	ByteArrayParameter(byte *data = NULL, unsigned int size = 0)
+		: m_data(data), m_size(size) {}
+	ByteArrayParameter(SecByteBlock &block)
+		: m_data(block.begin()), m_size(block.size()) {}
+
+	byte *begin() const {return m_data;}
+	byte *end() const {return m_data + m_size;}
+	size_t size() const {return m_size;}
+
+private:
+	byte *m_data;
+	size_t m_size;
+};
+
+class CRYPTOPP_DLL CombinedNameValuePairs : public NameValuePairs
+{
+public:
+	CombinedNameValuePairs(const NameValuePairs &pairs1, const NameValuePairs &pairs2)
+		: m_pairs1(pairs1), m_pairs2(pairs2) {}
+
+	bool GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const;
+
+private:
+	const NameValuePairs &m_pairs1, &m_pairs2;
+};
+
+template <class T, class BASE>
+class GetValueHelperClass
+{
+public:
+	GetValueHelperClass(const T *pObject, const char *name, const std::type_info &valueType, void *pValue, const NameValuePairs *searchFirst)
+		: m_pObject(pObject), m_name(name), m_valueType(&valueType), m_pValue(pValue), m_found(false), m_getValueNames(false)
+	{
+		if (strcmp(m_name, "ValueNames") == 0)
+		{
+			m_found = m_getValueNames = true;
+			NameValuePairs::ThrowIfTypeMismatch(m_name, typeid(std::string), *m_valueType);
+			if (searchFirst)
+				searchFirst->GetVoidValue(m_name, valueType, pValue);
+			if (typeid(T) != typeid(BASE))
+				pObject->BASE::GetVoidValue(m_name, valueType, pValue);
+			((*reinterpret_cast<std::string *>(m_pValue) += "ThisPointer:") += typeid(T).name()) += ';';
+		}
+
+		if (!m_found && strncmp(m_name, "ThisPointer:", 12) == 0 && strcmp(m_name+12, typeid(T).name()) == 0)
+		{
+			NameValuePairs::ThrowIfTypeMismatch(m_name, typeid(T *), *m_valueType);
+			*reinterpret_cast<const T **>(pValue) = pObject;
+			m_found = true;
+			return;
+		}
+
+		if (!m_found && searchFirst)
+			m_found = searchFirst->GetVoidValue(m_name, valueType, pValue);
+		
+		if (!m_found && typeid(T) != typeid(BASE))
+			m_found = pObject->BASE::GetVoidValue(m_name, valueType, pValue);
+	}
+
+	operator bool() const {return m_found;}
+
+	template <class R>
+	GetValueHelperClass<T,BASE> & operator()(const char *name, const R & (T::*pm)() const)
+	{
+		if (m_getValueNames)
+			(*reinterpret_cast<std::string *>(m_pValue) += name) += ";";
+		if (!m_found && strcmp(name, m_name) == 0)
+		{
+			NameValuePairs::ThrowIfTypeMismatch(name, typeid(R), *m_valueType);
+			*reinterpret_cast<R *>(m_pValue) = (m_pObject->*pm)();
+			m_found = true;
+		}
+		return *this;
+	}
+
+	GetValueHelperClass<T,BASE> &Assignable()
+	{
+#ifndef __INTEL_COMPILER	// ICL 9.1 workaround: Intel compiler copies the vTable pointer for some reason
+		if (m_getValueNames)
+			((*reinterpret_cast<std::string *>(m_pValue) += "ThisObject:") += typeid(T).name()) += ';';
+		if (!m_found && strncmp(m_name, "ThisObject:", 11) == 0 && strcmp(m_name+11, typeid(T).name()) == 0)
+		{
+			NameValuePairs::ThrowIfTypeMismatch(m_name, typeid(T), *m_valueType);
+			*reinterpret_cast<T *>(m_pValue) = *m_pObject;
+			m_found = true;
+		}
+#endif
+		return *this;
+	}
+
+private:
+	const T *m_pObject;
+	const char *m_name;
+	const std::type_info *m_valueType;
+	void *m_pValue;
+	bool m_found, m_getValueNames;
+};
+
+template <class BASE, class T>
+GetValueHelperClass<T, BASE> GetValueHelper(const T *pObject, const char *name, const std::type_info &valueType, void *pValue, const NameValuePairs *searchFirst=NULL, BASE *dummy=NULL)
+{
+	return GetValueHelperClass<T, BASE>(pObject, name, valueType, pValue, searchFirst);
+}
+
+template <class T>
+GetValueHelperClass<T, T> GetValueHelper(const T *pObject, const char *name, const std::type_info &valueType, void *pValue, const NameValuePairs *searchFirst=NULL)
+{
+	return GetValueHelperClass<T, T>(pObject, name, valueType, pValue, searchFirst);
+}
+
+// ********************************************************
+
+template <class R>
+R Hack_DefaultValueFromConstReferenceType(const R &)
+{
+	return R();
+}
+
+template <class R>
+bool Hack_GetValueIntoConstReference(const NameValuePairs &source, const char *name, const R &value)
+{
+	return source.GetValue(name, const_cast<R &>(value));
+}
+
+template <class T, class BASE>
+class AssignFromHelperClass
+{
+public:
+	AssignFromHelperClass(T *pObject, const NameValuePairs &source)
+		: m_pObject(pObject), m_source(source), m_done(false)
+	{
+		if (source.GetThisObject(*pObject))
+			m_done = true;
+		else if (typeid(BASE) != typeid(T))
+			pObject->BASE::AssignFrom(source);
+	}
+
+	template <class R>
+	AssignFromHelperClass & operator()(const char *name, void (T::*pm)(R))	// VC60 workaround: "const R &" here causes compiler error
+	{
+		if (!m_done)
+		{
+			R value = Hack_DefaultValueFromConstReferenceType(reinterpret_cast<R>(*(int *)NULL));
+			if (!Hack_GetValueIntoConstReference(m_source, name, value))
+				throw InvalidArgument(std::string(typeid(T).name()) + ": Missing required parameter '" + name + "'");
+			(m_pObject->*pm)(value);
+		}
+		return *this;
+	}
+
+	template <class R, class S>
+	AssignFromHelperClass & operator()(const char *name1, const char *name2, void (T::*pm)(R, S))	// VC60 workaround: "const R &" here causes compiler error
+	{
+		if (!m_done)
+		{
+			R value1 = Hack_DefaultValueFromConstReferenceType(reinterpret_cast<R>(*(int *)NULL));
+			if (!Hack_GetValueIntoConstReference(m_source, name1, value1))
+				throw InvalidArgument(std::string(typeid(T).name()) + ": Missing required parameter '" + name1 + "'");
+			S value2 = Hack_DefaultValueFromConstReferenceType(reinterpret_cast<S>(*(int *)NULL));
+			if (!Hack_GetValueIntoConstReference(m_source, name2, value2))
+				throw InvalidArgument(std::string(typeid(T).name()) + ": Missing required parameter '" + name2 + "'");
+			(m_pObject->*pm)(value1, value2);
+		}
+		return *this;
+	}
+
+private:
+	T *m_pObject;
+	const NameValuePairs &m_source;
+	bool m_done;
+};
+
+template <class BASE, class T>
+AssignFromHelperClass<T, BASE> AssignFromHelper(T *pObject, const NameValuePairs &source, BASE *dummy=NULL)
+{
+	return AssignFromHelperClass<T, BASE>(pObject, source);
+}
+
+template <class T>
+AssignFromHelperClass<T, T> AssignFromHelper(T *pObject, const NameValuePairs &source)
+{
+	return AssignFromHelperClass<T, T>(pObject, source);
+}
+
+// ********************************************************
+
+// to allow the linker to discard Integer code if not needed.
+typedef bool (CRYPTOPP_API * PAssignIntToInteger)(const std::type_info &valueType, void *pInteger, const void *pInt);
+CRYPTOPP_DLL extern PAssignIntToInteger g_pAssignIntToInteger;
+
+CRYPTOPP_DLL const std::type_info & CRYPTOPP_API IntegerTypeId();
+
+class CRYPTOPP_DLL AlgorithmParametersBase
+{
+public:
+	class ParameterNotUsed : public Exception
+	{
+	public: 
+		ParameterNotUsed(const char *name) : Exception(OTHER_ERROR, std::string("AlgorithmParametersBase: parameter \"") + name + "\" not used") {}
+	};
+
+	// this is actually a move, not a copy
+	AlgorithmParametersBase(const AlgorithmParametersBase &x)
+		: m_name(x.m_name), m_throwIfNotUsed(x.m_throwIfNotUsed), m_used(x.m_used)
+	{
+		m_next.reset(const_cast<AlgorithmParametersBase &>(x).m_next.release());
+		x.m_used = true;
+	}
+
+	AlgorithmParametersBase(const char *name, bool throwIfNotUsed)
+		: m_name(name), m_throwIfNotUsed(throwIfNotUsed), m_used(false) {}
+
+	virtual ~AlgorithmParametersBase()
+	{
+#ifdef CRYPTOPP_UNCAUGHT_EXCEPTION_AVAILABLE
+		if (!std::uncaught_exception())
+#else
+		try
+#endif
+		{
+			if (m_throwIfNotUsed && !m_used)
+				throw ParameterNotUsed(m_name);
+		}
+#ifndef CRYPTOPP_UNCAUGHT_EXCEPTION_AVAILABLE
+		catch(...)
+		{
+		}
+#endif
+	}
+
+	bool GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const;
+	
+protected:
+	friend class AlgorithmParameters;
+	void operator=(const AlgorithmParametersBase& rhs);	// assignment not allowed, declare this for VC60
+
+	virtual void AssignValue(const char *name, const std::type_info &valueType, void *pValue) const =0;
+	virtual void MoveInto(void *p) const =0;	// not really const
+
+	const char *m_name;
+	bool m_throwIfNotUsed;
+	mutable bool m_used;
+	member_ptr<AlgorithmParametersBase> m_next;
+};
+
+template <class T>
+class AlgorithmParametersTemplate : public AlgorithmParametersBase
+{
+public:
+	AlgorithmParametersTemplate(const char *name, const T &value, bool throwIfNotUsed)
+		: AlgorithmParametersBase(name, throwIfNotUsed), m_value(value)
+	{
+	}
+
+	void AssignValue(const char *name, const std::type_info &valueType, void *pValue) const
+	{
+		// special case for retrieving an Integer parameter when an int was passed in
+		if (!(g_pAssignIntToInteger != NULL && typeid(T) == typeid(int) && g_pAssignIntToInteger(valueType, pValue, &m_value)))
+		{
+			NameValuePairs::ThrowIfTypeMismatch(name, typeid(T), valueType);
+			*reinterpret_cast<T *>(pValue) = m_value;
+		}
+	}
+
+	void MoveInto(void *buffer) const
+	{
+		AlgorithmParametersTemplate<T>* p = new(buffer) AlgorithmParametersTemplate<T>(*this);
+	}
+
+protected:
+	T m_value;
+};
+
+CRYPTOPP_DLL_TEMPLATE_CLASS AlgorithmParametersTemplate<bool>;
+CRYPTOPP_DLL_TEMPLATE_CLASS AlgorithmParametersTemplate<int>;
+CRYPTOPP_DLL_TEMPLATE_CLASS AlgorithmParametersTemplate<ConstByteArrayParameter>;
+
+class CRYPTOPP_DLL AlgorithmParameters : public NameValuePairs
+{
+public:
+	AlgorithmParameters();
+
+#ifdef __BORLANDC__
+	template <class T>
+	AlgorithmParameters(const char *name, const T &value, bool throwIfNotUsed=true)
+		: m_next(new AlgorithmParametersTemplate<T>(name, value, throwIfNotUsed))
+		, m_defaultThrowIfNotUsed(throwIfNotUsed)
+	{
+	}
+#endif
+
+	AlgorithmParameters(const AlgorithmParameters &x);
+
+	AlgorithmParameters & operator=(const AlgorithmParameters &x);
+
+	template <class T>
+	AlgorithmParameters & operator()(const char *name, const T &value, bool throwIfNotUsed)
+	{
+		member_ptr<AlgorithmParametersBase> p(new AlgorithmParametersTemplate<T>(name, value, throwIfNotUsed));
+		p->m_next.reset(m_next.release());
+		m_next.reset(p.release());
+		m_defaultThrowIfNotUsed = throwIfNotUsed;
+		return *this;
+	}
+
+	template <class T>
+	AlgorithmParameters & operator()(const char *name, const T &value)
+	{
+		return operator()(name, value, m_defaultThrowIfNotUsed);
+	}
+
+	bool GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const;
+
+protected:
+	member_ptr<AlgorithmParametersBase> m_next;
+	bool m_defaultThrowIfNotUsed;
+};
+
+//! Create an object that implements NameValuePairs for passing parameters
+/*! \param throwIfNotUsed if true, the object will throw an exception if the value is not accessed
+	\note throwIfNotUsed is ignored if using a compiler that does not support std::uncaught_exception(),
+	such as MSVC 7.0 and earlier.
+	\note A NameValuePairs object containing an arbitrary number of name value pairs may be constructed by
+	repeatedly using operator() on the object returned by MakeParameters, for example:
+	AlgorithmParameters parameters = MakeParameters(name1, value1)(name2, value2)(name3, value3);
+*/
+#ifdef __BORLANDC__
+typedef AlgorithmParameters MakeParameters;
+#else
+template <class T>
+AlgorithmParameters MakeParameters(const char *name, const T &value, bool throwIfNotUsed = true)
+{
+	return AlgorithmParameters()(name, value, throwIfNotUsed);
+}
+#endif
+
+#define CRYPTOPP_GET_FUNCTION_ENTRY(name)		(Name::name(), &ThisClass::Get##name)
+#define CRYPTOPP_SET_FUNCTION_ENTRY(name)		(Name::name(), &ThisClass::Set##name)
+#define CRYPTOPP_SET_FUNCTION_ENTRY2(name1, name2)	(Name::name1(), Name::name2(), &ThisClass::Set##name1##And##name2)
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/argnames.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/argnames.h
index 077946de..e9617252 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/argnames.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/argnames.h
@@ -1,54 +1,81 @@
-#ifndef CRYPTOPP_ARGNAMES_H
-#define CRYPTOPP_ARGNAMES_H
-
-#include "cryptlib.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-DOCUMENTED_NAMESPACE_BEGIN(Name)
-
-#define CRYPTOPP_DEFINE_NAME_STRING(name)	inline const char *name() {return #name;}
-
-CRYPTOPP_DEFINE_NAME_STRING(ValueNames)			//!< string, a list of value names with a semicolon (';') after each name
-CRYPTOPP_DEFINE_NAME_STRING(Version)			//!< int
-CRYPTOPP_DEFINE_NAME_STRING(Seed)				//!< ConstByteArrayParameter
-CRYPTOPP_DEFINE_NAME_STRING(Key)				//!< ConstByteArrayParameter
-CRYPTOPP_DEFINE_NAME_STRING(IV)					//!< const byte *
-CRYPTOPP_DEFINE_NAME_STRING(StolenIV)			//!< byte *
-CRYPTOPP_DEFINE_NAME_STRING(Rounds)				//!< int
-CRYPTOPP_DEFINE_NAME_STRING(FeedbackSize)		//!< int
-CRYPTOPP_DEFINE_NAME_STRING(WordSize)			//!< int, in bytes
-CRYPTOPP_DEFINE_NAME_STRING(BlockSize)			//!< int, in bytes
-CRYPTOPP_DEFINE_NAME_STRING(EffectiveKeyLength)	//!< int, in bits
-CRYPTOPP_DEFINE_NAME_STRING(KeySize)			//!< int, in bits
-CRYPTOPP_DEFINE_NAME_STRING(ModulusSize)		//!< int, in bits
-CRYPTOPP_DEFINE_NAME_STRING(SubgroupOrderSize)	//!< int, in bits
-CRYPTOPP_DEFINE_NAME_STRING(PrivateExponentSize)//!< int, in bits
-CRYPTOPP_DEFINE_NAME_STRING(Modulus)			//!< Integer
-CRYPTOPP_DEFINE_NAME_STRING(PublicExponent)		//!< Integer
-CRYPTOPP_DEFINE_NAME_STRING(PrivateExponent)	//!< Integer
-CRYPTOPP_DEFINE_NAME_STRING(PublicElement)		//!< Integer
-CRYPTOPP_DEFINE_NAME_STRING(SubgroupOrder)		//!< Integer
-CRYPTOPP_DEFINE_NAME_STRING(Cofactor)			//!< Integer
-CRYPTOPP_DEFINE_NAME_STRING(SubgroupGenerator)	//!< Integer, ECP::Point, or EC2N::Point
-CRYPTOPP_DEFINE_NAME_STRING(Curve)				//!< ECP or EC2N
-CRYPTOPP_DEFINE_NAME_STRING(GroupOID)			//!< OID
-CRYPTOPP_DEFINE_NAME_STRING(Prime1)				//!< Integer
-CRYPTOPP_DEFINE_NAME_STRING(Prime2)				//!< Integer
-CRYPTOPP_DEFINE_NAME_STRING(ModPrime1PrivateExponent)	//!< Integer
-CRYPTOPP_DEFINE_NAME_STRING(ModPrime2PrivateExponent)	//!< Integer
-CRYPTOPP_DEFINE_NAME_STRING(MultiplicativeInverseOfPrime2ModPrime1)	//!< Integer
-CRYPTOPP_DEFINE_NAME_STRING(QuadraticResidueModPrime1)	//!< Integer
-CRYPTOPP_DEFINE_NAME_STRING(QuadraticResidueModPrime2)	//!< Integer
-CRYPTOPP_DEFINE_NAME_STRING(PutMessage)			//!< bool
-CRYPTOPP_DEFINE_NAME_STRING(HashVerificationFilterFlags)		//!< word32
-CRYPTOPP_DEFINE_NAME_STRING(SignatureVerificationFilterFlags)	//!< word32
-CRYPTOPP_DEFINE_NAME_STRING(InputBuffer)		//!< ConstByteArrayParameter
-CRYPTOPP_DEFINE_NAME_STRING(OutputBuffer)		//!< ByteArrayParameter
-CRYPTOPP_DEFINE_NAME_STRING(XMACC_Counter)		//!< word32
-
-DOCUMENTED_NAMESPACE_END
-
-NAMESPACE_END
-
-#endif
+#ifndef CRYPTOPP_ARGNAMES_H
+#define CRYPTOPP_ARGNAMES_H
+
+#include "cryptlib.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+DOCUMENTED_NAMESPACE_BEGIN(Name)
+
+#define CRYPTOPP_DEFINE_NAME_STRING(name)	inline const char *name() {return #name;}
+
+CRYPTOPP_DEFINE_NAME_STRING(ValueNames)			//!< string, a list of value names with a semicolon (';') after each name
+CRYPTOPP_DEFINE_NAME_STRING(Version)			//!< int
+CRYPTOPP_DEFINE_NAME_STRING(Seed)				//!< ConstByteArrayParameter
+CRYPTOPP_DEFINE_NAME_STRING(Key)				//!< ConstByteArrayParameter
+CRYPTOPP_DEFINE_NAME_STRING(IV)					//!< ConstByteArrayParameter, also accepts const byte * for backwards compatibility
+CRYPTOPP_DEFINE_NAME_STRING(StolenIV)			//!< byte *
+CRYPTOPP_DEFINE_NAME_STRING(Rounds)				//!< int
+CRYPTOPP_DEFINE_NAME_STRING(FeedbackSize)		//!< int
+CRYPTOPP_DEFINE_NAME_STRING(WordSize)			//!< int, in bytes
+CRYPTOPP_DEFINE_NAME_STRING(BlockSize)			//!< int, in bytes
+CRYPTOPP_DEFINE_NAME_STRING(EffectiveKeyLength)	//!< int, in bits
+CRYPTOPP_DEFINE_NAME_STRING(KeySize)			//!< int, in bits
+CRYPTOPP_DEFINE_NAME_STRING(ModulusSize)		//!< int, in bits
+CRYPTOPP_DEFINE_NAME_STRING(SubgroupOrderSize)	//!< int, in bits
+CRYPTOPP_DEFINE_NAME_STRING(PrivateExponentSize)//!< int, in bits
+CRYPTOPP_DEFINE_NAME_STRING(Modulus)			//!< Integer
+CRYPTOPP_DEFINE_NAME_STRING(PublicExponent)		//!< Integer
+CRYPTOPP_DEFINE_NAME_STRING(PrivateExponent)	//!< Integer
+CRYPTOPP_DEFINE_NAME_STRING(PublicElement)		//!< Integer
+CRYPTOPP_DEFINE_NAME_STRING(SubgroupOrder)		//!< Integer
+CRYPTOPP_DEFINE_NAME_STRING(Cofactor)			//!< Integer
+CRYPTOPP_DEFINE_NAME_STRING(SubgroupGenerator)	//!< Integer, ECP::Point, or EC2N::Point
+CRYPTOPP_DEFINE_NAME_STRING(Curve)				//!< ECP or EC2N
+CRYPTOPP_DEFINE_NAME_STRING(GroupOID)			//!< OID
+CRYPTOPP_DEFINE_NAME_STRING(PointerToPrimeSelector)		//!< const PrimeSelector *
+CRYPTOPP_DEFINE_NAME_STRING(Prime1)				//!< Integer
+CRYPTOPP_DEFINE_NAME_STRING(Prime2)				//!< Integer
+CRYPTOPP_DEFINE_NAME_STRING(ModPrime1PrivateExponent)	//!< Integer
+CRYPTOPP_DEFINE_NAME_STRING(ModPrime2PrivateExponent)	//!< Integer
+CRYPTOPP_DEFINE_NAME_STRING(MultiplicativeInverseOfPrime2ModPrime1)	//!< Integer
+CRYPTOPP_DEFINE_NAME_STRING(QuadraticResidueModPrime1)	//!< Integer
+CRYPTOPP_DEFINE_NAME_STRING(QuadraticResidueModPrime2)	//!< Integer
+CRYPTOPP_DEFINE_NAME_STRING(PutMessage)			//!< bool
+CRYPTOPP_DEFINE_NAME_STRING(TruncatedDigestSize)	//!< int
+CRYPTOPP_DEFINE_NAME_STRING(BlockPaddingScheme)	//!< StreamTransformationFilter::BlockPaddingScheme
+CRYPTOPP_DEFINE_NAME_STRING(HashVerificationFilterFlags)		//!< word32
+CRYPTOPP_DEFINE_NAME_STRING(AuthenticatedDecryptionFilterFlags)	//!< word32
+CRYPTOPP_DEFINE_NAME_STRING(SignatureVerificationFilterFlags)	//!< word32
+CRYPTOPP_DEFINE_NAME_STRING(InputBuffer)		//!< ConstByteArrayParameter
+CRYPTOPP_DEFINE_NAME_STRING(OutputBuffer)		//!< ByteArrayParameter
+CRYPTOPP_DEFINE_NAME_STRING(InputFileName)		//!< const char *
+CRYPTOPP_DEFINE_NAME_STRING(InputFileNameWide)	//!< const wchar_t *
+CRYPTOPP_DEFINE_NAME_STRING(InputStreamPointer)	//!< std::istream *
+CRYPTOPP_DEFINE_NAME_STRING(InputBinaryMode)	//!< bool
+CRYPTOPP_DEFINE_NAME_STRING(OutputFileName)		//!< const char *
+CRYPTOPP_DEFINE_NAME_STRING(OutputFileNameWide)	//!< const wchar_t *
+CRYPTOPP_DEFINE_NAME_STRING(OutputStreamPointer)	//!< std::ostream *
+CRYPTOPP_DEFINE_NAME_STRING(OutputBinaryMode)	//!< bool
+CRYPTOPP_DEFINE_NAME_STRING(EncodingParameters)	//!< ConstByteArrayParameter
+CRYPTOPP_DEFINE_NAME_STRING(KeyDerivationParameters)	//!< ConstByteArrayParameter
+CRYPTOPP_DEFINE_NAME_STRING(Separator)			//< ConstByteArrayParameter
+CRYPTOPP_DEFINE_NAME_STRING(Terminator)			//< ConstByteArrayParameter
+CRYPTOPP_DEFINE_NAME_STRING(Uppercase)			//< bool
+CRYPTOPP_DEFINE_NAME_STRING(GroupSize)			//< int
+CRYPTOPP_DEFINE_NAME_STRING(Pad)				//< bool
+CRYPTOPP_DEFINE_NAME_STRING(PaddingByte)		//< byte
+CRYPTOPP_DEFINE_NAME_STRING(Log2Base)			//< int
+CRYPTOPP_DEFINE_NAME_STRING(EncodingLookupArray)	//< const byte *
+CRYPTOPP_DEFINE_NAME_STRING(DecodingLookupArray)	//< const byte *
+CRYPTOPP_DEFINE_NAME_STRING(InsertLineBreaks)	//< bool
+CRYPTOPP_DEFINE_NAME_STRING(MaxLineLength)		//< int
+CRYPTOPP_DEFINE_NAME_STRING(DigestSize)			//!< int, in bytes
+CRYPTOPP_DEFINE_NAME_STRING(L1KeyLength)		//!< int, in bytes
+CRYPTOPP_DEFINE_NAME_STRING(TableSize)			//!< int, in bytes
+
+DOCUMENTED_NAMESPACE_END
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/asn.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/asn.h
index 336d97ed..c35126bc 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/asn.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/asn.h
@@ -1,346 +1,369 @@
-#ifndef CRYPTOPP_ASN_H
-#define CRYPTOPP_ASN_H
-
-#include "filters.h"
-#include "queue.h"
-#include <vector>
-
-NAMESPACE_BEGIN(CryptoPP)
-
-// these tags and flags are not complete
-enum ASNTag
-{
-	BOOLEAN 			= 0x01,
-	INTEGER 			= 0x02,
-	BIT_STRING			= 0x03,
-	OCTET_STRING		= 0x04,
-	TAG_NULL			= 0x05,
-	OBJECT_IDENTIFIER	= 0x06,
-	OBJECT_DESCRIPTOR	= 0x07,
-	EXTERNAL			= 0x08,
-	REAL				= 0x09,
-	ENUMERATED			= 0x0a,
-	UTF8_STRING			= 0x0c,
-	SEQUENCE			= 0x10,
-	SET 				= 0x11,
-	NUMERIC_STRING		= 0x12,
-	PRINTABLE_STRING 	= 0x13,
-	T61_STRING			= 0x14,
-	VIDEOTEXT_STRING 	= 0x15,
-	IA5_STRING			= 0x16,
-	UTC_TIME 			= 0x17,
-	GENERALIZED_TIME 	= 0x18,
-	GRAPHIC_STRING		= 0x19,
-	VISIBLE_STRING		= 0x1a,
-	GENERAL_STRING		= 0x1b
-};
-
-enum ASNIdFlag
-{
-	UNIVERSAL			= 0x00,
-//	DATA				= 0x01,
-//	HEADER				= 0x02,
-	CONSTRUCTED 		= 0x20,
-	APPLICATION 		= 0x40,
-	CONTEXT_SPECIFIC	= 0x80,
-	PRIVATE 			= 0xc0
-};
-
-inline void BERDecodeError() {throw BERDecodeErr();}
-
-class UnknownOID : public BERDecodeErr
-{
-public:
-	UnknownOID() : BERDecodeErr("BER decode error: unknown object identifier") {}
-	UnknownOID(const char *err) : BERDecodeErr(err) {}
-};
-
-// unsigned int DERLengthEncode(unsigned int length, byte *output=0);
-unsigned int DERLengthEncode(BufferedTransformation &out, unsigned int length);
-// returns false if indefinite length
-bool BERLengthDecode(BufferedTransformation &in, unsigned int &length);
-
-void DEREncodeNull(BufferedTransformation &out);
-void BERDecodeNull(BufferedTransformation &in);
-
-unsigned int DEREncodeOctetString(BufferedTransformation &out, const byte *str, unsigned int strLen);
-unsigned int DEREncodeOctetString(BufferedTransformation &out, const SecByteBlock &str);
-unsigned int BERDecodeOctetString(BufferedTransformation &in, SecByteBlock &str);
-unsigned int BERDecodeOctetString(BufferedTransformation &in, BufferedTransformation &str);
-
-// for UTF8_STRING, PRINTABLE_STRING, and IA5_STRING
-unsigned int DEREncodeTextString(BufferedTransformation &out, const std::string &str, byte asnTag);
-unsigned int BERDecodeTextString(BufferedTransformation &in, std::string &str, byte asnTag);
-
-unsigned int DEREncodeBitString(BufferedTransformation &out, const byte *str, unsigned int strLen, unsigned int unusedBits=0);
-unsigned int BERDecodeBitString(BufferedTransformation &in, SecByteBlock &str, unsigned int &unusedBits);
-
-//! Object Identifier
-class OID
-{
-public:
-	OID() {}
-	OID(unsigned long v) : m_values(1, v) {}
-	OID(BufferedTransformation &bt) {BERDecode(bt);}
-
-	inline OID & operator+=(unsigned long rhs) {m_values.push_back(rhs); return *this;}
-
-	void DEREncode(BufferedTransformation &bt) const;
-	void BERDecode(BufferedTransformation &bt);
-
-	// throw BERDecodeErr() if decoded value doesn't equal this OID
-	void BERDecodeAndCheck(BufferedTransformation &bt) const;
-
-	std::vector<unsigned long> m_values;
-
-private:
-	static void EncodeValue(BufferedTransformation &bt, unsigned long v);
-	static unsigned int DecodeValue(BufferedTransformation &bt, unsigned long &v);
-};
-
-class EncodedObjectFilter : public Filter
-{
-public:
-	enum Flag {PUT_OBJECTS=1, PUT_MESSANGE_END_AFTER_EACH_OBJECT=2, PUT_MESSANGE_END_AFTER_ALL_OBJECTS=4, PUT_MESSANGE_SERIES_END_AFTER_ALL_OBJECTS=8};
-	EncodedObjectFilter(BufferedTransformation *attachment = NULL, unsigned int nObjects = 1, word32 flags = 0);
-
-	void Put(const byte *inString, unsigned int length);
-
-	unsigned int GetNumberOfCompletedObjects() const {return m_nCurrentObject;}
-	unsigned long GetPositionOfObject(unsigned int i) const {return m_positions[i];}
-
-private:
-	BufferedTransformation & CurrentTarget();
-
-	word32 m_flags;
-	unsigned int m_nObjects, m_nCurrentObject, m_level;
-	std::vector<unsigned int> m_positions;
-	ByteQueue m_queue;
-	enum State {IDENTIFIER, LENGTH, BODY, TAIL, ALL_DONE} m_state;
-	byte m_id;
-	unsigned int m_lengthRemaining;
-};
-
-//! BER General Decoder
-class BERGeneralDecoder : public Store
-{
-public:
-	explicit BERGeneralDecoder(BufferedTransformation &inQueue, byte asnTag);
-	explicit BERGeneralDecoder(BERGeneralDecoder &inQueue, byte asnTag);
-	~BERGeneralDecoder();
-
-	bool IsDefiniteLength() const {return m_definiteLength;}
-	unsigned int RemainingLength() const {assert(m_definiteLength); return m_length;}
-	bool EndReached() const;
-	byte PeekByte() const;
-	void CheckByte(byte b);
-
-	unsigned int TransferTo2(BufferedTransformation &target, unsigned long &transferBytes, const std::string &channel=NULL_CHANNEL, bool blocking=true);
-	unsigned int CopyRangeTo2(BufferedTransformation &target, unsigned long &begin, unsigned long end=ULONG_MAX, const std::string &channel=NULL_CHANNEL, bool blocking=true) const;
-
-	// call this to denote end of sequence
-	void MessageEnd();
-
-protected:
-	BufferedTransformation &m_inQueue;
-	bool m_finished, m_definiteLength;
-	unsigned int m_length;
-
-private:
-	void StoreInitialize(const NameValuePairs &parameters) {assert(false);}
-	unsigned int ReduceLength(unsigned int delta);
-};
-
-//! DER General Encoder
-class DERGeneralEncoder : public ByteQueue
-{
-public:
-	explicit DERGeneralEncoder(BufferedTransformation &outQueue, byte asnTag = SEQUENCE | CONSTRUCTED);
-	explicit DERGeneralEncoder(DERGeneralEncoder &outQueue, byte asnTag = SEQUENCE | CONSTRUCTED);
-	~DERGeneralEncoder();
-
-	// call this to denote end of sequence
-	void MessageEnd();
-
-private:
-	BufferedTransformation &m_outQueue;
-	bool m_finished;
-
-	byte m_asnTag;
-};
-
-//! BER Sequence Decoder
-class BERSequenceDecoder : public BERGeneralDecoder
-{
-public:
-	explicit BERSequenceDecoder(BufferedTransformation &inQueue, byte asnTag = SEQUENCE | CONSTRUCTED)
-		: BERGeneralDecoder(inQueue, asnTag) {}
-	explicit BERSequenceDecoder(BERSequenceDecoder &inQueue, byte asnTag = SEQUENCE | CONSTRUCTED)
-		: BERGeneralDecoder(inQueue, asnTag) {}
-};
-
-//! DER Sequence Encoder
-class DERSequenceEncoder : public DERGeneralEncoder
-{
-public:
-	explicit DERSequenceEncoder(BufferedTransformation &outQueue, byte asnTag = SEQUENCE | CONSTRUCTED)
-		: DERGeneralEncoder(outQueue, asnTag) {}
-	explicit DERSequenceEncoder(DERSequenceEncoder &outQueue, byte asnTag = SEQUENCE | CONSTRUCTED)
-		: DERGeneralEncoder(outQueue, asnTag) {}
-};
-
-//! BER Set Decoder
-class BERSetDecoder : public BERGeneralDecoder
-{
-public:
-	explicit BERSetDecoder(BufferedTransformation &inQueue, byte asnTag = SET | CONSTRUCTED)
-		: BERGeneralDecoder(inQueue, asnTag) {}
-	explicit BERSetDecoder(BERSetDecoder &inQueue, byte asnTag = SET | CONSTRUCTED)
-		: BERGeneralDecoder(inQueue, asnTag) {}
-};
-
-//! DER Set Encoder
-class DERSetEncoder : public DERGeneralEncoder
-{
-public:
-	explicit DERSetEncoder(BufferedTransformation &outQueue, byte asnTag = SET | CONSTRUCTED)
-		: DERGeneralEncoder(outQueue, asnTag) {}
-	explicit DERSetEncoder(DERSetEncoder &outQueue, byte asnTag = SET | CONSTRUCTED)
-		: DERGeneralEncoder(outQueue, asnTag) {}
-};
-
-template <class T>
-class ASNOptional : public member_ptr<T>
-{
-public:
-	void BERDecode(BERSequenceDecoder &seqDecoder, byte tag, byte mask = ~CONSTRUCTED)
-	{
-		byte b;
-		if (seqDecoder.Peek(b) && (b & mask) == tag)
-			reset(new T(seqDecoder));
-	}
-	void DEREncode(BufferedTransformation &out)
-	{
-		if (get() != NULL)
-			get()->DEREncode(out);
-	}
-};
-
-//! .
-class ASN1Key : public ASN1CryptoMaterial
-{
-public:
-	virtual OID GetAlgorithmID() const =0;
-	virtual bool BERDecodeAlgorithmParameters(BufferedTransformation &bt)
-		{BERDecodeNull(bt); return false;}
-	virtual bool DEREncodeAlgorithmParameters(BufferedTransformation &bt) const
-		{DEREncodeNull(bt); return false;}	// see RFC 2459, section 7.3.1
-	// one of the following two should be overriden
-	//! decode subjectPublicKey part of subjectPublicKeyInfo, or privateKey part of privateKeyInfo, without the BIT STRING or OCTET STRING header
-	virtual void BERDecodeKey(BufferedTransformation &bt) {assert(false);}
-	virtual void BERDecodeKey2(BufferedTransformation &bt, bool parametersPresent, unsigned int size)
-		{BERDecodeKey(bt);}
-	//! encode subjectPublicKey part of subjectPublicKeyInfo, or privateKey part of privateKeyInfo, without the BIT STRING or OCTET STRING header
-	virtual void DEREncodeKey(BufferedTransformation &bt) const =0;
-};
-
-//! encodes/decodes subjectPublicKeyInfo
-class X509PublicKey : virtual public ASN1Key, public PublicKey
-{
-public:
-	void BERDecode(BufferedTransformation &bt);
-	void DEREncode(BufferedTransformation &bt) const;
-};
-
-//! encodes/decodes privateKeyInfo
-class PKCS8PrivateKey : virtual public ASN1Key, public PrivateKey
-{
-public:
-	void BERDecode(BufferedTransformation &bt);
-	void DEREncode(BufferedTransformation &bt) const;
-
-	virtual void BERDecodeOptionalAttributes(BufferedTransformation &bt)
-		{}	// TODO: skip optional attributes if present
-	virtual void DEREncodeOptionalAttributes(BufferedTransformation &bt) const
-		{}
-};
-
-// ********************************************************
-
-//! DER Encode Unsigned
-/*! for INTEGER, BOOLEAN, and ENUM */
-template <class T>
-unsigned int DEREncodeUnsigned(BufferedTransformation &out, T w, byte asnTag = INTEGER)
-{
-	byte buf[sizeof(w)+1];
-	unsigned int bc;
-	if (asnTag == BOOLEAN)
-	{
-		buf[sizeof(w)] = w ? 0xff : 0;
-		bc = 1;
-	}
-	else
-	{
-		buf[0] = 0;
-		for (unsigned int i=0; i<sizeof(w); i++)
-			buf[i+1] = byte(w >> (sizeof(w)-1-i)*8);
-		bc = sizeof(w);
-		while (bc > 1 && buf[sizeof(w)+1-bc] == 0)
-			--bc;
-		if (buf[sizeof(w)+1-bc] & 0x80)
-			++bc;
-	}
-	out.Put(asnTag);
-	unsigned int lengthBytes = DERLengthEncode(out, bc);
-	out.Put(buf+sizeof(w)+1-bc, bc);
-	return 1+lengthBytes+bc;
-}
-
-//! BER Decode Unsigned
-// VC60 workaround: std::numeric_limits<T>::max conflicts with MFC max macro
-// CW41 workaround: std::numeric_limits<T>::max causes a template error
-template <class T>
-void BERDecodeUnsigned(BufferedTransformation &in, T &w, byte asnTag = INTEGER,
-					   T minValue = 0, T maxValue = 0xffffffff)
-{
-	byte b;
-	if (!in.Get(b) || b != asnTag)
-		BERDecodeError();
-
-	unsigned int bc;
-	BERLengthDecode(in, bc);
-
-	SecByteBlock buf(bc);
-
-	if (bc != in.Get(buf, bc))
-		BERDecodeError();
-
-	const byte *ptr = buf;
-	while (bc > sizeof(w) && *ptr == 0)
-	{
-		bc--;
-		ptr++;
-	}
-	if (bc > sizeof(w))
-		BERDecodeError();
-
-	w = 0;
-	for (unsigned int i=0; i<bc; i++)
-		w = (w << 8) | ptr[i];
-
-	if (w < minValue || w > maxValue)
-		BERDecodeError();
-}
-
-inline bool operator==(const ::CryptoPP::OID &lhs, const ::CryptoPP::OID &rhs)
-	{return lhs.m_values == rhs.m_values;}
-inline bool operator!=(const ::CryptoPP::OID &lhs, const ::CryptoPP::OID &rhs)
-	{return lhs.m_values != rhs.m_values;}
-inline bool operator<(const ::CryptoPP::OID &lhs, const ::CryptoPP::OID &rhs)
-	{return std::lexicographical_compare(lhs.m_values.begin(), lhs.m_values.end(), rhs.m_values.begin(), rhs.m_values.end());}
-inline ::CryptoPP::OID operator+(const ::CryptoPP::OID &lhs, unsigned long rhs)
-	{return ::CryptoPP::OID(lhs)+=rhs;}
-
-NAMESPACE_END
-
-#endif
+#ifndef CRYPTOPP_ASN_H
+#define CRYPTOPP_ASN_H
+
+#include "filters.h"
+#include "queue.h"
+#include <vector>
+
+NAMESPACE_BEGIN(CryptoPP)
+
+// these tags and flags are not complete
+enum ASNTag
+{
+	BOOLEAN 			= 0x01,
+	INTEGER 			= 0x02,
+	BIT_STRING			= 0x03,
+	OCTET_STRING		= 0x04,
+	TAG_NULL			= 0x05,
+	OBJECT_IDENTIFIER	= 0x06,
+	OBJECT_DESCRIPTOR	= 0x07,
+	EXTERNAL			= 0x08,
+	REAL				= 0x09,
+	ENUMERATED			= 0x0a,
+	UTF8_STRING			= 0x0c,
+	SEQUENCE			= 0x10,
+	SET 				= 0x11,
+	NUMERIC_STRING		= 0x12,
+	PRINTABLE_STRING 	= 0x13,
+	T61_STRING			= 0x14,
+	VIDEOTEXT_STRING 	= 0x15,
+	IA5_STRING			= 0x16,
+	UTC_TIME 			= 0x17,
+	GENERALIZED_TIME 	= 0x18,
+	GRAPHIC_STRING		= 0x19,
+	VISIBLE_STRING		= 0x1a,
+	GENERAL_STRING		= 0x1b
+};
+
+enum ASNIdFlag
+{
+	UNIVERSAL			= 0x00,
+//	DATA				= 0x01,
+//	HEADER				= 0x02,
+	CONSTRUCTED 		= 0x20,
+	APPLICATION 		= 0x40,
+	CONTEXT_SPECIFIC	= 0x80,
+	PRIVATE 			= 0xc0
+};
+
+inline void BERDecodeError() {throw BERDecodeErr();}
+
+class CRYPTOPP_DLL UnknownOID : public BERDecodeErr
+{
+public:
+	UnknownOID() : BERDecodeErr("BER decode error: unknown object identifier") {}
+	UnknownOID(const char *err) : BERDecodeErr(err) {}
+};
+
+// unsigned int DERLengthEncode(unsigned int length, byte *output=0);
+CRYPTOPP_DLL size_t CRYPTOPP_API DERLengthEncode(BufferedTransformation &out, lword length);
+// returns false if indefinite length
+CRYPTOPP_DLL bool CRYPTOPP_API BERLengthDecode(BufferedTransformation &in, size_t &length);
+
+CRYPTOPP_DLL void CRYPTOPP_API DEREncodeNull(BufferedTransformation &out);
+CRYPTOPP_DLL void CRYPTOPP_API BERDecodeNull(BufferedTransformation &in);
+
+CRYPTOPP_DLL size_t CRYPTOPP_API DEREncodeOctetString(BufferedTransformation &out, const byte *str, size_t strLen);
+CRYPTOPP_DLL size_t CRYPTOPP_API DEREncodeOctetString(BufferedTransformation &out, const SecByteBlock &str);
+CRYPTOPP_DLL size_t CRYPTOPP_API BERDecodeOctetString(BufferedTransformation &in, SecByteBlock &str);
+CRYPTOPP_DLL size_t CRYPTOPP_API BERDecodeOctetString(BufferedTransformation &in, BufferedTransformation &str);
+
+// for UTF8_STRING, PRINTABLE_STRING, and IA5_STRING
+CRYPTOPP_DLL size_t CRYPTOPP_API DEREncodeTextString(BufferedTransformation &out, const std::string &str, byte asnTag);
+CRYPTOPP_DLL size_t CRYPTOPP_API BERDecodeTextString(BufferedTransformation &in, std::string &str, byte asnTag);
+
+CRYPTOPP_DLL size_t CRYPTOPP_API DEREncodeBitString(BufferedTransformation &out, const byte *str, size_t strLen, unsigned int unusedBits=0);
+CRYPTOPP_DLL size_t CRYPTOPP_API BERDecodeBitString(BufferedTransformation &in, SecByteBlock &str, unsigned int &unusedBits);
+
+// BER decode from source and DER reencode into dest
+CRYPTOPP_DLL void CRYPTOPP_API DERReencode(BufferedTransformation &source, BufferedTransformation &dest);
+
+//! Object Identifier
+class CRYPTOPP_DLL OID
+{
+public:
+	OID() {}
+	OID(word32 v) : m_values(1, v) {}
+	OID(BufferedTransformation &bt) {BERDecode(bt);}
+
+	inline OID & operator+=(word32 rhs) {m_values.push_back(rhs); return *this;}
+
+	void DEREncode(BufferedTransformation &bt) const;
+	void BERDecode(BufferedTransformation &bt);
+
+	// throw BERDecodeErr() if decoded value doesn't equal this OID
+	void BERDecodeAndCheck(BufferedTransformation &bt) const;
+
+	std::vector<word32> m_values;
+
+private:
+	static void EncodeValue(BufferedTransformation &bt, word32 v);
+	static size_t DecodeValue(BufferedTransformation &bt, word32 &v);
+};
+
+class EncodedObjectFilter : public Filter
+{
+public:
+	enum Flag {PUT_OBJECTS=1, PUT_MESSANGE_END_AFTER_EACH_OBJECT=2, PUT_MESSANGE_END_AFTER_ALL_OBJECTS=4, PUT_MESSANGE_SERIES_END_AFTER_ALL_OBJECTS=8};
+	EncodedObjectFilter(BufferedTransformation *attachment = NULL, unsigned int nObjects = 1, word32 flags = 0);
+
+	void Put(const byte *inString, size_t length);
+
+	unsigned int GetNumberOfCompletedObjects() const {return m_nCurrentObject;}
+	unsigned long GetPositionOfObject(unsigned int i) const {return m_positions[i];}
+
+private:
+	BufferedTransformation & CurrentTarget();
+
+	word32 m_flags;
+	unsigned int m_nObjects, m_nCurrentObject, m_level;
+	std::vector<unsigned int> m_positions;
+	ByteQueue m_queue;
+	enum State {IDENTIFIER, LENGTH, BODY, TAIL, ALL_DONE} m_state;
+	byte m_id;
+	lword m_lengthRemaining;
+};
+
+//! BER General Decoder
+class CRYPTOPP_DLL BERGeneralDecoder : public Store
+{
+public:
+	explicit BERGeneralDecoder(BufferedTransformation &inQueue, byte asnTag);
+	explicit BERGeneralDecoder(BERGeneralDecoder &inQueue, byte asnTag);
+	~BERGeneralDecoder();
+
+	bool IsDefiniteLength() const {return m_definiteLength;}
+	lword RemainingLength() const {assert(m_definiteLength); return m_length;}
+	bool EndReached() const;
+	byte PeekByte() const;
+	void CheckByte(byte b);
+
+	size_t TransferTo2(BufferedTransformation &target, lword &transferBytes, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true);
+	size_t CopyRangeTo2(BufferedTransformation &target, lword &begin, lword end=LWORD_MAX, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true) const;
+
+	// call this to denote end of sequence
+	void MessageEnd();
+
+protected:
+	BufferedTransformation &m_inQueue;
+	bool m_finished, m_definiteLength;
+	lword m_length;
+
+private:
+	void Init(byte asnTag);
+	void StoreInitialize(const NameValuePairs &parameters) {assert(false);}
+	lword ReduceLength(lword delta);
+};
+
+//! DER General Encoder
+class CRYPTOPP_DLL DERGeneralEncoder : public ByteQueue
+{
+public:
+	explicit DERGeneralEncoder(BufferedTransformation &outQueue, byte asnTag = SEQUENCE | CONSTRUCTED);
+	explicit DERGeneralEncoder(DERGeneralEncoder &outQueue, byte asnTag = SEQUENCE | CONSTRUCTED);
+	~DERGeneralEncoder();
+
+	// call this to denote end of sequence
+	void MessageEnd();
+
+private:
+	BufferedTransformation &m_outQueue;
+	bool m_finished;
+
+	byte m_asnTag;
+};
+
+//! BER Sequence Decoder
+class CRYPTOPP_DLL BERSequenceDecoder : public BERGeneralDecoder
+{
+public:
+	explicit BERSequenceDecoder(BufferedTransformation &inQueue, byte asnTag = SEQUENCE | CONSTRUCTED)
+		: BERGeneralDecoder(inQueue, asnTag) {}
+	explicit BERSequenceDecoder(BERSequenceDecoder &inQueue, byte asnTag = SEQUENCE | CONSTRUCTED)
+		: BERGeneralDecoder(inQueue, asnTag) {}
+};
+
+//! DER Sequence Encoder
+class CRYPTOPP_DLL DERSequenceEncoder : public DERGeneralEncoder
+{
+public:
+	explicit DERSequenceEncoder(BufferedTransformation &outQueue, byte asnTag = SEQUENCE | CONSTRUCTED)
+		: DERGeneralEncoder(outQueue, asnTag) {}
+	explicit DERSequenceEncoder(DERSequenceEncoder &outQueue, byte asnTag = SEQUENCE | CONSTRUCTED)
+		: DERGeneralEncoder(outQueue, asnTag) {}
+};
+
+//! BER Set Decoder
+class CRYPTOPP_DLL BERSetDecoder : public BERGeneralDecoder
+{
+public:
+	explicit BERSetDecoder(BufferedTransformation &inQueue, byte asnTag = SET | CONSTRUCTED)
+		: BERGeneralDecoder(inQueue, asnTag) {}
+	explicit BERSetDecoder(BERSetDecoder &inQueue, byte asnTag = SET | CONSTRUCTED)
+		: BERGeneralDecoder(inQueue, asnTag) {}
+};
+
+//! DER Set Encoder
+class CRYPTOPP_DLL DERSetEncoder : public DERGeneralEncoder
+{
+public:
+	explicit DERSetEncoder(BufferedTransformation &outQueue, byte asnTag = SET | CONSTRUCTED)
+		: DERGeneralEncoder(outQueue, asnTag) {}
+	explicit DERSetEncoder(DERSetEncoder &outQueue, byte asnTag = SET | CONSTRUCTED)
+		: DERGeneralEncoder(outQueue, asnTag) {}
+};
+
+template <class T>
+class ASNOptional : public member_ptr<T>
+{
+public:
+	void BERDecode(BERSequenceDecoder &seqDecoder, byte tag, byte mask = ~CONSTRUCTED)
+	{
+		byte b;
+		if (seqDecoder.Peek(b) && (b & mask) == tag)
+			reset(new T(seqDecoder));
+	}
+	void DEREncode(BufferedTransformation &out)
+	{
+		if (this->get() != NULL)
+			this->get()->DEREncode(out);
+	}
+};
+
+//! _
+template <class BASE>
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE ASN1CryptoMaterial : public ASN1Object, public BASE
+{
+public:
+	void Save(BufferedTransformation &bt) const
+		{BEREncode(bt);}
+	void Load(BufferedTransformation &bt)
+		{BERDecode(bt);}
+};
+
+//! encodes/decodes subjectPublicKeyInfo
+class CRYPTOPP_DLL X509PublicKey : public ASN1CryptoMaterial<PublicKey>
+{
+public:
+	void BERDecode(BufferedTransformation &bt);
+	void DEREncode(BufferedTransformation &bt) const;
+
+	virtual OID GetAlgorithmID() const =0;
+	virtual bool BERDecodeAlgorithmParameters(BufferedTransformation &bt)
+		{BERDecodeNull(bt); return false;}
+	virtual bool DEREncodeAlgorithmParameters(BufferedTransformation &bt) const
+		{DEREncodeNull(bt); return false;}	// see RFC 2459, section 7.3.1
+
+	//! decode subjectPublicKey part of subjectPublicKeyInfo, without the BIT STRING header
+	virtual void BERDecodePublicKey(BufferedTransformation &bt, bool parametersPresent, size_t size) =0;
+	//! encode subjectPublicKey part of subjectPublicKeyInfo, without the BIT STRING header
+	virtual void DEREncodePublicKey(BufferedTransformation &bt) const =0;
+};
+
+//! encodes/decodes privateKeyInfo
+class CRYPTOPP_DLL PKCS8PrivateKey : public ASN1CryptoMaterial<PrivateKey>
+{
+public:
+	void BERDecode(BufferedTransformation &bt);
+	void DEREncode(BufferedTransformation &bt) const;
+
+	virtual OID GetAlgorithmID() const =0;
+	virtual bool BERDecodeAlgorithmParameters(BufferedTransformation &bt)
+		{BERDecodeNull(bt); return false;}
+	virtual bool DEREncodeAlgorithmParameters(BufferedTransformation &bt) const
+		{DEREncodeNull(bt); return false;}	// see RFC 2459, section 7.3.1
+
+	//! decode privateKey part of privateKeyInfo, without the OCTET STRING header
+	virtual void BERDecodePrivateKey(BufferedTransformation &bt, bool parametersPresent, size_t size) =0;
+	//! encode privateKey part of privateKeyInfo, without the OCTET STRING header
+	virtual void DEREncodePrivateKey(BufferedTransformation &bt) const =0;
+
+	//! decode optional attributes including context-specific tag
+	/*! /note default implementation stores attributes to be output in DEREncodeOptionalAttributes */
+	virtual void BERDecodeOptionalAttributes(BufferedTransformation &bt);
+	//! encode optional attributes including context-specific tag
+	virtual void DEREncodeOptionalAttributes(BufferedTransformation &bt) const;
+
+protected:
+	ByteQueue m_optionalAttributes;
+};
+
+// ********************************************************
+
+//! DER Encode Unsigned
+/*! for INTEGER, BOOLEAN, and ENUM */
+template <class T>
+size_t DEREncodeUnsigned(BufferedTransformation &out, T w, byte asnTag = INTEGER)
+{
+	byte buf[sizeof(w)+1];
+	unsigned int bc;
+	if (asnTag == BOOLEAN)
+	{
+		buf[sizeof(w)] = w ? 0xff : 0;
+		bc = 1;
+	}
+	else
+	{
+		buf[0] = 0;
+		for (unsigned int i=0; i<sizeof(w); i++)
+			buf[i+1] = byte(w >> (sizeof(w)-1-i)*8);
+		bc = sizeof(w);
+		while (bc > 1 && buf[sizeof(w)+1-bc] == 0)
+			--bc;
+		if (buf[sizeof(w)+1-bc] & 0x80)
+			++bc;
+	}
+	out.Put(asnTag);
+	size_t lengthBytes = DERLengthEncode(out, bc);
+	out.Put(buf+sizeof(w)+1-bc, bc);
+	return 1+lengthBytes+bc;
+}
+
+//! BER Decode Unsigned
+// VC60 workaround: std::numeric_limits<T>::max conflicts with MFC max macro
+// CW41 workaround: std::numeric_limits<T>::max causes a template error
+template <class T>
+void BERDecodeUnsigned(BufferedTransformation &in, T &w, byte asnTag = INTEGER,
+					   T minValue = 0, T maxValue = 0xffffffff)
+{
+	byte b;
+	if (!in.Get(b) || b != asnTag)
+		BERDecodeError();
+
+	size_t bc;
+	BERLengthDecode(in, bc);
+
+	SecByteBlock buf(bc);
+
+	if (bc != in.Get(buf, bc))
+		BERDecodeError();
+
+	const byte *ptr = buf;
+	while (bc > sizeof(w) && *ptr == 0)
+	{
+		bc--;
+		ptr++;
+	}
+	if (bc > sizeof(w))
+		BERDecodeError();
+
+	w = 0;
+	for (unsigned int i=0; i<bc; i++)
+		w = (w << 8) | ptr[i];
+
+	if (w < minValue || w > maxValue)
+		BERDecodeError();
+}
+
+inline bool operator==(const ::CryptoPP::OID &lhs, const ::CryptoPP::OID &rhs)
+	{return lhs.m_values == rhs.m_values;}
+inline bool operator!=(const ::CryptoPP::OID &lhs, const ::CryptoPP::OID &rhs)
+	{return lhs.m_values != rhs.m_values;}
+inline bool operator<(const ::CryptoPP::OID &lhs, const ::CryptoPP::OID &rhs)
+	{return std::lexicographical_compare(lhs.m_values.begin(), lhs.m_values.end(), rhs.m_values.begin(), rhs.m_values.end());}
+inline ::CryptoPP::OID operator+(const ::CryptoPP::OID &lhs, unsigned long rhs)
+	{return ::CryptoPP::OID(lhs)+=rhs;}
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/basecode.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/basecode.h
index 30412e72..cc44c434 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/basecode.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/basecode.h
@@ -1,82 +1,86 @@
-#ifndef CRYPTOPP_BASECODE_H
-#define CRYPTOPP_BASECODE_H
-
-#include "filters.h"
-#include "algparam.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-class BaseN_Encoder : public Unflushable<Filter>
-{
-public:
-	BaseN_Encoder(BufferedTransformation *attachment=NULL)
-		: Unflushable<Filter>(attachment) {}
-
-	BaseN_Encoder(const byte *alphabet, int log2base, BufferedTransformation *attachment=NULL, int padding=-1)
-		: Unflushable<Filter>(attachment)
-	{
-		IsolatedInitialize(MakeParameters("EncodingLookupArray", alphabet)
-			("Log2Base", log2base)
-			("Pad", padding != -1)
-			("PaddingByte", byte(padding)));
-	}
-
-	void IsolatedInitialize(const NameValuePairs &parameters);
-	unsigned int Put2(const byte *begin, unsigned int length, int messageEnd, bool blocking);
-
-private:
-	const byte *m_alphabet;
-	int m_padding, m_bitsPerChar, m_outputBlockSize;
-	int m_bytePos, m_bitPos;
-	SecByteBlock m_outBuf;
-};
-
-class BaseN_Decoder : public Unflushable<Filter>
-{
-public:
-	BaseN_Decoder(BufferedTransformation *attachment=NULL)
-		: Unflushable<Filter>(attachment) {}
-
-	BaseN_Decoder(const int *lookup, int log2base, BufferedTransformation *attachment=NULL)
-		: Unflushable<Filter>(attachment)
-	{
-		IsolatedInitialize(MakeParameters("DecodingLookupArray", lookup)("Log2Base", log2base));
-	}
-
-	void IsolatedInitialize(const NameValuePairs &parameters);
-	unsigned int Put2(const byte *begin, unsigned int length, int messageEnd, bool blocking);
-
-	static void InitializeDecodingLookupArray(int *lookup, const byte *alphabet, unsigned int log2base, bool caseInsensitive);
-
-private:
-	const int *m_lookup;
-	int m_padding, m_bitsPerChar, m_outputBlockSize;
-	int m_bytePos, m_bitPos;
-	SecByteBlock m_outBuf;
-};
-
-class Grouper : public Bufferless<Filter>
-{
-public:
-	Grouper(BufferedTransformation *attachment=NULL)
-		: Bufferless<Filter>(attachment) {}
-
-	Grouper(int groupSize, const std::string &separator, const std::string &terminator, BufferedTransformation *attachment=NULL)
-		: Bufferless<Filter>(attachment)
-	{
-		IsolatedInitialize(MakeParameters("GroupSize", groupSize)
-			("Separator", ConstByteArrayParameter(separator))
-			("Terminator", ConstByteArrayParameter(terminator)));
-	}
-
-	void IsolatedInitialize(const NameValuePairs &parameters);
-	unsigned int Put2(const byte *begin, unsigned int length, int messageEnd, bool blocking);
-
-private:
-	SecByteBlock m_separator, m_terminator;
-	unsigned int m_groupSize, m_counter;
-};
-
-NAMESPACE_END
-
-#endif
+#ifndef CRYPTOPP_BASECODE_H
+#define CRYPTOPP_BASECODE_H
+
+#include "filters.h"
+#include "algparam.h"
+#include "argnames.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+//! base n encoder, where n is a power of 2
+class CRYPTOPP_DLL BaseN_Encoder : public Unflushable<Filter>
+{
+public:
+	BaseN_Encoder(BufferedTransformation *attachment=NULL)
+		{Detach(attachment);}
+
+	BaseN_Encoder(const byte *alphabet, int log2base, BufferedTransformation *attachment=NULL, int padding=-1)
+	{
+		Detach(attachment);
+		IsolatedInitialize(MakeParameters(Name::EncodingLookupArray(), alphabet)
+			(Name::Log2Base(), log2base)
+			(Name::Pad(), padding != -1)
+			(Name::PaddingByte(), byte(padding)));
+	}
+
+	void IsolatedInitialize(const NameValuePairs &parameters);
+	size_t Put2(const byte *begin, size_t length, int messageEnd, bool blocking);
+
+private:
+	const byte *m_alphabet;
+	int m_padding, m_bitsPerChar, m_outputBlockSize;
+	int m_bytePos, m_bitPos;
+	SecByteBlock m_outBuf;
+};
+
+//! base n decoder, where n is a power of 2
+class CRYPTOPP_DLL BaseN_Decoder : public Unflushable<Filter>
+{
+public:
+	BaseN_Decoder(BufferedTransformation *attachment=NULL)
+		{Detach(attachment);}
+
+	BaseN_Decoder(const int *lookup, int log2base, BufferedTransformation *attachment=NULL)
+	{
+		Detach(attachment);
+		IsolatedInitialize(MakeParameters(Name::DecodingLookupArray(), lookup)(Name::Log2Base(), log2base));
+	}
+
+	void IsolatedInitialize(const NameValuePairs &parameters);
+	size_t Put2(const byte *begin, size_t length, int messageEnd, bool blocking);
+
+	static void CRYPTOPP_API InitializeDecodingLookupArray(int *lookup, const byte *alphabet, unsigned int base, bool caseInsensitive);
+
+private:
+	const int *m_lookup;
+	int m_padding, m_bitsPerChar, m_outputBlockSize;
+	int m_bytePos, m_bitPos;
+	SecByteBlock m_outBuf;
+};
+
+//! filter that breaks input stream into groups of fixed size
+class CRYPTOPP_DLL Grouper : public Bufferless<Filter>
+{
+public:
+	Grouper(BufferedTransformation *attachment=NULL)
+		{Detach(attachment);}
+
+	Grouper(int groupSize, const std::string &separator, const std::string &terminator, BufferedTransformation *attachment=NULL)
+	{
+		Detach(attachment);
+		IsolatedInitialize(MakeParameters(Name::GroupSize(), groupSize)
+			(Name::Separator(), ConstByteArrayParameter(separator))
+			(Name::Terminator(), ConstByteArrayParameter(terminator)));
+	}
+
+	void IsolatedInitialize(const NameValuePairs &parameters);
+	size_t Put2(const byte *begin, size_t length, int messageEnd, bool blocking);
+
+private:
+	SecByteBlock m_separator, m_terminator;
+	size_t m_groupSize, m_counter;
+};
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/config.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/config.h
index 18c6e026..ac887069 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/config.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/config.h
@@ -1,247 +1,462 @@
-#ifndef CRYPTOPP_CONFIG_H
-#define CRYPTOPP_CONFIG_H
-
-// ***************** Important Settings ********************
-
-// define this if running on a big-endian CPU
-#if !defined(IS_LITTLE_ENDIAN) && (defined(__BIG_ENDIAN__) || defined(__sparc) || defined(__sparc__) || defined(__hppa__) || defined(__mips__) || (defined(__MWERKS__) && !defined(__INTEL__)))
-#	define IS_BIG_ENDIAN
-#endif
-
-// define this if running on a little-endian CPU
-// big endian will be assumed if IS_LITTLE_ENDIAN is not defined
-#ifndef IS_BIG_ENDIAN
-#	define IS_LITTLE_ENDIAN
-#endif
-
-// define this if you want to disable all OS-dependent features,
-// such as sockets and OS-provided random number generators
-// #define NO_OS_DEPENDENCE
-
-// Define this to use features provided by Microsoft's CryptoAPI.
-// Currently the only feature used is random number generation.
-// This macro will be ignored if NO_OS_DEPENDENCE is defined.
-#define USE_MS_CRYPTOAPI
-
-// Define this to 1 to enforce the requirement in FIPS 186-2 Change Notice 1 that only 1024 bit moduli be used
-#ifndef DSA_1024_BIT_MODULUS_ONLY
-#	define DSA_1024_BIT_MODULUS_ONLY 1
-#endif
-
-// ***************** Less Important Settings ***************
-
-// define this to retain (as much as possible) old deprecated function and class names
-// #define CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
-
-#define GZIP_OS_CODE 0
-
-// Try this if your CPU has 256K internal cache or a slow multiply instruction
-// and you want a (possibly) faster IDEA implementation using log tables
-// #define IDEA_LARGECACHE
-
-// Try this if you have a large cache or your CPU is slow manipulating
-// individual bytes.
-// #define DIAMOND_USE_PERMTABLE
-
-// Define this if, for the linear congruential RNG, you want to use
-// the original constants as specified in S.K. Park and K.W. Miller's
-// CACM paper.
-// #define LCRNG_ORIGINAL_NUMBERS
-
-// choose which style of sockets to wrap (mostly useful for cygwin which has both)
-#define PREFER_BERKELEY_STYLE_SOCKETS
-// #define PREFER_WINDOWS_STYLE_SOCKETS
-
-// ***************** Important Settings Again ********************
-// But the defaults should be ok.
-
-// namespace support is now required
-#ifdef NO_NAMESPACE
-#	error namespace support is now required
-#endif
-
-// Define this to workaround a Microsoft CryptoAPI bug where
-// each call to CryptAcquireContext causes a 100 KB memory leak.
-// Defining this will cause Crypto++ to make only one call to CryptAcquireContext.
-#define WORKAROUND_MS_BUG_Q258000
-
-// Avoid putting "CryptoPP::" in front of everything in Doxygen output
-#ifdef CRYPTOPP_DOXYGEN_PROCESSING
-#	define CryptoPP
-#	define NAMESPACE_BEGIN(x)
-#	define NAMESPACE_END
-#else
-#	define NAMESPACE_BEGIN(x) namespace x {
-#	define NAMESPACE_END }
-#endif
-#define ANONYMOUS_NAMESPACE_BEGIN namespace {
-#define USING_NAMESPACE(x) using namespace x;
-#define DOCUMENTED_NAMESPACE_BEGIN(x) namespace x {
-#define DOCUMENTED_NAMESPACE_END }
-
-// What is the type of the third parameter to bind?
-// For Unix, the new standard is ::socklen_t (typically unsigned int), and the old standard is int.
-// Unfortunately there is no way to tell whether or not socklen_t is defined.
-// To work around this, TYPE_OF_SOCKLEN_T is a macro so that you can change it from the makefile.
-#ifndef TYPE_OF_SOCKLEN_T
-#	if defined(_WIN32) || defined(__CYGWIN__) || defined(__MACH__)
-#		define TYPE_OF_SOCKLEN_T int
-#	else
-#		define TYPE_OF_SOCKLEN_T ::socklen_t
-#	endif
-#endif
-
-#if defined(__CYGWIN__) && defined(PREFER_WINDOWS_STYLE_SOCKETS)
-#	define __USE_W32_SOCKETS
-#endif
-
-typedef unsigned char byte;     // moved outside namespace for Borland C++Builder 5
-
-NAMESPACE_BEGIN(CryptoPP)
-
-typedef unsigned short word16;
-#if defined(__alpha) && !defined(_MSC_VER)
-	typedef unsigned int word32;
-#else
-	typedef unsigned long word32;
-#endif
-
-#if defined(__GNUC__) || defined(__MWERKS__)
-#	define WORD64_AVAILABLE
-	typedef unsigned long long word64;
-#	define W64LIT(x) x##LL
-#elif defined(_MSC_VER) || defined(__BCPLUSPLUS__)
-#	define WORD64_AVAILABLE
-	typedef unsigned __int64 word64;
-#	define W64LIT(x) x##ui64
-#endif
-
-// defined this if your CPU is not 64-bit
-#if defined(WORD64_AVAILABLE) && !defined(__alpha)
-#	define SLOW_WORD64
-#endif
-
-// word should have the same size as your CPU registers
-// dword should be twice as big as word
-
-#if (defined(__GNUC__) && !defined(__alpha)) || defined(__MWERKS__)
-	typedef unsigned long word;
-	typedef unsigned long long dword;
-#elif defined(_MSC_VER) || defined(__BCPLUSPLUS__)
-	typedef unsigned __int32 word;
-	typedef unsigned __int64 dword;
-#else
-	typedef unsigned int word;
-	typedef unsigned long dword;
-#endif
-
-const unsigned int WORD_SIZE = sizeof(word);
-const unsigned int WORD_BITS = WORD_SIZE * 8;
-
-#define LOW_WORD(x) (word)(x)
-
-union dword_union
-{
-	dword_union (const dword &dw) : dw(dw) {}
-	dword dw;
-	word w[2];
-};
-
-#ifdef IS_LITTLE_ENDIAN
-#	define HIGH_WORD(x) (dword_union(x).w[1])
-#else
-#	define HIGH_WORD(x) (dword_union(x).w[0])
-#endif
-
-// if the above HIGH_WORD macro doesn't work (if you are not sure, compile it
-// and run the validation tests), try this:
-// #define HIGH_WORD(x) (word)((x)>>WORD_BITS)
-
-#if defined(_MSC_VER) || defined(__BCPLUSPLUS__)
-#	define INTEL_INTRINSICS
-#	define FAST_ROTATE
-#elif defined(__MWERKS__) && TARGET_CPU_PPC
-#	define PPC_INTRINSICS
-#	define FAST_ROTATE
-#elif defined(__GNUC__) && defined(__i386__)
-	// GCC does peephole optimizations which should result in using rotate instructions
-#	define FAST_ROTATE
-#endif
-
-NAMESPACE_END
-
-// VC60 workaround: it doesn't allow typename in some places
-#if defined(_MSC_VER) && (_MSC_VER < 1300)
-#define CPP_TYPENAME
-#else
-#define CPP_TYPENAME typename
-#endif
-
-#ifdef _MSC_VER
-	// 4250: dominance
-	// 4660: explicitly instantiating a class that's already implicitly instantiated
-	// 4661: no suitable definition provided for explicit template instantiation request
-	// 4786: identifer was truncated in debug information
-	// 4355: 'this' : used in base member initializer list
-#	pragma warning(disable: 4250 4660 4661 4786 4355)
-#endif
-
-// ***************** determine availability of OS features ********************
-
-#ifndef NO_OS_DEPENDENCE
-
-#if defined(_WIN32) || defined(__CYGWIN__)
-#define CRYPTOPP_WIN32_AVAILABLE
-#endif
-
-#if defined(__unix__) || defined(__MACH__)
-#define CRYPTOPP_UNIX_AVAILABLE
-#endif
-
-#if defined(WORD64_AVAILABLE) && (defined(CRYPTOPP_WIN32_AVAILABLE) || defined(CRYPTOPP_UNIX_AVAILABLE) || defined(macintosh))
-#	define HIGHRES_TIMER_AVAILABLE
-#endif
-
-#ifdef CRYPTOPP_UNIX_AVAILABLE
-#	define HAS_BERKELEY_STYLE_SOCKETS
-#endif
-
-#ifdef CRYPTOPP_WIN32_AVAILABLE
-#	define HAS_WINDOWS_STYLE_SOCKETS
-#endif
-
-#if defined(HIGHRES_TIMER_AVAILABLE) && (defined(HAS_BERKELEY_STYLE_SOCKETS) || defined(HAS_WINDOWS_STYLE_SOCKETS))
-#	define SOCKETS_AVAILABLE
-#endif
-
-#if defined(HAS_WINDOWS_STYLE_SOCKETS) && (!defined(HAS_BERKELEY_STYLE_SOCKETS) || defined(PREFER_WINDOWS_STYLE_SOCKETS))
-#	define USE_WINDOWS_STYLE_SOCKETS
-#else
-#	define USE_BERKELEY_STYLE_SOCKETS
-#endif
-
-#if defined(CRYPTOPP_WIN32_AVAILABLE) && !defined(USE_BERKELEY_STYLE_SOCKETS)
-#	define WINDOWS_PIPES_AVAILABLE
-#endif
-
-#if defined(CRYPTOPP_WIN32_AVAILABLE) && defined(USE_MS_CRYPTOAPI)
-#	define NONBLOCKING_RNG_AVAILABLE
-#	define OS_RNG_AVAILABLE
-#endif
-
-#ifdef CRYPTOPP_UNIX_AVAILABLE
-#	define NONBLOCKING_RNG_AVAILABLE
-#	define BLOCKING_RNG_AVAILABLE
-#	define OS_RNG_AVAILABLE
-#	define HAS_PTHREADS
-#	define THREADS_AVAILABLE
-#endif
-
-#ifdef CRYPTOPP_WIN32_AVAILABLE
-#	define HAS_WINTHREADS
-#	define THREADS_AVAILABLE
-#endif
-
-#endif	// NO_OS_DEPENDENCE
-
-#endif
+#ifndef CRYPTOPP_CONFIG_H
+#define CRYPTOPP_CONFIG_H
+
+// ***************** Important Settings ********************
+
+// define this if running on a big-endian CPU
+#if !defined(IS_LITTLE_ENDIAN) && (defined(__BIG_ENDIAN__) || defined(__sparc) || defined(__sparc__) || defined(__hppa__) || defined(__MIPSEB__) || defined(__ARMEB__) || (defined(__MWERKS__) && !defined(__INTEL__)))
+#	define IS_BIG_ENDIAN
+#endif
+
+// define this if running on a little-endian CPU
+// big endian will be assumed if IS_LITTLE_ENDIAN is not defined
+#ifndef IS_BIG_ENDIAN
+#	define IS_LITTLE_ENDIAN
+#endif
+
+// define this if you want to disable all OS-dependent features,
+// such as sockets and OS-provided random number generators
+// #define NO_OS_DEPENDENCE
+
+// Define this to use features provided by Microsoft's CryptoAPI.
+// Currently the only feature used is random number generation.
+// This macro will be ignored if NO_OS_DEPENDENCE is defined.
+#define USE_MS_CRYPTOAPI
+
+// Define this to 1 to enforce the requirement in FIPS 186-2 Change Notice 1 that only 1024 bit moduli be used
+#ifndef DSA_1024_BIT_MODULUS_ONLY
+#	define DSA_1024_BIT_MODULUS_ONLY 1
+#endif
+
+// ***************** Less Important Settings ***************
+
+// define this to retain (as much as possible) old deprecated function and class names
+// #define CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
+
+#define GZIP_OS_CODE 0
+
+// Try this if your CPU has 256K internal cache or a slow multiply instruction
+// and you want a (possibly) faster IDEA implementation using log tables
+// #define IDEA_LARGECACHE
+
+// Define this if, for the linear congruential RNG, you want to use
+// the original constants as specified in S.K. Park and K.W. Miller's
+// CACM paper.
+// #define LCRNG_ORIGINAL_NUMBERS
+
+// choose which style of sockets to wrap (mostly useful for cygwin which has both)
+#define PREFER_BERKELEY_STYLE_SOCKETS
+// #define PREFER_WINDOWS_STYLE_SOCKETS
+
+// set the name of Rijndael cipher, was "Rijndael" before version 5.3
+#define CRYPTOPP_RIJNDAEL_NAME "AES"
+
+// ***************** Important Settings Again ********************
+// But the defaults should be ok.
+
+// namespace support is now required
+#ifdef NO_NAMESPACE
+#	error namespace support is now required
+#endif
+
+// Define this to workaround a Microsoft CryptoAPI bug where
+// each call to CryptAcquireContext causes a 100 KB memory leak.
+// Defining this will cause Crypto++ to make only one call to CryptAcquireContext.
+#define WORKAROUND_MS_BUG_Q258000
+
+#ifdef CRYPTOPP_DOXYGEN_PROCESSING
+// Avoid putting "CryptoPP::" in front of everything in Doxygen output
+#	define CryptoPP
+#	define NAMESPACE_BEGIN(x)
+#	define NAMESPACE_END
+// Get Doxygen to generate better documentation for these typedefs
+#	define DOCUMENTED_TYPEDEF(x, y) class y : public x {};
+#else
+#	define NAMESPACE_BEGIN(x) namespace x {
+#	define NAMESPACE_END }
+#	define DOCUMENTED_TYPEDEF(x, y) typedef x y;
+#endif
+#define ANONYMOUS_NAMESPACE_BEGIN namespace {
+#define USING_NAMESPACE(x) using namespace x;
+#define DOCUMENTED_NAMESPACE_BEGIN(x) namespace x {
+#define DOCUMENTED_NAMESPACE_END }
+
+// What is the type of the third parameter to bind?
+// For Unix, the new standard is ::socklen_t (typically unsigned int), and the old standard is int.
+// Unfortunately there is no way to tell whether or not socklen_t is defined.
+// To work around this, TYPE_OF_SOCKLEN_T is a macro so that you can change it from the makefile.
+#ifndef TYPE_OF_SOCKLEN_T
+#	if defined(_WIN32) || defined(__CYGWIN__)
+#		define TYPE_OF_SOCKLEN_T int
+#	else
+#		define TYPE_OF_SOCKLEN_T ::socklen_t
+#	endif
+#endif
+
+#if defined(__CYGWIN__) && defined(PREFER_WINDOWS_STYLE_SOCKETS)
+#	define __USE_W32_SOCKETS
+#endif
+
+typedef unsigned char byte;		// put in global namespace to avoid ambiguity with other byte typedefs
+
+NAMESPACE_BEGIN(CryptoPP)
+
+typedef unsigned short word16;
+typedef unsigned int word32;
+
+#if defined(_MSC_VER) || defined(__BORLANDC__)
+	typedef unsigned __int64 word64;
+	#define W64LIT(x) x##ui64
+#else
+	typedef unsigned long long word64;
+	#define W64LIT(x) x##ULL
+#endif
+
+// define large word type, used for file offsets and such
+typedef word64 lword;
+const lword LWORD_MAX = W64LIT(0xffffffffffffffff);
+
+#ifdef __GNUC__
+	#define CRYPTOPP_GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)
+#endif
+
+// define hword, word, and dword. these are used for multiprecision integer arithmetic
+// Intel compiler won't have _umul128 until version 10.0. See http://softwarecommunity.intel.com/isn/Community/en-US/forums/thread/30231625.aspx
+#if (defined(_MSC_VER) && (!defined(__INTEL_COMPILER) || __INTEL_COMPILER >= 1000) && (defined(_M_X64) || defined(_M_IA64))) || (defined(__DECCXX) && defined(__alpha__)) || (defined(__INTEL_COMPILER) && defined(__x86_64__)) || (defined(__SUNPRO_CC) && defined(__x86_64__))
+	typedef word32 hword;
+	typedef word64 word;
+#else
+	#define CRYPTOPP_NATIVE_DWORD_AVAILABLE
+	#if defined(__alpha__) || defined(__ia64__) || defined(_ARCH_PPC64) || defined(__x86_64__) || defined(__mips64) || defined(__sparc64__)
+		#if defined(__GNUC__) && !defined(__INTEL_COMPILER) && !(CRYPTOPP_GCC_VERSION == 40001 && defined(__APPLE__)) && CRYPTOPP_GCC_VERSION >= 30400
+			// GCC 4.0.1 on MacOS X is missing __umodti3 and __udivti3
+			// mode(TI) division broken on amd64 with GCC earlier than GCC 3.4
+			typedef word32 hword;
+			typedef word64 word;
+			typedef __uint128_t dword;
+			typedef __uint128_t word128;
+			#define CRYPTOPP_WORD128_AVAILABLE
+		#else
+			// if we're here, it means we're on a 64-bit CPU but we don't have a way to obtain 128-bit multiplication results
+			typedef word16 hword;
+			typedef word32 word;
+			typedef word64 dword;
+		#endif
+	#else
+		// being here means the native register size is probably 32 bits or less
+		#define CRYPTOPP_BOOL_SLOW_WORD64 1
+		typedef word16 hword;
+		typedef word32 word;
+		typedef word64 dword;
+	#endif
+#endif
+#ifndef CRYPTOPP_BOOL_SLOW_WORD64
+	#define CRYPTOPP_BOOL_SLOW_WORD64 0
+#endif
+
+const unsigned int WORD_SIZE = sizeof(word);
+const unsigned int WORD_BITS = WORD_SIZE * 8;
+
+NAMESPACE_END
+
+#ifndef CRYPTOPP_L1_CACHE_LINE_SIZE
+	// This should be a lower bound on the L1 cache line size. It's used for defense against timing attacks.
+	#if defined(_M_X64) || defined(__x86_64__)
+		#define CRYPTOPP_L1_CACHE_LINE_SIZE 64
+	#else
+		// L1 cache line size is 32 on Pentium III and earlier
+		#define CRYPTOPP_L1_CACHE_LINE_SIZE 32
+	#endif
+#endif
+
+#if defined(_MSC_VER)
+	#if _MSC_VER == 1200
+		#include <malloc.h>
+	#endif
+	#if _MSC_VER > 1200 || defined(_mm_free)
+		#define CRYPTOPP_MSVC6PP_OR_LATER		// VC 6 processor pack or later
+	#else
+		#define CRYPTOPP_MSVC6_NO_PP			// VC 6 without processor pack
+	#endif
+#endif
+
+#ifndef CRYPTOPP_ALIGN_DATA
+	#if defined(CRYPTOPP_MSVC6PP_OR_LATER)
+		#define CRYPTOPP_ALIGN_DATA(x) __declspec(align(x))
+	#elif defined(__GNUC__)
+		#define CRYPTOPP_ALIGN_DATA(x) __attribute__((aligned(x)))
+	#else
+		#define CRYPTOPP_ALIGN_DATA(x)
+	#endif
+#endif
+
+#ifndef CRYPTOPP_SECTION_ALIGN16
+	#if defined(__GNUC__) && !defined(__APPLE__)
+		// the alignment attribute doesn't seem to work without this section attribute when -fdata-sections is turned on
+		#define CRYPTOPP_SECTION_ALIGN16 __attribute__((section ("CryptoPP_Align16")))
+	#else
+		#define CRYPTOPP_SECTION_ALIGN16
+	#endif
+#endif
+
+#if defined(_MSC_VER) || defined(__fastcall)
+	#define CRYPTOPP_FASTCALL __fastcall
+#else
+	#define CRYPTOPP_FASTCALL
+#endif
+
+// VC60 workaround: it doesn't allow typename in some places
+#if defined(_MSC_VER) && (_MSC_VER < 1300)
+#define CPP_TYPENAME
+#else
+#define CPP_TYPENAME typename
+#endif
+
+// VC60 workaround: can't cast unsigned __int64 to float or double
+#if defined(_MSC_VER) && !defined(CRYPTOPP_MSVC6PP_OR_LATER)
+#define CRYPTOPP_VC6_INT64 (__int64)
+#else
+#define CRYPTOPP_VC6_INT64
+#endif
+
+#ifdef _MSC_VER
+#define CRYPTOPP_NO_VTABLE __declspec(novtable)
+#else
+#define CRYPTOPP_NO_VTABLE
+#endif
+
+#ifdef _MSC_VER
+	// 4231: nonstandard extension used : 'extern' before template explicit instantiation
+	// 4250: dominance
+	// 4251: member needs to have dll-interface
+	// 4275: base needs to have dll-interface
+	// 4660: explicitly instantiating a class that's already implicitly instantiated
+	// 4661: no suitable definition provided for explicit template instantiation request
+	// 4786: identifer was truncated in debug information
+	// 4355: 'this' : used in base member initializer list
+	// 4910: '__declspec(dllexport)' and 'extern' are incompatible on an explicit instantiation
+#	pragma warning(disable: 4231 4250 4251 4275 4660 4661 4786 4355 4910)
+#endif
+
+#ifdef __BORLANDC__
+// 8037: non-const function called for const object. needed to work around BCB2006 bug
+#	pragma warn -8037
+#endif
+
+#if (defined(_MSC_VER) && _MSC_VER <= 1300) || defined(__MWERKS__) || defined(_STLPORT_VERSION)
+#define CRYPTOPP_DISABLE_UNCAUGHT_EXCEPTION
+#endif
+
+#ifndef CRYPTOPP_DISABLE_UNCAUGHT_EXCEPTION
+#define CRYPTOPP_UNCAUGHT_EXCEPTION_AVAILABLE
+#endif
+
+#ifdef CRYPTOPP_DISABLE_X86ASM		// for backwards compatibility: this macro had both meanings
+#define CRYPTOPP_DISABLE_ASM
+#define CRYPTOPP_DISABLE_SSE2
+#endif
+
+#if !defined(CRYPTOPP_DISABLE_ASM) && ((defined(_MSC_VER) && defined(_M_IX86)) || (defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))))
+	// C++Builder 2010 does not allow "call label" where label is defined within inline assembly
+	#define CRYPTOPP_X86_ASM_AVAILABLE
+
+	#if !defined(CRYPTOPP_DISABLE_SSE2) && (defined(CRYPTOPP_MSVC6PP_OR_LATER) || CRYPTOPP_GCC_VERSION >= 30300)
+		#define CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE 1
+	#else
+		#define CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE 0
+	#endif
+
+	// SSSE3 was actually introduced in GNU as 2.17, which was released 6/23/2006, but we can't tell what version of binutils is installed.
+	// GCC 4.1.2 was released on 2/13/2007, so we'll use that as a proxy for the binutils version.
+	#if !defined(CRYPTOPP_DISABLE_SSSE3) && (_MSC_VER >= 1400 || CRYPTOPP_GCC_VERSION >= 40102)
+		#define CRYPTOPP_BOOL_SSSE3_ASM_AVAILABLE 1
+	#else
+		#define CRYPTOPP_BOOL_SSSE3_ASM_AVAILABLE 0
+	#endif
+#endif
+
+#if !defined(CRYPTOPP_DISABLE_ASM) && defined(_MSC_VER) && defined(_M_X64)
+	#define CRYPTOPP_X64_MASM_AVAILABLE
+#endif
+
+#if !defined(CRYPTOPP_DISABLE_ASM) && defined(__GNUC__) && defined(__x86_64__)
+	#define CRYPTOPP_X64_ASM_AVAILABLE
+#endif
+
+#if !defined(CRYPTOPP_DISABLE_SSE2) && (defined(CRYPTOPP_MSVC6PP_OR_LATER) || defined(__SSE2__))
+	#define CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE 1
+#else
+	#define CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE 0
+#endif
+
+#if !defined(CRYPTOPP_DISABLE_SSSE3) && !defined(CRYPTOPP_DISABLE_AESNI) && CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE && (CRYPTOPP_GCC_VERSION >= 40400 || _MSC_FULL_VER >= 150030729 || __INTEL_COMPILER >= 1110)
+	#define CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE 1
+#else
+	#define CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE 0
+#endif
+
+#if CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE || CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)
+	#define CRYPTOPP_BOOL_ALIGN16_ENABLED 1
+#else
+	#define CRYPTOPP_BOOL_ALIGN16_ENABLED 0
+#endif
+
+// how to allocate 16-byte aligned memory (for SSE2)
+#if defined(CRYPTOPP_MSVC6PP_OR_LATER)
+	#define CRYPTOPP_MM_MALLOC_AVAILABLE
+#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
+	#define CRYPTOPP_MALLOC_ALIGNMENT_IS_16
+#elif defined(__linux__) || defined(__sun__) || defined(__CYGWIN__)
+	#define CRYPTOPP_MEMALIGN_AVAILABLE
+#else
+	#define CRYPTOPP_NO_ALIGNED_ALLOC
+#endif
+
+// how to disable inlining
+#if defined(_MSC_VER) && _MSC_VER >= 1300
+#	define CRYPTOPP_NOINLINE_DOTDOTDOT
+#	define CRYPTOPP_NOINLINE __declspec(noinline)
+#elif defined(__GNUC__)
+#	define CRYPTOPP_NOINLINE_DOTDOTDOT
+#	define CRYPTOPP_NOINLINE __attribute__((noinline))
+#else
+#	define CRYPTOPP_NOINLINE_DOTDOTDOT ...
+#	define CRYPTOPP_NOINLINE 
+#endif
+
+// how to declare class constants
+#if (defined(_MSC_VER) && _MSC_VER <= 1300) || defined(__INTEL_COMPILER)
+#	define CRYPTOPP_CONSTANT(x) enum {x};
+#else
+#	define CRYPTOPP_CONSTANT(x) static const int x;
+#endif
+
+#if defined(_M_X64) || defined(__x86_64__)
+	#define CRYPTOPP_BOOL_X64 1
+#else
+	#define CRYPTOPP_BOOL_X64 0
+#endif
+
+// see http://predef.sourceforge.net/prearch.html
+#if defined(_M_IX86) || defined(__i386__) || defined(__i386) || defined(_X86_) || defined(__I86__) || defined(__INTEL__)
+	#define CRYPTOPP_BOOL_X86 1
+#else
+	#define CRYPTOPP_BOOL_X86 0
+#endif
+
+#if CRYPTOPP_BOOL_X64 || CRYPTOPP_BOOL_X86 || defined(__powerpc__)
+	#define CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS
+#endif
+
+#define CRYPTOPP_VERSION 561
+
+// ***************** determine availability of OS features ********************
+
+#ifndef NO_OS_DEPENDENCE
+
+#if defined(_WIN32) || defined(__CYGWIN__)
+#define CRYPTOPP_WIN32_AVAILABLE
+#endif
+
+#if defined(__unix__) || defined(__MACH__) || defined(__NetBSD__) || defined(__sun)
+#define CRYPTOPP_UNIX_AVAILABLE
+#endif
+
+#if defined(CRYPTOPP_WIN32_AVAILABLE) || defined(CRYPTOPP_UNIX_AVAILABLE)
+#	define HIGHRES_TIMER_AVAILABLE
+#endif
+
+#ifdef CRYPTOPP_UNIX_AVAILABLE
+#	define HAS_BERKELEY_STYLE_SOCKETS
+#endif
+
+#ifdef CRYPTOPP_WIN32_AVAILABLE
+#	define HAS_WINDOWS_STYLE_SOCKETS
+#endif
+
+#if defined(HIGHRES_TIMER_AVAILABLE) && (defined(HAS_BERKELEY_STYLE_SOCKETS) || defined(HAS_WINDOWS_STYLE_SOCKETS))
+#	define SOCKETS_AVAILABLE
+#endif
+
+#if defined(HAS_WINDOWS_STYLE_SOCKETS) && (!defined(HAS_BERKELEY_STYLE_SOCKETS) || defined(PREFER_WINDOWS_STYLE_SOCKETS))
+#	define USE_WINDOWS_STYLE_SOCKETS
+#else
+#	define USE_BERKELEY_STYLE_SOCKETS
+#endif
+
+#if defined(HIGHRES_TIMER_AVAILABLE) && defined(CRYPTOPP_WIN32_AVAILABLE) && !defined(USE_BERKELEY_STYLE_SOCKETS)
+#	define WINDOWS_PIPES_AVAILABLE
+#endif
+
+#if defined(CRYPTOPP_WIN32_AVAILABLE) && defined(USE_MS_CRYPTOAPI)
+#	define NONBLOCKING_RNG_AVAILABLE
+#	define OS_RNG_AVAILABLE
+#endif
+
+#if defined(CRYPTOPP_UNIX_AVAILABLE) || defined(CRYPTOPP_DOXYGEN_PROCESSING)
+#	define NONBLOCKING_RNG_AVAILABLE
+#	define BLOCKING_RNG_AVAILABLE
+#	define OS_RNG_AVAILABLE
+#	define HAS_PTHREADS
+#	define THREADS_AVAILABLE
+#endif
+
+#ifdef CRYPTOPP_WIN32_AVAILABLE
+#	define HAS_WINTHREADS
+#	define THREADS_AVAILABLE
+#endif
+
+#endif	// NO_OS_DEPENDENCE
+
+// ***************** DLL related ********************
+
+#if defined(CRYPTOPP_WIN32_AVAILABLE) && !defined(CRYPTOPP_DOXYGEN_PROCESSING)
+
+#ifdef CRYPTOPP_EXPORTS
+#define CRYPTOPP_IS_DLL
+#define CRYPTOPP_DLL __declspec(dllexport)
+#elif defined(CRYPTOPP_IMPORTS)
+#define CRYPTOPP_IS_DLL
+#define CRYPTOPP_DLL __declspec(dllimport)
+#else
+#define CRYPTOPP_DLL
+#endif
+
+#define CRYPTOPP_API __cdecl
+
+#else	// CRYPTOPP_WIN32_AVAILABLE
+
+#define CRYPTOPP_DLL
+#define CRYPTOPP_API
+
+#endif	// CRYPTOPP_WIN32_AVAILABLE
+
+#if defined(__MWERKS__)
+#define CRYPTOPP_EXTERN_DLL_TEMPLATE_CLASS extern class CRYPTOPP_DLL
+#elif defined(__BORLANDC__) || defined(__SUNPRO_CC)
+#define CRYPTOPP_EXTERN_DLL_TEMPLATE_CLASS template class CRYPTOPP_DLL
+#else
+#define CRYPTOPP_EXTERN_DLL_TEMPLATE_CLASS extern template class CRYPTOPP_DLL
+#endif
+
+#if defined(CRYPTOPP_MANUALLY_INSTANTIATE_TEMPLATES) && !defined(CRYPTOPP_IMPORTS)
+#define CRYPTOPP_DLL_TEMPLATE_CLASS template class CRYPTOPP_DLL
+#else
+#define CRYPTOPP_DLL_TEMPLATE_CLASS CRYPTOPP_EXTERN_DLL_TEMPLATE_CLASS
+#endif
+
+#if defined(__MWERKS__)
+#define CRYPTOPP_EXTERN_STATIC_TEMPLATE_CLASS extern class
+#elif defined(__BORLANDC__) || defined(__SUNPRO_CC)
+#define CRYPTOPP_EXTERN_STATIC_TEMPLATE_CLASS template class
+#else
+#define CRYPTOPP_EXTERN_STATIC_TEMPLATE_CLASS extern template class
+#endif
+
+#if defined(CRYPTOPP_MANUALLY_INSTANTIATE_TEMPLATES) && !defined(CRYPTOPP_EXPORTS)
+#define CRYPTOPP_STATIC_TEMPLATE_CLASS template class
+#else
+#define CRYPTOPP_STATIC_TEMPLATE_CLASS CRYPTOPP_EXTERN_STATIC_TEMPLATE_CLASS
+#endif
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/cpu.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/cpu.h
new file mode 100644
index 00000000..65029d33
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/cpu.h
@@ -0,0 +1,345 @@
+#ifndef CRYPTOPP_CPU_H
+#define CRYPTOPP_CPU_H
+
+#ifdef CRYPTOPP_GENERATE_X64_MASM
+
+#define CRYPTOPP_X86_ASM_AVAILABLE
+#define CRYPTOPP_BOOL_X64 1
+#define CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE 1
+#define NAMESPACE_END
+
+#else
+
+#include "config.h"
+
+#if CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE
+#include <emmintrin.h>
+#endif
+
+#if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE
+#if !defined(__GNUC__) || defined(__SSSE3__) || defined(__INTEL_COMPILER)
+#include <tmmintrin.h>
+#else
+__inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+_mm_shuffle_epi8 (__m128i a, __m128i b)
+{
+	asm ("pshufb %1, %0" : "+x"(a) : "xm"(b));
+  	return a;
+}
+#endif
+#if !defined(__GNUC__) || defined(__SSE4_1__) || defined(__INTEL_COMPILER)
+#include <smmintrin.h>
+#else
+__inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+_mm_extract_epi32 (__m128i a, const int i)
+{
+	int r;
+	asm ("pextrd %2, %1, %0" : "=rm"(r) : "x"(a), "i"(i));
+  	return r;
+}
+__inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+_mm_insert_epi32 (__m128i a, int b, const int i)
+{
+	asm ("pinsrd %2, %1, %0" : "+x"(a) : "rm"(b), "i"(i));
+  	return a;
+}
+#endif
+#if !defined(__GNUC__) || (defined(__AES__) && defined(__PCLMUL__)) || defined(__INTEL_COMPILER)
+#include <wmmintrin.h>
+#else
+__inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+_mm_clmulepi64_si128 (__m128i a, __m128i b, const int i)
+{
+	asm ("pclmulqdq %2, %1, %0" : "+x"(a) : "xm"(b), "i"(i));
+  	return a;
+}
+__inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+_mm_aeskeygenassist_si128 (__m128i a, const int i)
+{
+	__m128i r;
+	asm ("aeskeygenassist %2, %1, %0" : "=x"(r) : "xm"(a), "i"(i));
+  	return r;
+}
+__inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+_mm_aesimc_si128 (__m128i a)
+{
+	__m128i r;
+	asm ("aesimc %1, %0" : "=x"(r) : "xm"(a));
+  	return r;
+}
+__inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+_mm_aesenc_si128 (__m128i a, __m128i b)
+{
+	asm ("aesenc %1, %0" : "+x"(a) : "xm"(b));
+  	return a;
+}
+__inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+_mm_aesenclast_si128 (__m128i a, __m128i b)
+{
+	asm ("aesenclast %1, %0" : "+x"(a) : "xm"(b));
+  	return a;
+}
+__inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+_mm_aesdec_si128 (__m128i a, __m128i b)
+{
+	asm ("aesdec %1, %0" : "+x"(a) : "xm"(b));
+  	return a;
+}
+__inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+_mm_aesdeclast_si128 (__m128i a, __m128i b)
+{
+	asm ("aesdeclast %1, %0" : "+x"(a) : "xm"(b));
+  	return a;
+}
+#endif
+#endif
+
+NAMESPACE_BEGIN(CryptoPP)
+
+#if CRYPTOPP_BOOL_X86 || CRYPTOPP_BOOL_X64
+
+#define CRYPTOPP_CPUID_AVAILABLE
+
+// these should not be used directly
+extern CRYPTOPP_DLL bool g_x86DetectionDone;
+extern CRYPTOPP_DLL bool g_hasSSSE3;
+extern CRYPTOPP_DLL bool g_hasAESNI;
+extern CRYPTOPP_DLL bool g_hasCLMUL;
+extern CRYPTOPP_DLL bool g_isP4;
+extern CRYPTOPP_DLL word32 g_cacheLineSize;
+CRYPTOPP_DLL void CRYPTOPP_API DetectX86Features();
+CRYPTOPP_DLL bool CRYPTOPP_API CpuId(word32 input, word32 *output);
+
+#if CRYPTOPP_BOOL_X64
+inline bool HasSSE2()	{return true;}
+inline bool HasISSE()	{return true;}
+inline bool HasMMX()	{return true;}
+#else
+
+extern CRYPTOPP_DLL bool g_hasSSE2;
+extern CRYPTOPP_DLL bool g_hasISSE;
+extern CRYPTOPP_DLL bool g_hasMMX;
+
+inline bool HasSSE2()
+{
+	if (!g_x86DetectionDone)
+		DetectX86Features();
+	return g_hasSSE2;
+}
+
+inline bool HasISSE()
+{
+	if (!g_x86DetectionDone)
+		DetectX86Features();
+	return g_hasISSE;
+}
+
+inline bool HasMMX()
+{
+	if (!g_x86DetectionDone)
+		DetectX86Features();
+	return g_hasMMX;
+}
+
+#endif
+
+inline bool HasSSSE3()
+{
+	if (!g_x86DetectionDone)
+		DetectX86Features();
+	return g_hasSSSE3;
+}
+
+inline bool HasAESNI()
+{
+	if (!g_x86DetectionDone)
+		DetectX86Features();
+	return g_hasAESNI;
+}
+
+inline bool HasCLMUL()
+{
+	if (!g_x86DetectionDone)
+		DetectX86Features();
+	return g_hasCLMUL;
+}
+
+inline bool IsP4()
+{
+	if (!g_x86DetectionDone)
+		DetectX86Features();
+	return g_isP4;
+}
+
+inline int GetCacheLineSize()
+{
+	if (!g_x86DetectionDone)
+		DetectX86Features();
+	return g_cacheLineSize;
+}
+
+#else
+
+inline int GetCacheLineSize()
+{
+	return CRYPTOPP_L1_CACHE_LINE_SIZE;
+}
+
+#endif
+
+#endif
+
+#ifdef CRYPTOPP_GENERATE_X64_MASM
+	#define AS1(x) x*newline*
+	#define AS2(x, y) x, y*newline*
+	#define AS3(x, y, z) x, y, z*newline*
+	#define ASS(x, y, a, b, c, d) x, y, a*64+b*16+c*4+d*newline*
+	#define ASL(x) label##x:*newline*
+	#define ASJ(x, y, z) x label##y*newline*
+	#define ASC(x, y) x label##y*newline*
+	#define AS_HEX(y) 0##y##h
+#elif defined(_MSC_VER) || defined(__BORLANDC__)
+	#define CRYPTOPP_MS_STYLE_INLINE_ASSEMBLY
+	#define AS1(x) __asm {x}
+	#define AS2(x, y) __asm {x, y}
+	#define AS3(x, y, z) __asm {x, y, z}
+	#define ASS(x, y, a, b, c, d) __asm {x, y, (a)*64+(b)*16+(c)*4+(d)}
+	#define ASL(x) __asm {label##x:}
+	#define ASJ(x, y, z) __asm {x label##y}
+	#define ASC(x, y) __asm {x label##y}
+	#define CRYPTOPP_NAKED __declspec(naked)
+	#define AS_HEX(y) 0x##y
+#else
+	#define CRYPTOPP_GNU_STYLE_INLINE_ASSEMBLY
+	// define these in two steps to allow arguments to be expanded
+	#define GNU_AS1(x) #x ";"
+	#define GNU_AS2(x, y) #x ", " #y ";"
+	#define GNU_AS3(x, y, z) #x ", " #y ", " #z ";"
+	#define GNU_ASL(x) "\n" #x ":"
+	#define GNU_ASJ(x, y, z) #x " " #y #z ";"
+	#define AS1(x) GNU_AS1(x)
+	#define AS2(x, y) GNU_AS2(x, y)
+	#define AS3(x, y, z) GNU_AS3(x, y, z)
+	#define ASS(x, y, a, b, c, d) #x ", " #y ", " #a "*64+" #b "*16+" #c "*4+" #d ";"
+	#define ASL(x) GNU_ASL(x)
+	#define ASJ(x, y, z) GNU_ASJ(x, y, z)
+	#define ASC(x, y) #x " " #y ";"
+	#define CRYPTOPP_NAKED
+	#define AS_HEX(y) 0x##y
+#endif
+
+#define IF0(y)
+#define IF1(y) y
+
+#ifdef CRYPTOPP_GENERATE_X64_MASM
+#define ASM_MOD(x, y) ((x) MOD (y))
+#define XMMWORD_PTR XMMWORD PTR
+#else
+// GNU assembler doesn't seem to have mod operator
+#define ASM_MOD(x, y) ((x)-((x)/(y))*(y))
+// GAS 2.15 doesn't support XMMWORD PTR. it seems necessary only for MASM
+#define XMMWORD_PTR
+#endif
+
+#if CRYPTOPP_BOOL_X86
+	#define AS_REG_1 ecx
+	#define AS_REG_2 edx
+	#define AS_REG_3 esi
+	#define AS_REG_4 edi
+	#define AS_REG_5 eax
+	#define AS_REG_6 ebx
+	#define AS_REG_7 ebp
+	#define AS_REG_1d ecx
+	#define AS_REG_2d edx
+	#define AS_REG_3d esi
+	#define AS_REG_4d edi
+	#define AS_REG_5d eax
+	#define AS_REG_6d ebx
+	#define AS_REG_7d ebp
+	#define WORD_SZ 4
+	#define WORD_REG(x)	e##x
+	#define WORD_PTR DWORD PTR
+	#define AS_PUSH_IF86(x) AS1(push e##x)
+	#define AS_POP_IF86(x) AS1(pop e##x)
+	#define AS_JCXZ jecxz
+#elif CRYPTOPP_BOOL_X64
+	#ifdef CRYPTOPP_GENERATE_X64_MASM
+		#define AS_REG_1 rcx
+		#define AS_REG_2 rdx
+		#define AS_REG_3 r8
+		#define AS_REG_4 r9
+		#define AS_REG_5 rax
+		#define AS_REG_6 r10
+		#define AS_REG_7 r11
+		#define AS_REG_1d ecx
+		#define AS_REG_2d edx
+		#define AS_REG_3d r8d
+		#define AS_REG_4d r9d
+		#define AS_REG_5d eax
+		#define AS_REG_6d r10d
+		#define AS_REG_7d r11d
+	#else
+		#define AS_REG_1 rdi
+		#define AS_REG_2 rsi
+		#define AS_REG_3 rdx
+		#define AS_REG_4 rcx
+		#define AS_REG_5 r8
+		#define AS_REG_6 r9
+		#define AS_REG_7 r10
+		#define AS_REG_1d edi
+		#define AS_REG_2d esi
+		#define AS_REG_3d edx
+		#define AS_REG_4d ecx
+		#define AS_REG_5d r8d
+		#define AS_REG_6d r9d
+		#define AS_REG_7d r10d
+	#endif
+	#define WORD_SZ 8
+	#define WORD_REG(x)	r##x
+	#define WORD_PTR QWORD PTR
+	#define AS_PUSH_IF86(x)
+	#define AS_POP_IF86(x)
+	#define AS_JCXZ jrcxz
+#endif
+
+// helper macro for stream cipher output
+#define AS_XMM_OUTPUT4(labelPrefix, inputPtr, outputPtr, x0, x1, x2, x3, t, p0, p1, p2, p3, increment)\
+	AS2(	test	inputPtr, inputPtr)\
+	ASC(	jz,		labelPrefix##3)\
+	AS2(	test	inputPtr, 15)\
+	ASC(	jnz,	labelPrefix##7)\
+	AS2(	pxor	xmm##x0, [inputPtr+p0*16])\
+	AS2(	pxor	xmm##x1, [inputPtr+p1*16])\
+	AS2(	pxor	xmm##x2, [inputPtr+p2*16])\
+	AS2(	pxor	xmm##x3, [inputPtr+p3*16])\
+	AS2(	add		inputPtr, increment*16)\
+	ASC(	jmp,	labelPrefix##3)\
+	ASL(labelPrefix##7)\
+	AS2(	movdqu	xmm##t, [inputPtr+p0*16])\
+	AS2(	pxor	xmm##x0, xmm##t)\
+	AS2(	movdqu	xmm##t, [inputPtr+p1*16])\
+	AS2(	pxor	xmm##x1, xmm##t)\
+	AS2(	movdqu	xmm##t, [inputPtr+p2*16])\
+	AS2(	pxor	xmm##x2, xmm##t)\
+	AS2(	movdqu	xmm##t, [inputPtr+p3*16])\
+	AS2(	pxor	xmm##x3, xmm##t)\
+	AS2(	add		inputPtr, increment*16)\
+	ASL(labelPrefix##3)\
+	AS2(	test	outputPtr, 15)\
+	ASC(	jnz,	labelPrefix##8)\
+	AS2(	movdqa	[outputPtr+p0*16], xmm##x0)\
+	AS2(	movdqa	[outputPtr+p1*16], xmm##x1)\
+	AS2(	movdqa	[outputPtr+p2*16], xmm##x2)\
+	AS2(	movdqa	[outputPtr+p3*16], xmm##x3)\
+	ASC(	jmp,	labelPrefix##9)\
+	ASL(labelPrefix##8)\
+	AS2(	movdqu	[outputPtr+p0*16], xmm##x0)\
+	AS2(	movdqu	[outputPtr+p1*16], xmm##x1)\
+	AS2(	movdqu	[outputPtr+p2*16], xmm##x2)\
+	AS2(	movdqu	[outputPtr+p3*16], xmm##x3)\
+	ASL(labelPrefix##9)\
+	AS2(	add		outputPtr, increment*16)
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/cryptlib.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/cryptlib.h
index 324c0e79..0ad18de8 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/cryptlib.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/cryptlib.h
@@ -1,1564 +1,1655 @@
-// cryptlib.h - written and placed in the public domain by Wei Dai
-/*! \file
- 	This file contains the declarations for the abstract base
-	classes that provide a uniform interface to this library.
-*/
-
-/*!	\mainpage <a href="http://www.cryptopp.com">Crypto++</a><sup><small>TM</small></sup> Library 5.1 Reference Manual
-<dl>
-<dt>Abstract Base Classes<dd>
-	cryptlib.h
-<dt>Symmetric Ciphers<dd>
-	SymmetricCipherDocumentation
-<dt>Hash Functions<dd>
-	HAVAL, MD2, MD4, MD5, PanamaHash, RIPEMD160, SHA, SHA256, SHA384, SHA512, Tiger
-<dt>Non-Cryptographic Checksums<dd>
-	CRC32, Adler32
-<dt>Message Authentication Codes<dd>
-	#MD5MAC, XMACC, HMAC, CBC_MAC, DMAC, PanamaMAC
-<dt>Random Number Generators<dd>
-	NullRNG(), LC_RNG, RandomPool, BlockingRng, NonblockingRng, AutoSeededRandomPool, AutoSeededX917RNG
-<dt>Public Key Cryptosystems<dd>
-	DLIES, ECIES, LUCES, RSAES, RabinES, LUC_IES
-<dt>Public Key Signature Schemes<dd>
-	DSA, GDSA, ECDSA, NR, ECNR, LUCSS, RSASS, RabinSS, RWSS, ESIGN
-<dt>Key Agreement<dd>
-	#DH, DH2, #MQV, ECDH, ECMQV, XTR_DH
-<dt>Algebraic Structures<dd>
-	Integer, PolynomialMod2, PolynomialOver, RingOfPolynomialsOver,
-	ModularArithmetic, MontgomeryRepresentation, GFP2_ONB,
-	GF2NP, GF256, GF2_32, EC2N, ECP
-<dt>Secret Sharing and Information Dispersal<dd>
-	SecretSharing, SecretRecovery, InformationDispersal, InformationRecovery
-<dt>Compression<dd>
-	Deflator, Inflator, Gzip, Gunzip, ZlibCompressor, ZlibDecompressor
-<dt>Input Source Classes<dd>
-	StringSource, FileSource, SocketSource, WindowsPipeSource, RandomNumberSource
-<dt>Output Sink Classes<dd>
-	StringSinkTemplate, ArraySink, FileSink, SocketSink, WindowsPipeSink
-<dt>Filter Wrappers<dd>
-	StreamTransformationFilter, HashFilter, HashVerificationFilter, SignerFilter, SignatureVerificationFilter
-<dt>Binary to Text Encoders and Decoders<dd>
-	HexEncoder, HexDecoder, Base64Encoder, Base64Decoder
-<dt>Wrappers for OS features<dd>
-	Timer, Socket, WindowsHandle, ThreadLocalStorage
-<dt>FIPS 140 related<dd>
-	fips140.h
-</dl>
-
-<p>This reference manual is a work in progress. Some classes are still lacking detailed descriptions.
-<p>Click <a href="CryptoPPRef.zip">here</a> to download a zip archive containing this manual.
-<p>Thanks to Ryan Phillips for providing the Doxygen configuration file
-and getting me started with this manual.
-*/
-
-#ifndef CRYPTOPP_CRYPTLIB_H
-#define CRYPTOPP_CRYPTLIB_H
-
-#include "config.h"
-#include <limits.h>
-#include <exception>
-#include <string>
-#include <typeinfo>
-#include <assert.h>
-
-NAMESPACE_BEGIN(CryptoPP)
-
-// forward declarations
-class Integer;
-
-//! used to specify a direction for a cipher to operate in (encrypt or decrypt)
-enum CipherDir {ENCRYPTION,	DECRYPTION};
-
-//! used to represent infinite time
-const unsigned long INFINITE_TIME = ULONG_MAX;
-
-// VC60 workaround: using enums as template parameters causes problems
-template <typename ENUM_TYPE, int VALUE>
-struct EnumToType
-{
-	static ENUM_TYPE ToEnum() {return (ENUM_TYPE)VALUE;}
-};
-
-enum ByteOrder {LITTLE_ENDIAN_ORDER = 0, BIG_ENDIAN_ORDER = 1};
-typedef EnumToType<ByteOrder, LITTLE_ENDIAN_ORDER> LittleEndian;
-typedef EnumToType<ByteOrder, BIG_ENDIAN_ORDER> BigEndian;
-
-//! base class for all exceptions thrown by Crypto++
-class Exception : public std::exception
-{
-public:
-	//! error types
-	enum ErrorType {
-		//! a method is not implemented
-		NOT_IMPLEMENTED,
-		//! invalid function argument
-		INVALID_ARGUMENT,
-		//! BufferedTransformation received a Flush(true) signal but can't flush buffers
-		CANNOT_FLUSH,
-		//! data integerity check (such as CRC or MAC) failed
-		DATA_INTEGRITY_CHECK_FAILED,
-		//! received input data that doesn't conform to expected format
-		INVALID_DATA_FORMAT,
-		//! error reading from input device or writing to output device
-		IO_ERROR,
-		//! some error not belong to any of the above categories
-		OTHER_ERROR
-	};
-
-	explicit Exception(ErrorType errorType, const std::string &s) : m_errorType(errorType), m_what(s) {}
-	virtual ~Exception() throw() {}
-	const char *what() const throw() {return (m_what.c_str());}
-	const std::string &GetWhat() const {return m_what;}
-	void SetWhat(const std::string &s) {m_what = s;}
-	ErrorType GetErrorType() const {return m_errorType;}
-	void SetErrorType(ErrorType errorType) {m_errorType = errorType;}
-
-private:
-	ErrorType m_errorType;
-	std::string m_what;
-};
-
-//! exception thrown when an invalid argument is detected
-class InvalidArgument : public Exception
-{
-public:
-	explicit InvalidArgument(const std::string &s) : Exception(INVALID_ARGUMENT, s) {}
-};
-
-//! exception thrown by decryption filters when trying to decrypt an invalid ciphertext
-class InvalidDataFormat : public Exception
-{
-public:
-	explicit InvalidDataFormat(const std::string &s) : Exception(INVALID_DATA_FORMAT, s) {}
-};
-
-//! exception thrown by decryption filters when trying to decrypt an invalid ciphertext
-class InvalidCiphertext : public InvalidDataFormat
-{
-public:
-	explicit InvalidCiphertext(const std::string &s) : InvalidDataFormat(s) {}
-};
-
-//! exception thrown by a class if a non-implemented method is called
-class NotImplemented : public Exception
-{
-public:
-	explicit NotImplemented(const std::string &s) : Exception(NOT_IMPLEMENTED, s) {}
-};
-
-//! exception thrown by a class when Flush(true) is called but it can't completely flush its buffers
-class CannotFlush : public Exception
-{
-public:
-	explicit CannotFlush(const std::string &s) : Exception(CANNOT_FLUSH, s) {}
-};
-
-//! error reported by the operating system
-class OS_Error : public Exception
-{
-public:
-	OS_Error(ErrorType errorType, const std::string s, const std::string& operation, int errorCode)
-		: Exception(errorType, s), m_operation(operation), m_errorCode(errorCode) {}
-	~OS_Error() throw() {}
-
-	// the operating system API that reported the error
-	const std::string & GetOperation() const {return m_operation;}
-	// the error code return by the operating system
-	int GetErrorCode() const {return m_errorCode;}
-
-protected:
-	std::string m_operation;
-	int m_errorCode;
-};
-
-//! used to return decoding results
-struct DecodingResult
-{
-	explicit DecodingResult() : isValidCoding(false), messageLength(0) {}
-	explicit DecodingResult(unsigned int len) : isValidCoding(true), messageLength(len) {}
-
-	bool operator==(const DecodingResult &rhs) const {return isValidCoding == rhs.isValidCoding && messageLength == rhs.messageLength;}
-	bool operator!=(const DecodingResult &rhs) const {return !operator==(rhs);}
-
-	bool isValidCoding;
-	unsigned int messageLength;
-
-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
-	operator unsigned int() const {return isValidCoding ? messageLength : 0;}
-#endif
-};
-
-//! interface for retrieving values given their names
-/*! This class is used to safely pass a variable number of arbitrarily typed arguments to functions
-	and to read values from keys and crypto parameters.
-	To get a value, you need to know the name and the type of the value. 
-	Call GetValueNames() on a NameValuePairs object to obtain a list of value names that it supports.
-	Then look at the Name namespace documentation to see what the type of each value is, or
-	alternatively, call GetIntValue() with the value name, and if the type is not int, a
-	ValueTypeMismatch exception will be thrown and you can get the actual type from the exception object.
-*/
-class NameValuePairs
-{
-public:
-	virtual ~NameValuePairs() {}
-
-	//! exception thrown when trying to retrieve a value using a different type than expected
-	class ValueTypeMismatch : public InvalidArgument
-	{
-	public:
-		ValueTypeMismatch(std::string name, const std::type_info &stored, const std::type_info &retrieving)
-			: InvalidArgument("NameValuePairs: type mismatch for '" + name + "', stored '" + stored.name() + "', trying to retrieve '" + retrieving.name() + "'")
-			, m_stored(stored), m_retrieving(retrieving) {}
-
-		const std::type_info & GetStoredTypeInfo() const {return m_stored;}
-		const std::type_info & GetRetrievingTypeInfo() const {return m_retrieving;}
-
-	private:
-		const std::type_info &m_stored;
-		const std::type_info &m_retrieving;
-	};
-
-	//! get a copy of this object or a subobject of it
-	template <class T>
-	bool GetThisObject(T &object) const
-	{
-		return GetValue((std::string("ThisObject:")+typeid(T).name()).c_str(), object);
-	}
-
-	//! get a pointer to this object, as a pointer to T
-	template <class T>
-	bool GetThisPointer(T *&p) const
-	{
-		return GetValue((std::string("ThisPointer:")+typeid(T).name()).c_str(), p);
-	}
-
-	//! get a named value, returns true if the name exists
-	template <class T>
-	bool GetValue(const char *name, T &value) const
-	{
-		return GetVoidValue(name, typeid(T), &value);
-	}
-
-	//! get a named value, returns the default if the name doesn't exist
-	template <class T>
-	T GetValueWithDefault(const char *name, T defaultValue) const
-	{
-		GetValue(name, defaultValue);
-		return defaultValue;
-	}
-
-	//! get a list of value names that can be retrieved
-	std::string GetValueNames() const
-		{std::string result; GetValue("ValueNames", result); return result;}
-
-	//! get a named value with type int
-	/*! used to ensure we don't accidentally try to get an unsigned int
-		or some other type when we mean int (which is the most common case) */
-	bool GetIntValue(const char *name, int &value) const
-		{return GetValue(name, value);}
-
-	//! get a named value with type int, with default
-	int GetIntValueWithDefault(const char *name, int defaultValue) const
-		{return GetValueWithDefault(name, defaultValue);}
-
-	//! used by derived classes to check for type mismatch
-	static void ThrowIfTypeMismatch(const char *name, const std::type_info &stored, const std::type_info &retrieving)
-		{if (stored != retrieving) throw ValueTypeMismatch(name, stored, retrieving);}
-
-	template <class T>
-	void GetRequiredParameter(const char *className, const char *name, T &value) const
-	{
-		if (!GetValue(name, value))
-			throw InvalidArgument(std::string(className) + ": missing required parameter '" + name + "'");
-	}
-
-	void GetRequiredIntParameter(const char *className, const char *name, int &value) const
-	{
-		if (!GetIntValue(name, value))
-			throw InvalidArgument(std::string(className) + ": missing required parameter '" + name + "'");
-	}
-
-	//! to be implemented by derived classes, users should use one of the above functions instead
-	virtual bool GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const =0;
-};
-
-//! namespace containing value name definitions
-/*!	value names, types and semantics:
-
-	ThisObject:ClassName (ClassName, copy of this object or a subobject)
-	ThisPointer:ClassName (const ClassName *, pointer to this object or a subobject)
-*/
-DOCUMENTED_NAMESPACE_BEGIN(Name)
-// more names defined in argnames.h
-DOCUMENTED_NAMESPACE_END
-
-//! .
-class NullNameValuePairs : public NameValuePairs
-{
-public:
-	bool GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const {return false;}
-};
-
-//! .
-extern const NullNameValuePairs g_nullNameValuePairs;
-
-// ********************************************************
-
-//! interface for cloning objects, this is not implemented by most classes yet
-class Clonable
-{
-public:
-	virtual ~Clonable() {}
-	//! this is not implemented by most classes yet
-	virtual Clonable* Clone() const {throw NotImplemented("Clone() is not implemented yet.");}	// TODO: make this =0
-};
-
-//! interface for all crypto algorithms
-
-class Algorithm : public Clonable
-{
-public:
-	/*! When FIPS 140-2 compliance is enabled and checkSelfTestStatus == true,
-		this constructor throws SelfTestFailure if the self test hasn't been run or fails. */
-	Algorithm(bool checkSelfTestStatus = true);
-	//! returns name of this algorithm, not universally implemented yet
-	virtual std::string AlgorithmName() const {return "unknown";}
-};
-
-//! keying interface for crypto algorithms that take byte strings as keys
-
-class SimpleKeyingInterface
-{
-public:
-	//! returns smallest valid key length in bytes */
-	virtual unsigned int MinKeyLength() const =0;
-	//! returns largest valid key length in bytes */
-	virtual unsigned int MaxKeyLength() const =0;
-	//! returns default (recommended) key length in bytes */
-	virtual unsigned int DefaultKeyLength() const =0;
-
-	//! returns the smallest valid key length in bytes that is >= min(n, GetMaxKeyLength())
-	virtual unsigned int GetValidKeyLength(unsigned int n) const =0;
-
-	//! returns whether n is a valid key length
-	virtual bool IsValidKeyLength(unsigned int n) const
-		{return n == GetValidKeyLength(n);}
-
-	//! set or reset the key of this object
-	/*! \param params is used to specify Rounds, BlockSize, etc */
-	virtual void SetKey(const byte *key, unsigned int length, const NameValuePairs &params = g_nullNameValuePairs) =0;
-
-	//! calls SetKey() with an NameValuePairs object that just specifies "Rounds"
-	void SetKeyWithRounds(const byte *key, unsigned int length, int rounds);
-
-	//! calls SetKey() with an NameValuePairs object that just specifies "IV"
-	void SetKeyWithIV(const byte *key, unsigned int length, const byte *iv);
-
-	enum IV_Requirement {STRUCTURED_IV = 0, RANDOM_IV, UNPREDICTABLE_RANDOM_IV, INTERNALLY_GENERATED_IV, NOT_RESYNCHRONIZABLE};
-	//! returns the minimal requirement for secure IVs
-	virtual IV_Requirement IVRequirement() const =0;
-
-	//! returns whether this object can be resynchronized (i.e. supports initialization vectors)
-	/*! If this function returns true, and no IV is passed to SetKey() and CanUseStructuredIVs()==true, an IV of all 0's will be assumed. */
-	bool IsResynchronizable() const {return IVRequirement() < NOT_RESYNCHRONIZABLE;}
-	//! returns whether this object can use random IVs (in addition to ones returned by GetNextIV)
-	bool CanUseRandomIVs() const {return IVRequirement() <= UNPREDICTABLE_RANDOM_IV;}
-	//! returns whether this object can use random but possibly predictable IVs (in addition to ones returned by GetNextIV)
-	bool CanUsePredictableIVs() const {return IVRequirement() <= RANDOM_IV;}
-	//! returns whether this object can use structured IVs, for example a counter (in addition to ones returned by GetNextIV)
-	bool CanUseStructuredIVs() const {return IVRequirement() <= STRUCTURED_IV;}
-
-	//! returns size of IVs used by this object
-	virtual unsigned int IVSize() const {throw NotImplemented("SimpleKeyingInterface: this object doesn't support resynchronization");}
-	//! resynchronize with an IV
-	virtual void Resynchronize(const byte *IV) {throw NotImplemented("SimpleKeyingInterface: this object doesn't support resynchronization");}
-	//! get a secure IV for the next message
-	/*! This method should be called after you finish encrypting one message and are ready to start the next one.
-		After calling it, you must call SetKey() or Resynchronize() before using this object again. 
-		This method is not implemented on decryption objects. */
-	virtual void GetNextIV(byte *IV) {throw NotImplemented("SimpleKeyingInterface: this object doesn't support GetNextIV()");}
-
-protected:
-	void ThrowIfInvalidKeyLength(const Algorithm &algorithm, unsigned int length);
-
-	inline void AssertValidKeyLength(unsigned int length) const
-	{
-		assert(IsValidKeyLength(length));
-	}
-};
-
-//! interface for the data processing part of block ciphers
-
-/*! Classes derived from BlockTransformation are block ciphers
-	in ECB mode (for example the DES::Encryption class), which are stateless,
-	and they can make assumptions about the memory alignment of their inputs and outputs.
-	These classes should not be used directly, but only in combination with
-	a mode class (see CipherModeDocumentation in modes.h).
-*/
-class BlockTransformation : public Algorithm
-{
-public:
-	//! encrypt or decrypt inBlock, xor with xorBlock, and write to outBlock
-	virtual void ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const =0;
-
-	//! encrypt or decrypt one block
-	/*! \pre size of inBlock and outBlock == BlockSize() */
-	void ProcessBlock(const byte *inBlock, byte *outBlock) const
-		{ProcessAndXorBlock(inBlock, NULL, outBlock);}
-
-	//! encrypt or decrypt one block in place
-	void ProcessBlock(byte *inoutBlock) const
-		{ProcessAndXorBlock(inoutBlock, NULL, inoutBlock);}
-
-	//! block size of the cipher in bytes
-	virtual unsigned int BlockSize() const =0;
-
-	//! block pointers must be divisible by this
-	virtual unsigned int BlockAlignment() const {return 4;}
-
-	//! returns true if this is a permutation (i.e. there is an inverse transformation)
-	virtual bool IsPermutation() const {return true;}
-
-	//! returns true if this is an encryption object
-	virtual bool IsForwardTransformation() const =0;
-
-	//! return number of blocks that can be processed in parallel, for bit-slicing implementations
-	virtual unsigned int OptimalNumberOfParallelBlocks() const {return 1;}
-
-	//! encrypt or decrypt multiple blocks, for bit-slicing implementations
-	virtual void ProcessAndXorMultipleBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, unsigned int numberOfBlocks) const;
-};
-
-//! interface for the data processing part of stream ciphers
-
-class StreamTransformation : public Algorithm
-{
-public:
-	//! return a reference to this object, 
-	/*! This function is useful for passing a temporary StreamTransformation object to a 
-		function that takes a non-const reference. */
-	StreamTransformation& Ref() {return *this;}
-
-	//! returns block size, if input must be processed in blocks, otherwise 1
-	virtual unsigned int MandatoryBlockSize() const {return 1;}
-
-	//! returns the input block size that is most efficient for this cipher
-	/*! \note optimal input length is n * OptimalBlockSize() - GetOptimalBlockSizeUsed() for any n > 0 */
-	virtual unsigned int OptimalBlockSize() const {return MandatoryBlockSize();}
-	//! returns how much of the current block is used up
-	virtual unsigned int GetOptimalBlockSizeUsed() const {return 0;}
-
-	//! returns how input should be aligned for optimal performance
-	virtual unsigned int OptimalDataAlignment() const {return 1;}
-
-	//! encrypt or decrypt an array of bytes of specified length
-	/*! \note either inString == outString, or they don't overlap */
-	virtual void ProcessData(byte *outString, const byte *inString, unsigned int length) =0;
-
-	//! for ciphers where the last block of data is special, encrypt or decrypt the last block of data
-	/*! For now the only use of this function is for CBC-CTS mode. */
-	virtual void ProcessLastBlock(byte *outString, const byte *inString, unsigned int length);
-	//! returns the minimum size of the last block, 0 indicating the last block is not special
-	virtual unsigned int MinLastBlockSize() const {return 0;}
-
-	//! same as ProcessData(inoutString, inoutString, length)
-	inline void ProcessString(byte *inoutString, unsigned int length)
-		{ProcessData(inoutString, inoutString, length);}
-	//! same as ProcessData(outString, inString, length)
-	inline void ProcessString(byte *outString, const byte *inString, unsigned int length)
-		{ProcessData(outString, inString, length);}
-	//! implemented as {ProcessData(&input, &input, 1); return input;}
-	inline byte ProcessByte(byte input)
-		{ProcessData(&input, &input, 1); return input;}
-
-	//! returns whether this cipher supports random access
-	virtual bool IsRandomAccess() const =0;
-	//! for random access ciphers, seek to an absolute position
-	virtual void Seek(dword n)
-	{
-		assert(!IsRandomAccess());
-		throw NotImplemented("StreamTransformation: this object doesn't support random access");
-	}
-
-	//! returns whether this transformation is self-inverting (e.g. xor with a keystream)
-	virtual bool IsSelfInverting() const =0;
-	//! returns whether this is an encryption object
-	virtual bool IsForwardTransformation() const =0;
-};
-
-//! interface for hash functions and data processing part of MACs
-
-/*! HashTransformation objects are stateful.  They are created in an initial state,
-	change state as Update() is called, and return to the initial
-	state when Final() is called.  This interface allows a large message to
-	be hashed in pieces by calling Update() on each piece followed by
-	calling Final().
-*/
-class HashTransformation : public Algorithm
-{
-public:
-	//! process more input
-	virtual void Update(const byte *input, unsigned int length) =0;
-
-	//! request space to write input into
-	virtual byte * CreateUpdateSpace(unsigned int &size) {size=0; return NULL;}
-
-	//! compute hash for current message, then restart for a new message
-	/*!	\pre size of digest == DigestSize(). */
-	virtual void Final(byte *digest)
-		{TruncatedFinal(digest, DigestSize());}
-
-	//! discard the current state, and restart with a new message
-	virtual void Restart()
-		{TruncatedFinal(NULL, 0);}
-
-	//! size of the hash returned by Final()
-	virtual unsigned int DigestSize() const =0;
-
-	//! input to Update() should have length a multiple of this for optimal speed
-	virtual unsigned int OptimalBlockSize() const {return 1;}
-
-	//! returns how input should be aligned for optimal performance
-	virtual unsigned int OptimalDataAlignment() const {return 1;}
-
-	//! use this if your input is in one piece and you don't want to call Update() and Final() separately
-	virtual void CalculateDigest(byte *digest, const byte *input, unsigned int length)
-		{Update(input, length); Final(digest);}
-
-	//! verify that digest is a valid digest for the current message, then reinitialize the object
-	/*! Default implementation is to call Final() and do a bitwise comparison
-		between its output and digest. */
-	virtual bool Verify(const byte *digest)
-		{return TruncatedVerify(digest, DigestSize());}
-
-	//! use this if your input is in one piece and you don't want to call Update() and Verify() separately
-	virtual bool VerifyDigest(const byte *digest, const byte *input, unsigned int length)
-		{Update(input, length); return Verify(digest);}
-
-	//! truncated version of Final()
-	virtual void TruncatedFinal(byte *digest, unsigned int digestSize) =0;
-
-	//! truncated version of CalculateDigest()
-	virtual void CalculateTruncatedDigest(byte *digest, unsigned int digestSize, const byte *input, unsigned int length)
-		{Update(input, length); TruncatedFinal(digest, digestSize);}
-
-	//! truncated version of Verify()
-	virtual bool TruncatedVerify(const byte *digest, unsigned int digestLength);
-
-	//! truncated version of VerifyDigest()
-	virtual bool VerifyTruncatedDigest(const byte *digest, unsigned int digestLength, const byte *input, unsigned int length)
-		{Update(input, length); return TruncatedVerify(digest, digestLength);}
-
-protected:
-	void ThrowIfInvalidTruncatedSize(unsigned int size) const;
-};
-
-//! .
-template <class T>
-class SimpleKeyedTransformation : public T, public SimpleKeyingInterface
-{
-public:
-	void ThrowIfInvalidKeyLength(unsigned int length)
-		{SimpleKeyingInterface::ThrowIfInvalidKeyLength(*this, length);}
-};
-
-//! .
-typedef HashTransformation HashFunction;
-#ifdef CRYPTOPP_DOXYGEN_PROCESSING
-//! These objects usually should not be used directly. See BlockTransformation for more details.
-class BlockCipher : public BlockTransformation, public SimpleKeyingInterface {};
-//! interface for stream ciphers
-class SymmetricCipher : public StreamTransformation, public SimpleKeyingInterface {};
-//! interface for message authentication codes
-class MessageAuthenticationCode : public HashTransformation, public SimpleKeyingInterface {};
-#else
-typedef SimpleKeyedTransformation<BlockTransformation> BlockCipher;
-typedef SimpleKeyedTransformation<StreamTransformation> SymmetricCipher;
-typedef SimpleKeyedTransformation<HashTransformation> MessageAuthenticationCode;
-#endif
-
-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
-typedef SymmetricCipher StreamCipher;
-#endif
-
-//! interface for random number generators
-/*! All return values are uniformly distributed over the range specified.
-*/
-class RandomNumberGenerator : public Algorithm
-{
-public:
-	//! generate new random byte and return it
-	virtual byte GenerateByte() =0;
-
-	//! generate new random bit and return it
-	/*! Default implementation is to call GenerateByte() and return its parity. */
-	virtual unsigned int GenerateBit();
-
-	//! generate a random 32 bit word in the range min to max, inclusive
-	virtual word32 GenerateWord32(word32 a=0, word32 b=0xffffffffL);
-
-	//! generate random array of bytes
-	/*! Default implementation is to call GenerateByte() size times. */
-	virtual void GenerateBlock(byte *output, unsigned int size);
-
-	//! generate and discard n bytes
-	/*! Default implementation is to call GenerateByte() n times. */
-	virtual void DiscardBytes(unsigned int n);
-
-	//! randomly shuffle the specified array, resulting permutation is uniformly distributed
-	template <class IT> void Shuffle(IT begin, IT end)
-	{
-		for (; begin != end; ++begin)
-			std::iter_swap(begin, begin + GenerateWord32(0, end-begin-1));
-	}
-
-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
-	byte GetByte() {return GenerateByte();}
-	unsigned int GetBit() {return GenerateBit();}
-	word32 GetLong(word32 a=0, word32 b=0xffffffffL) {return GenerateWord32(a, b);}
-	word16 GetShort(word16 a=0, word16 b=0xffff) {return (word16)GenerateWord32(a, b);}
-	void GetBlock(byte *output, unsigned int size) {GenerateBlock(output, size);}
-#endif
-};
-
-//! returns a reference that can be passed to functions that ask for a RNG but doesn't actually use it
-RandomNumberGenerator & NullRNG();
-
-class WaitObjectContainer;
-
-//! interface for objects that you can wait for
-
-class Waitable
-{
-public:
-	//! maximum number of wait objects that this object can return
-	virtual unsigned int GetMaxWaitObjectCount() const =0;
-	//! put wait objects into container
-	virtual void GetWaitObjects(WaitObjectContainer &container) =0;
-	//! wait on this object
-	/*! same as creating an empty container, calling GetWaitObjects(), and calling Wait() on the container */
-	bool Wait(unsigned long milliseconds);
-};
-
-//! interface for buffered transformations
-
-/*! BufferedTransformation is a generalization of BlockTransformation,
-	StreamTransformation, and HashTransformation.
-
-	A buffered transformation is an object that takes a stream of bytes
-	as input (this may be done in stages), does some computation on them, and
-	then places the result into an internal buffer for later retrieval.  Any
-	partial result already in the output buffer is not modified by further
-	input.
-
-	If a method takes a "blocking" parameter, and you
-	pass "false" for it, the method will return before all input has been processed if
-	the input cannot be processed without waiting (for network buffers to become available, for example).
-	In this case the method will return true
-	or a non-zero integer value. When this happens you must continue to call the method with the same
-	parameters until it returns false or zero, before calling any other method on it or
-	attached BufferedTransformation. The integer return value in this case is approximately
-	the number of bytes left to be processed, and can be used to implement a progress bar.
-
-	For functions that take a "propagation" parameter, propagation != 0 means pass on the signal to attached
-	BufferedTransformation objects, with propagation decremented at each step until it reaches 0.
-	-1 means unlimited propagation.
-
-	\nosubgrouping
-*/
-class BufferedTransformation : public Algorithm, public Waitable
-{
-public:
-	// placed up here for CW8
-	static const std::string NULL_CHANNEL;	// the empty string ""
-
-	BufferedTransformation() : Algorithm(false) {}
-
-	//! return a reference to this object
-	/*! This function is useful for passing a temporary BufferedTransformation object to a 
-		function that takes a non-const reference. */
-	BufferedTransformation& Ref() {return *this;}
-
-	//!	\name INPUT
-	//@{
-		//! input a byte for processing
-		unsigned int Put(byte inByte, bool blocking=true)
-			{return Put(&inByte, 1, blocking);}
-		//! input multiple bytes
-		unsigned int Put(const byte *inString, unsigned int length, bool blocking=true)
-			{return Put2(inString, length, 0, blocking);}
-
-		//! input a 16-bit word
-		unsigned int PutWord16(word16 value, ByteOrder order=BIG_ENDIAN_ORDER, bool blocking=true);
-		//! input a 32-bit word
-		unsigned int PutWord32(word32 value, ByteOrder order=BIG_ENDIAN_ORDER, bool blocking=true);
-
-		//! request space which can be written into by the caller, and then used as input to Put()
-		/*! \param size is requested size (as a hint) for input, and size of the returned space for output */
-		/*! \note The purpose of this method is to help avoid doing extra memory allocations. */
-		virtual byte * CreatePutSpace(unsigned int &size) {size=0; return NULL;}
-
-		virtual bool CanModifyInput() const {return false;}
-
-		//! input multiple bytes that may be modified by callee
-		unsigned int PutModifiable(byte *inString, unsigned int length, bool blocking=true)
-			{return PutModifiable2(inString, length, 0, blocking);}
-
-		bool MessageEnd(int propagation=-1, bool blocking=true)
-			{return !!Put2(NULL, 0, propagation < 0 ? -1 : propagation+1, blocking);}
-		unsigned int PutMessageEnd(const byte *inString, unsigned int length, int propagation=-1, bool blocking=true)
-			{return Put2(inString, length, propagation < 0 ? -1 : propagation+1, blocking);}
-
-		//! input multiple bytes for blocking or non-blocking processing
-		/*! \param messageEnd means how many filters to signal MessageEnd to, including this one */
-		virtual unsigned int Put2(const byte *inString, unsigned int length, int messageEnd, bool blocking) =0;
-		//! input multiple bytes that may be modified by callee for blocking or non-blocking processing
-		/*! \param messageEnd means how many filters to signal MessageEnd to, including this one */
-		virtual unsigned int PutModifiable2(byte *inString, unsigned int length, int messageEnd, bool blocking)
-			{return Put2(inString, length, messageEnd, blocking);}
-
-		//! thrown by objects that have not implemented nonblocking input processing
-		struct BlockingInputOnly : public NotImplemented
-			{BlockingInputOnly(const std::string &s) : NotImplemented(s + ": Nonblocking input is not implemented by this object.") {}};
-	//@}
-
-	//!	\name WAITING
-	//@{
-		unsigned int GetMaxWaitObjectCount() const;
-		void GetWaitObjects(WaitObjectContainer &container);
-	//@}
-
-	//!	\name SIGNALS
-	//@{
-		virtual void IsolatedInitialize(const NameValuePairs &parameters) {throw NotImplemented("BufferedTransformation: this object can't be reinitialized");}
-		virtual bool IsolatedFlush(bool hardFlush, bool blocking) =0;
-		virtual bool IsolatedMessageSeriesEnd(bool blocking) {return false;}
-
-		//! initialize or reinitialize this object
-		virtual void Initialize(const NameValuePairs &parameters=g_nullNameValuePairs, int propagation=-1);
-		//! flush buffered input and/or output
-		/*! \param hardFlush is used to indicate whether all data should be flushed
-			\note Hard flushes must be used with care. It means try to process and output everything, even if
-			there may not be enough data to complete the action. For example, hard flushing a HexDecoder would
-			cause an error if you do it after inputing an odd number of hex encoded characters.
-			For some types of filters, for example ZlibDecompressor, hard flushes can only
-			be done at "synchronization points". These synchronization points are positions in the data
-			stream that are created by hard flushes on the corresponding reverse filters, in this
-			example ZlibCompressor. This is useful when zlib compressed data is moved across a
-			network in packets and compression state is preserved across packets, as in the ssh2 protocol.
-		*/
-		virtual bool Flush(bool hardFlush, int propagation=-1, bool blocking=true);
-		//! mark end of a series of messages
-		/*! There should be a MessageEnd immediately before MessageSeriesEnd. */
-		virtual bool MessageSeriesEnd(int propagation=-1, bool blocking=true);
-
-		//! set propagation of automatically generated and transfered signals
-		/*! propagation == 0 means do not automaticly generate signals */
-		virtual void SetAutoSignalPropagation(int propagation) {}
-
-		//!
-		virtual int GetAutoSignalPropagation() const {return 0;}
-public:
-
-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
-		void Close() {MessageEnd();}
-#endif
-	//@}
-
-	//!	\name RETRIEVAL OF ONE MESSAGE
-	//@{
-		//! returns number of bytes that is currently ready for retrieval
-		/*! All retrieval functions return the actual number of bytes
-			retrieved, which is the lesser of the request number and
-			MaxRetrievable(). */
-		virtual unsigned long MaxRetrievable() const;
-
-		//! returns whether any bytes are currently ready for retrieval
-		virtual bool AnyRetrievable() const;
-
-		//! try to retrieve a single byte
-		virtual unsigned int Get(byte &outByte);
-		//! try to retrieve multiple bytes
-		virtual unsigned int Get(byte *outString, unsigned int getMax);
-
-		//! peek at the next byte without removing it from the output buffer
-		virtual unsigned int Peek(byte &outByte) const;
-		//! peek at multiple bytes without removing them from the output buffer
-		virtual unsigned int Peek(byte *outString, unsigned int peekMax) const;
-
-		//! try to retrieve a 16-bit word
-		unsigned int GetWord16(word16 &value, ByteOrder order=BIG_ENDIAN_ORDER);
-		//! try to retrieve a 32-bit word
-		unsigned int GetWord32(word32 &value, ByteOrder order=BIG_ENDIAN_ORDER);
-
-		//! try to peek at a 16-bit word
-		unsigned int PeekWord16(word16 &value, ByteOrder order=BIG_ENDIAN_ORDER);
-		//! try to peek at a 32-bit word
-		unsigned int PeekWord32(word32 &value, ByteOrder order=BIG_ENDIAN_ORDER);
-
-		//! move transferMax bytes of the buffered output to target as input
-		unsigned long TransferTo(BufferedTransformation &target, unsigned long transferMax=ULONG_MAX, const std::string &channel=NULL_CHANNEL)
-			{TransferTo2(target, transferMax, channel); return transferMax;}
-
-		//! discard skipMax bytes from the output buffer
-		virtual unsigned long Skip(unsigned long skipMax=ULONG_MAX);
-
-		//! copy copyMax bytes of the buffered output to target as input
-		unsigned long CopyTo(BufferedTransformation &target, unsigned long copyMax=ULONG_MAX, const std::string &channel=NULL_CHANNEL) const
-			{return CopyRangeTo(target, 0, copyMax, channel);}
-
-		//! copy copyMax bytes of the buffered output, starting at position (relative to current position), to target as input
-		unsigned long CopyRangeTo(BufferedTransformation &target, unsigned long position, unsigned long copyMax=ULONG_MAX, const std::string &channel=NULL_CHANNEL) const
-			{unsigned long i = position; CopyRangeTo2(target, i, i+copyMax, channel); return i-position;}
-
-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
-		unsigned long MaxRetrieveable() const {return MaxRetrievable();}
-#endif
-	//@}
-
-	//!	\name RETRIEVAL OF MULTIPLE MESSAGES
-	//@{
-		//!
-		virtual unsigned long TotalBytesRetrievable() const;
-		//! number of times MessageEnd() has been received minus messages retrieved or skipped
-		virtual unsigned int NumberOfMessages() const;
-		//! returns true if NumberOfMessages() > 0
-		virtual bool AnyMessages() const;
-		//! start retrieving the next message
-		/*!
-			Returns false if no more messages exist or this message 
-			is not completely retrieved.
-		*/
-		virtual bool GetNextMessage();
-		//! skip count number of messages
-		virtual unsigned int SkipMessages(unsigned int count=UINT_MAX);
-		//!
-		unsigned int TransferMessagesTo(BufferedTransformation &target, unsigned int count=UINT_MAX, const std::string &channel=NULL_CHANNEL)
-			{TransferMessagesTo2(target, count, channel); return count;}
-		//!
-		unsigned int CopyMessagesTo(BufferedTransformation &target, unsigned int count=UINT_MAX, const std::string &channel=NULL_CHANNEL) const;
-
-		//!
-		virtual void SkipAll();
-		//!
-		void TransferAllTo(BufferedTransformation &target, const std::string &channel=NULL_CHANNEL)
-			{TransferAllTo2(target, channel);}
-		//!
-		void CopyAllTo(BufferedTransformation &target, const std::string &channel=NULL_CHANNEL) const;
-
-		virtual bool GetNextMessageSeries() {return false;}
-		virtual unsigned int NumberOfMessagesInThisSeries() const {return NumberOfMessages();}
-		virtual unsigned int NumberOfMessageSeries() const {return 0;}
-	//@}
-
-	//!	\name NON-BLOCKING TRANSFER OF OUTPUT
-	//@{
-		//! .
-		virtual unsigned int TransferTo2(BufferedTransformation &target, unsigned long &byteCount, const std::string &channel=NULL_CHANNEL, bool blocking=true) =0;
-		virtual unsigned int CopyRangeTo2(BufferedTransformation &target, unsigned long &begin, unsigned long end=ULONG_MAX, const std::string &channel=NULL_CHANNEL, bool blocking=true) const =0;
-		unsigned int TransferMessagesTo2(BufferedTransformation &target, unsigned int &messageCount, const std::string &channel=NULL_CHANNEL, bool blocking=true);
-		unsigned int TransferAllTo2(BufferedTransformation &target, const std::string &channel=NULL_CHANNEL, bool blocking=true);
-	//@}
-
-	//!	\name CHANNELS
-	//@{
-		struct NoChannelSupport : public NotImplemented
-			{NoChannelSupport() : NotImplemented("BufferedTransformation: this object doesn't support multiple channels") {}};
-
-		unsigned int ChannelPut(const std::string &channel, byte inByte, bool blocking=true)
-			{return ChannelPut(channel, &inByte, 1, blocking);}
-		unsigned int ChannelPut(const std::string &channel, const byte *inString, unsigned int length, bool blocking=true)
-			{return ChannelPut2(channel, inString, length, 0, blocking);}
-
-		unsigned int ChannelPutModifiable(const std::string &channel, byte *inString, unsigned int length, bool blocking=true)
-			{return ChannelPutModifiable2(channel, inString, length, 0, blocking);}
-
-		unsigned int ChannelPutWord16(const std::string &channel, word16 value, ByteOrder order=BIG_ENDIAN_ORDER, bool blocking=true);
-		unsigned int ChannelPutWord32(const std::string &channel, word32 value, ByteOrder order=BIG_ENDIAN_ORDER, bool blocking=true);
-
-		bool ChannelMessageEnd(const std::string &channel, int propagation=-1, bool blocking=true)
-			{return !!ChannelPut2(channel, NULL, 0, propagation < 0 ? -1 : propagation+1, blocking);}
-		unsigned int ChannelPutMessageEnd(const std::string &channel, const byte *inString, unsigned int length, int propagation=-1, bool blocking=true)
-			{return ChannelPut2(channel, inString, length, propagation < 0 ? -1 : propagation+1, blocking);}
-
-		virtual byte * ChannelCreatePutSpace(const std::string &channel, unsigned int &size);
-
-		virtual unsigned int ChannelPut2(const std::string &channel, const byte *begin, unsigned int length, int messageEnd, bool blocking);
-		virtual unsigned int ChannelPutModifiable2(const std::string &channel, byte *begin, unsigned int length, int messageEnd, bool blocking);
-
-		virtual void ChannelInitialize(const std::string &channel, const NameValuePairs &parameters=g_nullNameValuePairs, int propagation=-1);
-		virtual bool ChannelFlush(const std::string &channel, bool hardFlush, int propagation=-1, bool blocking=true);
-		virtual bool ChannelMessageSeriesEnd(const std::string &channel, int propagation=-1, bool blocking=true);
-
-		virtual void SetRetrievalChannel(const std::string &channel);
-	//@}
-
-	//!	\name ATTACHMENT
-	/*! Some BufferedTransformation objects (e.g. Filter objects)
-		allow other BufferedTransformation objects to be attached. When
-		this is done, the first object instead of buffering its output,
-		sents that output to the attached object as input. The entire
-		attachment chain is deleted when the anchor object is destructed.
-	*/
-	//@{
-		//! returns whether this object allows attachment
-		virtual bool Attachable() {return false;}
-		//! returns the object immediately attached to this object or NULL for no attachment
-		virtual BufferedTransformation *AttachedTransformation() {assert(!Attachable()); return 0;}
-		//!
-		virtual const BufferedTransformation *AttachedTransformation() const
-			{return const_cast<BufferedTransformation *>(this)->AttachedTransformation();}
-		//! delete the current attachment chain and replace it with newAttachment
-		virtual void Detach(BufferedTransformation *newAttachment = 0)
-			{assert(!Attachable()); throw NotImplemented("BufferedTransformation: this object is not attachable");}
-		//! add newAttachment to the end of attachment chain
-		virtual void Attach(BufferedTransformation *newAttachment);
-	//@}
-
-protected:
-	static int DecrementPropagation(int propagation)
-		{return propagation != 0 ? propagation - 1 : 0;}
-};
-
-//! returns a reference to a BufferedTransformation object that discards all input
-BufferedTransformation & TheBitBucket();
-
-//! interface for crypto material, such as public and private keys, and crypto parameters
-
-class CryptoMaterial : public NameValuePairs
-{
-public:
-	//! exception thrown when invalid crypto material is detected
-	class InvalidMaterial : public InvalidDataFormat
-	{
-	public:
-		explicit InvalidMaterial(const std::string &s) : InvalidDataFormat(s) {}
-	};
-
-	//! assign values from source to this object
-	/*! \note This function can be used to create a public key from a private key. */
-	virtual void AssignFrom(const NameValuePairs &source) =0;
-
-	//! check this object for errors
-	/*! \param level denotes the level of thoroughness:
-		0 - using this object won't cause a crash or exception (rng is ignored)
-		1 - this object will probably function (encrypt, sign, etc.) correctly (but may not check for weak keys and such)
-		2 - make sure this object will function correctly, and do reasonable security checks
-		3 - do checks that may take a long time
-		\return true if the tests pass */
-	virtual bool Validate(RandomNumberGenerator &rng, unsigned int level) const =0;
-
-	//! throws InvalidMaterial if this object fails Validate() test
-	virtual void ThrowIfInvalid(RandomNumberGenerator &rng, unsigned int level) const
-		{if (!Validate(rng, level)) throw InvalidMaterial("CryptoMaterial: this object contains invalid values");}
-
-//	virtual std::vector<std::string> GetSupportedFormats(bool includeSaveOnly=false, bool includeLoadOnly=false);
-
-	//! save key into a BufferedTransformation
-	virtual void Save(BufferedTransformation &bt) const
-		{throw NotImplemented("CryptoMaterial: this object does not support saving");}
-
-	//! load key from a BufferedTransformation
-	/*! \throws KeyingErr if decode fails
-		\note Generally does not check that the key is valid.
-			Call ValidateKey() or ThrowIfInvalidKey() to check that. */
-	virtual void Load(BufferedTransformation &bt)
-		{throw NotImplemented("CryptoMaterial: this object does not support loading");}
-
-	//! \return whether this object supports precomputation
-	virtual bool SupportsPrecomputation() const {return false;}
-	//! do precomputation
-	/*! The exact semantics of Precompute() is varies, but
-		typically it means calculate a table of n objects
-		that can be used later to speed up computation. */
-	virtual void Precompute(unsigned int n)
-		{assert(!SupportsPrecomputation()); throw NotImplemented("CryptoMaterial: this object does not support precomputation");}
-	//! retrieve previously saved precomputation
-	virtual void LoadPrecomputation(BufferedTransformation &storedPrecomputation)
-		{assert(!SupportsPrecomputation()); throw NotImplemented("CryptoMaterial: this object does not support precomputation");}
-	//! save precomputation for later use
-	virtual void SavePrecomputation(BufferedTransformation &storedPrecomputation) const
-		{assert(!SupportsPrecomputation()); throw NotImplemented("CryptoMaterial: this object does not support precomputation");}
-
-	// for internal library use
-	void DoQuickSanityCheck() const	{ThrowIfInvalid(NullRNG(), 0);}
-};
-
-//! interface for generatable crypto material, such as private keys and crypto parameters
-
-class GeneratableCryptoMaterial : virtual public CryptoMaterial
-{
-public:
-	//! generate a random key or crypto parameters
-	/*! \throws KeyingErr if algorithm parameters are invalid, or if a key can't be generated
-		(e.g., if this is a public key object) */
-	virtual void GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &params = g_nullNameValuePairs)
-		{throw NotImplemented("GeneratableCryptoMaterial: this object does not support key/parameter generation");}
-
-	//! calls the above function with a NameValuePairs object that just specifies "KeySize"
-	void GenerateRandomWithKeySize(RandomNumberGenerator &rng, unsigned int keySize);
-};
-
-//! interface for public keys
-
-class PublicKey : virtual public CryptoMaterial
-{
-};
-
-//! interface for private keys
-
-class PrivateKey : public GeneratableCryptoMaterial
-{
-};
-
-//! interface for crypto prameters
-
-class CryptoParameters : public GeneratableCryptoMaterial
-{
-};
-
-//! interface for asymmetric algorithms
-
-class AsymmetricAlgorithm : public Algorithm
-{
-public:
-	//! returns a reference to the crypto material used by this object
-	virtual CryptoMaterial & AccessMaterial() =0;
-	//! returns a const reference to the crypto material used by this object
-	virtual const CryptoMaterial & GetMaterial() const =0;
-
-	//! for backwards compatibility, calls AccessMaterial().Load(bt)
-	void BERDecode(BufferedTransformation &bt)
-		{AccessMaterial().Load(bt);}
-	//! for backwards compatibility, calls GetMaterial().Save(bt)
-	void DEREncode(BufferedTransformation &bt) const
-		{GetMaterial().Save(bt);}
-};
-
-//! interface for asymmetric algorithms using public keys
-
-class PublicKeyAlgorithm : public AsymmetricAlgorithm
-{
-public:
-	// VC60 workaround: no co-variant return type
-	CryptoMaterial & AccessMaterial() {return AccessPublicKey();}
-	const CryptoMaterial & GetMaterial() const {return GetPublicKey();}
-
-	virtual PublicKey & AccessPublicKey() =0;
-	virtual const PublicKey & GetPublicKey() const {return const_cast<PublicKeyAlgorithm *>(this)->AccessPublicKey();}
-};
-
-//! interface for asymmetric algorithms using private keys
-
-class PrivateKeyAlgorithm : public AsymmetricAlgorithm
-{
-public:
-	CryptoMaterial & AccessMaterial() {return AccessPrivateKey();}
-	const CryptoMaterial & GetMaterial() const {return GetPrivateKey();}
-
-	virtual PrivateKey & AccessPrivateKey() =0;
-	virtual const PrivateKey & GetPrivateKey() const {return const_cast<PrivateKeyAlgorithm *>(this)->AccessPrivateKey();}
-};
-
-//! interface for key agreement algorithms
-
-class KeyAgreementAlgorithm : public AsymmetricAlgorithm
-{
-public:
-	CryptoMaterial & AccessMaterial() {return AccessCryptoParameters();}
-	const CryptoMaterial & GetMaterial() const {return GetCryptoParameters();}
-
-	virtual CryptoParameters & AccessCryptoParameters() =0;
-	virtual const CryptoParameters & GetCryptoParameters() const {return const_cast<KeyAgreementAlgorithm *>(this)->AccessCryptoParameters();}
-};
-
-//! interface for public-key encryptors and decryptors
-
-/*! This class provides an interface common to encryptors and decryptors
-	for querying their plaintext and ciphertext lengths.
-*/
-class PK_CryptoSystem
-{
-public:
-	virtual ~PK_CryptoSystem() {}
-
-	//! maximum length of plaintext for a given ciphertext length
-	/*! \note This function returns 0 if cipherTextLength is not valid (too long or too short). */
-	virtual unsigned int MaxPlaintextLength(unsigned int cipherTextLength) const =0;
-
-	//! calculate length of ciphertext given length of plaintext
-	/*! \note This function returns 0 if plainTextLength is not valid (too long). */
-	virtual unsigned int CiphertextLength(unsigned int plainTextLength) const =0;
-
-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
-	unsigned int MaxPlainTextLength(unsigned int cipherTextLength) const {return MaxPlaintextLength(cipherTextLength);}
-	unsigned int CipherTextLength(unsigned int plainTextLength) const {return CiphertextLength(plainTextLength);}
-#endif
-};
-
-//! interface for public-key encryptors
-
-class PK_Encryptor : virtual public PK_CryptoSystem, public PublicKeyAlgorithm
-{
-public:
-	//! .
-	class InvalidPlaintextLength : public Exception
-	{
-	public:
-		InvalidPlaintextLength() : Exception(OTHER_ERROR, "PK_Encryptor: invalid plaintext length") {}
-	};
-
-	//! encrypt a byte string
-	/*! \pre CipherTextLength(plainTextLength) != 0 (i.e., plainText isn't too long)
-		\pre size of cipherText == CipherTextLength(plainTextLength)
-	*/
-	virtual void Encrypt(RandomNumberGenerator &rng, const byte *plainText, unsigned int plainTextLength, byte *cipherText) const =0;
-
-	//! create a new encryption filter
-	/*! \note caller is responsible for deleting the returned pointer
-	*/
-	virtual BufferedTransformation * CreateEncryptionFilter(RandomNumberGenerator &rng, BufferedTransformation *attachment=NULL) const;
-};
-
-//! interface for public-key decryptors
-
-class PK_Decryptor : virtual public PK_CryptoSystem, public PrivateKeyAlgorithm
-{
-public:
-	//! decrypt a byte string, and return the length of plaintext
-	/*! \pre size of plainText == MaxPlainTextLength(cipherTextLength) bytes.
-		\return the actual length of the plaintext, or 0 if decryption fails.
-	*/
-	virtual DecodingResult Decrypt(RandomNumberGenerator &rng, const byte *cipherText, unsigned int cipherTextLength, byte *plainText) const =0;
-
-	//! create a new decryption filter
-	/*! \note caller is responsible for deleting the returned pointer
-	*/
-	virtual BufferedTransformation * CreateDecryptionFilter(RandomNumberGenerator &rng, BufferedTransformation *attachment=NULL) const;
-};
-
-//! interface for encryptors and decryptors with fixed length ciphertext
-
-/*! A simplified interface is provided for crypto systems (such
-	as RSA) whose ciphertext length and maximum plaintext length
-	depend only on the key.
-*/
-class PK_FixedLengthCryptoSystem : virtual public PK_CryptoSystem
-{
-public:
-	//!
-	virtual unsigned int FixedMaxPlaintextLength() const =0;
-	//!
-	virtual unsigned int FixedCiphertextLength() const =0;
-
-	unsigned int MaxPlaintextLength(unsigned int cipherTextLength) const;
-	unsigned int CiphertextLength(unsigned int plainTextLength) const;
-	
-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
-	unsigned int MaxPlainTextLength(unsigned int cipherTextLength) const {return MaxPlaintextLength(cipherTextLength);}
-	unsigned int CipherTextLength(unsigned int plainTextLength) const {return CiphertextLength(plainTextLength);}
-	unsigned int MaxPlainTextLength() const {return FixedMaxPlaintextLength();}
-	unsigned int CipherTextLength() const {return FixedCiphertextLength();}
-#endif
-};
-
-//! interface for encryptors with fixed length ciphertext
-
-class PK_FixedLengthEncryptor : public PK_Encryptor, virtual public PK_FixedLengthCryptoSystem
-{
-};
-
-//! interface for decryptors with fixed length ciphertext
-
-class PK_FixedLengthDecryptor : public PK_Decryptor, virtual public PK_FixedLengthCryptoSystem
-{
-public:
-	//! decrypt a byte string, and return the length of plaintext
-	/*! \pre length of cipherText == CipherTextLength()
-		\pre size of plainText == MaxPlainTextLength()
-		\return the actual length of the plaintext, or 0 if decryption fails.
-	*/
-	virtual DecodingResult FixedLengthDecrypt(RandomNumberGenerator &rng, const byte *cipherText, byte *plainText) const =0;
-
-	DecodingResult Decrypt(RandomNumberGenerator &rng, const byte *cipherText, unsigned int cipherTextLength, byte *plainText) const;
-};
-
-//! interface for public-key signers and verifiers
-
-/*! This class provides an interface common to signers and verifiers
-	for querying scheme properties.
-*/
-class PK_SignatureScheme
-{
-public:
-	//! invalid key exception, may be thrown by any function in this class if the private or public key has a length that can't be used
-	class InvalidKeyLength : public Exception
-	{
-	public:
-		InvalidKeyLength(const std::string &message) : Exception(OTHER_ERROR, message) {}
-	};
-
-	//! key too short exception, may be thrown by any function in this class if the private or public key is too short to sign or verify anything
-	class KeyTooShort : public InvalidKeyLength
-	{
-	public:
-		KeyTooShort() : InvalidKeyLength("PK_Signer: key too short for this signature scheme") {}
-	};
-
-	virtual ~PK_SignatureScheme() {}
-
-	//! signature length if it only depends on the key, otherwise 0
-	virtual unsigned int SignatureLength() const =0;
-
-	//! maximum signature length produced for a given length of recoverable message part
-	virtual unsigned int MaxSignatureLength(unsigned int recoverablePartLength = 0) const {return SignatureLength();}
-
-	//! length of longest message that can be recovered, or 0 if this signature scheme does not support message recovery
-	virtual unsigned int MaxRecoverableLength() const =0;
-
-	//! length of longest message that can be recovered from a signature of given length, or 0 if this signature scheme does not support message recovery
-	virtual unsigned int MaxRecoverableLengthFromSignatureLength(unsigned int signatureLength) const =0;
-
-	//! requires a random number generator to sign
-	/*! if this returns false, NullRNG() can be passed to functions that take RandomNumberGenerator & */
-	virtual bool IsProbabilistic() const =0;
-
-	//! whether or not a non-recoverable message part can be signed
-	virtual bool AllowNonrecoverablePart() const =0;
-
-	//! if this function returns true, during verification you must input the signature before the message, otherwise you can input it at anytime */
-	virtual bool SignatureUpfront() const {return false;}
-
-	//! whether you must input the recoverable part before the non-recoverable part during signing
-	virtual bool RecoverablePartFirst() const =0;
-};
-
-//! interface for accumulating messages to be signed or verified
-/*! Only Update() should be called
-	on this class. No other functions inherited from HashTransformation should be called.
-*/
-class PK_MessageAccumulator : public HashTransformation
-{
-public:
-	//! should not be called on PK_MessageAccumulator
-	unsigned int DigestSize() const
-		{throw NotImplemented("PK_MessageAccumulator: DigestSize() should not be called");}
-	//! should not be called on PK_MessageAccumulator
-	void TruncatedFinal(byte *digest, unsigned int digestSize) 
-		{throw NotImplemented("PK_MessageAccumulator: TruncatedFinal() should not be called");}
-};
-
-//! interface for public-key signers
-
-class PK_Signer : virtual public PK_SignatureScheme, public PrivateKeyAlgorithm
-{
-public:
-	//! create a new HashTransformation to accumulate the message to be signed
-	virtual PK_MessageAccumulator * NewSignatureAccumulator(RandomNumberGenerator &rng = NullRNG()) const =0;
-
-	virtual void InputRecoverableMessage(PK_MessageAccumulator &messageAccumulator, const byte *recoverableMessage, unsigned int recoverableMessageLength) const =0;
-
-	//! sign and delete messageAccumulator (even in case of exception thrown)
-	/*! \pre size of signature == MaxSignatureLength()
-		\return actual signature length
-	*/
-	virtual unsigned int Sign(RandomNumberGenerator &rng, PK_MessageAccumulator *messageAccumulator, byte *signature) const;
-
-	//! sign and restart messageAccumulator
-	/*! \pre size of signature == MaxSignatureLength()
-		\return actual signature length
-	*/
-	virtual unsigned int SignAndRestart(RandomNumberGenerator &rng, PK_MessageAccumulator &messageAccumulator, byte *signature, bool restart=true) const =0;
-
-	//! sign a message
-	/*! \pre size of signature == MaxSignatureLength()
-		\return actual signature length
-	*/
-	virtual unsigned int SignMessage(RandomNumberGenerator &rng, const byte *message, unsigned int messageLen, byte *signature) const;
-
-	//! sign a recoverable message
-	/*! \pre size of signature == MaxSignatureLength(recoverableMessageLength)
-		\return actual signature length
-	*/
-	virtual unsigned int SignMessageWithRecovery(RandomNumberGenerator &rng, const byte *recoverableMessage, unsigned int recoverableMessageLength, 
-		const byte *nonrecoverableMessage, unsigned int nonrecoverableMessageLength, byte *signature) const;
-};
-
-//! interface for public-key signature verifiers
-/*! The Recover* functions throw NotImplemented if the signature scheme does not support
-	message recovery.
-	The Verify* functions throw InvalidDataFormat if the scheme does support message
-	recovery and the signature contains a non-empty recoverable message part. The
-	Recovery* functions should be used in that case.
-*/
-class PK_Verifier : virtual public PK_SignatureScheme, public PublicKeyAlgorithm
-{
-public:
-	//! create a new HashTransformation to accumulate the message to be verified
-	virtual PK_MessageAccumulator * NewVerificationAccumulator() const =0;
-
-	//! input signature into a message accumulator
-	virtual void InputSignature(PK_MessageAccumulator &messageAccumulator, const byte *signature, unsigned int signatureLength) const =0;
-
-	//! check whether messageAccumulator contains a valid signature and message, and delete messageAccumulator (even in case of exception thrown)
-	virtual bool Verify(PK_MessageAccumulator *messageAccumulator) const;
-
-	//! check whether messageAccumulator contains a valid signature and message, and restart messageAccumulator
-	virtual bool VerifyAndRestart(PK_MessageAccumulator &messageAccumulator) const =0;
-
-	//! check whether input signature is a valid signature for input message
-	virtual bool VerifyMessage(const byte *message, unsigned int messageLen, 
-		const byte *signature, unsigned int signatureLength) const;
-
-	//! recover a message from its signature
-	/*! \pre size of recoveredMessage == MaxRecoverableLengthFromSignatureLength(signatureLength)
-	*/
-	virtual DecodingResult Recover(byte *recoveredMessage, PK_MessageAccumulator *messageAccumulator) const;
-
-	//! recover a message from its signature
-	/*! \pre size of recoveredMessage == MaxRecoverableLengthFromSignatureLength(signatureLength)
-	*/
-	virtual DecodingResult RecoverAndRestart(byte *recoveredMessage, PK_MessageAccumulator &messageAccumulator) const =0;
-
-	//! recover a message from its signature
-	/*! \pre size of recoveredMessage == MaxRecoverableLengthFromSignatureLength(signatureLength)
-	*/
-	virtual DecodingResult RecoverMessage(byte *recoveredMessage, 
-		const byte *nonrecoverableMessage, unsigned int nonrecoverableMessageLength, 
-		const byte *signature, unsigned int signatureLength) const;
-};
-
-//! interface for domains of simple key agreement protocols
-
-/*! A key agreement domain is a set of parameters that must be shared
-	by two parties in a key agreement protocol, along with the algorithms
-	for generating key pairs and deriving agreed values.
-*/
-class SimpleKeyAgreementDomain : public KeyAgreementAlgorithm
-{
-public:
-	//! return length of agreed value produced
-	virtual unsigned int AgreedValueLength() const =0;
-	//! return length of private keys in this domain
-	virtual unsigned int PrivateKeyLength() const =0;
-	//! return length of public keys in this domain
-	virtual unsigned int PublicKeyLength() const =0;
-	//! generate private key
-	/*! \pre size of privateKey == PrivateKeyLength() */
-	virtual void GeneratePrivateKey(RandomNumberGenerator &rng, byte *privateKey) const =0;
-	//! generate public key
-	/*!	\pre size of publicKey == PublicKeyLength() */
-	virtual void GeneratePublicKey(RandomNumberGenerator &rng, const byte *privateKey, byte *publicKey) const =0;
-	//! generate private/public key pair
-	/*! \note equivalent to calling GeneratePrivateKey() and then GeneratePublicKey() */
-	virtual void GenerateKeyPair(RandomNumberGenerator &rng, byte *privateKey, byte *publicKey) const;
-	//! derive agreed value from your private key and couterparty's public key, return false in case of failure
-	/*! \note If you have previously validated the public key, use validateOtherPublicKey=false to save time.
-	/*! \pre size of agreedValue == AgreedValueLength()
-		\pre length of privateKey == PrivateKeyLength()
-		\pre length of otherPublicKey == PublicKeyLength()
-	*/
-	virtual bool Agree(byte *agreedValue, const byte *privateKey, const byte *otherPublicKey, bool validateOtherPublicKey=true) const =0;
-
-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
-	bool ValidateDomainParameters(RandomNumberGenerator &rng) const
-		{return GetCryptoParameters().Validate(rng, 2);}
-#endif
-};
-
-//! interface for domains of authenticated key agreement protocols
-
-/*! In an authenticated key agreement protocol, each party has two
-	key pairs. The long-lived key pair is called the static key pair,
-	and the short-lived key pair is called the ephemeral key pair.
-*/
-class AuthenticatedKeyAgreementDomain : public KeyAgreementAlgorithm
-{
-public:
-	//! return length of agreed value produced
-	virtual unsigned int AgreedValueLength() const =0;
-
-	//! return length of static private keys in this domain
-	virtual unsigned int StaticPrivateKeyLength() const =0;
-	//! return length of static public keys in this domain
-	virtual unsigned int StaticPublicKeyLength() const =0;
-	//! generate static private key
-	/*! \pre size of privateKey == PrivateStaticKeyLength() */
-	virtual void GenerateStaticPrivateKey(RandomNumberGenerator &rng, byte *privateKey) const =0;
-	//! generate static public key
-	/*!	\pre size of publicKey == PublicStaticKeyLength() */
-	virtual void GenerateStaticPublicKey(RandomNumberGenerator &rng, const byte *privateKey, byte *publicKey) const =0;
-	//! generate private/public key pair
-	/*! \note equivalent to calling GenerateStaticPrivateKey() and then GenerateStaticPublicKey() */
-	virtual void GenerateStaticKeyPair(RandomNumberGenerator &rng, byte *privateKey, byte *publicKey) const;
-
-	//! return length of ephemeral private keys in this domain
-	virtual unsigned int EphemeralPrivateKeyLength() const =0;
-	//! return length of ephemeral public keys in this domain
-	virtual unsigned int EphemeralPublicKeyLength() const =0;
-	//! generate ephemeral private key
-	/*! \pre size of privateKey == PrivateEphemeralKeyLength() */
-	virtual void GenerateEphemeralPrivateKey(RandomNumberGenerator &rng, byte *privateKey) const =0;
-	//! generate ephemeral public key
-	/*!	\pre size of publicKey == PublicEphemeralKeyLength() */
-	virtual void GenerateEphemeralPublicKey(RandomNumberGenerator &rng, const byte *privateKey, byte *publicKey) const =0;
-	//! generate private/public key pair
-	/*! \note equivalent to calling GenerateEphemeralPrivateKey() and then GenerateEphemeralPublicKey() */
-	virtual void GenerateEphemeralKeyPair(RandomNumberGenerator &rng, byte *privateKey, byte *publicKey) const;
-
-	//! derive agreed value from your private keys and couterparty's public keys, return false in case of failure
-	/*! \note The ephemeral public key will always be validated.
-		      If you have previously validated the static public key, use validateStaticOtherPublicKey=false to save time.
-		\pre size of agreedValue == AgreedValueLength()
-		\pre length of staticPrivateKey == StaticPrivateKeyLength()
-		\pre length of ephemeralPrivateKey == EphemeralPrivateKeyLength()
-		\pre length of staticOtherPublicKey == StaticPublicKeyLength()
-		\pre length of ephemeralOtherPublicKey == EphemeralPublicKeyLength()
-	*/
-	virtual bool Agree(byte *agreedValue,
-		const byte *staticPrivateKey, const byte *ephemeralPrivateKey,
-		const byte *staticOtherPublicKey, const byte *ephemeralOtherPublicKey,
-		bool validateStaticOtherPublicKey=true) const =0;
-
-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
-	bool ValidateDomainParameters(RandomNumberGenerator &rng) const
-		{return GetCryptoParameters().Validate(rng, 2);}
-#endif
-};
-
-// interface for password authenticated key agreement protocols, not implemented yet
-#if 0
-//! interface for protocol sessions
-/*! The methods should be called in the following order:
-
-	InitializeSession(rng, parameters);	// or call initialize method in derived class
-	while (true)
-	{
-		if (OutgoingMessageAvailable())
-		{
-			length = GetOutgoingMessageLength();
-			GetOutgoingMessage(message);
-			; // send outgoing message
-		}
-
-		if (LastMessageProcessed())
-			break;
-
-		; // receive incoming message
-		ProcessIncomingMessage(message);
-	}
-	; // call methods in derived class to obtain result of protocol session
-*/
-class ProtocolSession
-{
-public:
-	//! exception thrown when an invalid protocol message is processed
-	class ProtocolError : public Exception
-	{
-	public:
-		ProtocolError(ErrorType errorType, const std::string &s) : Exception(errorType, s) {}
-	};
-
-	//! exception thrown when a function is called unexpectedly
-	/*! for example calling ProcessIncomingMessage() when ProcessedLastMessage() == true */
-	class UnexpectedMethodCall : public Exception
-	{
-	public:
-		UnexpectedMethodCall(const std::string &s) : Exception(OTHER_ERROR, s) {}
-	};
-
-	ProtocolSession() : m_rng(NULL), m_throwOnProtocolError(true), m_validState(false) {}
-	virtual ~ProtocolSession() {}
-
-	virtual void InitializeSession(RandomNumberGenerator &rng, const NameValuePairs &parameters) =0;
-
-	bool GetThrowOnProtocolError() const {return m_throwOnProtocolError;}
-	void SetThrowOnProtocolError(bool throwOnProtocolError) {m_throwOnProtocolError = throwOnProtocolError;}
-
-	bool HasValidState() const {return m_validState;}
-
-	virtual bool OutgoingMessageAvailable() const =0;
-	virtual unsigned int GetOutgoingMessageLength() const =0;
-	virtual void GetOutgoingMessage(byte *message) =0;
-
-	virtual bool LastMessageProcessed() const =0;
-	virtual void ProcessIncomingMessage(const byte *message, unsigned int messageLength) =0;
-
-protected:
-	void HandleProtocolError(Exception::ErrorType errorType, const std::string &s) const;
-	void CheckAndHandleInvalidState() const;
-	void SetValidState(bool valid) {m_validState = valid;}
-
-	RandomNumberGenerator *m_rng;
-
-private:
-	bool m_throwOnProtocolError, m_validState;
-};
-
-class KeyAgreementSession : public ProtocolSession
-{
-public:
-	virtual unsigned int GetAgreedValueLength() const =0;
-	virtual void GetAgreedValue(byte *agreedValue) const =0;
-};
-
-class PasswordAuthenticatedKeyAgreementSession : public KeyAgreementSession
-{
-public:
-	void InitializePasswordAuthenticatedKeyAgreementSession(RandomNumberGenerator &rng, 
-		const byte *myId, unsigned int myIdLength, 
-		const byte *counterPartyId, unsigned int counterPartyIdLength, 
-		const byte *passwordOrVerifier, unsigned int passwordOrVerifierLength);
-};
-
-class PasswordAuthenticatedKeyAgreementDomain : public KeyAgreementAlgorithm
-{
-public:
-	//! return whether the domain parameters stored in this object are valid
-	virtual bool ValidateDomainParameters(RandomNumberGenerator &rng) const
-		{return GetCryptoParameters().Validate(rng, 2);}
-
-	virtual unsigned int GetPasswordVerifierLength(const byte *password, unsigned int passwordLength) const =0;
-	virtual void GeneratePasswordVerifier(RandomNumberGenerator &rng, const byte *userId, unsigned int userIdLength, const byte *password, unsigned int passwordLength, byte *verifier) const =0;
-
-	enum RoleFlags {CLIENT=1, SERVER=2, INITIATOR=4, RESPONDER=8};
-
-	virtual bool IsValidRole(unsigned int role) =0;
-	virtual PasswordAuthenticatedKeyAgreementSession * CreateProtocolSession(unsigned int role) const =0;
-};
-#endif
-
-//! BER Decode Exception Class, may be thrown during an ASN1 BER decode operation
-class BERDecodeErr : public InvalidArgument
-{
-public: 
-	BERDecodeErr() : InvalidArgument("BER decode error") {}
-	BERDecodeErr(const std::string &s) : InvalidArgument(s) {}
-};
-
-//! interface for encoding and decoding ASN1 objects
-class ASN1Object
-{
-public:
-	virtual ~ASN1Object() {}
-	//! decode this object from a BufferedTransformation, using BER (Basic Encoding Rules)
-	virtual void BERDecode(BufferedTransformation &bt) =0;
-	//! encode this object into a BufferedTransformation, using DER (Distinguished Encoding Rules)
-	virtual void DEREncode(BufferedTransformation &bt) const =0;
-	//! encode this object into a BufferedTransformation, using BER
-	/*! this may be useful if DEREncode() would be too inefficient */
-	virtual void BEREncode(BufferedTransformation &bt) const {DEREncode(bt);}
-};
-
-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
-typedef PK_SignatureScheme PK_SignatureSystem
-typedef PK_SignatureSchemeWithRecovery PK_SignatureSystemWithRecovery
-typedef SimpleKeyAgreementDomain PK_SimpleKeyAgreementDomain
-typedef AuthenticatedKeyAgreementDomain PK_AuthenticatedKeyAgreementDomain
-typedef WithPrecomputation PK_WithPrecomputation
-#endif
-
-NAMESPACE_END
-
-#endif
+// cryptlib.h - written and placed in the public domain by Wei Dai
+/*! \file
+ 	This file contains the declarations for the abstract base
+	classes that provide a uniform interface to this library.
+*/
+
+/*!	\mainpage Crypto++ Library 5.6.1 API Reference
+<dl>
+<dt>Abstract Base Classes<dd>
+	cryptlib.h
+<dt>Authenticated Encryption<dd>
+	AuthenticatedSymmetricCipherDocumentation
+<dt>Symmetric Ciphers<dd>
+	SymmetricCipherDocumentation
+<dt>Hash Functions<dd>
+	SHA1, SHA224, SHA256, SHA384, SHA512, Tiger, Whirlpool, RIPEMD160, RIPEMD320, RIPEMD128, RIPEMD256, Weak1::MD2, Weak1::MD4, Weak1::MD5
+<dt>Non-Cryptographic Checksums<dd>
+	CRC32, Adler32
+<dt>Message Authentication Codes<dd>
+	VMAC, HMAC, CBC_MAC, CMAC, DMAC, TTMAC, GCM (GMAC)
+<dt>Random Number Generators<dd>
+	NullRNG(), LC_RNG, RandomPool, BlockingRng, NonblockingRng, AutoSeededRandomPool, AutoSeededX917RNG, #DefaultAutoSeededRNG
+<dt>Password-based Cryptography<dd>
+	PasswordBasedKeyDerivationFunction
+<dt>Public Key Cryptosystems<dd>
+	DLIES, ECIES, LUCES, RSAES, RabinES, LUC_IES
+<dt>Public Key Signature Schemes<dd>
+	DSA, GDSA, ECDSA, NR, ECNR, LUCSS, RSASS, RSASS_ISO, RabinSS, RWSS, ESIGN
+<dt>Key Agreement<dd>
+	#DH, DH2, #MQV, ECDH, ECMQV, XTR_DH
+<dt>Algebraic Structures<dd>
+	Integer, PolynomialMod2, PolynomialOver, RingOfPolynomialsOver,
+	ModularArithmetic, MontgomeryRepresentation, GFP2_ONB,
+	GF2NP, GF256, GF2_32, EC2N, ECP
+<dt>Secret Sharing and Information Dispersal<dd>
+	SecretSharing, SecretRecovery, InformationDispersal, InformationRecovery
+<dt>Compression<dd>
+	Deflator, Inflator, Gzip, Gunzip, ZlibCompressor, ZlibDecompressor
+<dt>Input Source Classes<dd>
+	StringSource, #ArraySource, FileSource, SocketSource, WindowsPipeSource, RandomNumberSource
+<dt>Output Sink Classes<dd>
+	StringSinkTemplate, ArraySink, FileSink, SocketSink, WindowsPipeSink, RandomNumberSink
+<dt>Filter Wrappers<dd>
+	StreamTransformationFilter, HashFilter, HashVerificationFilter, SignerFilter, SignatureVerificationFilter
+<dt>Binary to Text Encoders and Decoders<dd>
+	HexEncoder, HexDecoder, Base64Encoder, Base64Decoder, Base32Encoder, Base32Decoder
+<dt>Wrappers for OS features<dd>
+	Timer, Socket, WindowsHandle, ThreadLocalStorage, ThreadUserTimer
+<dt>FIPS 140 related<dd>
+	fips140.h
+</dl>
+
+In the DLL version of Crypto++, only the following implementation class are available.
+<dl>
+<dt>Block Ciphers<dd>
+	AES, DES_EDE2, DES_EDE3, SKIPJACK
+<dt>Cipher Modes (replace template parameter BC with one of the block ciphers above)<dd>
+	ECB_Mode\<BC\>, CTR_Mode\<BC\>, CBC_Mode\<BC\>, CFB_FIPS_Mode\<BC\>, OFB_Mode\<BC\>, GCM\<AES\>
+<dt>Hash Functions<dd>
+	SHA1, SHA224, SHA256, SHA384, SHA512
+<dt>Public Key Signature Schemes (replace template parameter H with one of the hash functions above)<dd>
+	RSASS\<PKCS1v15, H\>, RSASS\<PSS, H\>, RSASS_ISO\<H\>, RWSS\<P1363_EMSA2, H\>, DSA, ECDSA\<ECP, H\>, ECDSA\<EC2N, H\>
+<dt>Message Authentication Codes (replace template parameter H with one of the hash functions above)<dd>
+	HMAC\<H\>, CBC_MAC\<DES_EDE2\>, CBC_MAC\<DES_EDE3\>, GCM\<AES\>
+<dt>Random Number Generators<dd>
+	#DefaultAutoSeededRNG (AutoSeededX917RNG\<AES\>)
+<dt>Key Agreement<dd>
+	#DH
+<dt>Public Key Cryptosystems<dd>
+	RSAES\<OAEP\<SHA1\> \>
+</dl>
+
+<p>This reference manual is a work in progress. Some classes are still lacking detailed descriptions.
+<p>Click <a href="CryptoPPRef.zip">here</a> to download a zip archive containing this manual.
+<p>Thanks to Ryan Phillips for providing the Doxygen configuration file
+and getting me started with this manual.
+*/
+
+#ifndef CRYPTOPP_CRYPTLIB_H
+#define CRYPTOPP_CRYPTLIB_H
+
+#include "config.h"
+#include "stdcpp.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+// forward declarations
+class Integer;
+class RandomNumberGenerator;
+class BufferedTransformation;
+
+//! used to specify a direction for a cipher to operate in (encrypt or decrypt)
+enum CipherDir {ENCRYPTION, DECRYPTION};
+
+//! used to represent infinite time
+const unsigned long INFINITE_TIME = ULONG_MAX;
+
+// VC60 workaround: using enums as template parameters causes problems
+template <typename ENUM_TYPE, int VALUE>
+struct EnumToType
+{
+	static ENUM_TYPE ToEnum() {return (ENUM_TYPE)VALUE;}
+};
+
+enum ByteOrder {LITTLE_ENDIAN_ORDER = 0, BIG_ENDIAN_ORDER = 1};
+typedef EnumToType<ByteOrder, LITTLE_ENDIAN_ORDER> LittleEndian;
+typedef EnumToType<ByteOrder, BIG_ENDIAN_ORDER> BigEndian;
+
+//! base class for all exceptions thrown by Crypto++
+class CRYPTOPP_DLL Exception : public std::exception
+{
+public:
+	//! error types
+	enum ErrorType {
+		//! a method is not implemented
+		NOT_IMPLEMENTED,
+		//! invalid function argument
+		INVALID_ARGUMENT,
+		//! BufferedTransformation received a Flush(true) signal but can't flush buffers
+		CANNOT_FLUSH,
+		//! data integerity check (such as CRC or MAC) failed
+		DATA_INTEGRITY_CHECK_FAILED,
+		//! received input data that doesn't conform to expected format
+		INVALID_DATA_FORMAT,
+		//! error reading from input device or writing to output device
+		IO_ERROR,
+		//! some error not belong to any of the above categories
+		OTHER_ERROR
+	};
+
+	explicit Exception(ErrorType errorType, const std::string &s) : m_errorType(errorType), m_what(s) {}
+	virtual ~Exception() throw() {}
+	const char *what() const throw() {return (m_what.c_str());}
+	const std::string &GetWhat() const {return m_what;}
+	void SetWhat(const std::string &s) {m_what = s;}
+	ErrorType GetErrorType() const {return m_errorType;}
+	void SetErrorType(ErrorType errorType) {m_errorType = errorType;}
+
+private:
+	ErrorType m_errorType;
+	std::string m_what;
+};
+
+//! exception thrown when an invalid argument is detected
+class CRYPTOPP_DLL InvalidArgument : public Exception
+{
+public:
+	explicit InvalidArgument(const std::string &s) : Exception(INVALID_ARGUMENT, s) {}
+};
+
+//! exception thrown when input data is received that doesn't conform to expected format
+class CRYPTOPP_DLL InvalidDataFormat : public Exception
+{
+public:
+	explicit InvalidDataFormat(const std::string &s) : Exception(INVALID_DATA_FORMAT, s) {}
+};
+
+//! exception thrown by decryption filters when trying to decrypt an invalid ciphertext
+class CRYPTOPP_DLL InvalidCiphertext : public InvalidDataFormat
+{
+public:
+	explicit InvalidCiphertext(const std::string &s) : InvalidDataFormat(s) {}
+};
+
+//! exception thrown by a class if a non-implemented method is called
+class CRYPTOPP_DLL NotImplemented : public Exception
+{
+public:
+	explicit NotImplemented(const std::string &s) : Exception(NOT_IMPLEMENTED, s) {}
+};
+
+//! exception thrown by a class when Flush(true) is called but it can't completely flush its buffers
+class CRYPTOPP_DLL CannotFlush : public Exception
+{
+public:
+	explicit CannotFlush(const std::string &s) : Exception(CANNOT_FLUSH, s) {}
+};
+
+//! error reported by the operating system
+class CRYPTOPP_DLL OS_Error : public Exception
+{
+public:
+	OS_Error(ErrorType errorType, const std::string &s, const std::string& operation, int errorCode)
+		: Exception(errorType, s), m_operation(operation), m_errorCode(errorCode) {}
+	~OS_Error() throw() {}
+
+	// the operating system API that reported the error
+	const std::string & GetOperation() const {return m_operation;}
+	// the error code return by the operating system
+	int GetErrorCode() const {return m_errorCode;}
+
+protected:
+	std::string m_operation;
+	int m_errorCode;
+};
+
+//! used to return decoding results
+struct CRYPTOPP_DLL DecodingResult
+{
+	explicit DecodingResult() : isValidCoding(false), messageLength(0) {}
+	explicit DecodingResult(size_t len) : isValidCoding(true), messageLength(len) {}
+
+	bool operator==(const DecodingResult &rhs) const {return isValidCoding == rhs.isValidCoding && messageLength == rhs.messageLength;}
+	bool operator!=(const DecodingResult &rhs) const {return !operator==(rhs);}
+
+	bool isValidCoding;
+	size_t messageLength;
+
+#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
+	operator size_t() const {return isValidCoding ? messageLength : 0;}
+#endif
+};
+
+//! interface for retrieving values given their names
+/*! \note This class is used to safely pass a variable number of arbitrarily typed arguments to functions
+	and to read values from keys and crypto parameters.
+	\note To obtain an object that implements NameValuePairs for the purpose of parameter
+	passing, use the MakeParameters() function.
+	\note To get a value from NameValuePairs, you need to know the name and the type of the value. 
+	Call GetValueNames() on a NameValuePairs object to obtain a list of value names that it supports.
+	Then look at the Name namespace documentation to see what the type of each value is, or
+	alternatively, call GetIntValue() with the value name, and if the type is not int, a
+	ValueTypeMismatch exception will be thrown and you can get the actual type from the exception object.
+*/
+class CRYPTOPP_NO_VTABLE NameValuePairs
+{
+public:
+	virtual ~NameValuePairs() {}
+
+	//! exception thrown when trying to retrieve a value using a different type than expected
+	class CRYPTOPP_DLL ValueTypeMismatch : public InvalidArgument
+	{
+	public:
+		ValueTypeMismatch(const std::string &name, const std::type_info &stored, const std::type_info &retrieving)
+			: InvalidArgument("NameValuePairs: type mismatch for '" + name + "', stored '" + stored.name() + "', trying to retrieve '" + retrieving.name() + "'")
+			, m_stored(stored), m_retrieving(retrieving) {}
+
+		const std::type_info & GetStoredTypeInfo() const {return m_stored;}
+		const std::type_info & GetRetrievingTypeInfo() const {return m_retrieving;}
+
+	private:
+		const std::type_info &m_stored;
+		const std::type_info &m_retrieving;
+	};
+
+	//! get a copy of this object or a subobject of it
+	template <class T>
+	bool GetThisObject(T &object) const
+	{
+		return GetValue((std::string("ThisObject:")+typeid(T).name()).c_str(), object);
+	}
+
+	//! get a pointer to this object, as a pointer to T
+	template <class T>
+	bool GetThisPointer(T *&p) const
+	{
+		return GetValue((std::string("ThisPointer:")+typeid(T).name()).c_str(), p);
+	}
+
+	//! get a named value, returns true if the name exists
+	template <class T>
+	bool GetValue(const char *name, T &value) const
+	{
+		return GetVoidValue(name, typeid(T), &value);
+	}
+
+	//! get a named value, returns the default if the name doesn't exist
+	template <class T>
+	T GetValueWithDefault(const char *name, T defaultValue) const
+	{
+		GetValue(name, defaultValue);
+		return defaultValue;
+	}
+
+	//! get a list of value names that can be retrieved
+	CRYPTOPP_DLL std::string GetValueNames() const
+		{std::string result; GetValue("ValueNames", result); return result;}
+
+	//! get a named value with type int
+	/*! used to ensure we don't accidentally try to get an unsigned int
+		or some other type when we mean int (which is the most common case) */
+	CRYPTOPP_DLL bool GetIntValue(const char *name, int &value) const
+		{return GetValue(name, value);}
+
+	//! get a named value with type int, with default
+	CRYPTOPP_DLL int GetIntValueWithDefault(const char *name, int defaultValue) const
+		{return GetValueWithDefault(name, defaultValue);}
+
+	//! used by derived classes to check for type mismatch
+	CRYPTOPP_DLL static void CRYPTOPP_API ThrowIfTypeMismatch(const char *name, const std::type_info &stored, const std::type_info &retrieving)
+		{if (stored != retrieving) throw ValueTypeMismatch(name, stored, retrieving);}
+
+	template <class T>
+	void GetRequiredParameter(const char *className, const char *name, T &value) const
+	{
+		if (!GetValue(name, value))
+			throw InvalidArgument(std::string(className) + ": missing required parameter '" + name + "'");
+	}
+
+	CRYPTOPP_DLL void GetRequiredIntParameter(const char *className, const char *name, int &value) const
+	{
+		if (!GetIntValue(name, value))
+			throw InvalidArgument(std::string(className) + ": missing required parameter '" + name + "'");
+	}
+
+	//! to be implemented by derived classes, users should use one of the above functions instead
+	CRYPTOPP_DLL virtual bool GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const =0;
+};
+
+//! namespace containing value name definitions
+/*!	value names, types and semantics:
+
+	ThisObject:ClassName (ClassName, copy of this object or a subobject)
+	ThisPointer:ClassName (const ClassName *, pointer to this object or a subobject)
+*/
+DOCUMENTED_NAMESPACE_BEGIN(Name)
+// more names defined in argnames.h
+DOCUMENTED_NAMESPACE_END
+
+//! empty set of name-value pairs
+extern CRYPTOPP_DLL const NameValuePairs &g_nullNameValuePairs;
+
+// ********************************************************
+
+//! interface for cloning objects, this is not implemented by most classes yet
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE Clonable
+{
+public:
+	virtual ~Clonable() {}
+	//! this is not implemented by most classes yet
+	virtual Clonable* Clone() const {throw NotImplemented("Clone() is not implemented yet.");}	// TODO: make this =0
+};
+
+//! interface for all crypto algorithms
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE Algorithm : public Clonable
+{
+public:
+	/*! When FIPS 140-2 compliance is enabled and checkSelfTestStatus == true,
+		this constructor throws SelfTestFailure if the self test hasn't been run or fails. */
+	Algorithm(bool checkSelfTestStatus = true);
+	//! returns name of this algorithm, not universally implemented yet
+	virtual std::string AlgorithmName() const {return "unknown";}
+};
+
+//! keying interface for crypto algorithms that take byte strings as keys
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE SimpleKeyingInterface
+{
+public:
+	virtual ~SimpleKeyingInterface() {}
+
+	//! returns smallest valid key length in bytes */
+	virtual size_t MinKeyLength() const =0;
+	//! returns largest valid key length in bytes */
+	virtual size_t MaxKeyLength() const =0;
+	//! returns default (recommended) key length in bytes */
+	virtual size_t DefaultKeyLength() const =0;
+
+	//! returns the smallest valid key length in bytes that is >= min(n, GetMaxKeyLength())
+	virtual size_t GetValidKeyLength(size_t n) const =0;
+
+	//! returns whether n is a valid key length
+	virtual bool IsValidKeyLength(size_t n) const
+		{return n == GetValidKeyLength(n);}
+
+	//! set or reset the key of this object
+	/*! \param params is used to specify Rounds, BlockSize, etc. */
+	virtual void SetKey(const byte *key, size_t length, const NameValuePairs &params = g_nullNameValuePairs);
+
+	//! calls SetKey() with an NameValuePairs object that just specifies "Rounds"
+	void SetKeyWithRounds(const byte *key, size_t length, int rounds);
+
+	//! calls SetKey() with an NameValuePairs object that just specifies "IV"
+	void SetKeyWithIV(const byte *key, size_t length, const byte *iv, size_t ivLength);
+
+	//! calls SetKey() with an NameValuePairs object that just specifies "IV"
+	void SetKeyWithIV(const byte *key, size_t length, const byte *iv)
+		{SetKeyWithIV(key, length, iv, IVSize());}
+
+	enum IV_Requirement {UNIQUE_IV = 0, RANDOM_IV, UNPREDICTABLE_RANDOM_IV, INTERNALLY_GENERATED_IV, NOT_RESYNCHRONIZABLE};
+	//! returns the minimal requirement for secure IVs
+	virtual IV_Requirement IVRequirement() const =0;
+
+	//! returns whether this object can be resynchronized (i.e. supports initialization vectors)
+	/*! If this function returns true, and no IV is passed to SetKey() and CanUseStructuredIVs()==true, an IV of all 0's will be assumed. */
+	bool IsResynchronizable() const {return IVRequirement() < NOT_RESYNCHRONIZABLE;}
+	//! returns whether this object can use random IVs (in addition to ones returned by GetNextIV)
+	bool CanUseRandomIVs() const {return IVRequirement() <= UNPREDICTABLE_RANDOM_IV;}
+	//! returns whether this object can use random but possibly predictable IVs (in addition to ones returned by GetNextIV)
+	bool CanUsePredictableIVs() const {return IVRequirement() <= RANDOM_IV;}
+	//! returns whether this object can use structured IVs, for example a counter (in addition to ones returned by GetNextIV)
+	bool CanUseStructuredIVs() const {return IVRequirement() <= UNIQUE_IV;}
+
+	virtual unsigned int IVSize() const {throw NotImplemented(GetAlgorithm().AlgorithmName() + ": this object doesn't support resynchronization");}
+	//! returns default length of IVs accepted by this object
+	unsigned int DefaultIVLength() const {return IVSize();}
+	//! returns minimal length of IVs accepted by this object
+	virtual unsigned int MinIVLength() const {return IVSize();}
+	//! returns maximal length of IVs accepted by this object
+	virtual unsigned int MaxIVLength() const {return IVSize();}
+	//! resynchronize with an IV. ivLength=-1 means use IVSize()
+	virtual void Resynchronize(const byte *iv, int ivLength=-1) {throw NotImplemented(GetAlgorithm().AlgorithmName() + ": this object doesn't support resynchronization");}
+	//! get a secure IV for the next message
+	/*! This method should be called after you finish encrypting one message and are ready to start the next one.
+		After calling it, you must call SetKey() or Resynchronize() before using this object again. 
+		This method is not implemented on decryption objects. */
+	virtual void GetNextIV(RandomNumberGenerator &rng, byte *IV);
+
+protected:
+	virtual const Algorithm & GetAlgorithm() const =0;
+	virtual void UncheckedSetKey(const byte *key, unsigned int length, const NameValuePairs &params) =0;
+
+	void ThrowIfInvalidKeyLength(size_t length);
+	void ThrowIfResynchronizable();			// to be called when no IV is passed
+	void ThrowIfInvalidIV(const byte *iv);	// check for NULL IV if it can't be used
+	size_t ThrowIfInvalidIVLength(int size);
+	const byte * GetIVAndThrowIfInvalid(const NameValuePairs &params, size_t &size);
+	inline void AssertValidKeyLength(size_t length) const
+		{assert(IsValidKeyLength(length));}
+};
+
+//! interface for the data processing part of block ciphers
+
+/*! Classes derived from BlockTransformation are block ciphers
+	in ECB mode (for example the DES::Encryption class), which are stateless.
+	These classes should not be used directly, but only in combination with
+	a mode class (see CipherModeDocumentation in modes.h).
+*/
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE BlockTransformation : public Algorithm
+{
+public:
+	//! encrypt or decrypt inBlock, xor with xorBlock, and write to outBlock
+	virtual void ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const =0;
+
+	//! encrypt or decrypt one block
+	/*! \pre size of inBlock and outBlock == BlockSize() */
+	void ProcessBlock(const byte *inBlock, byte *outBlock) const
+		{ProcessAndXorBlock(inBlock, NULL, outBlock);}
+
+	//! encrypt or decrypt one block in place
+	void ProcessBlock(byte *inoutBlock) const
+		{ProcessAndXorBlock(inoutBlock, NULL, inoutBlock);}
+
+	//! block size of the cipher in bytes
+	virtual unsigned int BlockSize() const =0;
+
+	//! returns how inputs and outputs should be aligned for optimal performance
+	virtual unsigned int OptimalDataAlignment() const;
+
+	//! returns true if this is a permutation (i.e. there is an inverse transformation)
+	virtual bool IsPermutation() const {return true;}
+
+	//! returns true if this is an encryption object
+	virtual bool IsForwardTransformation() const =0;
+
+	//! return number of blocks that can be processed in parallel, for bit-slicing implementations
+	virtual unsigned int OptimalNumberOfParallelBlocks() const {return 1;}
+
+	enum {BT_InBlockIsCounter=1, BT_DontIncrementInOutPointers=2, BT_XorInput=4, BT_ReverseDirection=8, BT_AllowParallel=16} FlagsForAdvancedProcessBlocks;
+
+	//! encrypt and xor blocks according to flags (see FlagsForAdvancedProcessBlocks)
+	/*! /note If BT_InBlockIsCounter is set, last byte of inBlocks may be modified. */
+	virtual size_t AdvancedProcessBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags) const;
+
+	inline CipherDir GetCipherDirection() const {return IsForwardTransformation() ? ENCRYPTION : DECRYPTION;}
+};
+
+//! interface for the data processing part of stream ciphers
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE StreamTransformation : public Algorithm
+{
+public:
+	//! return a reference to this object, useful for passing a temporary object to a function that takes a non-const reference
+	StreamTransformation& Ref() {return *this;}
+
+	//! returns block size, if input must be processed in blocks, otherwise 1
+	virtual unsigned int MandatoryBlockSize() const {return 1;}
+
+	//! returns the input block size that is most efficient for this cipher
+	/*! \note optimal input length is n * OptimalBlockSize() - GetOptimalBlockSizeUsed() for any n > 0 */
+	virtual unsigned int OptimalBlockSize() const {return MandatoryBlockSize();}
+	//! returns how much of the current block is used up
+	virtual unsigned int GetOptimalBlockSizeUsed() const {return 0;}
+
+	//! returns how input should be aligned for optimal performance
+	virtual unsigned int OptimalDataAlignment() const;
+
+	//! encrypt or decrypt an array of bytes of specified length
+	/*! \note either inString == outString, or they don't overlap */
+	virtual void ProcessData(byte *outString, const byte *inString, size_t length) =0;
+
+	//! for ciphers where the last block of data is special, encrypt or decrypt the last block of data
+	/*! For now the only use of this function is for CBC-CTS mode. */
+	virtual void ProcessLastBlock(byte *outString, const byte *inString, size_t length);
+	//! returns the minimum size of the last block, 0 indicating the last block is not special
+	virtual unsigned int MinLastBlockSize() const {return 0;}
+
+	//! same as ProcessData(inoutString, inoutString, length)
+	inline void ProcessString(byte *inoutString, size_t length)
+		{ProcessData(inoutString, inoutString, length);}
+	//! same as ProcessData(outString, inString, length)
+	inline void ProcessString(byte *outString, const byte *inString, size_t length)
+		{ProcessData(outString, inString, length);}
+	//! implemented as {ProcessData(&input, &input, 1); return input;}
+	inline byte ProcessByte(byte input)
+		{ProcessData(&input, &input, 1); return input;}
+
+	//! returns whether this cipher supports random access
+	virtual bool IsRandomAccess() const =0;
+	//! for random access ciphers, seek to an absolute position
+	virtual void Seek(lword n)
+	{
+		assert(!IsRandomAccess());
+		throw NotImplemented("StreamTransformation: this object doesn't support random access");
+	}
+
+	//! returns whether this transformation is self-inverting (e.g. xor with a keystream)
+	virtual bool IsSelfInverting() const =0;
+	//! returns whether this is an encryption object
+	virtual bool IsForwardTransformation() const =0;
+};
+
+//! interface for hash functions and data processing part of MACs
+
+/*! HashTransformation objects are stateful.  They are created in an initial state,
+	change state as Update() is called, and return to the initial
+	state when Final() is called.  This interface allows a large message to
+	be hashed in pieces by calling Update() on each piece followed by
+	calling Final().
+*/
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE HashTransformation : public Algorithm
+{
+public:
+	//! return a reference to this object, useful for passing a temporary object to a function that takes a non-const reference
+	HashTransformation& Ref() {return *this;}
+
+	//! process more input
+	virtual void Update(const byte *input, size_t length) =0;
+
+	//! request space to write input into
+	virtual byte * CreateUpdateSpace(size_t &size) {size=0; return NULL;}
+
+	//! compute hash for current message, then restart for a new message
+	/*!	\pre size of digest == DigestSize(). */
+	virtual void Final(byte *digest)
+		{TruncatedFinal(digest, DigestSize());}
+
+	//! discard the current state, and restart with a new message
+	virtual void Restart()
+		{TruncatedFinal(NULL, 0);}
+
+	//! size of the hash/digest/MAC returned by Final()
+	virtual unsigned int DigestSize() const =0;
+
+	//! same as DigestSize()
+	unsigned int TagSize() const {return DigestSize();}
+
+
+	//! block size of underlying compression function, or 0 if not block based
+	virtual unsigned int BlockSize() const {return 0;}
+
+	//! input to Update() should have length a multiple of this for optimal speed
+	virtual unsigned int OptimalBlockSize() const {return 1;}
+
+	//! returns how input should be aligned for optimal performance
+	virtual unsigned int OptimalDataAlignment() const;
+
+	//! use this if your input is in one piece and you don't want to call Update() and Final() separately
+	virtual void CalculateDigest(byte *digest, const byte *input, size_t length)
+		{Update(input, length); Final(digest);}
+
+	//! verify that digest is a valid digest for the current message, then reinitialize the object
+	/*! Default implementation is to call Final() and do a bitwise comparison
+		between its output and digest. */
+	virtual bool Verify(const byte *digest)
+		{return TruncatedVerify(digest, DigestSize());}
+
+	//! use this if your input is in one piece and you don't want to call Update() and Verify() separately
+	virtual bool VerifyDigest(const byte *digest, const byte *input, size_t length)
+		{Update(input, length); return Verify(digest);}
+
+	//! truncated version of Final()
+	virtual void TruncatedFinal(byte *digest, size_t digestSize) =0;
+
+	//! truncated version of CalculateDigest()
+	virtual void CalculateTruncatedDigest(byte *digest, size_t digestSize, const byte *input, size_t length)
+		{Update(input, length); TruncatedFinal(digest, digestSize);}
+
+	//! truncated version of Verify()
+	virtual bool TruncatedVerify(const byte *digest, size_t digestLength);
+
+	//! truncated version of VerifyDigest()
+	virtual bool VerifyTruncatedDigest(const byte *digest, size_t digestLength, const byte *input, size_t length)
+		{Update(input, length); return TruncatedVerify(digest, digestLength);}
+
+protected:
+	void ThrowIfInvalidTruncatedSize(size_t size) const;
+};
+
+typedef HashTransformation HashFunction;
+
+//! interface for one direction (encryption or decryption) of a block cipher
+/*! \note These objects usually should not be used directly. See BlockTransformation for more details. */
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE BlockCipher : public SimpleKeyingInterface, public BlockTransformation
+{
+protected:
+	const Algorithm & GetAlgorithm() const {return *this;}
+};
+
+//! interface for one direction (encryption or decryption) of a stream cipher or cipher mode
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE SymmetricCipher : public SimpleKeyingInterface, public StreamTransformation
+{
+protected:
+	const Algorithm & GetAlgorithm() const {return *this;}
+};
+
+//! interface for message authentication codes
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE MessageAuthenticationCode : public SimpleKeyingInterface, public HashTransformation
+{
+protected:
+	const Algorithm & GetAlgorithm() const {return *this;}
+};
+
+//! interface for for one direction (encryption or decryption) of a stream cipher or block cipher mode with authentication
+/*! The StreamTransformation part of this interface is used to encrypt/decrypt the data, and the MessageAuthenticationCode part of this
+	interface is used to input additional authenticated data (AAD, which is MAC'ed but not encrypted), and to generate/verify the MAC. */
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE AuthenticatedSymmetricCipher : public MessageAuthenticationCode, public StreamTransformation
+{
+public:
+	//! this indicates that a member function was called in the wrong state, for example trying to encrypt a message before having set the key or IV
+	class BadState : public Exception
+	{
+	public:
+		explicit BadState(const std::string &name, const char *message) : Exception(OTHER_ERROR, name + ": " + message) {}
+		explicit BadState(const std::string &name, const char *function, const char *state) : Exception(OTHER_ERROR, name + ": " + function + " was called before " + state) {}
+	};
+
+	//! the maximum length of AAD that can be input before the encrypted data
+	virtual lword MaxHeaderLength() const =0;
+	//! the maximum length of encrypted data
+	virtual lword MaxMessageLength() const =0;
+	//! the maximum length of AAD that can be input after the encrypted data
+	virtual lword MaxFooterLength() const {return 0;}
+	//! if this function returns true, SpecifyDataLengths() must be called before attempting to input data
+	/*! This is the case for some schemes, such as CCM. */
+	virtual bool NeedsPrespecifiedDataLengths() const {return false;}
+	//! this function only needs to be called if NeedsPrespecifiedDataLengths() returns true
+	void SpecifyDataLengths(lword headerLength, lword messageLength, lword footerLength=0);
+	//! encrypt and generate MAC in one call. will truncate MAC if macSize < TagSize()
+	virtual void EncryptAndAuthenticate(byte *ciphertext, byte *mac, size_t macSize, const byte *iv, int ivLength, const byte *header, size_t headerLength, const byte *message, size_t messageLength);
+	//! decrypt and verify MAC in one call, returning true iff MAC is valid. will assume MAC is truncated if macLength < TagSize()
+	virtual bool DecryptAndVerify(byte *message, const byte *mac, size_t macLength, const byte *iv, int ivLength, const byte *header, size_t headerLength, const byte *ciphertext, size_t ciphertextLength);
+
+	// redeclare this to avoid compiler ambiguity errors
+	virtual std::string AlgorithmName() const =0;
+
+protected:
+	const Algorithm & GetAlgorithm() const {return *static_cast<const MessageAuthenticationCode *>(this);}
+	virtual void UncheckedSpecifyDataLengths(lword headerLength, lword messageLength, lword footerLength) {}
+};
+
+#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
+typedef SymmetricCipher StreamCipher;
+#endif
+
+//! interface for random number generators
+/*! All return values are uniformly distributed over the range specified.
+*/
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE RandomNumberGenerator : public Algorithm
+{
+public:
+	//! update RNG state with additional unpredictable values
+	virtual void IncorporateEntropy(const byte *input, size_t length) {throw NotImplemented("RandomNumberGenerator: IncorporateEntropy not implemented");}
+
+	//! returns true if IncorporateEntropy is implemented
+	virtual bool CanIncorporateEntropy() const {return false;}
+
+	//! generate new random byte and return it
+	virtual byte GenerateByte();
+
+	//! generate new random bit and return it
+	/*! Default implementation is to call GenerateByte() and return its lowest bit. */
+	virtual unsigned int GenerateBit();
+
+	//! generate a random 32 bit word in the range min to max, inclusive
+	virtual word32 GenerateWord32(word32 a=0, word32 b=0xffffffffL);
+
+	//! generate random array of bytes
+	virtual void GenerateBlock(byte *output, size_t size);
+
+	//! generate and discard n bytes
+	virtual void DiscardBytes(size_t n);
+
+	//! generate random bytes as input to a BufferedTransformation
+	virtual void GenerateIntoBufferedTransformation(BufferedTransformation &target, const std::string &channel, lword length);
+
+	//! randomly shuffle the specified array, resulting permutation is uniformly distributed
+	template <class IT> void Shuffle(IT begin, IT end)
+	{
+		for (; begin != end; ++begin)
+			std::iter_swap(begin, begin + GenerateWord32(0, end-begin-1));
+	}
+
+#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
+	byte GetByte() {return GenerateByte();}
+	unsigned int GetBit() {return GenerateBit();}
+	word32 GetLong(word32 a=0, word32 b=0xffffffffL) {return GenerateWord32(a, b);}
+	word16 GetShort(word16 a=0, word16 b=0xffff) {return (word16)GenerateWord32(a, b);}
+	void GetBlock(byte *output, size_t size) {GenerateBlock(output, size);}
+#endif
+};
+
+//! returns a reference that can be passed to functions that ask for a RNG but doesn't actually use it
+CRYPTOPP_DLL RandomNumberGenerator & CRYPTOPP_API NullRNG();
+
+class WaitObjectContainer;
+class CallStack;
+
+//! interface for objects that you can wait for
+
+class CRYPTOPP_NO_VTABLE Waitable
+{
+public:
+	virtual ~Waitable() {}
+
+	//! maximum number of wait objects that this object can return
+	virtual unsigned int GetMaxWaitObjectCount() const =0;
+	//! put wait objects into container
+	/*! \param callStack is used for tracing no wait loops, example:
+	             something.GetWaitObjects(c, CallStack("my func after X", 0));
+			   - or in an outer GetWaitObjects() method that itself takes a callStack parameter:
+			     innerThing.GetWaitObjects(c, CallStack("MyClass::GetWaitObjects at X", &callStack)); */
+	virtual void GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack) =0;
+	//! wait on this object
+	/*! same as creating an empty container, calling GetWaitObjects(), and calling Wait() on the container */
+	bool Wait(unsigned long milliseconds, CallStack const& callStack);
+};
+
+//! the default channel for BufferedTransformation, equal to the empty string
+extern CRYPTOPP_DLL const std::string DEFAULT_CHANNEL;
+
+//! channel for additional authenticated data, equal to "AAD"
+extern CRYPTOPP_DLL const std::string AAD_CHANNEL;
+
+//! interface for buffered transformations
+
+/*! BufferedTransformation is a generalization of BlockTransformation,
+	StreamTransformation, and HashTransformation.
+
+	A buffered transformation is an object that takes a stream of bytes
+	as input (this may be done in stages), does some computation on them, and
+	then places the result into an internal buffer for later retrieval.  Any
+	partial result already in the output buffer is not modified by further
+	input.
+
+	If a method takes a "blocking" parameter, and you
+	pass "false" for it, the method will return before all input has been processed if
+	the input cannot be processed without waiting (for network buffers to become available, for example).
+	In this case the method will return true
+	or a non-zero integer value. When this happens you must continue to call the method with the same
+	parameters until it returns false or zero, before calling any other method on it or
+	attached BufferedTransformation. The integer return value in this case is approximately
+	the number of bytes left to be processed, and can be used to implement a progress bar.
+
+	For functions that take a "propagation" parameter, propagation != 0 means pass on the signal to attached
+	BufferedTransformation objects, with propagation decremented at each step until it reaches 0.
+	-1 means unlimited propagation.
+
+	\nosubgrouping
+*/
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE BufferedTransformation : public Algorithm, public Waitable
+{
+public:
+	// placed up here for CW8
+	static const std::string &NULL_CHANNEL;	// same as DEFAULT_CHANNEL, for backwards compatibility
+
+	BufferedTransformation() : Algorithm(false) {}
+
+	//! return a reference to this object, useful for passing a temporary object to a function that takes a non-const reference
+	BufferedTransformation& Ref() {return *this;}
+
+	//!	\name INPUT
+	//@{
+		//! input a byte for processing
+		size_t Put(byte inByte, bool blocking=true)
+			{return Put(&inByte, 1, blocking);}
+		//! input multiple bytes
+		size_t Put(const byte *inString, size_t length, bool blocking=true)
+			{return Put2(inString, length, 0, blocking);}
+
+		//! input a 16-bit word
+		size_t PutWord16(word16 value, ByteOrder order=BIG_ENDIAN_ORDER, bool blocking=true);
+		//! input a 32-bit word
+		size_t PutWord32(word32 value, ByteOrder order=BIG_ENDIAN_ORDER, bool blocking=true);
+
+		//! request space which can be written into by the caller, and then used as input to Put()
+		/*! \param size is requested size (as a hint) for input, and size of the returned space for output */
+		/*! \note The purpose of this method is to help avoid doing extra memory allocations. */
+		virtual byte * CreatePutSpace(size_t &size) {size=0; return NULL;}
+
+		virtual bool CanModifyInput() const {return false;}
+
+		//! input multiple bytes that may be modified by callee
+		size_t PutModifiable(byte *inString, size_t length, bool blocking=true)
+			{return PutModifiable2(inString, length, 0, blocking);}
+
+		bool MessageEnd(int propagation=-1, bool blocking=true)
+			{return !!Put2(NULL, 0, propagation < 0 ? -1 : propagation+1, blocking);}
+		size_t PutMessageEnd(const byte *inString, size_t length, int propagation=-1, bool blocking=true)
+			{return Put2(inString, length, propagation < 0 ? -1 : propagation+1, blocking);}
+
+		//! input multiple bytes for blocking or non-blocking processing
+		/*! \param messageEnd means how many filters to signal MessageEnd to, including this one */
+		virtual size_t Put2(const byte *inString, size_t length, int messageEnd, bool blocking) =0;
+		//! input multiple bytes that may be modified by callee for blocking or non-blocking processing
+		/*! \param messageEnd means how many filters to signal MessageEnd to, including this one */
+		virtual size_t PutModifiable2(byte *inString, size_t length, int messageEnd, bool blocking)
+			{return Put2(inString, length, messageEnd, blocking);}
+
+		//! thrown by objects that have not implemented nonblocking input processing
+		struct BlockingInputOnly : public NotImplemented
+			{BlockingInputOnly(const std::string &s) : NotImplemented(s + ": Nonblocking input is not implemented by this object.") {}};
+	//@}
+
+	//!	\name WAITING
+	//@{
+		unsigned int GetMaxWaitObjectCount() const;
+		void GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack);
+	//@}
+
+	//!	\name SIGNALS
+	//@{
+		virtual void IsolatedInitialize(const NameValuePairs &parameters) {throw NotImplemented("BufferedTransformation: this object can't be reinitialized");}
+		virtual bool IsolatedFlush(bool hardFlush, bool blocking) =0;
+		virtual bool IsolatedMessageSeriesEnd(bool blocking) {return false;}
+
+		//! initialize or reinitialize this object
+		virtual void Initialize(const NameValuePairs &parameters=g_nullNameValuePairs, int propagation=-1);
+		//! flush buffered input and/or output
+		/*! \param hardFlush is used to indicate whether all data should be flushed
+			\note Hard flushes must be used with care. It means try to process and output everything, even if
+			there may not be enough data to complete the action. For example, hard flushing a HexDecoder would
+			cause an error if you do it after inputing an odd number of hex encoded characters.
+			For some types of filters, for example ZlibDecompressor, hard flushes can only
+			be done at "synchronization points". These synchronization points are positions in the data
+			stream that are created by hard flushes on the corresponding reverse filters, in this
+			example ZlibCompressor. This is useful when zlib compressed data is moved across a
+			network in packets and compression state is preserved across packets, as in the ssh2 protocol.
+		*/
+		virtual bool Flush(bool hardFlush, int propagation=-1, bool blocking=true);
+		//! mark end of a series of messages
+		/*! There should be a MessageEnd immediately before MessageSeriesEnd. */
+		virtual bool MessageSeriesEnd(int propagation=-1, bool blocking=true);
+
+		//! set propagation of automatically generated and transferred signals
+		/*! propagation == 0 means do not automaticly generate signals */
+		virtual void SetAutoSignalPropagation(int propagation) {}
+
+		//!
+		virtual int GetAutoSignalPropagation() const {return 0;}
+public:
+
+#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
+		void Close() {MessageEnd();}
+#endif
+	//@}
+
+	//!	\name RETRIEVAL OF ONE MESSAGE
+	//@{
+		//! returns number of bytes that is currently ready for retrieval
+		/*! All retrieval functions return the actual number of bytes
+			retrieved, which is the lesser of the request number and
+			MaxRetrievable(). */
+		virtual lword MaxRetrievable() const;
+
+		//! returns whether any bytes are currently ready for retrieval
+		virtual bool AnyRetrievable() const;
+
+		//! try to retrieve a single byte
+		virtual size_t Get(byte &outByte);
+		//! try to retrieve multiple bytes
+		virtual size_t Get(byte *outString, size_t getMax);
+
+		//! peek at the next byte without removing it from the output buffer
+		virtual size_t Peek(byte &outByte) const;
+		//! peek at multiple bytes without removing them from the output buffer
+		virtual size_t Peek(byte *outString, size_t peekMax) const;
+
+		//! try to retrieve a 16-bit word
+		size_t GetWord16(word16 &value, ByteOrder order=BIG_ENDIAN_ORDER);
+		//! try to retrieve a 32-bit word
+		size_t GetWord32(word32 &value, ByteOrder order=BIG_ENDIAN_ORDER);
+
+		//! try to peek at a 16-bit word
+		size_t PeekWord16(word16 &value, ByteOrder order=BIG_ENDIAN_ORDER) const;
+		//! try to peek at a 32-bit word
+		size_t PeekWord32(word32 &value, ByteOrder order=BIG_ENDIAN_ORDER) const;
+
+		//! move transferMax bytes of the buffered output to target as input
+		lword TransferTo(BufferedTransformation &target, lword transferMax=LWORD_MAX, const std::string &channel=DEFAULT_CHANNEL)
+			{TransferTo2(target, transferMax, channel); return transferMax;}
+
+		//! discard skipMax bytes from the output buffer
+		virtual lword Skip(lword skipMax=LWORD_MAX);
+
+		//! copy copyMax bytes of the buffered output to target as input
+		lword CopyTo(BufferedTransformation &target, lword copyMax=LWORD_MAX, const std::string &channel=DEFAULT_CHANNEL) const
+			{return CopyRangeTo(target, 0, copyMax, channel);}
+
+		//! copy copyMax bytes of the buffered output, starting at position (relative to current position), to target as input
+		lword CopyRangeTo(BufferedTransformation &target, lword position, lword copyMax=LWORD_MAX, const std::string &channel=DEFAULT_CHANNEL) const
+			{lword i = position; CopyRangeTo2(target, i, i+copyMax, channel); return i-position;}
+
+#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
+		unsigned long MaxRetrieveable() const {return MaxRetrievable();}
+#endif
+	//@}
+
+	//!	\name RETRIEVAL OF MULTIPLE MESSAGES
+	//@{
+		//!
+		virtual lword TotalBytesRetrievable() const;
+		//! number of times MessageEnd() has been received minus messages retrieved or skipped
+		virtual unsigned int NumberOfMessages() const;
+		//! returns true if NumberOfMessages() > 0
+		virtual bool AnyMessages() const;
+		//! start retrieving the next message
+		/*!
+			Returns false if no more messages exist or this message 
+			is not completely retrieved.
+		*/
+		virtual bool GetNextMessage();
+		//! skip count number of messages
+		virtual unsigned int SkipMessages(unsigned int count=UINT_MAX);
+		//!
+		unsigned int TransferMessagesTo(BufferedTransformation &target, unsigned int count=UINT_MAX, const std::string &channel=DEFAULT_CHANNEL)
+			{TransferMessagesTo2(target, count, channel); return count;}
+		//!
+		unsigned int CopyMessagesTo(BufferedTransformation &target, unsigned int count=UINT_MAX, const std::string &channel=DEFAULT_CHANNEL) const;
+
+		//!
+		virtual void SkipAll();
+		//!
+		void TransferAllTo(BufferedTransformation &target, const std::string &channel=DEFAULT_CHANNEL)
+			{TransferAllTo2(target, channel);}
+		//!
+		void CopyAllTo(BufferedTransformation &target, const std::string &channel=DEFAULT_CHANNEL) const;
+
+		virtual bool GetNextMessageSeries() {return false;}
+		virtual unsigned int NumberOfMessagesInThisSeries() const {return NumberOfMessages();}
+		virtual unsigned int NumberOfMessageSeries() const {return 0;}
+	//@}
+
+	//!	\name NON-BLOCKING TRANSFER OF OUTPUT
+	//@{
+		//! upon return, byteCount contains number of bytes that have finished being transfered, and returns the number of bytes left in the current transfer block
+		virtual size_t TransferTo2(BufferedTransformation &target, lword &byteCount, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true) =0;
+		//! upon return, begin contains the start position of data yet to be finished copying, and returns the number of bytes left in the current transfer block
+		virtual size_t CopyRangeTo2(BufferedTransformation &target, lword &begin, lword end=LWORD_MAX, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true) const =0;
+		//! upon return, messageCount contains number of messages that have finished being transfered, and returns the number of bytes left in the current transfer block
+		size_t TransferMessagesTo2(BufferedTransformation &target, unsigned int &messageCount, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true);
+		//! returns the number of bytes left in the current transfer block
+		size_t TransferAllTo2(BufferedTransformation &target, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true);
+	//@}
+
+	//!	\name CHANNELS
+	//@{
+		struct NoChannelSupport : public NotImplemented
+			{NoChannelSupport(const std::string &name) : NotImplemented(name + ": this object doesn't support multiple channels") {}};
+		struct InvalidChannelName : public InvalidArgument
+			{InvalidChannelName(const std::string &name, const std::string &channel) : InvalidArgument(name + ": unexpected channel name \"" + channel + "\"") {}};
+
+		size_t ChannelPut(const std::string &channel, byte inByte, bool blocking=true)
+			{return ChannelPut(channel, &inByte, 1, blocking);}
+		size_t ChannelPut(const std::string &channel, const byte *inString, size_t length, bool blocking=true)
+			{return ChannelPut2(channel, inString, length, 0, blocking);}
+
+		size_t ChannelPutModifiable(const std::string &channel, byte *inString, size_t length, bool blocking=true)
+			{return ChannelPutModifiable2(channel, inString, length, 0, blocking);}
+
+		size_t ChannelPutWord16(const std::string &channel, word16 value, ByteOrder order=BIG_ENDIAN_ORDER, bool blocking=true);
+		size_t ChannelPutWord32(const std::string &channel, word32 value, ByteOrder order=BIG_ENDIAN_ORDER, bool blocking=true);
+
+		bool ChannelMessageEnd(const std::string &channel, int propagation=-1, bool blocking=true)
+			{return !!ChannelPut2(channel, NULL, 0, propagation < 0 ? -1 : propagation+1, blocking);}
+		size_t ChannelPutMessageEnd(const std::string &channel, const byte *inString, size_t length, int propagation=-1, bool blocking=true)
+			{return ChannelPut2(channel, inString, length, propagation < 0 ? -1 : propagation+1, blocking);}
+
+		virtual byte * ChannelCreatePutSpace(const std::string &channel, size_t &size);
+
+		virtual size_t ChannelPut2(const std::string &channel, const byte *begin, size_t length, int messageEnd, bool blocking);
+		virtual size_t ChannelPutModifiable2(const std::string &channel, byte *begin, size_t length, int messageEnd, bool blocking);
+
+		virtual bool ChannelFlush(const std::string &channel, bool hardFlush, int propagation=-1, bool blocking=true);
+		virtual bool ChannelMessageSeriesEnd(const std::string &channel, int propagation=-1, bool blocking=true);
+
+		virtual void SetRetrievalChannel(const std::string &channel);
+	//@}
+
+	//!	\name ATTACHMENT
+	/*! Some BufferedTransformation objects (e.g. Filter objects)
+		allow other BufferedTransformation objects to be attached. When
+		this is done, the first object instead of buffering its output,
+		sents that output to the attached object as input. The entire
+		attachment chain is deleted when the anchor object is destructed.
+	*/
+	//@{
+		//! returns whether this object allows attachment
+		virtual bool Attachable() {return false;}
+		//! returns the object immediately attached to this object or NULL for no attachment
+		virtual BufferedTransformation *AttachedTransformation() {assert(!Attachable()); return 0;}
+		//!
+		virtual const BufferedTransformation *AttachedTransformation() const
+			{return const_cast<BufferedTransformation *>(this)->AttachedTransformation();}
+		//! delete the current attachment chain and replace it with newAttachment
+		virtual void Detach(BufferedTransformation *newAttachment = 0)
+			{assert(!Attachable()); throw NotImplemented("BufferedTransformation: this object is not attachable");}
+		//! add newAttachment to the end of attachment chain
+		virtual void Attach(BufferedTransformation *newAttachment);
+	//@}
+
+protected:
+	static int DecrementPropagation(int propagation)
+		{return propagation != 0 ? propagation - 1 : 0;}
+
+private:
+	byte m_buf[4];	// for ChannelPutWord16 and ChannelPutWord32, to ensure buffer isn't deallocated before non-blocking operation completes
+};
+
+//! returns a reference to a BufferedTransformation object that discards all input
+BufferedTransformation & TheBitBucket();
+
+//! interface for crypto material, such as public and private keys, and crypto parameters
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE CryptoMaterial : public NameValuePairs
+{
+public:
+	//! exception thrown when invalid crypto material is detected
+	class CRYPTOPP_DLL InvalidMaterial : public InvalidDataFormat
+	{
+	public:
+		explicit InvalidMaterial(const std::string &s) : InvalidDataFormat(s) {}
+	};
+
+	//! assign values from source to this object
+	/*! \note This function can be used to create a public key from a private key. */
+	virtual void AssignFrom(const NameValuePairs &source) =0;
+
+	//! check this object for errors
+	/*! \param level denotes the level of thoroughness:
+		0 - using this object won't cause a crash or exception (rng is ignored)
+		1 - this object will probably function (encrypt, sign, etc.) correctly (but may not check for weak keys and such)
+		2 - make sure this object will function correctly, and do reasonable security checks
+		3 - do checks that may take a long time
+		\return true if the tests pass */
+	virtual bool Validate(RandomNumberGenerator &rng, unsigned int level) const =0;
+
+	//! throws InvalidMaterial if this object fails Validate() test
+	virtual void ThrowIfInvalid(RandomNumberGenerator &rng, unsigned int level) const
+		{if (!Validate(rng, level)) throw InvalidMaterial("CryptoMaterial: this object contains invalid values");}
+
+//	virtual std::vector<std::string> GetSupportedFormats(bool includeSaveOnly=false, bool includeLoadOnly=false);
+
+	//! save key into a BufferedTransformation
+	virtual void Save(BufferedTransformation &bt) const
+		{throw NotImplemented("CryptoMaterial: this object does not support saving");}
+
+	//! load key from a BufferedTransformation
+	/*! \throws KeyingErr if decode fails
+		\note Generally does not check that the key is valid.
+			Call ValidateKey() or ThrowIfInvalidKey() to check that. */
+	virtual void Load(BufferedTransformation &bt)
+		{throw NotImplemented("CryptoMaterial: this object does not support loading");}
+
+	//! \return whether this object supports precomputation
+	virtual bool SupportsPrecomputation() const {return false;}
+	//! do precomputation
+	/*! The exact semantics of Precompute() is varies, but
+		typically it means calculate a table of n objects
+		that can be used later to speed up computation. */
+	virtual void Precompute(unsigned int n)
+		{assert(!SupportsPrecomputation()); throw NotImplemented("CryptoMaterial: this object does not support precomputation");}
+	//! retrieve previously saved precomputation
+	virtual void LoadPrecomputation(BufferedTransformation &storedPrecomputation)
+		{assert(!SupportsPrecomputation()); throw NotImplemented("CryptoMaterial: this object does not support precomputation");}
+	//! save precomputation for later use
+	virtual void SavePrecomputation(BufferedTransformation &storedPrecomputation) const
+		{assert(!SupportsPrecomputation()); throw NotImplemented("CryptoMaterial: this object does not support precomputation");}
+
+	// for internal library use
+	void DoQuickSanityCheck() const	{ThrowIfInvalid(NullRNG(), 0);}
+
+#if (defined(__SUNPRO_CC) && __SUNPRO_CC < 0x590)
+	// Sun Studio 11/CC 5.8 workaround: it generates incorrect code when casting to an empty virtual base class
+	char m_sunCCworkaround;
+#endif
+};
+
+//! interface for generatable crypto material, such as private keys and crypto parameters
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE GeneratableCryptoMaterial : virtual public CryptoMaterial
+{
+public:
+	//! generate a random key or crypto parameters
+	/*! \throws KeyingErr if algorithm parameters are invalid, or if a key can't be generated
+		(e.g., if this is a public key object) */
+	virtual void GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &params = g_nullNameValuePairs)
+		{throw NotImplemented("GeneratableCryptoMaterial: this object does not support key/parameter generation");}
+
+	//! calls the above function with a NameValuePairs object that just specifies "KeySize"
+	void GenerateRandomWithKeySize(RandomNumberGenerator &rng, unsigned int keySize);
+};
+
+//! interface for public keys
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PublicKey : virtual public CryptoMaterial
+{
+};
+
+//! interface for private keys
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PrivateKey : public GeneratableCryptoMaterial
+{
+};
+
+//! interface for crypto prameters
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE CryptoParameters : public GeneratableCryptoMaterial
+{
+};
+
+//! interface for asymmetric algorithms
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE AsymmetricAlgorithm : public Algorithm
+{
+public:
+	//! returns a reference to the crypto material used by this object
+	virtual CryptoMaterial & AccessMaterial() =0;
+	//! returns a const reference to the crypto material used by this object
+	virtual const CryptoMaterial & GetMaterial() const =0;
+
+	//! for backwards compatibility, calls AccessMaterial().Load(bt)
+	void BERDecode(BufferedTransformation &bt)
+		{AccessMaterial().Load(bt);}
+	//! for backwards compatibility, calls GetMaterial().Save(bt)
+	void DEREncode(BufferedTransformation &bt) const
+		{GetMaterial().Save(bt);}
+};
+
+//! interface for asymmetric algorithms using public keys
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PublicKeyAlgorithm : public AsymmetricAlgorithm
+{
+public:
+	// VC60 workaround: no co-variant return type
+	CryptoMaterial & AccessMaterial() {return AccessPublicKey();}
+	const CryptoMaterial & GetMaterial() const {return GetPublicKey();}
+
+	virtual PublicKey & AccessPublicKey() =0;
+	virtual const PublicKey & GetPublicKey() const {return const_cast<PublicKeyAlgorithm *>(this)->AccessPublicKey();}
+};
+
+//! interface for asymmetric algorithms using private keys
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PrivateKeyAlgorithm : public AsymmetricAlgorithm
+{
+public:
+	CryptoMaterial & AccessMaterial() {return AccessPrivateKey();}
+	const CryptoMaterial & GetMaterial() const {return GetPrivateKey();}
+
+	virtual PrivateKey & AccessPrivateKey() =0;
+	virtual const PrivateKey & GetPrivateKey() const {return const_cast<PrivateKeyAlgorithm *>(this)->AccessPrivateKey();}
+};
+
+//! interface for key agreement algorithms
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE KeyAgreementAlgorithm : public AsymmetricAlgorithm
+{
+public:
+	CryptoMaterial & AccessMaterial() {return AccessCryptoParameters();}
+	const CryptoMaterial & GetMaterial() const {return GetCryptoParameters();}
+
+	virtual CryptoParameters & AccessCryptoParameters() =0;
+	virtual const CryptoParameters & GetCryptoParameters() const {return const_cast<KeyAgreementAlgorithm *>(this)->AccessCryptoParameters();}
+};
+
+//! interface for public-key encryptors and decryptors
+
+/*! This class provides an interface common to encryptors and decryptors
+	for querying their plaintext and ciphertext lengths.
+*/
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PK_CryptoSystem
+{
+public:
+	virtual ~PK_CryptoSystem() {}
+
+	//! maximum length of plaintext for a given ciphertext length
+	/*! \note This function returns 0 if ciphertextLength is not valid (too long or too short). */
+	virtual size_t MaxPlaintextLength(size_t ciphertextLength) const =0;
+
+	//! calculate length of ciphertext given length of plaintext
+	/*! \note This function returns 0 if plaintextLength is not valid (too long). */
+	virtual size_t CiphertextLength(size_t plaintextLength) const =0;
+
+	//! this object supports the use of the parameter with the given name
+	/*! some possible parameter names: EncodingParameters, KeyDerivationParameters */
+	virtual bool ParameterSupported(const char *name) const =0;
+
+	//! return fixed ciphertext length, if one exists, otherwise return 0
+	/*! \note "Fixed" here means length of ciphertext does not depend on length of plaintext.
+		It usually does depend on the key length. */
+	virtual size_t FixedCiphertextLength() const {return 0;}
+
+	//! return maximum plaintext length given the fixed ciphertext length, if one exists, otherwise return 0
+	virtual size_t FixedMaxPlaintextLength() const {return 0;}
+
+#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
+	size_t MaxPlainTextLength(size_t cipherTextLength) const {return MaxPlaintextLength(cipherTextLength);}
+	size_t CipherTextLength(size_t plainTextLength) const {return CiphertextLength(plainTextLength);}
+#endif
+};
+
+//! interface for public-key encryptors
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PK_Encryptor : public PK_CryptoSystem, public PublicKeyAlgorithm
+{
+public:
+	//! exception thrown when trying to encrypt plaintext of invalid length
+	class CRYPTOPP_DLL InvalidPlaintextLength : public Exception
+	{
+	public:
+		InvalidPlaintextLength() : Exception(OTHER_ERROR, "PK_Encryptor: invalid plaintext length") {}
+	};
+
+	//! encrypt a byte string
+	/*! \pre CiphertextLength(plaintextLength) != 0 (i.e., plaintext isn't too long)
+		\pre size of ciphertext == CiphertextLength(plaintextLength)
+	*/
+	virtual void Encrypt(RandomNumberGenerator &rng, 
+		const byte *plaintext, size_t plaintextLength, 
+		byte *ciphertext, const NameValuePairs &parameters = g_nullNameValuePairs) const =0;
+
+	//! create a new encryption filter
+	/*! \note The caller is responsible for deleting the returned pointer.
+		\note Encoding parameters should be passed in the "EP" channel.
+	*/
+	virtual BufferedTransformation * CreateEncryptionFilter(RandomNumberGenerator &rng, 
+		BufferedTransformation *attachment=NULL, const NameValuePairs &parameters = g_nullNameValuePairs) const;
+};
+
+//! interface for public-key decryptors
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PK_Decryptor : public PK_CryptoSystem, public PrivateKeyAlgorithm
+{
+public:
+	//! decrypt a byte string, and return the length of plaintext
+	/*! \pre size of plaintext == MaxPlaintextLength(ciphertextLength) bytes.
+		\return the actual length of the plaintext, indication that decryption failed.
+	*/
+	virtual DecodingResult Decrypt(RandomNumberGenerator &rng, 
+		const byte *ciphertext, size_t ciphertextLength, 
+		byte *plaintext, const NameValuePairs &parameters = g_nullNameValuePairs) const =0;
+
+	//! create a new decryption filter
+	/*! \note caller is responsible for deleting the returned pointer
+	*/
+	virtual BufferedTransformation * CreateDecryptionFilter(RandomNumberGenerator &rng, 
+		BufferedTransformation *attachment=NULL, const NameValuePairs &parameters = g_nullNameValuePairs) const;
+
+	//! decrypt a fixed size ciphertext
+	DecodingResult FixedLengthDecrypt(RandomNumberGenerator &rng, const byte *ciphertext, byte *plaintext, const NameValuePairs &parameters = g_nullNameValuePairs) const
+		{return Decrypt(rng, ciphertext, FixedCiphertextLength(), plaintext, parameters);}
+};
+
+#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
+typedef PK_CryptoSystem PK_FixedLengthCryptoSystem;
+typedef PK_Encryptor PK_FixedLengthEncryptor;
+typedef PK_Decryptor PK_FixedLengthDecryptor;
+#endif
+
+//! interface for public-key signers and verifiers
+
+/*! This class provides an interface common to signers and verifiers
+	for querying scheme properties.
+*/
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PK_SignatureScheme
+{
+public:
+	//! invalid key exception, may be thrown by any function in this class if the private or public key has a length that can't be used
+	class CRYPTOPP_DLL InvalidKeyLength : public Exception
+	{
+	public:
+		InvalidKeyLength(const std::string &message) : Exception(OTHER_ERROR, message) {}
+	};
+
+	//! key too short exception, may be thrown by any function in this class if the private or public key is too short to sign or verify anything
+	class CRYPTOPP_DLL KeyTooShort : public InvalidKeyLength
+	{
+	public:
+		KeyTooShort() : InvalidKeyLength("PK_Signer: key too short for this signature scheme") {}
+	};
+
+	virtual ~PK_SignatureScheme() {}
+
+	//! signature length if it only depends on the key, otherwise 0
+	virtual size_t SignatureLength() const =0;
+
+	//! maximum signature length produced for a given length of recoverable message part
+	virtual size_t MaxSignatureLength(size_t recoverablePartLength = 0) const {return SignatureLength();}
+
+	//! length of longest message that can be recovered, or 0 if this signature scheme does not support message recovery
+	virtual size_t MaxRecoverableLength() const =0;
+
+	//! length of longest message that can be recovered from a signature of given length, or 0 if this signature scheme does not support message recovery
+	virtual size_t MaxRecoverableLengthFromSignatureLength(size_t signatureLength) const =0;
+
+	//! requires a random number generator to sign
+	/*! if this returns false, NullRNG() can be passed to functions that take RandomNumberGenerator & */
+	virtual bool IsProbabilistic() const =0;
+
+	//! whether or not a non-recoverable message part can be signed
+	virtual bool AllowNonrecoverablePart() const =0;
+
+	//! if this function returns true, during verification you must input the signature before the message, otherwise you can input it at anytime */
+	virtual bool SignatureUpfront() const {return false;}
+
+	//! whether you must input the recoverable part before the non-recoverable part during signing
+	virtual bool RecoverablePartFirst() const =0;
+};
+
+//! interface for accumulating messages to be signed or verified
+/*! Only Update() should be called
+	on this class. No other functions inherited from HashTransformation should be called.
+*/
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PK_MessageAccumulator : public HashTransformation
+{
+public:
+	//! should not be called on PK_MessageAccumulator
+	unsigned int DigestSize() const
+		{throw NotImplemented("PK_MessageAccumulator: DigestSize() should not be called");}
+	//! should not be called on PK_MessageAccumulator
+	void TruncatedFinal(byte *digest, size_t digestSize) 
+		{throw NotImplemented("PK_MessageAccumulator: TruncatedFinal() should not be called");}
+};
+
+//! interface for public-key signers
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PK_Signer : public PK_SignatureScheme, public PrivateKeyAlgorithm
+{
+public:
+	//! create a new HashTransformation to accumulate the message to be signed
+	virtual PK_MessageAccumulator * NewSignatureAccumulator(RandomNumberGenerator &rng) const =0;
+
+	virtual void InputRecoverableMessage(PK_MessageAccumulator &messageAccumulator, const byte *recoverableMessage, size_t recoverableMessageLength) const =0;
+
+	//! sign and delete messageAccumulator (even in case of exception thrown)
+	/*! \pre size of signature == MaxSignatureLength()
+		\return actual signature length
+	*/
+	virtual size_t Sign(RandomNumberGenerator &rng, PK_MessageAccumulator *messageAccumulator, byte *signature) const;
+
+	//! sign and restart messageAccumulator
+	/*! \pre size of signature == MaxSignatureLength()
+		\return actual signature length
+	*/
+	virtual size_t SignAndRestart(RandomNumberGenerator &rng, PK_MessageAccumulator &messageAccumulator, byte *signature, bool restart=true) const =0;
+
+	//! sign a message
+	/*! \pre size of signature == MaxSignatureLength()
+		\return actual signature length
+	*/
+	virtual size_t SignMessage(RandomNumberGenerator &rng, const byte *message, size_t messageLen, byte *signature) const;
+
+	//! sign a recoverable message
+	/*! \pre size of signature == MaxSignatureLength(recoverableMessageLength)
+		\return actual signature length
+	*/
+	virtual size_t SignMessageWithRecovery(RandomNumberGenerator &rng, const byte *recoverableMessage, size_t recoverableMessageLength, 
+		const byte *nonrecoverableMessage, size_t nonrecoverableMessageLength, byte *signature) const;
+};
+
+//! interface for public-key signature verifiers
+/*! The Recover* functions throw NotImplemented if the signature scheme does not support
+	message recovery.
+	The Verify* functions throw InvalidDataFormat if the scheme does support message
+	recovery and the signature contains a non-empty recoverable message part. The
+	Recovery* functions should be used in that case.
+*/
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PK_Verifier : public PK_SignatureScheme, public PublicKeyAlgorithm
+{
+public:
+	//! create a new HashTransformation to accumulate the message to be verified
+	virtual PK_MessageAccumulator * NewVerificationAccumulator() const =0;
+
+	//! input signature into a message accumulator
+	virtual void InputSignature(PK_MessageAccumulator &messageAccumulator, const byte *signature, size_t signatureLength) const =0;
+
+	//! check whether messageAccumulator contains a valid signature and message, and delete messageAccumulator (even in case of exception thrown)
+	virtual bool Verify(PK_MessageAccumulator *messageAccumulator) const;
+
+	//! check whether messageAccumulator contains a valid signature and message, and restart messageAccumulator
+	virtual bool VerifyAndRestart(PK_MessageAccumulator &messageAccumulator) const =0;
+
+	//! check whether input signature is a valid signature for input message
+	virtual bool VerifyMessage(const byte *message, size_t messageLen, 
+		const byte *signature, size_t signatureLength) const;
+
+	//! recover a message from its signature
+	/*! \pre size of recoveredMessage == MaxRecoverableLengthFromSignatureLength(signatureLength)
+	*/
+	virtual DecodingResult Recover(byte *recoveredMessage, PK_MessageAccumulator *messageAccumulator) const;
+
+	//! recover a message from its signature
+	/*! \pre size of recoveredMessage == MaxRecoverableLengthFromSignatureLength(signatureLength)
+	*/
+	virtual DecodingResult RecoverAndRestart(byte *recoveredMessage, PK_MessageAccumulator &messageAccumulator) const =0;
+
+	//! recover a message from its signature
+	/*! \pre size of recoveredMessage == MaxRecoverableLengthFromSignatureLength(signatureLength)
+	*/
+	virtual DecodingResult RecoverMessage(byte *recoveredMessage, 
+		const byte *nonrecoverableMessage, size_t nonrecoverableMessageLength, 
+		const byte *signature, size_t signatureLength) const;
+};
+
+//! interface for domains of simple key agreement protocols
+
+/*! A key agreement domain is a set of parameters that must be shared
+	by two parties in a key agreement protocol, along with the algorithms
+	for generating key pairs and deriving agreed values.
+*/
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE SimpleKeyAgreementDomain : public KeyAgreementAlgorithm
+{
+public:
+	//! return length of agreed value produced
+	virtual unsigned int AgreedValueLength() const =0;
+	//! return length of private keys in this domain
+	virtual unsigned int PrivateKeyLength() const =0;
+	//! return length of public keys in this domain
+	virtual unsigned int PublicKeyLength() const =0;
+	//! generate private key
+	/*! \pre size of privateKey == PrivateKeyLength() */
+	virtual void GeneratePrivateKey(RandomNumberGenerator &rng, byte *privateKey) const =0;
+	//! generate public key
+	/*!	\pre size of publicKey == PublicKeyLength() */
+	virtual void GeneratePublicKey(RandomNumberGenerator &rng, const byte *privateKey, byte *publicKey) const =0;
+	//! generate private/public key pair
+	/*! \note equivalent to calling GeneratePrivateKey() and then GeneratePublicKey() */
+	virtual void GenerateKeyPair(RandomNumberGenerator &rng, byte *privateKey, byte *publicKey) const;
+	//! derive agreed value from your private key and couterparty's public key, return false in case of failure
+	/*! \note If you have previously validated the public key, use validateOtherPublicKey=false to save time.
+		\pre size of agreedValue == AgreedValueLength()
+		\pre length of privateKey == PrivateKeyLength()
+		\pre length of otherPublicKey == PublicKeyLength()
+	*/
+	virtual bool Agree(byte *agreedValue, const byte *privateKey, const byte *otherPublicKey, bool validateOtherPublicKey=true) const =0;
+
+#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
+	bool ValidateDomainParameters(RandomNumberGenerator &rng) const
+		{return GetCryptoParameters().Validate(rng, 2);}
+#endif
+};
+
+//! interface for domains of authenticated key agreement protocols
+
+/*! In an authenticated key agreement protocol, each party has two
+	key pairs. The long-lived key pair is called the static key pair,
+	and the short-lived key pair is called the ephemeral key pair.
+*/
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE AuthenticatedKeyAgreementDomain : public KeyAgreementAlgorithm
+{
+public:
+	//! return length of agreed value produced
+	virtual unsigned int AgreedValueLength() const =0;
+
+	//! return length of static private keys in this domain
+	virtual unsigned int StaticPrivateKeyLength() const =0;
+	//! return length of static public keys in this domain
+	virtual unsigned int StaticPublicKeyLength() const =0;
+	//! generate static private key
+	/*! \pre size of privateKey == PrivateStaticKeyLength() */
+	virtual void GenerateStaticPrivateKey(RandomNumberGenerator &rng, byte *privateKey) const =0;
+	//! generate static public key
+	/*!	\pre size of publicKey == PublicStaticKeyLength() */
+	virtual void GenerateStaticPublicKey(RandomNumberGenerator &rng, const byte *privateKey, byte *publicKey) const =0;
+	//! generate private/public key pair
+	/*! \note equivalent to calling GenerateStaticPrivateKey() and then GenerateStaticPublicKey() */
+	virtual void GenerateStaticKeyPair(RandomNumberGenerator &rng, byte *privateKey, byte *publicKey) const;
+
+	//! return length of ephemeral private keys in this domain
+	virtual unsigned int EphemeralPrivateKeyLength() const =0;
+	//! return length of ephemeral public keys in this domain
+	virtual unsigned int EphemeralPublicKeyLength() const =0;
+	//! generate ephemeral private key
+	/*! \pre size of privateKey == PrivateEphemeralKeyLength() */
+	virtual void GenerateEphemeralPrivateKey(RandomNumberGenerator &rng, byte *privateKey) const =0;
+	//! generate ephemeral public key
+	/*!	\pre size of publicKey == PublicEphemeralKeyLength() */
+	virtual void GenerateEphemeralPublicKey(RandomNumberGenerator &rng, const byte *privateKey, byte *publicKey) const =0;
+	//! generate private/public key pair
+	/*! \note equivalent to calling GenerateEphemeralPrivateKey() and then GenerateEphemeralPublicKey() */
+	virtual void GenerateEphemeralKeyPair(RandomNumberGenerator &rng, byte *privateKey, byte *publicKey) const;
+
+	//! derive agreed value from your private keys and couterparty's public keys, return false in case of failure
+	/*! \note The ephemeral public key will always be validated.
+		      If you have previously validated the static public key, use validateStaticOtherPublicKey=false to save time.
+		\pre size of agreedValue == AgreedValueLength()
+		\pre length of staticPrivateKey == StaticPrivateKeyLength()
+		\pre length of ephemeralPrivateKey == EphemeralPrivateKeyLength()
+		\pre length of staticOtherPublicKey == StaticPublicKeyLength()
+		\pre length of ephemeralOtherPublicKey == EphemeralPublicKeyLength()
+	*/
+	virtual bool Agree(byte *agreedValue,
+		const byte *staticPrivateKey, const byte *ephemeralPrivateKey,
+		const byte *staticOtherPublicKey, const byte *ephemeralOtherPublicKey,
+		bool validateStaticOtherPublicKey=true) const =0;
+
+#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
+	bool ValidateDomainParameters(RandomNumberGenerator &rng) const
+		{return GetCryptoParameters().Validate(rng, 2);}
+#endif
+};
+
+// interface for password authenticated key agreement protocols, not implemented yet
+#if 0
+//! interface for protocol sessions
+/*! The methods should be called in the following order:
+
+	InitializeSession(rng, parameters);	// or call initialize method in derived class
+	while (true)
+	{
+		if (OutgoingMessageAvailable())
+		{
+			length = GetOutgoingMessageLength();
+			GetOutgoingMessage(message);
+			; // send outgoing message
+		}
+
+		if (LastMessageProcessed())
+			break;
+
+		; // receive incoming message
+		ProcessIncomingMessage(message);
+	}
+	; // call methods in derived class to obtain result of protocol session
+*/
+class ProtocolSession
+{
+public:
+	//! exception thrown when an invalid protocol message is processed
+	class ProtocolError : public Exception
+	{
+	public:
+		ProtocolError(ErrorType errorType, const std::string &s) : Exception(errorType, s) {}
+	};
+
+	//! exception thrown when a function is called unexpectedly
+	/*! for example calling ProcessIncomingMessage() when ProcessedLastMessage() == true */
+	class UnexpectedMethodCall : public Exception
+	{
+	public:
+		UnexpectedMethodCall(const std::string &s) : Exception(OTHER_ERROR, s) {}
+	};
+
+	ProtocolSession() : m_rng(NULL), m_throwOnProtocolError(true), m_validState(false) {}
+	virtual ~ProtocolSession() {}
+
+	virtual void InitializeSession(RandomNumberGenerator &rng, const NameValuePairs &parameters) =0;
+
+	bool GetThrowOnProtocolError() const {return m_throwOnProtocolError;}
+	void SetThrowOnProtocolError(bool throwOnProtocolError) {m_throwOnProtocolError = throwOnProtocolError;}
+
+	bool HasValidState() const {return m_validState;}
+
+	virtual bool OutgoingMessageAvailable() const =0;
+	virtual unsigned int GetOutgoingMessageLength() const =0;
+	virtual void GetOutgoingMessage(byte *message) =0;
+
+	virtual bool LastMessageProcessed() const =0;
+	virtual void ProcessIncomingMessage(const byte *message, unsigned int messageLength) =0;
+
+protected:
+	void HandleProtocolError(Exception::ErrorType errorType, const std::string &s) const;
+	void CheckAndHandleInvalidState() const;
+	void SetValidState(bool valid) {m_validState = valid;}
+
+	RandomNumberGenerator *m_rng;
+
+private:
+	bool m_throwOnProtocolError, m_validState;
+};
+
+class KeyAgreementSession : public ProtocolSession
+{
+public:
+	virtual unsigned int GetAgreedValueLength() const =0;
+	virtual void GetAgreedValue(byte *agreedValue) const =0;
+};
+
+class PasswordAuthenticatedKeyAgreementSession : public KeyAgreementSession
+{
+public:
+	void InitializePasswordAuthenticatedKeyAgreementSession(RandomNumberGenerator &rng, 
+		const byte *myId, unsigned int myIdLength, 
+		const byte *counterPartyId, unsigned int counterPartyIdLength, 
+		const byte *passwordOrVerifier, unsigned int passwordOrVerifierLength);
+};
+
+class PasswordAuthenticatedKeyAgreementDomain : public KeyAgreementAlgorithm
+{
+public:
+	//! return whether the domain parameters stored in this object are valid
+	virtual bool ValidateDomainParameters(RandomNumberGenerator &rng) const
+		{return GetCryptoParameters().Validate(rng, 2);}
+
+	virtual unsigned int GetPasswordVerifierLength(const byte *password, unsigned int passwordLength) const =0;
+	virtual void GeneratePasswordVerifier(RandomNumberGenerator &rng, const byte *userId, unsigned int userIdLength, const byte *password, unsigned int passwordLength, byte *verifier) const =0;
+
+	enum RoleFlags {CLIENT=1, SERVER=2, INITIATOR=4, RESPONDER=8};
+
+	virtual bool IsValidRole(unsigned int role) =0;
+	virtual PasswordAuthenticatedKeyAgreementSession * CreateProtocolSession(unsigned int role) const =0;
+};
+#endif
+
+//! BER Decode Exception Class, may be thrown during an ASN1 BER decode operation
+class CRYPTOPP_DLL BERDecodeErr : public InvalidArgument
+{
+public: 
+	BERDecodeErr() : InvalidArgument("BER decode error") {}
+	BERDecodeErr(const std::string &s) : InvalidArgument(s) {}
+};
+
+//! interface for encoding and decoding ASN1 objects
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE ASN1Object
+{
+public:
+	virtual ~ASN1Object() {}
+	//! decode this object from a BufferedTransformation, using BER (Basic Encoding Rules)
+	virtual void BERDecode(BufferedTransformation &bt) =0;
+	//! encode this object into a BufferedTransformation, using DER (Distinguished Encoding Rules)
+	virtual void DEREncode(BufferedTransformation &bt) const =0;
+	//! encode this object into a BufferedTransformation, using BER
+	/*! this may be useful if DEREncode() would be too inefficient */
+	virtual void BEREncode(BufferedTransformation &bt) const {DEREncode(bt);}
+};
+
+#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
+typedef PK_SignatureScheme PK_SignatureSystem;
+typedef SimpleKeyAgreementDomain PK_SimpleKeyAgreementDomain;
+typedef AuthenticatedKeyAgreementDomain PK_AuthenticatedKeyAgreementDomain;
+#endif
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/default.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/default.h
index e3f34080..fb536415 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/default.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/default.h
@@ -1,105 +1,104 @@
-#ifndef CRYPTOPP_DEFAULT_H
-#define CRYPTOPP_DEFAULT_H
-
-#include "sha.h"
-#include "hmac.h"
-#include "des.h"
-#include "filters.h"
-#include "modes.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-//typedef DES_EDE2 Default_BlockCipher;
-typedef DES_EDE3 Default_BlockCipher;
-typedef SHA DefaultHashModule;
-typedef HMAC<DefaultHashModule> DefaultMAC;
-
-//! Password-Based Encryptor using DES-EDE2
-class DefaultEncryptor : public ProxyFilter
-{
-public:
-	DefaultEncryptor(const char *passphrase, BufferedTransformation *attachment = NULL);
-	DefaultEncryptor(const byte *passphrase, unsigned int passphraseLength, BufferedTransformation *attachment = NULL);
-
-protected:
-	void FirstPut(const byte *);
-	void LastPut(const byte *inString, unsigned int length);
-
-private:
-	SecByteBlock m_passphrase;
-	CBC_Mode<Default_BlockCipher>::Encryption m_cipher;
-};
-
-//! Password-Based Decryptor using DES-EDE2
-class DefaultDecryptor : public ProxyFilter
-{
-public:
-	DefaultDecryptor(const char *passphrase, BufferedTransformation *attachment = NULL, bool throwException=true);
-	DefaultDecryptor(const byte *passphrase, unsigned int passphraseLength, BufferedTransformation *attachment = NULL, bool throwException=true);
-
-	class Err : public Exception
-	{
-	public:
-		Err(const std::string &s) 
-			: Exception(DATA_INTEGRITY_CHECK_FAILED, s) {}
-	};
-	class KeyBadErr : public Err {public: KeyBadErr() : Err("DefaultDecryptor: cannot decrypt message with this passphrase") {}};
-
-	enum State {WAITING_FOR_KEYCHECK, KEY_GOOD, KEY_BAD};
-	State CurrentState() const {return m_state;}
-
-protected:
-	void FirstPut(const byte *inString);
-	void LastPut(const byte *inString, unsigned int length);
-
-	State m_state;
-
-private:
-	void CheckKey(const byte *salt, const byte *keyCheck);
-
-	SecByteBlock m_passphrase;
-	CBC_Mode<Default_BlockCipher>::Decryption m_cipher;
-	member_ptr<FilterWithBufferedInput> m_decryptor;
-	bool m_throwException;
-};
-
-//! Password-Based Encryptor using DES-EDE2 and HMAC/SHA-1
-class DefaultEncryptorWithMAC : public ProxyFilter
-{
-public:
-	DefaultEncryptorWithMAC(const char *passphrase, BufferedTransformation *attachment = NULL);
-	DefaultEncryptorWithMAC(const byte *passphrase, unsigned int passphraseLength, BufferedTransformation *attachment = NULL);
-
-protected:
-	void FirstPut(const byte *inString) {}
-	void LastPut(const byte *inString, unsigned int length);
-
-private:
-	member_ptr<DefaultMAC> m_mac;
-};
-
-//! Password-Based Decryptor using DES-EDE2 and HMAC/SHA-1
-class DefaultDecryptorWithMAC : public ProxyFilter
-{
-public:
-	class MACBadErr : public DefaultDecryptor::Err {public: MACBadErr() : DefaultDecryptor::Err("DefaultDecryptorWithMAC: MAC check failed") {}};
-
-	DefaultDecryptorWithMAC(const char *passphrase, BufferedTransformation *attachment = NULL, bool throwException=true);
-	DefaultDecryptorWithMAC(const byte *passphrase, unsigned int passphraseLength, BufferedTransformation *attachment = NULL, bool throwException=true);
-
-	DefaultDecryptor::State CurrentState() const;
-	bool CheckLastMAC() const;
-
-protected:
-	void FirstPut(const byte *inString) {}
-	void LastPut(const byte *inString, unsigned int length);
-
-private:
-	member_ptr<DefaultMAC> m_mac;
-	HashVerifier *m_hashVerifier;
-	bool m_throwException;
-};
-
-NAMESPACE_END
-
-#endif
+#ifndef CRYPTOPP_DEFAULT_H
+#define CRYPTOPP_DEFAULT_H
+
+#include "sha.h"
+#include "hmac.h"
+#include "des.h"
+#include "filters.h"
+#include "modes.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+typedef DES_EDE2 Default_BlockCipher;
+typedef SHA DefaultHashModule;
+typedef HMAC<DefaultHashModule> DefaultMAC;
+
+//! Password-Based Encryptor using DES-EDE2
+class DefaultEncryptor : public ProxyFilter
+{
+public:
+	DefaultEncryptor(const char *passphrase, BufferedTransformation *attachment = NULL);
+	DefaultEncryptor(const byte *passphrase, size_t passphraseLength, BufferedTransformation *attachment = NULL);
+
+protected:
+	void FirstPut(const byte *);
+	void LastPut(const byte *inString, size_t length);
+
+private:
+	SecByteBlock m_passphrase;
+	CBC_Mode<Default_BlockCipher>::Encryption m_cipher;
+};
+
+//! Password-Based Decryptor using DES-EDE2
+class DefaultDecryptor : public ProxyFilter
+{
+public:
+	DefaultDecryptor(const char *passphrase, BufferedTransformation *attachment = NULL, bool throwException=true);
+	DefaultDecryptor(const byte *passphrase, size_t passphraseLength, BufferedTransformation *attachment = NULL, bool throwException=true);
+
+	class Err : public Exception
+	{
+	public:
+		Err(const std::string &s) 
+			: Exception(DATA_INTEGRITY_CHECK_FAILED, s) {}
+	};
+	class KeyBadErr : public Err {public: KeyBadErr() : Err("DefaultDecryptor: cannot decrypt message with this passphrase") {}};
+
+	enum State {WAITING_FOR_KEYCHECK, KEY_GOOD, KEY_BAD};
+	State CurrentState() const {return m_state;}
+
+protected:
+	void FirstPut(const byte *inString);
+	void LastPut(const byte *inString, size_t length);
+
+	State m_state;
+
+private:
+	void CheckKey(const byte *salt, const byte *keyCheck);
+
+	SecByteBlock m_passphrase;
+	CBC_Mode<Default_BlockCipher>::Decryption m_cipher;
+	member_ptr<FilterWithBufferedInput> m_decryptor;
+	bool m_throwException;
+};
+
+//! Password-Based Encryptor using DES-EDE2 and HMAC/SHA-1
+class DefaultEncryptorWithMAC : public ProxyFilter
+{
+public:
+	DefaultEncryptorWithMAC(const char *passphrase, BufferedTransformation *attachment = NULL);
+	DefaultEncryptorWithMAC(const byte *passphrase, size_t passphraseLength, BufferedTransformation *attachment = NULL);
+
+protected:
+	void FirstPut(const byte *inString) {}
+	void LastPut(const byte *inString, size_t length);
+
+private:
+	member_ptr<DefaultMAC> m_mac;
+};
+
+//! Password-Based Decryptor using DES-EDE2 and HMAC/SHA-1
+class DefaultDecryptorWithMAC : public ProxyFilter
+{
+public:
+	class MACBadErr : public DefaultDecryptor::Err {public: MACBadErr() : DefaultDecryptor::Err("DefaultDecryptorWithMAC: MAC check failed") {}};
+
+	DefaultDecryptorWithMAC(const char *passphrase, BufferedTransformation *attachment = NULL, bool throwException=true);
+	DefaultDecryptorWithMAC(const byte *passphrase, size_t passphraseLength, BufferedTransformation *attachment = NULL, bool throwException=true);
+
+	DefaultDecryptor::State CurrentState() const;
+	bool CheckLastMAC() const;
+
+protected:
+	void FirstPut(const byte *inString) {}
+	void LastPut(const byte *inString, size_t length);
+
+private:
+	member_ptr<DefaultMAC> m_mac;
+	HashVerifier *m_hashVerifier;
+	bool m_throwException;
+};
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/des.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/des.h
index 8f3edf01..62f62882 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/des.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/des.h
@@ -1,133 +1,144 @@
-#ifndef CRYPTOPP_DES_H
-#define CRYPTOPP_DES_H
-
-/** \file
-*/
-
-#include "seckey.h"
-#include "secblock.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-struct DES_Info : public FixedBlockSize<8>, public FixedKeyLength<8>
-{
-	static const char *StaticAlgorithmName() {return "DES";}
-};
-
-/// <a href="http://www.weidai.com/scan-mirror/cs.html#DES">DES</a>
-/*! The DES implementation in Crypto++ ignores the parity bits
-	(the least significant bits of each byte) in the key. However
-	you can use CheckKeyParityBits() and CorrectKeyParityBits() to
-	check or correct the parity bits if you wish. */
-class DES : public DES_Info, public BlockCipherDocumentation
-{
-	class Base : public BlockCipherBaseTemplate<DES_Info>
-	{
-	public:
-		void UncheckedSetKey(CipherDir direction, const byte *userKey, unsigned int length = 8);
-		void ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const;
-
-		// exposed for faster Triple-DES
-		void RawProcessBlock(word32 &l, word32 &r) const;
-
-	protected:
-		static const word32 Spbox[8][64];
-
-		FixedSizeSecBlock<word32, 32> k;
-	};
-
-public:
-	//! check DES key parity bits
-	static bool CheckKeyParityBits(const byte *key);
-	//! correct DES key parity bits
-	static void CorrectKeyParityBits(byte *key);
-
-	typedef BlockCipherTemplate<ENCRYPTION, Base> Encryption;
-	typedef BlockCipherTemplate<DECRYPTION, Base> Decryption;
-};
-
-struct DES_EDE2_Info : public FixedBlockSize<8>, public FixedKeyLength<16>
-{
-	static const char *StaticAlgorithmName() {return "DES-EDE2";}
-};
-
-/// <a href="http://www.weidai.com/scan-mirror/cs.html#DESede">DES-EDE2</a>
-class DES_EDE2 : public DES_EDE2_Info, public BlockCipherDocumentation
-{
-	class Base : public BlockCipherBaseTemplate<DES_EDE2_Info>
-	{
-	public:
-		void UncheckedSetKey(CipherDir direction, const byte *userKey, unsigned int length);
-		void ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const;
-
-	protected:
-		DES::Encryption m_des1, m_des2;
-	};
-
-public:
-	typedef BlockCipherTemplate<ENCRYPTION, Base> Encryption;
-	typedef BlockCipherTemplate<DECRYPTION, Base> Decryption;
-};
-
-struct DES_EDE3_Info : public FixedBlockSize<8>, public FixedKeyLength<24>
-{
-	static const char *StaticAlgorithmName() {return "DES-EDE3";}
-};
-
-/// <a href="http://www.weidai.com/scan-mirror/cs.html#DESede">DES-EDE3</a>
-class DES_EDE3 : public DES_EDE3_Info, public BlockCipherDocumentation
-{
-	class Base : public BlockCipherBaseTemplate<DES_EDE3_Info>
-	{
-	public:
-		void UncheckedSetKey(CipherDir dir, const byte *key, unsigned int length);
-		void ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const;
-
-	protected:
-		DES::Encryption m_des1, m_des2, m_des3;
-	};
-
-public:
-	typedef BlockCipherTemplate<ENCRYPTION, Base> Encryption;
-	typedef BlockCipherTemplate<DECRYPTION, Base> Decryption;
-};
-
-struct DES_XEX3_Info : public FixedBlockSize<8>, public FixedKeyLength<24>
-{
-	static const char *StaticAlgorithmName() {return "DES-XEX3";}
-};
-
-/// <a href="http://www.weidai.com/scan-mirror/cs.html#DESX">DES-XEX3</a>, AKA DESX
-class DES_XEX3 : public DES_XEX3_Info, public BlockCipherDocumentation
-{
-	class Base : public BlockCipherBaseTemplate<DES_XEX3_Info>
-	{
-	public:
-		void UncheckedSetKey(CipherDir dir, const byte *key, unsigned int length);
-		void ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const;
-
-	protected:
-		FixedSizeSecBlock<byte, BLOCKSIZE> m_x1, m_x3;
-		DES::Encryption m_des;
-	};
-
-public:
-	typedef BlockCipherTemplate<ENCRYPTION, Base> Encryption;
-	typedef BlockCipherTemplate<DECRYPTION, Base> Decryption;
-};
-
-typedef DES::Encryption DESEncryption;
-typedef DES::Decryption DESDecryption;
-
-typedef DES_EDE2::Encryption DES_EDE2_Encryption;
-typedef DES_EDE2::Decryption DES_EDE2_Decryption;
-
-typedef DES_EDE3::Encryption DES_EDE3_Encryption;
-typedef DES_EDE3::Decryption DES_EDE3_Decryption;
-
-typedef DES_XEX3::Encryption DES_XEX3_Encryption;
-typedef DES_XEX3::Decryption DES_XEX3_Decryption;
-
-NAMESPACE_END
-
-#endif
+#ifndef CRYPTOPP_DES_H
+#define CRYPTOPP_DES_H
+
+/** \file
+*/
+
+#include "seckey.h"
+#include "secblock.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+class CRYPTOPP_DLL RawDES
+{
+public:
+	void RawSetKey(CipherDir direction, const byte *userKey);
+	void RawProcessBlock(word32 &l, word32 &r) const;
+
+protected:
+	static const word32 Spbox[8][64];
+
+	FixedSizeSecBlock<word32, 32> k;
+};
+
+//! _
+struct DES_Info : public FixedBlockSize<8>, public FixedKeyLength<8>
+{
+	// disable DES in DLL version by not exporting this function
+	static const char * StaticAlgorithmName() {return "DES";}
+};
+
+/// <a href="http://www.weidai.com/scan-mirror/cs.html#DES">DES</a>
+/*! The DES implementation in Crypto++ ignores the parity bits
+	(the least significant bits of each byte) in the key. However
+	you can use CheckKeyParityBits() and CorrectKeyParityBits() to
+	check or correct the parity bits if you wish. */
+class DES : public DES_Info, public BlockCipherDocumentation
+{
+	class CRYPTOPP_NO_VTABLE Base : public BlockCipherImpl<DES_Info>, public RawDES
+	{
+	public:
+		void UncheckedSetKey(const byte *userKey, unsigned int length, const NameValuePairs &params);
+		void ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const;
+	};
+
+public:
+	//! check DES key parity bits
+	static bool CheckKeyParityBits(const byte *key);
+	//! correct DES key parity bits
+	static void CorrectKeyParityBits(byte *key);
+
+	typedef BlockCipherFinal<ENCRYPTION, Base> Encryption;
+	typedef BlockCipherFinal<DECRYPTION, Base> Decryption;
+};
+
+//! _
+struct DES_EDE2_Info : public FixedBlockSize<8>, public FixedKeyLength<16>
+{
+	CRYPTOPP_DLL static const char * CRYPTOPP_API StaticAlgorithmName() {return "DES-EDE2";}
+};
+
+/// <a href="http://www.weidai.com/scan-mirror/cs.html#DESede">DES-EDE2</a>
+class DES_EDE2 : public DES_EDE2_Info, public BlockCipherDocumentation
+{
+	class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE Base : public BlockCipherImpl<DES_EDE2_Info>
+	{
+	public:
+		void UncheckedSetKey(const byte *userKey, unsigned int length, const NameValuePairs &params);
+		void ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const;
+
+	protected:
+		RawDES m_des1, m_des2;
+	};
+
+public:
+	typedef BlockCipherFinal<ENCRYPTION, Base> Encryption;
+	typedef BlockCipherFinal<DECRYPTION, Base> Decryption;
+};
+
+//! _
+struct DES_EDE3_Info : public FixedBlockSize<8>, public FixedKeyLength<24>
+{
+	CRYPTOPP_DLL static const char * CRYPTOPP_API StaticAlgorithmName() {return "DES-EDE3";}
+};
+
+/// <a href="http://www.weidai.com/scan-mirror/cs.html#DESede">DES-EDE3</a>
+class DES_EDE3 : public DES_EDE3_Info, public BlockCipherDocumentation
+{
+	class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE Base : public BlockCipherImpl<DES_EDE3_Info>
+	{
+	public:
+		void UncheckedSetKey(const byte *userKey, unsigned int length, const NameValuePairs &params);
+		void ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const;
+
+	protected:
+		RawDES m_des1, m_des2, m_des3;
+	};
+
+public:
+	typedef BlockCipherFinal<ENCRYPTION, Base> Encryption;
+	typedef BlockCipherFinal<DECRYPTION, Base> Decryption;
+};
+
+//! _
+struct DES_XEX3_Info : public FixedBlockSize<8>, public FixedKeyLength<24>
+{
+	static const char *StaticAlgorithmName() {return "DES-XEX3";}
+};
+
+/// <a href="http://www.weidai.com/scan-mirror/cs.html#DESX">DES-XEX3</a>, AKA DESX
+class DES_XEX3 : public DES_XEX3_Info, public BlockCipherDocumentation
+{
+	class CRYPTOPP_NO_VTABLE Base : public BlockCipherImpl<DES_XEX3_Info>
+	{
+	public:
+		void UncheckedSetKey(const byte *userKey, unsigned int length, const NameValuePairs &params);
+		void ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const;
+
+	protected:
+		FixedSizeSecBlock<byte, BLOCKSIZE> m_x1, m_x3;
+		// VS2005 workaround: calling modules compiled with /clr gets unresolved external symbol DES::Base::ProcessAndXorBlock
+		// if we use DES::Encryption here directly without value_ptr.
+		value_ptr<DES::Encryption> m_des;
+	};
+
+public:
+	typedef BlockCipherFinal<ENCRYPTION, Base> Encryption;
+	typedef BlockCipherFinal<DECRYPTION, Base> Decryption;
+};
+
+typedef DES::Encryption DESEncryption;
+typedef DES::Decryption DESDecryption;
+
+typedef DES_EDE2::Encryption DES_EDE2_Encryption;
+typedef DES_EDE2::Decryption DES_EDE2_Decryption;
+
+typedef DES_EDE3::Encryption DES_EDE3_Encryption;
+typedef DES_EDE3::Decryption DES_EDE3_Decryption;
+
+typedef DES_XEX3::Encryption DES_XEX3_Encryption;
+typedef DES_XEX3::Decryption DES_XEX3_Decryption;
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/eprecomp.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/eprecomp.h
index b92ef3e8..1f325676 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/eprecomp.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/eprecomp.h
@@ -1,69 +1,75 @@
-#ifndef CRYPTOPP_EPRECOMP_H
-#define CRYPTOPP_EPRECOMP_H
-
-#include "integer.h"
-#include "algebra.h"
-#include <vector>
-
-NAMESPACE_BEGIN(CryptoPP)
-
-template <class T>
-class DL_GroupPrecomputation
-{
-public:
-	typedef T Element;
-
-	virtual bool NeedConversions() const {return false;}
-	virtual Element ConvertIn(const Element &v) const {return v;}
-	virtual Element ConvertOut(const Element &v) const {return v;}
-	virtual const AbstractGroup<Element> & GetGroup() const =0;
-	virtual Element BERDecodeElement(BufferedTransformation &bt) const =0;
-	virtual void DEREncodeElement(BufferedTransformation &bt, const Element &P) const =0;
-};
-
-template <class T>
-class DL_FixedBasePrecomputation
-{
-public:
-	typedef T Element;
-
-	virtual bool IsInitialized() const =0;
-	virtual void SetBase(const DL_GroupPrecomputation<Element> &group, const Element &base) =0;
-	virtual const Element & GetBase(const DL_GroupPrecomputation<Element> &group) const =0;
-	virtual void Precompute(const DL_GroupPrecomputation<Element> &group, unsigned int maxExpBits, unsigned int storage) =0;
-	virtual void Load(const DL_GroupPrecomputation<Element> &group, BufferedTransformation &storedPrecomputation) =0;
-	virtual void Save(const DL_GroupPrecomputation<Element> &group, BufferedTransformation &storedPrecomputation) const =0;
-	virtual Element Exponentiate(const DL_GroupPrecomputation<Element> &group, const Integer &exponent) const =0;
-	virtual Element CascadeExponentiate(const DL_GroupPrecomputation<Element> &group, const Integer &exponent, const DL_FixedBasePrecomputation<Element> &pc2, const Integer &exponent2) const =0;
-};
-
-template <class T>
-class DL_FixedBasePrecomputationImpl : public DL_FixedBasePrecomputation<T>
-{
-public:
-	typedef T Element;
-
-	// DL_FixedBasePrecomputation
-	bool IsInitialized() const
-		{return !m_bases.empty();}
-	void SetBase(const DL_GroupPrecomputation<Element> &group, const Element &base);
-	const Element & GetBase(const DL_GroupPrecomputation<Element> &group) const
-		{return group.NeedConversions() ? m_base : m_bases[0];}
-	void Precompute(const DL_GroupPrecomputation<Element> &group, unsigned int maxExpBits, unsigned int storage);
-	void Load(const DL_GroupPrecomputation<Element> &group, BufferedTransformation &storedPrecomputation);
-	void Save(const DL_GroupPrecomputation<Element> &group, BufferedTransformation &storedPrecomputation) const;
-	Element Exponentiate(const DL_GroupPrecomputation<Element> &group, const Integer &exponent) const;
-	Element CascadeExponentiate(const DL_GroupPrecomputation<Element> &group, const Integer &exponent, const DL_FixedBasePrecomputation<Element> &pc2, const Integer &exponent2) const;
-
-private:
-	void PrepareCascade(const DL_GroupPrecomputation<Element> &group, std::vector<BaseAndExponent<Element> > &eb, const Integer &exponent) const;
-
-	Element m_base;
-	unsigned int m_windowSize;
-	Integer m_exponentBase;			// what base to represent the exponent in
-	std::vector<Element> m_bases;	// precalculated bases
-};
-
-NAMESPACE_END
-
-#endif
+#ifndef CRYPTOPP_EPRECOMP_H
+#define CRYPTOPP_EPRECOMP_H
+
+#include "integer.h"
+#include "algebra.h"
+#include <vector>
+
+NAMESPACE_BEGIN(CryptoPP)
+
+template <class T>
+class DL_GroupPrecomputation
+{
+public:
+	typedef T Element;
+
+	virtual bool NeedConversions() const {return false;}
+	virtual Element ConvertIn(const Element &v) const {return v;}
+	virtual Element ConvertOut(const Element &v) const {return v;}
+	virtual const AbstractGroup<Element> & GetGroup() const =0;
+	virtual Element BERDecodeElement(BufferedTransformation &bt) const =0;
+	virtual void DEREncodeElement(BufferedTransformation &bt, const Element &P) const =0;
+};
+
+template <class T>
+class DL_FixedBasePrecomputation
+{
+public:
+	typedef T Element;
+
+	virtual bool IsInitialized() const =0;
+	virtual void SetBase(const DL_GroupPrecomputation<Element> &group, const Element &base) =0;
+	virtual const Element & GetBase(const DL_GroupPrecomputation<Element> &group) const =0;
+	virtual void Precompute(const DL_GroupPrecomputation<Element> &group, unsigned int maxExpBits, unsigned int storage) =0;
+	virtual void Load(const DL_GroupPrecomputation<Element> &group, BufferedTransformation &storedPrecomputation) =0;
+	virtual void Save(const DL_GroupPrecomputation<Element> &group, BufferedTransformation &storedPrecomputation) const =0;
+	virtual Element Exponentiate(const DL_GroupPrecomputation<Element> &group, const Integer &exponent) const =0;
+	virtual Element CascadeExponentiate(const DL_GroupPrecomputation<Element> &group, const Integer &exponent, const DL_FixedBasePrecomputation<Element> &pc2, const Integer &exponent2) const =0;
+};
+
+template <class T>
+class DL_FixedBasePrecomputationImpl : public DL_FixedBasePrecomputation<T>
+{
+public:
+	typedef T Element;
+
+	DL_FixedBasePrecomputationImpl() : m_windowSize(0) {}
+
+	// DL_FixedBasePrecomputation
+	bool IsInitialized() const
+		{return !m_bases.empty();}
+	void SetBase(const DL_GroupPrecomputation<Element> &group, const Element &base);
+	const Element & GetBase(const DL_GroupPrecomputation<Element> &group) const
+		{return group.NeedConversions() ? m_base : m_bases[0];}
+	void Precompute(const DL_GroupPrecomputation<Element> &group, unsigned int maxExpBits, unsigned int storage);
+	void Load(const DL_GroupPrecomputation<Element> &group, BufferedTransformation &storedPrecomputation);
+	void Save(const DL_GroupPrecomputation<Element> &group, BufferedTransformation &storedPrecomputation) const;
+	Element Exponentiate(const DL_GroupPrecomputation<Element> &group, const Integer &exponent) const;
+	Element CascadeExponentiate(const DL_GroupPrecomputation<Element> &group, const Integer &exponent, const DL_FixedBasePrecomputation<Element> &pc2, const Integer &exponent2) const;
+
+private:
+	void PrepareCascade(const DL_GroupPrecomputation<Element> &group, std::vector<BaseAndExponent<Element> > &eb, const Integer &exponent) const;
+
+	Element m_base;
+	unsigned int m_windowSize;
+	Integer m_exponentBase;			// what base to represent the exponent in
+	std::vector<Element> m_bases;	// precalculated bases
+};
+
+NAMESPACE_END
+
+#ifdef CRYPTOPP_MANUALLY_INSTANTIATE_TEMPLATES
+#include "eprecomp.cpp"
+#endif
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/files.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/files.h
index a1a58bf7..a47e856b 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/files.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/files.h
@@ -1,95 +1,112 @@
-#ifndef CRYPTOPP_FILES_H
-#define CRYPTOPP_FILES_H
-
-#include "cryptlib.h"
-#include "filters.h"
-
-#include <iostream>
-#include <fstream>
-
-NAMESPACE_BEGIN(CryptoPP)
-
-//! .
-class FileStore : public Store, private FilterPutSpaceHelper
-{
-public:
-	class Err : public Exception
-	{
-	public:
-		Err(const std::string &s) : Exception(IO_ERROR, s) {}
-	};
-	class OpenErr : public Err {public: OpenErr(const std::string &filename) : Err("FileStore: error opening file for reading: " + filename) {}};
-	class ReadErr : public Err {public: ReadErr() : Err("FileStore: error reading file") {}};
-
-	FileStore() : m_stream(NULL) {}
-	FileStore(std::istream &in)
-		{StoreInitialize(MakeParameters("InputStreamPointer", &in));}
-	FileStore(const char *filename)
-		{StoreInitialize(MakeParameters("InputFileName", filename));}
-
-	std::istream* GetStream() {return m_stream;}
-
-	unsigned long MaxRetrievable() const;
-	unsigned int TransferTo2(BufferedTransformation &target, unsigned long &transferBytes, const std::string &channel=NULL_CHANNEL, bool blocking=true);
-	unsigned int CopyRangeTo2(BufferedTransformation &target, unsigned long &begin, unsigned long end=ULONG_MAX, const std::string &channel=NULL_CHANNEL, bool blocking=true) const;
-
-private:
-	void StoreInitialize(const NameValuePairs &parameters);
-	
-	std::ifstream m_file;
-	std::istream *m_stream;
-	byte *m_space;
-	unsigned int m_len;
-	bool m_waiting;
-};
-
-//! .
-class FileSource : public SourceTemplate<FileStore>
-{
-public:
-	typedef FileStore::Err Err;
-	typedef FileStore::OpenErr OpenErr;
-	typedef FileStore::ReadErr ReadErr;
-
-	FileSource(BufferedTransformation *attachment = NULL)
-		: SourceTemplate<FileStore>(attachment) {}
-	FileSource(std::istream &in, bool pumpAll, BufferedTransformation *attachment = NULL)
-		: SourceTemplate<FileStore>(attachment) {SourceInitialize(pumpAll, MakeParameters("InputStreamPointer", &in));}
-	FileSource(const char *filename, bool pumpAll, BufferedTransformation *attachment = NULL, bool binary=true)
-		: SourceTemplate<FileStore>(attachment) {SourceInitialize(pumpAll, MakeParameters("InputFileName", filename)("InputBinaryMode", binary));}
-
-	std::istream* GetStream() {return m_store.GetStream();}
-};
-
-//! .
-class FileSink : public Sink
-{
-public:
-	class Err : public Exception
-	{
-	public:
-		Err(const std::string &s) : Exception(IO_ERROR, s) {}
-	};
-	class OpenErr : public Err {public: OpenErr(const std::string &filename) : Err("FileSink: error opening file for writing: " + filename) {}};
-	class WriteErr : public Err {public: WriteErr() : Err("FileSink: error writing file") {}};
-
-	FileSink() : m_stream(NULL) {}
-	FileSink(std::ostream &out)
-		{IsolatedInitialize(MakeParameters("OutputStreamPointer", &out));}
-	FileSink(const char *filename, bool binary=true)
-		{IsolatedInitialize(MakeParameters("OutputFileName", filename)("OutputBinaryMode", binary));}
-
-	std::ostream* GetStream() {return m_stream;}
-
-	void IsolatedInitialize(const NameValuePairs &parameters);
-	unsigned int Put2(const byte *inString, unsigned int length, int messageEnd, bool blocking);
-	bool IsolatedFlush(bool hardFlush, bool blocking);
-
-private:
-	std::ofstream m_file;
-	std::ostream *m_stream;
-};
-
-NAMESPACE_END
-
-#endif
+#ifndef CRYPTOPP_FILES_H
+#define CRYPTOPP_FILES_H
+
+#include "cryptlib.h"
+#include "filters.h"
+#include "argnames.h"
+
+#include <iostream>
+#include <fstream>
+
+NAMESPACE_BEGIN(CryptoPP)
+
+//! file-based implementation of Store interface
+class CRYPTOPP_DLL FileStore : public Store, private FilterPutSpaceHelper, public NotCopyable
+{
+public:
+	class Err : public Exception
+	{
+	public:
+		Err(const std::string &s) : Exception(IO_ERROR, s) {}
+	};
+	class OpenErr : public Err {public: OpenErr(const std::string &filename) : Err("FileStore: error opening file for reading: " + filename) {}};
+	class ReadErr : public Err {public: ReadErr() : Err("FileStore: error reading file") {}};
+
+	FileStore() : m_stream(NULL) {}
+	FileStore(std::istream &in)
+		{StoreInitialize(MakeParameters(Name::InputStreamPointer(), &in));}
+	FileStore(const char *filename)
+		{StoreInitialize(MakeParameters(Name::InputFileName(), filename));}
+#if defined(CRYPTOPP_UNIX_AVAILABLE) || _MSC_VER >= 1400
+	//! specify file with Unicode name. On non-Windows OS, this function assumes that setlocale() has been called.
+	FileStore(const wchar_t *filename)
+		{StoreInitialize(MakeParameters(Name::InputFileNameWide(), filename));}
+#endif
+
+	std::istream* GetStream() {return m_stream;}
+
+	lword MaxRetrievable() const;
+	size_t TransferTo2(BufferedTransformation &target, lword &transferBytes, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true);
+	size_t CopyRangeTo2(BufferedTransformation &target, lword &begin, lword end=LWORD_MAX, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true) const;
+	lword Skip(lword skipMax=ULONG_MAX);
+
+private:
+	void StoreInitialize(const NameValuePairs &parameters);
+	
+	member_ptr<std::ifstream> m_file;
+	std::istream *m_stream;
+	byte *m_space;
+	size_t m_len;
+	bool m_waiting;
+};
+
+//! file-based implementation of Source interface
+class CRYPTOPP_DLL FileSource : public SourceTemplate<FileStore>
+{
+public:
+	typedef FileStore::Err Err;
+	typedef FileStore::OpenErr OpenErr;
+	typedef FileStore::ReadErr ReadErr;
+
+	FileSource(BufferedTransformation *attachment = NULL)
+		: SourceTemplate<FileStore>(attachment) {}
+	FileSource(std::istream &in, bool pumpAll, BufferedTransformation *attachment = NULL)
+		: SourceTemplate<FileStore>(attachment) {SourceInitialize(pumpAll, MakeParameters(Name::InputStreamPointer(), &in));}
+	FileSource(const char *filename, bool pumpAll, BufferedTransformation *attachment = NULL, bool binary=true)
+		: SourceTemplate<FileStore>(attachment) {SourceInitialize(pumpAll, MakeParameters(Name::InputFileName(), filename)(Name::InputBinaryMode(), binary));}
+#if defined(CRYPTOPP_UNIX_AVAILABLE) || _MSC_VER >= 1400
+	//! specify file with Unicode name. On non-Windows OS, this function assumes that setlocale() has been called.
+	FileSource(const wchar_t *filename, bool pumpAll, BufferedTransformation *attachment = NULL, bool binary=true)
+		: SourceTemplate<FileStore>(attachment) {SourceInitialize(pumpAll, MakeParameters(Name::InputFileNameWide(), filename)(Name::InputBinaryMode(), binary));}
+#endif
+
+	std::istream* GetStream() {return m_store.GetStream();}
+};
+
+//! file-based implementation of Sink interface
+class CRYPTOPP_DLL FileSink : public Sink, public NotCopyable
+{
+public:
+	class Err : public Exception
+	{
+	public:
+		Err(const std::string &s) : Exception(IO_ERROR, s) {}
+	};
+	class OpenErr : public Err {public: OpenErr(const std::string &filename) : Err("FileSink: error opening file for writing: " + filename) {}};
+	class WriteErr : public Err {public: WriteErr() : Err("FileSink: error writing file") {}};
+
+	FileSink() : m_stream(NULL) {}
+	FileSink(std::ostream &out)
+		{IsolatedInitialize(MakeParameters(Name::OutputStreamPointer(), &out));}
+	FileSink(const char *filename, bool binary=true)
+		{IsolatedInitialize(MakeParameters(Name::OutputFileName(), filename)(Name::OutputBinaryMode(), binary));}
+#if defined(CRYPTOPP_UNIX_AVAILABLE) || _MSC_VER >= 1400
+	//! specify file with Unicode name. On non-Windows OS, this function assumes that setlocale() has been called.
+	FileSink(const wchar_t *filename, bool binary=true)
+		{IsolatedInitialize(MakeParameters(Name::OutputFileNameWide(), filename)(Name::OutputBinaryMode(), binary));}
+#endif
+
+	std::ostream* GetStream() {return m_stream;}
+
+	void IsolatedInitialize(const NameValuePairs &parameters);
+	size_t Put2(const byte *inString, size_t length, int messageEnd, bool blocking);
+	bool IsolatedFlush(bool hardFlush, bool blocking);
+
+private:
+	member_ptr<std::ofstream> m_file;
+	std::ostream *m_stream;
+};
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/filters.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/filters.h
index 66d52148..c72a4ece 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/filters.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/filters.h
@@ -1,688 +1,810 @@
-#ifndef CRYPTOPP_FILTERS_H
-#define CRYPTOPP_FILTERS_H
-
-#include "simple.h"
-#include "secblock.h"
-#include "misc.h"
-#include "smartptr.h"
-#include "queue.h"
-#include "algparam.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-/// provides an implementation of BufferedTransformation's attachment interface
-class Filter : public BufferedTransformation, public NotCopyable
-{
-public:
-	Filter(BufferedTransformation *attachment);
-
-	bool Attachable() {return true;}
-	BufferedTransformation *AttachedTransformation();
-	const BufferedTransformation *AttachedTransformation() const;
-	void Detach(BufferedTransformation *newAttachment = NULL);
-
-	unsigned int TransferTo2(BufferedTransformation &target, unsigned long &transferBytes, const std::string &channel=NULL_CHANNEL, bool blocking=true);
-	unsigned int CopyRangeTo2(BufferedTransformation &target, unsigned long &begin, unsigned long end=ULONG_MAX, const std::string &channel=NULL_CHANNEL, bool blocking=true) const;
-
-	void Initialize(const NameValuePairs &parameters=g_nullNameValuePairs, int propagation=-1);
-	bool Flush(bool hardFlush, int propagation=-1, bool blocking=true);
-	bool MessageSeriesEnd(int propagation=-1, bool blocking=true);
-
-protected:
-	virtual void NotifyAttachmentChange() {}
-	virtual BufferedTransformation * NewDefaultAttachment() const;
-	void Insert(Filter *nextFilter);	// insert filter after this one
-
-	virtual bool ShouldPropagateMessageEnd() const {return true;}
-	virtual bool ShouldPropagateMessageSeriesEnd() const {return true;}
-
-	void PropagateInitialize(const NameValuePairs &parameters, int propagation, const std::string &channel=NULL_CHANNEL);
-
-	unsigned int Output(int outputSite, const byte *inString, unsigned int length, int messageEnd, bool blocking, const std::string &channel=NULL_CHANNEL);
-	bool OutputMessageEnd(int outputSite, int propagation, bool blocking, const std::string &channel=NULL_CHANNEL);
-	bool OutputFlush(int outputSite, bool hardFlush, int propagation, bool blocking, const std::string &channel=NULL_CHANNEL);
-	bool OutputMessageSeriesEnd(int outputSite, int propagation, bool blocking, const std::string &channel=NULL_CHANNEL);
-
-private:
-	member_ptr<BufferedTransformation> m_attachment;
-	
-protected:
-	unsigned int m_inputPosition;
-	int m_continueAt;
-};
-
-struct FilterPutSpaceHelper
-{
-	// desiredSize is how much to ask target, bufferSize is how much to allocate in m_tempSpace
-	byte *HelpCreatePutSpace(BufferedTransformation &target, const std::string &channel, unsigned int minSize, unsigned int desiredSize, unsigned int &bufferSize)
-	{
-		assert(desiredSize >= minSize && bufferSize >= minSize);
-		if (m_tempSpace.size() < minSize)
-		{
-			byte *result = target.ChannelCreatePutSpace(channel, desiredSize);
-			if (desiredSize >= minSize)
-			{
-				bufferSize = desiredSize;
-				return result;
-			}
-			m_tempSpace.New(bufferSize);
-		}
-
-		bufferSize = m_tempSpace.size();
-		return m_tempSpace.begin();
-	}
-	byte *HelpCreatePutSpace(BufferedTransformation &target, const std::string &channel, unsigned int minSize)
-		{return HelpCreatePutSpace(target, channel, minSize, minSize, minSize);}
-	byte *HelpCreatePutSpace(BufferedTransformation &target, const std::string &channel, unsigned int minSize, unsigned int bufferSize)
-		{return HelpCreatePutSpace(target, channel, minSize, minSize, bufferSize);}
-	SecByteBlock m_tempSpace;
-};
-
-//! measure how many byte and messages pass through, also serves as valve
-class MeterFilter : public Bufferless<Filter>
-{
-public:
-	MeterFilter(BufferedTransformation *attachment=NULL, bool transparent=true)
-		: Bufferless<Filter>(attachment), m_transparent(transparent) {ResetMeter();}
-
-	void SetTransparent(bool transparent) {m_transparent = transparent;}
-	void ResetMeter() {m_currentMessageBytes = m_totalBytes = m_currentSeriesMessages = m_totalMessages = m_totalMessageSeries = 0;}
-
-	unsigned long GetCurrentMessageBytes() const {return m_currentMessageBytes;}
-	unsigned long GetTotalBytes() {return m_totalBytes;}
-	unsigned int GetCurrentSeriesMessages() {return m_currentSeriesMessages;}
-	unsigned int GetTotalMessages() {return m_totalMessages;}
-	unsigned int GetTotalMessageSeries() {return m_totalMessageSeries;}
-
-	unsigned int Put2(const byte *begin, unsigned int length, int messageEnd, bool blocking);
-	bool IsolatedMessageSeriesEnd(bool blocking);
-
-private:
-	bool ShouldPropagateMessageEnd() const {return m_transparent;}
-	bool ShouldPropagateMessageSeriesEnd() const {return m_transparent;}
-
-	bool m_transparent;
-	unsigned long m_currentMessageBytes, m_totalBytes;
-	unsigned int m_currentSeriesMessages, m_totalMessages, m_totalMessageSeries;
-};
-
-//! .
-class TransparentFilter : public MeterFilter
-{
-public:
-	TransparentFilter(BufferedTransformation *attachment=NULL) : MeterFilter(attachment, true) {}
-};
-
-//! .
-class OpaqueFilter : public MeterFilter
-{
-public:
-	OpaqueFilter(BufferedTransformation *attachment=NULL) : MeterFilter(attachment, false) {}
-};
-
-/*! FilterWithBufferedInput divides up the input stream into
-	a first block, a number of middle blocks, and a last block.
-	First and last blocks are optional, and middle blocks may
-	be a stream instead (i.e. blockSize == 1).
-*/
-class FilterWithBufferedInput : public Filter
-{
-public:
-	FilterWithBufferedInput(BufferedTransformation *attachment);
-	//! firstSize and lastSize may be 0, blockSize must be at least 1
-	FilterWithBufferedInput(unsigned int firstSize, unsigned int blockSize, unsigned int lastSize, BufferedTransformation *attachment);
-
-	void IsolatedInitialize(const NameValuePairs &parameters);
-	unsigned int Put2(const byte *inString, unsigned int length, int messageEnd, bool blocking)
-	{
-		return PutMaybeModifiable(const_cast<byte *>(inString), length, messageEnd, blocking, false);
-	}
-	unsigned int PutModifiable2(byte *inString, unsigned int length, int messageEnd, bool blocking)
-	{
-		return PutMaybeModifiable(inString, length, messageEnd, blocking, true);
-	}
-	/*! calls ForceNextPut() if hardFlush is true */
-	bool IsolatedFlush(bool hardFlush, bool blocking);
-
-	/*! The input buffer may contain more than blockSize bytes if lastSize != 0.
-		ForceNextPut() forces a call to NextPut() if this is the case.
-	*/
-	void ForceNextPut();
-
-protected:
-	bool DidFirstPut() {return m_firstInputDone;}
-
-	virtual void InitializeDerivedAndReturnNewSizes(const NameValuePairs &parameters, unsigned int &firstSize, unsigned int &blockSize, unsigned int &lastSize)
-		{InitializeDerived(parameters);}
-	virtual void InitializeDerived(const NameValuePairs &parameters) {}
-	// FirstPut() is called if (firstSize != 0 and totalLength >= firstSize)
-	// or (firstSize == 0 and (totalLength > 0 or a MessageEnd() is received))
-	virtual void FirstPut(const byte *inString) =0;
-	// NextPut() is called if totalLength >= firstSize+blockSize+lastSize
-	virtual void NextPutSingle(const byte *inString) {assert(false);}
-	// Same as NextPut() except length can be a multiple of blockSize
-	// Either NextPut() or NextPutMultiple() must be overriden
-	virtual void NextPutMultiple(const byte *inString, unsigned int length);
-	// Same as NextPutMultiple(), but inString can be modified
-	virtual void NextPutModifiable(byte *inString, unsigned int length)
-		{NextPutMultiple(inString, length);}
-	// LastPut() is always called
-	// if totalLength < firstSize then length == totalLength
-	// else if totalLength <= firstSize+lastSize then length == totalLength-firstSize
-	// else lastSize <= length < lastSize+blockSize
-	virtual void LastPut(const byte *inString, unsigned int length) =0;
-	virtual void FlushDerived() {}
-
-private:
-	unsigned int PutMaybeModifiable(byte *begin, unsigned int length, int messageEnd, bool blocking, bool modifiable);
-	void NextPutMaybeModifiable(byte *inString, unsigned int length, bool modifiable)
-	{
-		if (modifiable) NextPutModifiable(inString, length);
-		else NextPutMultiple(inString, length);
-	}
-
-	// This function should no longer be used, put this here to cause a compiler error
-	// if someone tries to override NextPut().
-	virtual int NextPut(const byte *inString, unsigned int length) {assert(false); return 0;}
-
-	class BlockQueue
-	{
-	public:
-		void ResetQueue(unsigned int blockSize, unsigned int maxBlocks);
-		byte *GetBlock();
-		byte *GetContigousBlocks(unsigned int &numberOfBytes);
-		unsigned int GetAll(byte *outString);
-		void Put(const byte *inString, unsigned int length);
-		unsigned int CurrentSize() const {return m_size;}
-		unsigned int MaxSize() const {return m_buffer.size();}
-
-	private:
-		SecByteBlock m_buffer;
-		unsigned int m_blockSize, m_maxBlocks, m_size;
-		byte *m_begin;
-	};
-
-	unsigned int m_firstSize, m_blockSize, m_lastSize;
-	bool m_firstInputDone;
-	BlockQueue m_queue;
-};
-
-//! .
-class FilterWithInputQueue : public Filter
-{
-public:
-	FilterWithInputQueue(BufferedTransformation *attachment) : Filter(attachment) {}
-	unsigned int Put2(const byte *inString, unsigned int length, int messageEnd, bool blocking)
-	{
-		if (!blocking)
-			throw BlockingInputOnly("FilterWithInputQueue");
-		
-		m_inQueue.Put(inString, length);
-		if (messageEnd)
-		{
-			IsolatedMessageEnd(blocking);
-			Output(0, NULL, 0, messageEnd, blocking);
-		}
-		return 0;
-	}
-
-protected:
-	virtual bool IsolatedMessageEnd(bool blocking) =0;
-	void IsolatedInitialize(const NameValuePairs &parameters) {m_inQueue.Clear();}
-
-	ByteQueue m_inQueue;
-};
-
-//! Filter Wrapper for StreamTransformation
-class StreamTransformationFilter : public FilterWithBufferedInput, private FilterPutSpaceHelper
-{
-public:
-	enum BlockPaddingScheme {NO_PADDING, ZEROS_PADDING, PKCS_PADDING, ONE_AND_ZEROS_PADDING, DEFAULT_PADDING};
-	/*! DEFAULT_PADDING means PKCS_PADDING if c.MandatoryBlockSize() > 1 && c.MinLastBlockSize() == 0 (e.g. ECB or CBC mode),
-		otherwise NO_PADDING (OFB, CFB, CTR, CBC-CTS modes) */
-	StreamTransformationFilter(StreamTransformation &c, BufferedTransformation *attachment = NULL, BlockPaddingScheme padding = DEFAULT_PADDING);
-
-	void FirstPut(const byte *inString);
-	void NextPutMultiple(const byte *inString, unsigned int length);
-	void NextPutModifiable(byte *inString, unsigned int length);
-	void LastPut(const byte *inString, unsigned int length);
-//	byte * CreatePutSpace(unsigned int &size);
-
-protected:
-	static unsigned int LastBlockSize(StreamTransformation &c, BlockPaddingScheme padding);
-
-	StreamTransformation &m_cipher;
-	BlockPaddingScheme m_padding;
-	unsigned int m_optimalBufferSize;
-};
-
-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
-typedef StreamTransformationFilter StreamCipherFilter;
-#endif
-
-//! Filter Wrapper for HashTransformation
-class HashFilter : public Bufferless<Filter>, private FilterPutSpaceHelper
-{
-public:
-	HashFilter(HashTransformation &hm, BufferedTransformation *attachment = NULL, bool putMessage=false)
-		: Bufferless<Filter>(attachment), m_hashModule(hm), m_putMessage(putMessage) {}
-
-	void IsolatedInitialize(const NameValuePairs &parameters);
-	unsigned int Put2(const byte *begin, unsigned int length, int messageEnd, bool blocking);
-
-	byte * CreatePutSpace(unsigned int &size) {return m_hashModule.CreateUpdateSpace(size);}
-
-private:
-	HashTransformation &m_hashModule;
-	bool m_putMessage;
-	byte *m_space;
-};
-
-//! Filter Wrapper for HashTransformation
-class HashVerificationFilter : public FilterWithBufferedInput
-{
-public:
-	class HashVerificationFailed : public Exception
-	{
-	public:
-		HashVerificationFailed()
-			: Exception(DATA_INTEGRITY_CHECK_FAILED, "HashVerifier: message hash not valid") {}
-	};
-
-	enum Flags {HASH_AT_BEGIN=1, PUT_MESSAGE=2, PUT_HASH=4, PUT_RESULT=8, THROW_EXCEPTION=16, DEFAULT_FLAGS = HASH_AT_BEGIN | PUT_RESULT};
-	HashVerificationFilter(HashTransformation &hm, BufferedTransformation *attachment = NULL, word32 flags = DEFAULT_FLAGS);
-
-	bool GetLastResult() const {return m_verified;}
-
-protected:
-	void InitializeDerivedAndReturnNewSizes(const NameValuePairs &parameters, unsigned int &firstSize, unsigned int &blockSize, unsigned int &lastSize);
-	void FirstPut(const byte *inString);
-	void NextPutMultiple(const byte *inString, unsigned int length);
-	void LastPut(const byte *inString, unsigned int length);
-
-private:
-	static inline unsigned int FirstSize(word32 flags, HashTransformation &hm) {return flags & HASH_AT_BEGIN ? hm.DigestSize() : 0;}
-	static inline unsigned int LastSize(word32 flags, HashTransformation &hm) {return flags & HASH_AT_BEGIN ? 0 : hm.DigestSize();}
-
-	HashTransformation &m_hashModule;
-	word32 m_flags;
-	SecByteBlock m_expectedHash;
-	bool m_verified;
-};
-
-typedef HashVerificationFilter HashVerifier;	// for backwards compatibility
-
-//! Filter Wrapper for PK_Signer
-class SignerFilter : public Unflushable<Filter>
-{
-public:
-	SignerFilter(RandomNumberGenerator &rng, const PK_Signer &signer, BufferedTransformation *attachment = NULL, bool putMessage=false)
-		: Unflushable<Filter>(attachment), m_rng(rng), m_signer(signer), m_messageAccumulator(signer.NewSignatureAccumulator()), m_putMessage(putMessage) {}
-
-	void IsolatedInitialize(const NameValuePairs &parameters);
-	unsigned int Put2(const byte *begin, unsigned int length, int messageEnd, bool blocking);
-
-private:
-	RandomNumberGenerator &m_rng;
-	const PK_Signer	&m_signer;
-	member_ptr<PK_MessageAccumulator> m_messageAccumulator;
-	bool m_putMessage;
-	SecByteBlock m_buf;
-};
-
-//! Filter Wrapper for PK_Verifier
-class SignatureVerificationFilter : public FilterWithBufferedInput
-{
-public:
-	class SignatureVerificationFailed : public Exception
-	{
-	public:
-		SignatureVerificationFailed()
-			: Exception(DATA_INTEGRITY_CHECK_FAILED, "VerifierFilter: digital signature not valid") {}
-	};
-
-	enum Flags {SIGNATURE_AT_BEGIN=1, PUT_MESSAGE=2, PUT_SIGNATURE=4, PUT_RESULT=8, THROW_EXCEPTION=16, DEFAULT_FLAGS = SIGNATURE_AT_BEGIN | PUT_RESULT};
-	SignatureVerificationFilter(const PK_Verifier &verifier, BufferedTransformation *attachment = NULL, word32 flags = DEFAULT_FLAGS);
-
-	bool GetLastResult() const {return m_verified;}
-
-protected:
-	void InitializeDerivedAndReturnNewSizes(const NameValuePairs &parameters, unsigned int &firstSize, unsigned int &blockSize, unsigned int &lastSize);
-	void FirstPut(const byte *inString);
-	void NextPutMultiple(const byte *inString, unsigned int length);
-	void LastPut(const byte *inString, unsigned int length);
-
-private:
-	const PK_Verifier &m_verifier;
-	member_ptr<PK_MessageAccumulator> m_messageAccumulator;
-	word32 m_flags;
-	SecByteBlock m_signature;
-	bool m_verified;
-};
-
-typedef SignatureVerificationFilter VerifierFilter; // for backwards compatibility
-
-//! Redirect input to another BufferedTransformation without owning it
-class Redirector : public CustomSignalPropagation<Sink>
-{
-public:
-	Redirector() : m_target(NULL), m_passSignal(true) {}
-	Redirector(BufferedTransformation &target, bool passSignal=true) : m_target(&target), m_passSignal(passSignal) {}
-
-	void Redirect(BufferedTransformation &target) {m_target = &target;}
-	void StopRedirection() {m_target = NULL;}
-	bool GetPassSignal() const {return m_passSignal;}
-	void SetPassSignal(bool passSignal) {m_passSignal = passSignal;}
-
-	unsigned int Put2(const byte *begin, unsigned int length, int messageEnd, bool blocking)
-		{return m_target ? m_target->Put2(begin, length, m_passSignal ? messageEnd : 0, blocking) : 0;}
-	void Initialize(const NameValuePairs &parameters, int propagation)
-		{ChannelInitialize(NULL_CHANNEL, parameters, propagation);}
-	bool Flush(bool hardFlush, int propagation=-1, bool blocking=true)
-		{return m_target && m_passSignal ? m_target->Flush(hardFlush, propagation, blocking) : false;}
-	bool MessageSeriesEnd(int propagation=-1, bool blocking=true)
-		{return m_target && m_passSignal ? m_target->MessageSeriesEnd(propagation, blocking) : false;}
-
-	void ChannelInitialize(const std::string &channel, const NameValuePairs &parameters=g_nullNameValuePairs, int propagation=-1);
-	unsigned int ChannelPut2(const std::string &channel, const byte *begin, unsigned int length, int messageEnd, bool blocking)
-		{return m_target ? m_target->ChannelPut2(channel, begin, length, m_passSignal ? messageEnd : 0, blocking) : 0;}
-	unsigned int ChannelPutModifiable2(const std::string &channel, byte *begin, unsigned int length, int messageEnd, bool blocking)
-		{return m_target ? m_target->ChannelPutModifiable2(channel, begin, length, m_passSignal ? messageEnd : 0, blocking) : 0;}
-	bool ChannelFlush(const std::string &channel, bool completeFlush, int propagation=-1, bool blocking=true)
-		{return m_target && m_passSignal ? m_target->ChannelFlush(channel, completeFlush, propagation, blocking) : false;}
-	bool ChannelMessageSeriesEnd(const std::string &channel, int propagation=-1, bool blocking=true)
-		{return m_target && m_passSignal ? m_target->ChannelMessageSeriesEnd(channel, propagation, blocking) : false;}
-
-private:
-	BufferedTransformation *m_target;
-	bool m_passSignal;
-};
-
-// Used By ProxyFilter
-class OutputProxy : public CustomSignalPropagation<Sink>
-{
-public:
-	OutputProxy(BufferedTransformation &owner, bool passSignal) : m_owner(owner), m_passSignal(passSignal) {}
-
-	bool GetPassSignal() const {return m_passSignal;}
-	void SetPassSignal(bool passSignal) {m_passSignal = passSignal;}
-
-	unsigned int Put2(const byte *begin, unsigned int length, int messageEnd, bool blocking)
-		{return m_owner.AttachedTransformation()->Put2(begin, length, m_passSignal ? messageEnd : 0, blocking);}
-	unsigned int PutModifiable2(byte *begin, unsigned int length, int messageEnd, bool blocking)
-		{return m_owner.AttachedTransformation()->PutModifiable2(begin, length, m_passSignal ? messageEnd : 0, blocking);}
-	void Initialize(const NameValuePairs &parameters=g_nullNameValuePairs, int propagation=-1)
-		{if (m_passSignal) m_owner.AttachedTransformation()->Initialize(parameters, propagation);}
-	bool Flush(bool hardFlush, int propagation=-1, bool blocking=true)
-		{return m_passSignal ? m_owner.AttachedTransformation()->Flush(hardFlush, propagation, blocking) : false;}
-	bool MessageSeriesEnd(int propagation=-1, bool blocking=true)
-		{return m_passSignal ? m_owner.AttachedTransformation()->MessageSeriesEnd(propagation, blocking) : false;}
-
-	unsigned int ChannelPut2(const std::string &channel, const byte *begin, unsigned int length, int messageEnd, bool blocking)
-		{return m_owner.AttachedTransformation()->ChannelPut2(channel, begin, length, m_passSignal ? messageEnd : 0, blocking);}
-	unsigned int ChannelPutModifiable2(const std::string &channel, byte *begin, unsigned int length, int messageEnd, bool blocking)
-		{return m_owner.AttachedTransformation()->ChannelPutModifiable2(channel, begin, length, m_passSignal ? messageEnd : 0, blocking);}
-	void ChannelInitialize(const std::string &channel, const NameValuePairs &parameters, int propagation=-1)
-		{if (m_passSignal) m_owner.AttachedTransformation()->ChannelInitialize(channel, parameters, propagation);}
-	bool ChannelFlush(const std::string &channel, bool completeFlush, int propagation=-1, bool blocking=true)
-		{return m_passSignal ? m_owner.AttachedTransformation()->ChannelFlush(channel, completeFlush, propagation, blocking) : false;}
-	bool ChannelMessageSeriesEnd(const std::string &channel, int propagation=-1, bool blocking=true)
-		{return m_passSignal ? m_owner.AttachedTransformation()->ChannelMessageSeriesEnd(channel, propagation, blocking) : false;}
-
-private:
-	BufferedTransformation &m_owner;
-	bool m_passSignal;
-};
-
-//! Base class for Filter classes that are proxies for a chain of other filters.
-class ProxyFilter : public FilterWithBufferedInput
-{
-public:
-	ProxyFilter(BufferedTransformation *filter, unsigned int firstSize, unsigned int lastSize, BufferedTransformation *attachment);
-
-	bool IsolatedFlush(bool hardFlush, bool blocking);
-
-	void SetFilter(Filter *filter);
-	void NextPutMultiple(const byte *s, unsigned int len);
-
-protected:
-	member_ptr<BufferedTransformation> m_filter;
-};
-
-//! simple proxy filter that doesn't modify the underlying filter's input or output
-class SimpleProxyFilter : public ProxyFilter
-{
-public:
-	SimpleProxyFilter(BufferedTransformation *filter, BufferedTransformation *attachment)
-		: ProxyFilter(filter, 0, 0, attachment) {}
-
-	void FirstPut(const byte *) {}
-	void LastPut(const byte *, unsigned int) {m_filter->MessageEnd();}
-};
-
-//! proxy for the filter created by PK_Encryptor::CreateEncryptionFilter
-/*! This class is here just to provide symmetry with VerifierFilter. */
-class PK_EncryptorFilter : public SimpleProxyFilter
-{
-public:
-	PK_EncryptorFilter(RandomNumberGenerator &rng, const PK_Encryptor &encryptor, BufferedTransformation *attachment = NULL)
-		: SimpleProxyFilter(encryptor.CreateEncryptionFilter(rng), attachment) {}
-};
-
-//! proxy for the filter created by PK_Decryptor::CreateDecryptionFilter
-/*! This class is here just to provide symmetry with SignerFilter. */
-class PK_DecryptorFilter : public SimpleProxyFilter
-{
-public:
-	PK_DecryptorFilter(RandomNumberGenerator &rng, const PK_Decryptor &decryptor, BufferedTransformation *attachment = NULL)
-		: SimpleProxyFilter(decryptor.CreateDecryptionFilter(rng), attachment) {}
-};
-
-//! Append input to a string object
-template <class T>
-class StringSinkTemplate : public Bufferless<Sink>
-{
-public:
-	// VC60 workaround: no T::char_type
-	typedef typename T::traits_type::char_type char_type;
-
-	StringSinkTemplate(T &output)
-		: m_output(&output) {assert(sizeof(output[0])==1);}
-
-	void IsolatedInitialize(const NameValuePairs &parameters)
-		{if (!parameters.GetValue("OutputStringPointer", m_output)) throw InvalidArgument("StringSink: OutputStringPointer not specified");}
-
-	unsigned int Put2(const byte *begin, unsigned int length, int messageEnd, bool blocking)
-	{
-		if (length > 0)
-		{
-			typename T::size_type size = m_output->size();
-			if (length < size && size + length > m_output->capacity())
-				m_output->reserve(2*size);
-			m_output->append((const char_type *)begin, (const char_type *)begin+length);
-		}
-		return 0;
-	}
-
-private:	
-	T *m_output;
-};
-
-//! Append input to an std::string
-typedef StringSinkTemplate<std::string> StringSink;
-
-//! Copy input to a memory buffer
-class ArraySink : public Bufferless<Sink>
-{
-public:
-	ArraySink(const NameValuePairs &parameters = g_nullNameValuePairs) {IsolatedInitialize(parameters);}
-	ArraySink(byte *buf, unsigned int size) : m_buf(buf), m_size(size), m_total(0) {}
-
-	unsigned int AvailableSize() {return m_size - STDMIN(m_total, (unsigned long)m_size);}
-	unsigned long TotalPutLength() {return m_total;}
-
-	void IsolatedInitialize(const NameValuePairs &parameters);
-	byte * CreatePutSpace(unsigned int &size);
-	unsigned int Put2(const byte *begin, unsigned int length, int messageEnd, bool blocking);
-
-protected:
-	byte *m_buf;
-	unsigned int m_size;
-	unsigned long m_total;
-};
-
-//! Xor input to a memory buffer
-class ArrayXorSink : public ArraySink
-{
-public:
-	ArrayXorSink(byte *buf, unsigned int size)
-		: ArraySink(buf, size) {}
-
-	unsigned int Put2(const byte *begin, unsigned int length, int messageEnd, bool blocking);
-	byte * CreatePutSpace(unsigned int &size) {return BufferedTransformation::CreatePutSpace(size);}
-};
-
-//! .
-class StringStore : public Store
-{
-public:
-	StringStore(const char *string = NULL)
-		{StoreInitialize(MakeParameters("InputBuffer", ConstByteArrayParameter(string)));}
-	StringStore(const byte *string, unsigned int length)
-		{StoreInitialize(MakeParameters("InputBuffer", ConstByteArrayParameter(string, length)));}
-	template <class T> StringStore(const T &string)
-		{StoreInitialize(MakeParameters("InputBuffer", ConstByteArrayParameter(string)));}
-
-	unsigned int TransferTo2(BufferedTransformation &target, unsigned long &transferBytes, const std::string &channel=NULL_CHANNEL, bool blocking=true);
-	unsigned int CopyRangeTo2(BufferedTransformation &target, unsigned long &begin, unsigned long end=ULONG_MAX, const std::string &channel=NULL_CHANNEL, bool blocking=true) const;
-
-private:
-	void StoreInitialize(const NameValuePairs &parameters);
-
-	const byte *m_store;
-	unsigned int m_length, m_count;
-};
-
-//! .
-class RandomNumberStore : public Store
-{
-public:
-	RandomNumberStore(RandomNumberGenerator &rng, unsigned long length)
-		: m_rng(rng), m_length(length), m_count(0) {}
-
-	bool AnyRetrievable() const {return MaxRetrievable() != 0;}
-	unsigned long MaxRetrievable() const {return m_length-m_count;}
-
-	unsigned int TransferTo2(BufferedTransformation &target, unsigned long &transferBytes, const std::string &channel=NULL_CHANNEL, bool blocking=true);
-	unsigned int CopyRangeTo2(BufferedTransformation &target, unsigned long &begin, unsigned long end=ULONG_MAX, const std::string &channel=NULL_CHANNEL, bool blocking=true) const
-	{
-		throw NotImplemented("RandomNumberStore: CopyRangeTo2() is not supported by this store");
-	}
-
-private:
-	void StoreInitialize(const NameValuePairs &parameters) {m_count = 0;}
-
-	RandomNumberGenerator &m_rng;
-	const unsigned long m_length;
-	unsigned long m_count;
-};
-
-//! .
-class NullStore : public Store
-{
-public:
-	NullStore(unsigned long size = ULONG_MAX) : m_size(size) {}
-	void StoreInitialize(const NameValuePairs &parameters) {}
-	unsigned long MaxRetrievable() const {return m_size;}
-	unsigned int TransferTo2(BufferedTransformation &target, unsigned long &transferBytes, const std::string &channel=NULL_CHANNEL, bool blocking=true);
-	unsigned int CopyRangeTo2(BufferedTransformation &target, unsigned long &begin, unsigned long end=ULONG_MAX, const std::string &channel=NULL_CHANNEL, bool blocking=true) const;
-
-private:
-	unsigned long m_size;
-};
-
-//! A Filter that pumps data into its attachment as input
-class Source : public InputRejecting<Filter>
-{
-public:
-	Source(BufferedTransformation *attachment)
-		: InputRejecting<Filter>(attachment) {}
-
-	unsigned long Pump(unsigned long pumpMax=ULONG_MAX)
-		{Pump2(pumpMax); return pumpMax;}
-	unsigned int PumpMessages(unsigned int count=UINT_MAX)
-		{PumpMessages2(count); return count;}
-	void PumpAll()
-		{PumpAll2();}
-	virtual unsigned int Pump2(unsigned long &byteCount, bool blocking=true) =0;
-	virtual unsigned int PumpMessages2(unsigned int &messageCount, bool blocking=true) =0;
-	virtual unsigned int PumpAll2(bool blocking=true);
-	virtual bool SourceExhausted() const =0;
-
-protected:
-	void SourceInitialize(bool pumpAll, const NameValuePairs &parameters)
-	{
-		IsolatedInitialize(parameters);
-		if (pumpAll)
-			PumpAll();
-	}
-};
-
-//! Turn a Store into a Source
-template <class T>
-class SourceTemplate : public Source
-{
-public:
-	SourceTemplate<T>(BufferedTransformation *attachment)
-		: Source(attachment) {}
-	SourceTemplate<T>(BufferedTransformation *attachment, T store)
-		: Source(attachment), m_store(store) {}
-	void IsolatedInitialize(const NameValuePairs &parameters)
-		{m_store.IsolatedInitialize(parameters);}
-	unsigned int Pump2(unsigned long &byteCount, bool blocking=true)
-		{return m_store.TransferTo2(*AttachedTransformation(), byteCount, NULL_CHANNEL, blocking);}
-	unsigned int PumpMessages2(unsigned int &messageCount, bool blocking=true)
-		{return m_store.TransferMessagesTo2(*AttachedTransformation(), messageCount, NULL_CHANNEL, blocking);}
-	unsigned int PumpAll2(bool blocking=true)
-		{return m_store.TransferAllTo2(*AttachedTransformation(), NULL_CHANNEL, blocking);}
-	bool SourceExhausted() const
-		{return !m_store.AnyRetrievable() && !m_store.AnyMessages();}
-	void SetAutoSignalPropagation(int propagation)
-		{m_store.SetAutoSignalPropagation(propagation);}
-	int GetAutoSignalPropagation() const
-		{return m_store.GetAutoSignalPropagation();}
-
-protected:
-	T m_store;
-};
-
-//! .
-class StringSource : public SourceTemplate<StringStore>
-{
-public:
-	StringSource(BufferedTransformation *attachment = NULL)
-		: SourceTemplate<StringStore>(attachment) {}
-	StringSource(const char *string, bool pumpAll, BufferedTransformation *attachment = NULL)
-		: SourceTemplate<StringStore>(attachment) {SourceInitialize(pumpAll, MakeParameters("InputBuffer", ConstByteArrayParameter(string)));}
-	StringSource(const byte *string, unsigned int length, bool pumpAll, BufferedTransformation *attachment = NULL)
-		: SourceTemplate<StringStore>(attachment) {SourceInitialize(pumpAll, MakeParameters("InputBuffer", ConstByteArrayParameter(string, length)));}
-
-#ifdef __MWERKS__	// CW60 workaround
-	StringSource(const std::string &string, bool pumpAll, BufferedTransformation *attachment = NULL)
-#else
-	template <class T> StringSource(const T &string, bool pumpAll, BufferedTransformation *attachment = NULL)
-#endif
-		: SourceTemplate<StringStore>(attachment) {SourceInitialize(pumpAll, MakeParameters("InputBuffer", ConstByteArrayParameter(string)));}
-};
-
-//! .
-class RandomNumberSource : public SourceTemplate<RandomNumberStore>
-{
-public:
-	RandomNumberSource(RandomNumberGenerator &rng, unsigned int length, bool pumpAll, BufferedTransformation *attachment = NULL)
-		: SourceTemplate<RandomNumberStore>(attachment, RandomNumberStore(rng, length)) {if (pumpAll) PumpAll();}
-};
-
-NAMESPACE_END
-
-#endif
+#ifndef CRYPTOPP_FILTERS_H
+#define CRYPTOPP_FILTERS_H
+
+//! \file
+
+#include "simple.h"
+#include "secblock.h"
+#include "misc.h"
+#include "smartptr.h"
+#include "queue.h"
+#include "algparam.h"
+#include <deque>
+
+NAMESPACE_BEGIN(CryptoPP)
+
+/// provides an implementation of BufferedTransformation's attachment interface
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE Filter : public BufferedTransformation, public NotCopyable
+{
+public:
+	Filter(BufferedTransformation *attachment = NULL);
+
+	bool Attachable() {return true;}
+	BufferedTransformation *AttachedTransformation();
+	const BufferedTransformation *AttachedTransformation() const;
+	void Detach(BufferedTransformation *newAttachment = NULL);
+
+	size_t TransferTo2(BufferedTransformation &target, lword &transferBytes, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true);
+	size_t CopyRangeTo2(BufferedTransformation &target, lword &begin, lword end=LWORD_MAX, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true) const;
+
+	void Initialize(const NameValuePairs &parameters=g_nullNameValuePairs, int propagation=-1);
+	bool Flush(bool hardFlush, int propagation=-1, bool blocking=true);
+	bool MessageSeriesEnd(int propagation=-1, bool blocking=true);
+
+protected:
+	virtual BufferedTransformation * NewDefaultAttachment() const;
+	void Insert(Filter *nextFilter);	// insert filter after this one
+
+	virtual bool ShouldPropagateMessageEnd() const {return true;}
+	virtual bool ShouldPropagateMessageSeriesEnd() const {return true;}
+
+	void PropagateInitialize(const NameValuePairs &parameters, int propagation);
+
+	size_t Output(int outputSite, const byte *inString, size_t length, int messageEnd, bool blocking, const std::string &channel=DEFAULT_CHANNEL);
+	size_t OutputModifiable(int outputSite, byte *inString, size_t length, int messageEnd, bool blocking, const std::string &channel=DEFAULT_CHANNEL);
+	bool OutputMessageEnd(int outputSite, int propagation, bool blocking, const std::string &channel=DEFAULT_CHANNEL);
+	bool OutputFlush(int outputSite, bool hardFlush, int propagation, bool blocking, const std::string &channel=DEFAULT_CHANNEL);
+	bool OutputMessageSeriesEnd(int outputSite, int propagation, bool blocking, const std::string &channel=DEFAULT_CHANNEL);
+
+private:
+	member_ptr<BufferedTransformation> m_attachment;
+	
+protected:
+	size_t m_inputPosition;
+	int m_continueAt;
+};
+
+struct CRYPTOPP_DLL FilterPutSpaceHelper
+{
+	// desiredSize is how much to ask target, bufferSize is how much to allocate in m_tempSpace
+	byte *HelpCreatePutSpace(BufferedTransformation &target, const std::string &channel, size_t minSize, size_t desiredSize, size_t &bufferSize)
+	{
+		assert(desiredSize >= minSize && bufferSize >= minSize);
+		if (m_tempSpace.size() < minSize)
+		{
+			byte *result = target.ChannelCreatePutSpace(channel, desiredSize);
+			if (desiredSize >= minSize)
+			{
+				bufferSize = desiredSize;
+				return result;
+			}
+			m_tempSpace.New(bufferSize);
+		}
+
+		bufferSize = m_tempSpace.size();
+		return m_tempSpace.begin();
+	}
+	byte *HelpCreatePutSpace(BufferedTransformation &target, const std::string &channel, size_t minSize)
+		{return HelpCreatePutSpace(target, channel, minSize, minSize, minSize);}
+	byte *HelpCreatePutSpace(BufferedTransformation &target, const std::string &channel, size_t minSize, size_t bufferSize)
+		{return HelpCreatePutSpace(target, channel, minSize, minSize, bufferSize);}
+	SecByteBlock m_tempSpace;
+};
+
+//! measure how many byte and messages pass through, also serves as valve
+class CRYPTOPP_DLL MeterFilter : public Bufferless<Filter>
+{
+public:
+	MeterFilter(BufferedTransformation *attachment=NULL, bool transparent=true)
+		: m_transparent(transparent) {Detach(attachment); ResetMeter();}
+
+	void SetTransparent(bool transparent) {m_transparent = transparent;}
+	void AddRangeToSkip(unsigned int message, lword position, lword size, bool sortNow = true);
+	void ResetMeter();
+	void IsolatedInitialize(const NameValuePairs &parameters) {ResetMeter();}
+
+	lword GetCurrentMessageBytes() const {return m_currentMessageBytes;}
+	lword GetTotalBytes() {return m_totalBytes;}
+	unsigned int GetCurrentSeriesMessages() {return m_currentSeriesMessages;}
+	unsigned int GetTotalMessages() {return m_totalMessages;}
+	unsigned int GetTotalMessageSeries() {return m_totalMessageSeries;}
+
+	byte * CreatePutSpace(size_t &size)
+		{return AttachedTransformation()->CreatePutSpace(size);}
+	size_t Put2(const byte *begin, size_t length, int messageEnd, bool blocking);
+	size_t PutModifiable2(byte *inString, size_t length, int messageEnd, bool blocking);
+	bool IsolatedMessageSeriesEnd(bool blocking);
+
+private:
+	size_t PutMaybeModifiable(byte *inString, size_t length, int messageEnd, bool blocking, bool modifiable);
+	bool ShouldPropagateMessageEnd() const {return m_transparent;}
+	bool ShouldPropagateMessageSeriesEnd() const {return m_transparent;}
+
+	struct MessageRange
+	{
+		inline bool operator<(const MessageRange &b) const	// BCB2006 workaround: this has to be a member function
+			{return message < b.message || (message == b.message && position < b.position);}
+		unsigned int message; lword position; lword size;
+	};
+
+	bool m_transparent;
+	lword m_currentMessageBytes, m_totalBytes;
+	unsigned int m_currentSeriesMessages, m_totalMessages, m_totalMessageSeries;
+	std::deque<MessageRange> m_rangesToSkip;
+	byte *m_begin;
+	size_t m_length;
+};
+
+//! _
+class CRYPTOPP_DLL TransparentFilter : public MeterFilter
+{
+public:
+	TransparentFilter(BufferedTransformation *attachment=NULL) : MeterFilter(attachment, true) {}
+};
+
+//! _
+class CRYPTOPP_DLL OpaqueFilter : public MeterFilter
+{
+public:
+	OpaqueFilter(BufferedTransformation *attachment=NULL) : MeterFilter(attachment, false) {}
+};
+
+/*! FilterWithBufferedInput divides up the input stream into
+	a first block, a number of middle blocks, and a last block.
+	First and last blocks are optional, and middle blocks may
+	be a stream instead (i.e. blockSize == 1).
+*/
+class CRYPTOPP_DLL FilterWithBufferedInput : public Filter
+{
+public:
+	FilterWithBufferedInput(BufferedTransformation *attachment);
+	//! firstSize and lastSize may be 0, blockSize must be at least 1
+	FilterWithBufferedInput(size_t firstSize, size_t blockSize, size_t lastSize, BufferedTransformation *attachment);
+
+	void IsolatedInitialize(const NameValuePairs &parameters);
+	size_t Put2(const byte *inString, size_t length, int messageEnd, bool blocking)
+	{
+		return PutMaybeModifiable(const_cast<byte *>(inString), length, messageEnd, blocking, false);
+	}
+	size_t PutModifiable2(byte *inString, size_t length, int messageEnd, bool blocking)
+	{
+		return PutMaybeModifiable(inString, length, messageEnd, blocking, true);
+	}
+	/*! calls ForceNextPut() if hardFlush is true */
+	bool IsolatedFlush(bool hardFlush, bool blocking);
+
+	/*! The input buffer may contain more than blockSize bytes if lastSize != 0.
+		ForceNextPut() forces a call to NextPut() if this is the case.
+	*/
+	void ForceNextPut();
+
+protected:
+	bool DidFirstPut() {return m_firstInputDone;}
+
+	virtual void InitializeDerivedAndReturnNewSizes(const NameValuePairs &parameters, size_t &firstSize, size_t &blockSize, size_t &lastSize)
+		{InitializeDerived(parameters);}
+	virtual void InitializeDerived(const NameValuePairs &parameters) {}
+	// FirstPut() is called if (firstSize != 0 and totalLength >= firstSize)
+	// or (firstSize == 0 and (totalLength > 0 or a MessageEnd() is received))
+	virtual void FirstPut(const byte *inString) =0;
+	// NextPut() is called if totalLength >= firstSize+blockSize+lastSize
+	virtual void NextPutSingle(const byte *inString) {assert(false);}
+	// Same as NextPut() except length can be a multiple of blockSize
+	// Either NextPut() or NextPutMultiple() must be overriden
+	virtual void NextPutMultiple(const byte *inString, size_t length);
+	// Same as NextPutMultiple(), but inString can be modified
+	virtual void NextPutModifiable(byte *inString, size_t length)
+		{NextPutMultiple(inString, length);}
+	// LastPut() is always called
+	// if totalLength < firstSize then length == totalLength
+	// else if totalLength <= firstSize+lastSize then length == totalLength-firstSize
+	// else lastSize <= length < lastSize+blockSize
+	virtual void LastPut(const byte *inString, size_t length) =0;
+	virtual void FlushDerived() {}
+
+protected:
+	size_t PutMaybeModifiable(byte *begin, size_t length, int messageEnd, bool blocking, bool modifiable);
+	void NextPutMaybeModifiable(byte *inString, size_t length, bool modifiable)
+	{
+		if (modifiable) NextPutModifiable(inString, length);
+		else NextPutMultiple(inString, length);
+	}
+
+	// This function should no longer be used, put this here to cause a compiler error
+	// if someone tries to override NextPut().
+	virtual int NextPut(const byte *inString, size_t length) {assert(false); return 0;}
+
+	class BlockQueue
+	{
+	public:
+		void ResetQueue(size_t blockSize, size_t maxBlocks);
+		byte *GetBlock();
+		byte *GetContigousBlocks(size_t &numberOfBytes);
+		size_t GetAll(byte *outString);
+		void Put(const byte *inString, size_t length);
+		size_t CurrentSize() const {return m_size;}
+		size_t MaxSize() const {return m_buffer.size();}
+
+	private:
+		SecByteBlock m_buffer;
+		size_t m_blockSize, m_maxBlocks, m_size;
+		byte *m_begin;
+	};
+
+	size_t m_firstSize, m_blockSize, m_lastSize;
+	bool m_firstInputDone;
+	BlockQueue m_queue;
+};
+
+//! _
+class CRYPTOPP_DLL FilterWithInputQueue : public Filter
+{
+public:
+	FilterWithInputQueue(BufferedTransformation *attachment=NULL) : Filter(attachment) {}
+
+	size_t Put2(const byte *inString, size_t length, int messageEnd, bool blocking)
+	{
+		if (!blocking)
+			throw BlockingInputOnly("FilterWithInputQueue");
+		
+		m_inQueue.Put(inString, length);
+		if (messageEnd)
+		{
+			IsolatedMessageEnd(blocking);
+			Output(0, NULL, 0, messageEnd, blocking);
+		}
+		return 0;
+	}
+
+protected:
+	virtual bool IsolatedMessageEnd(bool blocking) =0;
+	void IsolatedInitialize(const NameValuePairs &parameters) {m_inQueue.Clear();}
+
+	ByteQueue m_inQueue;
+};
+
+struct BlockPaddingSchemeDef
+{
+	enum BlockPaddingScheme {NO_PADDING, ZEROS_PADDING, PKCS_PADDING, ONE_AND_ZEROS_PADDING, DEFAULT_PADDING};
+};
+
+//! Filter Wrapper for StreamTransformation, optionally handling padding/unpadding when needed
+class CRYPTOPP_DLL StreamTransformationFilter : public FilterWithBufferedInput, public BlockPaddingSchemeDef, private FilterPutSpaceHelper
+{
+public:
+	/*! DEFAULT_PADDING means PKCS_PADDING if c.MandatoryBlockSize() > 1 && c.MinLastBlockSize() == 0 (e.g. ECB or CBC mode),
+		otherwise NO_PADDING (OFB, CFB, CTR, CBC-CTS modes).
+		See http://www.weidai.com/scan-mirror/csp.html for details of the padding schemes. */
+	StreamTransformationFilter(StreamTransformation &c, BufferedTransformation *attachment = NULL, BlockPaddingScheme padding = DEFAULT_PADDING, bool allowAuthenticatedSymmetricCipher = false);
+
+	std::string AlgorithmName() const {return m_cipher.AlgorithmName();}
+
+protected:
+	void InitializeDerivedAndReturnNewSizes(const NameValuePairs &parameters, size_t &firstSize, size_t &blockSize, size_t &lastSize);
+	void FirstPut(const byte *inString);
+	void NextPutMultiple(const byte *inString, size_t length);
+	void NextPutModifiable(byte *inString, size_t length);
+	void LastPut(const byte *inString, size_t length);
+
+	static size_t LastBlockSize(StreamTransformation &c, BlockPaddingScheme padding);
+
+	StreamTransformation &m_cipher;
+	BlockPaddingScheme m_padding;
+	unsigned int m_optimalBufferSize;
+};
+
+#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
+typedef StreamTransformationFilter StreamCipherFilter;
+#endif
+
+//! Filter Wrapper for HashTransformation
+class CRYPTOPP_DLL HashFilter : public Bufferless<Filter>, private FilterPutSpaceHelper
+{
+public:
+	HashFilter(HashTransformation &hm, BufferedTransformation *attachment = NULL, bool putMessage=false, int truncatedDigestSize=-1, const std::string &messagePutChannel=DEFAULT_CHANNEL, const std::string &hashPutChannel=DEFAULT_CHANNEL);
+
+	std::string AlgorithmName() const {return m_hashModule.AlgorithmName();}
+	void IsolatedInitialize(const NameValuePairs &parameters);
+	size_t Put2(const byte *begin, size_t length, int messageEnd, bool blocking);
+	byte * CreatePutSpace(size_t &size) {return m_hashModule.CreateUpdateSpace(size);}
+
+private:
+	HashTransformation &m_hashModule;
+	bool m_putMessage;
+	unsigned int m_digestSize;
+	byte *m_space;
+	std::string m_messagePutChannel, m_hashPutChannel;
+};
+
+//! Filter Wrapper for HashTransformation
+class CRYPTOPP_DLL HashVerificationFilter : public FilterWithBufferedInput
+{
+public:
+	class HashVerificationFailed : public Exception
+	{
+	public:
+		HashVerificationFailed()
+			: Exception(DATA_INTEGRITY_CHECK_FAILED, "HashVerificationFilter: message hash or MAC not valid") {}
+	};
+
+	enum Flags {HASH_AT_END=0, HASH_AT_BEGIN=1, PUT_MESSAGE=2, PUT_HASH=4, PUT_RESULT=8, THROW_EXCEPTION=16, DEFAULT_FLAGS = HASH_AT_BEGIN | PUT_RESULT};
+	HashVerificationFilter(HashTransformation &hm, BufferedTransformation *attachment = NULL, word32 flags = DEFAULT_FLAGS, int truncatedDigestSize=-1);
+
+	std::string AlgorithmName() const {return m_hashModule.AlgorithmName();}
+	bool GetLastResult() const {return m_verified;}
+
+protected:
+	void InitializeDerivedAndReturnNewSizes(const NameValuePairs &parameters, size_t &firstSize, size_t &blockSize, size_t &lastSize);
+	void FirstPut(const byte *inString);
+	void NextPutMultiple(const byte *inString, size_t length);
+	void LastPut(const byte *inString, size_t length);
+
+private:
+	friend class AuthenticatedDecryptionFilter;
+
+	HashTransformation &m_hashModule;
+	word32 m_flags;
+	unsigned int m_digestSize;
+	bool m_verified;
+	SecByteBlock m_expectedHash;
+};
+
+typedef HashVerificationFilter HashVerifier;	// for backwards compatibility
+
+//! Filter wrapper for encrypting with AuthenticatedSymmetricCipher, optionally handling padding/unpadding when needed
+/*! Additional authenticated data should be given in channel "AAD". If putAAD is true, AAD will be Put() to the attached BufferedTransformation in channel "AAD". */
+class CRYPTOPP_DLL AuthenticatedEncryptionFilter : public StreamTransformationFilter
+{
+public:
+	/*! See StreamTransformationFilter for documentation on BlockPaddingScheme  */
+	AuthenticatedEncryptionFilter(AuthenticatedSymmetricCipher &c, BufferedTransformation *attachment = NULL, bool putAAD=false, int truncatedDigestSize=-1, const std::string &macChannel=DEFAULT_CHANNEL, BlockPaddingScheme padding = DEFAULT_PADDING);
+
+	void IsolatedInitialize(const NameValuePairs &parameters);
+	byte * ChannelCreatePutSpace(const std::string &channel, size_t &size);
+	size_t ChannelPut2(const std::string &channel, const byte *begin, size_t length, int messageEnd, bool blocking);
+	void LastPut(const byte *inString, size_t length);
+
+protected:
+	HashFilter m_hf;
+};
+
+//! Filter wrapper for decrypting with AuthenticatedSymmetricCipher, optionally handling padding/unpadding when needed
+/*! Additional authenticated data should be given in channel "AAD". */
+class CRYPTOPP_DLL AuthenticatedDecryptionFilter : public FilterWithBufferedInput, public BlockPaddingSchemeDef
+{
+public:
+	enum Flags {MAC_AT_END=0, MAC_AT_BEGIN=1, THROW_EXCEPTION=16, DEFAULT_FLAGS = THROW_EXCEPTION};
+
+	/*! See StreamTransformationFilter for documentation on BlockPaddingScheme  */
+	AuthenticatedDecryptionFilter(AuthenticatedSymmetricCipher &c, BufferedTransformation *attachment = NULL, word32 flags = DEFAULT_FLAGS, int truncatedDigestSize=-1, BlockPaddingScheme padding = DEFAULT_PADDING);
+
+	std::string AlgorithmName() const {return m_hashVerifier.AlgorithmName();}
+	byte * ChannelCreatePutSpace(const std::string &channel, size_t &size);
+	size_t ChannelPut2(const std::string &channel, const byte *begin, size_t length, int messageEnd, bool blocking);
+	bool GetLastResult() const {return m_hashVerifier.GetLastResult();}
+
+protected:
+	void InitializeDerivedAndReturnNewSizes(const NameValuePairs &parameters, size_t &firstSize, size_t &blockSize, size_t &lastSize);
+	void FirstPut(const byte *inString);
+	void NextPutMultiple(const byte *inString, size_t length);
+	void LastPut(const byte *inString, size_t length);
+
+	HashVerificationFilter m_hashVerifier;
+	StreamTransformationFilter m_streamFilter;
+};
+
+//! Filter Wrapper for PK_Signer
+class CRYPTOPP_DLL SignerFilter : public Unflushable<Filter>
+{
+public:
+	SignerFilter(RandomNumberGenerator &rng, const PK_Signer &signer, BufferedTransformation *attachment = NULL, bool putMessage=false)
+		: m_rng(rng), m_signer(signer), m_messageAccumulator(signer.NewSignatureAccumulator(rng)), m_putMessage(putMessage) {Detach(attachment);}
+
+	std::string AlgorithmName() const {return m_signer.AlgorithmName();}
+
+	void IsolatedInitialize(const NameValuePairs &parameters);
+	size_t Put2(const byte *begin, size_t length, int messageEnd, bool blocking);
+
+private:
+	RandomNumberGenerator &m_rng;
+	const PK_Signer &m_signer;
+	member_ptr<PK_MessageAccumulator> m_messageAccumulator;
+	bool m_putMessage;
+	SecByteBlock m_buf;
+};
+
+//! Filter Wrapper for PK_Verifier
+class CRYPTOPP_DLL SignatureVerificationFilter : public FilterWithBufferedInput
+{
+public:
+	class SignatureVerificationFailed : public Exception
+	{
+	public:
+		SignatureVerificationFailed()
+			: Exception(DATA_INTEGRITY_CHECK_FAILED, "VerifierFilter: digital signature not valid") {}
+	};
+
+	enum Flags {SIGNATURE_AT_END=0, SIGNATURE_AT_BEGIN=1, PUT_MESSAGE=2, PUT_SIGNATURE=4, PUT_RESULT=8, THROW_EXCEPTION=16, DEFAULT_FLAGS = SIGNATURE_AT_BEGIN | PUT_RESULT};
+	SignatureVerificationFilter(const PK_Verifier &verifier, BufferedTransformation *attachment = NULL, word32 flags = DEFAULT_FLAGS);
+
+	std::string AlgorithmName() const {return m_verifier.AlgorithmName();}
+
+	bool GetLastResult() const {return m_verified;}
+
+protected:
+	void InitializeDerivedAndReturnNewSizes(const NameValuePairs &parameters, size_t &firstSize, size_t &blockSize, size_t &lastSize);
+	void FirstPut(const byte *inString);
+	void NextPutMultiple(const byte *inString, size_t length);
+	void LastPut(const byte *inString, size_t length);
+
+private:
+	const PK_Verifier &m_verifier;
+	member_ptr<PK_MessageAccumulator> m_messageAccumulator;
+	word32 m_flags;
+	SecByteBlock m_signature;
+	bool m_verified;
+};
+
+typedef SignatureVerificationFilter VerifierFilter;	// for backwards compatibility
+
+//! Redirect input to another BufferedTransformation without owning it
+class CRYPTOPP_DLL Redirector : public CustomSignalPropagation<Sink>
+{
+public:
+	enum Behavior
+	{
+		DATA_ONLY = 0x00,
+		PASS_SIGNALS = 0x01,
+		PASS_WAIT_OBJECTS = 0x02,
+		PASS_EVERYTHING = PASS_SIGNALS | PASS_WAIT_OBJECTS
+	};
+
+	Redirector() : m_target(NULL), m_behavior(PASS_EVERYTHING) {}
+	Redirector(BufferedTransformation &target, Behavior behavior=PASS_EVERYTHING)
+		: m_target(&target), m_behavior(behavior) {}
+
+	void Redirect(BufferedTransformation &target) {m_target = &target;}
+	void StopRedirection() {m_target = NULL;}
+
+	Behavior GetBehavior() {return (Behavior) m_behavior;}
+	void SetBehavior(Behavior behavior) {m_behavior=behavior;}
+	bool GetPassSignals() const {return (m_behavior & PASS_SIGNALS) != 0;}
+	void SetPassSignals(bool pass) { if (pass) m_behavior |= PASS_SIGNALS; else m_behavior &= ~(word32) PASS_SIGNALS; }
+	bool GetPassWaitObjects() const {return (m_behavior & PASS_WAIT_OBJECTS) != 0;}
+	void SetPassWaitObjects(bool pass) { if (pass) m_behavior |= PASS_WAIT_OBJECTS; else m_behavior &= ~(word32) PASS_WAIT_OBJECTS; }
+
+	bool CanModifyInput() const
+		{return m_target ? m_target->CanModifyInput() : false;}
+
+	void Initialize(const NameValuePairs &parameters, int propagation);
+	byte * CreatePutSpace(size_t &size)
+		{return m_target ? m_target->CreatePutSpace(size) : (byte *)(size=0, NULL);}
+	size_t Put2(const byte *begin, size_t length, int messageEnd, bool blocking)
+		{return m_target ? m_target->Put2(begin, length, GetPassSignals() ? messageEnd : 0, blocking) : 0;}
+	bool Flush(bool hardFlush, int propagation=-1, bool blocking=true)
+		{return m_target && GetPassSignals() ? m_target->Flush(hardFlush, propagation, blocking) : false;}
+	bool MessageSeriesEnd(int propagation=-1, bool blocking=true)
+		{return m_target && GetPassSignals() ? m_target->MessageSeriesEnd(propagation, blocking) : false;}
+
+	byte * ChannelCreatePutSpace(const std::string &channel, size_t &size)
+		{return m_target ? m_target->ChannelCreatePutSpace(channel, size) : (byte *)(size=0, NULL);}
+	size_t ChannelPut2(const std::string &channel, const byte *begin, size_t length, int messageEnd, bool blocking)
+		{return m_target ? m_target->ChannelPut2(channel, begin, length, GetPassSignals() ? messageEnd : 0, blocking) : 0;}
+	size_t ChannelPutModifiable2(const std::string &channel, byte *begin, size_t length, int messageEnd, bool blocking)
+		{return m_target ? m_target->ChannelPutModifiable2(channel, begin, length, GetPassSignals() ? messageEnd : 0, blocking) : 0;}
+	bool ChannelFlush(const std::string &channel, bool completeFlush, int propagation=-1, bool blocking=true)
+		{return m_target && GetPassSignals() ? m_target->ChannelFlush(channel, completeFlush, propagation, blocking) : false;}
+	bool ChannelMessageSeriesEnd(const std::string &channel, int propagation=-1, bool blocking=true)
+		{return m_target && GetPassSignals() ? m_target->ChannelMessageSeriesEnd(channel, propagation, blocking) : false;}
+
+	unsigned int GetMaxWaitObjectCount() const
+		{ return m_target && GetPassWaitObjects() ? m_target->GetMaxWaitObjectCount() : 0; }
+	void GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack)
+		{ if (m_target && GetPassWaitObjects()) m_target->GetWaitObjects(container, callStack); }
+
+private:
+	BufferedTransformation *m_target;
+	word32 m_behavior;
+};
+
+// Used By ProxyFilter
+class CRYPTOPP_DLL OutputProxy : public CustomSignalPropagation<Sink>
+{
+public:
+	OutputProxy(BufferedTransformation &owner, bool passSignal) : m_owner(owner), m_passSignal(passSignal) {}
+
+	bool GetPassSignal() const {return m_passSignal;}
+	void SetPassSignal(bool passSignal) {m_passSignal = passSignal;}
+
+	byte * CreatePutSpace(size_t &size)
+		{return m_owner.AttachedTransformation()->CreatePutSpace(size);}
+	size_t Put2(const byte *begin, size_t length, int messageEnd, bool blocking)
+		{return m_owner.AttachedTransformation()->Put2(begin, length, m_passSignal ? messageEnd : 0, blocking);}
+	size_t PutModifiable2(byte *begin, size_t length, int messageEnd, bool blocking)
+		{return m_owner.AttachedTransformation()->PutModifiable2(begin, length, m_passSignal ? messageEnd : 0, blocking);}
+	void Initialize(const NameValuePairs &parameters=g_nullNameValuePairs, int propagation=-1)
+		{if (m_passSignal) m_owner.AttachedTransformation()->Initialize(parameters, propagation);}
+	bool Flush(bool hardFlush, int propagation=-1, bool blocking=true)
+		{return m_passSignal ? m_owner.AttachedTransformation()->Flush(hardFlush, propagation, blocking) : false;}
+	bool MessageSeriesEnd(int propagation=-1, bool blocking=true)
+		{return m_passSignal ? m_owner.AttachedTransformation()->MessageSeriesEnd(propagation, blocking) : false;}
+
+	byte * ChannelCreatePutSpace(const std::string &channel, size_t &size)
+		{return m_owner.AttachedTransformation()->ChannelCreatePutSpace(channel, size);}
+	size_t ChannelPut2(const std::string &channel, const byte *begin, size_t length, int messageEnd, bool blocking)
+		{return m_owner.AttachedTransformation()->ChannelPut2(channel, begin, length, m_passSignal ? messageEnd : 0, blocking);}
+	size_t ChannelPutModifiable2(const std::string &channel, byte *begin, size_t length, int messageEnd, bool blocking)
+		{return m_owner.AttachedTransformation()->ChannelPutModifiable2(channel, begin, length, m_passSignal ? messageEnd : 0, blocking);}
+	bool ChannelFlush(const std::string &channel, bool completeFlush, int propagation=-1, bool blocking=true)
+		{return m_passSignal ? m_owner.AttachedTransformation()->ChannelFlush(channel, completeFlush, propagation, blocking) : false;}
+	bool ChannelMessageSeriesEnd(const std::string &channel, int propagation=-1, bool blocking=true)
+		{return m_passSignal ? m_owner.AttachedTransformation()->ChannelMessageSeriesEnd(channel, propagation, blocking) : false;}
+
+private:
+	BufferedTransformation &m_owner;
+	bool m_passSignal;
+};
+
+//! Base class for Filter classes that are proxies for a chain of other filters.
+class CRYPTOPP_DLL ProxyFilter : public FilterWithBufferedInput
+{
+public:
+	ProxyFilter(BufferedTransformation *filter, size_t firstSize, size_t lastSize, BufferedTransformation *attachment);
+
+	bool IsolatedFlush(bool hardFlush, bool blocking);
+
+	void SetFilter(Filter *filter);
+	void NextPutMultiple(const byte *s, size_t len);
+	void NextPutModifiable(byte *inString, size_t length);
+
+protected:
+	member_ptr<BufferedTransformation> m_filter;
+};
+
+//! simple proxy filter that doesn't modify the underlying filter's input or output
+class CRYPTOPP_DLL SimpleProxyFilter : public ProxyFilter
+{
+public:
+	SimpleProxyFilter(BufferedTransformation *filter, BufferedTransformation *attachment)
+		: ProxyFilter(filter, 0, 0, attachment) {}
+
+	void FirstPut(const byte *) {}
+	void LastPut(const byte *, size_t) {m_filter->MessageEnd();}
+};
+
+//! proxy for the filter created by PK_Encryptor::CreateEncryptionFilter
+/*! This class is here just to provide symmetry with VerifierFilter. */
+class CRYPTOPP_DLL PK_EncryptorFilter : public SimpleProxyFilter
+{
+public:
+	PK_EncryptorFilter(RandomNumberGenerator &rng, const PK_Encryptor &encryptor, BufferedTransformation *attachment = NULL)
+		: SimpleProxyFilter(encryptor.CreateEncryptionFilter(rng), attachment) {}
+};
+
+//! proxy for the filter created by PK_Decryptor::CreateDecryptionFilter
+/*! This class is here just to provide symmetry with SignerFilter. */
+class CRYPTOPP_DLL PK_DecryptorFilter : public SimpleProxyFilter
+{
+public:
+	PK_DecryptorFilter(RandomNumberGenerator &rng, const PK_Decryptor &decryptor, BufferedTransformation *attachment = NULL)
+		: SimpleProxyFilter(decryptor.CreateDecryptionFilter(rng), attachment) {}
+};
+
+//! Append input to a string object
+template <class T>
+class StringSinkTemplate : public Bufferless<Sink>
+{
+public:
+	// VC60 workaround: no T::char_type
+	typedef typename T::traits_type::char_type char_type;
+
+	StringSinkTemplate(T &output)
+		: m_output(&output) {assert(sizeof(output[0])==1);}
+
+	void IsolatedInitialize(const NameValuePairs &parameters)
+		{if (!parameters.GetValue("OutputStringPointer", m_output)) throw InvalidArgument("StringSink: OutputStringPointer not specified");}
+
+	size_t Put2(const byte *begin, size_t length, int messageEnd, bool blocking)
+	{
+		if (length > 0)
+		{
+			typename T::size_type size = m_output->size();
+			if (length < size && size + length > m_output->capacity())
+				m_output->reserve(2*size);
+		m_output->append((const char_type *)begin, (const char_type *)begin+length);
+		}
+		return 0;
+	}
+
+private:	
+	T *m_output;
+};
+
+//! Append input to an std::string
+CRYPTOPP_DLL_TEMPLATE_CLASS StringSinkTemplate<std::string>;
+typedef StringSinkTemplate<std::string> StringSink;
+
+//! incorporates input into RNG as additional entropy
+class RandomNumberSink : public Bufferless<Sink>
+{
+public:
+	RandomNumberSink()
+		: m_rng(NULL) {}
+
+	RandomNumberSink(RandomNumberGenerator &rng)
+		: m_rng(&rng) {}
+
+	void IsolatedInitialize(const NameValuePairs &parameters);
+	size_t Put2(const byte *begin, size_t length, int messageEnd, bool blocking);
+
+private:
+	RandomNumberGenerator *m_rng;
+};
+
+//! Copy input to a memory buffer
+class CRYPTOPP_DLL ArraySink : public Bufferless<Sink>
+{
+public:
+	ArraySink(const NameValuePairs &parameters = g_nullNameValuePairs) {IsolatedInitialize(parameters);}
+	ArraySink(byte *buf, size_t size) : m_buf(buf), m_size(size), m_total(0) {}
+
+	size_t AvailableSize() {return SaturatingSubtract(m_size, m_total);}
+	lword TotalPutLength() {return m_total;}
+
+	void IsolatedInitialize(const NameValuePairs &parameters);
+	byte * CreatePutSpace(size_t &size);
+	size_t Put2(const byte *begin, size_t length, int messageEnd, bool blocking);
+
+protected:
+	byte *m_buf;
+	size_t m_size;
+	lword m_total;
+};
+
+//! Xor input to a memory buffer
+class CRYPTOPP_DLL ArrayXorSink : public ArraySink
+{
+public:
+	ArrayXorSink(byte *buf, size_t size)
+		: ArraySink(buf, size) {}
+
+	size_t Put2(const byte *begin, size_t length, int messageEnd, bool blocking);
+	byte * CreatePutSpace(size_t &size) {return BufferedTransformation::CreatePutSpace(size);}
+};
+
+//! string-based implementation of Store interface
+class StringStore : public Store
+{
+public:
+	StringStore(const char *string = NULL)
+		{StoreInitialize(MakeParameters("InputBuffer", ConstByteArrayParameter(string)));}
+	StringStore(const byte *string, size_t length)
+		{StoreInitialize(MakeParameters("InputBuffer", ConstByteArrayParameter(string, length)));}
+	template <class T> StringStore(const T &string)
+		{StoreInitialize(MakeParameters("InputBuffer", ConstByteArrayParameter(string)));}
+
+	CRYPTOPP_DLL size_t TransferTo2(BufferedTransformation &target, lword &transferBytes, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true);
+	CRYPTOPP_DLL size_t CopyRangeTo2(BufferedTransformation &target, lword &begin, lword end=LWORD_MAX, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true) const;
+
+private:
+	CRYPTOPP_DLL void StoreInitialize(const NameValuePairs &parameters);
+
+	const byte *m_store;
+	size_t m_length, m_count;
+};
+
+//! RNG-based implementation of Source interface
+class CRYPTOPP_DLL RandomNumberStore : public Store
+{
+public:
+	RandomNumberStore()
+		: m_rng(NULL), m_length(0), m_count(0) {}
+
+	RandomNumberStore(RandomNumberGenerator &rng, lword length)
+		: m_rng(&rng), m_length(length), m_count(0) {}
+
+	bool AnyRetrievable() const {return MaxRetrievable() != 0;}
+	lword MaxRetrievable() const {return m_length-m_count;}
+
+	size_t TransferTo2(BufferedTransformation &target, lword &transferBytes, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true);
+	size_t CopyRangeTo2(BufferedTransformation &target, lword &begin, lword end=LWORD_MAX, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true) const
+	{
+		throw NotImplemented("RandomNumberStore: CopyRangeTo2() is not supported by this store");
+	}
+
+private:
+	void StoreInitialize(const NameValuePairs &parameters);
+
+	RandomNumberGenerator *m_rng;
+	lword m_length, m_count;
+};
+
+//! empty store
+class CRYPTOPP_DLL NullStore : public Store
+{
+public:
+	NullStore(lword size = ULONG_MAX) : m_size(size) {}
+	void StoreInitialize(const NameValuePairs &parameters) {}
+	lword MaxRetrievable() const {return m_size;}
+	size_t TransferTo2(BufferedTransformation &target, lword &transferBytes, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true);
+	size_t CopyRangeTo2(BufferedTransformation &target, lword &begin, lword end=LWORD_MAX, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true) const;
+
+private:
+	lword m_size;
+};
+
+//! A Filter that pumps data into its attachment as input
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE Source : public InputRejecting<Filter>
+{
+public:
+	Source(BufferedTransformation *attachment = NULL)
+		{Source::Detach(attachment);}
+
+	lword Pump(lword pumpMax=size_t(0)-1)
+		{Pump2(pumpMax); return pumpMax;}
+	unsigned int PumpMessages(unsigned int count=UINT_MAX)
+		{PumpMessages2(count); return count;}
+	void PumpAll()
+		{PumpAll2();}
+	virtual size_t Pump2(lword &byteCount, bool blocking=true) =0;
+	virtual size_t PumpMessages2(unsigned int &messageCount, bool blocking=true) =0;
+	virtual size_t PumpAll2(bool blocking=true);
+	virtual bool SourceExhausted() const =0;
+
+protected:
+	void SourceInitialize(bool pumpAll, const NameValuePairs &parameters)
+	{
+		IsolatedInitialize(parameters);
+		if (pumpAll)
+			PumpAll();
+	}
+};
+
+//! Turn a Store into a Source
+template <class T>
+class SourceTemplate : public Source
+{
+public:
+	SourceTemplate<T>(BufferedTransformation *attachment)
+		: Source(attachment) {}
+	void IsolatedInitialize(const NameValuePairs &parameters)
+		{m_store.IsolatedInitialize(parameters);}
+	size_t Pump2(lword &byteCount, bool blocking=true)
+		{return m_store.TransferTo2(*AttachedTransformation(), byteCount, DEFAULT_CHANNEL, blocking);}
+	size_t PumpMessages2(unsigned int &messageCount, bool blocking=true)
+		{return m_store.TransferMessagesTo2(*AttachedTransformation(), messageCount, DEFAULT_CHANNEL, blocking);}
+	size_t PumpAll2(bool blocking=true)
+		{return m_store.TransferAllTo2(*AttachedTransformation(), DEFAULT_CHANNEL, blocking);}
+	bool SourceExhausted() const
+		{return !m_store.AnyRetrievable() && !m_store.AnyMessages();}
+	void SetAutoSignalPropagation(int propagation)
+		{m_store.SetAutoSignalPropagation(propagation);}
+	int GetAutoSignalPropagation() const
+		{return m_store.GetAutoSignalPropagation();}
+
+protected:
+	T m_store;
+};
+
+//! string-based implementation of Source interface
+class CRYPTOPP_DLL StringSource : public SourceTemplate<StringStore>
+{
+public:
+	StringSource(BufferedTransformation *attachment = NULL)
+		: SourceTemplate<StringStore>(attachment) {}
+	//! zero terminated string as source
+	StringSource(const char *string, bool pumpAll, BufferedTransformation *attachment = NULL)
+		: SourceTemplate<StringStore>(attachment) {SourceInitialize(pumpAll, MakeParameters("InputBuffer", ConstByteArrayParameter(string)));}
+	//! binary byte array as source
+	StringSource(const byte *string, size_t length, bool pumpAll, BufferedTransformation *attachment = NULL)
+		: SourceTemplate<StringStore>(attachment) {SourceInitialize(pumpAll, MakeParameters("InputBuffer", ConstByteArrayParameter(string, length)));}
+	//! std::string as source
+	StringSource(const std::string &string, bool pumpAll, BufferedTransformation *attachment = NULL)
+		: SourceTemplate<StringStore>(attachment) {SourceInitialize(pumpAll, MakeParameters("InputBuffer", ConstByteArrayParameter(string)));}
+};
+
+//! use the third constructor for an array source
+typedef StringSource ArraySource;
+
+//! RNG-based implementation of Source interface
+class CRYPTOPP_DLL RandomNumberSource : public SourceTemplate<RandomNumberStore>
+{
+public:
+	RandomNumberSource(RandomNumberGenerator &rng, int length, bool pumpAll, BufferedTransformation *attachment = NULL)
+		: SourceTemplate<RandomNumberStore>(attachment) 
+		{SourceInitialize(pumpAll, MakeParameters("RandomNumberGeneratorPointer", &rng)("RandomNumberStoreSize", length));}
+};
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/fips140.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/fips140.h
index 6b26c490..a3e53861 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/fips140.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/fips140.h
@@ -1,47 +1,59 @@
-#ifndef CRYPTOPP_FIPS140_H
-#define CRYPTOPP_FIPS140_H
-
-/*! \file
-	FIPS 140 related functions and classes.
-*/
-
-#include "cryptlib.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-//! exception thrown when a crypto algorithm is used after a self test fails
-class SelfTestFailure : public Exception
-{
-public:
-	explicit SelfTestFailure(const std::string &s) : Exception(OTHER_ERROR, s) {}
-};
-
-//! returns whether FIPS 140-2 compliance features were enabled at compile time
-bool FIPS_140_2_ComplianceEnabled();
-
-//! enum values representing status of the power-up self test
-enum PowerUpSelfTestStatus {POWER_UP_SELF_TEST_NOT_DONE, POWER_UP_SELF_TEST_FAILED, POWER_UP_SELF_TEST_PASSED};
-
-//! perform the power-up self test, and set the self test status
-void DoPowerUpSelfTest(const char *moduleFilename, const byte *expectedModuleSha1Digest);
-
-//! set the power-up self test status to POWER_UP_SELF_TEST_FAILED
-void SimulatePowerUpSelfTestFailure();
-
-//! return the current power-up self test status
-PowerUpSelfTestStatus GetPowerUpSelfTestStatus();
-
-// this is used by Algorithm constructor to allow Algorithm objects to be constructed for the self test
-bool PowerUpSelfTestInProgressOnThisThread();
-
-void SetPowerUpSelfTestInProgressOnThisThread(bool inProgress);
-
-void SignaturePairwiseConsistencyTest(const PK_Signer &signer, const PK_Verifier &verifier);
-void EncryptionPairwiseConsistencyTest(const PK_Encryptor &encryptor, const PK_Decryptor &decryptor);
-
-void SignaturePairwiseConsistencyTest_FIPS_140_Only(const PK_Signer &signer, const PK_Verifier &verifier);
-void EncryptionPairwiseConsistencyTest_FIPS_140_Only(const PK_Encryptor &encryptor, const PK_Decryptor &decryptor);
-
-NAMESPACE_END
-
-#endif
+#ifndef CRYPTOPP_FIPS140_H
+#define CRYPTOPP_FIPS140_H
+
+/*! \file
+	FIPS 140 related functions and classes.
+*/
+
+#include "cryptlib.h"
+#include "secblock.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+//! exception thrown when a crypto algorithm is used after a self test fails
+class CRYPTOPP_DLL SelfTestFailure : public Exception
+{
+public:
+	explicit SelfTestFailure(const std::string &s) : Exception(OTHER_ERROR, s) {}
+};
+
+//! returns whether FIPS 140-2 compliance features were enabled at compile time
+CRYPTOPP_DLL bool CRYPTOPP_API FIPS_140_2_ComplianceEnabled();
+
+//! enum values representing status of the power-up self test
+enum PowerUpSelfTestStatus {POWER_UP_SELF_TEST_NOT_DONE, POWER_UP_SELF_TEST_FAILED, POWER_UP_SELF_TEST_PASSED};
+
+//! perform the power-up self test, and set the self test status
+CRYPTOPP_DLL void CRYPTOPP_API DoPowerUpSelfTest(const char *moduleFilename, const byte *expectedModuleMac);
+
+//! perform the power-up self test using the filename of this DLL and the embedded module MAC
+CRYPTOPP_DLL void CRYPTOPP_API DoDllPowerUpSelfTest();
+
+//! set the power-up self test status to POWER_UP_SELF_TEST_FAILED
+CRYPTOPP_DLL void CRYPTOPP_API SimulatePowerUpSelfTestFailure();
+
+//! return the current power-up self test status
+CRYPTOPP_DLL PowerUpSelfTestStatus CRYPTOPP_API GetPowerUpSelfTestStatus();
+
+typedef PowerUpSelfTestStatus (CRYPTOPP_API * PGetPowerUpSelfTestStatus)();
+
+CRYPTOPP_DLL MessageAuthenticationCode * CRYPTOPP_API NewIntegrityCheckingMAC();
+
+CRYPTOPP_DLL bool CRYPTOPP_API IntegrityCheckModule(const char *moduleFilename, const byte *expectedModuleMac, SecByteBlock *pActualMac = NULL, unsigned long *pMacFileLocation = NULL);
+
+// this is used by Algorithm constructor to allow Algorithm objects to be constructed for the self test
+bool PowerUpSelfTestInProgressOnThisThread();
+
+void SetPowerUpSelfTestInProgressOnThisThread(bool inProgress);
+
+void SignaturePairwiseConsistencyTest(const PK_Signer &signer, const PK_Verifier &verifier);
+void EncryptionPairwiseConsistencyTest(const PK_Encryptor &encryptor, const PK_Decryptor &decryptor);
+
+void SignaturePairwiseConsistencyTest_FIPS_140_Only(const PK_Signer &signer, const PK_Verifier &verifier);
+void EncryptionPairwiseConsistencyTest_FIPS_140_Only(const PK_Encryptor &encryptor, const PK_Decryptor &decryptor);
+
+#define CRYPTOPP_DUMMY_DLL_MAC "MAC_51f34b8db820ae8"
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/fltrimpl.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/fltrimpl.h
index 2624f7b7..4087d7d9 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/fltrimpl.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/fltrimpl.h
@@ -1,42 +1,67 @@
-#ifndef CRYPTOPP_FLTRIMPL_H
-#define CRYPTOPP_FLTRIMPL_H
-
-#define FILTER_BEGIN	\
-	switch (m_continueAt)	\
-	{	\
-	case 0:	\
-		m_inputPosition = 0;
-
-#define FILTER_END_NO_MESSAGE_END_NO_RETURN	\
-		break;	\
-	default:	\
-		assert(false);	\
-	}
-
-#define FILTER_END_NO_MESSAGE_END	\
-	FILTER_END_NO_MESSAGE_END_NO_RETURN	\
-	return 0;
-
-/*
-#define FILTER_END	\
-	case -1:	\
-		if (messageEnd && Output(-1, NULL, 0, messageEnd, blocking))	\
-			return 1;	\
-	FILTER_END_NO_MESSAGE_END
-*/
-
-#define FILTER_OUTPUT2(site, statement, output, length, messageEnd)	\
-	{\
-	case site:	\
-	statement;	\
-	if (Output(site, output, length, messageEnd, blocking))	\
-		return STDMAX(1U, (unsigned int)length-m_inputPosition);\
-	}
-
-#define FILTER_OUTPUT(site, output, length, messageEnd)	\
-	FILTER_OUTPUT2(site, 0, output, length, messageEnd)
-
-#define FILTER_OUTPUT_BYTE(site, output)	\
-	FILTER_OUTPUT(site, &(const byte &)(byte)output, 1, 0)
-
-#endif
+#ifndef CRYPTOPP_FLTRIMPL_H
+#define CRYPTOPP_FLTRIMPL_H
+
+#define FILTER_BEGIN	\
+	switch (m_continueAt)	\
+	{	\
+	case 0:	\
+		m_inputPosition = 0;
+
+#define FILTER_END_NO_MESSAGE_END_NO_RETURN	\
+		break;	\
+	default:	\
+		assert(false);	\
+	}
+
+#define FILTER_END_NO_MESSAGE_END	\
+	FILTER_END_NO_MESSAGE_END_NO_RETURN	\
+	return 0;
+
+/*
+#define FILTER_END	\
+	case -1:	\
+		if (messageEnd && Output(-1, NULL, 0, messageEnd, blocking))	\
+			return 1;	\
+	FILTER_END_NO_MESSAGE_END
+*/
+
+#define FILTER_OUTPUT3(site, statement, output, length, messageEnd, channel)	\
+	{\
+	case site:	\
+	statement;	\
+	if (Output(site, output, length, messageEnd, blocking, channel))	\
+		return STDMAX(size_t(1), length-m_inputPosition);\
+	}
+
+#define FILTER_OUTPUT2(site, statement, output, length, messageEnd)	\
+	FILTER_OUTPUT3(site, statement, output, length, messageEnd, DEFAULT_CHANNEL)
+
+#define FILTER_OUTPUT(site, output, length, messageEnd)	\
+	FILTER_OUTPUT2(site, 0, output, length, messageEnd)
+
+#define FILTER_OUTPUT_BYTE(site, output)	\
+	FILTER_OUTPUT(site, &(const byte &)(byte)output, 1, 0)
+
+#define FILTER_OUTPUT2_MODIFIABLE(site, statement, output, length, messageEnd)	\
+	{\
+	case site:	\
+	statement;	\
+	if (OutputModifiable(site, output, length, messageEnd, blocking))	\
+		return STDMAX(size_t(1), length-m_inputPosition);\
+	}
+
+#define FILTER_OUTPUT_MODIFIABLE(site, output, length, messageEnd)	\
+	FILTER_OUTPUT2_MODIFIABLE(site, 0, output, length, messageEnd)
+
+#define FILTER_OUTPUT2_MAYBE_MODIFIABLE(site, statement, output, length, messageEnd, modifiable)	\
+	{\
+	case site:	\
+	statement;	\
+	if (modifiable ? OutputModifiable(site, output, length, messageEnd, blocking) : Output(site, output, length, messageEnd, blocking))	\
+		return STDMAX(size_t(1), length-m_inputPosition);\
+	}
+
+#define FILTER_OUTPUT_MAYBE_MODIFIABLE(site, output, length, messageEnd, modifiable)	\
+	FILTER_OUTPUT2_MAYBE_MODIFIABLE(site, 0, output, length, messageEnd, modifiable)
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/hex.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/hex.h
index 2925327e..006914c5 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/hex.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/hex.h
@@ -1,36 +1,36 @@
-#ifndef CRYPTOPP_HEX_H
-#define CRYPTOPP_HEX_H
-
-#include "basecode.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-//! Converts given data to base 16
-class HexEncoder : public SimpleProxyFilter
-{
-public:
-	HexEncoder(BufferedTransformation *attachment = NULL, bool uppercase = true, int outputGroupSize = 0, const std::string &separator = ":", const std::string &terminator = "")
-		: SimpleProxyFilter(new BaseN_Encoder(new Grouper), attachment)
-	{
-		IsolatedInitialize(MakeParameters("Uppercase", uppercase)("GroupSize", outputGroupSize)("Separator", ConstByteArrayParameter(separator)));
-	}
-
-	void IsolatedInitialize(const NameValuePairs &parameters);
-};
-
-//! Decode base 16 data back to bytes
-class HexDecoder : public BaseN_Decoder
-{
-public:
-	HexDecoder(BufferedTransformation *attachment = NULL)
-		: BaseN_Decoder(GetDecodingLookupArray(), 4, attachment) {}
-
-	void IsolatedInitialize(const NameValuePairs &parameters) {}
-
-private:
-	static const int *GetDecodingLookupArray();
-};
-
-NAMESPACE_END
-
-#endif
+#ifndef CRYPTOPP_HEX_H
+#define CRYPTOPP_HEX_H
+
+#include "basecode.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+//! Converts given data to base 16
+class CRYPTOPP_DLL HexEncoder : public SimpleProxyFilter
+{
+public:
+	HexEncoder(BufferedTransformation *attachment = NULL, bool uppercase = true, int outputGroupSize = 0, const std::string &separator = ":", const std::string &terminator = "")
+		: SimpleProxyFilter(new BaseN_Encoder(new Grouper), attachment)
+	{
+		IsolatedInitialize(MakeParameters(Name::Uppercase(), uppercase)(Name::GroupSize(), outputGroupSize)(Name::Separator(), ConstByteArrayParameter(separator))(Name::Terminator(), ConstByteArrayParameter(terminator)));
+	}
+
+	void IsolatedInitialize(const NameValuePairs &parameters);
+};
+
+//! Decode base 16 data back to bytes
+class CRYPTOPP_DLL HexDecoder : public BaseN_Decoder
+{
+public:
+	HexDecoder(BufferedTransformation *attachment = NULL)
+		: BaseN_Decoder(GetDefaultDecodingLookupArray(), 4, attachment) {}
+
+	void IsolatedInitialize(const NameValuePairs &parameters);
+
+private:
+	static const int * CRYPTOPP_API GetDefaultDecodingLookupArray();
+};
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/hmac.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/hmac.h
index c9d5aae8..62db5ef3 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/hmac.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/hmac.h
@@ -1,119 +1,61 @@
-// hmac.h - written and placed in the public domain by Wei Dai
-
-#ifndef CRYPTOPP_HMAC_H
-#define CRYPTOPP_HMAC_H
-
-#include "seckey.h"
-#include "secblock.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-template <class T>
-class HMAC_Base : public VariableKeyLength<16, 0, UINT_MAX>, public MessageAuthenticationCode
-{
-public:
-	static std::string StaticAlgorithmName() {return std::string("HMAC(") + T::StaticAlgorithmName() + ")";}
-
-	// put enums here for Metrowerks 4
-	enum {DIGESTSIZE=T::DIGESTSIZE, BLOCKSIZE=T::BLOCKSIZE};
-
-	HMAC_Base() : m_innerHashKeyed(false) {}
-	void UncheckedSetKey(const byte *userKey, unsigned int keylength);
-
-	void Restart();
-	void Update(const byte *input, unsigned int length);
-	void TruncatedFinal(byte *mac, unsigned int size);
-	unsigned int DigestSize() const {return DIGESTSIZE;}
-
-private:
-	void KeyInnerHash();
-
-	enum {IPAD=0x36, OPAD=0x5c};
-
-	FixedSizeSecBlock<byte, BLOCKSIZE> k_ipad, k_opad;
-	FixedSizeSecBlock<byte, DIGESTSIZE> m_innerHash;
-	T m_hash;
-	bool m_innerHashKeyed;
-};
-
-//! <a href="http://www.weidai.com/scan-mirror/mac.html#HMAC">HMAC</a>
-/*! HMAC(K, text) = H(K XOR opad, H(K XOR ipad, text)) */
-template <class T>
-class HMAC : public MessageAuthenticationCodeTemplate<HMAC_Base<T> >
-{
-public:
-	HMAC() {}
-	HMAC(const byte *key, unsigned int length=HMAC_Base<T>::DEFAULT_KEYLENGTH)
-		{SetKey(key, length);}
-};
-
-template <class T>
-void HMAC_Base<T>::UncheckedSetKey(const byte *userKey, unsigned int keylength)
-{
-	AssertValidKeyLength(keylength);
-
-	Restart();
-
-	if (keylength <= T::BLOCKSIZE)
-		memcpy(k_ipad, userKey, keylength);
-	else
-	{
-		m_hash.CalculateDigest(k_ipad, userKey, keylength);
-		keylength = T::DIGESTSIZE;
-	}
-
-	assert(keylength <= T::BLOCKSIZE);
-	memset(k_ipad+keylength, 0, T::BLOCKSIZE-keylength);
-
-	for (unsigned int i=0; i<T::BLOCKSIZE; i++)
-	{
-		k_opad[i] = k_ipad[i] ^ OPAD;
-		k_ipad[i] ^= IPAD;
-	}
-}
-
-template <class T>
-void HMAC_Base<T>::KeyInnerHash()
-{
-	assert(!m_innerHashKeyed);
-	m_hash.Update(k_ipad, T::BLOCKSIZE);
-	m_innerHashKeyed = true;
-}
-
-template <class T>
-void HMAC_Base<T>::Restart()
-{
-	if (m_innerHashKeyed)
-	{
-		m_hash.Restart();
-		m_innerHashKeyed = false;
-	}
-}
-
-template <class T>
-void HMAC_Base<T>::Update(const byte *input, unsigned int length)
-{
-	if (!m_innerHashKeyed)
-		KeyInnerHash();
-	m_hash.Update(input, length);
-}
-
-template <class T>
-void HMAC_Base<T>::TruncatedFinal(byte *mac, unsigned int size)
-{
-	ThrowIfInvalidTruncatedSize(size);
-
-	if (!m_innerHashKeyed)
-		KeyInnerHash();
-	m_hash.Final(m_innerHash);
-
-	m_hash.Update(k_opad, T::BLOCKSIZE);
-	m_hash.Update(m_innerHash, DIGESTSIZE);
-	m_hash.TruncatedFinal(mac, size);
-
-	m_innerHashKeyed = false;
-}
-
-NAMESPACE_END
-
-#endif
+// hmac.h - written and placed in the public domain by Wei Dai
+
+#ifndef CRYPTOPP_HMAC_H
+#define CRYPTOPP_HMAC_H
+
+#include "seckey.h"
+#include "secblock.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+//! _
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE HMAC_Base : public VariableKeyLength<16, 0, INT_MAX>, public MessageAuthenticationCode
+{
+public:
+	HMAC_Base() : m_innerHashKeyed(false) {}
+	void UncheckedSetKey(const byte *userKey, unsigned int keylength, const NameValuePairs &params);
+
+	void Restart();
+	void Update(const byte *input, size_t length);
+	void TruncatedFinal(byte *mac, size_t size);
+	unsigned int OptimalBlockSize() const {return const_cast<HMAC_Base*>(this)->AccessHash().OptimalBlockSize();}
+	unsigned int DigestSize() const {return const_cast<HMAC_Base*>(this)->AccessHash().DigestSize();}
+
+protected:
+	virtual HashTransformation & AccessHash() =0;
+	byte * AccessIpad() {return m_buf;}
+	byte * AccessOpad() {return m_buf + AccessHash().BlockSize();}
+	byte * AccessInnerHash() {return m_buf + 2*AccessHash().BlockSize();}
+
+private:
+	void KeyInnerHash();
+
+	SecByteBlock m_buf;
+	bool m_innerHashKeyed;
+};
+
+//! <a href="http://www.weidai.com/scan-mirror/mac.html#HMAC">HMAC</a>
+/*! HMAC(K, text) = H(K XOR opad, H(K XOR ipad, text)) */
+template <class T>
+class HMAC : public MessageAuthenticationCodeImpl<HMAC_Base, HMAC<T> >
+{
+public:
+	CRYPTOPP_CONSTANT(DIGESTSIZE=T::DIGESTSIZE)
+	CRYPTOPP_CONSTANT(BLOCKSIZE=T::BLOCKSIZE)
+
+	HMAC() {}
+	HMAC(const byte *key, size_t length=HMAC_Base::DEFAULT_KEYLENGTH)
+		{this->SetKey(key, length);}
+
+	static std::string StaticAlgorithmName() {return std::string("HMAC(") + T::StaticAlgorithmName() + ")";}
+	std::string AlgorithmName() const {return std::string("HMAC(") + m_hash.AlgorithmName() + ")";}
+
+private:
+	HashTransformation & AccessHash() {return m_hash;}
+
+	T m_hash;
+};
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/integer.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/integer.h
index 99aceaff..6d844fa5 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/integer.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/integer.h
@@ -1,439 +1,420 @@
-#ifndef CRYPTOPP_INTEGER_H
-#define CRYPTOPP_INTEGER_H
-
-/** \file */
-
-#include "cryptlib.h"
-#include "secblock.h"
-
-#include <iosfwd>
-#include <algorithm>
-
-#ifdef _M_IX86
-#	if (defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 500)) || (defined(__ICL) && (__ICL >= 500))
-#		define SSE2_INTRINSICS_AVAILABLE
-#	elif defined(_MSC_VER)
-		// _mm_free seems to be the only way to tell if the Processor Pack is installed or not
-#		include <malloc.h>
-#		if defined(_mm_free)
-#			define SSE2_INTRINSICS_AVAILABLE
-#		endif
-#	endif
-#endif
-
-NAMESPACE_BEGIN(CryptoPP)
-
-#ifdef SSE2_INTRINSICS_AVAILABLE
-	template <class T>
-	class AlignedAllocator : public AllocatorBase<T>
-	{
-	public:
-		CRYPTOPP_INHERIT_ALLOCATOR_TYPES
-
-		pointer allocate(size_type n, const void *);
-		void deallocate(void *p, size_type n);
-		pointer reallocate(T *p, size_type oldSize, size_type newSize, bool preserve)
-		{
-			return StandardReallocate(*this, p, oldSize, newSize, preserve);
-		}
-	};
-	typedef SecBlock<word, AlignedAllocator<word> > SecAlignedWordBlock;
-#else
-	typedef SecWordBlock SecAlignedWordBlock;
-#endif
-
-//! multiple precision integer and basic arithmetics
-/*! This class can represent positive and negative integers
-	with absolute value less than (256**sizeof(word)) ** (256**sizeof(int)).
-	\nosubgrouping
-*/
-class Integer : public ASN1Object
-{
-public:
-	//! \name ENUMS, EXCEPTIONS, and TYPEDEFS
-	//@{
-		//! division by zero exception
-		class DivideByZero : public Exception
-		{
-		public:
-			DivideByZero() : Exception(OTHER_ERROR, "Integer: division by zero") {}
-		};
-
-		//!
-		class RandomNumberNotFound : public Exception
-		{
-		public:
-			RandomNumberNotFound() : Exception(OTHER_ERROR, "Integer: no integer satisfies the given parameters") {}
-		};
-
-		//!
-		enum Sign {POSITIVE=0, NEGATIVE=1};
-
-		//!
-		enum Signedness {
-		//!
-			UNSIGNED,
-		//!
-			SIGNED};
-
-		//!
-		enum RandomNumberType {
-		//!
-			ANY,
-		//!
-			PRIME};
-	//@}
-
-	//! \name CREATORS
-	//@{
-		//! creates the zero integer
-		Integer();
-
-		//! copy constructor
-		Integer(const Integer& t);
-
-		//! convert from signed long
-		Integer(signed long value);
-
-		//! convert from two words
-		Integer(Sign s, word highWord, word lowWord);
-
-		//! convert from string
-		/*! str can be in base 2, 8, 10, or 16.  Base is determined by a
-			case insensitive suffix of 'h', 'o', or 'b'.  No suffix means base 10.
-		*/
-		explicit Integer(const char *str);
-		explicit Integer(const wchar_t *str);
-
-		//! convert from big-endian byte array
-		Integer(const byte *encodedInteger, unsigned int byteCount, Signedness s=UNSIGNED);
-
-		//! convert from big-endian form stored in a BufferedTransformation
-		Integer(BufferedTransformation &bt, unsigned int byteCount, Signedness s=UNSIGNED);
-
-		//! convert from BER encoded byte array stored in a BufferedTransformation object
-		explicit Integer(BufferedTransformation &bt);
-
-		//! create a random integer
-		/*! The random integer created is uniformly distributed over [0, 2**bitcount). */
-		Integer(RandomNumberGenerator &rng, unsigned int bitcount);
-
-		//! avoid calling constructors for these frequently used integers
-		static const Integer &Zero();
-		//! avoid calling constructors for these frequently used integers
-		static const Integer &One();
-		//! avoid calling constructors for these frequently used integers
-		static const Integer &Two();
-
-		//! create a random integer of special type
-		/*! Ideally, the random integer created should be uniformly distributed
-			over {x | min <= x <= max and x is of rnType and x % mod == equiv}.
-			However the actual distribution may not be uniform because sequential
-			search is used to find an appropriate number from a random starting
-			point.
-			May return (with very small probability) a pseudoprime when a prime
-			is requested and max > lastSmallPrime*lastSmallPrime (lastSmallPrime
-			is declared in nbtheory.h).
-			\throw RandomNumberNotFound if the set is empty.
-		*/
-		Integer(RandomNumberGenerator &rng, const Integer &min, const Integer &max, RandomNumberType rnType=ANY, const Integer &equiv=Zero(), const Integer &mod=One());
-
-		//! return the integer 2**e
-		static Integer Power2(unsigned int e);
-	//@}
-
-	//! \name ENCODE/DECODE
-	//@{
-		//! minimum number of bytes to encode this integer
-		/*! MinEncodedSize of 0 is 1 */
-		unsigned int MinEncodedSize(Signedness=UNSIGNED) const;
-		//! encode in big-endian format
-		/*! unsigned means encode absolute value, signed means encode two's complement if negative.
-			if outputLen < MinEncodedSize, the most significant bytes will be dropped
-			if outputLen > MinEncodedSize, the most significant bytes will be padded
-		*/
-		unsigned int Encode(byte *output, unsigned int outputLen, Signedness=UNSIGNED) const;
-		//!
-		unsigned int Encode(BufferedTransformation &bt, unsigned int outputLen, Signedness=UNSIGNED) const;
-
-		//! encode using Distinguished Encoding Rules, put result into a BufferedTransformation object
-		void DEREncode(BufferedTransformation &bt) const;
-
-		//! encode absolute value as big-endian octet string
-		void DEREncodeAsOctetString(BufferedTransformation &bt, unsigned int length) const;
-
-		//! encode absolute value in OpenPGP format, return length of output
-		unsigned int OpenPGPEncode(byte *output, unsigned int bufferSize) const;
-		//! encode absolute value in OpenPGP format, put result into a BufferedTransformation object
-		unsigned int OpenPGPEncode(BufferedTransformation &bt) const;
-
-		//!
-		void Decode(const byte *input, unsigned int inputLen, Signedness=UNSIGNED);
-		//! 
-		//* Precondition: bt.MaxRetrievable() >= inputLen
-		void Decode(BufferedTransformation &bt, unsigned int inputLen, Signedness=UNSIGNED);
-
-		//!
-		void BERDecode(const byte *input, unsigned int inputLen);
-		//!
-		void BERDecode(BufferedTransformation &bt);
-
-		//! decode nonnegative value as big-endian octet string
-		void BERDecodeAsOctetString(BufferedTransformation &bt, unsigned int length);
-
-		class OpenPGPDecodeErr : public Exception
-		{
-		public: 
-			OpenPGPDecodeErr() : Exception(INVALID_DATA_FORMAT, "OpenPGP decode error") {}
-		};
-
-		//!
-		void OpenPGPDecode(const byte *input, unsigned int inputLen);
-		//!
-		void OpenPGPDecode(BufferedTransformation &bt);
-	//@}
-
-	//! \name ACCESSORS
-	//@{
-		//! return true if *this can be represented as a signed long
-		bool IsConvertableToLong() const;
-		//! return equivalent signed long if possible, otherwise undefined
-		signed long ConvertToLong() const;
-
-		//! number of significant bits = floor(log2(abs(*this))) + 1
-		unsigned int BitCount() const;
-		//! number of significant bytes = ceiling(BitCount()/8)
-		unsigned int ByteCount() const;
-		//! number of significant words = ceiling(ByteCount()/sizeof(word))
-		unsigned int WordCount() const;
-
-		//! return the i-th bit, i=0 being the least significant bit
-		bool GetBit(unsigned int i) const;
-		//! return the i-th byte
-		byte GetByte(unsigned int i) const;
-		//! return n lowest bits of *this >> i
-		unsigned long GetBits(unsigned int i, unsigned int n) const;
-
-		//!
-		bool IsZero() const {return !*this;}
-		//!
-		bool NotZero() const {return !IsZero();}
-		//!
-		bool IsNegative() const {return sign == NEGATIVE;}
-		//!
-		bool NotNegative() const {return !IsNegative();}
-		//!
-		bool IsPositive() const {return NotNegative() && NotZero();}
-		//!
-		bool NotPositive() const {return !IsPositive();}
-		//!
-		bool IsEven() const {return GetBit(0) == 0;}
-		//!
-		bool IsOdd() const	{return GetBit(0) == 1;}
-	//@}
-
-	//! \name MANIPULATORS
-	//@{
-		//!
-		Integer&  operator=(const Integer& t);
-
-		//!
-		Integer&  operator+=(const Integer& t);
-		//!
-		Integer&  operator-=(const Integer& t);
-		//!
-		Integer&  operator*=(const Integer& t)	{return *this = Times(t);}
-		//!
-		Integer&  operator/=(const Integer& t)	{return *this = DividedBy(t);}
-		//!
-		Integer&  operator%=(const Integer& t)	{return *this = Modulo(t);}
-		//!
-		Integer&  operator/=(word t)  {return *this = DividedBy(t);}
-		//!
-		Integer&  operator%=(word t)  {return *this = Modulo(t);}
-
-		//!
-		Integer&  operator<<=(unsigned int);
-		//!
-		Integer&  operator>>=(unsigned int);
-
-		//!
-		void Randomize(RandomNumberGenerator &rng, unsigned int bitcount);
-		//!
-		void Randomize(RandomNumberGenerator &rng, const Integer &min, const Integer &max);
-		//! set this Integer to a random element of {x | min <= x <= max and x is of rnType and x % mod == equiv}
-		/*! returns false if the set is empty */
-		bool Randomize(RandomNumberGenerator &rng, const Integer &min, const Integer &max, RandomNumberType rnType, const Integer &equiv=Zero(), const Integer &mod=One());
-
-		bool GenerateRandomNoThrow(RandomNumberGenerator &rng, const NameValuePairs &params = g_nullNameValuePairs);
-		void GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &params = g_nullNameValuePairs)
-		{
-			if (!GenerateRandomNoThrow(rng, params))
-				throw RandomNumberNotFound();
-		}
-
-		//! set the n-th bit to value
-		void SetBit(unsigned int n, bool value=1);
-		//! set the n-th byte to value
-		void SetByte(unsigned int n, byte value);
-
-		//!
-		void Negate();
-		//!
-		void SetPositive() {sign = POSITIVE;}
-		//!
-		void SetNegative() {if (!!(*this)) sign = NEGATIVE;}
-
-		//!
-		void swap(Integer &a);
-	//@}
-
-	//! \name UNARY OPERATORS
-	//@{
-		//!
-		bool		operator!() const;
-		//!
-		Integer 	operator+() const {return *this;}
-		//!
-		Integer 	operator-() const;
-		//!
-		Integer&	operator++();
-		//!
-		Integer&	operator--();
-		//!
-		Integer 	operator++(int) {Integer temp = *this; ++*this; return temp;}
-		//!
-		Integer 	operator--(int) {Integer temp = *this; --*this; return temp;}
-	//@}
-
-	//! \name BINARY OPERATORS
-	//@{
-		//! signed comparison
-		/*! \retval -1 if *this < a
-			\retval  0 if *this = a
-			\retval  1 if *this > a
-		*/
-		int Compare(const Integer& a) const;
-
-		//!
-		Integer Plus(const Integer &b) const;
-		//!
-		Integer Minus(const Integer &b) const;
-		//!
-		Integer Times(const Integer &b) const;
-		//!
-		Integer DividedBy(const Integer &b) const;
-		//!
-		Integer Modulo(const Integer &b) const;
-		//!
-		Integer DividedBy(word b) const;
-		//!
-		word Modulo(word b) const;
-
-		//!
-		Integer operator>>(unsigned int n) const	{return Integer(*this)>>=n;}
-		//!
-		Integer operator<<(unsigned int n) const	{return Integer(*this)<<=n;}
-	//@}
-
-	//! \name OTHER ARITHMETIC FUNCTIONS
-	//@{
-		//!
-		Integer AbsoluteValue() const;
-		//!
-		Integer Doubled() const {return Plus(*this);}
-		//!
-		Integer Squared() const {return Times(*this);}
-		//! extract square root, if negative return 0, else return floor of square root
-		Integer SquareRoot() const;
-		//! return whether this integer is a perfect square
-		bool IsSquare() const;
-
-		//! is 1 or -1
-		bool IsUnit() const;
-		//! return inverse if 1 or -1, otherwise return 0
-		Integer MultiplicativeInverse() const;
-
-		//! modular multiplication
-		friend Integer a_times_b_mod_c(const Integer &x, const Integer& y, const Integer& m);
-		//! modular exponentiation
-		friend Integer a_exp_b_mod_c(const Integer &x, const Integer& e, const Integer& m);
-
-		//! calculate r and q such that (a == d*q + r) && (0 <= r < abs(d))
-		static void Divide(Integer &r, Integer &q, const Integer &a, const Integer &d);
-		//! use a faster division algorithm when divisor is short
-		static void Divide(word &r, Integer &q, const Integer &a, word d);
-
-		//! returns same result as Divide(r, q, a, Power2(n)), but faster
-		static void DivideByPowerOf2(Integer &r, Integer &q, const Integer &a, unsigned int n);
-
-		//! greatest common divisor
-		static Integer Gcd(const Integer &a, const Integer &n);
-		//! calculate multiplicative inverse of *this mod n
-		Integer InverseMod(const Integer &n) const;
-		//!
-		word InverseMod(word n) const;
-	//@}
-
-	//! \name INPUT/OUTPUT
-	//@{
-		//!
-		friend std::istream& operator>>(std::istream& in, Integer &a);
-		//!
-		friend std::ostream& operator<<(std::ostream& out, const Integer &a);
-	//@}
-
-private:
-	friend class ModularArithmetic;
-	friend class MontgomeryRepresentation;
-	friend class HalfMontgomeryRepresentation;
-
-	Integer(word value, unsigned int length);
-
-	int PositiveCompare(const Integer &t) const;
-	friend void PositiveAdd(Integer &sum, const Integer &a, const Integer &b);
-	friend void PositiveSubtract(Integer &diff, const Integer &a, const Integer &b);
-	friend void PositiveMultiply(Integer &product, const Integer &a, const Integer &b);
-	friend void PositiveDivide(Integer &remainder, Integer &quotient, const Integer &dividend, const Integer &divisor);
-
-	SecAlignedWordBlock reg;
-	Sign sign;
-};
-
-//!
-inline bool operator==(const CryptoPP::Integer& a, const CryptoPP::Integer& b) {return a.Compare(b)==0;}
-//!
-inline bool operator!=(const CryptoPP::Integer& a, const CryptoPP::Integer& b) {return a.Compare(b)!=0;}
-//!
-inline bool operator> (const CryptoPP::Integer& a, const CryptoPP::Integer& b) {return a.Compare(b)> 0;}
-//!
-inline bool operator>=(const CryptoPP::Integer& a, const CryptoPP::Integer& b) {return a.Compare(b)>=0;}
-//!
-inline bool operator< (const CryptoPP::Integer& a, const CryptoPP::Integer& b) {return a.Compare(b)< 0;}
-//!
-inline bool operator<=(const CryptoPP::Integer& a, const CryptoPP::Integer& b) {return a.Compare(b)<=0;}
-//!
-inline CryptoPP::Integer operator+(const CryptoPP::Integer &a, const CryptoPP::Integer &b) {return a.Plus(b);}
-//!
-inline CryptoPP::Integer operator-(const CryptoPP::Integer &a, const CryptoPP::Integer &b) {return a.Minus(b);}
-//!
-inline CryptoPP::Integer operator*(const CryptoPP::Integer &a, const CryptoPP::Integer &b) {return a.Times(b);}
-//!
-inline CryptoPP::Integer operator/(const CryptoPP::Integer &a, const CryptoPP::Integer &b) {return a.DividedBy(b);}
-//!
-inline CryptoPP::Integer operator%(const CryptoPP::Integer &a, const CryptoPP::Integer &b) {return a.Modulo(b);}
-//!
-inline CryptoPP::Integer operator/(const CryptoPP::Integer &a, CryptoPP::word b) {return a.DividedBy(b);}
-//!
-inline CryptoPP::word    operator%(const CryptoPP::Integer &a, CryptoPP::word b) {return a.Modulo(b);}
-
-NAMESPACE_END
-
-NAMESPACE_BEGIN(std)
-template<> inline void swap(CryptoPP::Integer &a, CryptoPP::Integer &b)
-{
-	a.swap(b);
-}
-NAMESPACE_END
-
-#endif
+#ifndef CRYPTOPP_INTEGER_H
+#define CRYPTOPP_INTEGER_H
+
+/** \file */
+
+#include "cryptlib.h"
+#include "secblock.h"
+
+#include <iosfwd>
+#include <algorithm>
+
+NAMESPACE_BEGIN(CryptoPP)
+
+struct InitializeInteger	// used to initialize static variables
+{
+	InitializeInteger();
+};
+
+typedef SecBlock<word, AllocatorWithCleanup<word, CRYPTOPP_BOOL_X86> > IntegerSecBlock;
+
+//! multiple precision integer and basic arithmetics
+/*! This class can represent positive and negative integers
+	with absolute value less than (256**sizeof(word)) ** (256**sizeof(int)).
+	\nosubgrouping
+*/
+class CRYPTOPP_DLL Integer : private InitializeInteger, public ASN1Object
+{
+public:
+	//! \name ENUMS, EXCEPTIONS, and TYPEDEFS
+	//@{
+		//! division by zero exception
+		class DivideByZero : public Exception
+		{
+		public:
+			DivideByZero() : Exception(OTHER_ERROR, "Integer: division by zero") {}
+		};
+
+		//!
+		class RandomNumberNotFound : public Exception
+		{
+		public:
+			RandomNumberNotFound() : Exception(OTHER_ERROR, "Integer: no integer satisfies the given parameters") {}
+		};
+
+		//!
+		enum Sign {POSITIVE=0, NEGATIVE=1};
+
+		//!
+		enum Signedness {
+		//!
+			UNSIGNED,
+		//!
+			SIGNED};
+
+		//!
+		enum RandomNumberType {
+		//!
+			ANY,
+		//!
+			PRIME};
+	//@}
+
+	//! \name CREATORS
+	//@{
+		//! creates the zero integer
+		Integer();
+
+		//! copy constructor
+		Integer(const Integer& t);
+
+		//! convert from signed long
+		Integer(signed long value);
+
+		//! convert from lword
+		Integer(Sign s, lword value);
+
+		//! convert from two words
+		Integer(Sign s, word highWord, word lowWord);
+
+		//! convert from string
+		/*! str can be in base 2, 8, 10, or 16.  Base is determined by a
+			case insensitive suffix of 'h', 'o', or 'b'.  No suffix means base 10.
+		*/
+		explicit Integer(const char *str);
+		explicit Integer(const wchar_t *str);
+
+		//! convert from big-endian byte array
+		Integer(const byte *encodedInteger, size_t byteCount, Signedness s=UNSIGNED);
+
+		//! convert from big-endian form stored in a BufferedTransformation
+		Integer(BufferedTransformation &bt, size_t byteCount, Signedness s=UNSIGNED);
+
+		//! convert from BER encoded byte array stored in a BufferedTransformation object
+		explicit Integer(BufferedTransformation &bt);
+
+		//! create a random integer
+		/*! The random integer created is uniformly distributed over [0, 2**bitcount). */
+		Integer(RandomNumberGenerator &rng, size_t bitcount);
+
+		//! avoid calling constructors for these frequently used integers
+		static const Integer & CRYPTOPP_API Zero();
+		//! avoid calling constructors for these frequently used integers
+		static const Integer & CRYPTOPP_API One();
+		//! avoid calling constructors for these frequently used integers
+		static const Integer & CRYPTOPP_API Two();
+
+		//! create a random integer of special type
+		/*! Ideally, the random integer created should be uniformly distributed
+			over {x | min <= x <= max and x is of rnType and x % mod == equiv}.
+			However the actual distribution may not be uniform because sequential
+			search is used to find an appropriate number from a random starting
+			point.
+			May return (with very small probability) a pseudoprime when a prime
+			is requested and max > lastSmallPrime*lastSmallPrime (lastSmallPrime
+			is declared in nbtheory.h).
+			\throw RandomNumberNotFound if the set is empty.
+		*/
+		Integer(RandomNumberGenerator &rng, const Integer &min, const Integer &max, RandomNumberType rnType=ANY, const Integer &equiv=Zero(), const Integer &mod=One());
+
+		//! return the integer 2**e
+		static Integer CRYPTOPP_API Power2(size_t e);
+	//@}
+
+	//! \name ENCODE/DECODE
+	//@{
+		//! minimum number of bytes to encode this integer
+		/*! MinEncodedSize of 0 is 1 */
+		size_t MinEncodedSize(Signedness=UNSIGNED) const;
+		//! encode in big-endian format
+		/*! unsigned means encode absolute value, signed means encode two's complement if negative.
+			if outputLen < MinEncodedSize, the most significant bytes will be dropped
+			if outputLen > MinEncodedSize, the most significant bytes will be padded
+		*/
+		void Encode(byte *output, size_t outputLen, Signedness=UNSIGNED) const;
+		//!
+		void Encode(BufferedTransformation &bt, size_t outputLen, Signedness=UNSIGNED) const;
+
+		//! encode using Distinguished Encoding Rules, put result into a BufferedTransformation object
+		void DEREncode(BufferedTransformation &bt) const;
+
+		//! encode absolute value as big-endian octet string
+		void DEREncodeAsOctetString(BufferedTransformation &bt, size_t length) const;
+
+		//! encode absolute value in OpenPGP format, return length of output
+		size_t OpenPGPEncode(byte *output, size_t bufferSize) const;
+		//! encode absolute value in OpenPGP format, put result into a BufferedTransformation object
+		size_t OpenPGPEncode(BufferedTransformation &bt) const;
+
+		//!
+		void Decode(const byte *input, size_t inputLen, Signedness=UNSIGNED);
+		//! 
+		//* Precondition: bt.MaxRetrievable() >= inputLen
+		void Decode(BufferedTransformation &bt, size_t inputLen, Signedness=UNSIGNED);
+
+		//!
+		void BERDecode(const byte *input, size_t inputLen);
+		//!
+		void BERDecode(BufferedTransformation &bt);
+
+		//! decode nonnegative value as big-endian octet string
+		void BERDecodeAsOctetString(BufferedTransformation &bt, size_t length);
+
+		class OpenPGPDecodeErr : public Exception
+		{
+		public: 
+			OpenPGPDecodeErr() : Exception(INVALID_DATA_FORMAT, "OpenPGP decode error") {}
+		};
+
+		//!
+		void OpenPGPDecode(const byte *input, size_t inputLen);
+		//!
+		void OpenPGPDecode(BufferedTransformation &bt);
+	//@}
+
+	//! \name ACCESSORS
+	//@{
+		//! return true if *this can be represented as a signed long
+		bool IsConvertableToLong() const;
+		//! return equivalent signed long if possible, otherwise undefined
+		signed long ConvertToLong() const;
+
+		//! number of significant bits = floor(log2(abs(*this))) + 1
+		unsigned int BitCount() const;
+		//! number of significant bytes = ceiling(BitCount()/8)
+		unsigned int ByteCount() const;
+		//! number of significant words = ceiling(ByteCount()/sizeof(word))
+		unsigned int WordCount() const;
+
+		//! return the i-th bit, i=0 being the least significant bit
+		bool GetBit(size_t i) const;
+		//! return the i-th byte
+		byte GetByte(size_t i) const;
+		//! return n lowest bits of *this >> i
+		lword GetBits(size_t i, size_t n) const;
+
+		//!
+		bool IsZero() const {return !*this;}
+		//!
+		bool NotZero() const {return !IsZero();}
+		//!
+		bool IsNegative() const {return sign == NEGATIVE;}
+		//!
+		bool NotNegative() const {return !IsNegative();}
+		//!
+		bool IsPositive() const {return NotNegative() && NotZero();}
+		//!
+		bool NotPositive() const {return !IsPositive();}
+		//!
+		bool IsEven() const {return GetBit(0) == 0;}
+		//!
+		bool IsOdd() const	{return GetBit(0) == 1;}
+	//@}
+
+	//! \name MANIPULATORS
+	//@{
+		//!
+		Integer&  operator=(const Integer& t);
+
+		//!
+		Integer&  operator+=(const Integer& t);
+		//!
+		Integer&  operator-=(const Integer& t);
+		//!
+		Integer&  operator*=(const Integer& t)	{return *this = Times(t);}
+		//!
+		Integer&  operator/=(const Integer& t)	{return *this = DividedBy(t);}
+		//!
+		Integer&  operator%=(const Integer& t)	{return *this = Modulo(t);}
+		//!
+		Integer&  operator/=(word t)  {return *this = DividedBy(t);}
+		//!
+		Integer&  operator%=(word t)  {return *this = Integer(POSITIVE, 0, Modulo(t));}
+
+		//!
+		Integer&  operator<<=(size_t);
+		//!
+		Integer&  operator>>=(size_t);
+
+		//!
+		void Randomize(RandomNumberGenerator &rng, size_t bitcount);
+		//!
+		void Randomize(RandomNumberGenerator &rng, const Integer &min, const Integer &max);
+		//! set this Integer to a random element of {x | min <= x <= max and x is of rnType and x % mod == equiv}
+		/*! returns false if the set is empty */
+		bool Randomize(RandomNumberGenerator &rng, const Integer &min, const Integer &max, RandomNumberType rnType, const Integer &equiv=Zero(), const Integer &mod=One());
+
+		bool GenerateRandomNoThrow(RandomNumberGenerator &rng, const NameValuePairs &params = g_nullNameValuePairs);
+		void GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &params = g_nullNameValuePairs)
+		{
+			if (!GenerateRandomNoThrow(rng, params))
+				throw RandomNumberNotFound();
+		}
+
+		//! set the n-th bit to value
+		void SetBit(size_t n, bool value=1);
+		//! set the n-th byte to value
+		void SetByte(size_t n, byte value);
+
+		//!
+		void Negate();
+		//!
+		void SetPositive() {sign = POSITIVE;}
+		//!
+		void SetNegative() {if (!!(*this)) sign = NEGATIVE;}
+
+		//!
+		void swap(Integer &a);
+	//@}
+
+	//! \name UNARY OPERATORS
+	//@{
+		//!
+		bool		operator!() const;
+		//!
+		Integer 	operator+() const {return *this;}
+		//!
+		Integer 	operator-() const;
+		//!
+		Integer&	operator++();
+		//!
+		Integer&	operator--();
+		//!
+		Integer 	operator++(int) {Integer temp = *this; ++*this; return temp;}
+		//!
+		Integer 	operator--(int) {Integer temp = *this; --*this; return temp;}
+	//@}
+
+	//! \name BINARY OPERATORS
+	//@{
+		//! signed comparison
+		/*! \retval -1 if *this < a
+			\retval  0 if *this = a
+			\retval  1 if *this > a
+		*/
+		int Compare(const Integer& a) const;
+
+		//!
+		Integer Plus(const Integer &b) const;
+		//!
+		Integer Minus(const Integer &b) const;
+		//!
+		Integer Times(const Integer &b) const;
+		//!
+		Integer DividedBy(const Integer &b) const;
+		//!
+		Integer Modulo(const Integer &b) const;
+		//!
+		Integer DividedBy(word b) const;
+		//!
+		word Modulo(word b) const;
+
+		//!
+		Integer operator>>(size_t n) const	{return Integer(*this)>>=n;}
+		//!
+		Integer operator<<(size_t n) const	{return Integer(*this)<<=n;}
+	//@}
+
+	//! \name OTHER ARITHMETIC FUNCTIONS
+	//@{
+		//!
+		Integer AbsoluteValue() const;
+		//!
+		Integer Doubled() const {return Plus(*this);}
+		//!
+		Integer Squared() const {return Times(*this);}
+		//! extract square root, if negative return 0, else return floor of square root
+		Integer SquareRoot() const;
+		//! return whether this integer is a perfect square
+		bool IsSquare() const;
+
+		//! is 1 or -1
+		bool IsUnit() const;
+		//! return inverse if 1 or -1, otherwise return 0
+		Integer MultiplicativeInverse() const;
+
+		//! modular multiplication
+		CRYPTOPP_DLL friend Integer CRYPTOPP_API a_times_b_mod_c(const Integer &x, const Integer& y, const Integer& m);
+		//! modular exponentiation
+		CRYPTOPP_DLL friend Integer CRYPTOPP_API a_exp_b_mod_c(const Integer &x, const Integer& e, const Integer& m);
+
+		//! calculate r and q such that (a == d*q + r) && (0 <= r < abs(d))
+		static void CRYPTOPP_API Divide(Integer &r, Integer &q, const Integer &a, const Integer &d);
+		//! use a faster division algorithm when divisor is short
+		static void CRYPTOPP_API Divide(word &r, Integer &q, const Integer &a, word d);
+
+		//! returns same result as Divide(r, q, a, Power2(n)), but faster
+		static void CRYPTOPP_API DivideByPowerOf2(Integer &r, Integer &q, const Integer &a, unsigned int n);
+
+		//! greatest common divisor
+		static Integer CRYPTOPP_API Gcd(const Integer &a, const Integer &n);
+		//! calculate multiplicative inverse of *this mod n
+		Integer InverseMod(const Integer &n) const;
+		//!
+		word InverseMod(word n) const;
+	//@}
+
+	//! \name INPUT/OUTPUT
+	//@{
+		//!
+		friend CRYPTOPP_DLL std::istream& CRYPTOPP_API operator>>(std::istream& in, Integer &a);
+		//!
+		friend CRYPTOPP_DLL std::ostream& CRYPTOPP_API operator<<(std::ostream& out, const Integer &a);
+	//@}
+
+private:
+	friend class ModularArithmetic;
+	friend class MontgomeryRepresentation;
+	friend class HalfMontgomeryRepresentation;
+
+	Integer(word value, size_t length);
+
+	int PositiveCompare(const Integer &t) const;
+	friend void PositiveAdd(Integer &sum, const Integer &a, const Integer &b);
+	friend void PositiveSubtract(Integer &diff, const Integer &a, const Integer &b);
+	friend void PositiveMultiply(Integer &product, const Integer &a, const Integer &b);
+	friend void PositiveDivide(Integer &remainder, Integer &quotient, const Integer &dividend, const Integer &divisor);
+
+	IntegerSecBlock reg;
+	Sign sign;
+};
+
+//!
+inline bool operator==(const CryptoPP::Integer& a, const CryptoPP::Integer& b) {return a.Compare(b)==0;}
+//!
+inline bool operator!=(const CryptoPP::Integer& a, const CryptoPP::Integer& b) {return a.Compare(b)!=0;}
+//!
+inline bool operator> (const CryptoPP::Integer& a, const CryptoPP::Integer& b) {return a.Compare(b)> 0;}
+//!
+inline bool operator>=(const CryptoPP::Integer& a, const CryptoPP::Integer& b) {return a.Compare(b)>=0;}
+//!
+inline bool operator< (const CryptoPP::Integer& a, const CryptoPP::Integer& b) {return a.Compare(b)< 0;}
+//!
+inline bool operator<=(const CryptoPP::Integer& a, const CryptoPP::Integer& b) {return a.Compare(b)<=0;}
+//!
+inline CryptoPP::Integer operator+(const CryptoPP::Integer &a, const CryptoPP::Integer &b) {return a.Plus(b);}
+//!
+inline CryptoPP::Integer operator-(const CryptoPP::Integer &a, const CryptoPP::Integer &b) {return a.Minus(b);}
+//!
+inline CryptoPP::Integer operator*(const CryptoPP::Integer &a, const CryptoPP::Integer &b) {return a.Times(b);}
+//!
+inline CryptoPP::Integer operator/(const CryptoPP::Integer &a, const CryptoPP::Integer &b) {return a.DividedBy(b);}
+//!
+inline CryptoPP::Integer operator%(const CryptoPP::Integer &a, const CryptoPP::Integer &b) {return a.Modulo(b);}
+//!
+inline CryptoPP::Integer operator/(const CryptoPP::Integer &a, CryptoPP::word b) {return a.DividedBy(b);}
+//!
+inline CryptoPP::word    operator%(const CryptoPP::Integer &a, CryptoPP::word b) {return a.Modulo(b);}
+
+NAMESPACE_END
+
+#ifndef __BORLANDC__
+NAMESPACE_BEGIN(std)
+inline void swap(CryptoPP::Integer &a, CryptoPP::Integer &b)
+{
+	a.swap(b);
+}
+NAMESPACE_END
+#endif
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/iterhash.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/iterhash.h
index faaa57f1..cce9e821 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/iterhash.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/iterhash.h
@@ -1,121 +1,106 @@
-#ifndef CRYPTOPP_ITERHASH_H
-#define CRYPTOPP_ITERHASH_H
-
-#include "cryptlib.h"
-#include "secblock.h"
-#include "misc.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-template <class T, class BASE>
-class IteratedHashBase : public BASE
-{
-public:
-	typedef T HashWordType;
-
-	IteratedHashBase(unsigned int blockSize, unsigned int digestSize);
-	unsigned int DigestSize() const {return m_digest.size() * sizeof(T);};
-	unsigned int OptimalBlockSize() const {return BlockSize();}
-	unsigned int OptimalDataAlignment() const {return sizeof(T);}
-	void Update(const byte *input, unsigned int length);
-	byte * CreateUpdateSpace(unsigned int &size);
-	void Restart();
-
-protected:
-	T GetBitCountHi() const {return (m_countLo >> (8*sizeof(T)-3)) + (m_countHi << 3);}
-	T GetBitCountLo() const {return m_countLo << 3;}
-
-	virtual unsigned int HashMultipleBlocks(const T *input, unsigned int length);
-	void PadLastBlock(unsigned int lastBlockSize, byte padFirst=0x80);
-	virtual void Init() =0;
-	virtual void HashBlock(const T *input) =0;
-	virtual unsigned int BlockSize() const =0;
-
-	SecBlock<T> m_data;			// Data buffer
-	SecBlock<T> m_digest;		// Message digest
-
-private:
-	T m_countLo, m_countHi;
-};
-
-//! .
-template <class T, class B, class BASE>
-class IteratedHashBase2 : public IteratedHashBase<T, BASE>
-{
-public:
-	IteratedHashBase2(unsigned int blockSize, unsigned int digestSize)
-		: IteratedHashBase<T, BASE>(blockSize, digestSize) {}
-
-	typedef B ByteOrderClass;
-	typedef typename IteratedHashBase<T, BASE>::HashWordType HashWordType;
-
-	inline static void CorrectEndianess(HashWordType *out, const HashWordType *in, unsigned int byteCount)
-	{
-		ConditionalByteReverse(B::ToEnum(), out, in, byteCount);
-	}
-
-	void TruncatedFinal(byte *hash, unsigned int size);
-
-protected:
-	void HashBlock(const HashWordType *input);
-
-	virtual void vTransform(const HashWordType *data) =0;
-};
-
-//! .
-template <class T, class B, unsigned int S, class BASE = HashTransformation>
-class IteratedHash : public IteratedHashBase2<T, B, BASE>
-{
-public:
-	enum {BLOCKSIZE = S};
-
-private:
-	CRYPTOPP_COMPILE_ASSERT((BLOCKSIZE & (BLOCKSIZE - 1)) == 0);		// blockSize is a power of 2
-
-protected:
-	IteratedHash(unsigned int digestSize) : IteratedHashBase2<T, B, BASE>(BLOCKSIZE, digestSize) {}
-	unsigned int BlockSize() const {return BLOCKSIZE;}
-};
-
-template <class T, class B, unsigned int S, class M>
-class IteratedHashWithStaticTransform : public IteratedHash<T, B, S>
-{
-protected:
-	IteratedHashWithStaticTransform(unsigned int digestSize) : IteratedHash<T, B, S>(digestSize) {}
-	void vTransform(const T *data) {M::Transform(m_digest, data);}
-	std::string AlgorithmName() const {return M::StaticAlgorithmName();}
-};
-
-// *************************************************************
-
-template <class T, class B, class BASE> void IteratedHashBase2<T, B, BASE>::TruncatedFinal(byte *hash, unsigned int size)
-{
-	ThrowIfInvalidTruncatedSize(size);
-
-	PadLastBlock(BlockSize() - 2*sizeof(HashWordType));
-	CorrectEndianess(m_data, m_data, BlockSize() - 2*sizeof(HashWordType));
-
-	m_data[m_data.size()-2] = B::ToEnum() ? GetBitCountHi() : GetBitCountLo();
-	m_data[m_data.size()-1] = B::ToEnum() ? GetBitCountLo() : GetBitCountHi();
-
-	vTransform(m_data);
-	CorrectEndianess(m_digest, m_digest, DigestSize());
-	memcpy(hash, m_digest, size);
-
-	Restart();		// reinit for next use
-}
-
-template <class T, class B, class BASE> void IteratedHashBase2<T, B, BASE>::HashBlock(const HashWordType *input)
-{
-	if (NativeByteOrderIs(B::ToEnum()))
-		vTransform(input);
-	else
-	{
-		ByteReverse(m_data.begin(), input, BlockSize());
-		vTransform(m_data);
-	}
-}
-
-NAMESPACE_END
-
-#endif
+#ifndef CRYPTOPP_ITERHASH_H
+#define CRYPTOPP_ITERHASH_H
+
+#include "cryptlib.h"
+#include "secblock.h"
+#include "misc.h"
+#include "simple.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+//! exception thrown when trying to hash more data than is allowed by a hash function
+class CRYPTOPP_DLL HashInputTooLong : public InvalidDataFormat
+{
+public:
+	explicit HashInputTooLong(const std::string &alg)
+		: InvalidDataFormat("IteratedHashBase: input data exceeds maximum allowed by hash function " + alg) {}
+};
+
+//! _
+template <class T, class BASE>
+class CRYPTOPP_NO_VTABLE IteratedHashBase : public BASE
+{
+public:
+	typedef T HashWordType;
+
+	IteratedHashBase() : m_countLo(0), m_countHi(0) {}
+	unsigned int OptimalBlockSize() const {return this->BlockSize();}
+	unsigned int OptimalDataAlignment() const {return GetAlignmentOf<T>();}
+	void Update(const byte *input, size_t length);
+	byte * CreateUpdateSpace(size_t &size);
+	void Restart();
+	void TruncatedFinal(byte *digest, size_t size);
+
+protected:
+	inline T GetBitCountHi() const {return (m_countLo >> (8*sizeof(T)-3)) + (m_countHi << 3);}
+	inline T GetBitCountLo() const {return m_countLo << 3;}
+
+	void PadLastBlock(unsigned int lastBlockSize, byte padFirst=0x80);
+	virtual void Init() =0;
+
+	virtual ByteOrder GetByteOrder() const =0;
+	virtual void HashEndianCorrectedBlock(const HashWordType *data) =0;
+	virtual size_t HashMultipleBlocks(const T *input, size_t length);
+	void HashBlock(const HashWordType *input) {HashMultipleBlocks(input, this->BlockSize());}
+
+	virtual T* DataBuf() =0;
+	virtual T* StateBuf() =0;
+
+private:
+	T m_countLo, m_countHi;
+};
+
+//! _
+template <class T_HashWordType, class T_Endianness, unsigned int T_BlockSize, class T_Base = HashTransformation>
+class CRYPTOPP_NO_VTABLE IteratedHash : public IteratedHashBase<T_HashWordType, T_Base>
+{
+public:
+	typedef T_Endianness ByteOrderClass;
+	typedef T_HashWordType HashWordType;
+
+	CRYPTOPP_CONSTANT(BLOCKSIZE = T_BlockSize)
+	// BCB2006 workaround: can't use BLOCKSIZE here
+	CRYPTOPP_COMPILE_ASSERT((T_BlockSize & (T_BlockSize - 1)) == 0);	// blockSize is a power of 2
+	unsigned int BlockSize() const {return T_BlockSize;}
+
+	ByteOrder GetByteOrder() const {return T_Endianness::ToEnum();}
+
+	inline static void CorrectEndianess(HashWordType *out, const HashWordType *in, size_t byteCount)
+	{
+		ConditionalByteReverse(T_Endianness::ToEnum(), out, in, byteCount);
+	}
+
+protected:
+	T_HashWordType* DataBuf() {return this->m_data;}
+	FixedSizeSecBlock<T_HashWordType, T_BlockSize/sizeof(T_HashWordType)> m_data;
+};
+
+//! _
+template <class T_HashWordType, class T_Endianness, unsigned int T_BlockSize, unsigned int T_StateSize, class T_Transform, unsigned int T_DigestSize = 0, bool T_StateAligned = false>
+class CRYPTOPP_NO_VTABLE IteratedHashWithStaticTransform
+	: public ClonableImpl<T_Transform, AlgorithmImpl<IteratedHash<T_HashWordType, T_Endianness, T_BlockSize>, T_Transform> >
+{
+public:
+	CRYPTOPP_CONSTANT(DIGESTSIZE = T_DigestSize ? T_DigestSize : T_StateSize)
+	unsigned int DigestSize() const {return DIGESTSIZE;};
+
+protected:
+	IteratedHashWithStaticTransform() {this->Init();}
+	void HashEndianCorrectedBlock(const T_HashWordType *data) {T_Transform::Transform(this->m_state, data);}
+	void Init() {T_Transform::InitState(this->m_state);}
+
+	T_HashWordType* StateBuf() {return this->m_state;}
+	FixedSizeAlignedSecBlock<T_HashWordType, T_BlockSize/sizeof(T_HashWordType), T_StateAligned> m_state;
+};
+
+#ifndef __GNUC__
+	CRYPTOPP_DLL_TEMPLATE_CLASS IteratedHashBase<word64, HashTransformation>;
+	CRYPTOPP_STATIC_TEMPLATE_CLASS IteratedHashBase<word64, MessageAuthenticationCode>;
+
+	CRYPTOPP_DLL_TEMPLATE_CLASS IteratedHashBase<word32, HashTransformation>;
+	CRYPTOPP_STATIC_TEMPLATE_CLASS IteratedHashBase<word32, MessageAuthenticationCode>;
+#endif
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/misc.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/misc.h
index e7760c20..8425c536 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/misc.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/misc.h
@@ -1,688 +1,1282 @@
-#ifndef CRYPTOPP_MISC_H
-#define CRYPTOPP_MISC_H
-
-#include "config.h"
-#include "cryptlib.h"
-#include <assert.h>
-#include <string.h>		// CodeWarrior doesn't have memory.h
-#include <algorithm>
-#include <string>
-
-#ifdef INTEL_INTRINSICS
-#include <stdlib.h>
-#endif
-
-NAMESPACE_BEGIN(CryptoPP)
-
-// ************** compile-time assertion ***************
-
-template <bool b>
-struct CompileAssert
-{
-	static char dummy[2*b-1];
-};
-
-#define CRYPTOPP_COMPILE_ASSERT(assertion) CRYPTOPP_COMPILE_ASSERT_INSTANCE(assertion, __LINE__)
-#define CRYPTOPP_COMPILE_ASSERT_INSTANCE(assertion, instance) static CompileAssert<(assertion)> CRYPTOPP_ASSERT_JOIN(cryptopp_assert_, instance)
-#define CRYPTOPP_ASSERT_JOIN(X, Y) CRYPTOPP_DO_ASSERT_JOIN(X, Y)
-#define CRYPTOPP_DO_ASSERT_JOIN(X, Y) X##Y
-
-// ************** misc classes ***************
-
-class Empty
-{
-};
-
-template <class BASE1, class BASE2>
-class TwoBases : public BASE1, public BASE2
-{
-};
-
-template <class BASE1, class BASE2, class BASE3>
-class ThreeBases : public BASE1, public BASE2, public BASE3
-{
-};
-
-template <class T>
-class ObjectHolder
-{
-protected:
-	T m_object;
-};
-
-class NotCopyable
-{
-public:
-	NotCopyable() {}
-private:
-    NotCopyable(const NotCopyable &);
-    void operator=(const NotCopyable &);
-};
-
-// ************** misc functions ***************
-
-// can't use std::min or std::max in MSVC60 or Cygwin 1.1.0
-template <class _Tp> inline const _Tp& STDMIN(const _Tp& __a, const _Tp& __b)
-{
-	return __b < __a ? __b : __a;
-}
-
-template <class _Tp> inline const _Tp& STDMAX(const _Tp& __a, const _Tp& __b)
-{
-	return  __a < __b ? __b : __a;
-}
-
-#define RETURN_IF_NONZERO(x) unsigned int returnedValue = x; if (returnedValue) return returnedValue
-
-// this version of the macro is fastest on Pentium 3 and Pentium 4 with MSVC 6 SP5 w/ Processor Pack
-#define GETBYTE(x, y) (unsigned int)byte((x)>>(8*(y)))
-// these may be faster on other CPUs/compilers
-// #define GETBYTE(x, y) (unsigned int)(((x)>>(8*(y)))&255)
-// #define GETBYTE(x, y) (((byte *)&(x))[y])
-
-unsigned int Parity(unsigned long);
-unsigned int BytePrecision(unsigned long);
-unsigned int BitPrecision(unsigned long);
-unsigned long Crop(unsigned long, unsigned int size);
-
-inline unsigned int BitsToBytes(unsigned int bitCount)
-{
-	return ((bitCount+7)/(8));
-}
-
-inline unsigned int BytesToWords(unsigned int byteCount)
-{
-	return ((byteCount+WORD_SIZE-1)/WORD_SIZE);
-}
-
-inline unsigned int BitsToWords(unsigned int bitCount)
-{
-	return ((bitCount+WORD_BITS-1)/(WORD_BITS));
-}
-
-void xorbuf(byte *buf, const byte *mask, unsigned int count);
-void xorbuf(byte *output, const byte *input, const byte *mask, unsigned int count);
-
-template <class T>
-inline bool IsPowerOf2(T n)
-{
-	return n > 0 && (n & (n-1)) == 0;
-}
-
-template <class T1, class T2>
-inline T2 ModPowerOf2(T1 a, T2 b)
-{
-	assert(IsPowerOf2(b));
-	return T2(a) & (b-1);
-}
-
-template <class T>
-inline T RoundDownToMultipleOf(T n, T m)
-{
-	return n - (IsPowerOf2(m) ? ModPowerOf2(n, m) : (n%m));
-}
-
-template <class T>
-inline T RoundUpToMultipleOf(T n, T m)
-{
-	return RoundDownToMultipleOf(n+m-1, m);
-}
-
-template <class T>
-inline unsigned int GetAlignment(T *dummy=NULL)	// VC60 workaround
-{
-#if (_MSC_VER >= 1300)
-	return __alignof(T);
-#elif defined(__GNUC__)
-	return __alignof__(T);
-#else
-	return sizeof(T);
-#endif
-}
-
-inline bool IsAlignedOn(const void *p, unsigned int alignment)
-{
-	return IsPowerOf2(alignment) ? ModPowerOf2((unsigned int)p, alignment) == 0 : (unsigned int)p % alignment == 0;
-}
-
-template <class T>
-inline bool IsAligned(const void *p, T *dummy=NULL)	// VC60 workaround
-{
-	return IsAlignedOn(p, GetAlignment<T>());
-}
-
-#ifdef IS_LITTLE_ENDIAN
-	typedef LittleEndian NativeByteOrder;
-#else
-	typedef BigEndian NativeByteOrder;
-#endif
-
-inline ByteOrder GetNativeByteOrder()
-{
-	return NativeByteOrder::ToEnum();
-}
-
-inline bool NativeByteOrderIs(ByteOrder order)
-{
-	return order == GetNativeByteOrder();
-}
-
-template <class T>		// can't use <sstream> because GCC 2.95.2 doesn't have it
-std::string IntToString(T a, unsigned int base = 10)
-{
-	if (a == 0)
-		return "0";
-	bool negate = false;
-	if (a < 0)
-	{
-		negate = true;
-		a = 0-a;	// VC .NET does not like -a
-	}
-	std::string result;
-	while (a > 0)
-	{
-		T digit = a % base;
-		result = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;
-		a /= base;
-	}
-	if (negate)
-		result = "-" + result;
-	return result;
-}
-
-template <class T1, class T2>
-inline T1 SaturatingSubtract(T1 a, T2 b)
-{
-	CRYPTOPP_COMPILE_ASSERT_INSTANCE(T1(-1)>0, 0);	// T1 is unsigned type
-	CRYPTOPP_COMPILE_ASSERT_INSTANCE(T2(-1)>0, 1);	// T2 is unsigned type
-	return T1((a > b) ? (a - b) : 0);
-}
-
-template <class T>
-inline CipherDir GetCipherDir(const T &obj)
-{
-	return obj.IsForwardTransformation() ? ENCRYPTION : DECRYPTION;
-}
-
-// ************** rotate functions ***************
-
-template <class T> inline T rotlFixed(T x, unsigned int y)
-{
-	assert(y < sizeof(T)*8);
-	return (x<<y) | (x>>(sizeof(T)*8-y));
-}
-
-template <class T> inline T rotrFixed(T x, unsigned int y)
-{
-	assert(y < sizeof(T)*8);
-	return (x>>y) | (x<<(sizeof(T)*8-y));
-}
-
-template <class T> inline T rotlVariable(T x, unsigned int y)
-{
-	assert(y < sizeof(T)*8);
-	return (x<<y) | (x>>(sizeof(T)*8-y));
-}
-
-template <class T> inline T rotrVariable(T x, unsigned int y)
-{
-	assert(y < sizeof(T)*8);
-	return (x>>y) | (x<<(sizeof(T)*8-y));
-}
-
-template <class T> inline T rotlMod(T x, unsigned int y)
-{
-	y %= sizeof(T)*8;
-	return (x<<y) | (x>>(sizeof(T)*8-y));
-}
-
-template <class T> inline T rotrMod(T x, unsigned int y)
-{
-	y %= sizeof(T)*8;
-	return (x>>y) | (x<<(sizeof(T)*8-y));
-}
-
-#ifdef INTEL_INTRINSICS
-
-#pragma intrinsic(_lrotl, _lrotr)
-
-template<> inline word32 rotlFixed<word32>(word32 x, unsigned int y)
-{
-	assert(y < 32);
-	return y ? _lrotl(x, y) : x;
-}
-
-template<> inline word32 rotrFixed<word32>(word32 x, unsigned int y)
-{
-	assert(y < 32);
-	return y ? _lrotr(x, y) : x;
-}
-
-template<> inline word32 rotlVariable<word32>(word32 x, unsigned int y)
-{
-	assert(y < 32);
-	return _lrotl(x, y);
-}
-
-template<> inline word32 rotrVariable<word32>(word32 x, unsigned int y)
-{
-	assert(y < 32);
-	return _lrotr(x, y);
-}
-
-template<> inline word32 rotlMod<word32>(word32 x, unsigned int y)
-{
-	return _lrotl(x, y);
-}
-
-template<> inline word32 rotrMod<word32>(word32 x, unsigned int y)
-{
-	return _lrotr(x, y);
-}
-
-#endif // #ifdef INTEL_INTRINSICS
-
-#ifdef PPC_INTRINSICS
-
-template<> inline word32 rotlFixed<word32>(word32 x, unsigned int y)
-{
-	assert(y < 32);
-	return y ? __rlwinm(x,y,0,31) : x;
-}
-
-template<> inline word32 rotrFixed<word32>(word32 x, unsigned int y)
-{
-	assert(y < 32);
-	return y ? __rlwinm(x,32-y,0,31) : x;
-}
-
-template<> inline word32 rotlVariable<word32>(word32 x, unsigned int y)
-{
-	assert(y < 32);
-	return (__rlwnm(x,y,0,31));
-}
-
-template<> inline word32 rotrVariable<word32>(word32 x, unsigned int y)
-{
-	assert(y < 32);
-	return (__rlwnm(x,32-y,0,31));
-}
-
-template<> inline word32 rotlMod<word32>(word32 x, unsigned int y)
-{
-	return (__rlwnm(x,y,0,31));
-}
-
-template<> inline word32 rotrMod<word32>(word32 x, unsigned int y)
-{
-	return (__rlwnm(x,32-y,0,31));
-}
-
-#endif // #ifdef PPC_INTRINSICS
-
-// ************** endian reversal ***************
-
-template <class T>
-inline unsigned int GetByte(ByteOrder order, T value, unsigned int index)
-{
-	if (order == LITTLE_ENDIAN_ORDER)
-		return GETBYTE(value, index);
-	else
-		return GETBYTE(value, sizeof(T)-index-1);
-}
-
-inline byte ByteReverse(byte value)
-{
-	return value;
-}
-
-inline word16 ByteReverse(word16 value)
-{
-	return rotlFixed(value, 8U);
-}
-
-inline word32 ByteReverse(word32 value)
-{
-#ifdef PPC_INTRINSICS
-	// PPC: load reverse indexed instruction
-	return (word32)__lwbrx(&value,0);
-#elif defined(FAST_ROTATE)
-	// 5 instructions with rotate instruction, 9 without
-	return (rotrFixed(value, 8U) & 0xff00ff00) | (rotlFixed(value, 8U) & 0x00ff00ff);
-#else
-	// 6 instructions with rotate instruction, 8 without
-	value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
-	return rotlFixed(value, 16U);
-#endif
-}
-
-#ifdef WORD64_AVAILABLE
-inline word64 ByteReverse(word64 value)
-{
-#ifdef SLOW_WORD64
-	return (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));
-#else
-	value = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);
-	value = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);
-	return rotlFixed(value, 32U);
-#endif
-}
-#endif
-
-inline byte BitReverse(byte value)
-{
-	value = ((value & 0xAA) >> 1) | ((value & 0x55) << 1);
-	value = ((value & 0xCC) >> 2) | ((value & 0x33) << 2);
-	return rotlFixed(value, 4);
-}
-
-inline word16 BitReverse(word16 value)
-{
-	value = ((value & 0xAAAA) >> 1) | ((value & 0x5555) << 1);
-	value = ((value & 0xCCCC) >> 2) | ((value & 0x3333) << 2);
-	value = ((value & 0xF0F0) >> 4) | ((value & 0x0F0F) << 4);
-	return ByteReverse(value);
-}
-
-inline word32 BitReverse(word32 value)
-{
-	value = ((value & 0xAAAAAAAA) >> 1) | ((value & 0x55555555) << 1);
-	value = ((value & 0xCCCCCCCC) >> 2) | ((value & 0x33333333) << 2);
-	value = ((value & 0xF0F0F0F0) >> 4) | ((value & 0x0F0F0F0F) << 4);
-	return ByteReverse(value);
-}
-
-#ifdef WORD64_AVAILABLE
-inline word64 BitReverse(word64 value)
-{
-#ifdef SLOW_WORD64
-	return (word64(BitReverse(word32(value))) << 32) | BitReverse(word32(value>>32));
-#else
-	value = ((value & W64LIT(0xAAAAAAAAAAAAAAAA)) >> 1) | ((value & W64LIT(0x5555555555555555)) << 1);
-	value = ((value & W64LIT(0xCCCCCCCCCCCCCCCC)) >> 2) | ((value & W64LIT(0x3333333333333333)) << 2);
-	value = ((value & W64LIT(0xF0F0F0F0F0F0F0F0)) >> 4) | ((value & W64LIT(0x0F0F0F0F0F0F0F0F)) << 4);
-	return ByteReverse(value);
-#endif
-}
-#endif
-
-template <class T>
-inline T BitReverse(T value)
-{
-	if (sizeof(T) == 1)
-		return (T)BitReverse((byte)value);
-	else if (sizeof(T) == 2)
-		return (T)BitReverse((word16)value);
-	else if (sizeof(T) == 4)
-		return (T)BitReverse((word32)value);
-	else
-	{
-#ifdef WORD64_AVAILABLE
-		assert(sizeof(T) == 8);
-		return (T)BitReverse((word64)value);
-#else
-		assert(false);
-		return 0;
-#endif
-	}
-}
-
-template <class T>
-inline T ConditionalByteReverse(ByteOrder order, T value)
-{
-	return NativeByteOrderIs(order) ? value : ByteReverse(value);
-}
-
-template <class T>
-void ByteReverse(T *out, const T *in, unsigned int byteCount)
-{
-	assert(byteCount % sizeof(T) == 0);
-	unsigned int count = byteCount/sizeof(T);
-	for (unsigned int i=0; i<count; i++)
-		out[i] = ByteReverse(in[i]);
-}
-
-template <class T>
-inline void ConditionalByteReverse(ByteOrder order, T *out, const T *in, unsigned int byteCount)
-{
-	if (!NativeByteOrderIs(order))
-		ByteReverse(out, in, byteCount);
-	else if (in != out)
-		memcpy(out, in, byteCount);
-}
-
-template <class T>
-inline void GetUserKey(ByteOrder order, T *out, unsigned int outlen, const byte *in, unsigned int inlen)
-{
-	const unsigned int U = sizeof(T);
-	assert(inlen <= outlen*U);
-	memcpy(out, in, inlen);
-	memset((byte *)out+inlen, 0, outlen*U-inlen);
-	ConditionalByteReverse(order, out, out, RoundUpToMultipleOf(inlen, U));
-}
-
-inline byte UnalignedGetWordNonTemplate(ByteOrder order, const byte *block, byte*)
-{
-	return block[0];
-}
-
-inline word16 UnalignedGetWordNonTemplate(ByteOrder order, const byte *block, word16*)
-{
-	return (order == BIG_ENDIAN_ORDER)
-		? block[1] | (block[0] << 8)
-		: block[0] | (block[1] << 8);
-}
-
-inline word32 UnalignedGetWordNonTemplate(ByteOrder order, const byte *block, word32*)
-{
-	return (order == BIG_ENDIAN_ORDER)
-		? word32(block[3]) | (word32(block[2]) << 8) | (word32(block[1]) << 16) | (word32(block[0]) << 24)
-		: word32(block[0]) | (word32(block[1]) << 8) | (word32(block[2]) << 16) | (word32(block[3]) << 24);
-}
-
-template <class T>
-inline T UnalignedGetWord(ByteOrder order, const byte *block, T*dummy=NULL)
-{
-	return UnalignedGetWordNonTemplate(order, block, dummy);
-}
-
-inline void UnalignedPutWord(ByteOrder order, byte *block, byte value, const byte *xorBlock = NULL)
-{
-	block[0] = xorBlock ? (value ^ xorBlock[0]) : value;
-}
-
-inline void UnalignedPutWord(ByteOrder order, byte *block, word16 value, const byte *xorBlock = NULL)
-{
-	if (order == BIG_ENDIAN_ORDER)
-	{
-		block[0] = GETBYTE(value, 1);
-		block[1] = GETBYTE(value, 0);
-	}
-	else
-	{
-		block[0] = GETBYTE(value, 0);
-		block[1] = GETBYTE(value, 1);
-	}
-
-	if (xorBlock)
-	{
-		block[0] ^= xorBlock[0];
-		block[1] ^= xorBlock[1];
-	}
-}
-
-inline void UnalignedPutWord(ByteOrder order, byte *block, word32 value, const byte *xorBlock = NULL)
-{
-	if (order == BIG_ENDIAN_ORDER)
-	{
-		block[0] = GETBYTE(value, 3);
-		block[1] = GETBYTE(value, 2);
-		block[2] = GETBYTE(value, 1);
-		block[3] = GETBYTE(value, 0);
-	}
-	else
-	{
-		block[0] = GETBYTE(value, 0);
-		block[1] = GETBYTE(value, 1);
-		block[2] = GETBYTE(value, 2);
-		block[3] = GETBYTE(value, 3);
-	}
-
-	if (xorBlock)
-	{
-		block[0] ^= xorBlock[0];
-		block[1] ^= xorBlock[1];
-		block[2] ^= xorBlock[2];
-		block[3] ^= xorBlock[3];
-	}
-}
-
-template <class T>
-inline T GetWord(bool assumeAligned, ByteOrder order, const byte *block)
-{
-	if (assumeAligned)
-	{
-		assert(IsAligned<T>(block));
-		return ConditionalByteReverse(order, *reinterpret_cast<const T *>(block));
-	}
-	else
-		return UnalignedGetWord<T>(order, block);
-}
-
-template <class T>
-inline void GetWord(bool assumeAligned, ByteOrder order, T &result, const byte *block)
-{
-	result = GetWord<T>(assumeAligned, order, block);
-}
-
-template <class T>
-inline void PutWord(bool assumeAligned, ByteOrder order, byte *block, T value, const byte *xorBlock = NULL)
-{
-	if (assumeAligned)
-	{
-		assert(IsAligned<T>(block));
-		if (xorBlock)
-			*reinterpret_cast<T *>(block) = ConditionalByteReverse(order, value) ^ *reinterpret_cast<const T *>(xorBlock);
-		else
-			*reinterpret_cast<T *>(block) = ConditionalByteReverse(order, value);
-	}
-	else
-		UnalignedPutWord(order, block, value, xorBlock);
-}
-
-template <class T, class B, bool A=true>
-class GetBlock
-{
-public:
-	GetBlock(const void *block)
-		: m_block((const byte *)block) {}
-
-	template <class U>
-	inline GetBlock<T, B, A> & operator()(U &x)
-	{
-		CRYPTOPP_COMPILE_ASSERT(sizeof(U) >= sizeof(T));
-		x = GetWord<T>(A, B::ToEnum(), m_block);
-		m_block += sizeof(T);
-		return *this;
-	}
-
-private:
-	const byte *m_block;
-};
-
-template <class T, class B, bool A=true>
-class PutBlock
-{
-public:
-	PutBlock(const void *xorBlock, void *block)
-		: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}
-
-	template <class U>
-	inline PutBlock<T, B, A> & operator()(U x)
-	{
-		PutWord(A, B::ToEnum(), m_block, (T)x, m_xorBlock);
-		m_block += sizeof(T);
-		if (m_xorBlock)
-			m_xorBlock += sizeof(T);
-		return *this;
-	}
-
-private:
-	const byte *m_xorBlock;
-	byte *m_block;
-};
-
-template <class T, class B, bool A=true>
-struct BlockGetAndPut
-{
-	// function needed because of C++ grammatical ambiguity between expression-statements and declarations
-	static inline GetBlock<T, B, A> Get(const void *block) {return GetBlock<T, B, A>(block);}
-	typedef PutBlock<T, B, A> Put;
-};
-
-template <class T>
-std::string WordToString(T value, ByteOrder order = BIG_ENDIAN_ORDER)
-{
-	if (!NativeByteOrderIs(order))
-		value = ByteReverse(value);
-
-	return std::string((char *)&value, sizeof(value));
-}
-
-template <class T>
-T StringToWord(const std::string &str, ByteOrder order = BIG_ENDIAN_ORDER)
-{
-	T value = 0;
-	memcpy(&value, str.data(), STDMIN(sizeof(value), str.size()));
-	return NativeByteOrderIs(order) ? value : ByteReverse(value);
-}
-
-// ************** help remove warning on g++ ***************
-
-template <bool overflow> struct SafeShifter;
-
-template<> struct SafeShifter<true>
-{
-	template <class T>
-	static inline T RightShift(T value, unsigned int bits)
-	{
-		return 0;
-	}
-
-	template <class T>
-	static inline T LeftShift(T value, unsigned int bits)
-	{
-		return 0;
-	}
-};
-
-template<> struct SafeShifter<false>
-{
-	template <class T>
-	static inline T RightShift(T value, unsigned int bits)
-	{
-		return value >> bits;
-	}
-
-	template <class T>
-	static inline T LeftShift(T value, unsigned int bits)
-	{
-		return value << bits;
-	}
-};
-
-template <unsigned int bits, class T>
-inline T SafeRightShift(T value)
-{
-	return SafeShifter<(bits>=(8*sizeof(T)))>::RightShift(value, bits);
-}
-
-template <unsigned int bits, class T>
-inline T SafeLeftShift(T value)
-{
-	return SafeShifter<(bits>=(8*sizeof(T)))>::LeftShift(value, bits);
-}
-
-NAMESPACE_END
-
-#endif // MISC_H
+#ifndef CRYPTOPP_MISC_H
+#define CRYPTOPP_MISC_H
+
+#include "cryptlib.h"
+#include "smartptr.h"
+#include <string.h>		// for memcpy and memmove
+
+#ifdef _MSC_VER
+	#if _MSC_VER >= 1400
+		// VC2005 workaround: disable declarations that conflict with winnt.h
+		#define _interlockedbittestandset CRYPTOPP_DISABLED_INTRINSIC_1
+		#define _interlockedbittestandreset CRYPTOPP_DISABLED_INTRINSIC_2
+		#define _interlockedbittestandset64 CRYPTOPP_DISABLED_INTRINSIC_3
+		#define _interlockedbittestandreset64 CRYPTOPP_DISABLED_INTRINSIC_4
+		#include <intrin.h>
+		#undef _interlockedbittestandset
+		#undef _interlockedbittestandreset
+		#undef _interlockedbittestandset64
+		#undef _interlockedbittestandreset64
+		#define CRYPTOPP_FAST_ROTATE(x) 1
+	#elif _MSC_VER >= 1300
+		#define CRYPTOPP_FAST_ROTATE(x) ((x) == 32 | (x) == 64)
+	#else
+		#define CRYPTOPP_FAST_ROTATE(x) ((x) == 32)
+	#endif
+#elif (defined(__MWERKS__) && TARGET_CPU_PPC) || \
+	(defined(__GNUC__) && (defined(_ARCH_PWR2) || defined(_ARCH_PWR) || defined(_ARCH_PPC) || defined(_ARCH_PPC64) || defined(_ARCH_COM)))
+	#define CRYPTOPP_FAST_ROTATE(x) ((x) == 32)
+#elif defined(__GNUC__) && (CRYPTOPP_BOOL_X64 || CRYPTOPP_BOOL_X86)	// depend on GCC's peephole optimization to generate rotate instructions
+	#define CRYPTOPP_FAST_ROTATE(x) 1
+#else
+	#define CRYPTOPP_FAST_ROTATE(x) 0
+#endif
+
+#ifdef __BORLANDC__
+#include <mem.h>
+#endif
+
+#if defined(__GNUC__) && defined(__linux__)
+#define CRYPTOPP_BYTESWAP_AVAILABLE
+#include <byteswap.h>
+#endif
+
+NAMESPACE_BEGIN(CryptoPP)
+
+// ************** compile-time assertion ***************
+
+template <bool b>
+struct CompileAssert
+{
+	static char dummy[2*b-1];
+};
+
+#define CRYPTOPP_COMPILE_ASSERT(assertion) CRYPTOPP_COMPILE_ASSERT_INSTANCE(assertion, __LINE__)
+#if defined(CRYPTOPP_EXPORTS) || defined(CRYPTOPP_IMPORTS)
+#define CRYPTOPP_COMPILE_ASSERT_INSTANCE(assertion, instance)
+#else
+#define CRYPTOPP_COMPILE_ASSERT_INSTANCE(assertion, instance) static CompileAssert<(assertion)> CRYPTOPP_ASSERT_JOIN(cryptopp_assert_, instance)
+#endif
+#define CRYPTOPP_ASSERT_JOIN(X, Y) CRYPTOPP_DO_ASSERT_JOIN(X, Y)
+#define CRYPTOPP_DO_ASSERT_JOIN(X, Y) X##Y
+
+// ************** misc classes ***************
+
+class CRYPTOPP_DLL Empty
+{
+};
+
+//! _
+template <class BASE1, class BASE2>
+class CRYPTOPP_NO_VTABLE TwoBases : public BASE1, public BASE2
+{
+};
+
+//! _
+template <class BASE1, class BASE2, class BASE3>
+class CRYPTOPP_NO_VTABLE ThreeBases : public BASE1, public BASE2, public BASE3
+{
+};
+
+template <class T>
+class ObjectHolder
+{
+protected:
+	T m_object;
+};
+
+class NotCopyable
+{
+public:
+	NotCopyable() {}
+private:
+    NotCopyable(const NotCopyable &);
+    void operator=(const NotCopyable &);
+};
+
+template <class T>
+struct NewObject
+{
+	T* operator()() const {return new T;}
+};
+
+/*! This function safely initializes a static object in a multithreaded environment without using locks (for portability).
+	Note that if two threads call Ref() at the same time, they may get back different references, and one object 
+	may end up being memory leaked. This is by design.
+*/
+template <class T, class F = NewObject<T>, int instance=0>
+class Singleton
+{
+public:
+	Singleton(F objectFactory = F()) : m_objectFactory(objectFactory) {}
+
+	// prevent this function from being inlined
+	CRYPTOPP_NOINLINE const T & Ref(CRYPTOPP_NOINLINE_DOTDOTDOT) const;
+
+private:
+	F m_objectFactory;
+};
+
+template <class T, class F, int instance>
+const T & Singleton<T, F, instance>::Ref(CRYPTOPP_NOINLINE_DOTDOTDOT) const
+{
+	static volatile simple_ptr<T> s_pObject;
+	T *p = s_pObject.m_p;
+
+	if (p)
+		return *p;
+
+	T *newObject = m_objectFactory();
+	p = s_pObject.m_p;
+
+	if (p)
+	{
+		delete newObject;
+		return *p;
+	}
+
+	s_pObject.m_p = newObject;
+	return *newObject;
+}
+
+// ************** misc functions ***************
+
+#if (!__STDC_WANT_SECURE_LIB__)
+inline void memcpy_s(void *dest, size_t sizeInBytes, const void *src, size_t count)
+{
+	if (count > sizeInBytes)
+		throw InvalidArgument("memcpy_s: buffer overflow");
+	memcpy(dest, src, count);
+}
+
+inline void memmove_s(void *dest, size_t sizeInBytes, const void *src, size_t count)
+{
+	if (count > sizeInBytes)
+		throw InvalidArgument("memmove_s: buffer overflow");
+	memmove(dest, src, count);
+}
+
+#if __BORLANDC__ >= 0x620
+// C++Builder 2010 workaround: can't use std::memcpy_s because it doesn't allow 0 lengths
+#define memcpy_s CryptoPP::memcpy_s
+#define memmove_s CryptoPP::memmove_s
+#endif
+#endif
+
+inline void * memset_z(void *ptr, int value, size_t num)
+{
+// avoid extranous warning on GCC 4.3.2 Ubuntu 8.10
+#if CRYPTOPP_GCC_VERSION >= 30001
+	if (__builtin_constant_p(num) && num==0)
+		return ptr;
+#endif
+	return memset(ptr, value, num);
+}
+
+// can't use std::min or std::max in MSVC60 or Cygwin 1.1.0
+template <class T> inline const T& STDMIN(const T& a, const T& b)
+{
+	return b < a ? b : a;
+}
+
+template <class T1, class T2> inline const T1 UnsignedMin(const T1& a, const T2& b)
+{
+	CRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));
+	assert(a==0 || a>0);	// GCC workaround: get rid of the warning "comparison is always true due to limited range of data type"
+	assert(b>=0);
+
+	if (sizeof(T1)<=sizeof(T2))
+		return b < (T2)a ? (T1)b : a;
+	else
+		return (T1)b < a ? (T1)b : a;
+}
+
+template <class T> inline const T& STDMAX(const T& a, const T& b)
+{
+	return a < b ? b : a;
+}
+
+#define RETURN_IF_NONZERO(x) size_t returnedValue = x; if (returnedValue) return returnedValue
+
+// this version of the macro is fastest on Pentium 3 and Pentium 4 with MSVC 6 SP5 w/ Processor Pack
+#define GETBYTE(x, y) (unsigned int)byte((x)>>(8*(y)))
+// these may be faster on other CPUs/compilers
+// #define GETBYTE(x, y) (unsigned int)(((x)>>(8*(y)))&255)
+// #define GETBYTE(x, y) (((byte *)&(x))[y])
+
+#define CRYPTOPP_GET_BYTE_AS_BYTE(x, y) byte((x)>>(8*(y)))
+
+template <class T>
+unsigned int Parity(T value)
+{
+	for (unsigned int i=8*sizeof(value)/2; i>0; i/=2)
+		value ^= value >> i;
+	return (unsigned int)value&1;
+}
+
+template <class T>
+unsigned int BytePrecision(const T &value)
+{
+	if (!value)
+		return 0;
+
+	unsigned int l=0, h=8*sizeof(value);
+
+	while (h-l > 8)
+	{
+		unsigned int t = (l+h)/2;
+		if (value >> t)
+			l = t;
+		else
+			h = t;
+	}
+
+	return h/8;
+}
+
+template <class T>
+unsigned int BitPrecision(const T &value)
+{
+	if (!value)
+		return 0;
+
+	unsigned int l=0, h=8*sizeof(value);
+
+	while (h-l > 1)
+	{
+		unsigned int t = (l+h)/2;
+		if (value >> t)
+			l = t;
+		else
+			h = t;
+	}
+
+	return h;
+}
+
+inline unsigned int TrailingZeros(word32 v)
+{
+#if defined(__GNUC__) && CRYPTOPP_GCC_VERSION >= 30400
+	return __builtin_ctz(v);
+#elif defined(_MSC_VER) && _MSC_VER >= 1400
+	unsigned long result;
+	_BitScanForward(&result, v);
+	return result;
+#else
+	// from http://graphics.stanford.edu/~seander/bithacks.html#ZerosOnRightMultLookup
+	static const int MultiplyDeBruijnBitPosition[32] = 
+	{
+	  0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 
+	  31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9
+	};
+	return MultiplyDeBruijnBitPosition[((word32)((v & -v) * 0x077CB531U)) >> 27];
+#endif
+}
+
+inline unsigned int TrailingZeros(word64 v)
+{
+#if defined(__GNUC__) && CRYPTOPP_GCC_VERSION >= 30400
+	return __builtin_ctzll(v);
+#elif defined(_MSC_VER) && _MSC_VER >= 1400 && (defined(_M_X64) || defined(_M_IA64))
+	unsigned long result;
+	_BitScanForward64(&result, v);
+	return result;
+#else
+	return word32(v) ? TrailingZeros(word32(v)) : 32 + TrailingZeros(word32(v>>32));
+#endif
+}
+
+template <class T>
+inline T Crop(T value, size_t size)
+{
+	if (size < 8*sizeof(value))
+    	return T(value & ((T(1) << size) - 1));
+	else
+		return value;
+}
+
+template <class T1, class T2>
+inline bool SafeConvert(T1 from, T2 &to)
+{
+	to = (T2)from;
+	if (from != to || (from > 0) != (to > 0))
+		return false;
+	return true;
+}
+
+inline size_t BitsToBytes(size_t bitCount)
+{
+	return ((bitCount+7)/(8));
+}
+
+inline size_t BytesToWords(size_t byteCount)
+{
+	return ((byteCount+WORD_SIZE-1)/WORD_SIZE);
+}
+
+inline size_t BitsToWords(size_t bitCount)
+{
+	return ((bitCount+WORD_BITS-1)/(WORD_BITS));
+}
+
+inline size_t BitsToDwords(size_t bitCount)
+{
+	return ((bitCount+2*WORD_BITS-1)/(2*WORD_BITS));
+}
+
+CRYPTOPP_DLL void CRYPTOPP_API xorbuf(byte *buf, const byte *mask, size_t count);
+CRYPTOPP_DLL void CRYPTOPP_API xorbuf(byte *output, const byte *input, const byte *mask, size_t count);
+
+CRYPTOPP_DLL bool CRYPTOPP_API VerifyBufsEqual(const byte *buf1, const byte *buf2, size_t count);
+
+template <class T>
+inline bool IsPowerOf2(const T &n)
+{
+	return n > 0 && (n & (n-1)) == 0;
+}
+
+template <class T1, class T2>
+inline T2 ModPowerOf2(const T1 &a, const T2 &b)
+{
+	assert(IsPowerOf2(b));
+	return T2(a) & (b-1);
+}
+
+template <class T1, class T2>
+inline T1 RoundDownToMultipleOf(const T1 &n, const T2 &m)
+{
+	if (IsPowerOf2(m))
+		return n - ModPowerOf2(n, m);
+	else
+		return n - n%m;
+}
+
+template <class T1, class T2>
+inline T1 RoundUpToMultipleOf(const T1 &n, const T2 &m)
+{
+	if (n+m-1 < n)
+		throw InvalidArgument("RoundUpToMultipleOf: integer overflow");
+	return RoundDownToMultipleOf(n+m-1, m);
+}
+
+template <class T>
+inline unsigned int GetAlignmentOf(T *dummy=NULL)	// VC60 workaround
+{
+#ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS
+	if (sizeof(T) < 16)
+		return 1;
+#endif
+
+#if (_MSC_VER >= 1300)
+	return __alignof(T);
+#elif defined(__GNUC__)
+	return __alignof__(T);
+#elif CRYPTOPP_BOOL_SLOW_WORD64
+	return UnsignedMin(4U, sizeof(T));
+#else
+	return sizeof(T);
+#endif
+}
+
+inline bool IsAlignedOn(const void *p, unsigned int alignment)
+{
+	return alignment==1 || (IsPowerOf2(alignment) ? ModPowerOf2((size_t)p, alignment) == 0 : (size_t)p % alignment == 0);
+}
+
+template <class T>
+inline bool IsAligned(const void *p, T *dummy=NULL)	// VC60 workaround
+{
+	return IsAlignedOn(p, GetAlignmentOf<T>());
+}
+
+#ifdef IS_LITTLE_ENDIAN
+	typedef LittleEndian NativeByteOrder;
+#else
+	typedef BigEndian NativeByteOrder;
+#endif
+
+inline ByteOrder GetNativeByteOrder()
+{
+	return NativeByteOrder::ToEnum();
+}
+
+inline bool NativeByteOrderIs(ByteOrder order)
+{
+	return order == GetNativeByteOrder();
+}
+
+template <class T>
+std::string IntToString(T a, unsigned int base = 10)
+{
+	if (a == 0)
+		return "0";
+	bool negate = false;
+	if (a < 0)
+	{
+		negate = true;
+		a = 0-a;	// VC .NET does not like -a
+	}
+	std::string result;
+	while (a > 0)
+	{
+		T digit = a % base;
+		result = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;
+		a /= base;
+	}
+	if (negate)
+		result = "-" + result;
+	return result;
+}
+
+template <class T1, class T2>
+inline T1 SaturatingSubtract(const T1 &a, const T2 &b)
+{
+	return T1((a > b) ? (a - b) : 0);
+}
+
+template <class T>
+inline CipherDir GetCipherDir(const T &obj)
+{
+	return obj.IsForwardTransformation() ? ENCRYPTION : DECRYPTION;
+}
+
+CRYPTOPP_DLL void CRYPTOPP_API CallNewHandler();
+
+inline void IncrementCounterByOne(byte *inout, unsigned int s)
+{
+	for (int i=s-1, carry=1; i>=0 && carry; i--)
+		carry = !++inout[i];
+}
+
+inline void IncrementCounterByOne(byte *output, const byte *input, unsigned int s)
+{
+	int i, carry;
+	for (i=s-1, carry=1; i>=0 && carry; i--)
+		carry = ((output[i] = input[i]+1) == 0);
+	memcpy_s(output, s, input, i+1);
+}
+
+template <class T>
+inline void ConditionalSwap(bool c, T &a, T &b)
+{
+	T t = c * (a ^ b);
+	a ^= t;
+	b ^= t;
+}
+
+template <class T>
+inline void ConditionalSwapPointers(bool c, T &a, T &b)
+{
+	ptrdiff_t t = c * (a - b);
+	a -= t;
+	b += t;
+}
+
+// see http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/protect-secrets.html
+// and https://www.securecoding.cert.org/confluence/display/cplusplus/MSC06-CPP.+Be+aware+of+compiler+optimization+when+dealing+with+sensitive+data
+template <class T>
+void SecureWipeBuffer(T *buf, size_t n)
+{
+	// GCC 4.3.2 on Cygwin optimizes away the first store if this loop is done in the forward direction
+	volatile T *p = buf+n;
+	while (n--)
+		*(--p) = 0;
+}
+
+#if (_MSC_VER >= 1400 || defined(__GNUC__)) && (CRYPTOPP_BOOL_X64 || CRYPTOPP_BOOL_X86)
+
+template<> inline void SecureWipeBuffer(byte *buf, size_t n)
+{
+	volatile byte *p = buf;
+#ifdef __GNUC__
+	asm volatile("rep stosb" : "+c"(n), "+D"(p) : "a"(0) : "memory");
+#else
+	__stosb((byte *)(size_t)p, 0, n);
+#endif
+}
+
+template<> inline void SecureWipeBuffer(word16 *buf, size_t n)
+{
+	volatile word16 *p = buf;
+#ifdef __GNUC__
+	asm volatile("rep stosw" : "+c"(n), "+D"(p) : "a"(0) : "memory");
+#else
+	__stosw((word16 *)(size_t)p, 0, n);
+#endif
+}
+
+template<> inline void SecureWipeBuffer(word32 *buf, size_t n)
+{
+	volatile word32 *p = buf;
+#ifdef __GNUC__
+	asm volatile("rep stosl" : "+c"(n), "+D"(p) : "a"(0) : "memory");
+#else
+	__stosd((unsigned long *)(size_t)p, 0, n);
+#endif
+}
+
+template<> inline void SecureWipeBuffer(word64 *buf, size_t n)
+{
+#if CRYPTOPP_BOOL_X64
+	volatile word64 *p = buf;
+#ifdef __GNUC__
+	asm volatile("rep stosq" : "+c"(n), "+D"(p) : "a"(0) : "memory");
+#else
+	__stosq((word64 *)(size_t)p, 0, n);
+#endif
+#else
+	SecureWipeBuffer((word32 *)buf, 2*n);
+#endif
+}
+
+#endif	// #if (_MSC_VER >= 1400 || defined(__GNUC__)) && (CRYPTOPP_BOOL_X64 || CRYPTOPP_BOOL_X86)
+
+template <class T>
+inline void SecureWipeArray(T *buf, size_t n)
+{
+	if (sizeof(T) % 8 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word64>() == 0)
+		SecureWipeBuffer((word64 *)buf, n * (sizeof(T)/8));
+	else if (sizeof(T) % 4 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word32>() == 0)
+		SecureWipeBuffer((word32 *)buf, n * (sizeof(T)/4));
+	else if (sizeof(T) % 2 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word16>() == 0)
+		SecureWipeBuffer((word16 *)buf, n * (sizeof(T)/2));
+	else
+		SecureWipeBuffer((byte *)buf, n * sizeof(T));
+}
+
+// this function uses wcstombs(), which assumes that setlocale() has been called
+static std::string StringNarrow(const wchar_t *str, bool throwOnError = true)
+{
+#ifdef _MSC_VER
+#pragma warning(push)
+#pragma warning(disable: 4996)	//  'wcstombs': This function or variable may be unsafe.
+#endif
+	size_t size = wcstombs(NULL, str, 0);
+	if (size == size_t(0)-1)
+	{
+		if (throwOnError)
+			throw InvalidArgument("StringNarrow: wcstombs() call failed");
+		else
+			return std::string();
+	}
+	std::string result(size, 0);
+	wcstombs(&result[0], str, size);
+	return result;
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif
+}
+
+#if CRYPTOPP_BOOL_ALIGN16_ENABLED
+CRYPTOPP_DLL void * CRYPTOPP_API AlignedAllocate(size_t size);
+CRYPTOPP_DLL void CRYPTOPP_API AlignedDeallocate(void *p);
+#endif
+
+CRYPTOPP_DLL void * CRYPTOPP_API UnalignedAllocate(size_t size);
+CRYPTOPP_DLL void CRYPTOPP_API UnalignedDeallocate(void *p);
+
+// ************** rotate functions ***************
+
+template <class T> inline T rotlFixed(T x, unsigned int y)
+{
+	assert(y < sizeof(T)*8);
+	return T((x<<y) | (x>>(sizeof(T)*8-y)));
+}
+
+template <class T> inline T rotrFixed(T x, unsigned int y)
+{
+	assert(y < sizeof(T)*8);
+	return T((x>>y) | (x<<(sizeof(T)*8-y)));
+}
+
+template <class T> inline T rotlVariable(T x, unsigned int y)
+{
+	assert(y < sizeof(T)*8);
+	return T((x<<y) | (x>>(sizeof(T)*8-y)));
+}
+
+template <class T> inline T rotrVariable(T x, unsigned int y)
+{
+	assert(y < sizeof(T)*8);
+	return T((x>>y) | (x<<(sizeof(T)*8-y)));
+}
+
+template <class T> inline T rotlMod(T x, unsigned int y)
+{
+	y %= sizeof(T)*8;
+	return T((x<<y) | (x>>(sizeof(T)*8-y)));
+}
+
+template <class T> inline T rotrMod(T x, unsigned int y)
+{
+	y %= sizeof(T)*8;
+	return T((x>>y) | (x<<(sizeof(T)*8-y)));
+}
+
+#ifdef _MSC_VER
+
+template<> inline word32 rotlFixed<word32>(word32 x, unsigned int y)
+{
+	assert(y < 8*sizeof(x));
+	return y ? _lrotl(x, y) : x;
+}
+
+template<> inline word32 rotrFixed<word32>(word32 x, unsigned int y)
+{
+	assert(y < 8*sizeof(x));
+	return y ? _lrotr(x, y) : x;
+}
+
+template<> inline word32 rotlVariable<word32>(word32 x, unsigned int y)
+{
+	assert(y < 8*sizeof(x));
+	return _lrotl(x, y);
+}
+
+template<> inline word32 rotrVariable<word32>(word32 x, unsigned int y)
+{
+	assert(y < 8*sizeof(x));
+	return _lrotr(x, y);
+}
+
+template<> inline word32 rotlMod<word32>(word32 x, unsigned int y)
+{
+	return _lrotl(x, y);
+}
+
+template<> inline word32 rotrMod<word32>(word32 x, unsigned int y)
+{
+	return _lrotr(x, y);
+}
+
+#endif // #ifdef _MSC_VER
+
+#if _MSC_VER >= 1300 && !defined(__INTEL_COMPILER)
+// Intel C++ Compiler 10.0 calls a function instead of using the rotate instruction when using these instructions
+
+template<> inline word64 rotlFixed<word64>(word64 x, unsigned int y)
+{
+	assert(y < 8*sizeof(x));
+	return y ? _rotl64(x, y) : x;
+}
+
+template<> inline word64 rotrFixed<word64>(word64 x, unsigned int y)
+{
+	assert(y < 8*sizeof(x));
+	return y ? _rotr64(x, y) : x;
+}
+
+template<> inline word64 rotlVariable<word64>(word64 x, unsigned int y)
+{
+	assert(y < 8*sizeof(x));
+	return _rotl64(x, y);
+}
+
+template<> inline word64 rotrVariable<word64>(word64 x, unsigned int y)
+{
+	assert(y < 8*sizeof(x));
+	return _rotr64(x, y);
+}
+
+template<> inline word64 rotlMod<word64>(word64 x, unsigned int y)
+{
+	return _rotl64(x, y);
+}
+
+template<> inline word64 rotrMod<word64>(word64 x, unsigned int y)
+{
+	return _rotr64(x, y);
+}
+
+#endif // #if _MSC_VER >= 1310
+
+#if _MSC_VER >= 1400 && !defined(__INTEL_COMPILER)
+// Intel C++ Compiler 10.0 gives undefined externals with these
+
+template<> inline word16 rotlFixed<word16>(word16 x, unsigned int y)
+{
+	assert(y < 8*sizeof(x));
+	return y ? _rotl16(x, y) : x;
+}
+
+template<> inline word16 rotrFixed<word16>(word16 x, unsigned int y)
+{
+	assert(y < 8*sizeof(x));
+	return y ? _rotr16(x, y) : x;
+}
+
+template<> inline word16 rotlVariable<word16>(word16 x, unsigned int y)
+{
+	assert(y < 8*sizeof(x));
+	return _rotl16(x, y);
+}
+
+template<> inline word16 rotrVariable<word16>(word16 x, unsigned int y)
+{
+	assert(y < 8*sizeof(x));
+	return _rotr16(x, y);
+}
+
+template<> inline word16 rotlMod<word16>(word16 x, unsigned int y)
+{
+	return _rotl16(x, y);
+}
+
+template<> inline word16 rotrMod<word16>(word16 x, unsigned int y)
+{
+	return _rotr16(x, y);
+}
+
+template<> inline byte rotlFixed<byte>(byte x, unsigned int y)
+{
+	assert(y < 8*sizeof(x));
+	return y ? _rotl8(x, y) : x;
+}
+
+template<> inline byte rotrFixed<byte>(byte x, unsigned int y)
+{
+	assert(y < 8*sizeof(x));
+	return y ? _rotr8(x, y) : x;
+}
+
+template<> inline byte rotlVariable<byte>(byte x, unsigned int y)
+{
+	assert(y < 8*sizeof(x));
+	return _rotl8(x, y);
+}
+
+template<> inline byte rotrVariable<byte>(byte x, unsigned int y)
+{
+	assert(y < 8*sizeof(x));
+	return _rotr8(x, y);
+}
+
+template<> inline byte rotlMod<byte>(byte x, unsigned int y)
+{
+	return _rotl8(x, y);
+}
+
+template<> inline byte rotrMod<byte>(byte x, unsigned int y)
+{
+	return _rotr8(x, y);
+}
+
+#endif // #if _MSC_VER >= 1400
+
+#if (defined(__MWERKS__) && TARGET_CPU_PPC)
+
+template<> inline word32 rotlFixed<word32>(word32 x, unsigned int y)
+{
+	assert(y < 32);
+	return y ? __rlwinm(x,y,0,31) : x;
+}
+
+template<> inline word32 rotrFixed<word32>(word32 x, unsigned int y)
+{
+	assert(y < 32);
+	return y ? __rlwinm(x,32-y,0,31) : x;
+}
+
+template<> inline word32 rotlVariable<word32>(word32 x, unsigned int y)
+{
+	assert(y < 32);
+	return (__rlwnm(x,y,0,31));
+}
+
+template<> inline word32 rotrVariable<word32>(word32 x, unsigned int y)
+{
+	assert(y < 32);
+	return (__rlwnm(x,32-y,0,31));
+}
+
+template<> inline word32 rotlMod<word32>(word32 x, unsigned int y)
+{
+	return (__rlwnm(x,y,0,31));
+}
+
+template<> inline word32 rotrMod<word32>(word32 x, unsigned int y)
+{
+	return (__rlwnm(x,32-y,0,31));
+}
+
+#endif // #if (defined(__MWERKS__) && TARGET_CPU_PPC)
+
+// ************** endian reversal ***************
+
+template <class T>
+inline unsigned int GetByte(ByteOrder order, T value, unsigned int index)
+{
+	if (order == LITTLE_ENDIAN_ORDER)
+		return GETBYTE(value, index);
+	else
+		return GETBYTE(value, sizeof(T)-index-1);
+}
+
+inline byte ByteReverse(byte value)
+{
+	return value;
+}
+
+inline word16 ByteReverse(word16 value)
+{
+#ifdef CRYPTOPP_BYTESWAP_AVAILABLE
+	return bswap_16(value);
+#elif defined(_MSC_VER) && _MSC_VER >= 1300
+	return _byteswap_ushort(value);
+#else
+	return rotlFixed(value, 8U);
+#endif
+}
+
+inline word32 ByteReverse(word32 value)
+{
+#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE)
+	__asm__ ("bswap %0" : "=r" (value) : "0" (value));
+	return value;
+#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)
+	return bswap_32(value);
+#elif defined(__MWERKS__) && TARGET_CPU_PPC
+	return (word32)__lwbrx(&value,0);
+#elif _MSC_VER >= 1400 || (_MSC_VER >= 1300 && !defined(_DLL))
+	return _byteswap_ulong(value);
+#elif CRYPTOPP_FAST_ROTATE(32)
+	// 5 instructions with rotate instruction, 9 without
+	return (rotrFixed(value, 8U) & 0xff00ff00) | (rotlFixed(value, 8U) & 0x00ff00ff);
+#else
+	// 6 instructions with rotate instruction, 8 without
+	value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
+	return rotlFixed(value, 16U);
+#endif
+}
+
+inline word64 ByteReverse(word64 value)
+{
+#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE) && defined(__x86_64__)
+	__asm__ ("bswap %0" : "=r" (value) : "0" (value));
+	return value;
+#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)
+	return bswap_64(value);
+#elif defined(_MSC_VER) && _MSC_VER >= 1300
+	return _byteswap_uint64(value);
+#elif CRYPTOPP_BOOL_SLOW_WORD64
+	return (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));
+#else
+	value = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);
+	value = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);
+	return rotlFixed(value, 32U);
+#endif
+}
+
+inline byte BitReverse(byte value)
+{
+	value = ((value & 0xAA) >> 1) | ((value & 0x55) << 1);
+	value = ((value & 0xCC) >> 2) | ((value & 0x33) << 2);
+	return rotlFixed(value, 4U);
+}
+
+inline word16 BitReverse(word16 value)
+{
+	value = ((value & 0xAAAA) >> 1) | ((value & 0x5555) << 1);
+	value = ((value & 0xCCCC) >> 2) | ((value & 0x3333) << 2);
+	value = ((value & 0xF0F0) >> 4) | ((value & 0x0F0F) << 4);
+	return ByteReverse(value);
+}
+
+inline word32 BitReverse(word32 value)
+{
+	value = ((value & 0xAAAAAAAA) >> 1) | ((value & 0x55555555) << 1);
+	value = ((value & 0xCCCCCCCC) >> 2) | ((value & 0x33333333) << 2);
+	value = ((value & 0xF0F0F0F0) >> 4) | ((value & 0x0F0F0F0F) << 4);
+	return ByteReverse(value);
+}
+
+inline word64 BitReverse(word64 value)
+{
+#if CRYPTOPP_BOOL_SLOW_WORD64
+	return (word64(BitReverse(word32(value))) << 32) | BitReverse(word32(value>>32));
+#else
+	value = ((value & W64LIT(0xAAAAAAAAAAAAAAAA)) >> 1) | ((value & W64LIT(0x5555555555555555)) << 1);
+	value = ((value & W64LIT(0xCCCCCCCCCCCCCCCC)) >> 2) | ((value & W64LIT(0x3333333333333333)) << 2);
+	value = ((value & W64LIT(0xF0F0F0F0F0F0F0F0)) >> 4) | ((value & W64LIT(0x0F0F0F0F0F0F0F0F)) << 4);
+	return ByteReverse(value);
+#endif
+}
+
+template <class T>
+inline T BitReverse(T value)
+{
+	if (sizeof(T) == 1)
+		return (T)BitReverse((byte)value);
+	else if (sizeof(T) == 2)
+		return (T)BitReverse((word16)value);
+	else if (sizeof(T) == 4)
+		return (T)BitReverse((word32)value);
+	else
+	{
+		assert(sizeof(T) == 8);
+		return (T)BitReverse((word64)value);
+	}
+}
+
+template <class T>
+inline T ConditionalByteReverse(ByteOrder order, T value)
+{
+	return NativeByteOrderIs(order) ? value : ByteReverse(value);
+}
+
+template <class T>
+void ByteReverse(T *out, const T *in, size_t byteCount)
+{
+	assert(byteCount % sizeof(T) == 0);
+	size_t count = byteCount/sizeof(T);
+	for (size_t i=0; i<count; i++)
+		out[i] = ByteReverse(in[i]);
+}
+
+template <class T>
+inline void ConditionalByteReverse(ByteOrder order, T *out, const T *in, size_t byteCount)
+{
+	if (!NativeByteOrderIs(order))
+		ByteReverse(out, in, byteCount);
+	else if (in != out)
+		memcpy_s(out, byteCount, in, byteCount);
+}
+
+template <class T>
+inline void GetUserKey(ByteOrder order, T *out, size_t outlen, const byte *in, size_t inlen)
+{
+	const size_t U = sizeof(T);
+	assert(inlen <= outlen*U);
+	memcpy_s(out, outlen*U, in, inlen);
+	memset_z((byte *)out+inlen, 0, outlen*U-inlen);
+	ConditionalByteReverse(order, out, out, RoundUpToMultipleOf(inlen, U));
+}
+
+#ifndef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS
+inline byte UnalignedGetWordNonTemplate(ByteOrder order, const byte *block, const byte *)
+{
+	return block[0];
+}
+
+inline word16 UnalignedGetWordNonTemplate(ByteOrder order, const byte *block, const word16 *)
+{
+	return (order == BIG_ENDIAN_ORDER)
+		? block[1] | (block[0] << 8)
+		: block[0] | (block[1] << 8);
+}
+
+inline word32 UnalignedGetWordNonTemplate(ByteOrder order, const byte *block, const word32 *)
+{
+	return (order == BIG_ENDIAN_ORDER)
+		? word32(block[3]) | (word32(block[2]) << 8) | (word32(block[1]) << 16) | (word32(block[0]) << 24)
+		: word32(block[0]) | (word32(block[1]) << 8) | (word32(block[2]) << 16) | (word32(block[3]) << 24);
+}
+
+inline word64 UnalignedGetWordNonTemplate(ByteOrder order, const byte *block, const word64 *)
+{
+	return (order == BIG_ENDIAN_ORDER)
+		?
+		(word64(block[7]) |
+		(word64(block[6]) <<  8) |
+		(word64(block[5]) << 16) |
+		(word64(block[4]) << 24) |
+		(word64(block[3]) << 32) |
+		(word64(block[2]) << 40) |
+		(word64(block[1]) << 48) |
+		(word64(block[0]) << 56))
+		:
+		(word64(block[0]) |
+		(word64(block[1]) <<  8) |
+		(word64(block[2]) << 16) |
+		(word64(block[3]) << 24) |
+		(word64(block[4]) << 32) |
+		(word64(block[5]) << 40) |
+		(word64(block[6]) << 48) |
+		(word64(block[7]) << 56));
+}
+
+inline void UnalignedPutWordNonTemplate(ByteOrder order, byte *block, byte value, const byte *xorBlock)
+{
+	block[0] = xorBlock ? (value ^ xorBlock[0]) : value;
+}
+
+inline void UnalignedPutWordNonTemplate(ByteOrder order, byte *block, word16 value, const byte *xorBlock)
+{
+	if (order == BIG_ENDIAN_ORDER)
+	{
+		if (xorBlock)
+		{
+			block[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);
+			block[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);
+		}
+		else
+		{
+			block[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);
+			block[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);
+		}
+	}
+	else
+	{
+		if (xorBlock)
+		{
+			block[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);
+			block[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);
+		}
+		else
+		{
+			block[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);
+			block[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);
+		}
+	}
+}
+
+inline void UnalignedPutWordNonTemplate(ByteOrder order, byte *block, word32 value, const byte *xorBlock)
+{
+	if (order == BIG_ENDIAN_ORDER)
+	{
+		if (xorBlock)
+		{
+			block[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);
+			block[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);
+			block[2] = xorBlock[2] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);
+			block[3] = xorBlock[3] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);
+		}
+		else
+		{
+			block[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);
+			block[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);
+			block[2] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);
+			block[3] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);
+		}
+	}
+	else
+	{
+		if (xorBlock)
+		{
+			block[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);
+			block[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);
+			block[2] = xorBlock[2] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);
+			block[3] = xorBlock[3] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);
+		}
+		else
+		{
+			block[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);
+			block[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);
+			block[2] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);
+			block[3] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);
+		}
+	}
+}
+
+inline void UnalignedPutWordNonTemplate(ByteOrder order, byte *block, word64 value, const byte *xorBlock)
+{
+	if (order == BIG_ENDIAN_ORDER)
+	{
+		if (xorBlock)
+		{
+			block[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);
+			block[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);
+			block[2] = xorBlock[2] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);
+			block[3] = xorBlock[3] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);
+			block[4] = xorBlock[4] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);
+			block[5] = xorBlock[5] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);
+			block[6] = xorBlock[6] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);
+			block[7] = xorBlock[7] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);
+		}
+		else
+		{
+			block[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);
+			block[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);
+			block[2] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);
+			block[3] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);
+			block[4] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);
+			block[5] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);
+			block[6] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);
+			block[7] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);
+		}
+	}
+	else
+	{
+		if (xorBlock)
+		{
+			block[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);
+			block[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);
+			block[2] = xorBlock[2] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);
+			block[3] = xorBlock[3] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);
+			block[4] = xorBlock[4] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);
+			block[5] = xorBlock[5] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);
+			block[6] = xorBlock[6] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);
+			block[7] = xorBlock[7] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);
+		}
+		else
+		{
+			block[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);
+			block[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);
+			block[2] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);
+			block[3] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);
+			block[4] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);
+			block[5] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);
+			block[6] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);
+			block[7] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);
+		}
+	}
+}
+#endif	// #ifndef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS
+
+template <class T>
+inline T GetWord(bool assumeAligned, ByteOrder order, const byte *block)
+{
+#ifndef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS
+	if (!assumeAligned)
+		return UnalignedGetWordNonTemplate(order, block, (T*)NULL);
+	assert(IsAligned<T>(block));
+#endif
+	return ConditionalByteReverse(order, *reinterpret_cast<const T *>(block));
+}
+
+template <class T>
+inline void GetWord(bool assumeAligned, ByteOrder order, T &result, const byte *block)
+{
+	result = GetWord<T>(assumeAligned, order, block);
+}
+
+template <class T>
+inline void PutWord(bool assumeAligned, ByteOrder order, byte *block, T value, const byte *xorBlock = NULL)
+{
+#ifndef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS
+	if (!assumeAligned)
+		return UnalignedPutWordNonTemplate(order, block, value, xorBlock);
+	assert(IsAligned<T>(block));
+	assert(IsAligned<T>(xorBlock));
+#endif
+	*reinterpret_cast<T *>(block) = ConditionalByteReverse(order, value) ^ (xorBlock ? *reinterpret_cast<const T *>(xorBlock) : 0);
+}
+
+template <class T, class B, bool A=false>
+class GetBlock
+{
+public:
+	GetBlock(const void *block)
+		: m_block((const byte *)block) {}
+
+	template <class U>
+	inline GetBlock<T, B, A> & operator()(U &x)
+	{
+		CRYPTOPP_COMPILE_ASSERT(sizeof(U) >= sizeof(T));
+		x = GetWord<T>(A, B::ToEnum(), m_block);
+		m_block += sizeof(T);
+		return *this;
+	}
+
+private:
+	const byte *m_block;
+};
+
+template <class T, class B, bool A=false>
+class PutBlock
+{
+public:
+	PutBlock(const void *xorBlock, void *block)
+		: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}
+
+	template <class U>
+	inline PutBlock<T, B, A> & operator()(U x)
+	{
+		PutWord(A, B::ToEnum(), m_block, (T)x, m_xorBlock);
+		m_block += sizeof(T);
+		if (m_xorBlock)
+			m_xorBlock += sizeof(T);
+		return *this;
+	}
+
+private:
+	const byte *m_xorBlock;
+	byte *m_block;
+};
+
+template <class T, class B, bool GA=false, bool PA=false>
+struct BlockGetAndPut
+{
+	// function needed because of C++ grammatical ambiguity between expression-statements and declarations
+	static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}
+	typedef PutBlock<T, B, PA> Put;
+};
+
+template <class T>
+std::string WordToString(T value, ByteOrder order = BIG_ENDIAN_ORDER)
+{
+	if (!NativeByteOrderIs(order))
+		value = ByteReverse(value);
+
+	return std::string((char *)&value, sizeof(value));
+}
+
+template <class T>
+T StringToWord(const std::string &str, ByteOrder order = BIG_ENDIAN_ORDER)
+{
+	T value = 0;
+	memcpy_s(&value, sizeof(value), str.data(), UnsignedMin(str.size(), sizeof(value)));
+	return NativeByteOrderIs(order) ? value : ByteReverse(value);
+}
+
+// ************** help remove warning on g++ ***************
+
+template <bool overflow> struct SafeShifter;
+
+template<> struct SafeShifter<true>
+{
+	template <class T>
+	static inline T RightShift(T value, unsigned int bits)
+	{
+		return 0;
+	}
+
+	template <class T>
+	static inline T LeftShift(T value, unsigned int bits)
+	{
+		return 0;
+	}
+};
+
+template<> struct SafeShifter<false>
+{
+	template <class T>
+	static inline T RightShift(T value, unsigned int bits)
+	{
+		return value >> bits;
+	}
+
+	template <class T>
+	static inline T LeftShift(T value, unsigned int bits)
+	{
+		return value << bits;
+	}
+};
+
+template <unsigned int bits, class T>
+inline T SafeRightShift(T value)
+{
+	return SafeShifter<(bits>=(8*sizeof(T)))>::RightShift(value, bits);
+}
+
+template <unsigned int bits, class T>
+inline T SafeLeftShift(T value)
+{
+	return SafeShifter<(bits>=(8*sizeof(T)))>::LeftShift(value, bits);
+}
+
+// ************** use one buffer for multiple data members ***************
+
+#define CRYPTOPP_BLOCK_1(n, t, s) t* m_##n() {return (t *)(m_aggregate+0);}     size_t SS1() {return       sizeof(t)*(s);} size_t m_##n##Size() {return (s);}
+#define CRYPTOPP_BLOCK_2(n, t, s) t* m_##n() {return (t *)(m_aggregate+SS1());} size_t SS2() {return SS1()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}
+#define CRYPTOPP_BLOCK_3(n, t, s) t* m_##n() {return (t *)(m_aggregate+SS2());} size_t SS3() {return SS2()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}
+#define CRYPTOPP_BLOCK_4(n, t, s) t* m_##n() {return (t *)(m_aggregate+SS3());} size_t SS4() {return SS3()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}
+#define CRYPTOPP_BLOCK_5(n, t, s) t* m_##n() {return (t *)(m_aggregate+SS4());} size_t SS5() {return SS4()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}
+#define CRYPTOPP_BLOCK_6(n, t, s) t* m_##n() {return (t *)(m_aggregate+SS5());} size_t SS6() {return SS5()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}
+#define CRYPTOPP_BLOCK_7(n, t, s) t* m_##n() {return (t *)(m_aggregate+SS6());} size_t SS7() {return SS6()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}
+#define CRYPTOPP_BLOCK_8(n, t, s) t* m_##n() {return (t *)(m_aggregate+SS7());} size_t SS8() {return SS7()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}
+#define CRYPTOPP_BLOCKS_END(i) size_t SST() {return SS##i();} void AllocateBlocks() {m_aggregate.New(SST());} AlignedSecByteBlock m_aggregate;
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/modarith.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/modarith.h
index 6eeb70e4..c0368e3f 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/modarith.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/modarith.h
@@ -1,149 +1,158 @@
-#ifndef CRYPTOPP_MODARITH_H
-#define CRYPTOPP_MODARITH_H
-
-// implementations are in integer.cpp
-
-#include "cryptlib.h"
-#include "misc.h"
-#include "integer.h"
-#include "algebra.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-//! .
-class ModularArithmetic : public AbstractRing<Integer>
-{
-public:
-
-	typedef int RandomizationParameter;
-	typedef Integer Element;
-
-	ModularArithmetic(const Integer &modulus = Integer::One())
-		: modulus(modulus), result((word)0, modulus.reg.size()) {}
-
-	ModularArithmetic(const ModularArithmetic &ma)
-		: modulus(ma.modulus), result((word)0, modulus.reg.size()) {}
-
-	ModularArithmetic(BufferedTransformation &bt);	// construct from BER encoded parameters
-
-	virtual ModularArithmetic * Clone() const {return new ModularArithmetic(*this);}
-
-	void DEREncode(BufferedTransformation &bt) const;
-
-	void DEREncodeElement(BufferedTransformation &out, const Element &a) const;
-	void BERDecodeElement(BufferedTransformation &in, Element &a) const;
-
-	const Integer& GetModulus() const {return modulus;}
-	void SetModulus(const Integer &newModulus) {modulus = newModulus; result.reg.resize(modulus.reg.size());}
-
-	virtual bool IsMontgomeryRepresentation() const {return false;}
-
-	virtual Integer ConvertIn(const Integer &a) const
-		{return a%modulus;}
-
-	virtual Integer ConvertOut(const Integer &a) const
-		{return a;}
-
-	const Integer& Half(const Integer &a) const;
-
-	bool Equal(const Integer &a, const Integer &b) const
-		{return a==b;}
-
-	const Integer& Identity() const
-		{return Integer::Zero();}
-
-	const Integer& Add(const Integer &a, const Integer &b) const;
-
-	Integer& Accumulate(Integer &a, const Integer &b) const;
-
-	const Integer& Inverse(const Integer &a) const;
-
-	const Integer& Subtract(const Integer &a, const Integer &b) const;
-
-	Integer& Reduce(Integer &a, const Integer &b) const;
-
-	const Integer& Double(const Integer &a) const
-		{return Add(a, a);}
-
-	const Integer& MultiplicativeIdentity() const
-		{return Integer::One();}
-
-	const Integer& Multiply(const Integer &a, const Integer &b) const
-		{return result1 = a*b%modulus;}
-
-	const Integer& Square(const Integer &a) const
-		{return result1 = a.Squared()%modulus;}
-
-	bool IsUnit(const Integer &a) const
-		{return Integer::Gcd(a, modulus).IsUnit();}
-
-	const Integer& MultiplicativeInverse(const Integer &a) const
-		{return result1 = a.InverseMod(modulus);}
-
-	const Integer& Divide(const Integer &a, const Integer &b) const
-		{return Multiply(a, MultiplicativeInverse(b));}
-
-	Integer CascadeExponentiate(const Integer &x, const Integer &e1, const Integer &y, const Integer &e2) const;
-
-	void SimultaneousExponentiate(Element *results, const Element &base, const Integer *exponents, unsigned int exponentsCount) const;
-
-	unsigned int MaxElementBitLength() const
-		{return (modulus-1).BitCount();}
-
-	unsigned int MaxElementByteLength() const
-		{return (modulus-1).ByteCount();}
-
-	Element RandomElement( RandomNumberGenerator &rng , const RandomizationParameter &ignore_for_now = 0 ) const
-		// left RandomizationParameter arg as ref in case RandomizationParameter becomes a more complicated struct
-	{ 
-		return Element( rng , Integer( (long) 0) , modulus - Integer( (long) 1 )   ) ; 
-	}   
-
-	static const RandomizationParameter DefaultRandomizationParameter ;
-
-protected:
-	Integer modulus;
-	mutable Integer result, result1;
-
-};
-
-// const ModularArithmetic::RandomizationParameter ModularArithmetic::DefaultRandomizationParameter = 0 ;
-
-//! do modular arithmetics in Montgomery representation for increased speed
-class MontgomeryRepresentation : public ModularArithmetic
-{
-public:
-	MontgomeryRepresentation(const Integer &modulus);	// modulus must be odd
-
-	virtual ModularArithmetic * Clone() const {return new MontgomeryRepresentation(*this);}
-
-	bool IsMontgomeryRepresentation() const {return true;}
-
-	Integer ConvertIn(const Integer &a) const
-		{return (a<<(WORD_BITS*modulus.reg.size()))%modulus;}
-
-	Integer ConvertOut(const Integer &a) const;
-
-	const Integer& MultiplicativeIdentity() const
-		{return result1 = Integer::Power2(WORD_BITS*modulus.reg.size())%modulus;}
-
-	const Integer& Multiply(const Integer &a, const Integer &b) const;
-
-	const Integer& Square(const Integer &a) const;
-
-	const Integer& MultiplicativeInverse(const Integer &a) const;
-
-	Integer CascadeExponentiate(const Integer &x, const Integer &e1, const Integer &y, const Integer &e2) const
-		{return AbstractRing<Integer>::CascadeExponentiate(x, e1, y, e2);}
-
-	void SimultaneousExponentiate(Element *results, const Element &base, const Integer *exponents, unsigned int exponentsCount) const
-		{AbstractRing<Integer>::SimultaneousExponentiate(results, base, exponents, exponentsCount);}
-
-private:
-	Integer u;
-	mutable SecAlignedWordBlock workspace;
-};
-
-NAMESPACE_END
-
-#endif
+#ifndef CRYPTOPP_MODARITH_H
+#define CRYPTOPP_MODARITH_H
+
+// implementations are in integer.cpp
+
+#include "cryptlib.h"
+#include "misc.h"
+#include "integer.h"
+#include "algebra.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+CRYPTOPP_DLL_TEMPLATE_CLASS AbstractGroup<Integer>;
+CRYPTOPP_DLL_TEMPLATE_CLASS AbstractRing<Integer>;
+CRYPTOPP_DLL_TEMPLATE_CLASS AbstractEuclideanDomain<Integer>;
+
+//! ring of congruence classes modulo n
+/*! \note this implementation represents each congruence class as the smallest non-negative integer in that class */
+class CRYPTOPP_DLL ModularArithmetic : public AbstractRing<Integer>
+{
+public:
+
+	typedef int RandomizationParameter;
+	typedef Integer Element;
+
+	ModularArithmetic(const Integer &modulus = Integer::One())
+		: m_modulus(modulus), m_result((word)0, modulus.reg.size()) {}
+
+	ModularArithmetic(const ModularArithmetic &ma)
+		: m_modulus(ma.m_modulus), m_result((word)0, m_modulus.reg.size()) {}
+
+	ModularArithmetic(BufferedTransformation &bt);	// construct from BER encoded parameters
+
+	virtual ModularArithmetic * Clone() const {return new ModularArithmetic(*this);}
+
+	void DEREncode(BufferedTransformation &bt) const;
+
+	void DEREncodeElement(BufferedTransformation &out, const Element &a) const;
+	void BERDecodeElement(BufferedTransformation &in, Element &a) const;
+
+	const Integer& GetModulus() const {return m_modulus;}
+	void SetModulus(const Integer &newModulus) {m_modulus = newModulus; m_result.reg.resize(m_modulus.reg.size());}
+
+	virtual bool IsMontgomeryRepresentation() const {return false;}
+
+	virtual Integer ConvertIn(const Integer &a) const
+		{return a%m_modulus;}
+
+	virtual Integer ConvertOut(const Integer &a) const
+		{return a;}
+
+	const Integer& Half(const Integer &a) const;
+
+	bool Equal(const Integer &a, const Integer &b) const
+		{return a==b;}
+
+	const Integer& Identity() const
+		{return Integer::Zero();}
+
+	const Integer& Add(const Integer &a, const Integer &b) const;
+
+	Integer& Accumulate(Integer &a, const Integer &b) const;
+
+	const Integer& Inverse(const Integer &a) const;
+
+	const Integer& Subtract(const Integer &a, const Integer &b) const;
+
+	Integer& Reduce(Integer &a, const Integer &b) const;
+
+	const Integer& Double(const Integer &a) const
+		{return Add(a, a);}
+
+	const Integer& MultiplicativeIdentity() const
+		{return Integer::One();}
+
+	const Integer& Multiply(const Integer &a, const Integer &b) const
+		{return m_result1 = a*b%m_modulus;}
+
+	const Integer& Square(const Integer &a) const
+		{return m_result1 = a.Squared()%m_modulus;}
+
+	bool IsUnit(const Integer &a) const
+		{return Integer::Gcd(a, m_modulus).IsUnit();}
+
+	const Integer& MultiplicativeInverse(const Integer &a) const
+		{return m_result1 = a.InverseMod(m_modulus);}
+
+	const Integer& Divide(const Integer &a, const Integer &b) const
+		{return Multiply(a, MultiplicativeInverse(b));}
+
+	Integer CascadeExponentiate(const Integer &x, const Integer &e1, const Integer &y, const Integer &e2) const;
+
+	void SimultaneousExponentiate(Element *results, const Element &base, const Integer *exponents, unsigned int exponentsCount) const;
+
+	unsigned int MaxElementBitLength() const
+		{return (m_modulus-1).BitCount();}
+
+	unsigned int MaxElementByteLength() const
+		{return (m_modulus-1).ByteCount();}
+
+	Element RandomElement( RandomNumberGenerator &rng , const RandomizationParameter &ignore_for_now = 0 ) const
+		// left RandomizationParameter arg as ref in case RandomizationParameter becomes a more complicated struct
+	{ 
+		return Element( rng , Integer( (long) 0) , m_modulus - Integer( (long) 1 )   ) ; 
+	}   
+
+	bool operator==(const ModularArithmetic &rhs) const
+		{return m_modulus == rhs.m_modulus;}
+
+	static const RandomizationParameter DefaultRandomizationParameter ;
+
+protected:
+	Integer m_modulus;
+	mutable Integer m_result, m_result1;
+
+};
+
+// const ModularArithmetic::RandomizationParameter ModularArithmetic::DefaultRandomizationParameter = 0 ;
+
+//! do modular arithmetics in Montgomery representation for increased speed
+/*! \note the Montgomery representation represents each congruence class [a] as a*r%n, where r is a convenient power of 2 */
+class CRYPTOPP_DLL MontgomeryRepresentation : public ModularArithmetic
+{
+public:
+	MontgomeryRepresentation(const Integer &modulus);	// modulus must be odd
+
+	virtual ModularArithmetic * Clone() const {return new MontgomeryRepresentation(*this);}
+
+	bool IsMontgomeryRepresentation() const {return true;}
+
+	Integer ConvertIn(const Integer &a) const
+		{return (a<<(WORD_BITS*m_modulus.reg.size()))%m_modulus;}
+
+	Integer ConvertOut(const Integer &a) const;
+
+	const Integer& MultiplicativeIdentity() const
+		{return m_result1 = Integer::Power2(WORD_BITS*m_modulus.reg.size())%m_modulus;}
+
+	const Integer& Multiply(const Integer &a, const Integer &b) const;
+
+	const Integer& Square(const Integer &a) const;
+
+	const Integer& MultiplicativeInverse(const Integer &a) const;
+
+	Integer CascadeExponentiate(const Integer &x, const Integer &e1, const Integer &y, const Integer &e2) const
+		{return AbstractRing<Integer>::CascadeExponentiate(x, e1, y, e2);}
+
+	void SimultaneousExponentiate(Element *results, const Element &base, const Integer *exponents, unsigned int exponentsCount) const
+		{AbstractRing<Integer>::SimultaneousExponentiate(results, base, exponents, exponentsCount);}
+
+private:
+	Integer m_u;
+	mutable IntegerSecBlock m_workspace;
+};
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/modes.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/modes.h
index a9e58e1b..c0c30c47 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/modes.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/modes.h
@@ -1,370 +1,422 @@
-#ifndef CRYPTOPP_MODES_H
-#define CRYPTOPP_MODES_H
-
-/*! \file
-*/
-
-#include "cryptlib.h"
-#include "secblock.h"
-#include "misc.h"
-#include "strciphr.h"
-#include "argnames.h"
-#include "algparam.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-//! Cipher mode documentation. See NIST SP 800-38A for definitions of these modes.
-
-/*! Each class derived from this one defines two types, Encryption and Decryption, 
-	both of which implement the SymmetricCipher interface.
-	For each mode there are two classes, one of which is a template class,
-	and the other one has a name that ends in "_ExternalCipher".
-	The "external cipher" mode objects hold a reference to the underlying block cipher,
-	instead of holding an instance of it. The reference must be passed in to the constructor.
-	For the "cipher holder" classes, the CIPHER template parameter should be a class
-	derived from BlockCipherDocumentation, for example DES or AES.
-*/
-struct CipherModeDocumentation : public SymmetricCipherDocumentation
-{
-};
-
-class CipherModeBase : public SymmetricCipher
-{
-public:
-	unsigned int MinKeyLength() const {return m_cipher->MinKeyLength();}
-	unsigned int MaxKeyLength() const {return m_cipher->MaxKeyLength();}
-	unsigned int DefaultKeyLength() const {return m_cipher->DefaultKeyLength();}
-	unsigned int GetValidKeyLength(unsigned int n) const {return m_cipher->GetValidKeyLength(n);}
-	bool IsValidKeyLength(unsigned int n) const {return m_cipher->IsValidKeyLength(n);}
-
-	void SetKey(const byte *key, unsigned int length, const NameValuePairs &params = g_nullNameValuePairs);
-
-	unsigned int OptimalDataAlignment() const {return BlockSize();}
-
-	unsigned int IVSize() const {return BlockSize();}
-	void GetNextIV(byte *IV);
-	virtual IV_Requirement IVRequirement() const =0;
-
-protected:
-	inline unsigned int BlockSize() const {assert(m_register.size() > 0); return m_register.size();}
-	void SetIV(const byte *iv);
-	virtual void SetFeedbackSize(unsigned int feedbackSize)
-	{
-		if (!(feedbackSize == 0 || feedbackSize == BlockSize()))
-			throw InvalidArgument("CipherModeBase: feedback size cannot be specified for this cipher mode");
-	}
-	virtual void ResizeBuffers()
-	{
-		m_register.New(m_cipher->BlockSize());
-	}
-	virtual void UncheckedSetKey(const NameValuePairs &params, const byte *key, unsigned int length) =0;
-
-	BlockCipher *m_cipher;
-	SecByteBlock m_register;
-};
-
-template <class POLICY_INTERFACE>
-class ModePolicyCommonTemplate : public CipherModeBase, public POLICY_INTERFACE
-{
-	unsigned int GetAlignment() const {return m_cipher->BlockAlignment();}
-	void CipherSetKey(const NameValuePairs &params, const byte *key, unsigned int length)
-	{
-		m_cipher->SetKey(key, length, params);
-		ResizeBuffers();
-		int feedbackSize = params.GetIntValueWithDefault(Name::FeedbackSize(), 0);
-		SetFeedbackSize(feedbackSize);
-		const byte *iv = params.GetValueWithDefault(Name::IV(), (const byte *)NULL);
-		SetIV(iv);
-	}
-};
-
-class CFB_ModePolicy : public ModePolicyCommonTemplate<CFB_CipherAbstractPolicy>
-{
-public:
-	IV_Requirement IVRequirement() const {return RANDOM_IV;}
-
-protected:
-	unsigned int GetBytesPerIteration() const {return m_feedbackSize;}
-	byte * GetRegisterBegin() {return m_register + BlockSize() - m_feedbackSize;}
-	void TransformRegister()
-	{
-		m_cipher->ProcessBlock(m_register, m_temp);
-		memmove(m_register, m_register+m_feedbackSize, BlockSize()-m_feedbackSize);
-		memcpy(m_register+BlockSize()-m_feedbackSize, m_temp, m_feedbackSize);
-	}
-	void CipherResynchronize(const byte *iv)
-	{
-		memcpy(m_register, iv, BlockSize());
-		TransformRegister();
-	}
-	void SetFeedbackSize(unsigned int feedbackSize)
-	{
-		if (feedbackSize > BlockSize())
-			throw InvalidArgument("CFB_Mode: invalid feedback size");
-		m_feedbackSize = feedbackSize ? feedbackSize : BlockSize();
-	}
-	void ResizeBuffers()
-	{
-		CipherModeBase::ResizeBuffers();
-		m_temp.New(BlockSize());
-	}
-
-	SecByteBlock m_temp;
-	unsigned int m_feedbackSize;
-};
-
-class OFB_ModePolicy : public ModePolicyCommonTemplate<AdditiveCipherAbstractPolicy>
-{
-	unsigned int GetBytesPerIteration() const {return BlockSize();}
-	unsigned int GetIterationsToBuffer() const {return 1;}
-	void WriteKeystream(byte *keystreamBuffer, unsigned int iterationCount)
-	{
-		assert(iterationCount == 1);
-		m_cipher->ProcessBlock(keystreamBuffer);
-	}
-	void CipherResynchronize(byte *keystreamBuffer, const byte *iv)
-	{
-		memcpy(keystreamBuffer, iv, BlockSize());
-	}
-	bool IsRandomAccess() const {return false;}
-	IV_Requirement IVRequirement() const {return STRUCTURED_IV;}
-};
-
-class CTR_ModePolicy : public ModePolicyCommonTemplate<AdditiveCipherAbstractPolicy>
-{
-	unsigned int GetBytesPerIteration() const {return BlockSize();}
-	unsigned int GetIterationsToBuffer() const {return m_cipher->OptimalNumberOfParallelBlocks();}
-	void WriteKeystream(byte *buffer, unsigned int iterationCount)
-		{OperateKeystream(WRITE_KEYSTREAM, buffer, NULL, iterationCount);}
-	bool CanOperateKeystream() const {return true;}
-	void OperateKeystream(KeystreamOperation operation, byte *output, const byte *input, unsigned int iterationCount);
-	void CipherResynchronize(byte *keystreamBuffer, const byte *iv);
-	bool IsRandomAccess() const {return true;}
-	void SeekToIteration(dword iterationCount);
-	IV_Requirement IVRequirement() const {return STRUCTURED_IV;}
-
-	inline void ProcessMultipleBlocks(byte *output, const byte *input, unsigned int n);
-
-	SecByteBlock m_counterArray;
-};
-
-class BlockOrientedCipherModeBase : public CipherModeBase
-{
-public:
-	void UncheckedSetKey(const NameValuePairs &params, const byte *key, unsigned int length);
-	unsigned int MandatoryBlockSize() const {return BlockSize();}
-	bool IsRandomAccess() const {return false;}
-	bool IsSelfInverting() const {return false;}
-	bool IsForwardTransformation() const {return m_cipher->IsForwardTransformation();}
-	void Resynchronize(const byte *iv) {memcpy(m_register, iv, BlockSize());}
-	void ProcessData(byte *outString, const byte *inString, unsigned int length);
-
-protected:
-	bool RequireAlignedInput() const {return true;}
-	virtual void ProcessBlocks(byte *outString, const byte *inString, unsigned int numberOfBlocks) =0;
-	void ResizeBuffers()
-	{
-		CipherModeBase::ResizeBuffers();
-		m_buffer.New(BlockSize());
-	}
-
-	SecByteBlock m_buffer;
-};
-
-class ECB_OneWay : public BlockOrientedCipherModeBase
-{
-public:
-	IV_Requirement IVRequirement() const {return NOT_RESYNCHRONIZABLE;}
-	unsigned int OptimalBlockSize() const {return BlockSize() * m_cipher->OptimalNumberOfParallelBlocks();}
-	void ProcessBlocks(byte *outString, const byte *inString, unsigned int numberOfBlocks)
-		{m_cipher->ProcessAndXorMultipleBlocks(inString, NULL, outString, numberOfBlocks);}
-};
-
-class CBC_ModeBase : public BlockOrientedCipherModeBase
-{
-public:
-	IV_Requirement IVRequirement() const {return UNPREDICTABLE_RANDOM_IV;}
-	bool RequireAlignedInput() const {return false;}
-	unsigned int MinLastBlockSize() const {return 0;}
-};
-
-class CBC_Encryption : public CBC_ModeBase
-{
-public:
-	void ProcessBlocks(byte *outString, const byte *inString, unsigned int numberOfBlocks);
-};
-
-class CBC_CTS_Encryption : public CBC_Encryption
-{
-public:
-	void SetStolenIV(byte *iv) {m_stolenIV = iv;}
-	unsigned int MinLastBlockSize() const {return BlockSize()+1;}
-	void ProcessLastBlock(byte *outString, const byte *inString, unsigned int length);
-
-protected:
-	void UncheckedSetKey(const NameValuePairs &params, const byte *key, unsigned int length)
-	{
-		CBC_Encryption::UncheckedSetKey(params, key, length);
-		m_stolenIV = params.GetValueWithDefault(Name::StolenIV(), (byte *)NULL);
-	}
-
-	byte *m_stolenIV;
-};
-
-class CBC_Decryption : public CBC_ModeBase
-{
-public:
-	void ProcessBlocks(byte *outString, const byte *inString, unsigned int numberOfBlocks);
-	
-protected:
-	void ResizeBuffers()
-	{
-		BlockOrientedCipherModeBase::ResizeBuffers();
-		m_temp.New(BlockSize());
-	}
-	SecByteBlock m_temp;
-};
-
-class CBC_CTS_Decryption : public CBC_Decryption
-{
-public:
-	unsigned int MinLastBlockSize() const {return BlockSize()+1;}
-	void ProcessLastBlock(byte *outString, const byte *inString, unsigned int length);
-};
-
-//! .
-template <class CIPHER, class BASE>
-class CipherModeFinalTemplate_CipherHolder : public ObjectHolder<CIPHER>, public BASE
-{
-public:
-	CipherModeFinalTemplate_CipherHolder()
-	{
-		m_cipher = &m_object;
-		ResizeBuffers();
-	}
-	CipherModeFinalTemplate_CipherHolder(const byte *key, unsigned int length)
-	{
-		m_cipher = &m_object;
-		SetKey(key, length);
-	}
-	CipherModeFinalTemplate_CipherHolder(const byte *key, unsigned int length, const byte *iv, int feedbackSize = 0)
-	{
-		m_cipher = &m_object;
-		SetKey(key, length, MakeParameters("IV", iv)("FeedbackSize", feedbackSize));
-	}
-};
-
-//! .
-template <class BASE>
-class CipherModeFinalTemplate_ExternalCipher : public BASE
-{
-public:
-	CipherModeFinalTemplate_ExternalCipher(BlockCipher &cipher, const byte *iv = NULL, int feedbackSize = 0)
-	{
-		m_cipher = &cipher;
-		ResizeBuffers();
-		SetFeedbackSize(feedbackSize);
-		SetIV(iv);
-	}
-};
-
-//! CFB mode
-template <class CIPHER>
-struct CFB_Mode : public CipherModeDocumentation
-{
-	typedef CipherModeFinalTemplate_CipherHolder<CPP_TYPENAME CIPHER::Encryption, ConcretePolicyHolder<Empty, CFB_EncryptionTemplate<AbstractPolicyHolder<CFB_CipherAbstractPolicy, CFB_ModePolicy> > > > Encryption;
-	typedef CipherModeFinalTemplate_CipherHolder<CPP_TYPENAME CIPHER::Encryption, ConcretePolicyHolder<Empty, CFB_DecryptionTemplate<AbstractPolicyHolder<CFB_CipherAbstractPolicy, CFB_ModePolicy> > > > Decryption;
-};
-
-//! CFB mode, external cipher
-struct CFB_Mode_ExternalCipher : public CipherModeDocumentation
-{
-	typedef CipherModeFinalTemplate_ExternalCipher<ConcretePolicyHolder<Empty, CFB_EncryptionTemplate<AbstractPolicyHolder<CFB_CipherAbstractPolicy, CFB_ModePolicy> > > > Encryption;
-	typedef CipherModeFinalTemplate_ExternalCipher<ConcretePolicyHolder<Empty, CFB_DecryptionTemplate<AbstractPolicyHolder<CFB_CipherAbstractPolicy, CFB_ModePolicy> > > > Decryption;
-};
-
-//! OFB mode
-template <class CIPHER>
-struct OFB_Mode : public CipherModeDocumentation
-{
-	typedef CipherModeFinalTemplate_CipherHolder<CPP_TYPENAME CIPHER::Encryption, ConcretePolicyHolder<Empty, AdditiveCipherTemplate<AbstractPolicyHolder<AdditiveCipherAbstractPolicy, OFB_ModePolicy> > > > Encryption;
-	typedef Encryption Decryption;
-};
-
-//! OFB mode, external cipher
-struct OFB_Mode_ExternalCipher : public CipherModeDocumentation
-{
-	typedef CipherModeFinalTemplate_ExternalCipher<ConcretePolicyHolder<Empty, AdditiveCipherTemplate<AbstractPolicyHolder<AdditiveCipherAbstractPolicy, OFB_ModePolicy> > > > Encryption;
-	typedef Encryption Decryption;
-};
-
-//! CTR mode
-template <class CIPHER>
-struct CTR_Mode : public CipherModeDocumentation
-{
-	typedef CipherModeFinalTemplate_CipherHolder<CPP_TYPENAME CIPHER::Encryption, ConcretePolicyHolder<Empty, AdditiveCipherTemplate<AbstractPolicyHolder<AdditiveCipherAbstractPolicy, CTR_ModePolicy> > > > Encryption;
-	typedef Encryption Decryption;
-};
-
-//! CTR mode, external cipher
-struct CTR_Mode_ExternalCipher : public CipherModeDocumentation
-{
-	typedef CipherModeFinalTemplate_ExternalCipher<ConcretePolicyHolder<Empty, AdditiveCipherTemplate<AbstractPolicyHolder<AdditiveCipherAbstractPolicy, CTR_ModePolicy> > > > Encryption;
-	typedef Encryption Decryption;
-};
-
-//! ECB mode
-template <class CIPHER>
-struct ECB_Mode : public CipherModeDocumentation
-{
-	typedef CipherModeFinalTemplate_CipherHolder<CPP_TYPENAME CIPHER::Encryption, ECB_OneWay> Encryption;
-	typedef CipherModeFinalTemplate_CipherHolder<CPP_TYPENAME CIPHER::Decryption, ECB_OneWay> Decryption;
-};
-
-//! ECB mode, external cipher
-struct ECB_Mode_ExternalCipher : public CipherModeDocumentation
-{
-	typedef CipherModeFinalTemplate_ExternalCipher<ECB_OneWay> Encryption;
-	typedef Encryption Decryption;
-};
-
-//! CBC mode
-template <class CIPHER>
-struct CBC_Mode : public CipherModeDocumentation
-{
-	typedef CipherModeFinalTemplate_CipherHolder<CPP_TYPENAME CIPHER::Encryption, CBC_Encryption> Encryption;
-	typedef CipherModeFinalTemplate_CipherHolder<CPP_TYPENAME CIPHER::Decryption, CBC_Decryption> Decryption;
-};
-
-//! CBC mode, external cipher
-struct CBC_Mode_ExternalCipher : public CipherModeDocumentation
-{
-	typedef CipherModeFinalTemplate_ExternalCipher<CBC_Encryption> Encryption;
-	typedef CipherModeFinalTemplate_ExternalCipher<CBC_Decryption> Decryption;
-};
-
-//! CBC mode with ciphertext stealing
-template <class CIPHER>
-struct CBC_CTS_Mode : public CipherModeDocumentation
-{
-	typedef CipherModeFinalTemplate_CipherHolder<CPP_TYPENAME CIPHER::Encryption, CBC_CTS_Encryption> Encryption;
-	typedef CipherModeFinalTemplate_CipherHolder<CPP_TYPENAME CIPHER::Decryption, CBC_CTS_Decryption> Decryption;
-};
-
-//! CBC mode with ciphertext stealing, external cipher
-struct CBC_CTS_Mode_ExternalCipher : public CipherModeDocumentation
-{
-	typedef CipherModeFinalTemplate_ExternalCipher<CBC_CTS_Encryption> Encryption;
-	typedef CipherModeFinalTemplate_ExternalCipher<CBC_CTS_Decryption> Decryption;
-};
-
-#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
-typedef CFB_Mode_ExternalCipher::Encryption CFBEncryption;
-typedef CFB_Mode_ExternalCipher::Decryption CFBDecryption;
-typedef OFB_Mode_ExternalCipher::Encryption OFB;
-typedef CTR_Mode_ExternalCipher::Encryption CounterMode;
-#endif
-
-NAMESPACE_END
-
-#endif
+#ifndef CRYPTOPP_MODES_H
+#define CRYPTOPP_MODES_H
+
+/*! \file
+*/
+
+#include "cryptlib.h"
+#include "secblock.h"
+#include "misc.h"
+#include "strciphr.h"
+#include "argnames.h"
+#include "algparam.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+//! Cipher modes documentation. See NIST SP 800-38A for definitions of these modes. See AuthenticatedSymmetricCipherDocumentation for authenticated encryption modes.
+
+/*! Each class derived from this one defines two types, Encryption and Decryption, 
+	both of which implement the SymmetricCipher interface.
+	For each mode there are two classes, one of which is a template class,
+	and the other one has a name that ends in "_ExternalCipher".
+	The "external cipher" mode objects hold a reference to the underlying block cipher,
+	instead of holding an instance of it. The reference must be passed in to the constructor.
+	For the "cipher holder" classes, the CIPHER template parameter should be a class
+	derived from BlockCipherDocumentation, for example DES or AES.
+*/
+struct CipherModeDocumentation : public SymmetricCipherDocumentation
+{
+};
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE CipherModeBase : public SymmetricCipher
+{
+public:
+	size_t MinKeyLength() const {return m_cipher->MinKeyLength();}
+	size_t MaxKeyLength() const {return m_cipher->MaxKeyLength();}
+	size_t DefaultKeyLength() const {return m_cipher->DefaultKeyLength();}
+	size_t GetValidKeyLength(size_t n) const {return m_cipher->GetValidKeyLength(n);}
+	bool IsValidKeyLength(size_t n) const {return m_cipher->IsValidKeyLength(n);}
+
+	unsigned int OptimalDataAlignment() const {return m_cipher->OptimalDataAlignment();}
+
+	unsigned int IVSize() const {return BlockSize();}
+	virtual IV_Requirement IVRequirement() const =0;
+
+	void SetCipher(BlockCipher &cipher)
+	{
+		this->ThrowIfResynchronizable();
+		this->m_cipher = &cipher;
+		this->ResizeBuffers();
+	}
+
+	void SetCipherWithIV(BlockCipher &cipher, const byte *iv, int feedbackSize = 0)
+	{
+		this->ThrowIfInvalidIV(iv);
+		this->m_cipher = &cipher;
+		this->ResizeBuffers();
+		this->SetFeedbackSize(feedbackSize);
+		if (this->IsResynchronizable())
+			this->Resynchronize(iv);
+	}
+
+protected:
+	CipherModeBase() : m_cipher(NULL) {}
+	inline unsigned int BlockSize() const {assert(m_register.size() > 0); return (unsigned int)m_register.size();}
+	virtual void SetFeedbackSize(unsigned int feedbackSize)
+	{
+		if (!(feedbackSize == 0 || feedbackSize == BlockSize()))
+			throw InvalidArgument("CipherModeBase: feedback size cannot be specified for this cipher mode");
+	}
+	virtual void ResizeBuffers()
+	{
+		m_register.New(m_cipher->BlockSize());
+	}
+
+	BlockCipher *m_cipher;
+	AlignedSecByteBlock m_register;
+};
+
+template <class POLICY_INTERFACE>
+class CRYPTOPP_NO_VTABLE ModePolicyCommonTemplate : public CipherModeBase, public POLICY_INTERFACE
+{
+	unsigned int GetAlignment() const {return m_cipher->OptimalDataAlignment();}
+	void CipherSetKey(const NameValuePairs &params, const byte *key, size_t length);
+};
+
+template <class POLICY_INTERFACE>
+void ModePolicyCommonTemplate<POLICY_INTERFACE>::CipherSetKey(const NameValuePairs &params, const byte *key, size_t length)
+{
+	m_cipher->SetKey(key, length, params);
+	ResizeBuffers();
+	int feedbackSize = params.GetIntValueWithDefault(Name::FeedbackSize(), 0);
+	SetFeedbackSize(feedbackSize);
+}
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE CFB_ModePolicy : public ModePolicyCommonTemplate<CFB_CipherAbstractPolicy>
+{
+public:
+	IV_Requirement IVRequirement() const {return RANDOM_IV;}
+	static const char * CRYPTOPP_API StaticAlgorithmName() {return "CFB";}
+
+protected:
+	unsigned int GetBytesPerIteration() const {return m_feedbackSize;}
+	byte * GetRegisterBegin() {return m_register + BlockSize() - m_feedbackSize;}
+	bool CanIterate() const {return m_feedbackSize == BlockSize();}
+	void Iterate(byte *output, const byte *input, CipherDir dir, size_t iterationCount);
+	void TransformRegister();
+	void CipherResynchronize(const byte *iv, size_t length);
+	void SetFeedbackSize(unsigned int feedbackSize);
+	void ResizeBuffers();
+
+	SecByteBlock m_temp;
+	unsigned int m_feedbackSize;
+};
+
+inline void CopyOrZero(void *dest, const void *src, size_t s)
+{
+	if (src)
+		memcpy_s(dest, s, src, s);
+	else
+		memset(dest, 0, s);
+}
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE OFB_ModePolicy : public ModePolicyCommonTemplate<AdditiveCipherAbstractPolicy>
+{
+public:
+	bool CipherIsRandomAccess() const {return false;}
+	IV_Requirement IVRequirement() const {return UNIQUE_IV;}
+	static const char * CRYPTOPP_API StaticAlgorithmName() {return "OFB";}
+
+private:
+	unsigned int GetBytesPerIteration() const {return BlockSize();}
+	unsigned int GetIterationsToBuffer() const {return m_cipher->OptimalNumberOfParallelBlocks();}
+	void WriteKeystream(byte *keystreamBuffer, size_t iterationCount);
+	void CipherResynchronize(byte *keystreamBuffer, const byte *iv, size_t length);
+};
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE CTR_ModePolicy : public ModePolicyCommonTemplate<AdditiveCipherAbstractPolicy>
+{
+public:
+	bool CipherIsRandomAccess() const {return true;}
+	IV_Requirement IVRequirement() const {return RANDOM_IV;}
+	static const char * CRYPTOPP_API StaticAlgorithmName() {return "CTR";}
+
+protected:
+	virtual void IncrementCounterBy256();
+
+	unsigned int GetAlignment() const {return m_cipher->OptimalDataAlignment();}
+	unsigned int GetBytesPerIteration() const {return BlockSize();}
+	unsigned int GetIterationsToBuffer() const {return m_cipher->OptimalNumberOfParallelBlocks();}
+	void WriteKeystream(byte *buffer, size_t iterationCount)
+		{OperateKeystream(WRITE_KEYSTREAM, buffer, NULL, iterationCount);}
+	bool CanOperateKeystream() const {return true;}
+	void OperateKeystream(KeystreamOperation operation, byte *output, const byte *input, size_t iterationCount);
+	void CipherResynchronize(byte *keystreamBuffer, const byte *iv, size_t length);
+	void SeekToIteration(lword iterationCount);
+
+	AlignedSecByteBlock m_counterArray;
+};
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE BlockOrientedCipherModeBase : public CipherModeBase
+{
+public:
+	void UncheckedSetKey(const byte *key, unsigned int length, const NameValuePairs &params);
+	unsigned int MandatoryBlockSize() const {return BlockSize();}
+	bool IsRandomAccess() const {return false;}
+	bool IsSelfInverting() const {return false;}
+	bool IsForwardTransformation() const {return m_cipher->IsForwardTransformation();}
+	void Resynchronize(const byte *iv, int length=-1) {memcpy_s(m_register, m_register.size(), iv, ThrowIfInvalidIVLength(length));}
+
+protected:
+	bool RequireAlignedInput() const {return true;}
+	void ResizeBuffers()
+	{
+		CipherModeBase::ResizeBuffers();
+		m_buffer.New(BlockSize());
+	}
+
+	SecByteBlock m_buffer;
+};
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE ECB_OneWay : public BlockOrientedCipherModeBase
+{
+public:
+	void SetKey(const byte *key, size_t length, const NameValuePairs &params = g_nullNameValuePairs)
+		{m_cipher->SetKey(key, length, params); BlockOrientedCipherModeBase::ResizeBuffers();}
+	IV_Requirement IVRequirement() const {return NOT_RESYNCHRONIZABLE;}
+	unsigned int OptimalBlockSize() const {return BlockSize() * m_cipher->OptimalNumberOfParallelBlocks();}
+	void ProcessData(byte *outString, const byte *inString, size_t length);
+	static const char * CRYPTOPP_API StaticAlgorithmName() {return "ECB";}
+};
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE CBC_ModeBase : public BlockOrientedCipherModeBase
+{
+public:
+	IV_Requirement IVRequirement() const {return UNPREDICTABLE_RANDOM_IV;}
+	bool RequireAlignedInput() const {return false;}
+	unsigned int MinLastBlockSize() const {return 0;}
+	static const char * CRYPTOPP_API StaticAlgorithmName() {return "CBC";}
+};
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE CBC_Encryption : public CBC_ModeBase
+{
+public:
+	void ProcessData(byte *outString, const byte *inString, size_t length);
+};
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE CBC_CTS_Encryption : public CBC_Encryption
+{
+public:
+	void SetStolenIV(byte *iv) {m_stolenIV = iv;}
+	unsigned int MinLastBlockSize() const {return BlockSize()+1;}
+	void ProcessLastBlock(byte *outString, const byte *inString, size_t length);
+	static const char * CRYPTOPP_API StaticAlgorithmName() {return "CBC/CTS";}
+
+protected:
+	void UncheckedSetKey(const byte *key, unsigned int length, const NameValuePairs &params)
+	{
+		CBC_Encryption::UncheckedSetKey(key, length, params);
+		m_stolenIV = params.GetValueWithDefault(Name::StolenIV(), (byte *)NULL);
+	}
+
+	byte *m_stolenIV;
+};
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE CBC_Decryption : public CBC_ModeBase
+{
+public:
+	void ProcessData(byte *outString, const byte *inString, size_t length);
+	
+protected:
+	void ResizeBuffers()
+	{
+		BlockOrientedCipherModeBase::ResizeBuffers();
+		m_temp.New(BlockSize());
+	}
+	AlignedSecByteBlock m_temp;
+};
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE CBC_CTS_Decryption : public CBC_Decryption
+{
+public:
+	unsigned int MinLastBlockSize() const {return BlockSize()+1;}
+	void ProcessLastBlock(byte *outString, const byte *inString, size_t length);
+};
+
+//! _
+template <class CIPHER, class BASE>
+class CipherModeFinalTemplate_CipherHolder : protected ObjectHolder<CIPHER>, public AlgorithmImpl<BASE, CipherModeFinalTemplate_CipherHolder<CIPHER, BASE> >
+{
+public:
+	CipherModeFinalTemplate_CipherHolder()
+	{
+		this->m_cipher = &this->m_object;
+		this->ResizeBuffers();
+	}
+	CipherModeFinalTemplate_CipherHolder(const byte *key, size_t length)
+	{
+		this->m_cipher = &this->m_object;
+		this->SetKey(key, length);
+	}
+	CipherModeFinalTemplate_CipherHolder(const byte *key, size_t length, const byte *iv)
+	{
+		this->m_cipher = &this->m_object;
+		this->SetKey(key, length, MakeParameters(Name::IV(), ConstByteArrayParameter(iv, this->m_cipher->BlockSize())));
+	}
+	CipherModeFinalTemplate_CipherHolder(const byte *key, size_t length, const byte *iv, int feedbackSize)
+	{
+		this->m_cipher = &this->m_object;
+		this->SetKey(key, length, MakeParameters(Name::IV(), ConstByteArrayParameter(iv, this->m_cipher->BlockSize()))(Name::FeedbackSize(), feedbackSize));
+	}
+
+	static std::string CRYPTOPP_API StaticAlgorithmName()
+		{return CIPHER::StaticAlgorithmName() + "/" + BASE::StaticAlgorithmName();}
+};
+
+//! _
+template <class BASE>
+class CipherModeFinalTemplate_ExternalCipher : public BASE
+{
+public:
+	CipherModeFinalTemplate_ExternalCipher() {}
+	CipherModeFinalTemplate_ExternalCipher(BlockCipher &cipher)
+		{this->SetCipher(cipher);}
+	CipherModeFinalTemplate_ExternalCipher(BlockCipher &cipher, const byte *iv, int feedbackSize = 0)
+		{this->SetCipherWithIV(cipher, iv, feedbackSize);}
+
+	std::string AlgorithmName() const
+		{return (this->m_cipher ? this->m_cipher->AlgorithmName() + "/" : std::string("")) + BASE::StaticAlgorithmName();}
+};
+
+CRYPTOPP_DLL_TEMPLATE_CLASS CFB_CipherTemplate<AbstractPolicyHolder<CFB_CipherAbstractPolicy, CFB_ModePolicy> >;
+CRYPTOPP_DLL_TEMPLATE_CLASS CFB_EncryptionTemplate<AbstractPolicyHolder<CFB_CipherAbstractPolicy, CFB_ModePolicy> >;
+CRYPTOPP_DLL_TEMPLATE_CLASS CFB_DecryptionTemplate<AbstractPolicyHolder<CFB_CipherAbstractPolicy, CFB_ModePolicy> >;
+
+//! CFB mode
+template <class CIPHER>
+struct CFB_Mode : public CipherModeDocumentation
+{
+	typedef CipherModeFinalTemplate_CipherHolder<CPP_TYPENAME CIPHER::Encryption, ConcretePolicyHolder<Empty, CFB_EncryptionTemplate<AbstractPolicyHolder<CFB_CipherAbstractPolicy, CFB_ModePolicy> > > > Encryption;
+	typedef CipherModeFinalTemplate_CipherHolder<CPP_TYPENAME CIPHER::Encryption, ConcretePolicyHolder<Empty, CFB_DecryptionTemplate<AbstractPolicyHolder<CFB_CipherAbstractPolicy, CFB_ModePolicy> > > > Decryption;
+};
+
+//! CFB mode, external cipher
+struct CFB_Mode_ExternalCipher : public CipherModeDocumentation
+{
+	typedef CipherModeFinalTemplate_ExternalCipher<ConcretePolicyHolder<Empty, CFB_EncryptionTemplate<AbstractPolicyHolder<CFB_CipherAbstractPolicy, CFB_ModePolicy> > > > Encryption;
+	typedef CipherModeFinalTemplate_ExternalCipher<ConcretePolicyHolder<Empty, CFB_DecryptionTemplate<AbstractPolicyHolder<CFB_CipherAbstractPolicy, CFB_ModePolicy> > > > Decryption;
+};
+
+//! CFB mode FIPS variant, requiring full block plaintext according to FIPS 800-38A
+template <class CIPHER>
+struct CFB_FIPS_Mode : public CipherModeDocumentation
+{
+	typedef CipherModeFinalTemplate_CipherHolder<CPP_TYPENAME CIPHER::Encryption, ConcretePolicyHolder<Empty, CFB_RequireFullDataBlocks<CFB_EncryptionTemplate<AbstractPolicyHolder<CFB_CipherAbstractPolicy, CFB_ModePolicy> > > > > Encryption;
+	typedef CipherModeFinalTemplate_CipherHolder<CPP_TYPENAME CIPHER::Encryption, ConcretePolicyHolder<Empty, CFB_RequireFullDataBlocks<CFB_DecryptionTemplate<AbstractPolicyHolder<CFB_CipherAbstractPolicy, CFB_ModePolicy> > > > > Decryption;
+};
+
+//! CFB mode FIPS variant, requiring full block plaintext according to FIPS 800-38A, external cipher
+struct CFB_FIPS_Mode_ExternalCipher : public CipherModeDocumentation
+{
+	typedef CipherModeFinalTemplate_ExternalCipher<ConcretePolicyHolder<Empty, CFB_RequireFullDataBlocks<CFB_EncryptionTemplate<AbstractPolicyHolder<CFB_CipherAbstractPolicy, CFB_ModePolicy> > > > > Encryption;
+	typedef CipherModeFinalTemplate_ExternalCipher<ConcretePolicyHolder<Empty, CFB_RequireFullDataBlocks<CFB_DecryptionTemplate<AbstractPolicyHolder<CFB_CipherAbstractPolicy, CFB_ModePolicy> > > > > Decryption;
+};
+
+CRYPTOPP_DLL_TEMPLATE_CLASS AdditiveCipherTemplate<AbstractPolicyHolder<AdditiveCipherAbstractPolicy, OFB_ModePolicy> >;
+
+//! OFB mode
+template <class CIPHER>
+struct OFB_Mode : public CipherModeDocumentation
+{
+	typedef CipherModeFinalTemplate_CipherHolder<CPP_TYPENAME CIPHER::Encryption, ConcretePolicyHolder<Empty, AdditiveCipherTemplate<AbstractPolicyHolder<AdditiveCipherAbstractPolicy, OFB_ModePolicy> > > > Encryption;
+	typedef Encryption Decryption;
+};
+
+//! OFB mode, external cipher
+struct OFB_Mode_ExternalCipher : public CipherModeDocumentation
+{
+	typedef CipherModeFinalTemplate_ExternalCipher<ConcretePolicyHolder<Empty, AdditiveCipherTemplate<AbstractPolicyHolder<AdditiveCipherAbstractPolicy, OFB_ModePolicy> > > > Encryption;
+	typedef Encryption Decryption;
+};
+
+CRYPTOPP_DLL_TEMPLATE_CLASS AdditiveCipherTemplate<AbstractPolicyHolder<AdditiveCipherAbstractPolicy, CTR_ModePolicy> >;
+CRYPTOPP_DLL_TEMPLATE_CLASS CipherModeFinalTemplate_ExternalCipher<ConcretePolicyHolder<Empty, AdditiveCipherTemplate<AbstractPolicyHolder<AdditiveCipherAbstractPolicy, CTR_ModePolicy> > > >;
+
+//! CTR mode
+template <class CIPHER>
+struct CTR_Mode : public CipherModeDocumentation
+{
+	typedef CipherModeFinalTemplate_CipherHolder<CPP_TYPENAME CIPHER::Encryption, ConcretePolicyHolder<Empty, AdditiveCipherTemplate<AbstractPolicyHolder<AdditiveCipherAbstractPolicy, CTR_ModePolicy> > > > Encryption;
+	typedef Encryption Decryption;
+};
+
+//! CTR mode, external cipher
+struct CTR_Mode_ExternalCipher : public CipherModeDocumentation
+{
+	typedef CipherModeFinalTemplate_ExternalCipher<ConcretePolicyHolder<Empty, AdditiveCipherTemplate<AbstractPolicyHolder<AdditiveCipherAbstractPolicy, CTR_ModePolicy> > > > Encryption;
+	typedef Encryption Decryption;
+};
+
+//! ECB mode
+template <class CIPHER>
+struct ECB_Mode : public CipherModeDocumentation
+{
+	typedef CipherModeFinalTemplate_CipherHolder<CPP_TYPENAME CIPHER::Encryption, ECB_OneWay> Encryption;
+	typedef CipherModeFinalTemplate_CipherHolder<CPP_TYPENAME CIPHER::Decryption, ECB_OneWay> Decryption;
+};
+
+CRYPTOPP_DLL_TEMPLATE_CLASS CipherModeFinalTemplate_ExternalCipher<ECB_OneWay>;
+
+//! ECB mode, external cipher
+struct ECB_Mode_ExternalCipher : public CipherModeDocumentation
+{
+	typedef CipherModeFinalTemplate_ExternalCipher<ECB_OneWay> Encryption;
+	typedef Encryption Decryption;
+};
+
+//! CBC mode
+template <class CIPHER>
+struct CBC_Mode : public CipherModeDocumentation
+{
+	typedef CipherModeFinalTemplate_CipherHolder<CPP_TYPENAME CIPHER::Encryption, CBC_Encryption> Encryption;
+	typedef CipherModeFinalTemplate_CipherHolder<CPP_TYPENAME CIPHER::Decryption, CBC_Decryption> Decryption;
+};
+
+CRYPTOPP_DLL_TEMPLATE_CLASS CipherModeFinalTemplate_ExternalCipher<CBC_Encryption>;
+CRYPTOPP_DLL_TEMPLATE_CLASS CipherModeFinalTemplate_ExternalCipher<CBC_Decryption>;
+
+//! CBC mode, external cipher
+struct CBC_Mode_ExternalCipher : public CipherModeDocumentation
+{
+	typedef CipherModeFinalTemplate_ExternalCipher<CBC_Encryption> Encryption;
+	typedef CipherModeFinalTemplate_ExternalCipher<CBC_Decryption> Decryption;
+};
+
+//! CBC mode with ciphertext stealing
+template <class CIPHER>
+struct CBC_CTS_Mode : public CipherModeDocumentation
+{
+	typedef CipherModeFinalTemplate_CipherHolder<CPP_TYPENAME CIPHER::Encryption, CBC_CTS_Encryption> Encryption;
+	typedef CipherModeFinalTemplate_CipherHolder<CPP_TYPENAME CIPHER::Decryption, CBC_CTS_Decryption> Decryption;
+};
+
+CRYPTOPP_DLL_TEMPLATE_CLASS CipherModeFinalTemplate_ExternalCipher<CBC_CTS_Encryption>;
+CRYPTOPP_DLL_TEMPLATE_CLASS CipherModeFinalTemplate_ExternalCipher<CBC_CTS_Decryption>;
+
+//! CBC mode with ciphertext stealing, external cipher
+struct CBC_CTS_Mode_ExternalCipher : public CipherModeDocumentation
+{
+	typedef CipherModeFinalTemplate_ExternalCipher<CBC_CTS_Encryption> Encryption;
+	typedef CipherModeFinalTemplate_ExternalCipher<CBC_CTS_Decryption> Decryption;
+};
+
+#ifdef CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY
+typedef CFB_Mode_ExternalCipher::Encryption CFBEncryption;
+typedef CFB_Mode_ExternalCipher::Decryption CFBDecryption;
+typedef OFB_Mode_ExternalCipher::Encryption OFB;
+typedef CTR_Mode_ExternalCipher::Encryption CounterMode;
+#endif
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/modexppc.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/modexppc.h
index 7b2b55e2..fbe70127 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/modexppc.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/modexppc.h
@@ -1,32 +1,34 @@
-#ifndef CRYPTOPP_MODEXPPC_H
-#define CRYPTOPP_MODEXPPC_H
-
-#include "modarith.h"
-#include "eprecomp.h"
-#include "smartptr.h"
-#include "pubkey.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-class ModExpPrecomputation : public DL_GroupPrecomputation<Integer>
-{
-public:
-	// DL_GroupPrecomputation
-	bool NeedConversions() const {return true;}
-	Element ConvertIn(const Element &v) const {return m_mr->ConvertIn(v);}
-	virtual Element ConvertOut(const Element &v) const {return m_mr->ConvertOut(v);}
-	const AbstractGroup<Element> & GetGroup() const {return m_mr->MultiplicativeGroup();}
-	Element BERDecodeElement(BufferedTransformation &bt) const {return Integer(bt);}
-	void DEREncodeElement(BufferedTransformation &bt, const Element &v) const {v.DEREncode(bt);}
-
-	// non-inherited
-	void SetModulus(const Integer &v) {m_mr.reset(new MontgomeryRepresentation(v));}
-	const Integer & GetModulus() const {return m_mr->GetModulus();}
-
-private:
-	value_ptr<MontgomeryRepresentation> m_mr;
-};
-
-NAMESPACE_END
-
-#endif
+#ifndef CRYPTOPP_MODEXPPC_H
+#define CRYPTOPP_MODEXPPC_H
+
+#include "modarith.h"
+#include "eprecomp.h"
+#include "smartptr.h"
+#include "pubkey.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+CRYPTOPP_DLL_TEMPLATE_CLASS DL_FixedBasePrecomputationImpl<Integer>;
+
+class ModExpPrecomputation : public DL_GroupPrecomputation<Integer>
+{
+public:
+	// DL_GroupPrecomputation
+	bool NeedConversions() const {return true;}
+	Element ConvertIn(const Element &v) const {return m_mr->ConvertIn(v);}
+	virtual Element ConvertOut(const Element &v) const {return m_mr->ConvertOut(v);}
+	const AbstractGroup<Element> & GetGroup() const {return m_mr->MultiplicativeGroup();}
+	Element BERDecodeElement(BufferedTransformation &bt) const {return Integer(bt);}
+	void DEREncodeElement(BufferedTransformation &bt, const Element &v) const {v.DEREncode(bt);}
+
+	// non-inherited
+	void SetModulus(const Integer &v) {m_mr.reset(new MontgomeryRepresentation(v));}
+	const Integer & GetModulus() const {return m_mr->GetModulus();}
+
+private:
+	value_ptr<MontgomeryRepresentation> m_mr;
+};
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/mqueue.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/mqueue.h
index 3573c573..efa57a7c 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/mqueue.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/mqueue.h
@@ -1,98 +1,100 @@
-#ifndef CRYPTOPP_MQUEUE_H
-#define CRYPTOPP_MQUEUE_H
-
-#include "queue.h"
-#include "filters.h"
-#include <deque>
-
-NAMESPACE_BEGIN(CryptoPP)
-
-//! Message Queue
-class MessageQueue : public AutoSignaling<BufferedTransformation>
-{
-public:
-	MessageQueue(unsigned int nodeSize=256);
-
-	void IsolatedInitialize(const NameValuePairs &parameters)
-		{m_queue.IsolatedInitialize(parameters); m_lengths.assign(1, 0U); m_messageCounts.assign(1, 0U);}
-	unsigned int Put2(const byte *begin, unsigned int length, int messageEnd, bool blocking)
-	{
-		m_queue.Put(begin, length);
-		m_lengths.back() += length;
-		if (messageEnd)
-		{
-			m_lengths.push_back(0);
-			m_messageCounts.back()++;
-		}
-		return 0;
-	}
-	bool IsolatedFlush(bool hardFlush, bool blocking) {return false;}
-	bool IsolatedMessageSeriesEnd(bool blocking)
-		{m_messageCounts.push_back(0); return false;}
-
-	unsigned long MaxRetrievable() const
-		{return m_lengths.front();}
-	bool AnyRetrievable() const
-		{return m_lengths.front() > 0;}
-
-	unsigned int TransferTo2(BufferedTransformation &target, unsigned long &transferBytes, const std::string &channel=NULL_CHANNEL, bool blocking=true);
-	unsigned int CopyRangeTo2(BufferedTransformation &target, unsigned long &begin, unsigned long end=ULONG_MAX, const std::string &channel=NULL_CHANNEL, bool blocking=true) const;
-
-	unsigned long TotalBytesRetrievable() const
-		{return m_queue.MaxRetrievable();}
-	unsigned int NumberOfMessages() const
-		{return m_lengths.size()-1;}
-	bool GetNextMessage();
-
-	unsigned int NumberOfMessagesInThisSeries() const
-		{return m_messageCounts[0];}
-	unsigned int NumberOfMessageSeries() const
-		{return m_messageCounts.size()-1;}
-
-	unsigned int CopyMessagesTo(BufferedTransformation &target, unsigned int count=UINT_MAX, const std::string &channel=NULL_CHANNEL) const;
-
-	const byte * Spy(unsigned int &contiguousSize) const;
-
-	void swap(MessageQueue &rhs);
-
-private:
-	ByteQueue m_queue;
-	std::deque<unsigned long> m_lengths, m_messageCounts;
-};
-
-
-//! A filter that checks messages on two channels for equality
-class EqualityComparisonFilter : public Unflushable<Multichannel<Filter> >
-{
-public:
-	struct MismatchDetected : public Exception {MismatchDetected() : Exception(DATA_INTEGRITY_CHECK_FAILED, "EqualityComparisonFilter: did not receive the same data on two channels") {}};
-
-	/*! if throwIfNotEqual is false, this filter will output a '\0' byte when it detects a mismatch, '\1' otherwise */
-	EqualityComparisonFilter(BufferedTransformation *attachment=NULL, bool throwIfNotEqual=true, const std::string &firstChannel="0", const std::string &secondChannel="1")
-		: Unflushable<Multichannel<Filter> >(attachment), m_throwIfNotEqual(throwIfNotEqual), m_mismatchDetected(false)
-		, m_firstChannel(firstChannel), m_secondChannel(secondChannel) {}
-
-	unsigned int ChannelPut2(const std::string &channel, const byte *begin, unsigned int length, int messageEnd, bool blocking);
-
-	void ChannelInitialize(const std::string &channel, const NameValuePairs &parameters=g_nullNameValuePairs, int propagation=-1);
-	bool ChannelMessageSeriesEnd(const std::string &channel, int propagation=-1, bool blocking=true);
-
-private:
-	unsigned int MapChannel(const std::string &channel) const;
-	bool HandleMismatchDetected(bool blocking);
-
-	bool m_throwIfNotEqual, m_mismatchDetected;
-	std::string m_firstChannel, m_secondChannel;
-	MessageQueue m_q[2];
-};
-
-NAMESPACE_END
-
-NAMESPACE_BEGIN(std)
-template<> inline void swap(CryptoPP::MessageQueue &a, CryptoPP::MessageQueue &b)
-{
-	a.swap(b);
-}
-NAMESPACE_END
-
-#endif
+#ifndef CRYPTOPP_MQUEUE_H
+#define CRYPTOPP_MQUEUE_H
+
+#include "queue.h"
+#include "filters.h"
+#include <deque>
+
+NAMESPACE_BEGIN(CryptoPP)
+
+//! Message Queue
+class CRYPTOPP_DLL MessageQueue : public AutoSignaling<BufferedTransformation>
+{
+public:
+	MessageQueue(unsigned int nodeSize=256);
+
+	void IsolatedInitialize(const NameValuePairs &parameters)
+		{m_queue.IsolatedInitialize(parameters); m_lengths.assign(1, 0U); m_messageCounts.assign(1, 0U);}
+	size_t Put2(const byte *begin, size_t length, int messageEnd, bool blocking)
+	{
+		m_queue.Put(begin, length);
+		m_lengths.back() += length;
+		if (messageEnd)
+		{
+			m_lengths.push_back(0);
+			m_messageCounts.back()++;
+		}
+		return 0;
+	}
+	bool IsolatedFlush(bool hardFlush, bool blocking) {return false;}
+	bool IsolatedMessageSeriesEnd(bool blocking)
+		{m_messageCounts.push_back(0); return false;}
+
+	lword MaxRetrievable() const
+		{return m_lengths.front();}
+	bool AnyRetrievable() const
+		{return m_lengths.front() > 0;}
+
+	size_t TransferTo2(BufferedTransformation &target, lword &transferBytes, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true);
+	size_t CopyRangeTo2(BufferedTransformation &target, lword &begin, lword end=LWORD_MAX, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true) const;
+
+	lword TotalBytesRetrievable() const
+		{return m_queue.MaxRetrievable();}
+	unsigned int NumberOfMessages() const
+		{return (unsigned int)m_lengths.size()-1;}
+	bool GetNextMessage();
+
+	unsigned int NumberOfMessagesInThisSeries() const
+		{return m_messageCounts[0];}
+	unsigned int NumberOfMessageSeries() const
+		{return (unsigned int)m_messageCounts.size()-1;}
+
+	unsigned int CopyMessagesTo(BufferedTransformation &target, unsigned int count=UINT_MAX, const std::string &channel=DEFAULT_CHANNEL) const;
+
+	const byte * Spy(size_t &contiguousSize) const;
+
+	void swap(MessageQueue &rhs);
+
+private:
+	ByteQueue m_queue;
+	std::deque<lword> m_lengths;
+	std::deque<unsigned int> m_messageCounts;
+};
+
+
+//! A filter that checks messages on two channels for equality
+class CRYPTOPP_DLL EqualityComparisonFilter : public Unflushable<Multichannel<Filter> >
+{
+public:
+	struct MismatchDetected : public Exception {MismatchDetected() : Exception(DATA_INTEGRITY_CHECK_FAILED, "EqualityComparisonFilter: did not receive the same data on two channels") {}};
+
+	/*! if throwIfNotEqual is false, this filter will output a '\\0' byte when it detects a mismatch, '\\1' otherwise */
+	EqualityComparisonFilter(BufferedTransformation *attachment=NULL, bool throwIfNotEqual=true, const std::string &firstChannel="0", const std::string &secondChannel="1")
+		: m_throwIfNotEqual(throwIfNotEqual), m_mismatchDetected(false)
+		, m_firstChannel(firstChannel), m_secondChannel(secondChannel)
+		{Detach(attachment);}
+
+	size_t ChannelPut2(const std::string &channel, const byte *begin, size_t length, int messageEnd, bool blocking);
+	bool ChannelMessageSeriesEnd(const std::string &channel, int propagation=-1, bool blocking=true);
+
+private:
+	unsigned int MapChannel(const std::string &channel) const;
+	bool HandleMismatchDetected(bool blocking);
+
+	bool m_throwIfNotEqual, m_mismatchDetected;
+	std::string m_firstChannel, m_secondChannel;
+	MessageQueue m_q[2];
+};
+
+NAMESPACE_END
+
+#ifndef __BORLANDC__
+NAMESPACE_BEGIN(std)
+template<> inline void swap(CryptoPP::MessageQueue &a, CryptoPP::MessageQueue &b)
+{
+	a.swap(b);
+}
+NAMESPACE_END
+#endif
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/nbtheory.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/nbtheory.h
index ea37f3c6..63647926 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/nbtheory.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/nbtheory.h
@@ -1,143 +1,131 @@
-// nbtheory.h - written and placed in the public domain by Wei Dai
-
-#ifndef CRYPTOPP_NBTHEORY_H
-#define CRYPTOPP_NBTHEORY_H
-
-#include "integer.h"
-#include "algparam.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-// export a table of small primes
-extern const unsigned int maxPrimeTableSize;
-extern const word lastSmallPrime;
-extern unsigned int primeTableSize;
-extern word primeTable[];
-
-// build up the table to maxPrimeTableSize
-void BuildPrimeTable();
-
-// ************ primality testing ****************
-
-// generate a provable prime
-Integer MaurerProvablePrime(RandomNumberGenerator &rng, unsigned int bits);
-Integer MihailescuProvablePrime(RandomNumberGenerator &rng, unsigned int bits);
-
-bool IsSmallPrime(const Integer &p);
-
-// returns true if p is divisible by some prime less than bound
-// bound not be greater than the largest entry in the prime table
-bool TrialDivision(const Integer &p, unsigned bound);
-
-// returns true if p is NOT divisible by small primes
-bool SmallDivisorsTest(const Integer &p);
-
-// These is no reason to use these two, use the ones below instead
-bool IsFermatProbablePrime(const Integer &n, const Integer &b);
-bool IsLucasProbablePrime(const Integer &n);
-
-bool IsStrongProbablePrime(const Integer &n, const Integer &b);
-bool IsStrongLucasProbablePrime(const Integer &n);
-
-// Rabin-Miller primality test, i.e. repeating the strong probable prime test 
-// for several rounds with random bases
-bool RabinMillerTest(RandomNumberGenerator &rng, const Integer &w, unsigned int rounds);
-
-// primality test, used to generate primes
-bool IsPrime(const Integer &p);
-
-// more reliable than IsPrime(), used to verify primes generated by others
-bool VerifyPrime(RandomNumberGenerator &rng, const Integer &p, unsigned int level = 1);
-
-class PrimeSelector
-{
-public:
-	const PrimeSelector *GetSelectorPointer() const {return this;}
-	virtual bool IsAcceptable(const Integer &candidate) const =0;
-};
-
-// use a fast sieve to find the first probable prime in {x | p<=x<=max and x%mod==equiv}
-// returns true iff successful, value of p is undefined if no such prime exists
-bool FirstPrime(Integer &p, const Integer &max, const Integer &equiv, const Integer &mod, const PrimeSelector *pSelector);
-
-unsigned int PrimeSearchInterval(const Integer &max);
-
-AlgorithmParameters<AlgorithmParameters<AlgorithmParameters<NullNameValuePairs, Integer::RandomNumberType>, Integer>, Integer>
-	MakeParametersForTwoPrimesOfEqualSize(unsigned int productBitLength);
-
-// ********** other number theoretic functions ************
-
-inline Integer GCD(const Integer &a, const Integer &b)
-	{return Integer::Gcd(a,b);}
-inline bool RelativelyPrime(const Integer &a, const Integer &b)
-	{return Integer::Gcd(a,b) == Integer::One();}
-inline Integer LCM(const Integer &a, const Integer &b)
-	{return a/Integer::Gcd(a,b)*b;}
-inline Integer EuclideanMultiplicativeInverse(const Integer &a, const Integer &b)
-	{return a.InverseMod(b);}
-
-// use Chinese Remainder Theorem to calculate x given x mod p and x mod q
-Integer CRT(const Integer &xp, const Integer &p, const Integer &xq, const Integer &q);
-// use this one if u = inverse of p mod q has been precalculated
-Integer CRT(const Integer &xp, const Integer &p, const Integer &xq, const Integer &q, const Integer &u);
-
-// if b is prime, then Jacobi(a, b) returns 0 if a%b==0, 1 if a is quadratic residue mod b, -1 otherwise
-// check a number theory book for what Jacobi symbol means when b is not prime
-int Jacobi(const Integer &a, const Integer &b);
-
-// calculates the Lucas function V_e(p, 1) mod n
-Integer Lucas(const Integer &e, const Integer &p, const Integer &n);
-// calculates x such that m==Lucas(e, x, p*q), p q primes
-Integer InverseLucas(const Integer &e, const Integer &m, const Integer &p, const Integer &q);
-// use this one if u=inverse of p mod q has been precalculated
-Integer InverseLucas(const Integer &e, const Integer &m, const Integer &p, const Integer &q, const Integer &u);
-
-inline Integer ModularExponentiation(const Integer &a, const Integer &e, const Integer &m)
-	{return a_exp_b_mod_c(a, e, m);}
-// returns x such that x*x%p == a, p prime
-Integer ModularSquareRoot(const Integer &a, const Integer &p);
-// returns x such that a==ModularExponentiation(x, e, p*q), p q primes,
-// and e relatively prime to (p-1)*(q-1)
-Integer ModularRoot(const Integer &a, const Integer &e, const Integer &p, const Integer &q);
-// use this one if dp=d%(p-1), dq=d%(q-1), (d is inverse of e mod (p-1)*(q-1))
-// and u=inverse of p mod q have been precalculated
-Integer ModularRoot(const Integer &a, const Integer &dp, const Integer &dq, const Integer &p, const Integer &q, const Integer &u);
-
-// find r1 and r2 such that ax^2 + bx + c == 0 (mod p) for x in {r1, r2}, p prime
-// returns true if solutions exist
-bool SolveModularQuadraticEquation(Integer &r1, Integer &r2, const Integer &a, const Integer &b, const Integer &c, const Integer &p);
-
-// returns log base 2 of estimated number of operations to calculate discrete log or factor a number
-unsigned int DiscreteLogWorkFactor(unsigned int bitlength);
-unsigned int FactoringWorkFactor(unsigned int bitlength);
-
-// ********************************************************
-
-//! generator of prime numbers of special forms
-class PrimeAndGenerator
-{
-public:
-	PrimeAndGenerator() {}
-	// generate a random prime p of the form 2*q+delta, where delta is 1 or -1 and q is also prime
-	// Precondition: pbits > 5
-	// warning: this is slow, because primes of this form are harder to find
-	PrimeAndGenerator(signed int delta, RandomNumberGenerator &rng, unsigned int pbits)
-		{Generate(delta, rng, pbits, pbits-1);}
-	// generate a random prime p of the form 2*r*q+delta, where q is also prime
-	// Precondition: qbits > 4 && pbits > qbits
-	PrimeAndGenerator(signed int delta, RandomNumberGenerator &rng, unsigned int pbits, unsigned qbits)
-		{Generate(delta, rng, pbits, qbits);}
-	
-	void Generate(signed int delta, RandomNumberGenerator &rng, unsigned int pbits, unsigned qbits);
-
-	const Integer& Prime() const {return p;}
-	const Integer& SubPrime() const {return q;}
-	const Integer& Generator() const {return g;}
-
-private:
-	Integer p, q, g;
-};
-
-NAMESPACE_END
-
-#endif
+// nbtheory.h - written and placed in the public domain by Wei Dai
+
+#ifndef CRYPTOPP_NBTHEORY_H
+#define CRYPTOPP_NBTHEORY_H
+
+#include "integer.h"
+#include "algparam.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+// obtain pointer to small prime table and get its size
+CRYPTOPP_DLL const word16 * CRYPTOPP_API GetPrimeTable(unsigned int &size);
+
+// ************ primality testing ****************
+
+// generate a provable prime
+CRYPTOPP_DLL Integer CRYPTOPP_API MaurerProvablePrime(RandomNumberGenerator &rng, unsigned int bits);
+CRYPTOPP_DLL Integer CRYPTOPP_API MihailescuProvablePrime(RandomNumberGenerator &rng, unsigned int bits);
+
+CRYPTOPP_DLL bool CRYPTOPP_API IsSmallPrime(const Integer &p);
+
+// returns true if p is divisible by some prime less than bound
+// bound not be greater than the largest entry in the prime table
+CRYPTOPP_DLL bool CRYPTOPP_API TrialDivision(const Integer &p, unsigned bound);
+
+// returns true if p is NOT divisible by small primes
+CRYPTOPP_DLL bool CRYPTOPP_API SmallDivisorsTest(const Integer &p);
+
+// These is no reason to use these two, use the ones below instead
+CRYPTOPP_DLL bool CRYPTOPP_API IsFermatProbablePrime(const Integer &n, const Integer &b);
+CRYPTOPP_DLL bool CRYPTOPP_API IsLucasProbablePrime(const Integer &n);
+
+CRYPTOPP_DLL bool CRYPTOPP_API IsStrongProbablePrime(const Integer &n, const Integer &b);
+CRYPTOPP_DLL bool CRYPTOPP_API IsStrongLucasProbablePrime(const Integer &n);
+
+// Rabin-Miller primality test, i.e. repeating the strong probable prime test 
+// for several rounds with random bases
+CRYPTOPP_DLL bool CRYPTOPP_API RabinMillerTest(RandomNumberGenerator &rng, const Integer &w, unsigned int rounds);
+
+// primality test, used to generate primes
+CRYPTOPP_DLL bool CRYPTOPP_API IsPrime(const Integer &p);
+
+// more reliable than IsPrime(), used to verify primes generated by others
+CRYPTOPP_DLL bool CRYPTOPP_API VerifyPrime(RandomNumberGenerator &rng, const Integer &p, unsigned int level = 1);
+
+class CRYPTOPP_DLL PrimeSelector
+{
+public:
+	const PrimeSelector *GetSelectorPointer() const {return this;}
+	virtual bool IsAcceptable(const Integer &candidate) const =0;
+};
+
+// use a fast sieve to find the first probable prime in {x | p<=x<=max and x%mod==equiv}
+// returns true iff successful, value of p is undefined if no such prime exists
+CRYPTOPP_DLL bool CRYPTOPP_API FirstPrime(Integer &p, const Integer &max, const Integer &equiv, const Integer &mod, const PrimeSelector *pSelector);
+
+CRYPTOPP_DLL unsigned int CRYPTOPP_API PrimeSearchInterval(const Integer &max);
+
+CRYPTOPP_DLL AlgorithmParameters CRYPTOPP_API MakeParametersForTwoPrimesOfEqualSize(unsigned int productBitLength);
+
+// ********** other number theoretic functions ************
+
+inline Integer GCD(const Integer &a, const Integer &b)
+	{return Integer::Gcd(a,b);}
+inline bool RelativelyPrime(const Integer &a, const Integer &b)
+	{return Integer::Gcd(a,b) == Integer::One();}
+inline Integer LCM(const Integer &a, const Integer &b)
+	{return a/Integer::Gcd(a,b)*b;}
+inline Integer EuclideanMultiplicativeInverse(const Integer &a, const Integer &b)
+	{return a.InverseMod(b);}
+
+// use Chinese Remainder Theorem to calculate x given x mod p and x mod q, and u = inverse of p mod q
+CRYPTOPP_DLL Integer CRYPTOPP_API CRT(const Integer &xp, const Integer &p, const Integer &xq, const Integer &q, const Integer &u);
+
+// if b is prime, then Jacobi(a, b) returns 0 if a%b==0, 1 if a is quadratic residue mod b, -1 otherwise
+// check a number theory book for what Jacobi symbol means when b is not prime
+CRYPTOPP_DLL int CRYPTOPP_API Jacobi(const Integer &a, const Integer &b);
+
+// calculates the Lucas function V_e(p, 1) mod n
+CRYPTOPP_DLL Integer CRYPTOPP_API Lucas(const Integer &e, const Integer &p, const Integer &n);
+// calculates x such that m==Lucas(e, x, p*q), p q primes, u=inverse of p mod q
+CRYPTOPP_DLL Integer CRYPTOPP_API InverseLucas(const Integer &e, const Integer &m, const Integer &p, const Integer &q, const Integer &u);
+
+inline Integer ModularExponentiation(const Integer &a, const Integer &e, const Integer &m)
+	{return a_exp_b_mod_c(a, e, m);}
+// returns x such that x*x%p == a, p prime
+CRYPTOPP_DLL Integer CRYPTOPP_API ModularSquareRoot(const Integer &a, const Integer &p);
+// returns x such that a==ModularExponentiation(x, e, p*q), p q primes,
+// and e relatively prime to (p-1)*(q-1)
+// dp=d%(p-1), dq=d%(q-1), (d is inverse of e mod (p-1)*(q-1))
+// and u=inverse of p mod q
+CRYPTOPP_DLL Integer CRYPTOPP_API ModularRoot(const Integer &a, const Integer &dp, const Integer &dq, const Integer &p, const Integer &q, const Integer &u);
+
+// find r1 and r2 such that ax^2 + bx + c == 0 (mod p) for x in {r1, r2}, p prime
+// returns true if solutions exist
+CRYPTOPP_DLL bool CRYPTOPP_API SolveModularQuadraticEquation(Integer &r1, Integer &r2, const Integer &a, const Integer &b, const Integer &c, const Integer &p);
+
+// returns log base 2 of estimated number of operations to calculate discrete log or factor a number
+CRYPTOPP_DLL unsigned int CRYPTOPP_API DiscreteLogWorkFactor(unsigned int bitlength);
+CRYPTOPP_DLL unsigned int CRYPTOPP_API FactoringWorkFactor(unsigned int bitlength);
+
+// ********************************************************
+
+//! generator of prime numbers of special forms
+class CRYPTOPP_DLL PrimeAndGenerator
+{
+public:
+	PrimeAndGenerator() {}
+	// generate a random prime p of the form 2*q+delta, where delta is 1 or -1 and q is also prime
+	// Precondition: pbits > 5
+	// warning: this is slow, because primes of this form are harder to find
+	PrimeAndGenerator(signed int delta, RandomNumberGenerator &rng, unsigned int pbits)
+		{Generate(delta, rng, pbits, pbits-1);}
+	// generate a random prime p of the form 2*r*q+delta, where q is also prime
+	// Precondition: qbits > 4 && pbits > qbits
+	PrimeAndGenerator(signed int delta, RandomNumberGenerator &rng, unsigned int pbits, unsigned qbits)
+		{Generate(delta, rng, pbits, qbits);}
+	
+	void Generate(signed int delta, RandomNumberGenerator &rng, unsigned int pbits, unsigned qbits);
+
+	const Integer& Prime() const {return p;}
+	const Integer& SubPrime() const {return q;}
+	const Integer& Generator() const {return g;}
+
+private:
+	Integer p, q, g;
+};
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/oids.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/oids.h
index 56e15be8..8b103015 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/oids.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/oids.h
@@ -1,112 +1,123 @@
-#ifndef CRYPTOPP_OIDS_H
-#define CRYPTOPP_OIDS_H
-
-// crypto-related ASN.1 object identifiers
-
-#include "asn.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-NAMESPACE_BEGIN(ASN1)
-
-#define DEFINE_OID(value, name)	inline OID name() {return value;}
-
-DEFINE_OID(1, iso)
-	DEFINE_OID(iso()+2, member_body)
-		DEFINE_OID(member_body()+840, iso_us)
-			DEFINE_OID(iso_us()+10040, ansi_x9_57)
-				DEFINE_OID(ansi_x9_57()+4+1, id_dsa)
-			DEFINE_OID(iso_us()+10045, ansi_x9_62)
-				DEFINE_OID(ansi_x9_62()+1, id_fieldType)
-					DEFINE_OID(id_fieldType()+1, prime_field)
-					DEFINE_OID(id_fieldType()+2, characteristic_two_field)
-						DEFINE_OID(characteristic_two_field()+3, id_characteristic_two_basis)
-							DEFINE_OID(id_characteristic_two_basis()+1, gnBasis)
-							DEFINE_OID(id_characteristic_two_basis()+2, tpBasis)
-							DEFINE_OID(id_characteristic_two_basis()+3, ppBasis)
-				DEFINE_OID(ansi_x9_62()+2, id_publicKeyType)
-					DEFINE_OID(id_publicKeyType()+1, id_ecPublicKey)
-				DEFINE_OID(ansi_x9_62()+3, ansi_x9_62_curves)
-					DEFINE_OID(ansi_x9_62_curves()+1, ansi_x9_62_curves_prime)
-						DEFINE_OID(ansi_x9_62_curves_prime()+1, secp192r1)
-						DEFINE_OID(ansi_x9_62_curves_prime()+7, secp256r1)
-			DEFINE_OID(iso_us()+113549, rsadsi)
-				DEFINE_OID(rsadsi()+1, pkcs)
-					DEFINE_OID(pkcs()+1, pkcs_1)
-						DEFINE_OID(pkcs_1()+1, rsaEncryption);
-				DEFINE_OID(rsadsi()+2, rsadsi_digestAlgorithm)
-					DEFINE_OID(rsadsi_digestAlgorithm()+2, id_md2)
-					DEFINE_OID(rsadsi_digestAlgorithm()+5, id_md5)
-	DEFINE_OID(iso()+3, identified_organization);
-		DEFINE_OID(identified_organization()+14, oiw);
-			DEFINE_OID(oiw()+14, oiw_secsig);
-				DEFINE_OID(oiw_secsig()+2, oiw_secsig_algorithms);
-					DEFINE_OID(oiw_secsig_algorithms()+26, id_sha1);
-		DEFINE_OID(identified_organization()+36, teletrust);
-			DEFINE_OID(teletrust()+3+2+1, id_ripemd160)
-		DEFINE_OID(identified_organization()+132, certicom);
-			DEFINE_OID(certicom()+0, certicom_ellipticCurve);
-				// these are sorted by curve type and then by OID
-				// first curves based on GF(p)
-				DEFINE_OID(certicom_ellipticCurve()+6, secp112r1);
-				DEFINE_OID(certicom_ellipticCurve()+7, secp112r2);
-				DEFINE_OID(certicom_ellipticCurve()+8, secp160r1);
-				DEFINE_OID(certicom_ellipticCurve()+9, secp160k1);
-				DEFINE_OID(certicom_ellipticCurve()+10, secp256k1);
-				DEFINE_OID(certicom_ellipticCurve()+28, secp128r1);
-				DEFINE_OID(certicom_ellipticCurve()+29, secp128r2);
-				DEFINE_OID(certicom_ellipticCurve()+30, secp160r2);
-				DEFINE_OID(certicom_ellipticCurve()+31, secp192k1);
-				DEFINE_OID(certicom_ellipticCurve()+32, secp224k1);
-				DEFINE_OID(certicom_ellipticCurve()+33, secp224r1);
-				DEFINE_OID(certicom_ellipticCurve()+34, secp384r1);
-				DEFINE_OID(certicom_ellipticCurve()+35, secp521r1);
-				// then curves based on GF(2^n)
-				DEFINE_OID(certicom_ellipticCurve()+1, sect163k1);
-				DEFINE_OID(certicom_ellipticCurve()+2, sect163r1);
-				DEFINE_OID(certicom_ellipticCurve()+3, sect239k1);
-				DEFINE_OID(certicom_ellipticCurve()+4, sect113r1);
-				DEFINE_OID(certicom_ellipticCurve()+5, sect113r2);
-				DEFINE_OID(certicom_ellipticCurve()+15, sect163r2);
-				DEFINE_OID(certicom_ellipticCurve()+16, sect283k1);
-				DEFINE_OID(certicom_ellipticCurve()+17, sect283r1);
-				DEFINE_OID(certicom_ellipticCurve()+22, sect131r1);
-				DEFINE_OID(certicom_ellipticCurve()+23, sect131r2);
-				DEFINE_OID(certicom_ellipticCurve()+24, sect193r1);
-				DEFINE_OID(certicom_ellipticCurve()+25, sect193r2);
-				DEFINE_OID(certicom_ellipticCurve()+26, sect233k1);
-				DEFINE_OID(certicom_ellipticCurve()+27, sect233r1);
-				DEFINE_OID(certicom_ellipticCurve()+36, sect409k1);
-				DEFINE_OID(certicom_ellipticCurve()+37, sect409r1);
-				DEFINE_OID(certicom_ellipticCurve()+38, sect571k1);
-				DEFINE_OID(certicom_ellipticCurve()+39, sect571r1);
-DEFINE_OID(2, joint_iso_ccitt)
-	DEFINE_OID(joint_iso_ccitt()+16, country)
-		DEFINE_OID(country()+840, joint_iso_ccitt_us)
-			DEFINE_OID(joint_iso_ccitt_us()+1, us_organization)
-				DEFINE_OID(us_organization()+101, us_gov)
-					DEFINE_OID(us_gov()+3, csor)
-						DEFINE_OID(csor()+4, nistalgorithms)
-							DEFINE_OID(nistalgorithms()+1, aes)
-								DEFINE_OID(aes()+1, id_aes128_ECB)
-								DEFINE_OID(aes()+2, id_aes128_cbc)
-								DEFINE_OID(aes()+3, id_aes128_ofb)
-								DEFINE_OID(aes()+4, id_aes128_cfb)
-								DEFINE_OID(aes()+21, id_aes192_ECB)
-								DEFINE_OID(aes()+22, id_aes192_cbc)
-								DEFINE_OID(aes()+23, id_aes192_ofb)
-								DEFINE_OID(aes()+24, id_aes192_cfb)
-								DEFINE_OID(aes()+41, id_aes256_ECB)
-								DEFINE_OID(aes()+42, id_aes256_cbc)
-								DEFINE_OID(aes()+43, id_aes256_ofb)
-								DEFINE_OID(aes()+44, id_aes256_cfb)
-							DEFINE_OID(nistalgorithms()+2, nist_hashalgs)
-								DEFINE_OID(nist_hashalgs()+1, id_sha256)
-								DEFINE_OID(nist_hashalgs()+2, id_sha384)
-								DEFINE_OID(nist_hashalgs()+3, id_sha512)
-
-NAMESPACE_END
-
-NAMESPACE_END
-
-#endif
+#ifndef CRYPTOPP_OIDS_H
+#define CRYPTOPP_OIDS_H
+
+// crypto-related ASN.1 object identifiers
+
+#include "asn.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+NAMESPACE_BEGIN(ASN1)
+
+#define DEFINE_OID(value, name)	inline OID name() {return value;}
+
+DEFINE_OID(1, iso)
+	DEFINE_OID(iso()+2, member_body)
+		DEFINE_OID(member_body()+840, iso_us)
+			DEFINE_OID(iso_us()+10040, ansi_x9_57)
+				DEFINE_OID(ansi_x9_57()+4+1, id_dsa)
+			DEFINE_OID(iso_us()+10045, ansi_x9_62)
+				DEFINE_OID(ansi_x9_62()+1, id_fieldType)
+					DEFINE_OID(id_fieldType()+1, prime_field)
+					DEFINE_OID(id_fieldType()+2, characteristic_two_field)
+						DEFINE_OID(characteristic_two_field()+3, id_characteristic_two_basis)
+							DEFINE_OID(id_characteristic_two_basis()+1, gnBasis)
+							DEFINE_OID(id_characteristic_two_basis()+2, tpBasis)
+							DEFINE_OID(id_characteristic_two_basis()+3, ppBasis)
+				DEFINE_OID(ansi_x9_62()+2, id_publicKeyType)
+					DEFINE_OID(id_publicKeyType()+1, id_ecPublicKey)
+				DEFINE_OID(ansi_x9_62()+3, ansi_x9_62_curves)
+					DEFINE_OID(ansi_x9_62_curves()+1, ansi_x9_62_curves_prime)
+						DEFINE_OID(ansi_x9_62_curves_prime()+1, secp192r1)
+						DEFINE_OID(ansi_x9_62_curves_prime()+7, secp256r1)
+			DEFINE_OID(iso_us()+113549, rsadsi)
+				DEFINE_OID(rsadsi()+1, pkcs)
+					DEFINE_OID(pkcs()+1, pkcs_1)
+						DEFINE_OID(pkcs_1()+1, rsaEncryption);
+				DEFINE_OID(rsadsi()+2, rsadsi_digestAlgorithm)
+					DEFINE_OID(rsadsi_digestAlgorithm()+2, id_md2)
+					DEFINE_OID(rsadsi_digestAlgorithm()+5, id_md5)
+	DEFINE_OID(iso()+3, identified_organization);
+		DEFINE_OID(identified_organization()+14, oiw);
+			DEFINE_OID(oiw()+3, oiw_secsig);
+				DEFINE_OID(oiw_secsig()+2, oiw_secsig_algorithms);
+					DEFINE_OID(oiw_secsig_algorithms()+26, id_sha1);
+
+		DEFINE_OID(identified_organization()+36, teletrust);
+			DEFINE_OID(teletrust()+3, teletrust_algorithm)
+				DEFINE_OID(teletrust_algorithm()+2+1, id_ripemd160)
+				DEFINE_OID(teletrust_algorithm()+3+2+8+1, teletrust_ellipticCurve)
+					DEFINE_OID(teletrust_ellipticCurve()+1+1, brainpoolP160r1)
+					DEFINE_OID(teletrust_ellipticCurve()+1+3, brainpoolP192r1)
+					DEFINE_OID(teletrust_ellipticCurve()+1+5, brainpoolP224r1)
+					DEFINE_OID(teletrust_ellipticCurve()+1+7, brainpoolP256r1)
+					DEFINE_OID(teletrust_ellipticCurve()+1+9, brainpoolP320r1)
+					DEFINE_OID(teletrust_ellipticCurve()+1+11, brainpoolP384r1)
+					DEFINE_OID(teletrust_ellipticCurve()+1+13, brainpoolP512r1)
+
+		DEFINE_OID(identified_organization()+132, certicom);
+			DEFINE_OID(certicom()+0, certicom_ellipticCurve);
+				// these are sorted by curve type and then by OID
+				// first curves based on GF(p)
+				DEFINE_OID(certicom_ellipticCurve()+6, secp112r1);
+				DEFINE_OID(certicom_ellipticCurve()+7, secp112r2);
+				DEFINE_OID(certicom_ellipticCurve()+8, secp160r1);
+				DEFINE_OID(certicom_ellipticCurve()+9, secp160k1);
+				DEFINE_OID(certicom_ellipticCurve()+10, secp256k1);
+				DEFINE_OID(certicom_ellipticCurve()+28, secp128r1);
+				DEFINE_OID(certicom_ellipticCurve()+29, secp128r2);
+				DEFINE_OID(certicom_ellipticCurve()+30, secp160r2);
+				DEFINE_OID(certicom_ellipticCurve()+31, secp192k1);
+				DEFINE_OID(certicom_ellipticCurve()+32, secp224k1);
+				DEFINE_OID(certicom_ellipticCurve()+33, secp224r1);
+				DEFINE_OID(certicom_ellipticCurve()+34, secp384r1);
+				DEFINE_OID(certicom_ellipticCurve()+35, secp521r1);
+				// then curves based on GF(2^n)
+				DEFINE_OID(certicom_ellipticCurve()+1, sect163k1);
+				DEFINE_OID(certicom_ellipticCurve()+2, sect163r1);
+				DEFINE_OID(certicom_ellipticCurve()+3, sect239k1);
+				DEFINE_OID(certicom_ellipticCurve()+4, sect113r1);
+				DEFINE_OID(certicom_ellipticCurve()+5, sect113r2);
+				DEFINE_OID(certicom_ellipticCurve()+15, sect163r2);
+				DEFINE_OID(certicom_ellipticCurve()+16, sect283k1);
+				DEFINE_OID(certicom_ellipticCurve()+17, sect283r1);
+				DEFINE_OID(certicom_ellipticCurve()+22, sect131r1);
+				DEFINE_OID(certicom_ellipticCurve()+23, sect131r2);
+				DEFINE_OID(certicom_ellipticCurve()+24, sect193r1);
+				DEFINE_OID(certicom_ellipticCurve()+25, sect193r2);
+				DEFINE_OID(certicom_ellipticCurve()+26, sect233k1);
+				DEFINE_OID(certicom_ellipticCurve()+27, sect233r1);
+				DEFINE_OID(certicom_ellipticCurve()+36, sect409k1);
+				DEFINE_OID(certicom_ellipticCurve()+37, sect409r1);
+				DEFINE_OID(certicom_ellipticCurve()+38, sect571k1);
+				DEFINE_OID(certicom_ellipticCurve()+39, sect571r1);
+DEFINE_OID(2, joint_iso_ccitt)
+	DEFINE_OID(joint_iso_ccitt()+16, country)
+		DEFINE_OID(country()+840, joint_iso_ccitt_us)
+			DEFINE_OID(joint_iso_ccitt_us()+1, us_organization)
+				DEFINE_OID(us_organization()+101, us_gov)
+					DEFINE_OID(us_gov()+3, csor)
+						DEFINE_OID(csor()+4, nistalgorithms)
+							DEFINE_OID(nistalgorithms()+1, aes)
+								DEFINE_OID(aes()+1, id_aes128_ECB)
+								DEFINE_OID(aes()+2, id_aes128_cbc)
+								DEFINE_OID(aes()+3, id_aes128_ofb)
+								DEFINE_OID(aes()+4, id_aes128_cfb)
+								DEFINE_OID(aes()+21, id_aes192_ECB)
+								DEFINE_OID(aes()+22, id_aes192_cbc)
+								DEFINE_OID(aes()+23, id_aes192_ofb)
+								DEFINE_OID(aes()+24, id_aes192_cfb)
+								DEFINE_OID(aes()+41, id_aes256_ECB)
+								DEFINE_OID(aes()+42, id_aes256_cbc)
+								DEFINE_OID(aes()+43, id_aes256_ofb)
+								DEFINE_OID(aes()+44, id_aes256_cfb)
+							DEFINE_OID(nistalgorithms()+2, nist_hashalgs)
+								DEFINE_OID(nist_hashalgs()+1, id_sha256)
+								DEFINE_OID(nist_hashalgs()+2, id_sha384)
+								DEFINE_OID(nist_hashalgs()+3, id_sha512)
+
+NAMESPACE_END
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/osrng.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/osrng.h
new file mode 100644
index 00000000..ae07d057
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/osrng.h
@@ -0,0 +1,156 @@
+#ifndef CRYPTOPP_OSRNG_H
+#define CRYPTOPP_OSRNG_H
+
+//! \file
+
+#include "config.h"
+
+#ifdef OS_RNG_AVAILABLE
+
+#include "randpool.h"
+#include "rng.h"
+#include "aes.h"
+#include "sha.h"
+#include "fips140.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+//! Exception class for Operating-System Random Number Generator.
+class CRYPTOPP_DLL OS_RNG_Err : public Exception
+{
+public:
+	OS_RNG_Err(const std::string &operation);
+};
+
+#ifdef NONBLOCKING_RNG_AVAILABLE
+
+#ifdef CRYPTOPP_WIN32_AVAILABLE
+class CRYPTOPP_DLL MicrosoftCryptoProvider
+{
+public:
+	MicrosoftCryptoProvider();
+	~MicrosoftCryptoProvider();
+#if defined(_WIN64)
+	typedef unsigned __int64 ProviderHandle;	// type HCRYPTPROV, avoid #include <windows.h>
+#else
+	typedef unsigned long ProviderHandle;
+#endif
+	ProviderHandle GetProviderHandle() const {return m_hProvider;}
+private:
+	ProviderHandle m_hProvider;
+};
+
+#pragma comment(lib, "advapi32.lib")
+#endif
+
+//! encapsulate CryptoAPI's CryptGenRandom or /dev/urandom
+class CRYPTOPP_DLL NonblockingRng : public RandomNumberGenerator
+{
+public:
+	NonblockingRng();
+	~NonblockingRng();
+	void GenerateBlock(byte *output, size_t size);
+
+protected:
+#ifdef CRYPTOPP_WIN32_AVAILABLE
+#	ifndef WORKAROUND_MS_BUG_Q258000
+		MicrosoftCryptoProvider m_Provider;
+#	endif
+#else
+	int m_fd;
+#endif
+};
+
+#endif
+
+#ifdef BLOCKING_RNG_AVAILABLE
+
+//! encapsulate /dev/random, or /dev/srandom on OpenBSD
+class CRYPTOPP_DLL BlockingRng : public RandomNumberGenerator
+{
+public:
+	BlockingRng();
+	~BlockingRng();
+	void GenerateBlock(byte *output, size_t size);
+
+protected:
+	int m_fd;
+};
+
+#endif
+
+CRYPTOPP_DLL void CRYPTOPP_API OS_GenerateRandomBlock(bool blocking, byte *output, size_t size);
+
+//! Automaticly Seeded Randomness Pool
+/*! This class seeds itself using an operating system provided RNG. */
+class CRYPTOPP_DLL AutoSeededRandomPool : public RandomPool
+{
+public:
+	//! use blocking to choose seeding with BlockingRng or NonblockingRng. the parameter is ignored if only one of these is available
+	explicit AutoSeededRandomPool(bool blocking = false, unsigned int seedSize = 32)
+		{Reseed(blocking, seedSize);}
+	void Reseed(bool blocking = false, unsigned int seedSize = 32);
+};
+
+//! RNG from ANSI X9.17 Appendix C, seeded using an OS provided RNG
+template <class BLOCK_CIPHER>
+class AutoSeededX917RNG : public RandomNumberGenerator, public NotCopyable
+{
+public:
+	//! use blocking to choose seeding with BlockingRng or NonblockingRng. the parameter is ignored if only one of these is available
+	explicit AutoSeededX917RNG(bool blocking = false, bool autoSeed = true)
+		{if (autoSeed) Reseed(blocking);}
+	void Reseed(bool blocking = false, const byte *additionalEntropy = NULL, size_t length = 0);
+	// exposed for testing
+	void Reseed(const byte *key, size_t keylength, const byte *seed, const byte *timeVector);
+
+	bool CanIncorporateEntropy() const {return true;}
+	void IncorporateEntropy(const byte *input, size_t length) {Reseed(false, input, length);}
+	void GenerateIntoBufferedTransformation(BufferedTransformation &target, const std::string &channel, lword length) {m_rng->GenerateIntoBufferedTransformation(target, channel, length);}
+
+private:
+	member_ptr<RandomNumberGenerator> m_rng;
+};
+
+template <class BLOCK_CIPHER>
+void AutoSeededX917RNG<BLOCK_CIPHER>::Reseed(const byte *key, size_t keylength, const byte *seed, const byte *timeVector)
+{
+	m_rng.reset(new X917RNG(new typename BLOCK_CIPHER::Encryption(key, keylength), seed, timeVector));
+}
+
+template <class BLOCK_CIPHER>
+void AutoSeededX917RNG<BLOCK_CIPHER>::Reseed(bool blocking, const byte *input, size_t length)
+{
+	SecByteBlock seed(BLOCK_CIPHER::BLOCKSIZE + BLOCK_CIPHER::DEFAULT_KEYLENGTH);
+	const byte *key;
+	do
+	{
+		OS_GenerateRandomBlock(blocking, seed, seed.size());
+		if (length > 0)
+		{
+			SHA256 hash;
+			hash.Update(seed, seed.size());
+			hash.Update(input, length);
+			hash.TruncatedFinal(seed, UnsignedMin(hash.DigestSize(), seed.size()));
+		}
+		key = seed + BLOCK_CIPHER::BLOCKSIZE;
+	}	// check that seed and key don't have same value
+	while (memcmp(key, seed, STDMIN((unsigned int)BLOCK_CIPHER::BLOCKSIZE, (unsigned int)BLOCK_CIPHER::DEFAULT_KEYLENGTH)) == 0);
+
+	Reseed(key, BLOCK_CIPHER::DEFAULT_KEYLENGTH, seed, NULL);
+}
+
+CRYPTOPP_DLL_TEMPLATE_CLASS AutoSeededX917RNG<AES>;
+
+//! this is AutoSeededX917RNG\<AES\> in FIPS mode, otherwise it's AutoSeededRandomPool
+#if CRYPTOPP_ENABLE_COMPLIANCE_WITH_FIPS_140_2
+typedef AutoSeededX917RNG<AES> DefaultAutoSeededRNG;
+#else
+typedef AutoSeededRandomPool DefaultAutoSeededRNG;
+#endif
+
+NAMESPACE_END
+
+#endif
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/pch.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/pch.h
new file mode 100644
index 00000000..418c3907
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/pch.h
@@ -0,0 +1,21 @@
+#ifndef CRYPTOPP_PCH_H
+#define CRYPTOPP_PCH_H
+
+#ifdef CRYPTOPP_GENERATE_X64_MASM
+
+	#include "cpu.h"
+
+#else
+
+	#include "config.h"
+
+	#ifdef USE_PRECOMPILED_HEADERS
+		#include "simple.h"
+		#include "secblock.h"
+		#include "misc.h"
+		#include "smartptr.h"
+	#endif
+
+#endif
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/pubkey.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/pubkey.h
index 78b437a7..3a3f3bcd 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/pubkey.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/pubkey.h
@@ -1,1708 +1,1678 @@
-// pubkey.h - written and placed in the public domain by Wei Dai
-
-#ifndef CRYPTOPP_PUBKEY_H
-#define CRYPTOPP_PUBKEY_H
-
-/** \file
-
-	This file contains helper classes/functions for implementing public key algorithms.
-
-	The class hierachies in this .h file tend to look like this:
-<pre>
-                  x1
-                 / \
-                y1  z1
-                 |  |
-            x2<y1>  x2<z1>
-                 |  |
-                y2  z2
-                 |  |
-            x3<y2>  x3<z2>
-                 |  |
-                y3  z3
-</pre>
-	- x1, y1, z1 are abstract interface classes defined in cryptlib.h
-	- x2, y2, z2 are implementations of the interfaces using "abstract policies", which
-	  are pure virtual functions that should return interfaces to interchangeable algorithms.
-	  These classes have "Base" suffixes.
-	- x3, y3, z3 hold actual algorithms and implement those virtual functions.
-	  These classes have "Impl" suffixes.
-
-	The "TF_" prefix means an implementation using trapdoor functions on integers.
-	The "DL_" prefix means an implementation using group operations (in groups where discrete log is hard).
-*/
-
-#include "integer.h"
-#include "filters.h"
-#include "eprecomp.h"
-#include "fips140.h"
-#include "argnames.h"
-#include <memory>
-
-// VC60 workaround: this macro is defined in shlobj.h and conflicts with a template parameter used in this file
-#undef INTERFACE
-
-NAMESPACE_BEGIN(CryptoPP)
-
-Integer NR_EncodeDigest(unsigned int modulusBits, const byte *digest, unsigned int digestLen);
-Integer DSA_EncodeDigest(unsigned int modulusBits, const byte *digest, unsigned int digestLen);
-
-// ********************************************************
-
-//! .
-class TrapdoorFunctionBounds
-{
-public:
-	virtual ~TrapdoorFunctionBounds() {}
-
-	virtual Integer PreimageBound() const =0;
-	virtual Integer ImageBound() const =0;
-	virtual Integer MaxPreimage() const {return --PreimageBound();}
-	virtual Integer MaxImage() const {return --ImageBound();}
-};
-
-//! .
-class RandomizedTrapdoorFunction : public TrapdoorFunctionBounds
-{
-public:
-	virtual Integer ApplyRandomizedFunction(RandomNumberGenerator &rng, const Integer &x) const =0;
-	virtual bool IsRandomized() const {return true;}
-};
-
-//! .
-class TrapdoorFunction : public RandomizedTrapdoorFunction
-{
-public:
-	Integer ApplyRandomizedFunction(RandomNumberGenerator &rng, const Integer &x) const
-		{return ApplyFunction(x);}
-	bool IsRandomized() const {return false;}
-
-	virtual Integer ApplyFunction(const Integer &x) const =0;
-};
-
-//! .
-class RandomizedTrapdoorFunctionInverse
-{
-public:
-	virtual ~RandomizedTrapdoorFunctionInverse() {}
-
-	virtual Integer CalculateRandomizedInverse(RandomNumberGenerator &rng, const Integer &x) const =0;
-	virtual bool IsRandomized() const {return true;}
-};
-
-//! .
-class TrapdoorFunctionInverse : public RandomizedTrapdoorFunctionInverse
-{
-public:
-	virtual ~TrapdoorFunctionInverse() {}
-
-	Integer CalculateRandomizedInverse(RandomNumberGenerator &rng, const Integer &x) const
-		{return CalculateInverse(rng, x);}
-	bool IsRandomized() const {return false;}
-
-	virtual Integer CalculateInverse(RandomNumberGenerator &rng, const Integer &x) const =0;
-};
-
-// ********************************************************
-
-//! .
-class PK_EncryptionMessageEncodingMethod
-{
-public:
-	virtual ~PK_EncryptionMessageEncodingMethod() {}
-
-	//! max size of unpadded message in bytes, given max size of padded message in bits (1 less than size of modulus)
-	virtual unsigned int MaxUnpaddedLength(unsigned int paddedLength) const =0;
-
-	virtual void Pad(RandomNumberGenerator &rng, const byte *raw, unsigned int inputLength, byte *padded, unsigned int paddedBitLength) const =0;
-
-	virtual DecodingResult Unpad(const byte *padded, unsigned int paddedBitLength, byte *raw) const =0;
-};
-
-// ********************************************************
-
-//! .
-template <class TFI, class MEI>
-class TF_Base
-{
-protected:
-	virtual const TrapdoorFunctionBounds & GetTrapdoorFunctionBounds() const =0;
-
-	typedef TFI TrapdoorFunctionInterface;
-	virtual const TrapdoorFunctionInterface & GetTrapdoorFunctionInterface() const =0;
-
-	typedef MEI MessageEncodingInterface;
-	virtual const MessageEncodingInterface & GetMessageEncodingInterface() const =0;
-};
-
-// ********************************************************
-
-//! .
-template <class INTERFACE, class BASE>
-class TF_CryptoSystemBase : public INTERFACE, protected BASE
-{
-public:
-	unsigned int FixedMaxPlaintextLength() const {return GetMessageEncodingInterface().MaxUnpaddedLength(PaddedBlockBitLength());}
-	unsigned int FixedCiphertextLength() const {return GetTrapdoorFunctionBounds().MaxImage().ByteCount();}
-
-protected:
-	unsigned int PaddedBlockByteLength() const {return BitsToBytes(PaddedBlockBitLength());}
-	unsigned int PaddedBlockBitLength() const {return GetTrapdoorFunctionBounds().PreimageBound().BitCount()-1;}
-};
-
-//! .
-class TF_DecryptorBase : public TF_CryptoSystemBase<PK_FixedLengthDecryptor, TF_Base<TrapdoorFunctionInverse, PK_EncryptionMessageEncodingMethod> >
-{
-public:
-	DecodingResult FixedLengthDecrypt(RandomNumberGenerator &rng, const byte *cipherText, byte *plainText) const;
-};
-
-//! .
-class TF_EncryptorBase : public TF_CryptoSystemBase<PK_FixedLengthEncryptor, TF_Base<RandomizedTrapdoorFunction, PK_EncryptionMessageEncodingMethod> >
-{
-public:
-	void Encrypt(RandomNumberGenerator &rng, const byte *plainText, unsigned int plainTextLength, byte *cipherText) const;
-};
-
-// ********************************************************
-
-typedef std::pair<const byte *, unsigned int> HashIdentifier;
-
-//! .
-class PK_SignatureMessageEncodingMethod
-{
-public:
-	virtual ~PK_SignatureMessageEncodingMethod() {}
-
-	virtual unsigned int MaxRecoverableLength(unsigned int representativeBitLength, unsigned int hashIdentifierLength, unsigned int digestLength) const
-		{return 0;}
-
-	bool IsProbabilistic() const 
-		{return true;}
-	bool AllowNonrecoverablePart() const
-		{throw NotImplemented("PK_MessageEncodingMethod: this signature scheme does not support message recovery");}
-	virtual bool RecoverablePartFirst() const
-		{throw NotImplemented("PK_MessageEncodingMethod: this signature scheme does not support message recovery");}
-
-	// for verification, DL
-	virtual void ProcessSemisignature(HashTransformation &hash, const byte *semisignature, unsigned int semisignatureLength) const {}
-
-	// for signature
-	virtual void ProcessRecoverableMessage(HashTransformation &hash, 
-		const byte *recoverableMessage, unsigned int recoverableMessageLength, 
-		const byte *presignature, unsigned int presignatureLength,
-		SecByteBlock &semisignature) const
-	{
-		if (RecoverablePartFirst())
-			assert(!"ProcessRecoverableMessage() not implemented");
-	}
-
-	virtual void ComputeMessageRepresentative(RandomNumberGenerator &rng, 
-		const byte *recoverableMessage, unsigned int recoverableMessageLength,
-		HashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,
-		byte *representative, unsigned int representativeBitLength) const =0;
-
-	virtual bool VerifyMessageRepresentative(
-		HashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,
-		byte *representative, unsigned int representativeBitLength) const =0;
-
-	virtual DecodingResult RecoverMessageFromRepresentative(	// for TF
-		HashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,
-		byte *representative, unsigned int representativeBitLength,
-		byte *recoveredMessage) const
-		{throw NotImplemented("PK_MessageEncodingMethod: this signature scheme does not support message recovery");}
-
-	virtual DecodingResult RecoverMessageFromSemisignature(		// for DL
-		HashTransformation &hash, HashIdentifier hashIdentifier,
-		const byte *presignature, unsigned int presignatureLength,
-		const byte *semisignature, unsigned int semisignatureLength,
-		byte *recoveredMessage) const
-		{throw NotImplemented("PK_MessageEncodingMethod: this signature scheme does not support message recovery");}
-
-	// VC60 workaround
-	struct HashIdentifierLookup
-	{
-		template <class H> struct HashIdentifierLookup2
-		{
-			static HashIdentifier Lookup()
-			{
-				return HashIdentifier(NULL, 0);
-			}
-		};
-	};
-};
-
-class PK_DeterministicSignatureMessageEncodingMethod : public PK_SignatureMessageEncodingMethod
-{
-public:
-	bool VerifyMessageRepresentative(
-		HashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,
-		byte *representative, unsigned int representativeBitLength) const;
-};
-
-class PK_RecoverableSignatureMessageEncodingMethod : public PK_SignatureMessageEncodingMethod
-{
-public:
-	bool VerifyMessageRepresentative(
-		HashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,
-		byte *representative, unsigned int representativeBitLength) const;
-};
-
-class DL_SignatureMessageEncodingMethod_DSA : public PK_DeterministicSignatureMessageEncodingMethod
-{
-public:
-	void ComputeMessageRepresentative(RandomNumberGenerator &rng, 
-		const byte *recoverableMessage, unsigned int recoverableMessageLength,
-		HashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,
-		byte *representative, unsigned int representativeBitLength) const;
-};
-
-class DL_SignatureMessageEncodingMethod_NR : public PK_DeterministicSignatureMessageEncodingMethod
-{
-public:
-	void ComputeMessageRepresentative(RandomNumberGenerator &rng, 
-		const byte *recoverableMessage, unsigned int recoverableMessageLength,
-		HashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,
-		byte *representative, unsigned int representativeBitLength) const;
-};
-
-class PK_MessageAccumulatorBase : public PK_MessageAccumulator
-{
-public:
-	PK_MessageAccumulatorBase() : m_empty(true) {}
-
-	virtual HashTransformation & AccessHash() =0;
-
-	void Update(const byte *input, unsigned int length)
-	{
-		AccessHash().Update(input, length);
-		m_empty = m_empty && length == 0;
-	}
-
-	SecByteBlock m_recoverableMessage, m_representative, m_presignature, m_semisignature;
-	Integer m_k, m_s;
-	bool m_empty;
-};
-
-template <class HASH_ALGORITHM>
-class PK_MessageAccumulatorImpl : public PK_MessageAccumulatorBase, protected ObjectHolder<HASH_ALGORITHM>
-{
-public:
-	HashTransformation & AccessHash() {return m_object;}
-};
-
-//! .
-template <class INTERFACE, class BASE>
-class TF_SignatureSchemeBase : public INTERFACE, protected BASE
-{
-public:
-	unsigned int SignatureLength() const 
-		{return GetTrapdoorFunctionBounds().MaxPreimage().ByteCount();}
-	unsigned int MaxRecoverableLength() const 
-		{return GetMessageEncodingInterface().MaxRecoverableLength(MessageRepresentativeBitLength(), GetHashIdentifier().second, GetDigestSize());}
-	unsigned int MaxRecoverableLengthFromSignatureLength(unsigned int signatureLength) const
-		{return MaxRecoverableLength();}
-
-	bool IsProbabilistic() const 
-		{return GetTrapdoorFunctionInterface().IsRandomized() || GetMessageEncodingInterface().IsProbabilistic();}
-	bool AllowNonrecoverablePart() const 
-		{return GetMessageEncodingInterface().AllowNonrecoverablePart();}
-	bool RecoverablePartFirst() const 
-		{return GetMessageEncodingInterface().RecoverablePartFirst();}
-
-protected:
-	unsigned int MessageRepresentativeLength() const {return BitsToBytes(MessageRepresentativeBitLength());}
-	unsigned int MessageRepresentativeBitLength() const {return GetTrapdoorFunctionBounds().ImageBound().BitCount()-1;}
-	virtual HashIdentifier GetHashIdentifier() const =0;
-	virtual unsigned int GetDigestSize() const =0;
-};
-
-//! .
-class TF_SignerBase : public TF_SignatureSchemeBase<PK_Signer, TF_Base<RandomizedTrapdoorFunctionInverse, PK_SignatureMessageEncodingMethod> >
-{
-public:
-	void InputRecoverableMessage(PK_MessageAccumulator &messageAccumulator, const byte *recoverableMessage, unsigned int recoverableMessageLength) const;
-	unsigned int SignAndRestart(RandomNumberGenerator &rng, PK_MessageAccumulator &messageAccumulator, byte *signature, bool restart=true) const;
-};
-
-//! .
-class TF_VerifierBase : public TF_SignatureSchemeBase<PK_Verifier, TF_Base<TrapdoorFunction, PK_SignatureMessageEncodingMethod> >
-{
-public:
-	void InputSignature(PK_MessageAccumulator &messageAccumulator, const byte *signature, unsigned int signatureLength) const;
-	bool VerifyAndRestart(PK_MessageAccumulator &messageAccumulator) const;
-	DecodingResult RecoverAndRestart(byte *recoveredMessage, PK_MessageAccumulator &recoveryAccumulator) const;
-};
-
-// ********************************************************
-
-//! .
-template <class T1, class T2, class T3>
-struct TF_CryptoSchemeOptions
-{
-	typedef T1 AlgorithmInfo;
-	typedef T2 Keys;
-	typedef typename Keys::PrivateKey PrivateKey;
-	typedef typename Keys::PublicKey PublicKey;
-	typedef T3 MessageEncodingMethod;
-};
-
-//! .
-template <class T1, class T2, class T3, class T4>
-struct TF_SignatureSchemeOptions : public TF_CryptoSchemeOptions<T1, T2, T3>
-{
-	typedef T4 HashFunction;
-};
-
-//! .
-template <class KEYS>
-class PublicKeyCopier
-{
-public:
-	virtual void CopyKeyInto(typename KEYS::PublicKey &key) const =0;
-};
-
-//! .
-template <class KEYS>
-class PrivateKeyCopier
-{
-public:
-	virtual void CopyKeyInto(typename KEYS::PublicKey &key) const =0;
-	virtual void CopyKeyInto(typename KEYS::PrivateKey &key) const =0;
-};
-
-//! .
-template <class BASE, class SCHEME_OPTIONS, class KEY>
-class TF_ObjectImplBase : public AlgorithmImpl<BASE, typename SCHEME_OPTIONS::AlgorithmInfo>
-{
-public:
-	typedef SCHEME_OPTIONS SchemeOptions;
-	typedef KEY KeyClass;
-
-	PublicKey & AccessPublicKey() {return AccessKey();}
-	const PublicKey & GetPublicKey() const {return GetKey();}
-
-	PrivateKey & AccessPrivateKey() {return AccessKey();}
-	const PrivateKey & GetPrivateKey() const {return GetKey();}
-
-	virtual const KeyClass & GetKey() const =0;
-	virtual KeyClass & AccessKey() =0;
-
-	const KeyClass & GetTrapdoorFunction() const {return GetKey();}
-
-protected:
-	const typename BASE::MessageEncodingInterface & GetMessageEncodingInterface() const 
-		{static typename SCHEME_OPTIONS::MessageEncodingMethod messageEncodingMethod; return messageEncodingMethod;}
-	const TrapdoorFunctionBounds & GetTrapdoorFunctionBounds() const 
-		{return GetKey();}
-	const typename BASE::TrapdoorFunctionInterface & GetTrapdoorFunctionInterface() const 
-		{return GetKey();}
-
-	// for signature scheme
-	HashIdentifier GetHashIdentifier() const
-	{
-		typedef CPP_TYPENAME SchemeOptions::MessageEncodingMethod::HashIdentifierLookup::HashIdentifierLookup2<CPP_TYPENAME SchemeOptions::HashFunction> L;
-		return L::Lookup();
-	}
-	unsigned int GetDigestSize() const
-	{
-		typedef CPP_TYPENAME SchemeOptions::HashFunction H;
-		return H::DIGESTSIZE;
-	}
-};
-
-//! .
-template <class BASE, class SCHEME_OPTIONS, class KEY>
-class TF_ObjectImplExtRef : public TF_ObjectImplBase<BASE, SCHEME_OPTIONS, KEY>
-{
-public:
-	TF_ObjectImplExtRef(const KEY *pKey = NULL) : m_pKey(pKey) {}
-	void SetKeyPtr(const KEY *pKey) {m_pKey = pKey;}
-
-	const KEY & GetKey() const {return *m_pKey;}
-	KEY & AccessKey() {throw NotImplemented("TF_ObjectImplExtRef: cannot modify refererenced key");}
-
-	void CopyKeyInto(typename SCHEME_OPTIONS::PrivateKey &key) const {assert(false);}
-	void CopyKeyInto(typename SCHEME_OPTIONS::PublicKey &key) const {assert(false);}
-
-private:
-	const KEY * m_pKey;
-};
-
-//! .
-template <class BASE, class SCHEME_OPTIONS, class KEY>
-class TF_ObjectImpl : public TF_ObjectImplBase<BASE, SCHEME_OPTIONS, KEY>
-{
-public:
-	const KEY & GetKey() const {return m_trapdoorFunction;}
-	KEY & AccessKey() {return m_trapdoorFunction;}
-
-private:
-	KEY m_trapdoorFunction;
-};
-
-//! .
-template <class BASE, class SCHEME_OPTIONS>
-class TF_PublicObjectImpl : public TF_ObjectImpl<BASE, SCHEME_OPTIONS, typename SCHEME_OPTIONS::PublicKey>, public PublicKeyCopier<SCHEME_OPTIONS>
-{
-public:
-	void CopyKeyInto(typename SCHEME_OPTIONS::PublicKey &key) const {key = GetKey();}
-};
-
-//! .
-template <class BASE, class SCHEME_OPTIONS>
-class TF_PrivateObjectImpl : public TF_ObjectImpl<BASE, SCHEME_OPTIONS, typename SCHEME_OPTIONS::PrivateKey>, public PrivateKeyCopier<SCHEME_OPTIONS>
-{
-public:
-	void CopyKeyInto(typename SCHEME_OPTIONS::PrivateKey &key) const {key = GetKey();}
-	void CopyKeyInto(typename SCHEME_OPTIONS::PublicKey &key) const {key = GetKey();}
-};
-
-//! .
-template <class SCHEME_OPTIONS>
-class TF_DecryptorImpl : public TF_PrivateObjectImpl<TF_DecryptorBase, SCHEME_OPTIONS>
-{
-};
-
-//! .
-template <class SCHEME_OPTIONS>
-class TF_EncryptorImpl : public TF_PublicObjectImpl<TF_EncryptorBase, SCHEME_OPTIONS>
-{
-};
-
-//! .
-template <class SCHEME_OPTIONS>
-class TF_SignerImpl : public TF_PrivateObjectImpl<TF_SignerBase, SCHEME_OPTIONS>
-{
-	PK_MessageAccumulator * NewSignatureAccumulator(RandomNumberGenerator &rng = NullRNG()) const
-	{
-		return new PK_MessageAccumulatorImpl<CPP_TYPENAME SCHEME_OPTIONS::HashFunction>;
-	}
-};
-
-//! .
-template <class SCHEME_OPTIONS>
-class TF_VerifierImpl : public TF_PublicObjectImpl<TF_VerifierBase, SCHEME_OPTIONS>
-{
-	PK_MessageAccumulator * NewVerificationAccumulator() const
-	{
-		return new PK_MessageAccumulatorImpl<CPP_TYPENAME SCHEME_OPTIONS::HashFunction>;
-	}
-};
-
-// ********************************************************
-
-class MaskGeneratingFunction
-{
-public:
-	virtual ~MaskGeneratingFunction() {}
-	virtual void GenerateAndMask(HashTransformation &hash, byte *output, unsigned int outputLength, const byte *input, unsigned int inputLength, bool mask = true) const =0;
-};
-
-void P1363_MGF1KDF2_Common(HashTransformation &hash, byte *output, unsigned int outputLength, const byte *input, unsigned int inputLength, bool mask, unsigned int counterStart);
-
-//! .
-class P1363_MGF1 : public MaskGeneratingFunction
-{
-public:
-	static const char * StaticAlgorithmName() {return "MGF1";}
-#if 0
-	// VC60 workaround: this function causes internal compiler error
-	template <class H>
-	static void GenerateAndMaskTemplate(byte *output, unsigned int outputLength, const byte *input, unsigned int inputLength, H* dummy=NULL)
-	{
-		H h;
-		P1363_MGF1KDF2_Common(h, output, outputLength, input, inputLength, mask, 0);
-	}
-#endif
-	void GenerateAndMask(HashTransformation &hash, byte *output, unsigned int outputLength, const byte *input, unsigned int inputLength, bool mask = true) const
-	{
-		P1363_MGF1KDF2_Common(hash, output, outputLength, input, inputLength, mask, 0);
-	}
-};
-
-// ********************************************************
-
-//! .
-template <class H>
-class P1363_KDF2
-{
-public:
-	static void DeriveKey(byte *output, unsigned int outputLength, const byte *input, unsigned int inputLength)
-	{
-		H h;
-		P1363_MGF1KDF2_Common(h, output, outputLength, input, inputLength, false, 1);
-	}
-};
-
-// ********************************************************
-
-// to be thrown by DecodeElement and AgreeWithStaticPrivateKey
-class DL_BadElement : public InvalidDataFormat
-{
-public:
-	DL_BadElement() : InvalidDataFormat("CryptoPP: invalid group element") {}
-};
-
-//! .
-template <class T>
-class DL_GroupParameters : public CryptoParameters
-{
-	typedef DL_GroupParameters<T> ThisClass;
-	
-public:
-	typedef T Element;
-
-	DL_GroupParameters() : m_validationLevel(0) {}
-
-	// CryptoMaterial
-	bool Validate(RandomNumberGenerator &rng, unsigned int level) const
-	{
-		if (!GetBasePrecomputation().IsInitialized())
-			return false;
-
-		if (m_validationLevel > level)
-			return true;
-
-		bool pass = ValidateGroup(rng, level);
-		pass = pass && ValidateElement(level, GetSubgroupGenerator(), &GetBasePrecomputation());
-
-		m_validationLevel = pass ? level+1 : 0;
-
-		return pass;
-	}
-
-	bool GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const
-	{
-		return GetValueHelper(this, name, valueType, pValue)
-			CRYPTOPP_GET_FUNCTION_ENTRY(SubgroupOrder)
-			CRYPTOPP_GET_FUNCTION_ENTRY(SubgroupGenerator)
-			;
-	}
-
-	bool SupportsPrecomputation() const {return true;}
-
-	void Precompute(unsigned int precomputationStorage=16)
-	{
-		AccessBasePrecomputation().Precompute(GetGroupPrecomputation(), GetSubgroupOrder().BitCount(), precomputationStorage);
-	}
-
-	void LoadPrecomputation(BufferedTransformation &storedPrecomputation)
-	{
-		AccessBasePrecomputation().Load(GetGroupPrecomputation(), storedPrecomputation);
-		m_validationLevel = 0;
-	}
-
-	void SavePrecomputation(BufferedTransformation &storedPrecomputation) const
-	{
-		GetBasePrecomputation().Save(GetGroupPrecomputation(), storedPrecomputation);
-	}
-
-	// non-inherited
-	virtual const Element & GetSubgroupGenerator() const {return GetBasePrecomputation().GetBase(GetGroupPrecomputation());}
-	virtual void SetSubgroupGenerator(const Element &base) {AccessBasePrecomputation().SetBase(GetGroupPrecomputation(), base);}
-	virtual Element ExponentiateBase(const Integer &exponent) const
-	{
-		return GetBasePrecomputation().Exponentiate(GetGroupPrecomputation(), exponent);
-	}
-	virtual Element ExponentiateElement(const Element &base, const Integer &exponent) const
-	{
-		Element result;
-		SimultaneousExponentiate(&result, base, &exponent, 1);
-		return result;
-	}
-
-	virtual const DL_GroupPrecomputation<Element> & GetGroupPrecomputation() const =0;
-	virtual const DL_FixedBasePrecomputation<Element> & GetBasePrecomputation() const =0;
-	virtual DL_FixedBasePrecomputation<Element> & AccessBasePrecomputation() =0;
-	virtual const Integer & GetSubgroupOrder() const =0;	// order of subgroup generated by base element
-	virtual Integer GetMaxExponent() const =0;
-	virtual Integer GetGroupOrder() const {return GetSubgroupOrder()*GetCofactor();}	// one of these two needs to be overriden
-	virtual Integer GetCofactor() const {return GetGroupOrder()/GetSubgroupOrder();}
-	virtual unsigned int GetEncodedElementSize(bool reversible) const =0;
-	virtual void EncodeElement(bool reversible, const Element &element, byte *encoded) const =0;
-	virtual Element DecodeElement(const byte *encoded, bool checkForGroupMembership) const =0;
-	virtual Integer ConvertElementToInteger(const Element &element) const =0;
-	virtual bool ValidateGroup(RandomNumberGenerator &rng, unsigned int level) const =0;
-	virtual bool ValidateElement(unsigned int level, const Element &element, const DL_FixedBasePrecomputation<Element> *precomp) const =0;
-	virtual bool FastSubgroupCheckAvailable() const =0;
-	virtual bool IsIdentity(const Element &element) const =0;
-	virtual void SimultaneousExponentiate(Element *results, const Element &base, const Integer *exponents, unsigned int exponentsCount) const =0;
-
-protected:
-	void ParametersChanged() {m_validationLevel = 0;}
-
-private:
-	mutable unsigned int m_validationLevel;
-};
-
-//! .
-template <class GROUP_PRECOMP, class BASE_PRECOMP = DL_FixedBasePrecomputationImpl<typename GROUP_PRECOMP::Element>, class BASE = DL_GroupParameters<typename GROUP_PRECOMP::Element> >
-class DL_GroupParametersImpl : public BASE
-{
-public:
-	typedef GROUP_PRECOMP GroupPrecomputation;
-	typedef typename GROUP_PRECOMP::Element Element;
-	typedef BASE_PRECOMP BasePrecomputation;
-	
-	const DL_GroupPrecomputation<Element> & GetGroupPrecomputation() const {return m_groupPrecomputation;}
-	const DL_FixedBasePrecomputation<Element> & GetBasePrecomputation() const {return m_gpc;}
-	DL_FixedBasePrecomputation<Element> & AccessBasePrecomputation() {return m_gpc;}
-
-protected:
-	GROUP_PRECOMP m_groupPrecomputation;
-	BASE_PRECOMP m_gpc;
-};
-
-//! .
-template <class T>
-class DL_Key
-{
-public:
-	virtual const DL_GroupParameters<T> & GetAbstractGroupParameters() const =0;
-	virtual DL_GroupParameters<T> & AccessAbstractGroupParameters() =0;
-};
-
-//! .
-template <class T>
-class DL_PublicKey : public DL_Key<T>
-{
-	typedef DL_PublicKey<T> ThisClass;
-
-public:
-	typedef T Element;
-
-	bool GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const
-	{
-		return GetValueHelper(this, name, valueType, pValue, &GetAbstractGroupParameters())
-				CRYPTOPP_GET_FUNCTION_ENTRY(PublicElement);
-	}
-
-	void AssignFrom(const NameValuePairs &source);
-	
-	// non-inherited
-	virtual const Element & GetPublicElement() const {return GetPublicPrecomputation().GetBase(GetAbstractGroupParameters().GetGroupPrecomputation());}
-	virtual void SetPublicElement(const Element &y) {AccessPublicPrecomputation().SetBase(GetAbstractGroupParameters().GetGroupPrecomputation(), y);}
-	virtual Element ExponentiatePublicElement(const Integer &exponent) const
-	{
-		const DL_GroupParameters<T> &params = GetAbstractGroupParameters();
-		return GetPublicPrecomputation().Exponentiate(params.GetGroupPrecomputation(), exponent);
-	}
-	virtual Element CascadeExponentiateBaseAndPublicElement(const Integer &baseExp, const Integer &publicExp) const
-	{
-		const DL_GroupParameters<T> &params = GetAbstractGroupParameters();
-		return params.GetBasePrecomputation().CascadeExponentiate(params.GetGroupPrecomputation(), baseExp, GetPublicPrecomputation(), publicExp);
-	}
-
-	virtual const DL_FixedBasePrecomputation<T> & GetPublicPrecomputation() const =0;
-	virtual DL_FixedBasePrecomputation<T> & AccessPublicPrecomputation() =0;
-};
-
-//! .
-template <class T>
-class DL_PrivateKey : public DL_Key<T>
-{
-	typedef DL_PrivateKey<T> ThisClass;
-
-public:
-	typedef T Element;
-
-	void MakePublicKey(DL_PublicKey<T> &pub) const
-	{
-		pub.AccessAbstractGroupParameters().AssignFrom(GetAbstractGroupParameters());
-		pub.SetPublicElement(GetAbstractGroupParameters().ExponentiateBase(GetPrivateExponent()));
-	}
-
-	bool GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const
-	{
-		return GetValueHelper(this, name, valueType, pValue, &GetAbstractGroupParameters())
-				CRYPTOPP_GET_FUNCTION_ENTRY(PrivateExponent);
-	}
-
-	void AssignFrom(const NameValuePairs &source)
-	{
-		AccessAbstractGroupParameters().AssignFrom(source);
-		AssignFromHelper(this, source)
-			CRYPTOPP_SET_FUNCTION_ENTRY(PrivateExponent);
-	}
-
-	virtual const Integer & GetPrivateExponent() const =0;
-	virtual void SetPrivateExponent(const Integer &x) =0;
-};
-
-template <class T>
-void DL_PublicKey<T>::AssignFrom(const NameValuePairs &source)
-{
-	DL_PrivateKey<T> *pPrivateKey = NULL;
-	if (source.GetThisPointer(pPrivateKey))
-		pPrivateKey->MakePublicKey(*this);
-	else
-	{
-		AccessAbstractGroupParameters().AssignFrom(source);
-		AssignFromHelper(this, source)
-			CRYPTOPP_SET_FUNCTION_ENTRY(PublicElement);
-	}
-}
-
-class OID;
-
-//! .
-template <class PK, class GP>
-class DL_KeyImpl : public PK
-{
-public:
-	typedef GP GroupParameters;
-
-	OID GetAlgorithmID() const {return GetGroupParameters().GetAlgorithmID();}
-//	void BERDecode(BufferedTransformation &bt)
-//		{PK::BERDecode(bt);}
-//	void DEREncode(BufferedTransformation &bt) const
-//		{PK::DEREncode(bt);}
-	bool BERDecodeAlgorithmParameters(BufferedTransformation &bt)
-		{AccessGroupParameters().BERDecode(bt); return true;}
-	bool DEREncodeAlgorithmParameters(BufferedTransformation &bt) const
-		{GetGroupParameters().DEREncode(bt); return true;}
-
-	const GP & GetGroupParameters() const {return m_groupParameters;}
-	GP & AccessGroupParameters() {return m_groupParameters;}
-
-private:
-	GP m_groupParameters;
-};
-
-class X509PublicKey;
-class PKCS8PrivateKey;
-
-//! .
-template <class GP>
-class DL_PrivateKeyImpl : public DL_PrivateKey<CPP_TYPENAME GP::Element>, public DL_KeyImpl<PKCS8PrivateKey, GP>
-{
-public:
-	typedef typename GP::Element Element;
-
-	// GeneratableCryptoMaterial
-	bool Validate(RandomNumberGenerator &rng, unsigned int level) const
-	{
-		bool pass = GetAbstractGroupParameters().Validate(rng, level);
-
-		const Integer &q = GetAbstractGroupParameters().GetSubgroupOrder();
-		const Integer &x = GetPrivateExponent();
-
-		pass = pass && x.IsPositive() && x < q;
-		if (level >= 1)
-			pass = pass && Integer::Gcd(x, q) == Integer::One();
-		return pass;
-	}
-
-	bool GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const
-	{
-		return GetValueHelper<DL_PrivateKey<Element> >(this, name, valueType, pValue).Assignable();
-	}
-
-	void AssignFrom(const NameValuePairs &source)
-	{
-		AssignFromHelper<DL_PrivateKey<Element> >(this, source);
-	}
-
-	void GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &params)
-	{
-		if (!params.GetThisObject(AccessGroupParameters()))
-			AccessGroupParameters().GenerateRandom(rng, params);
-//		std::pair<const byte *, int> seed;
-		Integer x(rng, Integer::One(), GetAbstractGroupParameters().GetMaxExponent());
-//			Integer::ANY, Integer::Zero(), Integer::One(),
-//			params.GetValue("DeterministicKeyGenerationSeed", seed) ? &seed : NULL);
-		SetPrivateExponent(x);
-	}
-
-	bool SupportsPrecomputation() const {return true;}
-
-	void Precompute(unsigned int precomputationStorage=16)
-		{AccessAbstractGroupParameters().Precompute(precomputationStorage);}
-
-	void LoadPrecomputation(BufferedTransformation &storedPrecomputation)
-		{AccessAbstractGroupParameters().LoadPrecomputation(storedPrecomputation);}
-
-	void SavePrecomputation(BufferedTransformation &storedPrecomputation) const
-		{GetAbstractGroupParameters().SavePrecomputation(storedPrecomputation);}
-
-	// DL_Key
-	const DL_GroupParameters<Element> & GetAbstractGroupParameters() const {return GetGroupParameters();}
-	DL_GroupParameters<Element> & AccessAbstractGroupParameters() {return AccessGroupParameters();}
-
-	// DL_PrivateKey
-	const Integer & GetPrivateExponent() const {return m_x;}
-	void SetPrivateExponent(const Integer &x) {m_x = x;}
-
-	// PKCS8PrivateKey
-	void BERDecodeKey(BufferedTransformation &bt)
-		{m_x.BERDecode(bt);}
-	void DEREncodeKey(BufferedTransformation &bt) const
-		{m_x.DEREncode(bt);}
-
-private:
-	Integer m_x;
-};
-
-//! .
-template <class BASE, class SIGNATURE_SCHEME>
-class DL_PrivateKey_WithSignaturePairwiseConsistencyTest : public BASE
-{
-public:
-	void GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &params)
-	{
-		BASE::GenerateRandom(rng, params);
-
-		if (FIPS_140_2_ComplianceEnabled())
-		{
-			typename SIGNATURE_SCHEME::Signer signer(*this);
-			typename SIGNATURE_SCHEME::Verifier verifier(signer);
-			SignaturePairwiseConsistencyTest_FIPS_140_Only(signer, verifier);
-		}
-	}
-};
-
-//! .
-template <class GP>
-class DL_PublicKeyImpl : public DL_PublicKey<typename GP::Element>, public DL_KeyImpl<X509PublicKey, GP>
-{
-public:
-	typedef typename GP::Element Element;
-
-	// CryptoMaterial
-	bool Validate(RandomNumberGenerator &rng, unsigned int level) const
-	{
-		bool pass = GetAbstractGroupParameters().Validate(rng, level);
-		pass = pass && GetAbstractGroupParameters().ValidateElement(level, GetPublicElement(), &GetPublicPrecomputation());
-		return pass;
-	}
-
-	bool GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const
-	{
-		return GetValueHelper<DL_PublicKey<Element> >(this, name, valueType, pValue).Assignable();
-	}
-
-	void AssignFrom(const NameValuePairs &source)
-	{
-		AssignFromHelper<DL_PublicKey<Element> >(this, source);
-	}
-
-	bool SupportsPrecomputation() const {return true;}
-
-	void Precompute(unsigned int precomputationStorage=16)
-	{
-		AccessAbstractGroupParameters().Precompute(precomputationStorage);
-		AccessPublicPrecomputation().Precompute(GetAbstractGroupParameters().GetGroupPrecomputation(), GetAbstractGroupParameters().GetSubgroupOrder().BitCount(), precomputationStorage);
-	}
-
-	void LoadPrecomputation(BufferedTransformation &storedPrecomputation)
-	{
-		AccessAbstractGroupParameters().LoadPrecomputation(storedPrecomputation);
-		AccessPublicPrecomputation().Load(GetAbstractGroupParameters().GetGroupPrecomputation(), storedPrecomputation);
-	}
-
-	void SavePrecomputation(BufferedTransformation &storedPrecomputation) const
-	{
-		GetAbstractGroupParameters().SavePrecomputation(storedPrecomputation);
-		GetPublicPrecomputation().Save(GetAbstractGroupParameters().GetGroupPrecomputation(), storedPrecomputation);
-	}
-
-	// DL_Key
-	const DL_GroupParameters<Element> & GetAbstractGroupParameters() const {return GetGroupParameters();}
-	DL_GroupParameters<Element> & AccessAbstractGroupParameters() {return AccessGroupParameters();}
-
-	// DL_PublicKey
-	const DL_FixedBasePrecomputation<Element> & GetPublicPrecomputation() const {return m_ypc;}
-	DL_FixedBasePrecomputation<Element> & AccessPublicPrecomputation() {return m_ypc;}
-
-	// non-inherited
-	bool operator==(const DL_PublicKeyImpl<GP> &rhs) const
-		{return GetGroupParameters() == rhs.GetGroupParameters() && GetPublicElement() == rhs.GetPublicElement();}
-
-private:
-	typename GP::BasePrecomputation m_ypc;
-};
-
-//! .
-template <class T>
-class DL_ElgamalLikeSignatureAlgorithm
-{
-public:
-//	virtual Integer EncodeDigest(unsigned int modulusBits, const byte *digest, unsigned int digestLength) const =0;
-	virtual void Sign(const DL_GroupParameters<T> &params, const Integer &privateKey, const Integer &k, const Integer &e, Integer &r, Integer &s) const =0;
-	virtual bool Verify(const DL_GroupParameters<T> &params, const DL_PublicKey<T> &publicKey, const Integer &e, const Integer &r, const Integer &s) const =0;
-	virtual Integer RecoverPresignature(const DL_GroupParameters<T> &params, const DL_PublicKey<T> &publicKey, const Integer &r, const Integer &s) const
-		{throw NotImplemented("DL_ElgamalLikeSignatureAlgorithm: this signature scheme does not support message recovery");}
-	virtual unsigned int RLen(const DL_GroupParameters<T> &params) const
-		{return params.GetSubgroupOrder().ByteCount();}
-	virtual unsigned int SLen(const DL_GroupParameters<T> &params) const
-		{return params.GetSubgroupOrder().ByteCount();}
-};
-
-//! .
-template <class T>
-class DL_KeyAgreementAlgorithm
-{
-public:
-	typedef T Element;
-
-	virtual Element AgreeWithEphemeralPrivateKey(const DL_GroupParameters<Element> &params, const DL_FixedBasePrecomputation<Element> &publicPrecomputation, const Integer &privateExponent) const =0;
-	virtual Element AgreeWithStaticPrivateKey(const DL_GroupParameters<Element> &params, const Element &publicElement, bool validateOtherPublicKey, const Integer &privateExponent) const =0;
-};
-
-//! .
-template <class T>
-class DL_KeyDerivationAlgorithm
-{
-public:
-	virtual void Derive(const DL_GroupParameters<T> &params, byte *derivedKey, unsigned int derivedLength, const T &agreedElement, const T &ephemeralPublicKey) const =0;
-};
-
-//! .
-class DL_SymmetricEncryptionAlgorithm
-{
-public:
-	virtual unsigned int GetSymmetricKeyLength(unsigned int plainTextLength) const =0;
-	virtual unsigned int GetSymmetricCiphertextLength(unsigned int plainTextLength) const =0;
-	virtual unsigned int GetMaxSymmetricPlaintextLength(unsigned int cipherTextLength) const =0;
-	virtual void SymmetricEncrypt(RandomNumberGenerator &rng, const byte *key, const byte *plainText, unsigned int plainTextLength, byte *cipherText) const =0;
-	virtual DecodingResult SymmetricDecrypt(const byte *key, const byte *cipherText, unsigned int cipherTextLength, byte *plainText) const =0;
-};
-
-//! .
-template <class KI>
-class DL_Base
-{
-protected:
-	typedef KI KeyInterface;
-	typedef typename KI::Element Element;
-
-	const DL_GroupParameters<Element> & GetAbstractGroupParameters() const {return GetKeyInterface().GetAbstractGroupParameters();}
-	DL_GroupParameters<Element> & AccessAbstractGroupParameters() {return AccessKeyInterface().AccessAbstractGroupParameters();}
-
-	virtual KeyInterface & AccessKeyInterface() =0;
-	virtual const KeyInterface & GetKeyInterface() const =0;
-};
-
-//! .
-template <class INTERFACE, class KEY_INTERFACE>
-class DL_SignatureSchemeBase : public INTERFACE, public DL_Base<KEY_INTERFACE>
-{
-public:
-	unsigned int SignatureLength() const
-	{
-		return GetSignatureAlgorithm().RLen(GetAbstractGroupParameters())
-			+ GetSignatureAlgorithm().SLen(GetAbstractGroupParameters());
-	}
-	unsigned int MaxRecoverableLength() const 
-		{return GetMessageEncodingInterface().MaxRecoverableLength(0, GetHashIdentifier().second, GetDigestSize());}
-	unsigned int MaxRecoverableLengthFromSignatureLength(unsigned int signatureLength) const
-		{assert(false); return 0;}	// TODO
-
-	bool IsProbabilistic() const 
-		{return true;}
-	bool AllowNonrecoverablePart() const 
-		{return GetMessageEncodingInterface().AllowNonrecoverablePart();}
-	bool RecoverablePartFirst() const 
-		{return GetMessageEncodingInterface().RecoverablePartFirst();}
-
-protected:
-	unsigned int MessageRepresentativeLength() const {return BitsToBytes(MessageRepresentativeBitLength());}
-	unsigned int MessageRepresentativeBitLength() const {return GetAbstractGroupParameters().GetSubgroupOrder().BitCount();}
-
-	virtual const DL_ElgamalLikeSignatureAlgorithm<CPP_TYPENAME KEY_INTERFACE::Element> & GetSignatureAlgorithm() const =0;
-	virtual const PK_SignatureMessageEncodingMethod & GetMessageEncodingInterface() const =0;
-	virtual HashIdentifier GetHashIdentifier() const =0;
-	virtual unsigned int GetDigestSize() const =0;
-};
-
-//! .
-template <class T>
-class DL_SignerBase : public DL_SignatureSchemeBase<PK_Signer, DL_PrivateKey<T> >
-{
-public:
-	// for validation testing
-	void RawSign(const Integer &k, const Integer &e, Integer &r, Integer &s) const
-	{
-		const DL_ElgamalLikeSignatureAlgorithm<T> &alg = GetSignatureAlgorithm();
-		const DL_GroupParameters<T> &params = GetAbstractGroupParameters();
-		const DL_PrivateKey<T> &key = GetKeyInterface();
-
-		r = params.ConvertElementToInteger(params.ExponentiateBase(k));
-		alg.Sign(params, key.GetPrivateExponent(), k, e, r, s);
-	}
-
-	void InputRecoverableMessage(PK_MessageAccumulator &messageAccumulator, const byte *recoverableMessage, unsigned int recoverableMessageLength) const
-	{
-		PK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);
-		ma.m_recoverableMessage.Assign(recoverableMessage, recoverableMessageLength);
-		GetMessageEncodingInterface().ProcessRecoverableMessage(ma.AccessHash(), 
-			recoverableMessage, recoverableMessageLength, 
-			ma.m_presignature, ma.m_presignature.size(),
-			ma.m_semisignature);
-	}
-
-	unsigned int SignAndRestart(RandomNumberGenerator &rng, PK_MessageAccumulator &messageAccumulator, byte *signature, bool restart) const
-	{
-		GetMaterial().DoQuickSanityCheck();
-
-		PK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);
-		const DL_ElgamalLikeSignatureAlgorithm<T> &alg = GetSignatureAlgorithm();
-		const DL_GroupParameters<T> &params = GetAbstractGroupParameters();
-		const DL_PrivateKey<T> &key = GetKeyInterface();
-
-		SecByteBlock representative(MessageRepresentativeLength());
-		GetMessageEncodingInterface().ComputeMessageRepresentative(
-			rng, 
-			ma.m_recoverableMessage, ma.m_recoverableMessage.size(), 
-			ma.AccessHash(), GetHashIdentifier(), ma.m_empty, 
-			representative, MessageRepresentativeBitLength());
-		ma.m_empty = true;
-		Integer e(representative, representative.size());
-
-		Integer r;
-		if (MaxRecoverableLength() > 0)
-			r.Decode(ma.m_semisignature, ma.m_semisignature.size());
-		else
-			r.Decode(ma.m_presignature, ma.m_presignature.size());
-		Integer s;
-		alg.Sign(params, key.GetPrivateExponent(), ma.m_k, e, r, s);
-
-		unsigned int rLen = alg.RLen(params);
-		r.Encode(signature, rLen);
-		s.Encode(signature+rLen, alg.SLen(params));
-
-		if (restart)
-			RestartMessageAccumulator(rng, ma);
-
-		return SignatureLength();
-	}
-
-protected:
-	void RestartMessageAccumulator(RandomNumberGenerator &rng, PK_MessageAccumulatorBase &ma) const
-	{
-		const DL_ElgamalLikeSignatureAlgorithm<T> &alg = GetSignatureAlgorithm();
-		const DL_GroupParameters<T> &params = GetAbstractGroupParameters();
-		ma.m_k.Randomize(rng, 1, params.GetSubgroupOrder()-1);
-		ma.m_presignature.New(params.GetEncodedElementSize(false));
-		params.ConvertElementToInteger(params.ExponentiateBase(ma.m_k)).Encode(ma.m_presignature, ma.m_presignature.size());
-	}
-};
-
-//! .
-template <class T>
-class DL_VerifierBase : public DL_SignatureSchemeBase<PK_Verifier, DL_PublicKey<T> >
-{
-public:
-	void InputSignature(PK_MessageAccumulator &messageAccumulator, const byte *signature, unsigned int signatureLength) const
-	{
-		PK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);
-		const DL_ElgamalLikeSignatureAlgorithm<T> &alg = GetSignatureAlgorithm();
-		const DL_GroupParameters<T> &params = GetAbstractGroupParameters();
-
-		unsigned int rLen = alg.RLen(params);
-		ma.m_semisignature.Assign(signature, rLen);
-		ma.m_s.Decode(signature+rLen, alg.SLen(params));
-
-		GetMessageEncodingInterface().ProcessSemisignature(ma.AccessHash(), ma.m_semisignature, ma.m_semisignature.size());
-	}
-	
-	bool VerifyAndRestart(PK_MessageAccumulator &messageAccumulator) const
-	{
-		GetMaterial().DoQuickSanityCheck();
-
-		PK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);
-		const DL_ElgamalLikeSignatureAlgorithm<T> &alg = GetSignatureAlgorithm();
-		const DL_GroupParameters<T> &params = GetAbstractGroupParameters();
-		const DL_PublicKey<T> &key = GetKeyInterface();
-
-		SecByteBlock representative(MessageRepresentativeLength());
-		GetMessageEncodingInterface().ComputeMessageRepresentative(NullRNG(), ma.m_recoverableMessage, ma.m_recoverableMessage.size(), 
-			ma.AccessHash(), GetHashIdentifier(), ma.m_empty,
-			representative, MessageRepresentativeBitLength());
-		ma.m_empty = true;
-		Integer e(representative, representative.size());
-
-		Integer r(ma.m_semisignature, ma.m_semisignature.size());
-		return alg.Verify(params, key, e, r, ma.m_s);
-	}
-
-	DecodingResult RecoverAndRestart(byte *recoveredMessage, PK_MessageAccumulator &messageAccumulator) const
-	{
-		GetMaterial().DoQuickSanityCheck();
-
-		PK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);
-		const DL_ElgamalLikeSignatureAlgorithm<T> &alg = GetSignatureAlgorithm();
-		const DL_GroupParameters<T> &params = GetAbstractGroupParameters();
-		const DL_PublicKey<T> &key = GetKeyInterface();
-
-		SecByteBlock representative(MessageRepresentativeLength());
-		GetMessageEncodingInterface().ComputeMessageRepresentative(
-			NullRNG(), 
-			ma.m_recoverableMessage, ma.m_recoverableMessage.size(), 
-			ma.AccessHash(), GetHashIdentifier(), ma.m_empty,
-			representative, MessageRepresentativeBitLength());
-		ma.m_empty = true;
-		Integer e(representative, representative.size());
-
-		ma.m_presignature.New(params.GetEncodedElementSize(false));
-		Integer r(ma.m_semisignature, ma.m_semisignature.size());
-		alg.RecoverPresignature(params, key, r, ma.m_s).Encode(ma.m_presignature, ma.m_presignature.size());
-
-		return GetMessageEncodingInterface().RecoverMessageFromSemisignature(
-			ma.AccessHash(), GetHashIdentifier(),
-			ma.m_presignature, ma.m_presignature.size(),
-			ma.m_semisignature, ma.m_semisignature.size(),
-			recoveredMessage);
-	}
-};
-
-//! .
-template <class PK, class KI>
-class DL_CryptoSystemBase : public PK, public DL_Base<KI>
-{
-public:
-	typedef typename DL_Base<KI>::Element Element;
-
-	unsigned int MaxPlaintextLength(unsigned int cipherTextLength) const
-	{
-		unsigned int minLen = GetAbstractGroupParameters().GetEncodedElementSize(true);
-		return cipherTextLength < minLen ? 0 : GetSymmetricEncryptionAlgorithm().GetMaxSymmetricPlaintextLength(cipherTextLength - minLen);
-	}
-
-	unsigned int CiphertextLength(unsigned int plainTextLength) const
-	{
-		unsigned int len = GetSymmetricEncryptionAlgorithm().GetSymmetricCiphertextLength(plainTextLength);
-		return len == 0 ? 0 : GetAbstractGroupParameters().GetEncodedElementSize(true) + len;
-	}
-
-protected:
-	virtual const DL_KeyAgreementAlgorithm<Element> & GetKeyAgreementAlgorithm() const =0;
-	virtual const DL_KeyDerivationAlgorithm<Element> & GetKeyDerivationAlgorithm() const =0;
-	virtual const DL_SymmetricEncryptionAlgorithm & GetSymmetricEncryptionAlgorithm() const =0;
-};
-
-//! .
-template <class T, class PK = PK_Decryptor>
-class DL_DecryptorBase : public DL_CryptoSystemBase<PK, DL_PrivateKey<T> >
-{
-public:
-	typedef T Element;
-
-	DecodingResult Decrypt(RandomNumberGenerator &rng, const byte *cipherText, unsigned int cipherTextLength, byte *plainText) const
-	{
-		try
-		{
-			const DL_KeyAgreementAlgorithm<T> &agreeAlg = GetKeyAgreementAlgorithm();
-			const DL_KeyDerivationAlgorithm<T> &derivAlg = GetKeyDerivationAlgorithm();
-			const DL_SymmetricEncryptionAlgorithm &encAlg = GetSymmetricEncryptionAlgorithm();
-			const DL_GroupParameters<T> &params = GetAbstractGroupParameters();
-			const DL_PrivateKey<T> &key = GetKeyInterface();
-
-			Element q = params.DecodeElement(cipherText, true);
-			unsigned int elementSize = params.GetEncodedElementSize(true);
-			cipherText += elementSize;
-			cipherTextLength -= elementSize;
-
-			Element z = agreeAlg.AgreeWithStaticPrivateKey(params, q, true, key.GetPrivateExponent());
-
-			SecByteBlock derivedKey(encAlg.GetSymmetricKeyLength(encAlg.GetMaxSymmetricPlaintextLength(cipherTextLength)));
-			derivAlg.Derive(params, derivedKey, derivedKey.size(), z, q);
-
-			return encAlg.SymmetricDecrypt(derivedKey, cipherText, cipherTextLength, plainText);
-		}
-		catch (DL_BadElement &)
-		{
-			return DecodingResult();
-		}
-	}
-};
-
-//! .
-template <class T, class PK = PK_Encryptor>
-class DL_EncryptorBase : public DL_CryptoSystemBase<PK, DL_PublicKey<T> >
-{
-public:
-	typedef T Element;
-
-	void Encrypt(RandomNumberGenerator &rng, const byte *plainText, unsigned int plainTextLength, byte *cipherText) const
-	{
-		const DL_KeyAgreementAlgorithm<T> &agreeAlg = GetKeyAgreementAlgorithm();
-		const DL_KeyDerivationAlgorithm<T> &derivAlg = GetKeyDerivationAlgorithm();
-		const DL_SymmetricEncryptionAlgorithm &encAlg = GetSymmetricEncryptionAlgorithm();
-		const DL_GroupParameters<T> &params = GetAbstractGroupParameters();
-		const DL_PublicKey<T> &key = GetKeyInterface();
-
-		Integer x(rng, Integer::One(), params.GetMaxExponent());
-		Element q = params.ExponentiateBase(x);
-		params.EncodeElement(true, q, cipherText);
-		unsigned int elementSize = params.GetEncodedElementSize(true);
-		cipherText += elementSize;
-
-		Element z = agreeAlg.AgreeWithEphemeralPrivateKey(params, key.GetPublicPrecomputation(), x);
-
-		SecByteBlock derivedKey(encAlg.GetSymmetricKeyLength(plainTextLength));
-		derivAlg.Derive(params, derivedKey, derivedKey.size(), z, q);
-
-		encAlg.SymmetricEncrypt(rng, derivedKey, plainText, plainTextLength, cipherText);
-	}
-};
-
-//! .
-template <class T1, class T2>
-struct DL_SchemeOptionsBase
-{
-	typedef T1 AlgorithmInfo;
-	typedef T2 GroupParameters;
-	typedef typename GroupParameters::Element Element;
-};
-
-//! .
-template <class T1, class T2>
-struct DL_KeyedSchemeOptions : public DL_SchemeOptionsBase<T1, typename T2::PublicKey::GroupParameters>
-{
-	typedef T2 Keys;
-	typedef typename Keys::PrivateKey PrivateKey;
-	typedef typename Keys::PublicKey PublicKey;
-};
-
-//! .
-template <class T1, class T2, class T3, class T4, class T5>
-struct DL_SignatureSchemeOptions : public DL_KeyedSchemeOptions<T1, T2>
-{
-	typedef T3 SignatureAlgorithm;
-	typedef T4 MessageEncodingMethod;
-	typedef T5 HashFunction;
-};
-
-//! .
-template <class T1, class T2, class T3, class T4, class T5>
-struct DL_CryptoSchemeOptions : public DL_KeyedSchemeOptions<T1, T2>
-{
-	typedef T3 KeyAgreementAlgorithm;
-	typedef T4 KeyDerivationAlgorithm;
-	typedef T5 SymmetricEncryptionAlgorithm;
-};
-
-//! .
-template <class BASE, class SCHEME_OPTIONS, class KEY>
-class DL_ObjectImplBase : public AlgorithmImpl<BASE, typename SCHEME_OPTIONS::AlgorithmInfo>
-{
-public:
-	typedef SCHEME_OPTIONS SchemeOptions;
-	typedef KEY KeyClass;
-	typedef typename KeyClass::Element Element;
-
-	PrivateKey & AccessPrivateKey() {return m_key;}
-	PublicKey & AccessPublicKey() {return m_key;}
-
-	// KeyAccessor
-	const KeyClass & GetKey() const {return m_key;}
-	KeyClass & AccessKey() {return m_key;}
-
-protected:
-	typename BASE::KeyInterface & AccessKeyInterface() {return m_key;}
-	const typename BASE::KeyInterface & GetKeyInterface() const {return m_key;}
-
-	// for signature scheme
-	HashIdentifier GetHashIdentifier() const
-	{
-		typedef CPP_TYPENAME SchemeOptions::MessageEncodingMethod::HashIdentifierLookup::HashIdentifierLookup2<CPP_TYPENAME SchemeOptions::HashFunction> L;
-		return L::Lookup();
-	}
-	unsigned int GetDigestSize() const
-	{
-		typedef CPP_TYPENAME SchemeOptions::HashFunction H;
-		return H::DIGESTSIZE;
-	}
-
-private:
-	KeyClass m_key;
-};
-
-//! .
-template <class BASE, class SCHEME_OPTIONS, class KEY>
-class DL_ObjectImpl : public DL_ObjectImplBase<BASE, SCHEME_OPTIONS, KEY>
-{
-public:
-	typedef typename KEY::Element Element;
-
-protected:
-	const DL_ElgamalLikeSignatureAlgorithm<Element> & GetSignatureAlgorithm() const
-		{static typename SCHEME_OPTIONS::SignatureAlgorithm a; return a;}
-	const DL_KeyAgreementAlgorithm<Element> & GetKeyAgreementAlgorithm() const
-		{static typename SCHEME_OPTIONS::KeyAgreementAlgorithm a; return a;}
-	const DL_KeyDerivationAlgorithm<Element> & GetKeyDerivationAlgorithm() const
-		{static typename SCHEME_OPTIONS::KeyDerivationAlgorithm a; return a;}
-	const DL_SymmetricEncryptionAlgorithm & GetSymmetricEncryptionAlgorithm() const
-		{static typename SCHEME_OPTIONS::SymmetricEncryptionAlgorithm a; return a;}
-	HashIdentifier GetHashIdentifier() const
-		{return HashIdentifier();}
-	const PK_SignatureMessageEncodingMethod & GetMessageEncodingInterface() const 
-		{static typename SCHEME_OPTIONS::MessageEncodingMethod a; return a;}
-};
-
-//! .
-template <class BASE, class SCHEME_OPTIONS>
-class DL_PublicObjectImpl : public DL_ObjectImpl<BASE, SCHEME_OPTIONS, typename SCHEME_OPTIONS::PublicKey>, public PublicKeyCopier<SCHEME_OPTIONS>
-{
-public:
-	void CopyKeyInto(typename SCHEME_OPTIONS::PublicKey &key) const
-		{key = GetKey();}
-};
-
-//! .
-template <class BASE, class SCHEME_OPTIONS>
-class DL_PrivateObjectImpl : public DL_ObjectImpl<BASE, SCHEME_OPTIONS, typename SCHEME_OPTIONS::PrivateKey>, public PrivateKeyCopier<SCHEME_OPTIONS>
-{
-public:
-	void CopyKeyInto(typename SCHEME_OPTIONS::PublicKey &key) const
-		{GetKey().MakePublicKey(key);}
-	void CopyKeyInto(typename SCHEME_OPTIONS::PrivateKey &key) const
-		{key = GetKey();}
-};
-
-//! .
-template <class SCHEME_OPTIONS>
-class DL_SignerImpl : public DL_PrivateObjectImpl<DL_SignerBase<typename SCHEME_OPTIONS::Element>, SCHEME_OPTIONS>
-{
-	PK_MessageAccumulator * NewSignatureAccumulator(RandomNumberGenerator &rng = NullRNG()) const
-	{
-		std::auto_ptr<PK_MessageAccumulatorBase> p(new PK_MessageAccumulatorImpl<CPP_TYPENAME SCHEME_OPTIONS::HashFunction>);
-		RestartMessageAccumulator(rng, *p);
-		return p.release();
-	}
-};
-
-//! .
-template <class SCHEME_OPTIONS>
-class DL_VerifierImpl : public DL_PublicObjectImpl<DL_VerifierBase<typename SCHEME_OPTIONS::Element>, SCHEME_OPTIONS>
-{
-	PK_MessageAccumulator * NewVerificationAccumulator() const
-	{
-		return new PK_MessageAccumulatorImpl<CPP_TYPENAME SCHEME_OPTIONS::HashFunction>;
-	}
-};
-
-//! .
-template <class SCHEME_OPTIONS>
-class DL_EncryptorImpl : public DL_PublicObjectImpl<DL_EncryptorBase<typename SCHEME_OPTIONS::Element>, SCHEME_OPTIONS>
-{
-};
-
-//! .
-template <class SCHEME_OPTIONS>
-class DL_DecryptorImpl : public DL_PrivateObjectImpl<DL_DecryptorBase<typename SCHEME_OPTIONS::Element>, SCHEME_OPTIONS>
-{
-};
-
-// ********************************************************
-
-//! .
-template <class T>
-class DL_SimpleKeyAgreementDomainBase : public SimpleKeyAgreementDomain
-{
-public:
-	typedef T Element;
-
-	CryptoParameters & AccessCryptoParameters() {return AccessAbstractGroupParameters();}
-	unsigned int AgreedValueLength() const {return GetAbstractGroupParameters().GetEncodedElementSize(false);}
-	unsigned int PrivateKeyLength() const {return GetAbstractGroupParameters().GetSubgroupOrder().ByteCount();}
-	unsigned int PublicKeyLength() const {return GetAbstractGroupParameters().GetEncodedElementSize(true);}
-
-	void GeneratePrivateKey(RandomNumberGenerator &rng, byte *privateKey) const
-	{
-		Integer x(rng, Integer::One(), GetAbstractGroupParameters().GetMaxExponent());
-		x.Encode(privateKey, PrivateKeyLength());
-	}
-
-	void GeneratePublicKey(RandomNumberGenerator &rng, const byte *privateKey, byte *publicKey) const
-	{
-		const DL_GroupParameters<T> &params = GetAbstractGroupParameters();
-		Integer x(privateKey, PrivateKeyLength());
-		Element y = params.ExponentiateBase(x);
-		params.EncodeElement(true, y, publicKey);
-	}
-	
-	bool Agree(byte *agreedValue, const byte *privateKey, const byte *otherPublicKey, bool validateOtherPublicKey=true) const
-	{
-		try
-		{
-			const DL_GroupParameters<T> &params = GetAbstractGroupParameters();
-			Integer x(privateKey, PrivateKeyLength());
-			Element w = params.DecodeElement(otherPublicKey, validateOtherPublicKey);
-
-			Element z = GetKeyAgreementAlgorithm().AgreeWithStaticPrivateKey(
-				GetAbstractGroupParameters(), w, validateOtherPublicKey, x);
-			params.EncodeElement(false, z, agreedValue);
-		}
-		catch (DL_BadElement &)
-		{
-			return false;
-		}
-		return true;
-	}
-
-	const Element &GetGenerator() const {return GetAbstractGroupParameters().GetSubgroupGenerator();}
-
-protected:
-	virtual const DL_KeyAgreementAlgorithm<Element> & GetKeyAgreementAlgorithm() const =0;
-	virtual DL_GroupParameters<Element> & AccessAbstractGroupParameters() =0;
-	const DL_GroupParameters<Element> & GetAbstractGroupParameters() const {return const_cast<DL_SimpleKeyAgreementDomainBase<Element> *>(this)->AccessAbstractGroupParameters();}
-};
-
-enum CofactorMultiplicationOption {NO_COFACTOR_MULTIPLICTION, COMPATIBLE_COFACTOR_MULTIPLICTION, INCOMPATIBLE_COFACTOR_MULTIPLICTION};
-typedef EnumToType<CofactorMultiplicationOption, NO_COFACTOR_MULTIPLICTION> NoCofactorMultiplication;
-typedef EnumToType<CofactorMultiplicationOption, COMPATIBLE_COFACTOR_MULTIPLICTION> CompatibleCofactorMultiplication;
-typedef EnumToType<CofactorMultiplicationOption, INCOMPATIBLE_COFACTOR_MULTIPLICTION> IncompatibleCofactorMultiplication;
-
-//! DH key agreement algorithm
-template <class ELEMENT, class COFACTOR_OPTION>
-class DL_KeyAgreementAlgorithm_DH : public DL_KeyAgreementAlgorithm<ELEMENT>
-{
-public:
-	typedef ELEMENT Element;
-
-	static const char *StaticAlgorithmName()
-		{return COFACTOR_OPTION::ToEnum() == NO_COFACTOR_MULTIPLICTION ? "DH" : "DHC";}
-
-	Element AgreeWithEphemeralPrivateKey(const DL_GroupParameters<Element> &params, const DL_FixedBasePrecomputation<Element> &publicPrecomputation, const Integer &privateExponent) const
-	{
-		return publicPrecomputation.Exponentiate(params.GetGroupPrecomputation(), 
-			COFACTOR_OPTION::ToEnum() == INCOMPATIBLE_COFACTOR_MULTIPLICTION ? privateExponent*params.GetCofactor() : privateExponent);
-	}
-
-	Element AgreeWithStaticPrivateKey(const DL_GroupParameters<Element> &params, const Element &publicElement, bool validateOtherPublicKey, const Integer &privateExponent) const
-	{
-		if (COFACTOR_OPTION::ToEnum() == COMPATIBLE_COFACTOR_MULTIPLICTION)
-		{
-			const Integer &k = params.GetCofactor();
-			return params.ExponentiateElement(publicElement, 
-				ModularArithmetic(params.GetSubgroupOrder()).Divide(privateExponent, k)*k);
-		}
-		else if (COFACTOR_OPTION::ToEnum() == INCOMPATIBLE_COFACTOR_MULTIPLICTION)
-			return params.ExponentiateElement(publicElement, privateExponent*params.GetCofactor());
-		else
-		{
-			assert(COFACTOR_OPTION::ToEnum() == NO_COFACTOR_MULTIPLICTION);
-
-			if (!validateOtherPublicKey)
-				return params.ExponentiateElement(publicElement, privateExponent);
-
-			if (params.FastSubgroupCheckAvailable())
-			{
-				if (!params.ValidateElement(2, publicElement, NULL))
-					throw DL_BadElement();
-				return params.ExponentiateElement(publicElement, privateExponent);
-			}
-			else
-			{
-				const Integer e[2] = {params.GetSubgroupOrder(), privateExponent};
-				Element r[2];
-				params.SimultaneousExponentiate(r, publicElement, e, 2);
-				if (!params.IsIdentity(r[0]))
-					throw DL_BadElement();
-				return r[1];
-			}
-		}
-	}
-};
-
-// ********************************************************
-
-//! A template implementing constructors for public key algorithm classes
-template <class BASE>
-class PK_FinalTemplate : public BASE
-{
-public:
-	PK_FinalTemplate() {}
-
-	PK_FinalTemplate(const Integer &v1)
-		{AccessKey().Initialize(v1);}
-
-	PK_FinalTemplate(const typename BASE::KeyClass &key)  {AccessKey().operator=(key);}
-
-	template <class T>
-	PK_FinalTemplate(const PublicKeyCopier<T> &key)
-		{key.CopyKeyInto(AccessKey());}
-
-	template <class T>
-	PK_FinalTemplate(const PrivateKeyCopier<T> &key)
-		{key.CopyKeyInto(AccessKey());}
-
-	PK_FinalTemplate(BufferedTransformation &bt) {AccessKey().BERDecode(bt);}
-
-#if (defined(_MSC_VER) && _MSC_VER < 1300)
-
-	template <class T1, class T2>
-	PK_FinalTemplate(T1 &v1, T2 &v2)
-		{AccessKey().Initialize(v1, v2);}
-
-	template <class T1, class T2, class T3>
-	PK_FinalTemplate(T1 &v1, T2 &v2, T3 &v3)
-		{AccessKey().Initialize(v1, v2, v3);}
-	
-	template <class T1, class T2, class T3, class T4>
-	PK_FinalTemplate(T1 &v1, T2 &v2, T3 &v3, T4 &v4)
-		{AccessKey().Initialize(v1, v2, v3, v4);}
-
-	template <class T1, class T2, class T3, class T4, class T5>
-	PK_FinalTemplate(T1 &v1, T2 &v2, T3 &v3, T4 &v4, T5 &v5)
-		{AccessKey().Initialize(v1, v2, v3, v4, v5);}
-
-	template <class T1, class T2, class T3, class T4, class T5, class T6>
-	PK_FinalTemplate(T1 &v1, T2 &v2, T3 &v3, T4 &v4, T5 &v5, T6 &v6)
-		{AccessKey().Initialize(v1, v2, v3, v4, v5, v6);}
-
-	template <class T1, class T2, class T3, class T4, class T5, class T6, class T7>
-	PK_FinalTemplate(T1 &v1, T2 &v2, T3 &v3, T4 &v4, T5 &v5, T6 &v6, T7 &v7)
-		{AccessKey().Initialize(v1, v2, v3, v4, v5, v6, v7);}
-
-	template <class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
-	PK_FinalTemplate(T1 &v1, T2 &v2, T3 &v3, T4 &v4, T5 &v5, T6 &v6, T7 &v7, T8 &v8)
-		{AccessKey().Initialize(v1, v2, v3, v4, v5, v6, v7, v8);}
-
-#else
-
-	template <class T1, class T2>
-	PK_FinalTemplate(const T1 &v1, const T2 &v2)
-		{AccessKey().Initialize(v1, v2);}
-
-	template <class T1, class T2, class T3>
-	PK_FinalTemplate(const T1 &v1, const T2 &v2, const T3 &v3)
-		{AccessKey().Initialize(v1, v2, v3);}
-	
-	template <class T1, class T2, class T3, class T4>
-	PK_FinalTemplate(const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4)
-		{AccessKey().Initialize(v1, v2, v3, v4);}
-
-	template <class T1, class T2, class T3, class T4, class T5>
-	PK_FinalTemplate(const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5)
-		{AccessKey().Initialize(v1, v2, v3, v4, v5);}
-
-	template <class T1, class T2, class T3, class T4, class T5, class T6>
-	PK_FinalTemplate(const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6)
-		{AccessKey().Initialize(v1, v2, v3, v4, v5, v6);}
-
-	template <class T1, class T2, class T3, class T4, class T5, class T6, class T7>
-	PK_FinalTemplate(const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7)
-		{AccessKey().Initialize(v1, v2, v3, v4, v5, v6, v7);}
-
-	template <class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
-	PK_FinalTemplate(const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7, const T8 &v8)
-		{AccessKey().Initialize(v1, v2, v3, v4, v5, v6, v7, v8);}
-
-	template <class T1, class T2>
-	PK_FinalTemplate(T1 &v1, const T2 &v2)
-		{AccessKey().Initialize(v1, v2);}
-
-	template <class T1, class T2, class T3>
-	PK_FinalTemplate(T1 &v1, const T2 &v2, const T3 &v3)
-		{AccessKey().Initialize(v1, v2, v3);}
-	
-	template <class T1, class T2, class T3, class T4>
-	PK_FinalTemplate(T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4)
-		{AccessKey().Initialize(v1, v2, v3, v4);}
-
-	template <class T1, class T2, class T3, class T4, class T5>
-	PK_FinalTemplate(T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5)
-		{AccessKey().Initialize(v1, v2, v3, v4, v5);}
-
-	template <class T1, class T2, class T3, class T4, class T5, class T6>
-	PK_FinalTemplate(T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6)
-		{AccessKey().Initialize(v1, v2, v3, v4, v5, v6);}
-
-	template <class T1, class T2, class T3, class T4, class T5, class T6, class T7>
-	PK_FinalTemplate(T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7)
-		{AccessKey().Initialize(v1, v2, v3, v4, v5, v6, v7);}
-
-	template <class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
-	PK_FinalTemplate(T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7, const T8 &v8)
-		{AccessKey().Initialize(v1, v2, v3, v4, v5, v6, v7, v8);}
-
-#endif
-};
-
-//! Base class for public key encryption standard classes. These classes are used to select from variants of algorithms. Note that not all standards apply to all algorithms.
-struct EncryptionStandard {};
-
-//! Base class for public key signature standard classes. These classes are used to select from variants of algorithms. Note that not all standards apply to all algorithms.
-struct SignatureStandard {};
-
-template <class STANDARD, class KEYS, class ALG_INFO>
-class TF_ES;
-
-//! Trapdoor Function Based Encryption Scheme
-template <class STANDARD, class KEYS, class ALG_INFO = TF_ES<STANDARD, KEYS, int> >
-class TF_ES : public KEYS
-{
-	typedef typename STANDARD::EncryptionMessageEncodingMethod MessageEncodingMethod;
-
-public:
-	//! see EncryptionStandard for a list of standards
-	typedef STANDARD Standard;
-	typedef TF_CryptoSchemeOptions<ALG_INFO, KEYS, MessageEncodingMethod> SchemeOptions;
-
-	static std::string StaticAlgorithmName() {return KEYS::StaticAlgorithmName() + "/" + MessageEncodingMethod::StaticAlgorithmName();}
-
-	//! implements PK_Decryptor interface
-	typedef PK_FinalTemplate<TF_DecryptorImpl<SchemeOptions> > Decryptor;
-	//! implements PK_Encryptor interface
-	typedef PK_FinalTemplate<TF_EncryptorImpl<SchemeOptions> > Encryptor;
-};
-
-template <class STANDARD, class H, class KEYS, class ALG_INFO>	// VC60 workaround: doesn't work if KEYS is first parameter
-class TF_SS;
-
-//! Trapdoor Function Based Signature Scheme
-template <class STANDARD, class H, class KEYS, class ALG_INFO = TF_SS<STANDARD, H, KEYS, int> >	// VC60 workaround: doesn't work if KEYS is first parameter
-class TF_SS : public KEYS
-{
-public:
-	//! see SignatureStandard for a list of standards
-	typedef STANDARD Standard;
-	typedef typename Standard::SignatureMessageEncodingMethod MessageEncodingMethod;
-	typedef TF_SignatureSchemeOptions<ALG_INFO, KEYS, MessageEncodingMethod, H> SchemeOptions;
-
-	static std::string StaticAlgorithmName() {return KEYS::StaticAlgorithmName() + "/" + MessageEncodingMethod::StaticAlgorithmName() + "(" + H::StaticAlgorithmName() + ")";}
-
-	//! implements PK_Signer interface
-	typedef PK_FinalTemplate<TF_SignerImpl<SchemeOptions> > Signer;
-	//! implements PK_Verifier interface
-	typedef PK_FinalTemplate<TF_VerifierImpl<SchemeOptions> > Verifier;
-};
-
-template <class KEYS, class SA, class MEM, class H, class ALG_INFO>
-class DL_SS;
-
-//! Discrete Log Based Signature Scheme
-template <class KEYS, class SA, class MEM, class H, class ALG_INFO = DL_SS<KEYS, SA, MEM, H, int> >
-class DL_SS : public KEYS
-{
-	typedef DL_SignatureSchemeOptions<ALG_INFO, KEYS, SA, MEM, H> SchemeOptions;
-
-public:
-	static std::string StaticAlgorithmName() {return SA::StaticAlgorithmName() + std::string("/EMSA1(") + H::StaticAlgorithmName() + ")";}
-
-	//! implements PK_Signer interface
-	typedef PK_FinalTemplate<DL_SignerImpl<SchemeOptions> > Signer;
-	//! implements PK_Verifier interface
-	typedef PK_FinalTemplate<DL_VerifierImpl<SchemeOptions> > Verifier;
-};
-
-//! Discrete Log Based Encryption Scheme
-template <class KEYS, class AA, class DA, class EA, class ALG_INFO>
-class DL_ES : public KEYS
-{
-	typedef DL_CryptoSchemeOptions<ALG_INFO, KEYS, AA, DA, EA> SchemeOptions;
-
-public:
-	//! implements PK_Decryptor interface
-	typedef PK_FinalTemplate<DL_DecryptorImpl<SchemeOptions> > Decryptor;
-	//! implements PK_Encryptor interface
-	typedef PK_FinalTemplate<DL_EncryptorImpl<SchemeOptions> > Encryptor;
-};
-
-NAMESPACE_END
-
-#endif
+// pubkey.h - written and placed in the public domain by Wei Dai
+
+#ifndef CRYPTOPP_PUBKEY_H
+#define CRYPTOPP_PUBKEY_H
+
+/** \file
+
+	This file contains helper classes/functions for implementing public key algorithms.
+
+	The class hierachies in this .h file tend to look like this:
+<pre>
+                  x1
+                 / \
+                y1  z1
+                 |  |
+            x2<y1>  x2<z1>
+                 |  |
+                y2  z2
+                 |  |
+            x3<y2>  x3<z2>
+                 |  |
+                y3  z3
+</pre>
+	- x1, y1, z1 are abstract interface classes defined in cryptlib.h
+	- x2, y2, z2 are implementations of the interfaces using "abstract policies", which
+	  are pure virtual functions that should return interfaces to interchangeable algorithms.
+	  These classes have "Base" suffixes.
+	- x3, y3, z3 hold actual algorithms and implement those virtual functions.
+	  These classes have "Impl" suffixes.
+
+	The "TF_" prefix means an implementation using trapdoor functions on integers.
+	The "DL_" prefix means an implementation using group operations (in groups where discrete log is hard).
+*/
+
+#include "modarith.h"
+#include "filters.h"
+#include "eprecomp.h"
+#include "fips140.h"
+#include "argnames.h"
+#include <memory>
+
+// VC60 workaround: this macro is defined in shlobj.h and conflicts with a template parameter used in this file
+#undef INTERFACE
+
+NAMESPACE_BEGIN(CryptoPP)
+
+//! _
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE TrapdoorFunctionBounds
+{
+public:
+	virtual ~TrapdoorFunctionBounds() {}
+
+	virtual Integer PreimageBound() const =0;
+	virtual Integer ImageBound() const =0;
+	virtual Integer MaxPreimage() const {return --PreimageBound();}
+	virtual Integer MaxImage() const {return --ImageBound();}
+};
+
+//! _
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE RandomizedTrapdoorFunction : public TrapdoorFunctionBounds
+{
+public:
+	virtual Integer ApplyRandomizedFunction(RandomNumberGenerator &rng, const Integer &x) const =0;
+	virtual bool IsRandomized() const {return true;}
+};
+
+//! _
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE TrapdoorFunction : public RandomizedTrapdoorFunction
+{
+public:
+	Integer ApplyRandomizedFunction(RandomNumberGenerator &rng, const Integer &x) const
+		{return ApplyFunction(x);}
+	bool IsRandomized() const {return false;}
+
+	virtual Integer ApplyFunction(const Integer &x) const =0;
+};
+
+//! _
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE RandomizedTrapdoorFunctionInverse
+{
+public:
+	virtual ~RandomizedTrapdoorFunctionInverse() {}
+
+	virtual Integer CalculateRandomizedInverse(RandomNumberGenerator &rng, const Integer &x) const =0;
+	virtual bool IsRandomized() const {return true;}
+};
+
+//! _
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE TrapdoorFunctionInverse : public RandomizedTrapdoorFunctionInverse
+{
+public:
+	virtual ~TrapdoorFunctionInverse() {}
+
+	Integer CalculateRandomizedInverse(RandomNumberGenerator &rng, const Integer &x) const
+		{return CalculateInverse(rng, x);}
+	bool IsRandomized() const {return false;}
+
+	virtual Integer CalculateInverse(RandomNumberGenerator &rng, const Integer &x) const =0;
+};
+
+// ********************************************************
+
+//! message encoding method for public key encryption
+class CRYPTOPP_NO_VTABLE PK_EncryptionMessageEncodingMethod
+{
+public:
+	virtual ~PK_EncryptionMessageEncodingMethod() {}
+
+	virtual bool ParameterSupported(const char *name) const {return false;}
+
+	//! max size of unpadded message in bytes, given max size of padded message in bits (1 less than size of modulus)
+	virtual size_t MaxUnpaddedLength(size_t paddedLength) const =0;
+
+	virtual void Pad(RandomNumberGenerator &rng, const byte *raw, size_t inputLength, byte *padded, size_t paddedBitLength, const NameValuePairs &parameters) const =0;
+
+	virtual DecodingResult Unpad(const byte *padded, size_t paddedBitLength, byte *raw, const NameValuePairs &parameters) const =0;
+};
+
+// ********************************************************
+
+//! _
+template <class TFI, class MEI>
+class CRYPTOPP_NO_VTABLE TF_Base
+{
+protected:
+	virtual const TrapdoorFunctionBounds & GetTrapdoorFunctionBounds() const =0;
+
+	typedef TFI TrapdoorFunctionInterface;
+	virtual const TrapdoorFunctionInterface & GetTrapdoorFunctionInterface() const =0;
+
+	typedef MEI MessageEncodingInterface;
+	virtual const MessageEncodingInterface & GetMessageEncodingInterface() const =0;
+};
+
+// ********************************************************
+
+//! _
+template <class BASE>
+class CRYPTOPP_NO_VTABLE PK_FixedLengthCryptoSystemImpl : public BASE
+{
+public:
+	size_t MaxPlaintextLength(size_t ciphertextLength) const
+		{return ciphertextLength == FixedCiphertextLength() ? FixedMaxPlaintextLength() : 0;}
+	size_t CiphertextLength(size_t plaintextLength) const
+		{return plaintextLength <= FixedMaxPlaintextLength() ? FixedCiphertextLength() : 0;}
+
+	virtual size_t FixedMaxPlaintextLength() const =0;
+	virtual size_t FixedCiphertextLength() const =0;
+};
+
+//! _
+template <class INTERFACE, class BASE>
+class CRYPTOPP_NO_VTABLE TF_CryptoSystemBase : public PK_FixedLengthCryptoSystemImpl<INTERFACE>, protected BASE
+{
+public:
+	bool ParameterSupported(const char *name) const {return this->GetMessageEncodingInterface().ParameterSupported(name);}
+	size_t FixedMaxPlaintextLength() const {return this->GetMessageEncodingInterface().MaxUnpaddedLength(PaddedBlockBitLength());}
+	size_t FixedCiphertextLength() const {return this->GetTrapdoorFunctionBounds().MaxImage().ByteCount();}
+
+protected:
+	size_t PaddedBlockByteLength() const {return BitsToBytes(PaddedBlockBitLength());}
+	size_t PaddedBlockBitLength() const {return this->GetTrapdoorFunctionBounds().PreimageBound().BitCount()-1;}
+};
+
+//! _
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE TF_DecryptorBase : public TF_CryptoSystemBase<PK_Decryptor, TF_Base<TrapdoorFunctionInverse, PK_EncryptionMessageEncodingMethod> >
+{
+public:
+	DecodingResult Decrypt(RandomNumberGenerator &rng, const byte *ciphertext, size_t ciphertextLength, byte *plaintext, const NameValuePairs &parameters = g_nullNameValuePairs) const;
+};
+
+//! _
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE TF_EncryptorBase : public TF_CryptoSystemBase<PK_Encryptor, TF_Base<RandomizedTrapdoorFunction, PK_EncryptionMessageEncodingMethod> >
+{
+public:
+	void Encrypt(RandomNumberGenerator &rng, const byte *plaintext, size_t plaintextLength, byte *ciphertext, const NameValuePairs &parameters = g_nullNameValuePairs) const;
+};
+
+// ********************************************************
+
+typedef std::pair<const byte *, size_t> HashIdentifier;
+
+//! interface for message encoding method for public key signature schemes
+class CRYPTOPP_NO_VTABLE PK_SignatureMessageEncodingMethod
+{
+public:
+	virtual ~PK_SignatureMessageEncodingMethod() {}
+
+	virtual size_t MinRepresentativeBitLength(size_t hashIdentifierLength, size_t digestLength) const
+		{return 0;}
+	virtual size_t MaxRecoverableLength(size_t representativeBitLength, size_t hashIdentifierLength, size_t digestLength) const
+		{return 0;}
+
+	bool IsProbabilistic() const 
+		{return true;}
+	bool AllowNonrecoverablePart() const
+		{throw NotImplemented("PK_MessageEncodingMethod: this signature scheme does not support message recovery");}
+	virtual bool RecoverablePartFirst() const
+		{throw NotImplemented("PK_MessageEncodingMethod: this signature scheme does not support message recovery");}
+
+	// for verification, DL
+	virtual void ProcessSemisignature(HashTransformation &hash, const byte *semisignature, size_t semisignatureLength) const {}
+
+	// for signature
+	virtual void ProcessRecoverableMessage(HashTransformation &hash, 
+		const byte *recoverableMessage, size_t recoverableMessageLength, 
+		const byte *presignature, size_t presignatureLength,
+		SecByteBlock &semisignature) const
+	{
+		if (RecoverablePartFirst())
+			assert(!"ProcessRecoverableMessage() not implemented");
+	}
+
+	virtual void ComputeMessageRepresentative(RandomNumberGenerator &rng, 
+		const byte *recoverableMessage, size_t recoverableMessageLength,
+		HashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,
+		byte *representative, size_t representativeBitLength) const =0;
+
+	virtual bool VerifyMessageRepresentative(
+		HashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,
+		byte *representative, size_t representativeBitLength) const =0;
+
+	virtual DecodingResult RecoverMessageFromRepresentative(	// for TF
+		HashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,
+		byte *representative, size_t representativeBitLength,
+		byte *recoveredMessage) const
+		{throw NotImplemented("PK_MessageEncodingMethod: this signature scheme does not support message recovery");}
+
+	virtual DecodingResult RecoverMessageFromSemisignature(		// for DL
+		HashTransformation &hash, HashIdentifier hashIdentifier,
+		const byte *presignature, size_t presignatureLength,
+		const byte *semisignature, size_t semisignatureLength,
+		byte *recoveredMessage) const
+		{throw NotImplemented("PK_MessageEncodingMethod: this signature scheme does not support message recovery");}
+
+	// VC60 workaround
+	struct HashIdentifierLookup
+	{
+		template <class H> struct HashIdentifierLookup2
+		{
+			static HashIdentifier CRYPTOPP_API Lookup()
+			{
+				return HashIdentifier((const byte *)NULL, 0);
+			}
+		};
+	};
+};
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PK_DeterministicSignatureMessageEncodingMethod : public PK_SignatureMessageEncodingMethod
+{
+public:
+	bool VerifyMessageRepresentative(
+		HashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,
+		byte *representative, size_t representativeBitLength) const;
+};
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PK_RecoverableSignatureMessageEncodingMethod : public PK_SignatureMessageEncodingMethod
+{
+public:
+	bool VerifyMessageRepresentative(
+		HashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,
+		byte *representative, size_t representativeBitLength) const;
+};
+
+class CRYPTOPP_DLL DL_SignatureMessageEncodingMethod_DSA : public PK_DeterministicSignatureMessageEncodingMethod
+{
+public:
+	void ComputeMessageRepresentative(RandomNumberGenerator &rng, 
+		const byte *recoverableMessage, size_t recoverableMessageLength,
+		HashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,
+		byte *representative, size_t representativeBitLength) const;
+};
+
+class CRYPTOPP_DLL DL_SignatureMessageEncodingMethod_NR : public PK_DeterministicSignatureMessageEncodingMethod
+{
+public:
+	void ComputeMessageRepresentative(RandomNumberGenerator &rng, 
+		const byte *recoverableMessage, size_t recoverableMessageLength,
+		HashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,
+		byte *representative, size_t representativeBitLength) const;
+};
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE PK_MessageAccumulatorBase : public PK_MessageAccumulator
+{
+public:
+	PK_MessageAccumulatorBase() : m_empty(true) {}
+
+	virtual HashTransformation & AccessHash() =0;
+
+	void Update(const byte *input, size_t length)
+	{
+		AccessHash().Update(input, length);
+		m_empty = m_empty && length == 0;
+	}
+
+	SecByteBlock m_recoverableMessage, m_representative, m_presignature, m_semisignature;
+	Integer m_k, m_s;
+	bool m_empty;
+};
+
+template <class HASH_ALGORITHM>
+class PK_MessageAccumulatorImpl : public PK_MessageAccumulatorBase, protected ObjectHolder<HASH_ALGORITHM>
+{
+public:
+	HashTransformation & AccessHash() {return this->m_object;}
+};
+
+//! _
+template <class INTERFACE, class BASE>
+class CRYPTOPP_NO_VTABLE TF_SignatureSchemeBase : public INTERFACE, protected BASE
+{
+public:
+	size_t SignatureLength() const 
+		{return this->GetTrapdoorFunctionBounds().MaxPreimage().ByteCount();}
+	size_t MaxRecoverableLength() const 
+		{return this->GetMessageEncodingInterface().MaxRecoverableLength(MessageRepresentativeBitLength(), GetHashIdentifier().second, GetDigestSize());}
+	size_t MaxRecoverableLengthFromSignatureLength(size_t signatureLength) const
+		{return this->MaxRecoverableLength();}
+
+	bool IsProbabilistic() const 
+		{return this->GetTrapdoorFunctionInterface().IsRandomized() || this->GetMessageEncodingInterface().IsProbabilistic();}
+	bool AllowNonrecoverablePart() const 
+		{return this->GetMessageEncodingInterface().AllowNonrecoverablePart();}
+	bool RecoverablePartFirst() const 
+		{return this->GetMessageEncodingInterface().RecoverablePartFirst();}
+
+protected:
+	size_t MessageRepresentativeLength() const {return BitsToBytes(MessageRepresentativeBitLength());}
+	size_t MessageRepresentativeBitLength() const {return this->GetTrapdoorFunctionBounds().ImageBound().BitCount()-1;}
+	virtual HashIdentifier GetHashIdentifier() const =0;
+	virtual size_t GetDigestSize() const =0;
+};
+
+//! _
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE TF_SignerBase : public TF_SignatureSchemeBase<PK_Signer, TF_Base<RandomizedTrapdoorFunctionInverse, PK_SignatureMessageEncodingMethod> >
+{
+public:
+	void InputRecoverableMessage(PK_MessageAccumulator &messageAccumulator, const byte *recoverableMessage, size_t recoverableMessageLength) const;
+	size_t SignAndRestart(RandomNumberGenerator &rng, PK_MessageAccumulator &messageAccumulator, byte *signature, bool restart=true) const;
+};
+
+//! _
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE TF_VerifierBase : public TF_SignatureSchemeBase<PK_Verifier, TF_Base<TrapdoorFunction, PK_SignatureMessageEncodingMethod> >
+{
+public:
+	void InputSignature(PK_MessageAccumulator &messageAccumulator, const byte *signature, size_t signatureLength) const;
+	bool VerifyAndRestart(PK_MessageAccumulator &messageAccumulator) const;
+	DecodingResult RecoverAndRestart(byte *recoveredMessage, PK_MessageAccumulator &recoveryAccumulator) const;
+};
+
+// ********************************************************
+
+//! _
+template <class T1, class T2, class T3>
+struct TF_CryptoSchemeOptions
+{
+	typedef T1 AlgorithmInfo;
+	typedef T2 Keys;
+	typedef typename Keys::PrivateKey PrivateKey;
+	typedef typename Keys::PublicKey PublicKey;
+	typedef T3 MessageEncodingMethod;
+};
+
+//! _
+template <class T1, class T2, class T3, class T4>
+struct TF_SignatureSchemeOptions : public TF_CryptoSchemeOptions<T1, T2, T3>
+{
+	typedef T4 HashFunction;
+};
+
+//! _
+template <class BASE, class SCHEME_OPTIONS, class KEY_CLASS>
+class CRYPTOPP_NO_VTABLE TF_ObjectImplBase : public AlgorithmImpl<BASE, typename SCHEME_OPTIONS::AlgorithmInfo>
+{
+public:
+	typedef SCHEME_OPTIONS SchemeOptions;
+	typedef KEY_CLASS KeyClass;
+
+	PublicKey & AccessPublicKey() {return AccessKey();}
+	const PublicKey & GetPublicKey() const {return GetKey();}
+
+	PrivateKey & AccessPrivateKey() {return AccessKey();}
+	const PrivateKey & GetPrivateKey() const {return GetKey();}
+
+	virtual const KeyClass & GetKey() const =0;
+	virtual KeyClass & AccessKey() =0;
+
+	const KeyClass & GetTrapdoorFunction() const {return GetKey();}
+
+	PK_MessageAccumulator * NewSignatureAccumulator(RandomNumberGenerator &rng) const
+	{
+		return new PK_MessageAccumulatorImpl<CPP_TYPENAME SCHEME_OPTIONS::HashFunction>;
+	}
+	PK_MessageAccumulator * NewVerificationAccumulator() const
+	{
+		return new PK_MessageAccumulatorImpl<CPP_TYPENAME SCHEME_OPTIONS::HashFunction>;
+	}
+
+protected:
+	const typename BASE::MessageEncodingInterface & GetMessageEncodingInterface() const 
+		{return Singleton<CPP_TYPENAME SCHEME_OPTIONS::MessageEncodingMethod>().Ref();}
+	const TrapdoorFunctionBounds & GetTrapdoorFunctionBounds() const 
+		{return GetKey();}
+	const typename BASE::TrapdoorFunctionInterface & GetTrapdoorFunctionInterface() const 
+		{return GetKey();}
+
+	// for signature scheme
+	HashIdentifier GetHashIdentifier() const
+	{
+        typedef CPP_TYPENAME SchemeOptions::MessageEncodingMethod::HashIdentifierLookup::template HashIdentifierLookup2<CPP_TYPENAME SchemeOptions::HashFunction> L;
+        return L::Lookup();
+	}
+	size_t GetDigestSize() const
+	{
+		typedef CPP_TYPENAME SchemeOptions::HashFunction H;
+		return H::DIGESTSIZE;
+	}
+};
+
+//! _
+template <class BASE, class SCHEME_OPTIONS, class KEY>
+class TF_ObjectImplExtRef : public TF_ObjectImplBase<BASE, SCHEME_OPTIONS, KEY>
+{
+public:
+	TF_ObjectImplExtRef(const KEY *pKey = NULL) : m_pKey(pKey) {}
+	void SetKeyPtr(const KEY *pKey) {m_pKey = pKey;}
+
+	const KEY & GetKey() const {return *m_pKey;}
+	KEY & AccessKey() {throw NotImplemented("TF_ObjectImplExtRef: cannot modify refererenced key");}
+
+private:
+	const KEY * m_pKey;
+};
+
+//! _
+template <class BASE, class SCHEME_OPTIONS, class KEY_CLASS>
+class CRYPTOPP_NO_VTABLE TF_ObjectImpl : public TF_ObjectImplBase<BASE, SCHEME_OPTIONS, KEY_CLASS>
+{
+public:
+	typedef KEY_CLASS KeyClass;
+
+	const KeyClass & GetKey() const {return m_trapdoorFunction;}
+	KeyClass & AccessKey() {return m_trapdoorFunction;}
+
+private:
+	KeyClass m_trapdoorFunction;
+};
+
+//! _
+template <class SCHEME_OPTIONS>
+class TF_DecryptorImpl : public TF_ObjectImpl<TF_DecryptorBase, SCHEME_OPTIONS, typename SCHEME_OPTIONS::PrivateKey>
+{
+};
+
+//! _
+template <class SCHEME_OPTIONS>
+class TF_EncryptorImpl : public TF_ObjectImpl<TF_EncryptorBase, SCHEME_OPTIONS, typename SCHEME_OPTIONS::PublicKey>
+{
+};
+
+//! _
+template <class SCHEME_OPTIONS>
+class TF_SignerImpl : public TF_ObjectImpl<TF_SignerBase, SCHEME_OPTIONS, typename SCHEME_OPTIONS::PrivateKey>
+{
+};
+
+//! _
+template <class SCHEME_OPTIONS>
+class TF_VerifierImpl : public TF_ObjectImpl<TF_VerifierBase, SCHEME_OPTIONS, typename SCHEME_OPTIONS::PublicKey>
+{
+};
+
+// ********************************************************
+
+//! _
+class CRYPTOPP_NO_VTABLE MaskGeneratingFunction
+{
+public:
+	virtual ~MaskGeneratingFunction() {}
+	virtual void GenerateAndMask(HashTransformation &hash, byte *output, size_t outputLength, const byte *input, size_t inputLength, bool mask = true) const =0;
+};
+
+CRYPTOPP_DLL void CRYPTOPP_API P1363_MGF1KDF2_Common(HashTransformation &hash, byte *output, size_t outputLength, const byte *input, size_t inputLength, const byte *derivationParams, size_t derivationParamsLength, bool mask, unsigned int counterStart);
+
+//! _
+class P1363_MGF1 : public MaskGeneratingFunction
+{
+public:
+	static const char * CRYPTOPP_API StaticAlgorithmName() {return "MGF1";}
+	void GenerateAndMask(HashTransformation &hash, byte *output, size_t outputLength, const byte *input, size_t inputLength, bool mask = true) const
+	{
+		P1363_MGF1KDF2_Common(hash, output, outputLength, input, inputLength, NULL, 0, mask, 0);
+	}
+};
+
+// ********************************************************
+
+//! _
+template <class H>
+class P1363_KDF2
+{
+public:
+	static void CRYPTOPP_API DeriveKey(byte *output, size_t outputLength, const byte *input, size_t inputLength, const byte *derivationParams, size_t derivationParamsLength)
+	{
+		H h;
+		P1363_MGF1KDF2_Common(h, output, outputLength, input, inputLength, derivationParams, derivationParamsLength, false, 1);
+	}
+};
+
+// ********************************************************
+
+//! to be thrown by DecodeElement and AgreeWithStaticPrivateKey
+class DL_BadElement : public InvalidDataFormat
+{
+public:
+	DL_BadElement() : InvalidDataFormat("CryptoPP: invalid group element") {}
+};
+
+//! interface for DL group parameters
+template <class T>
+class CRYPTOPP_NO_VTABLE DL_GroupParameters : public CryptoParameters
+{
+	typedef DL_GroupParameters<T> ThisClass;
+	
+public:
+	typedef T Element;
+
+	DL_GroupParameters() : m_validationLevel(0) {}
+
+	// CryptoMaterial
+	bool Validate(RandomNumberGenerator &rng, unsigned int level) const
+	{
+		if (!GetBasePrecomputation().IsInitialized())
+			return false;
+
+		if (m_validationLevel > level)
+			return true;
+
+		bool pass = ValidateGroup(rng, level);
+		pass = pass && ValidateElement(level, GetSubgroupGenerator(), &GetBasePrecomputation());
+
+		m_validationLevel = pass ? level+1 : 0;
+
+		return pass;
+	}
+
+	bool GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const
+	{
+		return GetValueHelper(this, name, valueType, pValue)
+			CRYPTOPP_GET_FUNCTION_ENTRY(SubgroupOrder)
+			CRYPTOPP_GET_FUNCTION_ENTRY(SubgroupGenerator)
+			;
+	}
+
+	bool SupportsPrecomputation() const {return true;}
+
+	void Precompute(unsigned int precomputationStorage=16)
+	{
+		AccessBasePrecomputation().Precompute(GetGroupPrecomputation(), GetSubgroupOrder().BitCount(), precomputationStorage);
+	}
+
+	void LoadPrecomputation(BufferedTransformation &storedPrecomputation)
+	{
+		AccessBasePrecomputation().Load(GetGroupPrecomputation(), storedPrecomputation);
+		m_validationLevel = 0;
+	}
+
+	void SavePrecomputation(BufferedTransformation &storedPrecomputation) const
+	{
+		GetBasePrecomputation().Save(GetGroupPrecomputation(), storedPrecomputation);
+	}
+
+	// non-inherited
+	virtual const Element & GetSubgroupGenerator() const {return GetBasePrecomputation().GetBase(GetGroupPrecomputation());}
+	virtual void SetSubgroupGenerator(const Element &base) {AccessBasePrecomputation().SetBase(GetGroupPrecomputation(), base);}
+	virtual Element ExponentiateBase(const Integer &exponent) const
+	{
+		return GetBasePrecomputation().Exponentiate(GetGroupPrecomputation(), exponent);
+	}
+	virtual Element ExponentiateElement(const Element &base, const Integer &exponent) const
+	{
+		Element result;
+		SimultaneousExponentiate(&result, base, &exponent, 1);
+		return result;
+	}
+
+	virtual const DL_GroupPrecomputation<Element> & GetGroupPrecomputation() const =0;
+	virtual const DL_FixedBasePrecomputation<Element> & GetBasePrecomputation() const =0;
+	virtual DL_FixedBasePrecomputation<Element> & AccessBasePrecomputation() =0;
+	virtual const Integer & GetSubgroupOrder() const =0;	// order of subgroup generated by base element
+	virtual Integer GetMaxExponent() const =0;
+	virtual Integer GetGroupOrder() const {return GetSubgroupOrder()*GetCofactor();}	// one of these two needs to be overriden
+	virtual Integer GetCofactor() const {return GetGroupOrder()/GetSubgroupOrder();}
+	virtual unsigned int GetEncodedElementSize(bool reversible) const =0;
+	virtual void EncodeElement(bool reversible, const Element &element, byte *encoded) const =0;
+	virtual Element DecodeElement(const byte *encoded, bool checkForGroupMembership) const =0;
+	virtual Integer ConvertElementToInteger(const Element &element) const =0;
+	virtual bool ValidateGroup(RandomNumberGenerator &rng, unsigned int level) const =0;
+	virtual bool ValidateElement(unsigned int level, const Element &element, const DL_FixedBasePrecomputation<Element> *precomp) const =0;
+	virtual bool FastSubgroupCheckAvailable() const =0;
+	virtual bool IsIdentity(const Element &element) const =0;
+	virtual void SimultaneousExponentiate(Element *results, const Element &base, const Integer *exponents, unsigned int exponentsCount) const =0;
+
+protected:
+	void ParametersChanged() {m_validationLevel = 0;}
+
+private:
+	mutable unsigned int m_validationLevel;
+};
+
+//! _
+template <class GROUP_PRECOMP, class BASE_PRECOMP = DL_FixedBasePrecomputationImpl<CPP_TYPENAME GROUP_PRECOMP::Element>, class BASE = DL_GroupParameters<CPP_TYPENAME GROUP_PRECOMP::Element> >
+class DL_GroupParametersImpl : public BASE
+{
+public:
+	typedef GROUP_PRECOMP GroupPrecomputation;
+	typedef typename GROUP_PRECOMP::Element Element;
+	typedef BASE_PRECOMP BasePrecomputation;
+	
+	const DL_GroupPrecomputation<Element> & GetGroupPrecomputation() const {return m_groupPrecomputation;}
+	const DL_FixedBasePrecomputation<Element> & GetBasePrecomputation() const {return m_gpc;}
+	DL_FixedBasePrecomputation<Element> & AccessBasePrecomputation() {return m_gpc;}
+
+protected:
+	GROUP_PRECOMP m_groupPrecomputation;
+	BASE_PRECOMP m_gpc;
+};
+
+//! _
+template <class T>
+class CRYPTOPP_NO_VTABLE DL_Key
+{
+public:
+	virtual const DL_GroupParameters<T> & GetAbstractGroupParameters() const =0;
+	virtual DL_GroupParameters<T> & AccessAbstractGroupParameters() =0;
+};
+
+//! interface for DL public keys
+template <class T>
+class CRYPTOPP_NO_VTABLE DL_PublicKey : public DL_Key<T>
+{
+	typedef DL_PublicKey<T> ThisClass;
+
+public:
+	typedef T Element;
+
+	bool GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const
+	{
+		return GetValueHelper(this, name, valueType, pValue, &this->GetAbstractGroupParameters())
+				CRYPTOPP_GET_FUNCTION_ENTRY(PublicElement);
+	}
+
+	void AssignFrom(const NameValuePairs &source);
+	
+	// non-inherited
+	virtual const Element & GetPublicElement() const {return GetPublicPrecomputation().GetBase(this->GetAbstractGroupParameters().GetGroupPrecomputation());}
+	virtual void SetPublicElement(const Element &y) {AccessPublicPrecomputation().SetBase(this->GetAbstractGroupParameters().GetGroupPrecomputation(), y);}
+	virtual Element ExponentiatePublicElement(const Integer &exponent) const
+	{
+		const DL_GroupParameters<T> &params = this->GetAbstractGroupParameters();
+		return GetPublicPrecomputation().Exponentiate(params.GetGroupPrecomputation(), exponent);
+	}
+	virtual Element CascadeExponentiateBaseAndPublicElement(const Integer &baseExp, const Integer &publicExp) const
+	{
+		const DL_GroupParameters<T> &params = this->GetAbstractGroupParameters();
+		return params.GetBasePrecomputation().CascadeExponentiate(params.GetGroupPrecomputation(), baseExp, GetPublicPrecomputation(), publicExp);
+	}
+
+	virtual const DL_FixedBasePrecomputation<T> & GetPublicPrecomputation() const =0;
+	virtual DL_FixedBasePrecomputation<T> & AccessPublicPrecomputation() =0;
+};
+
+//! interface for DL private keys
+template <class T>
+class CRYPTOPP_NO_VTABLE DL_PrivateKey : public DL_Key<T>
+{
+	typedef DL_PrivateKey<T> ThisClass;
+
+public:
+	typedef T Element;
+
+	void MakePublicKey(DL_PublicKey<T> &pub) const
+	{
+		pub.AccessAbstractGroupParameters().AssignFrom(this->GetAbstractGroupParameters());
+		pub.SetPublicElement(this->GetAbstractGroupParameters().ExponentiateBase(GetPrivateExponent()));
+	}
+
+	bool GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const
+	{
+		return GetValueHelper(this, name, valueType, pValue, &this->GetAbstractGroupParameters())
+				CRYPTOPP_GET_FUNCTION_ENTRY(PrivateExponent);
+	}
+
+	void AssignFrom(const NameValuePairs &source)
+	{
+		this->AccessAbstractGroupParameters().AssignFrom(source);
+		AssignFromHelper(this, source)
+			CRYPTOPP_SET_FUNCTION_ENTRY(PrivateExponent);
+	}
+
+	virtual const Integer & GetPrivateExponent() const =0;
+	virtual void SetPrivateExponent(const Integer &x) =0;
+};
+
+template <class T>
+void DL_PublicKey<T>::AssignFrom(const NameValuePairs &source)
+{
+	DL_PrivateKey<T> *pPrivateKey = NULL;
+	if (source.GetThisPointer(pPrivateKey))
+		pPrivateKey->MakePublicKey(*this);
+	else
+	{
+		this->AccessAbstractGroupParameters().AssignFrom(source);
+		AssignFromHelper(this, source)
+			CRYPTOPP_SET_FUNCTION_ENTRY(PublicElement);
+	}
+}
+
+class OID;
+
+//! _
+template <class PK, class GP, class O = OID>
+class DL_KeyImpl : public PK
+{
+public:
+	typedef GP GroupParameters;
+
+	O GetAlgorithmID() const {return GetGroupParameters().GetAlgorithmID();}
+//	void BERDecode(BufferedTransformation &bt)
+//		{PK::BERDecode(bt);}
+//	void DEREncode(BufferedTransformation &bt) const
+//		{PK::DEREncode(bt);}
+	bool BERDecodeAlgorithmParameters(BufferedTransformation &bt)
+		{AccessGroupParameters().BERDecode(bt); return true;}
+	bool DEREncodeAlgorithmParameters(BufferedTransformation &bt) const
+		{GetGroupParameters().DEREncode(bt); return true;}
+
+	const GP & GetGroupParameters() const {return m_groupParameters;}
+	GP & AccessGroupParameters() {return m_groupParameters;}
+
+private:
+	GP m_groupParameters;
+};
+
+class X509PublicKey;
+class PKCS8PrivateKey;
+
+//! _
+template <class GP>
+class DL_PrivateKeyImpl : public DL_PrivateKey<CPP_TYPENAME GP::Element>, public DL_KeyImpl<PKCS8PrivateKey, GP>
+{
+public:
+	typedef typename GP::Element Element;
+
+	// GeneratableCryptoMaterial
+	bool Validate(RandomNumberGenerator &rng, unsigned int level) const
+	{
+		bool pass = GetAbstractGroupParameters().Validate(rng, level);
+
+		const Integer &q = GetAbstractGroupParameters().GetSubgroupOrder();
+		const Integer &x = GetPrivateExponent();
+
+		pass = pass && x.IsPositive() && x < q;
+		if (level >= 1)
+			pass = pass && Integer::Gcd(x, q) == Integer::One();
+		return pass;
+	}
+
+	bool GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const
+	{
+		return GetValueHelper<DL_PrivateKey<Element> >(this, name, valueType, pValue).Assignable();
+	}
+
+	void AssignFrom(const NameValuePairs &source)
+	{
+		AssignFromHelper<DL_PrivateKey<Element> >(this, source);
+	}
+
+	void GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &params)
+	{
+		if (!params.GetThisObject(this->AccessGroupParameters()))
+			this->AccessGroupParameters().GenerateRandom(rng, params);
+//		std::pair<const byte *, int> seed;
+		Integer x(rng, Integer::One(), GetAbstractGroupParameters().GetMaxExponent());
+//			Integer::ANY, Integer::Zero(), Integer::One(),
+//			params.GetValue("DeterministicKeyGenerationSeed", seed) ? &seed : NULL);
+		SetPrivateExponent(x);
+	}
+
+	bool SupportsPrecomputation() const {return true;}
+
+	void Precompute(unsigned int precomputationStorage=16)
+		{AccessAbstractGroupParameters().Precompute(precomputationStorage);}
+
+	void LoadPrecomputation(BufferedTransformation &storedPrecomputation)
+		{AccessAbstractGroupParameters().LoadPrecomputation(storedPrecomputation);}
+
+	void SavePrecomputation(BufferedTransformation &storedPrecomputation) const
+		{GetAbstractGroupParameters().SavePrecomputation(storedPrecomputation);}
+
+	// DL_Key
+	const DL_GroupParameters<Element> & GetAbstractGroupParameters() const {return this->GetGroupParameters();}
+	DL_GroupParameters<Element> & AccessAbstractGroupParameters() {return this->AccessGroupParameters();}
+
+	// DL_PrivateKey
+	const Integer & GetPrivateExponent() const {return m_x;}
+	void SetPrivateExponent(const Integer &x) {m_x = x;}
+
+	// PKCS8PrivateKey
+	void BERDecodePrivateKey(BufferedTransformation &bt, bool, size_t)
+		{m_x.BERDecode(bt);}
+	void DEREncodePrivateKey(BufferedTransformation &bt) const
+		{m_x.DEREncode(bt);}
+
+private:
+	Integer m_x;
+};
+
+//! _
+template <class BASE, class SIGNATURE_SCHEME>
+class DL_PrivateKey_WithSignaturePairwiseConsistencyTest : public BASE
+{
+public:
+	void GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &params)
+	{
+		BASE::GenerateRandom(rng, params);
+
+		if (FIPS_140_2_ComplianceEnabled())
+		{
+			typename SIGNATURE_SCHEME::Signer signer(*this);
+			typename SIGNATURE_SCHEME::Verifier verifier(signer);
+			SignaturePairwiseConsistencyTest_FIPS_140_Only(signer, verifier);
+		}
+	}
+};
+
+//! _
+template <class GP>
+class DL_PublicKeyImpl : public DL_PublicKey<typename GP::Element>, public DL_KeyImpl<X509PublicKey, GP>
+{
+public:
+	typedef typename GP::Element Element;
+
+	// CryptoMaterial
+	bool Validate(RandomNumberGenerator &rng, unsigned int level) const
+	{
+		bool pass = GetAbstractGroupParameters().Validate(rng, level);
+		pass = pass && GetAbstractGroupParameters().ValidateElement(level, this->GetPublicElement(), &GetPublicPrecomputation());
+		return pass;
+	}
+
+	bool GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const
+	{
+		return GetValueHelper<DL_PublicKey<Element> >(this, name, valueType, pValue).Assignable();
+	}
+
+	void AssignFrom(const NameValuePairs &source)
+	{
+		AssignFromHelper<DL_PublicKey<Element> >(this, source);
+	}
+
+	bool SupportsPrecomputation() const {return true;}
+
+	void Precompute(unsigned int precomputationStorage=16)
+	{
+		AccessAbstractGroupParameters().Precompute(precomputationStorage);
+		AccessPublicPrecomputation().Precompute(GetAbstractGroupParameters().GetGroupPrecomputation(), GetAbstractGroupParameters().GetSubgroupOrder().BitCount(), precomputationStorage);
+	}
+
+	void LoadPrecomputation(BufferedTransformation &storedPrecomputation)
+	{
+		AccessAbstractGroupParameters().LoadPrecomputation(storedPrecomputation);
+		AccessPublicPrecomputation().Load(GetAbstractGroupParameters().GetGroupPrecomputation(), storedPrecomputation);
+	}
+
+	void SavePrecomputation(BufferedTransformation &storedPrecomputation) const
+	{
+		GetAbstractGroupParameters().SavePrecomputation(storedPrecomputation);
+		GetPublicPrecomputation().Save(GetAbstractGroupParameters().GetGroupPrecomputation(), storedPrecomputation);
+	}
+
+	// DL_Key
+	const DL_GroupParameters<Element> & GetAbstractGroupParameters() const {return this->GetGroupParameters();}
+	DL_GroupParameters<Element> & AccessAbstractGroupParameters() {return this->AccessGroupParameters();}
+
+	// DL_PublicKey
+	const DL_FixedBasePrecomputation<Element> & GetPublicPrecomputation() const {return m_ypc;}
+	DL_FixedBasePrecomputation<Element> & AccessPublicPrecomputation() {return m_ypc;}
+
+	// non-inherited
+	bool operator==(const DL_PublicKeyImpl<GP> &rhs) const
+		{return this->GetGroupParameters() == rhs.GetGroupParameters() && this->GetPublicElement() == rhs.GetPublicElement();}
+
+private:
+	typename GP::BasePrecomputation m_ypc;
+};
+
+//! interface for Elgamal-like signature algorithms
+template <class T>
+class CRYPTOPP_NO_VTABLE DL_ElgamalLikeSignatureAlgorithm
+{
+public:
+	virtual void Sign(const DL_GroupParameters<T> &params, const Integer &privateKey, const Integer &k, const Integer &e, Integer &r, Integer &s) const =0;
+	virtual bool Verify(const DL_GroupParameters<T> &params, const DL_PublicKey<T> &publicKey, const Integer &e, const Integer &r, const Integer &s) const =0;
+	virtual Integer RecoverPresignature(const DL_GroupParameters<T> &params, const DL_PublicKey<T> &publicKey, const Integer &r, const Integer &s) const
+		{throw NotImplemented("DL_ElgamalLikeSignatureAlgorithm: this signature scheme does not support message recovery");}
+	virtual size_t RLen(const DL_GroupParameters<T> &params) const
+		{return params.GetSubgroupOrder().ByteCount();}
+	virtual size_t SLen(const DL_GroupParameters<T> &params) const
+		{return params.GetSubgroupOrder().ByteCount();}
+};
+
+//! interface for DL key agreement algorithms
+template <class T>
+class CRYPTOPP_NO_VTABLE DL_KeyAgreementAlgorithm
+{
+public:
+	typedef T Element;
+
+	virtual Element AgreeWithEphemeralPrivateKey(const DL_GroupParameters<Element> &params, const DL_FixedBasePrecomputation<Element> &publicPrecomputation, const Integer &privateExponent) const =0;
+	virtual Element AgreeWithStaticPrivateKey(const DL_GroupParameters<Element> &params, const Element &publicElement, bool validateOtherPublicKey, const Integer &privateExponent) const =0;
+};
+
+//! interface for key derivation algorithms used in DL cryptosystems
+template <class T>
+class CRYPTOPP_NO_VTABLE DL_KeyDerivationAlgorithm
+{
+public:
+	virtual bool ParameterSupported(const char *name) const {return false;}
+	virtual void Derive(const DL_GroupParameters<T> &groupParams, byte *derivedKey, size_t derivedLength, const T &agreedElement, const T &ephemeralPublicKey, const NameValuePairs &derivationParams) const =0;
+};
+
+//! interface for symmetric encryption algorithms used in DL cryptosystems
+class CRYPTOPP_NO_VTABLE DL_SymmetricEncryptionAlgorithm
+{
+public:
+	virtual bool ParameterSupported(const char *name) const {return false;}
+	virtual size_t GetSymmetricKeyLength(size_t plaintextLength) const =0;
+	virtual size_t GetSymmetricCiphertextLength(size_t plaintextLength) const =0;
+	virtual size_t GetMaxSymmetricPlaintextLength(size_t ciphertextLength) const =0;
+	virtual void SymmetricEncrypt(RandomNumberGenerator &rng, const byte *key, const byte *plaintext, size_t plaintextLength, byte *ciphertext, const NameValuePairs &parameters) const =0;
+	virtual DecodingResult SymmetricDecrypt(const byte *key, const byte *ciphertext, size_t ciphertextLength, byte *plaintext, const NameValuePairs &parameters) const =0;
+};
+
+//! _
+template <class KI>
+class CRYPTOPP_NO_VTABLE DL_Base
+{
+protected:
+	typedef KI KeyInterface;
+	typedef typename KI::Element Element;
+
+	const DL_GroupParameters<Element> & GetAbstractGroupParameters() const {return GetKeyInterface().GetAbstractGroupParameters();}
+	DL_GroupParameters<Element> & AccessAbstractGroupParameters() {return AccessKeyInterface().AccessAbstractGroupParameters();}
+
+	virtual KeyInterface & AccessKeyInterface() =0;
+	virtual const KeyInterface & GetKeyInterface() const =0;
+};
+
+//! _
+template <class INTERFACE, class KEY_INTERFACE>
+class CRYPTOPP_NO_VTABLE DL_SignatureSchemeBase : public INTERFACE, public DL_Base<KEY_INTERFACE>
+{
+public:
+	size_t SignatureLength() const
+	{
+		return GetSignatureAlgorithm().RLen(this->GetAbstractGroupParameters())
+			+ GetSignatureAlgorithm().SLen(this->GetAbstractGroupParameters());
+	}
+	size_t MaxRecoverableLength() const 
+		{return GetMessageEncodingInterface().MaxRecoverableLength(0, GetHashIdentifier().second, GetDigestSize());}
+	size_t MaxRecoverableLengthFromSignatureLength(size_t signatureLength) const
+		{assert(false); return 0;}	// TODO
+
+	bool IsProbabilistic() const 
+		{return true;}
+	bool AllowNonrecoverablePart() const 
+		{return GetMessageEncodingInterface().AllowNonrecoverablePart();}
+	bool RecoverablePartFirst() const 
+		{return GetMessageEncodingInterface().RecoverablePartFirst();}
+
+protected:
+	size_t MessageRepresentativeLength() const {return BitsToBytes(MessageRepresentativeBitLength());}
+	size_t MessageRepresentativeBitLength() const {return this->GetAbstractGroupParameters().GetSubgroupOrder().BitCount();}
+
+	virtual const DL_ElgamalLikeSignatureAlgorithm<CPP_TYPENAME KEY_INTERFACE::Element> & GetSignatureAlgorithm() const =0;
+	virtual const PK_SignatureMessageEncodingMethod & GetMessageEncodingInterface() const =0;
+	virtual HashIdentifier GetHashIdentifier() const =0;
+	virtual size_t GetDigestSize() const =0;
+};
+
+//! _
+template <class T>
+class CRYPTOPP_NO_VTABLE DL_SignerBase : public DL_SignatureSchemeBase<PK_Signer, DL_PrivateKey<T> >
+{
+public:
+	// for validation testing
+	void RawSign(const Integer &k, const Integer &e, Integer &r, Integer &s) const
+	{
+		const DL_ElgamalLikeSignatureAlgorithm<T> &alg = this->GetSignatureAlgorithm();
+		const DL_GroupParameters<T> &params = this->GetAbstractGroupParameters();
+		const DL_PrivateKey<T> &key = this->GetKeyInterface();
+
+		r = params.ConvertElementToInteger(params.ExponentiateBase(k));
+		alg.Sign(params, key.GetPrivateExponent(), k, e, r, s);
+	}
+
+	void InputRecoverableMessage(PK_MessageAccumulator &messageAccumulator, const byte *recoverableMessage, size_t recoverableMessageLength) const
+	{
+		PK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);
+		ma.m_recoverableMessage.Assign(recoverableMessage, recoverableMessageLength);
+		this->GetMessageEncodingInterface().ProcessRecoverableMessage(ma.AccessHash(), 
+			recoverableMessage, recoverableMessageLength, 
+			ma.m_presignature, ma.m_presignature.size(),
+			ma.m_semisignature);
+	}
+
+	size_t SignAndRestart(RandomNumberGenerator &rng, PK_MessageAccumulator &messageAccumulator, byte *signature, bool restart) const
+	{
+		this->GetMaterial().DoQuickSanityCheck();
+
+		PK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);
+		const DL_ElgamalLikeSignatureAlgorithm<T> &alg = this->GetSignatureAlgorithm();
+		const DL_GroupParameters<T> &params = this->GetAbstractGroupParameters();
+		const DL_PrivateKey<T> &key = this->GetKeyInterface();
+
+		SecByteBlock representative(this->MessageRepresentativeLength());
+		this->GetMessageEncodingInterface().ComputeMessageRepresentative(
+			rng, 
+			ma.m_recoverableMessage, ma.m_recoverableMessage.size(), 
+			ma.AccessHash(), this->GetHashIdentifier(), ma.m_empty, 
+			representative, this->MessageRepresentativeBitLength());
+		ma.m_empty = true;
+		Integer e(representative, representative.size());
+
+		// hash message digest into random number k to prevent reusing the same k on a different messages
+		// after virtual machine rollback
+		if (rng.CanIncorporateEntropy())
+			rng.IncorporateEntropy(representative, representative.size());
+		Integer k(rng, 1, params.GetSubgroupOrder()-1);
+		Integer r, s;
+		r = params.ConvertElementToInteger(params.ExponentiateBase(k));
+		alg.Sign(params, key.GetPrivateExponent(), k, e, r, s);
+
+		/*
+		Integer r, s;
+		if (this->MaxRecoverableLength() > 0)
+			r.Decode(ma.m_semisignature, ma.m_semisignature.size());
+		else
+			r.Decode(ma.m_presignature, ma.m_presignature.size());
+		alg.Sign(params, key.GetPrivateExponent(), ma.m_k, e, r, s);
+		*/
+
+		size_t rLen = alg.RLen(params);
+		r.Encode(signature, rLen);
+		s.Encode(signature+rLen, alg.SLen(params));
+
+		if (restart)
+			RestartMessageAccumulator(rng, ma);
+
+		return this->SignatureLength();
+	}
+
+protected:
+	void RestartMessageAccumulator(RandomNumberGenerator &rng, PK_MessageAccumulatorBase &ma) const
+	{
+		// k needs to be generated before hashing for signature schemes with recovery
+		// but to defend against VM rollbacks we need to generate k after hashing.
+		// so this code is commented out, since no DL-based signature scheme with recovery
+		// has been implemented in Crypto++ anyway
+		/*
+		const DL_ElgamalLikeSignatureAlgorithm<T> &alg = this->GetSignatureAlgorithm();
+		const DL_GroupParameters<T> &params = this->GetAbstractGroupParameters();
+		ma.m_k.Randomize(rng, 1, params.GetSubgroupOrder()-1);
+		ma.m_presignature.New(params.GetEncodedElementSize(false));
+		params.ConvertElementToInteger(params.ExponentiateBase(ma.m_k)).Encode(ma.m_presignature, ma.m_presignature.size());
+		*/
+	}
+};
+
+//! _
+template <class T>
+class CRYPTOPP_NO_VTABLE DL_VerifierBase : public DL_SignatureSchemeBase<PK_Verifier, DL_PublicKey<T> >
+{
+public:
+	void InputSignature(PK_MessageAccumulator &messageAccumulator, const byte *signature, size_t signatureLength) const
+	{
+		PK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);
+		const DL_ElgamalLikeSignatureAlgorithm<T> &alg = this->GetSignatureAlgorithm();
+		const DL_GroupParameters<T> &params = this->GetAbstractGroupParameters();
+
+		size_t rLen = alg.RLen(params);
+		ma.m_semisignature.Assign(signature, rLen);
+		ma.m_s.Decode(signature+rLen, alg.SLen(params));
+
+		this->GetMessageEncodingInterface().ProcessSemisignature(ma.AccessHash(), ma.m_semisignature, ma.m_semisignature.size());
+	}
+	
+	bool VerifyAndRestart(PK_MessageAccumulator &messageAccumulator) const
+	{
+		this->GetMaterial().DoQuickSanityCheck();
+
+		PK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);
+		const DL_ElgamalLikeSignatureAlgorithm<T> &alg = this->GetSignatureAlgorithm();
+		const DL_GroupParameters<T> &params = this->GetAbstractGroupParameters();
+		const DL_PublicKey<T> &key = this->GetKeyInterface();
+
+		SecByteBlock representative(this->MessageRepresentativeLength());
+		this->GetMessageEncodingInterface().ComputeMessageRepresentative(NullRNG(), ma.m_recoverableMessage, ma.m_recoverableMessage.size(), 
+			ma.AccessHash(), this->GetHashIdentifier(), ma.m_empty,
+			representative, this->MessageRepresentativeBitLength());
+		ma.m_empty = true;
+		Integer e(representative, representative.size());
+
+		Integer r(ma.m_semisignature, ma.m_semisignature.size());
+		return alg.Verify(params, key, e, r, ma.m_s);
+	}
+
+	DecodingResult RecoverAndRestart(byte *recoveredMessage, PK_MessageAccumulator &messageAccumulator) const
+	{
+		this->GetMaterial().DoQuickSanityCheck();
+
+		PK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);
+		const DL_ElgamalLikeSignatureAlgorithm<T> &alg = this->GetSignatureAlgorithm();
+		const DL_GroupParameters<T> &params = this->GetAbstractGroupParameters();
+		const DL_PublicKey<T> &key = this->GetKeyInterface();
+
+		SecByteBlock representative(this->MessageRepresentativeLength());
+		this->GetMessageEncodingInterface().ComputeMessageRepresentative(
+			NullRNG(), 
+			ma.m_recoverableMessage, ma.m_recoverableMessage.size(), 
+			ma.AccessHash(), this->GetHashIdentifier(), ma.m_empty,
+			representative, this->MessageRepresentativeBitLength());
+		ma.m_empty = true;
+		Integer e(representative, representative.size());
+
+		ma.m_presignature.New(params.GetEncodedElementSize(false));
+		Integer r(ma.m_semisignature, ma.m_semisignature.size());
+		alg.RecoverPresignature(params, key, r, ma.m_s).Encode(ma.m_presignature, ma.m_presignature.size());
+
+		return this->GetMessageEncodingInterface().RecoverMessageFromSemisignature(
+			ma.AccessHash(), this->GetHashIdentifier(),
+			ma.m_presignature, ma.m_presignature.size(),
+			ma.m_semisignature, ma.m_semisignature.size(),
+			recoveredMessage);
+	}
+};
+
+//! _
+template <class PK, class KI>
+class CRYPTOPP_NO_VTABLE DL_CryptoSystemBase : public PK, public DL_Base<KI>
+{
+public:
+	typedef typename DL_Base<KI>::Element Element;
+
+	size_t MaxPlaintextLength(size_t ciphertextLength) const
+	{
+		unsigned int minLen = this->GetAbstractGroupParameters().GetEncodedElementSize(true);
+		return ciphertextLength < minLen ? 0 : GetSymmetricEncryptionAlgorithm().GetMaxSymmetricPlaintextLength(ciphertextLength - minLen);
+	}
+
+	size_t CiphertextLength(size_t plaintextLength) const
+	{
+		size_t len = GetSymmetricEncryptionAlgorithm().GetSymmetricCiphertextLength(plaintextLength);
+		return len == 0 ? 0 : this->GetAbstractGroupParameters().GetEncodedElementSize(true) + len;
+	}
+
+	bool ParameterSupported(const char *name) const
+		{return GetKeyDerivationAlgorithm().ParameterSupported(name) || GetSymmetricEncryptionAlgorithm().ParameterSupported(name);}
+
+protected:
+	virtual const DL_KeyAgreementAlgorithm<Element> & GetKeyAgreementAlgorithm() const =0;
+	virtual const DL_KeyDerivationAlgorithm<Element> & GetKeyDerivationAlgorithm() const =0;
+	virtual const DL_SymmetricEncryptionAlgorithm & GetSymmetricEncryptionAlgorithm() const =0;
+};
+
+//! _
+template <class T>
+class CRYPTOPP_NO_VTABLE DL_DecryptorBase : public DL_CryptoSystemBase<PK_Decryptor, DL_PrivateKey<T> >
+{
+public:
+	typedef T Element;
+
+	DecodingResult Decrypt(RandomNumberGenerator &rng, const byte *ciphertext, size_t ciphertextLength, byte *plaintext, const NameValuePairs &parameters = g_nullNameValuePairs) const
+	{
+		try
+		{
+			const DL_KeyAgreementAlgorithm<T> &agreeAlg = this->GetKeyAgreementAlgorithm();
+			const DL_KeyDerivationAlgorithm<T> &derivAlg = this->GetKeyDerivationAlgorithm();
+			const DL_SymmetricEncryptionAlgorithm &encAlg = this->GetSymmetricEncryptionAlgorithm();
+			const DL_GroupParameters<T> &params = this->GetAbstractGroupParameters();
+			const DL_PrivateKey<T> &key = this->GetKeyInterface();
+
+			Element q = params.DecodeElement(ciphertext, true);
+			size_t elementSize = params.GetEncodedElementSize(true);
+			ciphertext += elementSize;
+			ciphertextLength -= elementSize;
+
+			Element z = agreeAlg.AgreeWithStaticPrivateKey(params, q, true, key.GetPrivateExponent());
+
+			SecByteBlock derivedKey(encAlg.GetSymmetricKeyLength(encAlg.GetMaxSymmetricPlaintextLength(ciphertextLength)));
+			derivAlg.Derive(params, derivedKey, derivedKey.size(), z, q, parameters);
+
+			return encAlg.SymmetricDecrypt(derivedKey, ciphertext, ciphertextLength, plaintext, parameters);
+		}
+		catch (DL_BadElement &)
+		{
+			return DecodingResult();
+		}
+	}
+};
+
+//! _
+template <class T>
+class CRYPTOPP_NO_VTABLE DL_EncryptorBase : public DL_CryptoSystemBase<PK_Encryptor, DL_PublicKey<T> >
+{
+public:
+	typedef T Element;
+
+	void Encrypt(RandomNumberGenerator &rng, const byte *plaintext, size_t plaintextLength, byte *ciphertext, const NameValuePairs &parameters = g_nullNameValuePairs) const
+	{
+		const DL_KeyAgreementAlgorithm<T> &agreeAlg = this->GetKeyAgreementAlgorithm();
+		const DL_KeyDerivationAlgorithm<T> &derivAlg = this->GetKeyDerivationAlgorithm();
+		const DL_SymmetricEncryptionAlgorithm &encAlg = this->GetSymmetricEncryptionAlgorithm();
+		const DL_GroupParameters<T> &params = this->GetAbstractGroupParameters();
+		const DL_PublicKey<T> &key = this->GetKeyInterface();
+
+		Integer x(rng, Integer::One(), params.GetMaxExponent());
+		Element q = params.ExponentiateBase(x);
+		params.EncodeElement(true, q, ciphertext);
+		unsigned int elementSize = params.GetEncodedElementSize(true);
+		ciphertext += elementSize;
+
+		Element z = agreeAlg.AgreeWithEphemeralPrivateKey(params, key.GetPublicPrecomputation(), x);
+
+		SecByteBlock derivedKey(encAlg.GetSymmetricKeyLength(plaintextLength));
+		derivAlg.Derive(params, derivedKey, derivedKey.size(), z, q, parameters);
+
+		encAlg.SymmetricEncrypt(rng, derivedKey, plaintext, plaintextLength, ciphertext, parameters);
+	}
+};
+
+//! _
+template <class T1, class T2>
+struct DL_SchemeOptionsBase
+{
+	typedef T1 AlgorithmInfo;
+	typedef T2 GroupParameters;
+	typedef typename GroupParameters::Element Element;
+};
+
+//! _
+template <class T1, class T2>
+struct DL_KeyedSchemeOptions : public DL_SchemeOptionsBase<T1, typename T2::PublicKey::GroupParameters>
+{
+	typedef T2 Keys;
+	typedef typename Keys::PrivateKey PrivateKey;
+	typedef typename Keys::PublicKey PublicKey;
+};
+
+//! _
+template <class T1, class T2, class T3, class T4, class T5>
+struct DL_SignatureSchemeOptions : public DL_KeyedSchemeOptions<T1, T2>
+{
+	typedef T3 SignatureAlgorithm;
+	typedef T4 MessageEncodingMethod;
+	typedef T5 HashFunction;
+};
+
+//! _
+template <class T1, class T2, class T3, class T4, class T5>
+struct DL_CryptoSchemeOptions : public DL_KeyedSchemeOptions<T1, T2>
+{
+	typedef T3 KeyAgreementAlgorithm;
+	typedef T4 KeyDerivationAlgorithm;
+	typedef T5 SymmetricEncryptionAlgorithm;
+};
+
+//! _
+template <class BASE, class SCHEME_OPTIONS, class KEY>
+class CRYPTOPP_NO_VTABLE DL_ObjectImplBase : public AlgorithmImpl<BASE, typename SCHEME_OPTIONS::AlgorithmInfo>
+{
+public:
+	typedef SCHEME_OPTIONS SchemeOptions;
+	typedef typename KEY::Element Element;
+
+	PrivateKey & AccessPrivateKey() {return m_key;}
+	PublicKey & AccessPublicKey() {return m_key;}
+
+	// KeyAccessor
+	const KEY & GetKey() const {return m_key;}
+	KEY & AccessKey() {return m_key;}
+
+protected:
+	typename BASE::KeyInterface & AccessKeyInterface() {return m_key;}
+	const typename BASE::KeyInterface & GetKeyInterface() const {return m_key;}
+
+	// for signature scheme
+	HashIdentifier GetHashIdentifier() const
+	{
+		typedef typename SchemeOptions::MessageEncodingMethod::HashIdentifierLookup HashLookup;
+		return HashLookup::template HashIdentifierLookup2<CPP_TYPENAME SchemeOptions::HashFunction>::Lookup();
+	}
+	size_t GetDigestSize() const
+	{
+		typedef CPP_TYPENAME SchemeOptions::HashFunction H;
+		return H::DIGESTSIZE;
+	}
+
+private:
+	KEY m_key;
+};
+
+//! _
+template <class BASE, class SCHEME_OPTIONS, class KEY>
+class CRYPTOPP_NO_VTABLE DL_ObjectImpl : public DL_ObjectImplBase<BASE, SCHEME_OPTIONS, KEY>
+{
+public:
+	typedef typename KEY::Element Element;
+
+protected:
+	const DL_ElgamalLikeSignatureAlgorithm<Element> & GetSignatureAlgorithm() const
+		{return Singleton<CPP_TYPENAME SCHEME_OPTIONS::SignatureAlgorithm>().Ref();}
+	const DL_KeyAgreementAlgorithm<Element> & GetKeyAgreementAlgorithm() const
+		{return Singleton<CPP_TYPENAME SCHEME_OPTIONS::KeyAgreementAlgorithm>().Ref();}
+	const DL_KeyDerivationAlgorithm<Element> & GetKeyDerivationAlgorithm() const
+		{return Singleton<CPP_TYPENAME SCHEME_OPTIONS::KeyDerivationAlgorithm>().Ref();}
+	const DL_SymmetricEncryptionAlgorithm & GetSymmetricEncryptionAlgorithm() const
+		{return Singleton<CPP_TYPENAME SCHEME_OPTIONS::SymmetricEncryptionAlgorithm>().Ref();}
+	HashIdentifier GetHashIdentifier() const
+		{return HashIdentifier();}
+	const PK_SignatureMessageEncodingMethod & GetMessageEncodingInterface() const 
+		{return Singleton<CPP_TYPENAME SCHEME_OPTIONS::MessageEncodingMethod>().Ref();}
+};
+
+//! _
+template <class SCHEME_OPTIONS>
+class DL_SignerImpl : public DL_ObjectImpl<DL_SignerBase<typename SCHEME_OPTIONS::Element>, SCHEME_OPTIONS, typename SCHEME_OPTIONS::PrivateKey>
+{
+public:
+	PK_MessageAccumulator * NewSignatureAccumulator(RandomNumberGenerator &rng) const
+	{
+		std::auto_ptr<PK_MessageAccumulatorBase> p(new PK_MessageAccumulatorImpl<CPP_TYPENAME SCHEME_OPTIONS::HashFunction>);
+		this->RestartMessageAccumulator(rng, *p);
+		return p.release();
+	}
+};
+
+//! _
+template <class SCHEME_OPTIONS>
+class DL_VerifierImpl : public DL_ObjectImpl<DL_VerifierBase<typename SCHEME_OPTIONS::Element>, SCHEME_OPTIONS, typename SCHEME_OPTIONS::PublicKey>
+{
+public:
+	PK_MessageAccumulator * NewVerificationAccumulator() const
+	{
+		return new PK_MessageAccumulatorImpl<CPP_TYPENAME SCHEME_OPTIONS::HashFunction>;
+	}
+};
+
+//! _
+template <class SCHEME_OPTIONS>
+class DL_EncryptorImpl : public DL_ObjectImpl<DL_EncryptorBase<typename SCHEME_OPTIONS::Element>, SCHEME_OPTIONS, typename SCHEME_OPTIONS::PublicKey>
+{
+};
+
+//! _
+template <class SCHEME_OPTIONS>
+class DL_DecryptorImpl : public DL_ObjectImpl<DL_DecryptorBase<typename SCHEME_OPTIONS::Element>, SCHEME_OPTIONS, typename SCHEME_OPTIONS::PrivateKey>
+{
+};
+
+// ********************************************************
+
+//! _
+template <class T>
+class CRYPTOPP_NO_VTABLE DL_SimpleKeyAgreementDomainBase : public SimpleKeyAgreementDomain
+{
+public:
+	typedef T Element;
+
+	CryptoParameters & AccessCryptoParameters() {return AccessAbstractGroupParameters();}
+	unsigned int AgreedValueLength() const {return GetAbstractGroupParameters().GetEncodedElementSize(false);}
+	unsigned int PrivateKeyLength() const {return GetAbstractGroupParameters().GetSubgroupOrder().ByteCount();}
+	unsigned int PublicKeyLength() const {return GetAbstractGroupParameters().GetEncodedElementSize(true);}
+
+	void GeneratePrivateKey(RandomNumberGenerator &rng, byte *privateKey) const
+	{
+		Integer x(rng, Integer::One(), GetAbstractGroupParameters().GetMaxExponent());
+		x.Encode(privateKey, PrivateKeyLength());
+	}
+
+	void GeneratePublicKey(RandomNumberGenerator &rng, const byte *privateKey, byte *publicKey) const
+	{
+		const DL_GroupParameters<T> &params = GetAbstractGroupParameters();
+		Integer x(privateKey, PrivateKeyLength());
+		Element y = params.ExponentiateBase(x);
+		params.EncodeElement(true, y, publicKey);
+	}
+	
+	bool Agree(byte *agreedValue, const byte *privateKey, const byte *otherPublicKey, bool validateOtherPublicKey=true) const
+	{
+		try
+		{
+			const DL_GroupParameters<T> &params = GetAbstractGroupParameters();
+			Integer x(privateKey, PrivateKeyLength());
+			Element w = params.DecodeElement(otherPublicKey, validateOtherPublicKey);
+
+			Element z = GetKeyAgreementAlgorithm().AgreeWithStaticPrivateKey(
+				GetAbstractGroupParameters(), w, validateOtherPublicKey, x);
+			params.EncodeElement(false, z, agreedValue);
+		}
+		catch (DL_BadElement &)
+		{
+			return false;
+		}
+		return true;
+	}
+
+	const Element &GetGenerator() const {return GetAbstractGroupParameters().GetSubgroupGenerator();}
+
+protected:
+	virtual const DL_KeyAgreementAlgorithm<Element> & GetKeyAgreementAlgorithm() const =0;
+	virtual DL_GroupParameters<Element> & AccessAbstractGroupParameters() =0;
+	const DL_GroupParameters<Element> & GetAbstractGroupParameters() const {return const_cast<DL_SimpleKeyAgreementDomainBase<Element> *>(this)->AccessAbstractGroupParameters();}
+};
+
+enum CofactorMultiplicationOption {NO_COFACTOR_MULTIPLICTION, COMPATIBLE_COFACTOR_MULTIPLICTION, INCOMPATIBLE_COFACTOR_MULTIPLICTION};
+typedef EnumToType<CofactorMultiplicationOption, NO_COFACTOR_MULTIPLICTION> NoCofactorMultiplication;
+typedef EnumToType<CofactorMultiplicationOption, COMPATIBLE_COFACTOR_MULTIPLICTION> CompatibleCofactorMultiplication;
+typedef EnumToType<CofactorMultiplicationOption, INCOMPATIBLE_COFACTOR_MULTIPLICTION> IncompatibleCofactorMultiplication;
+
+//! DH key agreement algorithm
+template <class ELEMENT, class COFACTOR_OPTION>
+class DL_KeyAgreementAlgorithm_DH : public DL_KeyAgreementAlgorithm<ELEMENT>
+{
+public:
+	typedef ELEMENT Element;
+
+	static const char * CRYPTOPP_API StaticAlgorithmName()
+		{return COFACTOR_OPTION::ToEnum() == INCOMPATIBLE_COFACTOR_MULTIPLICTION ? "DHC" : "DH";}
+
+	Element AgreeWithEphemeralPrivateKey(const DL_GroupParameters<Element> &params, const DL_FixedBasePrecomputation<Element> &publicPrecomputation, const Integer &privateExponent) const
+	{
+		return publicPrecomputation.Exponentiate(params.GetGroupPrecomputation(), 
+			COFACTOR_OPTION::ToEnum() == INCOMPATIBLE_COFACTOR_MULTIPLICTION ? privateExponent*params.GetCofactor() : privateExponent);
+	}
+
+	Element AgreeWithStaticPrivateKey(const DL_GroupParameters<Element> &params, const Element &publicElement, bool validateOtherPublicKey, const Integer &privateExponent) const
+	{
+		if (COFACTOR_OPTION::ToEnum() == COMPATIBLE_COFACTOR_MULTIPLICTION)
+		{
+			const Integer &k = params.GetCofactor();
+			return params.ExponentiateElement(publicElement, 
+				ModularArithmetic(params.GetSubgroupOrder()).Divide(privateExponent, k)*k);
+		}
+		else if (COFACTOR_OPTION::ToEnum() == INCOMPATIBLE_COFACTOR_MULTIPLICTION)
+			return params.ExponentiateElement(publicElement, privateExponent*params.GetCofactor());
+		else
+		{
+			assert(COFACTOR_OPTION::ToEnum() == NO_COFACTOR_MULTIPLICTION);
+
+			if (!validateOtherPublicKey)
+				return params.ExponentiateElement(publicElement, privateExponent);
+
+			if (params.FastSubgroupCheckAvailable())
+			{
+				if (!params.ValidateElement(2, publicElement, NULL))
+					throw DL_BadElement();
+				return params.ExponentiateElement(publicElement, privateExponent);
+			}
+			else
+			{
+				const Integer e[2] = {params.GetSubgroupOrder(), privateExponent};
+				Element r[2];
+				params.SimultaneousExponentiate(r, publicElement, e, 2);
+				if (!params.IsIdentity(r[0]))
+					throw DL_BadElement();
+				return r[1];
+			}
+		}
+	}
+};
+
+// ********************************************************
+
+//! A template implementing constructors for public key algorithm classes
+template <class BASE>
+class CRYPTOPP_NO_VTABLE PK_FinalTemplate : public BASE
+{
+public:
+	PK_FinalTemplate() {}
+
+	PK_FinalTemplate(const CryptoMaterial &key)
+		{this->AccessKey().AssignFrom(key);}
+
+	PK_FinalTemplate(BufferedTransformation &bt)
+		{this->AccessKey().BERDecode(bt);}
+
+	PK_FinalTemplate(const AsymmetricAlgorithm &algorithm)
+		{this->AccessKey().AssignFrom(algorithm.GetMaterial());}
+
+	PK_FinalTemplate(const Integer &v1)
+		{this->AccessKey().Initialize(v1);}
+
+#if (defined(_MSC_VER) && _MSC_VER < 1300)
+
+	template <class T1, class T2>
+	PK_FinalTemplate(T1 &v1, T2 &v2)
+		{this->AccessKey().Initialize(v1, v2);}
+
+	template <class T1, class T2, class T3>
+	PK_FinalTemplate(T1 &v1, T2 &v2, T3 &v3)
+		{this->AccessKey().Initialize(v1, v2, v3);}
+	
+	template <class T1, class T2, class T3, class T4>
+	PK_FinalTemplate(T1 &v1, T2 &v2, T3 &v3, T4 &v4)
+		{this->AccessKey().Initialize(v1, v2, v3, v4);}
+
+	template <class T1, class T2, class T3, class T4, class T5>
+	PK_FinalTemplate(T1 &v1, T2 &v2, T3 &v3, T4 &v4, T5 &v5)
+		{this->AccessKey().Initialize(v1, v2, v3, v4, v5);}
+
+	template <class T1, class T2, class T3, class T4, class T5, class T6>
+	PK_FinalTemplate(T1 &v1, T2 &v2, T3 &v3, T4 &v4, T5 &v5, T6 &v6)
+		{this->AccessKey().Initialize(v1, v2, v3, v4, v5, v6);}
+
+	template <class T1, class T2, class T3, class T4, class T5, class T6, class T7>
+	PK_FinalTemplate(T1 &v1, T2 &v2, T3 &v3, T4 &v4, T5 &v5, T6 &v6, T7 &v7)
+		{this->AccessKey().Initialize(v1, v2, v3, v4, v5, v6, v7);}
+
+	template <class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
+	PK_FinalTemplate(T1 &v1, T2 &v2, T3 &v3, T4 &v4, T5 &v5, T6 &v6, T7 &v7, T8 &v8)
+		{this->AccessKey().Initialize(v1, v2, v3, v4, v5, v6, v7, v8);}
+
+#else
+
+	template <class T1, class T2>
+	PK_FinalTemplate(const T1 &v1, const T2 &v2)
+		{this->AccessKey().Initialize(v1, v2);}
+
+	template <class T1, class T2, class T3>
+	PK_FinalTemplate(const T1 &v1, const T2 &v2, const T3 &v3)
+		{this->AccessKey().Initialize(v1, v2, v3);}
+	
+	template <class T1, class T2, class T3, class T4>
+	PK_FinalTemplate(const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4)
+		{this->AccessKey().Initialize(v1, v2, v3, v4);}
+
+	template <class T1, class T2, class T3, class T4, class T5>
+	PK_FinalTemplate(const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5)
+		{this->AccessKey().Initialize(v1, v2, v3, v4, v5);}
+
+	template <class T1, class T2, class T3, class T4, class T5, class T6>
+	PK_FinalTemplate(const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6)
+		{this->AccessKey().Initialize(v1, v2, v3, v4, v5, v6);}
+
+	template <class T1, class T2, class T3, class T4, class T5, class T6, class T7>
+	PK_FinalTemplate(const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7)
+		{this->AccessKey().Initialize(v1, v2, v3, v4, v5, v6, v7);}
+
+	template <class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
+	PK_FinalTemplate(const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7, const T8 &v8)
+		{this->AccessKey().Initialize(v1, v2, v3, v4, v5, v6, v7, v8);}
+
+	template <class T1, class T2>
+	PK_FinalTemplate(T1 &v1, const T2 &v2)
+		{this->AccessKey().Initialize(v1, v2);}
+
+	template <class T1, class T2, class T3>
+	PK_FinalTemplate(T1 &v1, const T2 &v2, const T3 &v3)
+		{this->AccessKey().Initialize(v1, v2, v3);}
+	
+	template <class T1, class T2, class T3, class T4>
+	PK_FinalTemplate(T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4)
+		{this->AccessKey().Initialize(v1, v2, v3, v4);}
+
+	template <class T1, class T2, class T3, class T4, class T5>
+	PK_FinalTemplate(T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5)
+		{this->AccessKey().Initialize(v1, v2, v3, v4, v5);}
+
+	template <class T1, class T2, class T3, class T4, class T5, class T6>
+	PK_FinalTemplate(T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6)
+		{this->AccessKey().Initialize(v1, v2, v3, v4, v5, v6);}
+
+	template <class T1, class T2, class T3, class T4, class T5, class T6, class T7>
+	PK_FinalTemplate(T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7)
+		{this->AccessKey().Initialize(v1, v2, v3, v4, v5, v6, v7);}
+
+	template <class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
+	PK_FinalTemplate(T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7, const T8 &v8)
+		{this->AccessKey().Initialize(v1, v2, v3, v4, v5, v6, v7, v8);}
+
+#endif
+};
+
+//! Base class for public key encryption standard classes. These classes are used to select from variants of algorithms. Note that not all standards apply to all algorithms.
+struct EncryptionStandard {};
+
+//! Base class for public key signature standard classes. These classes are used to select from variants of algorithms. Note that not all standards apply to all algorithms.
+struct SignatureStandard {};
+
+template <class STANDARD, class KEYS, class ALG_INFO>
+class TF_ES;
+
+//! Trapdoor Function Based Encryption Scheme
+template <class STANDARD, class KEYS, class ALG_INFO = TF_ES<STANDARD, KEYS, int> >
+class TF_ES : public KEYS
+{
+	typedef typename STANDARD::EncryptionMessageEncodingMethod MessageEncodingMethod;
+
+public:
+	//! see EncryptionStandard for a list of standards
+	typedef STANDARD Standard;
+	typedef TF_CryptoSchemeOptions<ALG_INFO, KEYS, MessageEncodingMethod> SchemeOptions;
+
+	static std::string CRYPTOPP_API StaticAlgorithmName() {return std::string(KEYS::StaticAlgorithmName()) + "/" + MessageEncodingMethod::StaticAlgorithmName();}
+
+	//! implements PK_Decryptor interface
+	typedef PK_FinalTemplate<TF_DecryptorImpl<SchemeOptions> > Decryptor;
+	//! implements PK_Encryptor interface
+	typedef PK_FinalTemplate<TF_EncryptorImpl<SchemeOptions> > Encryptor;
+};
+
+template <class STANDARD, class H, class KEYS, class ALG_INFO>	// VC60 workaround: doesn't work if KEYS is first parameter
+class TF_SS;
+
+//! Trapdoor Function Based Signature Scheme
+template <class STANDARD, class H, class KEYS, class ALG_INFO = TF_SS<STANDARD, H, KEYS, int> >	// VC60 workaround: doesn't work if KEYS is first parameter
+class TF_SS : public KEYS
+{
+public:
+	//! see SignatureStandard for a list of standards
+	typedef STANDARD Standard;
+	typedef typename Standard::SignatureMessageEncodingMethod MessageEncodingMethod;
+	typedef TF_SignatureSchemeOptions<ALG_INFO, KEYS, MessageEncodingMethod, H> SchemeOptions;
+
+	static std::string CRYPTOPP_API StaticAlgorithmName() {return std::string(KEYS::StaticAlgorithmName()) + "/" + MessageEncodingMethod::StaticAlgorithmName() + "(" + H::StaticAlgorithmName() + ")";}
+
+	//! implements PK_Signer interface
+	typedef PK_FinalTemplate<TF_SignerImpl<SchemeOptions> > Signer;
+	//! implements PK_Verifier interface
+	typedef PK_FinalTemplate<TF_VerifierImpl<SchemeOptions> > Verifier;
+};
+
+template <class KEYS, class SA, class MEM, class H, class ALG_INFO>
+class DL_SS;
+
+//! Discrete Log Based Signature Scheme
+template <class KEYS, class SA, class MEM, class H, class ALG_INFO = DL_SS<KEYS, SA, MEM, H, int> >
+class DL_SS : public KEYS
+{
+	typedef DL_SignatureSchemeOptions<ALG_INFO, KEYS, SA, MEM, H> SchemeOptions;
+
+public:
+	static std::string StaticAlgorithmName() {return SA::StaticAlgorithmName() + std::string("/EMSA1(") + H::StaticAlgorithmName() + ")";}
+
+	//! implements PK_Signer interface
+	typedef PK_FinalTemplate<DL_SignerImpl<SchemeOptions> > Signer;
+	//! implements PK_Verifier interface
+	typedef PK_FinalTemplate<DL_VerifierImpl<SchemeOptions> > Verifier;
+};
+
+//! Discrete Log Based Encryption Scheme
+template <class KEYS, class AA, class DA, class EA, class ALG_INFO>
+class DL_ES : public KEYS
+{
+	typedef DL_CryptoSchemeOptions<ALG_INFO, KEYS, AA, DA, EA> SchemeOptions;
+
+public:
+	//! implements PK_Decryptor interface
+	typedef PK_FinalTemplate<DL_DecryptorImpl<SchemeOptions> > Decryptor;
+	//! implements PK_Encryptor interface
+	typedef PK_FinalTemplate<DL_EncryptorImpl<SchemeOptions> > Encryptor;
+};
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/queue.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/queue.h
index 64328195..75f7807f 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/queue.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/queue.h
@@ -1,128 +1,143 @@
-// specification file for an unlimited queue for storing bytes
-
-#ifndef CRYPTOPP_QUEUE_H
-#define CRYPTOPP_QUEUE_H
-
-#include "simple.h"
-//#include <algorithm>
-
-NAMESPACE_BEGIN(CryptoPP)
-
-/** The queue is implemented as a linked list of byte arrays, but you don't need to
-    know about that.  So just ignore this next line. :) */
-class ByteQueueNode;
-
-//! Byte Queue
-class ByteQueue : public Bufferless<BufferedTransformation>
-{
-public:
-	ByteQueue(unsigned int m_nodeSize=256);
-	ByteQueue(const ByteQueue &copy);
-	~ByteQueue();
-
-	unsigned long MaxRetrievable() const
-		{return CurrentSize();}
-	bool AnyRetrievable() const
-		{return !IsEmpty();}
-
-	void IsolatedInitialize(const NameValuePairs &parameters);
-	byte * CreatePutSpace(unsigned int &size);
-	unsigned int Put2(const byte *inString, unsigned int length, int messageEnd, bool blocking);
-
-	unsigned int Get(byte &outByte);
-	unsigned int Get(byte *outString, unsigned int getMax);
-
-	unsigned int Peek(byte &outByte) const;
-	unsigned int Peek(byte *outString, unsigned int peekMax) const;
-
-	unsigned int TransferTo2(BufferedTransformation &target, unsigned long &transferBytes, const std::string &channel=NULL_CHANNEL, bool blocking=true);
-	unsigned int CopyRangeTo2(BufferedTransformation &target, unsigned long &begin, unsigned long end=ULONG_MAX, const std::string &channel=NULL_CHANNEL, bool blocking=true) const;
-
-	// these member functions are not inherited
-	void SetNodeSize(unsigned int nodeSize) {m_nodeSize = nodeSize;}
-
-	unsigned long CurrentSize() const;
-	bool IsEmpty() const;
-
-	void Clear();
-
-	void Unget(byte inByte);
-	void Unget(const byte *inString, unsigned int length);
-
-	const byte * Spy(unsigned int &contiguousSize) const;
-
-	void LazyPut(const byte *inString, unsigned int size);
-	void UndoLazyPut(unsigned int size);
-	void FinalizeLazyPut();
-
-	ByteQueue & operator=(const ByteQueue &rhs);
-	bool operator==(const ByteQueue &rhs) const;
-	byte operator[](unsigned long i) const;
-	void swap(ByteQueue &rhs);
-
-	class Walker : public InputRejecting<BufferedTransformation>
-	{
-	public:
-		Walker(const ByteQueue &queue)
-			: m_queue(queue) {Initialize();}
-
-		unsigned long GetCurrentPosition() {return m_position;}
-
-		unsigned long MaxRetrievable() const
-			{return m_queue.CurrentSize() - m_position;}
-
-		void IsolatedInitialize(const NameValuePairs &parameters);
-
-		unsigned int Get(byte &outByte);
-		unsigned int Get(byte *outString, unsigned int getMax);
-
-		unsigned int Peek(byte &outByte) const;
-		unsigned int Peek(byte *outString, unsigned int peekMax) const;
-
-		unsigned int TransferTo2(BufferedTransformation &target, unsigned long &transferBytes, const std::string &channel=NULL_CHANNEL, bool blocking=true);
-		unsigned int CopyRangeTo2(BufferedTransformation &target, unsigned long &begin, unsigned long end=ULONG_MAX, const std::string &channel=NULL_CHANNEL, bool blocking=true) const;
-
-	private:
-		const ByteQueue &m_queue;
-		const ByteQueueNode *m_node;
-		unsigned long m_position;
-		unsigned int m_offset;
-		const byte *m_lazyString;
-		unsigned int m_lazyLength;
-	};
-
-	friend class Walker;
-
-private:
-	void CleanupUsedNodes();
-	void CopyFrom(const ByteQueue &copy);
-	void Destroy();
-
-	unsigned int m_nodeSize;
-	ByteQueueNode *m_head, *m_tail;
-	const byte *m_lazyString;
-	unsigned int m_lazyLength;
-};
-
-//! use this to make sure LazyPut is finalized in event of exception
-class LazyPutter
-{
-public:
-	LazyPutter(ByteQueue &bq, const byte *inString, unsigned int size)
-		: m_bq(bq) {bq.LazyPut(inString, size);}
-	~LazyPutter()
-		{try {m_bq.FinalizeLazyPut();} catch(...) {}}
-private:
-	ByteQueue &m_bq;
-};
-
-NAMESPACE_END
-
-NAMESPACE_BEGIN(std)
-template<> inline void swap(CryptoPP::ByteQueue &a, CryptoPP::ByteQueue &b)
-{
-	a.swap(b);
-}
-NAMESPACE_END
-
-#endif
+// specification file for an unlimited queue for storing bytes
+
+#ifndef CRYPTOPP_QUEUE_H
+#define CRYPTOPP_QUEUE_H
+
+#include "simple.h"
+//#include <algorithm>
+
+NAMESPACE_BEGIN(CryptoPP)
+
+/** The queue is implemented as a linked list of byte arrays, but you don't need to
+    know about that.  So just ignore this next line. :) */
+class ByteQueueNode;
+
+//! Byte Queue
+class CRYPTOPP_DLL ByteQueue : public Bufferless<BufferedTransformation>
+{
+public:
+	ByteQueue(size_t nodeSize=0);
+	ByteQueue(const ByteQueue &copy);
+	~ByteQueue();
+
+	lword MaxRetrievable() const
+		{return CurrentSize();}
+	bool AnyRetrievable() const
+		{return !IsEmpty();}
+
+	void IsolatedInitialize(const NameValuePairs &parameters);
+	byte * CreatePutSpace(size_t &size);
+	size_t Put2(const byte *inString, size_t length, int messageEnd, bool blocking);
+
+	size_t Get(byte &outByte);
+	size_t Get(byte *outString, size_t getMax);
+
+	size_t Peek(byte &outByte) const;
+	size_t Peek(byte *outString, size_t peekMax) const;
+
+	size_t TransferTo2(BufferedTransformation &target, lword &transferBytes, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true);
+	size_t CopyRangeTo2(BufferedTransformation &target, lword &begin, lword end=LWORD_MAX, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true) const;
+
+	// these member functions are not inherited
+	void SetNodeSize(size_t nodeSize);
+
+	lword CurrentSize() const;
+	bool IsEmpty() const;
+
+	void Clear();
+
+	void Unget(byte inByte);
+	void Unget(const byte *inString, size_t length);
+
+	const byte * Spy(size_t &contiguousSize) const;
+
+	void LazyPut(const byte *inString, size_t size);
+	void LazyPutModifiable(byte *inString, size_t size);
+	void UndoLazyPut(size_t size);
+	void FinalizeLazyPut();
+
+	ByteQueue & operator=(const ByteQueue &rhs);
+	bool operator==(const ByteQueue &rhs) const;
+	byte operator[](lword i) const;
+	void swap(ByteQueue &rhs);
+
+	class Walker : public InputRejecting<BufferedTransformation>
+	{
+	public:
+		Walker(const ByteQueue &queue)
+			: m_queue(queue) {Initialize();}
+
+		lword GetCurrentPosition() {return m_position;}
+
+		lword MaxRetrievable() const
+			{return m_queue.CurrentSize() - m_position;}
+
+		void IsolatedInitialize(const NameValuePairs &parameters);
+
+		size_t Get(byte &outByte);
+		size_t Get(byte *outString, size_t getMax);
+
+		size_t Peek(byte &outByte) const;
+		size_t Peek(byte *outString, size_t peekMax) const;
+
+		size_t TransferTo2(BufferedTransformation &target, lword &transferBytes, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true);
+		size_t CopyRangeTo2(BufferedTransformation &target, lword &begin, lword end=LWORD_MAX, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true) const;
+
+	private:
+		const ByteQueue &m_queue;
+		const ByteQueueNode *m_node;
+		lword m_position;
+		size_t m_offset;
+		const byte *m_lazyString;
+		size_t m_lazyLength;
+	};
+
+	friend class Walker;
+
+private:
+	void CleanupUsedNodes();
+	void CopyFrom(const ByteQueue &copy);
+	void Destroy();
+
+	bool m_autoNodeSize;
+	size_t m_nodeSize;
+	ByteQueueNode *m_head, *m_tail;
+	byte *m_lazyString;
+	size_t m_lazyLength;
+	bool m_lazyStringModifiable;
+};
+
+//! use this to make sure LazyPut is finalized in event of exception
+class CRYPTOPP_DLL LazyPutter
+{
+public:
+	LazyPutter(ByteQueue &bq, const byte *inString, size_t size)
+		: m_bq(bq) {bq.LazyPut(inString, size);}
+	~LazyPutter()
+		{try {m_bq.FinalizeLazyPut();} catch(...) {}}
+protected:
+	LazyPutter(ByteQueue &bq) : m_bq(bq) {}
+private:
+	ByteQueue &m_bq;
+};
+
+//! like LazyPutter, but does a LazyPutModifiable instead
+class LazyPutterModifiable : public LazyPutter
+{
+public:
+	LazyPutterModifiable(ByteQueue &bq, byte *inString, size_t size)
+		: LazyPutter(bq) {bq.LazyPutModifiable(inString, size);}
+};
+
+NAMESPACE_END
+
+#ifndef __BORLANDC__
+NAMESPACE_BEGIN(std)
+template<> inline void swap(CryptoPP::ByteQueue &a, CryptoPP::ByteQueue &b)
+{
+	a.swap(b);
+}
+NAMESPACE_END
+#endif
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/randpool.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/randpool.h
new file mode 100644
index 00000000..c25bc9bb
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/randpool.h
@@ -0,0 +1,33 @@
+#ifndef CRYPTOPP_RANDPOOL_H
+#define CRYPTOPP_RANDPOOL_H
+
+#include "cryptlib.h"
+#include "filters.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+//! Randomness Pool
+/*! This class can be used to generate cryptographic quality
+	pseudorandom bytes after seeding the pool with IncorporateEntropy() */
+class CRYPTOPP_DLL RandomPool : public RandomNumberGenerator, public NotCopyable
+{
+public:
+	RandomPool();
+
+	bool CanIncorporateEntropy() const {return true;}
+	void IncorporateEntropy(const byte *input, size_t length);
+	void GenerateIntoBufferedTransformation(BufferedTransformation &target, const std::string &channel, lword size);
+
+	// for backwards compatibility. use RandomNumberSource, RandomNumberStore, and RandomNumberSink for other BufferTransformation functionality
+	void Put(const byte *input, size_t length) {IncorporateEntropy(input, length);}
+
+private:
+	FixedSizeSecBlock<byte, 32> m_key;
+	FixedSizeSecBlock<byte, 16> m_seed;
+	member_ptr<BlockCipher> m_pCipher;
+	bool m_keySet;
+};
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/rijndael.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/rijndael.h
new file mode 100644
index 00000000..64c784b0
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/rijndael.h
@@ -0,0 +1,68 @@
+#ifndef CRYPTOPP_RIJNDAEL_H
+#define CRYPTOPP_RIJNDAEL_H
+
+/** \file
+*/
+
+#include "seckey.h"
+#include "secblock.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+//! _
+struct Rijndael_Info : public FixedBlockSize<16>, public VariableKeyLength<16, 16, 32, 8>
+{
+	CRYPTOPP_DLL static const char * CRYPTOPP_API StaticAlgorithmName() {return CRYPTOPP_RIJNDAEL_NAME;}
+};
+
+/// <a href="http://www.weidai.com/scan-mirror/cs.html#Rijndael">Rijndael</a>
+class CRYPTOPP_DLL Rijndael : public Rijndael_Info, public BlockCipherDocumentation
+{
+	class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE Base : public BlockCipherImpl<Rijndael_Info>
+	{
+	public:
+		void UncheckedSetKey(const byte *userKey, unsigned int length, const NameValuePairs &params);
+
+	protected:
+		static void FillEncTable();
+		static void FillDecTable();
+
+		// VS2005 workaround: have to put these on seperate lines, or error C2487 is triggered in DLL build
+		static const byte Se[256];
+		static const byte Sd[256];
+
+		static const word32 rcon[];
+
+		unsigned int m_rounds;
+		FixedSizeAlignedSecBlock<word32, 4*15> m_key;
+	};
+
+	class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE Enc : public Base
+	{
+	public:
+		void ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const;
+#if CRYPTOPP_BOOL_X64 || CRYPTOPP_BOOL_X86
+		size_t AdvancedProcessBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags) const;
+#endif
+	};
+
+	class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE Dec : public Base
+	{
+	public:
+		void ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const;
+#if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE
+		size_t AdvancedProcessBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags) const;
+#endif
+	};
+
+public:
+	typedef BlockCipherFinal<ENCRYPTION, Enc> Encryption;
+	typedef BlockCipherFinal<DECRYPTION, Dec> Decryption;
+};
+
+typedef Rijndael::Encryption RijndaelEncryption;
+typedef Rijndael::Decryption RijndaelDecryption;
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/rng.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/rng.h
new file mode 100644
index 00000000..2439dee6
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/rng.h
@@ -0,0 +1,77 @@
+// rng.h - misc RNG related classes, see also osrng.h, randpool.h
+
+#ifndef CRYPTOPP_RNG_H
+#define CRYPTOPP_RNG_H
+
+#include "cryptlib.h"
+#include "filters.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+//! linear congruential generator
+/*! originally by William S. England, do not use for cryptographic purposes */
+class LC_RNG : public RandomNumberGenerator
+{
+public:
+	LC_RNG(word32 init_seed)
+		: seed(init_seed) {}
+
+	void GenerateBlock(byte *output, size_t size);
+
+	word32 GetSeed() {return seed;}
+
+private:
+	word32 seed;
+
+	static const word32 m;
+	static const word32 q;
+	static const word16 a;
+	static const word16 r;
+};
+
+//! RNG derived from ANSI X9.17 Appendix C
+
+class CRYPTOPP_DLL X917RNG : public RandomNumberGenerator, public NotCopyable
+{
+public:
+	// cipher will be deleted by destructor, deterministicTimeVector = 0 means obtain time vector from system
+	X917RNG(BlockTransformation *cipher, const byte *seed, const byte *deterministicTimeVector = 0);
+
+	void GenerateIntoBufferedTransformation(BufferedTransformation &target, const std::string &channel, lword size);
+
+private:
+	member_ptr<BlockTransformation> cipher;
+	unsigned int S;			// blocksize of cipher
+	SecByteBlock dtbuf; 	// buffer for enciphered timestamp
+	SecByteBlock randseed, m_lastBlock, m_deterministicTimeVector;
+};
+
+/** This class implements Maurer's Universal Statistical Test for Random Bit Generators
+    it is intended for measuring the randomness of *PHYSICAL* RNGs.
+    For more details see his paper in Journal of Cryptology, 1992. */
+
+class MaurerRandomnessTest : public Bufferless<Sink>
+{
+public:
+	MaurerRandomnessTest();
+
+	size_t Put2(const byte *inString, size_t length, int messageEnd, bool blocking);
+
+	// BytesNeeded() returns how many more bytes of input is needed by the test
+	// GetTestValue() should not be called before BytesNeeded()==0
+	unsigned int BytesNeeded() const {return n >= (Q+K) ? 0 : Q+K-n;}
+
+	// returns a number between 0.0 and 1.0, describing the quality of the
+	// random numbers entered
+	double GetTestValue() const;
+
+private:
+	enum {L=8, V=256, Q=2000, K=2000};
+	double sum;
+	unsigned int n;
+	unsigned int tab[V];
+};
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/secblock.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/secblock.h
index c3ac9c99..24b9fc09 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/secblock.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/secblock.h
@@ -1,385 +1,467 @@
-// secblock.h - written and placed in the public domain by Wei Dai
-
-#ifndef CRYPTOPP_SECBLOCK_H
-#define CRYPTOPP_SECBLOCK_H
-
-#include "config.h"
-#include "misc.h"
-#include <string.h>		// CodeWarrior doesn't have memory.h
-#include <assert.h>
-
-NAMESPACE_BEGIN(CryptoPP)
-
-// ************** secure memory allocation ***************
-
-template<class T>
-class AllocatorBase
-{
-public:
-	typedef T value_type;
-	typedef size_t size_type;
-#if (defined(_MSC_VER) && _MSC_VER < 1300)
-	typedef ptrdiff_t difference_type;
-#else
-	typedef std::ptrdiff_t difference_type;
-#endif
-	typedef T * pointer;
-	typedef const T * const_pointer;
-	typedef T & reference;
-	typedef const T & const_reference;
-
-	pointer address(reference r) const {return (&r);}
-	const_pointer address(const_reference r) const {return (&r); }
-	void construct(pointer p, const T& val) {new (p) T(val);}
-	void destroy(pointer p) {p->~T();}
-	size_type max_size() const {return size_type(-1)/sizeof(T);}
-};
-
-#define CRYPTOPP_INHERIT_ALLOCATOR_TYPES	\
-typedef typename AllocatorBase<T>::value_type value_type;\
-typedef typename AllocatorBase<T>::size_type size_type;\
-typedef typename AllocatorBase<T>::difference_type difference_type;\
-typedef typename AllocatorBase<T>::pointer pointer;\
-typedef typename AllocatorBase<T>::const_pointer const_pointer;\
-typedef typename AllocatorBase<T>::reference reference;\
-typedef typename AllocatorBase<T>::const_reference const_reference;
-
-template <class T, class A>
-typename A::pointer StandardReallocate(A& a, T *p, typename A::size_type oldSize, typename A::size_type newSize, bool preserve)
-{
-	if (oldSize == newSize)
-		return p;
-
-	if (preserve)
-	{
-		typename A::pointer newPointer = a.allocate(newSize, NULL);
-		memcpy(newPointer, p, sizeof(T)*STDMIN(oldSize, newSize));
-		a.deallocate(p, oldSize);
-		return newPointer;
-	}
-	else
-	{
-		a.deallocate(p, oldSize);
-		return a.allocate(newSize, NULL);
-	}
-}
-
-template <class T>
-class AllocatorWithCleanup : public AllocatorBase<T>
-{
-public:
-	CRYPTOPP_INHERIT_ALLOCATOR_TYPES
-
-	pointer allocate(size_type n, const void * = NULL)
-	{
-		if (n > 0)
-			return new T[n];
-		else
-			return NULL;
-	}
-
-	void deallocate(void *p, size_type n)
-	{
-		memset(p, 0, n*sizeof(T));
-		delete [] (T *)p;
-	}
-
-	pointer reallocate(T *p, size_type oldSize, size_type newSize, bool preserve)
-	{
-		return StandardReallocate(*this, p, oldSize, newSize, preserve);
-	}
-
-	// VS.NET STL enforces the policy of "All STL-compliant allocators have to provide a
-	// template class member called rebind".
-    template <class U> struct rebind { typedef AllocatorWithCleanup<U> other; };
-};
-
-template <class T>
-class NullAllocator : public AllocatorBase<T>
-{
-public:
-	CRYPTOPP_INHERIT_ALLOCATOR_TYPES
-
-	pointer allocate(size_type n, const void * = NULL)
-	{
-		assert(false);
-		return NULL;
-	}
-
-	void deallocate(void *p, size_type n)
-	{
-		assert(false);
-	}
-};
-
-// this allocator can't be used with standard collections
-template <class T, unsigned int S, class A = NullAllocator<T> >
-class FixedSizeAllocatorWithCleanup : public AllocatorBase<T>
-{
-public:
-	CRYPTOPP_INHERIT_ALLOCATOR_TYPES
-
-	pointer allocate(size_type n)
-	{
-		if (n <= S)
-		{
-			assert(!m_allocated);
-#ifndef NDEBUG
-			m_allocated = true;
-#endif
-			return m_array;
-		}
-		else
-			return m_fallbackAllocator.allocate(n);
-	}
-
-	pointer allocate(size_type n, const void *hint)
-	{
-		if (n <= S)
-		{
-			assert(!m_allocated);
-#ifndef NDEBUG
-			m_allocated = true;
-#endif
-			return m_array;
-		}
-		else
-			return m_fallbackAllocator.allocate(n, hint);
-	}
-
-	void deallocate(void *p, size_type n)
-	{
-		if (n <= S)
-		{
-			assert(m_allocated);
-			assert(p == m_array);
-#ifndef NDEBUG
-			m_allocated = false;
-#endif
-			memset(p, 0, n*sizeof(T));
-		}
-		else
-			m_fallbackAllocator.deallocate(p, n);
-	}
-
-	pointer reallocate(pointer p, size_type oldSize, size_type newSize, bool preserve)
-	{
-		if (oldSize <= S && newSize <= S)
-			return p;
-
-		return StandardReallocate(*this, p, oldSize, newSize, preserve);
-	}
-
-	size_type max_size() const {return m_fallbackAllocator.max_size();}
-
-private:
-	A m_fallbackAllocator;
-	T m_array[S];
-
-#ifndef NDEBUG
-public:
-	FixedSizeAllocatorWithCleanup() : m_allocated(false) {}
-	bool m_allocated;
-#endif
-};
-
-//! a block of memory allocated using A
-template <class T, class A = AllocatorWithCleanup<T> >
-class SecBlock
-{
-public:
-	explicit SecBlock(unsigned int size=0)
-		: m_size(size) {m_ptr = m_alloc.allocate(size, NULL);}
-	SecBlock(const SecBlock<T, A> &t)
-		: m_size(t.m_size) {m_ptr = m_alloc.allocate(m_size, NULL); memcpy(m_ptr, t.m_ptr, m_size*sizeof(T));}
-	SecBlock(const T *t, unsigned int len)
-		: m_size(len)
-	{
-		m_ptr = m_alloc.allocate(len, NULL);
-		if (t == NULL)
-			memset(m_ptr, 0, len*sizeof(T));
-		else
-			memcpy(m_ptr, t, len*sizeof(T));
-	}
-
-	~SecBlock()
-		{m_alloc.deallocate(m_ptr, m_size);}
-
-#if defined(__GNUC__) || defined(__BCPLUSPLUS__)
-	operator const void *() const
-		{return m_ptr;}
-	operator void *()
-		{return m_ptr;}
-#endif
-#if defined(__GNUC__)	// reduce warnings
-	operator const void *()
-		{return m_ptr;}
-#endif
-
-	operator const T *() const
-		{return m_ptr;}
-	operator T *()
-		{return m_ptr;}
-#if defined(__GNUC__)	// reduce warnings
-	operator const T *()
-		{return m_ptr;}
-#endif
-
-	template <typename I>
-	T *operator +(I offset)
-		{return m_ptr+offset;}
-
-	template <typename I>
-	const T *operator +(I offset) const
-		{return m_ptr+offset;}
-
-	template <typename I>
-	T& operator[](I index)
-		{assert(index >= 0 && (unsigned int)index < m_size); return m_ptr[index];}
-
-	template <typename I>
-	const T& operator[](I index) const
-		{assert(index >= 0 && (unsigned int)index < m_size); return m_ptr[index];}
-
-	typedef typename A::pointer iterator;
-	typedef typename A::const_pointer const_iterator;
-	typedef typename A::size_type size_type;
-
-	iterator begin()
-		{return m_ptr;}
-	const_iterator begin() const
-		{return m_ptr;}
-	iterator end()
-		{return m_ptr+m_size;}
-	const_iterator end() const
-		{return m_ptr+m_size;}
-
-	typename A::pointer data() {return m_ptr;}
-	typename A::const_pointer data() const {return m_ptr;}
-
-	size_type size() const {return m_size;}
-	bool empty() const {return m_size == 0;}
-
-	void Assign(const T *t, unsigned int len)
-	{
-		New(len);
-		memcpy(m_ptr, t, len*sizeof(T));
-	}
-
-	void Assign(const SecBlock<T, A> &t)
-	{
-		New(t.m_size);
-		memcpy(m_ptr, t.m_ptr, m_size*sizeof(T));
-	}
-
-	SecBlock& operator=(const SecBlock<T, A> &t)
-	{
-		Assign(t);
-		return *this;
-	}
-
-	bool operator==(const SecBlock<T, A> &t) const
-	{
-		return m_size == t.m_size && memcmp(m_ptr, t.m_ptr, m_size*sizeof(T)) == 0;
-	}
-
-	bool operator!=(const SecBlock<T, A> &t) const
-	{
-		return !operator==(t);
-	}
-
-	void New(unsigned int newSize)
-	{
-		m_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);
-		m_size = newSize;
-	}
-
-	void CleanNew(unsigned int newSize)
-	{
-		New(newSize);
-		memset(m_ptr, 0, m_size*sizeof(T));
-	}
-
-	void Grow(unsigned int newSize)
-	{
-		if (newSize > m_size)
-		{
-			m_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, true);
-			m_size = newSize;
-		}
-	}
-
-	void CleanGrow(unsigned int newSize)
-	{
-		if (newSize > m_size)
-		{
-			m_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, true);
-			memset(m_ptr+m_size, 0, (newSize-m_size)*sizeof(T));
-			m_size = newSize;
-		}
-	}
-
-	void resize(unsigned int newSize)
-	{
-		m_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, true);
-		m_size = newSize;
-	}
-
-	void swap(SecBlock<T, A> &b);
-
-//private:
-	A m_alloc;
-	unsigned int m_size;
-	T *m_ptr;
-};
-
-template <class T, class A> void SecBlock<T, A>::swap(SecBlock<T, A> &b)
-{
-	std::swap(m_alloc, b.m_alloc);
-	std::swap(m_size, b.m_size);
-	std::swap(m_ptr, b.m_ptr);
-}
-
-typedef SecBlock<byte> SecByteBlock;
-typedef SecBlock<word> SecWordBlock;
-
-template <class T, unsigned int S, class A = FixedSizeAllocatorWithCleanup<T, S> >
-class FixedSizeSecBlock : public SecBlock<T, A>
-{
-public:
-	explicit FixedSizeSecBlock() : SecBlock<T, A>(S) {}
-};
-
-template <class T, unsigned int S, class A = FixedSizeAllocatorWithCleanup<T, S, AllocatorWithCleanup<T> > >
-class SecBlockWithHint : public SecBlock<T, A>
-{
-public:
-	explicit SecBlockWithHint(unsigned int size) : SecBlock<T, A>(size) {}
-};
-
-template<class T, class U>
-inline bool operator==(const CryptoPP::AllocatorWithCleanup<T>&, const CryptoPP::AllocatorWithCleanup<U>&) {return (true);}
-template<class T, class U>
-inline bool operator!=(const CryptoPP::AllocatorWithCleanup<T>&, const CryptoPP::AllocatorWithCleanup<U>&) {return (false);}
-
-NAMESPACE_END
-
-NAMESPACE_BEGIN(std)
-template <class T, class A>
-inline void swap(CryptoPP::SecBlock<T, A> &a, CryptoPP::SecBlock<T, A> &b)
-{
-	a.swap(b);
-}
-
-#if defined(_STLPORT_VERSION) && !defined(_STLP_MEMBER_TEMPLATE_CLASSES)
-template <class _Tp1, class _Tp2>
-inline CryptoPP::AllocatorWithCleanup<_Tp2>&
-__stl_alloc_rebind(CryptoPP::AllocatorWithCleanup<_Tp1>& __a, const _Tp2*)
-{
-	return (CryptoPP::AllocatorWithCleanup<_Tp2>&)(__a);
-}
-#endif
-
-NAMESPACE_END
-
-#endif
+// secblock.h - written and placed in the public domain by Wei Dai
+
+#ifndef CRYPTOPP_SECBLOCK_H
+#define CRYPTOPP_SECBLOCK_H
+
+#include "config.h"
+#include "misc.h"
+#include <assert.h>
+
+NAMESPACE_BEGIN(CryptoPP)
+
+// ************** secure memory allocation ***************
+
+template<class T>
+class AllocatorBase
+{
+public:
+	typedef T value_type;
+	typedef size_t size_type;
+#ifdef CRYPTOPP_MSVCRT6
+	typedef ptrdiff_t difference_type;
+#else
+	typedef std::ptrdiff_t difference_type;
+#endif
+	typedef T * pointer;
+	typedef const T * const_pointer;
+	typedef T & reference;
+	typedef const T & const_reference;
+
+	pointer address(reference r) const {return (&r);}
+	const_pointer address(const_reference r) const {return (&r); }
+	void construct(pointer p, const T& val) {new (p) T(val);}
+	void destroy(pointer p) {p->~T();}
+	size_type max_size() const {return ~size_type(0)/sizeof(T);}	// switch to std::numeric_limits<T>::max later
+
+protected:
+	static void CheckSize(size_t n)
+	{
+		if (n > ~size_t(0) / sizeof(T))
+			throw InvalidArgument("AllocatorBase: requested size would cause integer overflow");
+	}
+};
+
+#define CRYPTOPP_INHERIT_ALLOCATOR_TYPES	\
+typedef typename AllocatorBase<T>::value_type value_type;\
+typedef typename AllocatorBase<T>::size_type size_type;\
+typedef typename AllocatorBase<T>::difference_type difference_type;\
+typedef typename AllocatorBase<T>::pointer pointer;\
+typedef typename AllocatorBase<T>::const_pointer const_pointer;\
+typedef typename AllocatorBase<T>::reference reference;\
+typedef typename AllocatorBase<T>::const_reference const_reference;
+
+#if defined(_MSC_VER) && (_MSC_VER < 1300)
+// this pragma causes an internal compiler error if placed immediately before std::swap(a, b)
+#pragma warning(push)
+#pragma warning(disable: 4700)	// VC60 workaround: don't know how to get rid of this warning
+#endif
+
+template <class T, class A>
+typename A::pointer StandardReallocate(A& a, T *p, typename A::size_type oldSize, typename A::size_type newSize, bool preserve)
+{
+	if (oldSize == newSize)
+		return p;
+
+	if (preserve)
+	{
+		typename A::pointer newPointer = a.allocate(newSize, NULL);
+		memcpy_s(newPointer, sizeof(T)*newSize, p, sizeof(T)*STDMIN(oldSize, newSize));
+		a.deallocate(p, oldSize);
+		return newPointer;
+	}
+	else
+	{
+		a.deallocate(p, oldSize);
+		return a.allocate(newSize, NULL);
+	}
+}
+
+#if defined(_MSC_VER) && (_MSC_VER < 1300)
+#pragma warning(pop)
+#endif
+
+template <class T, bool T_Align16 = false>
+class AllocatorWithCleanup : public AllocatorBase<T>
+{
+public:
+	CRYPTOPP_INHERIT_ALLOCATOR_TYPES
+
+	pointer allocate(size_type n, const void * = NULL)
+	{
+		CheckSize(n);
+		if (n == 0)
+			return NULL;
+
+#if CRYPTOPP_BOOL_ALIGN16_ENABLED
+		if (T_Align16 && n*sizeof(T) >= 16)
+			return (pointer)AlignedAllocate(n*sizeof(T));
+#endif
+
+		return (pointer)UnalignedAllocate(n*sizeof(T));
+	}
+
+	void deallocate(void *p, size_type n)
+	{
+		SecureWipeArray((pointer)p, n);
+
+#if CRYPTOPP_BOOL_ALIGN16_ENABLED
+		if (T_Align16 && n*sizeof(T) >= 16)
+			return AlignedDeallocate(p);
+#endif
+
+		UnalignedDeallocate(p);
+	}
+
+	pointer reallocate(T *p, size_type oldSize, size_type newSize, bool preserve)
+	{
+		return StandardReallocate(*this, p, oldSize, newSize, preserve);
+	}
+
+	// VS.NET STL enforces the policy of "All STL-compliant allocators have to provide a
+	// template class member called rebind".
+    template <class U> struct rebind { typedef AllocatorWithCleanup<U, T_Align16> other; };
+#if _MSC_VER >= 1500
+	AllocatorWithCleanup() {}
+	template <class U, bool A> AllocatorWithCleanup(const AllocatorWithCleanup<U, A> &) {}
+#endif
+};
+
+CRYPTOPP_DLL_TEMPLATE_CLASS AllocatorWithCleanup<byte>;
+CRYPTOPP_DLL_TEMPLATE_CLASS AllocatorWithCleanup<word16>;
+CRYPTOPP_DLL_TEMPLATE_CLASS AllocatorWithCleanup<word32>;
+CRYPTOPP_DLL_TEMPLATE_CLASS AllocatorWithCleanup<word64>;
+#if CRYPTOPP_BOOL_X86
+CRYPTOPP_DLL_TEMPLATE_CLASS AllocatorWithCleanup<word, true>;	// for Integer
+#endif
+
+template <class T>
+class NullAllocator : public AllocatorBase<T>
+{
+public:
+	CRYPTOPP_INHERIT_ALLOCATOR_TYPES
+
+	pointer allocate(size_type n, const void * = NULL)
+	{
+		assert(false);
+		return NULL;
+	}
+
+	void deallocate(void *p, size_type n)
+	{
+		assert(false);
+	}
+
+	size_type max_size() const {return 0;}
+};
+
+// This allocator can't be used with standard collections because
+// they require that all objects of the same allocator type are equivalent.
+// So this is for use with SecBlock only.
+template <class T, size_t S, class A = NullAllocator<T>, bool T_Align16 = false>
+class FixedSizeAllocatorWithCleanup : public AllocatorBase<T>
+{
+public:
+	CRYPTOPP_INHERIT_ALLOCATOR_TYPES
+
+	FixedSizeAllocatorWithCleanup() : m_allocated(false) {}
+
+	pointer allocate(size_type n)
+	{
+		assert(IsAlignedOn(m_array, 8));
+
+		if (n <= S && !m_allocated)
+		{
+			m_allocated = true;
+			return GetAlignedArray();
+		}
+		else
+			return m_fallbackAllocator.allocate(n);
+	}
+
+	pointer allocate(size_type n, const void *hint)
+	{
+		if (n <= S && !m_allocated)
+		{
+			m_allocated = true;
+			return GetAlignedArray();
+		}
+		else
+			return m_fallbackAllocator.allocate(n, hint);
+	}
+
+	void deallocate(void *p, size_type n)
+	{
+		if (p == GetAlignedArray())
+		{
+			assert(n <= S);
+			assert(m_allocated);
+			m_allocated = false;
+			SecureWipeArray((pointer)p, n);
+		}
+		else
+			m_fallbackAllocator.deallocate(p, n);
+	}
+
+	pointer reallocate(pointer p, size_type oldSize, size_type newSize, bool preserve)
+	{
+		if (p == GetAlignedArray() && newSize <= S)
+		{
+			assert(oldSize <= S);
+			if (oldSize > newSize)
+				SecureWipeArray(p+newSize, oldSize-newSize);
+			return p;
+		}
+
+		pointer newPointer = allocate(newSize, NULL);
+		if (preserve)
+			memcpy(newPointer, p, sizeof(T)*STDMIN(oldSize, newSize));
+		deallocate(p, oldSize);
+		return newPointer;
+	}
+
+	size_type max_size() const {return STDMAX(m_fallbackAllocator.max_size(), S);}
+
+private:
+#ifdef __BORLANDC__
+	T* GetAlignedArray() {return m_array;}
+	T m_array[S];
+#else
+	T* GetAlignedArray() {return (CRYPTOPP_BOOL_ALIGN16_ENABLED && T_Align16) ? (T*)(((byte *)m_array) + (0-(size_t)m_array)%16) : m_array;}
+	CRYPTOPP_ALIGN_DATA(8) T m_array[(CRYPTOPP_BOOL_ALIGN16_ENABLED && T_Align16) ? S+8/sizeof(T) : S];
+#endif
+	A m_fallbackAllocator;
+	bool m_allocated;
+};
+
+//! a block of memory allocated using A
+template <class T, class A = AllocatorWithCleanup<T> >
+class SecBlock
+{
+public:
+	typedef typename A::value_type value_type;
+	typedef typename A::pointer iterator;
+	typedef typename A::const_pointer const_iterator;
+	typedef typename A::size_type size_type;
+
+	explicit SecBlock(size_type size=0)
+		: m_size(size) {m_ptr = m_alloc.allocate(size, NULL);}
+	SecBlock(const SecBlock<T, A> &t)
+		: m_size(t.m_size) {m_ptr = m_alloc.allocate(m_size, NULL); memcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, m_size*sizeof(T));}
+	SecBlock(const T *t, size_type len)
+		: m_size(len)
+	{
+		m_ptr = m_alloc.allocate(len, NULL);
+		if (t == NULL)
+			memset_z(m_ptr, 0, len*sizeof(T));
+		else
+			memcpy(m_ptr, t, len*sizeof(T));
+	}
+
+	~SecBlock()
+		{m_alloc.deallocate(m_ptr, m_size);}
+
+#ifdef __BORLANDC__
+	operator T *() const
+		{return (T*)m_ptr;}
+#else
+	operator const void *() const
+		{return m_ptr;}
+	operator void *()
+		{return m_ptr;}
+
+	operator const T *() const
+		{return m_ptr;}
+	operator T *()
+		{return m_ptr;}
+#endif
+
+//	T *operator +(size_type offset)
+//		{return m_ptr+offset;}
+
+//	const T *operator +(size_type offset) const
+//		{return m_ptr+offset;}
+
+//	T& operator[](size_type index)
+//		{assert(index >= 0 && index < m_size); return m_ptr[index];}
+
+//	const T& operator[](size_type index) const
+//		{assert(index >= 0 && index < m_size); return m_ptr[index];}
+
+	iterator begin()
+		{return m_ptr;}
+	const_iterator begin() const
+		{return m_ptr;}
+	iterator end()
+		{return m_ptr+m_size;}
+	const_iterator end() const
+		{return m_ptr+m_size;}
+
+	typename A::pointer data() {return m_ptr;}
+	typename A::const_pointer data() const {return m_ptr;}
+
+	size_type size() const {return m_size;}
+	bool empty() const {return m_size == 0;}
+
+	byte * BytePtr() {return (byte *)m_ptr;}
+	const byte * BytePtr() const {return (const byte *)m_ptr;}
+	size_type SizeInBytes() const {return m_size*sizeof(T);}
+
+	//! set contents and size
+	void Assign(const T *t, size_type len)
+	{
+		New(len);
+		memcpy_s(m_ptr, m_size*sizeof(T), t, len*sizeof(T));
+	}
+
+	//! copy contents and size from another SecBlock
+	void Assign(const SecBlock<T, A> &t)
+	{
+		if (this != &t)
+		{
+			New(t.m_size);
+			memcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, m_size*sizeof(T));
+		}
+	}
+
+	SecBlock<T, A>& operator=(const SecBlock<T, A> &t)
+	{
+		Assign(t);
+		return *this;
+	}
+
+	// append to this object
+	SecBlock<T, A>& operator+=(const SecBlock<T, A> &t)
+	{
+		size_type oldSize = m_size;
+		Grow(m_size+t.m_size);
+		memcpy_s(m_ptr+oldSize, m_size*sizeof(T), t.m_ptr, t.m_size*sizeof(T));
+		return *this;
+	}
+
+	// append operator
+	SecBlock<T, A> operator+(const SecBlock<T, A> &t)
+	{
+		SecBlock<T, A> result(m_size+t.m_size);
+		memcpy_s(result.m_ptr, result.m_size*sizeof(T), m_ptr, m_size*sizeof(T));
+		memcpy_s(result.m_ptr+m_size, t.m_size*sizeof(T), t.m_ptr, t.m_size*sizeof(T));
+		return result;
+	}
+
+	bool operator==(const SecBlock<T, A> &t) const
+	{
+		return m_size == t.m_size && VerifyBufsEqual(m_ptr, t.m_ptr, m_size*sizeof(T));
+	}
+
+	bool operator!=(const SecBlock<T, A> &t) const
+	{
+		return !operator==(t);
+	}
+
+	//! change size, without preserving contents
+	void New(size_type newSize)
+	{
+		m_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);
+		m_size = newSize;
+	}
+
+	//! change size and set contents to 0
+	void CleanNew(size_type newSize)
+	{
+		New(newSize);
+		memset_z(m_ptr, 0, m_size*sizeof(T));
+	}
+
+	//! change size only if newSize > current size. contents are preserved
+	void Grow(size_type newSize)
+	{
+		if (newSize > m_size)
+		{
+			m_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, true);
+			m_size = newSize;
+		}
+	}
+
+	//! change size only if newSize > current size. contents are preserved and additional area is set to 0
+	void CleanGrow(size_type newSize)
+	{
+		if (newSize > m_size)
+		{
+			m_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, true);
+			memset(m_ptr+m_size, 0, (newSize-m_size)*sizeof(T));
+			m_size = newSize;
+		}
+	}
+
+	//! change size and preserve contents
+	void resize(size_type newSize)
+	{
+		m_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, true);
+		m_size = newSize;
+	}
+
+	//! swap contents and size with another SecBlock
+	void swap(SecBlock<T, A> &b)
+	{
+		std::swap(m_alloc, b.m_alloc);
+		std::swap(m_size, b.m_size);
+		std::swap(m_ptr, b.m_ptr);
+	}
+
+//private:
+	A m_alloc;
+	size_type m_size;
+	T *m_ptr;
+};
+
+typedef SecBlock<byte> SecByteBlock;
+typedef SecBlock<byte, AllocatorWithCleanup<byte, true> > AlignedSecByteBlock;
+typedef SecBlock<word> SecWordBlock;
+
+//! a SecBlock with fixed size, allocated statically
+template <class T, unsigned int S, class A = FixedSizeAllocatorWithCleanup<T, S> >
+class FixedSizeSecBlock : public SecBlock<T, A>
+{
+public:
+	explicit FixedSizeSecBlock() : SecBlock<T, A>(S) {}
+};
+
+template <class T, unsigned int S, bool T_Align16 = true>
+class FixedSizeAlignedSecBlock : public FixedSizeSecBlock<T, S, FixedSizeAllocatorWithCleanup<T, S, NullAllocator<T>, T_Align16> >
+{
+};
+
+//! a SecBlock that preallocates size S statically, and uses the heap when this size is exceeded
+template <class T, unsigned int S, class A = FixedSizeAllocatorWithCleanup<T, S, AllocatorWithCleanup<T> > >
+class SecBlockWithHint : public SecBlock<T, A>
+{
+public:
+	explicit SecBlockWithHint(size_t size) : SecBlock<T, A>(size) {}
+};
+
+template<class T, bool A, class U, bool B>
+inline bool operator==(const CryptoPP::AllocatorWithCleanup<T, A>&, const CryptoPP::AllocatorWithCleanup<U, B>&) {return (true);}
+template<class T, bool A, class U, bool B>
+inline bool operator!=(const CryptoPP::AllocatorWithCleanup<T, A>&, const CryptoPP::AllocatorWithCleanup<U, B>&) {return (false);}
+
+NAMESPACE_END
+
+NAMESPACE_BEGIN(std)
+template <class T, class A>
+inline void swap(CryptoPP::SecBlock<T, A> &a, CryptoPP::SecBlock<T, A> &b)
+{
+	a.swap(b);
+}
+
+#if defined(_STLP_DONT_SUPPORT_REBIND_MEMBER_TEMPLATE) || (defined(_STLPORT_VERSION) && !defined(_STLP_MEMBER_TEMPLATE_CLASSES))
+// working for STLport 5.1.3 and MSVC 6 SP5
+template <class _Tp1, class _Tp2>
+inline CryptoPP::AllocatorWithCleanup<_Tp2>&
+__stl_alloc_rebind(CryptoPP::AllocatorWithCleanup<_Tp1>& __a, const _Tp2*)
+{
+	return (CryptoPP::AllocatorWithCleanup<_Tp2>&)(__a);
+}
+#endif
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/seckey.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/seckey.h
index 5ce3f868..35046a61 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/seckey.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/seckey.h
@@ -1,237 +1,221 @@
-// seckey.h - written and placed in the public domain by Wei Dai
-
-// This file contains helper classes/functions for implementing secret key algorithms.
-
-#ifndef CRYPTOPP_SECKEY_H
-#define CRYPTOPP_SECKEY_H
-
-#include "cryptlib.h"
-#include "misc.h"
-#include "simple.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-inline CipherDir ReverseCipherDir(CipherDir dir)
-{
-	return (dir == ENCRYPTION) ? DECRYPTION : ENCRYPTION;
-}
-
-//! .
-template <unsigned int N>
-class FixedBlockSize
-{
-public:
-	enum {BLOCKSIZE = N};
-};
-
-// ************** rounds ***************
-
-//! .
-template <unsigned int R>
-class FixedRounds
-{
-public:
-	enum {ROUNDS = R};
-
-protected:
-	template <class T>
-	static inline void CheckedSetKey(T *obj, CipherDir dir, const byte *key, unsigned int length, const NameValuePairs &param)
-	{
-		obj->ThrowIfInvalidKeyLength(length);
-		int rounds = param.GetIntValueWithDefault("Rounds", ROUNDS);
-		if (rounds != ROUNDS)
-			throw InvalidRounds(obj->StaticAlgorithmName(), rounds);
-		obj->UncheckedSetKey(dir, key, length);
-	}
-};
-
-//! .
-template <unsigned int D, unsigned int N=1, unsigned int M=INT_MAX>		// use INT_MAX here because enums are treated as signed ints
-class VariableRounds
-{
-public:
-	enum {DEFAULT_ROUNDS = D, MIN_ROUNDS = N, MAX_ROUNDS = M};
-	static unsigned int StaticGetDefaultRounds(unsigned int keylength) {return DEFAULT_ROUNDS;}
-
-protected:
-	static inline void AssertValidRounds(unsigned int rounds)
-	{
-		assert(rounds >= MIN_ROUNDS && rounds <= MAX_ROUNDS);
-	}
-
-	template <class T>
-	static inline void CheckedSetKey(T *obj, CipherDir dir, const byte *key, unsigned int length, const NameValuePairs &param)
-	{
-		obj->ThrowIfInvalidKeyLength(length);
-		int rounds = param.GetIntValueWithDefault("Rounds", obj->StaticGetDefaultRounds(length));
-		if (rounds < (unsigned int)MIN_ROUNDS || rounds > (unsigned int)MAX_ROUNDS)
-			throw InvalidRounds(obj->AlgorithmName(), rounds);
-		obj->UncheckedSetKey(dir, key, length, rounds);
-	}
-};
-
-// ************** key length ***************
-
-//! .
-template <unsigned int N, unsigned int IV_REQ = SimpleKeyingInterface::NOT_RESYNCHRONIZABLE>
-class FixedKeyLength
-{
-public:
-	enum {KEYLENGTH=N, MIN_KEYLENGTH=N, MAX_KEYLENGTH=N, DEFAULT_KEYLENGTH=N};
-	enum {IV_REQUIREMENT = IV_REQ};
-	static unsigned int StaticGetValidKeyLength(unsigned int) {return KEYLENGTH;}
-};
-
-/// support query of variable key length, template parameters are default, min, max, multiple (default multiple 1)
-template <unsigned int D, unsigned int N, unsigned int M, unsigned int Q = 1, unsigned int IV_REQ = SimpleKeyingInterface::NOT_RESYNCHRONIZABLE>
-class VariableKeyLength
-{
-	// make these private to avoid Doxygen documenting them in all derived classes
-	CRYPTOPP_COMPILE_ASSERT(Q > 0);
-	CRYPTOPP_COMPILE_ASSERT(N % Q == 0);
-	CRYPTOPP_COMPILE_ASSERT(M % Q == 0);
-	CRYPTOPP_COMPILE_ASSERT(N < M);
-	CRYPTOPP_COMPILE_ASSERT(D >= N && M >= D);
-
-public:
-	enum {MIN_KEYLENGTH=N, MAX_KEYLENGTH=M, DEFAULT_KEYLENGTH=D, KEYLENGTH_MULTIPLE=Q};
-	enum {IV_REQUIREMENT = IV_REQ};
-	static unsigned int StaticGetValidKeyLength(unsigned int n)
-	{
-		if (n < (unsigned int)MIN_KEYLENGTH)
-			return MIN_KEYLENGTH;
-		else if (n > (unsigned int)MAX_KEYLENGTH)
-			return (unsigned int)MAX_KEYLENGTH;
-		else
-		{
-			n += KEYLENGTH_MULTIPLE-1;
-			return n - n%KEYLENGTH_MULTIPLE;
-		}
-	}
-};
-
-/// support query of key length that's the same as another class
-template <class T>
-class SameKeyLengthAs
-{
-public:
-	enum {MIN_KEYLENGTH=T::MIN_KEYLENGTH, MAX_KEYLENGTH=T::MAX_KEYLENGTH, DEFAULT_KEYLENGTH=T::DEFAULT_KEYLENGTH};
-	enum {IV_REQUIREMENT = T::IV_REQUIREMENT};
-	static unsigned int StaticGetValidKeyLength(unsigned int keylength)
-		{return T::StaticGetValidKeyLength(keylength);}
-};
-
-// ************** implementation helper for SimpledKeyed ***************
-
-template <class T>
-static inline void CheckedSetKey(T *obj, Empty empty, const byte *key, unsigned int length, const NameValuePairs &param)
-{
-	obj->ThrowIfInvalidKeyLength(length);
-	obj->UncheckedSetKey(key, length);
-}
-
-template <class T>
-static inline void CheckedSetKey(T *obj, CipherDir dir, const byte *key, unsigned int length, const NameValuePairs &param)
-{
-	obj->ThrowIfInvalidKeyLength(length);
-	obj->UncheckedSetKey(dir, key, length);
-}
-
-//! .
-template <class BASE, class INFO = BASE>
-class SimpleKeyingInterfaceImpl : public BASE
-{
-public:
-	unsigned int MinKeyLength() const {return INFO::MIN_KEYLENGTH;}
-	unsigned int MaxKeyLength() const {return (unsigned int)INFO::MAX_KEYLENGTH;}
-	unsigned int DefaultKeyLength() const {return INFO::DEFAULT_KEYLENGTH;}
-	unsigned int GetValidKeyLength(unsigned int n) const {return INFO::StaticGetValidKeyLength(n);}
-	typename BASE::IV_Requirement IVRequirement() const {return (typename BASE::IV_Requirement)INFO::IV_REQUIREMENT;}
-
-protected:
-	void AssertValidKeyLength(unsigned int length) {assert(GetValidKeyLength(length) == length);}
-};
-
-template <class INFO, class INTERFACE = BlockCipher>
-class BlockCipherBaseTemplate : public AlgorithmImpl<SimpleKeyingInterfaceImpl<TwoBases<INFO, INTERFACE> > >
-{
-public:
-	unsigned int BlockSize() const {return BLOCKSIZE;}
-};
-
-//! .
-template <CipherDir DIR, class BASE>
-class BlockCipherTemplate : public BASE
-{
-public:
- 	BlockCipherTemplate() {}
-	BlockCipherTemplate(const byte *key)
-		{SetKey(key, DEFAULT_KEYLENGTH);}
-	BlockCipherTemplate(const byte *key, unsigned int length)
-		{SetKey(key, length);}
-	BlockCipherTemplate(const byte *key, unsigned int length, unsigned int rounds)
-		{SetKeyWithRounds(key, length, rounds);}
-
-	bool IsForwardTransformation() const {return DIR == ENCRYPTION;}
-
-	void SetKey(const byte *key, unsigned int length, const NameValuePairs &param = g_nullNameValuePairs)
-	{
-		CheckedSetKey(this, DIR, key, length, param);
-	}
-
-	Clonable * Clone() const {return new BlockCipherTemplate<DIR, BASE>(*this);}
-};
-
-//! .
-template <class BASE>
-class MessageAuthenticationCodeTemplate : public 
-#ifdef CRYPTOPP_DOXYGEN_PROCESSING
-	MessageAuthenticationCode
-#else
-	SimpleKeyingInterfaceImpl<BASE>
-#endif
-{
-public:
- 	MessageAuthenticationCodeTemplate() {}
-	MessageAuthenticationCodeTemplate(const byte *key)
-		{SetKey(key, DEFAULT_KEYLENGTH);}
-	MessageAuthenticationCodeTemplate(const byte *key, unsigned int length)
-		{SetKey(key, length);}
-
-	std::string AlgorithmName() const {return StaticAlgorithmName();}
-
-	void SetKey(const byte *key, unsigned int length, const NameValuePairs &param = g_nullNameValuePairs)
-	{
-		CheckedSetKey(this, Empty(), key, length, param);
-	}
-
-	Clonable * Clone() const {return new MessageAuthenticationCodeTemplate<BASE>(*this);}
-};
-
-// ************** documentation ***************
-
-//! These objects usually should not be used directly. See CipherModeDocumentation instead.
-/*! Each class derived from this one defines two types, Encryption and Decryption, 
-	both of which implement the BlockCipher interface. */
-struct BlockCipherDocumentation
-{
-	//! implements the BlockCipher interface
-	typedef BlockCipher Encryption;
-	//! implements the BlockCipher interface
-	typedef BlockCipher Decryption;
-};
-
-/*! \brief Each class derived from this one defines two types, Encryption and Decryption, 
-	both of which implement the SymmetricCipher interface. See CipherModeDocumentation
-	for information about using block ciphers. */
-struct SymmetricCipherDocumentation
-{
-	//! implements the SymmetricCipher interface
-	typedef SymmetricCipher Encryption;
-	//! implements the SymmetricCipher interface
-	typedef SymmetricCipher Decryption;
-};
-
-NAMESPACE_END
-
-#endif
+// seckey.h - written and placed in the public domain by Wei Dai
+
+// This file contains helper classes/functions for implementing secret key algorithms.
+
+#ifndef CRYPTOPP_SECKEY_H
+#define CRYPTOPP_SECKEY_H
+
+#include "cryptlib.h"
+#include "misc.h"
+#include "simple.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+inline CipherDir ReverseCipherDir(CipherDir dir)
+{
+	return (dir == ENCRYPTION) ? DECRYPTION : ENCRYPTION;
+}
+
+//! to be inherited by block ciphers with fixed block size
+template <unsigned int N>
+class FixedBlockSize
+{
+public:
+	CRYPTOPP_CONSTANT(BLOCKSIZE = N)
+};
+
+// ************** rounds ***************
+
+//! to be inherited by ciphers with fixed number of rounds
+template <unsigned int R>
+class FixedRounds
+{
+public:
+	CRYPTOPP_CONSTANT(ROUNDS = R)
+};
+
+//! to be inherited by ciphers with variable number of rounds
+template <unsigned int D, unsigned int N=1, unsigned int M=INT_MAX>		// use INT_MAX here because enums are treated as signed ints
+class VariableRounds
+{
+public:
+	CRYPTOPP_CONSTANT(DEFAULT_ROUNDS = D)
+	CRYPTOPP_CONSTANT(MIN_ROUNDS = N)
+	CRYPTOPP_CONSTANT(MAX_ROUNDS = M)
+	static unsigned int StaticGetDefaultRounds(size_t keylength) {return DEFAULT_ROUNDS;}
+
+protected:
+	inline void ThrowIfInvalidRounds(int rounds, const Algorithm *alg)
+	{
+		if (rounds < MIN_ROUNDS || rounds > MAX_ROUNDS)
+			throw InvalidRounds(alg->AlgorithmName(), rounds);
+	}
+
+	inline unsigned int GetRoundsAndThrowIfInvalid(const NameValuePairs &param, const Algorithm *alg)
+	{
+		int rounds = param.GetIntValueWithDefault("Rounds", DEFAULT_ROUNDS);
+		ThrowIfInvalidRounds(rounds, alg);
+		return (unsigned int)rounds;
+	}
+};
+
+// ************** key length ***************
+
+//! to be inherited by keyed algorithms with fixed key length
+template <unsigned int N, unsigned int IV_REQ = SimpleKeyingInterface::NOT_RESYNCHRONIZABLE, unsigned int IV_L = 0>
+class FixedKeyLength
+{
+public:
+	CRYPTOPP_CONSTANT(KEYLENGTH=N)
+	CRYPTOPP_CONSTANT(MIN_KEYLENGTH=N)
+	CRYPTOPP_CONSTANT(MAX_KEYLENGTH=N)
+	CRYPTOPP_CONSTANT(DEFAULT_KEYLENGTH=N)
+	CRYPTOPP_CONSTANT(IV_REQUIREMENT = IV_REQ)
+	CRYPTOPP_CONSTANT(IV_LENGTH = IV_L)
+	static size_t CRYPTOPP_API StaticGetValidKeyLength(size_t) {return KEYLENGTH;}
+};
+
+/// support query of variable key length, template parameters are default, min, max, multiple (default multiple 1)
+template <unsigned int D, unsigned int N, unsigned int M, unsigned int Q = 1, unsigned int IV_REQ = SimpleKeyingInterface::NOT_RESYNCHRONIZABLE, unsigned int IV_L = 0>
+class VariableKeyLength
+{
+	// make these private to avoid Doxygen documenting them in all derived classes
+	CRYPTOPP_COMPILE_ASSERT(Q > 0);
+	CRYPTOPP_COMPILE_ASSERT(N % Q == 0);
+	CRYPTOPP_COMPILE_ASSERT(M % Q == 0);
+	CRYPTOPP_COMPILE_ASSERT(N < M);
+	CRYPTOPP_COMPILE_ASSERT(D >= N);
+	CRYPTOPP_COMPILE_ASSERT(M >= D);
+
+public:
+	CRYPTOPP_CONSTANT(MIN_KEYLENGTH=N)
+	CRYPTOPP_CONSTANT(MAX_KEYLENGTH=M)
+	CRYPTOPP_CONSTANT(DEFAULT_KEYLENGTH=D)
+	CRYPTOPP_CONSTANT(KEYLENGTH_MULTIPLE=Q)
+	CRYPTOPP_CONSTANT(IV_REQUIREMENT=IV_REQ)
+	CRYPTOPP_CONSTANT(IV_LENGTH=IV_L)
+
+	static size_t CRYPTOPP_API StaticGetValidKeyLength(size_t n)
+	{
+		if (n < (size_t)MIN_KEYLENGTH)
+			return MIN_KEYLENGTH;
+		else if (n > (size_t)MAX_KEYLENGTH)
+			return (size_t)MAX_KEYLENGTH;
+		else
+		{
+			n += KEYLENGTH_MULTIPLE-1;
+			return n - n%KEYLENGTH_MULTIPLE;
+		}
+	}
+};
+
+/// support query of key length that's the same as another class
+template <class T, unsigned int IV_REQ = SimpleKeyingInterface::NOT_RESYNCHRONIZABLE, unsigned int IV_L = 0>
+class SameKeyLengthAs
+{
+public:
+	CRYPTOPP_CONSTANT(MIN_KEYLENGTH=T::MIN_KEYLENGTH)
+	CRYPTOPP_CONSTANT(MAX_KEYLENGTH=T::MAX_KEYLENGTH)
+	CRYPTOPP_CONSTANT(DEFAULT_KEYLENGTH=T::DEFAULT_KEYLENGTH)
+	CRYPTOPP_CONSTANT(IV_REQUIREMENT=IV_REQ)
+	CRYPTOPP_CONSTANT(IV_LENGTH=IV_L)
+
+	static size_t CRYPTOPP_API StaticGetValidKeyLength(size_t keylength)
+		{return T::StaticGetValidKeyLength(keylength);}
+};
+
+// ************** implementation helper for SimpleKeyed ***************
+
+//! _
+template <class BASE, class INFO = BASE>
+class CRYPTOPP_NO_VTABLE SimpleKeyingInterfaceImpl : public BASE
+{
+public:
+	size_t MinKeyLength() const {return INFO::MIN_KEYLENGTH;}
+	size_t MaxKeyLength() const {return (size_t)INFO::MAX_KEYLENGTH;}
+	size_t DefaultKeyLength() const {return INFO::DEFAULT_KEYLENGTH;}
+	size_t GetValidKeyLength(size_t n) const {return INFO::StaticGetValidKeyLength(n);}
+	SimpleKeyingInterface::IV_Requirement IVRequirement() const {return (SimpleKeyingInterface::IV_Requirement)INFO::IV_REQUIREMENT;}
+	unsigned int IVSize() const {return INFO::IV_LENGTH;}
+};
+
+template <class INFO, class BASE = BlockCipher>
+class CRYPTOPP_NO_VTABLE BlockCipherImpl : public AlgorithmImpl<SimpleKeyingInterfaceImpl<TwoBases<BASE, INFO> > >
+{
+public:
+	unsigned int BlockSize() const {return this->BLOCKSIZE;}
+};
+
+//! _
+template <CipherDir DIR, class BASE>
+class BlockCipherFinal : public ClonableImpl<BlockCipherFinal<DIR, BASE>, BASE>
+{
+public:
+ 	BlockCipherFinal() {}
+	BlockCipherFinal(const byte *key)
+		{this->SetKey(key, this->DEFAULT_KEYLENGTH);}
+	BlockCipherFinal(const byte *key, size_t length)
+		{this->SetKey(key, length);}
+	BlockCipherFinal(const byte *key, size_t length, unsigned int rounds)
+		{this->SetKeyWithRounds(key, length, rounds);}
+
+	bool IsForwardTransformation() const {return DIR == ENCRYPTION;}
+};
+
+//! _
+template <class BASE, class INFO = BASE>
+class MessageAuthenticationCodeImpl : public AlgorithmImpl<SimpleKeyingInterfaceImpl<BASE, INFO>, INFO>
+{
+};
+
+//! _
+template <class BASE>
+class MessageAuthenticationCodeFinal : public ClonableImpl<MessageAuthenticationCodeFinal<BASE>, MessageAuthenticationCodeImpl<BASE> >
+{
+public:
+ 	MessageAuthenticationCodeFinal() {}
+	MessageAuthenticationCodeFinal(const byte *key)
+		{this->SetKey(key, this->DEFAULT_KEYLENGTH);}
+	MessageAuthenticationCodeFinal(const byte *key, size_t length)
+		{this->SetKey(key, length);}
+};
+
+// ************** documentation ***************
+
+//! These objects usually should not be used directly. See CipherModeDocumentation instead.
+/*! Each class derived from this one defines two types, Encryption and Decryption, 
+	both of which implement the BlockCipher interface. */
+struct BlockCipherDocumentation
+{
+	//! implements the BlockCipher interface
+	typedef BlockCipher Encryption;
+	//! implements the BlockCipher interface
+	typedef BlockCipher Decryption;
+};
+
+/*! \brief Each class derived from this one defines two types, Encryption and Decryption, 
+	both of which implement the SymmetricCipher interface. Two types of classes derive
+	from this class: stream ciphers and block cipher modes. Stream ciphers can be used
+	alone, cipher mode classes need to be used with a block cipher. See CipherModeDocumentation
+	for more for information about using cipher modes and block ciphers. */
+struct SymmetricCipherDocumentation
+{
+	//! implements the SymmetricCipher interface
+	typedef SymmetricCipher Encryption;
+	//! implements the SymmetricCipher interface
+	typedef SymmetricCipher Decryption;
+};
+
+/*! \brief Each class derived from this one defines two types, Encryption and Decryption, 
+	both of which implement the AuthenticatedSymmetricCipher interface. */
+struct AuthenticatedSymmetricCipherDocumentation
+{
+	//! implements the AuthenticatedSymmetricCipher interface
+	typedef AuthenticatedSymmetricCipher Encryption;
+	//! implements the AuthenticatedSymmetricCipher interface
+	typedef AuthenticatedSymmetricCipher Decryption;
+};
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/sha.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/sha.h
index 7674c625..679081e8 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/sha.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/sha.h
@@ -1,72 +1,63 @@
-#ifndef CRYPTOPP_SHA_H
-#define CRYPTOPP_SHA_H
-
-#include "iterhash.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-/// <a href="http://www.weidai.com/scan-mirror/md.html#SHA-1">SHA-1</a>
-class SHA : public IteratedHashWithStaticTransform<word32, BigEndian, 64, SHA>
-{
-public:
-	enum {DIGESTSIZE = 20};
-	SHA() : IteratedHashWithStaticTransform<word32, BigEndian, 64, SHA>(DIGESTSIZE) {Init();}
-	static void Transform(word32 *digest, const word32 *data);
-	static const char *StaticAlgorithmName() {return "SHA-1";}
-
-protected:
-	void Init();
-};
-
-typedef SHA SHA1;
-
-//! implements the SHA-256 standard
-class SHA256 : public IteratedHashWithStaticTransform<word32, BigEndian, 64, SHA256>
-{
-public:
-	enum {DIGESTSIZE = 32};
-	SHA256() : IteratedHashWithStaticTransform<word32, BigEndian, 64, SHA256>(DIGESTSIZE) {Init();}
-	static void Transform(word32 *digest, const word32 *data);
-	static const char *StaticAlgorithmName() {return "SHA-256";}
-
-protected:
-	void Init();
-
-	static const word32 K[64];
-};
-
-#ifdef WORD64_AVAILABLE
-
-//! implements the SHA-512 standard
-class SHA512 : public IteratedHashWithStaticTransform<word64, BigEndian, 128, SHA512>
-{
-public:
-	enum {DIGESTSIZE = 64};
-	SHA512() : IteratedHashWithStaticTransform<word64, BigEndian, 128, SHA512>(DIGESTSIZE) {Init();}
-	static void Transform(word64 *digest, const word64 *data);
-	static const char *StaticAlgorithmName() {return "SHA-512";}
-
-protected:
-	void Init();
-
-	static const word64 K[80];
-};
-
-//! implements the SHA-384 standard
-class SHA384 : public IteratedHashWithStaticTransform<word64, BigEndian, 128, SHA512>
-{
-public:
-	enum {DIGESTSIZE = 48};
-	SHA384() : IteratedHashWithStaticTransform<word64, BigEndian, 128, SHA512>(64) {Init();}
-	unsigned int DigestSize() const {return DIGESTSIZE;};
-	static const char *StaticAlgorithmName() {return "SHA-384";}
-
-protected:
-	void Init();
-};
-
-#endif
-
-NAMESPACE_END
-
-#endif
+#ifndef CRYPTOPP_SHA_H
+#define CRYPTOPP_SHA_H
+
+#include "iterhash.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+/// <a href="http://www.weidai.com/scan-mirror/md.html#SHA-1">SHA-1</a>
+class CRYPTOPP_DLL SHA1 : public IteratedHashWithStaticTransform<word32, BigEndian, 64, 20, SHA1>
+{
+public:
+	static void CRYPTOPP_API InitState(HashWordType *state);
+	static void CRYPTOPP_API Transform(word32 *digest, const word32 *data);
+	static const char * CRYPTOPP_API StaticAlgorithmName() {return "SHA-1";}
+};
+
+typedef SHA1 SHA;	// for backwards compatibility
+
+//! implements the SHA-256 standard
+class CRYPTOPP_DLL SHA256 : public IteratedHashWithStaticTransform<word32, BigEndian, 64, 32, SHA256, 32, true>
+{
+public:
+#if defined(CRYPTOPP_X86_ASM_AVAILABLE) || defined(CRYPTOPP_X64_MASM_AVAILABLE)
+	size_t HashMultipleBlocks(const word32 *input, size_t length);
+#endif
+	static void CRYPTOPP_API InitState(HashWordType *state);
+	static void CRYPTOPP_API Transform(word32 *digest, const word32 *data);
+	static const char * CRYPTOPP_API StaticAlgorithmName() {return "SHA-256";}
+};
+
+//! implements the SHA-224 standard
+class CRYPTOPP_DLL SHA224 : public IteratedHashWithStaticTransform<word32, BigEndian, 64, 32, SHA224, 28, true>
+{
+public:
+#if defined(CRYPTOPP_X86_ASM_AVAILABLE) || defined(CRYPTOPP_X64_MASM_AVAILABLE)
+	size_t HashMultipleBlocks(const word32 *input, size_t length);
+#endif
+	static void CRYPTOPP_API InitState(HashWordType *state);
+	static void CRYPTOPP_API Transform(word32 *digest, const word32 *data) {SHA256::Transform(digest, data);}
+	static const char * CRYPTOPP_API StaticAlgorithmName() {return "SHA-224";}
+};
+
+//! implements the SHA-512 standard
+class CRYPTOPP_DLL SHA512 : public IteratedHashWithStaticTransform<word64, BigEndian, 128, 64, SHA512, 64, CRYPTOPP_BOOL_X86>
+{
+public:
+	static void CRYPTOPP_API InitState(HashWordType *state);
+	static void CRYPTOPP_API Transform(word64 *digest, const word64 *data);
+	static const char * CRYPTOPP_API StaticAlgorithmName() {return "SHA-512";}
+};
+
+//! implements the SHA-384 standard
+class CRYPTOPP_DLL SHA384 : public IteratedHashWithStaticTransform<word64, BigEndian, 128, 64, SHA384, 48, CRYPTOPP_BOOL_X86>
+{
+public:
+	static void CRYPTOPP_API InitState(HashWordType *state);
+	static void CRYPTOPP_API Transform(word64 *digest, const word64 *data) {SHA512::Transform(digest, data);}
+	static const char * CRYPTOPP_API StaticAlgorithmName() {return "SHA-384";}
+};
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/simple.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/simple.h
index 861e5b08..35fd65ae 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/simple.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/simple.h
@@ -1,230 +1,209 @@
-// simple.h - written and placed in the public domain by Wei Dai
-/*! \file
- 	Simple non-interface classes derived from classes in cryptlib.h.
-*/
-
-#ifndef CRYPTOPP_SIMPLE_H
-#define CRYPTOPP_SIMPLE_H
-
-#include "cryptlib.h"
-#include "misc.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-template <class BASE, class ALGORITHM_INFO = BASE>
-class AlgorithmImpl : public BASE
-{
-public:
-	std::string AlgorithmName() const {return ALGORITHM_INFO::StaticAlgorithmName();}
-};
-
-//! .
-class InvalidKeyLength : public InvalidArgument
-{
-public:
-	explicit InvalidKeyLength(const std::string &algorithm, unsigned int length) : InvalidArgument(algorithm + ": " + IntToString(length) + " is not a valid key length") {}
-};
-
-//! .
-class InvalidRounds : public InvalidArgument
-{
-public:
-	explicit InvalidRounds(const std::string &algorithm, unsigned int rounds) : InvalidArgument(algorithm + ": " + IntToString(rounds) + " is not a valid number of rounds") {}
-};
-
-class HashTransformationWithDefaultTruncation : public HashTransformation
-{
-public:
-	virtual void Final(byte *digest) =0;
-	void TruncatedFinal(byte *digest, unsigned int digestSize);
-};
-
-//! .
-// TODO: look into this virtual inheritance
-class ASN1CryptoMaterial : virtual public ASN1Object, virtual public CryptoMaterial
-{
-public:
-	void Save(BufferedTransformation &bt) const
-		{BEREncode(bt);}
-	void Load(BufferedTransformation &bt)
-		{BERDecode(bt);}
-};
-
-// *****************************
-
-template <class T>
-class Bufferless : public T
-{
-public:
-	Bufferless() {}
-	Bufferless(BufferedTransformation *q) : T(q) {}
-	bool IsolatedFlush(bool hardFlush, bool blocking) {return false;}
-};
-
-template <class T>
-class Unflushable : public T
-{
-public:
-	Unflushable() {}
-	Unflushable(BufferedTransformation *q) : T(q) {}
-	bool Flush(bool completeFlush, int propagation=-1, bool blocking=true)
-		{return ChannelFlush(NULL_CHANNEL, completeFlush, propagation);}
-	bool IsolatedFlush(bool hardFlush, bool blocking)
-		{assert(false); return false;}
-	bool ChannelFlush(const std::string &channel, bool hardFlush, int propagation=-1, bool blocking=true)
-	{
-		if (hardFlush && !InputBufferIsEmpty())
-			throw CannotFlush("Unflushable<T>: this object has buffered input that cannot be flushed");
-		else 
-		{
-			BufferedTransformation *attached = AttachedTransformation();
-			return attached && propagation ? attached->ChannelFlush(channel, hardFlush, propagation-1, blocking) : false;
-		}
-	}
-
-protected:
-	virtual bool InputBufferIsEmpty() const {return false;}
-};
-
-template <class T>
-class InputRejecting : public T
-{
-public:
-	InputRejecting() {}
-	InputRejecting(BufferedTransformation *q) : T(q) {}
-
-protected:
-	struct InputRejected : public NotImplemented
-		{InputRejected() : NotImplemented("BufferedTransformation: this object doesn't allow input") {}};
-
-	// shouldn't be calling these functions on this class
-	unsigned int Put2(const byte *begin, unsigned int length, int messageEnd, bool blocking)
-		{throw InputRejected();}
-	bool IsolatedFlush(bool, bool) {return false;}
-	bool IsolatedMessageSeriesEnd(bool) {throw InputRejected();}
-
-	unsigned int ChannelPut2(const std::string &channel, const byte *begin, unsigned int length, int messageEnd, bool blocking)
-		{throw InputRejected();}
-	bool ChannelMessageSeriesEnd(const std::string &, int, bool) {throw InputRejected();}
-};
-
-template <class T>
-class CustomSignalPropagation : public T
-{
-public:
-	CustomSignalPropagation() {}
-	CustomSignalPropagation(BufferedTransformation *q) : T(q) {}
-
-	virtual void Initialize(const NameValuePairs &parameters=g_nullNameValuePairs, int propagation=-1) =0;
-	virtual bool Flush(bool hardFlush, int propagation=-1, bool blocking=true) =0;
-
-private:
-	void IsolatedInitialize(const NameValuePairs &parameters) {assert(false);}
-	bool IsolatedFlush(bool hardFlush, bool blocking) {assert(false); return false;}
-};
-
-template <class T>
-class Multichannel : public CustomSignalPropagation<T>
-{
-public:
-	Multichannel() {}
-	Multichannel(BufferedTransformation *q) : CustomSignalPropagation<T>(q) {}
-
-	void Initialize(const NameValuePairs &parameters, int propagation)
-		{ChannelInitialize(NULL_CHANNEL, parameters, propagation);}
-	bool Flush(bool hardFlush, int propagation=-1, bool blocking=true)
-		{return ChannelFlush(NULL_CHANNEL, hardFlush, propagation, blocking);}
-	bool MessageSeriesEnd(int propagation=-1, bool blocking=true)
-		{return ChannelMessageSeriesEnd(NULL_CHANNEL, propagation, blocking);}
-	byte * CreatePutSpace(unsigned int &size)
-		{return ChannelCreatePutSpace(NULL_CHANNEL, size);}
-	unsigned int Put2(const byte *begin, unsigned int length, int messageEnd, bool blocking)
-		{return ChannelPut2(NULL_CHANNEL, begin, length, messageEnd, blocking);}
-	unsigned int PutModifiable2(byte *inString, unsigned int length, int messageEnd, bool blocking)
-		{return ChannelPutModifiable2(NULL_CHANNEL, inString, length, messageEnd, blocking);}
-
-//	void ChannelMessageSeriesEnd(const std::string &channel, int propagation=-1)
-//		{PropagateMessageSeriesEnd(propagation, channel);}
-	byte * ChannelCreatePutSpace(const std::string &channel, unsigned int &size)
-		{size = 0; return NULL;}
-	bool ChannelPutModifiable(const std::string &channel, byte *inString, unsigned int length)
-		{ChannelPut(channel, inString, length); return false;}
-
-	virtual unsigned int ChannelPut2(const std::string &channel, const byte *begin, unsigned int length, int messageEnd, bool blocking) =0;
-	unsigned int ChannelPutModifiable2(const std::string &channel, byte *begin, unsigned int length, int messageEnd, bool blocking)
-		{return ChannelPut2(channel, begin, length, messageEnd, blocking);}
-
-	virtual void ChannelInitialize(const std::string &channel, const NameValuePairs &parameters=g_nullNameValuePairs, int propagation=-1) =0;
-	virtual bool ChannelFlush(const std::string &channel, bool hardFlush, int propagation=-1, bool blocking=true) =0;
-};
-
-template <class T>
-class AutoSignaling : public T
-{
-public:
-	AutoSignaling(int propagation=-1) : m_autoSignalPropagation(propagation) {}
-	AutoSignaling(BufferedTransformation *q, int propagation=-1) : T(q), m_autoSignalPropagation(propagation) {}
-
-	void SetAutoSignalPropagation(int propagation)
-		{m_autoSignalPropagation = propagation;}
-	int GetAutoSignalPropagation() const
-		{return m_autoSignalPropagation;}
-
-private:
-	int m_autoSignalPropagation;
-};
-
-//! A BufferedTransformation that only contains pre-existing data as "output"
-class Store : public AutoSignaling<InputRejecting<BufferedTransformation> >
-{
-public:
-	Store() : m_messageEnd(false) {}
-
-	void IsolatedInitialize(const NameValuePairs &parameters)
-	{
-		m_messageEnd = false;
-		StoreInitialize(parameters);
-	}
-
-	unsigned int NumberOfMessages() const {return m_messageEnd ? 0 : 1;}
-	bool GetNextMessage();
-	unsigned int CopyMessagesTo(BufferedTransformation &target, unsigned int count=UINT_MAX, const std::string &channel=NULL_CHANNEL) const;
-
-protected:
-	virtual void StoreInitialize(const NameValuePairs &parameters) =0;
-
-	bool m_messageEnd;
-};
-
-//! A BufferedTransformation that doesn't produce any retrievable output
-class Sink : public BufferedTransformation
-{
-protected:
-	// make these functions protected to help prevent unintentional calls to them
-	BufferedTransformation::Get;
-	BufferedTransformation::Peek;
-	BufferedTransformation::TransferTo;
-	BufferedTransformation::CopyTo;
-	BufferedTransformation::CopyRangeTo;
-	BufferedTransformation::TransferMessagesTo;
-	BufferedTransformation::CopyMessagesTo;
-	BufferedTransformation::TransferAllTo;
-	BufferedTransformation::CopyAllTo;
-	unsigned int TransferTo2(BufferedTransformation &target, unsigned long &transferBytes, const std::string &channel=NULL_CHANNEL, bool blocking=true)
-		{transferBytes = 0; return 0;}
-	unsigned int CopyRangeTo2(BufferedTransformation &target, unsigned long &begin, unsigned long end=ULONG_MAX, const std::string &channel=NULL_CHANNEL, bool blocking=true) const
-		{return 0;}
-};
-
-class BitBucket : public Bufferless<Sink>
-{
-public:
-	std::string AlgorithmName() const {return "BitBucket";}
-	void IsolatedInitialize(const NameValuePairs &parameters) {}
-	unsigned int Put2(const byte *begin, unsigned int length, int messageEnd, bool blocking)
-		{return 0;}
-};
-
-NAMESPACE_END
-
-#endif
+// simple.h - written and placed in the public domain by Wei Dai
+/*! \file
+ 	Simple non-interface classes derived from classes in cryptlib.h.
+*/
+
+#ifndef CRYPTOPP_SIMPLE_H
+#define CRYPTOPP_SIMPLE_H
+
+#include "cryptlib.h"
+#include "misc.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+//! _
+template <class DERIVED, class BASE>
+class CRYPTOPP_NO_VTABLE ClonableImpl : public BASE
+{
+public:
+	Clonable * Clone() const {return new DERIVED(*static_cast<const DERIVED *>(this));}
+};
+
+//! _
+template <class BASE, class ALGORITHM_INFO=BASE>
+class CRYPTOPP_NO_VTABLE AlgorithmImpl : public BASE
+{
+public:
+	static std::string CRYPTOPP_API StaticAlgorithmName() {return ALGORITHM_INFO::StaticAlgorithmName();}
+	std::string AlgorithmName() const {return ALGORITHM_INFO::StaticAlgorithmName();}
+};
+
+//! _
+class CRYPTOPP_DLL InvalidKeyLength : public InvalidArgument
+{
+public:
+	explicit InvalidKeyLength(const std::string &algorithm, size_t length) : InvalidArgument(algorithm + ": " + IntToString(length) + " is not a valid key length") {}
+};
+
+//! _
+class CRYPTOPP_DLL InvalidRounds : public InvalidArgument
+{
+public:
+	explicit InvalidRounds(const std::string &algorithm, unsigned int rounds) : InvalidArgument(algorithm + ": " + IntToString(rounds) + " is not a valid number of rounds") {}
+};
+
+// *****************************
+
+//! _
+template <class T>
+class CRYPTOPP_NO_VTABLE Bufferless : public T
+{
+public:
+	bool IsolatedFlush(bool hardFlush, bool blocking) {return false;}
+};
+
+//! _
+template <class T>
+class CRYPTOPP_NO_VTABLE Unflushable : public T
+{
+public:
+	bool Flush(bool completeFlush, int propagation=-1, bool blocking=true)
+		{return ChannelFlush(DEFAULT_CHANNEL, completeFlush, propagation, blocking);}
+	bool IsolatedFlush(bool hardFlush, bool blocking)
+		{assert(false); return false;}
+	bool ChannelFlush(const std::string &channel, bool hardFlush, int propagation=-1, bool blocking=true)
+	{
+		if (hardFlush && !InputBufferIsEmpty())
+			throw CannotFlush("Unflushable<T>: this object has buffered input that cannot be flushed");
+		else 
+		{
+			BufferedTransformation *attached = this->AttachedTransformation();
+			return attached && propagation ? attached->ChannelFlush(channel, hardFlush, propagation-1, blocking) : false;
+		}
+	}
+
+protected:
+	virtual bool InputBufferIsEmpty() const {return false;}
+};
+
+//! _
+template <class T>
+class CRYPTOPP_NO_VTABLE InputRejecting : public T
+{
+public:
+	struct InputRejected : public NotImplemented
+		{InputRejected() : NotImplemented("BufferedTransformation: this object doesn't allow input") {}};
+
+	// shouldn't be calling these functions on this class
+	size_t Put2(const byte *begin, size_t length, int messageEnd, bool blocking)
+		{throw InputRejected();}
+	bool IsolatedFlush(bool, bool) {return false;}
+	bool IsolatedMessageSeriesEnd(bool) {throw InputRejected();}
+
+	size_t ChannelPut2(const std::string &channel, const byte *begin, size_t length, int messageEnd, bool blocking)
+		{throw InputRejected();}
+	bool ChannelMessageSeriesEnd(const std::string &, int, bool) {throw InputRejected();}
+};
+
+//! _
+template <class T>
+class CRYPTOPP_NO_VTABLE CustomFlushPropagation : public T
+{
+public:
+	virtual bool Flush(bool hardFlush, int propagation=-1, bool blocking=true) =0;
+
+private:
+	bool IsolatedFlush(bool hardFlush, bool blocking) {assert(false); return false;}
+};
+
+//! _
+template <class T>
+class CRYPTOPP_NO_VTABLE CustomSignalPropagation : public CustomFlushPropagation<T>
+{
+public:
+	virtual void Initialize(const NameValuePairs &parameters=g_nullNameValuePairs, int propagation=-1) =0;
+
+private:
+	void IsolatedInitialize(const NameValuePairs &parameters) {assert(false);}
+};
+
+//! _
+template <class T>
+class CRYPTOPP_NO_VTABLE Multichannel : public CustomFlushPropagation<T>
+{
+public:
+	bool Flush(bool hardFlush, int propagation=-1, bool blocking=true)
+		{return this->ChannelFlush(DEFAULT_CHANNEL, hardFlush, propagation, blocking);}
+	bool MessageSeriesEnd(int propagation=-1, bool blocking=true)
+		{return this->ChannelMessageSeriesEnd(DEFAULT_CHANNEL, propagation, blocking);}
+	byte * CreatePutSpace(size_t &size)
+		{return this->ChannelCreatePutSpace(DEFAULT_CHANNEL, size);}
+	size_t Put2(const byte *begin, size_t length, int messageEnd, bool blocking)
+		{return this->ChannelPut2(DEFAULT_CHANNEL, begin, length, messageEnd, blocking);}
+	size_t PutModifiable2(byte *inString, size_t length, int messageEnd, bool blocking)
+		{return this->ChannelPutModifiable2(DEFAULT_CHANNEL, inString, length, messageEnd, blocking);}
+
+//	void ChannelMessageSeriesEnd(const std::string &channel, int propagation=-1)
+//		{PropagateMessageSeriesEnd(propagation, channel);}
+	byte * ChannelCreatePutSpace(const std::string &channel, size_t &size)
+		{size = 0; return NULL;}
+	bool ChannelPutModifiable(const std::string &channel, byte *inString, size_t length)
+		{this->ChannelPut(channel, inString, length); return false;}
+
+	virtual size_t ChannelPut2(const std::string &channel, const byte *begin, size_t length, int messageEnd, bool blocking) =0;
+	size_t ChannelPutModifiable2(const std::string &channel, byte *begin, size_t length, int messageEnd, bool blocking)
+		{return ChannelPut2(channel, begin, length, messageEnd, blocking);}
+
+	virtual bool ChannelFlush(const std::string &channel, bool hardFlush, int propagation=-1, bool blocking=true) =0;
+};
+
+//! _
+template <class T>
+class CRYPTOPP_NO_VTABLE AutoSignaling : public T
+{
+public:
+	AutoSignaling(int propagation=-1) : m_autoSignalPropagation(propagation) {}
+
+	void SetAutoSignalPropagation(int propagation)
+		{m_autoSignalPropagation = propagation;}
+	int GetAutoSignalPropagation() const
+		{return m_autoSignalPropagation;}
+
+private:
+	int m_autoSignalPropagation;
+};
+
+//! A BufferedTransformation that only contains pre-existing data as "output"
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE Store : public AutoSignaling<InputRejecting<BufferedTransformation> >
+{
+public:
+	Store() : m_messageEnd(false) {}
+
+	void IsolatedInitialize(const NameValuePairs &parameters)
+	{
+		m_messageEnd = false;
+		StoreInitialize(parameters);
+	}
+
+	unsigned int NumberOfMessages() const {return m_messageEnd ? 0 : 1;}
+	bool GetNextMessage();
+	unsigned int CopyMessagesTo(BufferedTransformation &target, unsigned int count=UINT_MAX, const std::string &channel=DEFAULT_CHANNEL) const;
+
+protected:
+	virtual void StoreInitialize(const NameValuePairs &parameters) =0;
+
+	bool m_messageEnd;
+};
+
+//! A BufferedTransformation that doesn't produce any retrievable output
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE Sink : public BufferedTransformation
+{
+public:
+	size_t TransferTo2(BufferedTransformation &target, lword &transferBytes, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true)
+		{transferBytes = 0; return 0;}
+	size_t CopyRangeTo2(BufferedTransformation &target, lword &begin, lword end=LWORD_MAX, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true) const
+		{return 0;}
+};
+
+class CRYPTOPP_DLL BitBucket : public Bufferless<Sink>
+{
+public:
+	std::string AlgorithmName() const {return "BitBucket";}
+	void IsolatedInitialize(const NameValuePairs &parameters) {}
+	size_t Put2(const byte *begin, size_t length, int messageEnd, bool blocking)
+		{return 0;}
+};
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/smartptr.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/smartptr.h
index 9e9572ac..a0a727ed 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/smartptr.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/smartptr.h
@@ -1,215 +1,223 @@
-#ifndef CRYPTOPP_SMARTPTR_H
-#define CRYPTOPP_SMARTPTR_H
-
-#include "config.h"
-#include <algorithm>
-
-NAMESPACE_BEGIN(CryptoPP)
-
-template<class T> class member_ptr
-{
-public:
-	explicit member_ptr(T *p = NULL) : m_p(p) {}
-
-	~member_ptr();
-
-	const T& operator*() const { return *m_p; }
-	T& operator*() { return *m_p; }
-
-	const T* operator->() const { return m_p; }
-	T* operator->() { return m_p; }
-
-	const T* get() const { return m_p; }
-	T* get() { return m_p; }
-
-	T* release()
-	{
-		T *old_p = m_p;
-		m_p = 0;
-		return old_p;
-	} 
-
-	void reset(T *p = 0);
-
-protected:
-	member_ptr(const member_ptr<T>& rhs);		// copy not allowed
-	void operator=(const member_ptr<T>& rhs);	// assignment not allowed
-
-	T *m_p;
-};
-
-template <class T> member_ptr<T>::~member_ptr() {delete m_p;}
-template <class T> void member_ptr<T>::reset(T *p) {delete m_p; m_p = p;}
-
-// ********************************************************
-
-template<class T> class value_ptr : public member_ptr<T>
-{
-public:
-	value_ptr(const T &obj) : member_ptr<T>(new T(obj)) {}
-	value_ptr(T *p = NULL) : member_ptr<T>(p) {}
-	value_ptr(const value_ptr<T>& rhs)
-		: member_ptr<T>(rhs.m_p ? new T(*rhs.m_p) : NULL) {}
-
-	value_ptr<T>& operator=(const value_ptr<T>& rhs);
-	bool operator==(const value_ptr<T>& rhs)
-	{
-		return (!m_p && !rhs.m_p) || (m_p && rhs.m_p && *m_p == *rhs.m_p);
-	}
-};
-
-template <class T> value_ptr<T>& value_ptr<T>::operator=(const value_ptr<T>& rhs)
-{
-	T *old_p = m_p;
-	m_p = rhs.m_p ? new T(*rhs.m_p) : NULL;
-	delete old_p;
-	return *this;
-}
-
-// ********************************************************
-
-template<class T> class clonable_ptr : public member_ptr<T>
-{
-public:
-	clonable_ptr(const T &obj) : member_ptr<T>(obj.Clone()) {}
-	clonable_ptr(T *p = NULL) : member_ptr<T>(p) {}
-	clonable_ptr(const clonable_ptr<T>& rhs)
-		: member_ptr<T>(rhs.m_p ? rhs.m_p->Clone() : NULL) {}
-
-	clonable_ptr<T>& operator=(const clonable_ptr<T>& rhs);
-};
-
-template <class T> clonable_ptr<T>& clonable_ptr<T>::operator=(const clonable_ptr<T>& rhs)
-{
-	T *old_p = m_p;
-	m_p = rhs.m_p ? rhs.m_p->Clone() : NULL;
-	delete old_p;
-	return *this;
-}
-
-// ********************************************************
-
-template<class T> class counted_ptr
-{
-public:
-	explicit counted_ptr(T *p = 0);
-	counted_ptr(const T &r) : m_p(0) {attach(r);}
-	counted_ptr(const counted_ptr<T>& rhs);
-
-	~counted_ptr();
-
-	const T& operator*() const { return *m_p; }
-	T& operator*() { return *m_p; }
-
-	const T* operator->() const { return m_p; }
-	T* operator->() { return get(); }
-
-	const T* get() const { return m_p; }
-	T* get();
-
-	void attach(const T &p);
-
-	counted_ptr<T> & operator=(const counted_ptr<T>& rhs);
-
-private:
-	T *m_p;
-};
-
-template <class T> counted_ptr<T>::counted_ptr(T *p)
-	: m_p(p) 
-{
-	if (m_p)
-		m_p->m_referenceCount = 1;
-}
-
-template <class T> counted_ptr<T>::counted_ptr(const counted_ptr<T>& rhs)
-	: m_p(rhs.m_p)
-{
-	if (m_p)
-		m_p->m_referenceCount++;
-}
-
-template <class T> counted_ptr<T>::~counted_ptr()
-{
-	if (m_p && --m_p->m_referenceCount == 0)
-		delete m_p;
-}
-
-template <class T> void counted_ptr<T>::attach(const T &r)
-{
-	if (m_p && --m_p->m_referenceCount == 0)
-		delete m_p;
-	if (r.m_referenceCount == 0)
-	{
-		m_p = r.clone();
-		m_p->m_referenceCount = 1;
-	}
-	else
-	{
-		m_p = const_cast<T *>(&r);
-		m_p->m_referenceCount++;
-	}
-}
-
-template <class T> T* counted_ptr<T>::get()
-{
-	if (m_p && m_p->m_referenceCount > 1)
-	{
-		T *temp = m_p->clone();
-		m_p->m_referenceCount--;
-		m_p = temp;
-		m_p->m_referenceCount = 1;
-	}
-	return m_p;
-}
-
-template <class T> counted_ptr<T> & counted_ptr<T>::operator=(const counted_ptr<T>& rhs)
-{
-	if (m_p != rhs.m_p)
-	{
-		if (m_p && --m_p->m_referenceCount == 0)
-			delete m_p;
-		m_p = rhs.m_p;
-		if (m_p)
-			m_p->m_referenceCount++;
-	}
-	return *this;
-}
-
-// ********************************************************
-
-template <class T> class vector_member_ptrs
-{
-public:
-	vector_member_ptrs(unsigned int size=0)
-		: _size(size) {ptr = new member_ptr<T>[_size];}
-	~vector_member_ptrs()
-		{delete [] ptr;}
-
-	member_ptr<T>& operator[](unsigned int index)
-		{assert(index<_size); return ptr[index];}
-	const member_ptr<T>& operator[](unsigned int index) const
-		{assert(index<_size); return ptr[index];}
-
-	unsigned int size() const {return _size;}
-	void resize(unsigned int newSize)
-	{
-		member_ptr<T> *newPtr = new member_ptr<T>[newSize];
-		for (unsigned int i=0; i<STDMIN(_size, newSize); i++)
-			newPtr[i].reset(ptr[i].release());
-		delete [] ptr;
-		_size = newSize;
-		ptr = newPtr;
-	}
-
-private:
-	vector_member_ptrs(const vector_member_ptrs<T> &c);	// copy not allowed
-	void operator=(const vector_member_ptrs<T> &x);		// assignment not allowed
-
-	unsigned int _size;
-	member_ptr<T> *ptr;
-};
-
-NAMESPACE_END
-
-#endif
+#ifndef CRYPTOPP_SMARTPTR_H
+#define CRYPTOPP_SMARTPTR_H
+
+#include "config.h"
+#include <algorithm>
+
+NAMESPACE_BEGIN(CryptoPP)
+
+template <class T> class simple_ptr
+{
+public:
+	simple_ptr(T *p = NULL) : m_p(p) {}
+	~simple_ptr() {delete m_p; m_p = NULL;}		// set m_p to NULL so double destruction (which might occur in Singleton) will be harmless
+	T *m_p;
+};
+
+template <class T> class member_ptr
+{
+public:
+	explicit member_ptr(T *p = NULL) : m_p(p) {}
+
+	~member_ptr();
+
+	const T& operator*() const { return *m_p; }
+	T& operator*() { return *m_p; }
+
+	const T* operator->() const { return m_p; }
+	T* operator->() { return m_p; }
+
+	const T* get() const { return m_p; }
+	T* get() { return m_p; }
+
+	T* release()
+	{
+		T *old_p = m_p;
+		m_p = 0;
+		return old_p;
+	} 
+
+	void reset(T *p = 0);
+
+protected:
+	member_ptr(const member_ptr<T>& rhs);		// copy not allowed
+	void operator=(const member_ptr<T>& rhs);	// assignment not allowed
+
+	T *m_p;
+};
+
+template <class T> member_ptr<T>::~member_ptr() {delete m_p;}
+template <class T> void member_ptr<T>::reset(T *p) {delete m_p; m_p = p;}
+
+// ********************************************************
+
+template<class T> class value_ptr : public member_ptr<T>
+{
+public:
+	value_ptr(const T &obj) : member_ptr<T>(new T(obj)) {}
+	value_ptr(T *p = NULL) : member_ptr<T>(p) {}
+	value_ptr(const value_ptr<T>& rhs)
+		: member_ptr<T>(rhs.m_p ? new T(*rhs.m_p) : NULL) {}
+
+	value_ptr<T>& operator=(const value_ptr<T>& rhs);
+	bool operator==(const value_ptr<T>& rhs)
+	{
+		return (!this->m_p && !rhs.m_p) || (this->m_p && rhs.m_p && *this->m_p == *rhs.m_p);
+	}
+};
+
+template <class T> value_ptr<T>& value_ptr<T>::operator=(const value_ptr<T>& rhs)
+{
+	T *old_p = this->m_p;
+	this->m_p = rhs.m_p ? new T(*rhs.m_p) : NULL;
+	delete old_p;
+	return *this;
+}
+
+// ********************************************************
+
+template<class T> class clonable_ptr : public member_ptr<T>
+{
+public:
+	clonable_ptr(const T &obj) : member_ptr<T>(obj.Clone()) {}
+	clonable_ptr(T *p = NULL) : member_ptr<T>(p) {}
+	clonable_ptr(const clonable_ptr<T>& rhs)
+		: member_ptr<T>(rhs.m_p ? rhs.m_p->Clone() : NULL) {}
+
+	clonable_ptr<T>& operator=(const clonable_ptr<T>& rhs);
+};
+
+template <class T> clonable_ptr<T>& clonable_ptr<T>::operator=(const clonable_ptr<T>& rhs)
+{
+	T *old_p = this->m_p;
+	this->m_p = rhs.m_p ? rhs.m_p->Clone() : NULL;
+	delete old_p;
+	return *this;
+}
+
+// ********************************************************
+
+template<class T> class counted_ptr
+{
+public:
+	explicit counted_ptr(T *p = 0);
+	counted_ptr(const T &r) : m_p(0) {attach(r);}
+	counted_ptr(const counted_ptr<T>& rhs);
+
+	~counted_ptr();
+
+	const T& operator*() const { return *m_p; }
+	T& operator*() { return *m_p; }
+
+	const T* operator->() const { return m_p; }
+	T* operator->() { return get(); }
+
+	const T* get() const { return m_p; }
+	T* get();
+
+	void attach(const T &p);
+
+	counted_ptr<T> & operator=(const counted_ptr<T>& rhs);
+
+private:
+	T *m_p;
+};
+
+template <class T> counted_ptr<T>::counted_ptr(T *p)
+	: m_p(p) 
+{
+	if (m_p)
+		m_p->m_referenceCount = 1;
+}
+
+template <class T> counted_ptr<T>::counted_ptr(const counted_ptr<T>& rhs)
+	: m_p(rhs.m_p)
+{
+	if (m_p)
+		m_p->m_referenceCount++;
+}
+
+template <class T> counted_ptr<T>::~counted_ptr()
+{
+	if (m_p && --m_p->m_referenceCount == 0)
+		delete m_p;
+}
+
+template <class T> void counted_ptr<T>::attach(const T &r)
+{
+	if (m_p && --m_p->m_referenceCount == 0)
+		delete m_p;
+	if (r.m_referenceCount == 0)
+	{
+		m_p = r.clone();
+		m_p->m_referenceCount = 1;
+	}
+	else
+	{
+		m_p = const_cast<T *>(&r);
+		m_p->m_referenceCount++;
+	}
+}
+
+template <class T> T* counted_ptr<T>::get()
+{
+	if (m_p && m_p->m_referenceCount > 1)
+	{
+		T *temp = m_p->clone();
+		m_p->m_referenceCount--;
+		m_p = temp;
+		m_p->m_referenceCount = 1;
+	}
+	return m_p;
+}
+
+template <class T> counted_ptr<T> & counted_ptr<T>::operator=(const counted_ptr<T>& rhs)
+{
+	if (m_p != rhs.m_p)
+	{
+		if (m_p && --m_p->m_referenceCount == 0)
+			delete m_p;
+		m_p = rhs.m_p;
+		if (m_p)
+			m_p->m_referenceCount++;
+	}
+	return *this;
+}
+
+// ********************************************************
+
+template <class T> class vector_member_ptrs
+{
+public:
+	vector_member_ptrs(size_t size=0)
+		: m_size(size), m_ptr(new member_ptr<T>[size]) {}
+	~vector_member_ptrs()
+		{delete [] this->m_ptr;}
+
+	member_ptr<T>& operator[](size_t index)
+		{assert(index<this->m_size); return this->m_ptr[index];}
+	const member_ptr<T>& operator[](size_t index) const
+		{assert(index<this->m_size); return this->m_ptr[index];}
+
+	size_t size() const {return this->m_size;}
+	void resize(size_t newSize)
+	{
+		member_ptr<T> *newPtr = new member_ptr<T>[newSize];
+		for (size_t i=0; i<this->m_size && i<newSize; i++)
+			newPtr[i].reset(this->m_ptr[i].release());
+		delete [] this->m_ptr;
+		this->m_size = newSize;
+		this->m_ptr = newPtr;
+	}
+
+private:
+	vector_member_ptrs(const vector_member_ptrs<T> &c);	// copy not allowed
+	void operator=(const vector_member_ptrs<T> &x);		// assignment not allowed
+
+	size_t m_size;
+	member_ptr<T> *m_ptr;
+};
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/stdcpp.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/stdcpp.h
new file mode 100644
index 00000000..6511c4fa
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/stdcpp.h
@@ -0,0 +1,41 @@
+#ifndef CRYPTOPP_STDCPP_H
+#define CRYPTOPP_STDCPP_H
+
+#if _MSC_VER >= 1500
+#define _DO_NOT_DECLARE_INTERLOCKED_INTRINSICS_IN_MEMORY
+#include <intrin.h>
+#endif
+
+#include <stddef.h>
+#include <assert.h>
+#include <limits.h>
+#include <stdlib.h>
+#include <string.h>
+#include <memory>
+#include <string>
+#include <exception>
+#include <typeinfo>
+#include <algorithm>
+#include <map>
+#include <vector>
+
+#ifdef CRYPTOPP_INCLUDE_VECTOR_CC
+// workaround needed on Sun Studio 12u1 Sun C++ 5.10 SunOS_i386 128229-02 2009/09/21
+#include <vector.cc>
+#endif
+
+// for alloca
+#ifdef __sun
+#include <alloca.h>
+#elif defined(__MINGW32__) || defined(__BORLANDC__)
+#include <malloc.h>
+#endif
+
+#ifdef _MSC_VER
+#pragma warning(disable: 4231)	// re-disable this
+#ifdef _CRTAPI1
+#define CRYPTOPP_MSVCRT6
+#endif
+#endif
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/strciphr.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/strciphr.h
index fb5aee43..d1d11a17 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/strciphr.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/strciphr.h
@@ -1,288 +1,306 @@
-/*! \file
- 	This file contains helper classes for implementing stream ciphers.
-
-	All this infrastructure may look very complex compared to what's in Crypto++ 4.x,
-	but stream ciphers implementations now support a lot of new functionality,
-	including better performance (minimizing copying), resetting of keys and IVs, and methods to
-	query which features are supported by a cipher.
-
-	Here's an explanation of these classes. The word "policy" is used here to mean a class with a
-	set of methods that must be implemented by individual stream cipher implementations.
-	This is usually much simpler than the full stream cipher API, which is implemented by
-	either AdditiveCipherTemplate or CFB_CipherTemplate using the policy. So for example, an
-	implementation of SEAL only needs to implement the AdditiveCipherAbstractPolicy interface
-	(since it's an additive cipher, i.e., it xors a keystream into the plaintext).
-	See this line in seal.h:
-
-	typedef SymmetricCipherFinalTemplate<ConcretePolicyHolder<SEAL_Policy<B>, AdditiveCipherTemplate<> > > Encryption;
-
-	AdditiveCipherTemplate and CFB_CipherTemplate are designed so that they don't need
-	to take a policy class as a template parameter (although this is allowed), so that
-	their code is not duplicated for each new cipher. Instead they each
-	get a reference to an abstract policy interface by calling AccessPolicy() on itself, so
-	AccessPolicy() must be overriden to return the actual policy reference. This is done
-	by the ConceretePolicyHolder class. Finally, SymmetricCipherFinalTemplate implements the constructors and
-	other functions that must be implemented by the most derived class.
-*/
-
-#ifndef CRYPTOPP_STRCIPHR_H
-#define CRYPTOPP_STRCIPHR_H
-
-#include "seckey.h"
-#include "secblock.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-template <class POLICY_INTERFACE, class BASE = Empty>
-class AbstractPolicyHolder : public BASE
-{
-public:
-	typedef POLICY_INTERFACE PolicyInterface;
-
-protected:
-	virtual const POLICY_INTERFACE & GetPolicy() const =0;
-	virtual POLICY_INTERFACE & AccessPolicy() =0;
-};
-
-template <class POLICY, class BASE, class POLICY_INTERFACE = CPP_TYPENAME BASE::PolicyInterface>
-class ConcretePolicyHolder : public BASE, protected POLICY
-{
-protected:
-	const POLICY_INTERFACE & GetPolicy() const {return *this;}
-	POLICY_INTERFACE & AccessPolicy() {return *this;}
-};
-
-enum KeystreamOperation {WRITE_KEYSTREAM, XOR_KEYSTREAM, XOR_KEYSTREAM_INPLACE};
-
-struct AdditiveCipherAbstractPolicy
-{
-	virtual unsigned int GetAlignment() const =0;
-	virtual unsigned int GetBytesPerIteration() const =0;
-	virtual unsigned int GetIterationsToBuffer() const =0;
-	virtual void WriteKeystream(byte *keystreamBuffer, unsigned int iterationCount) =0;
-	virtual bool CanOperateKeystream() const {return false;}
-	virtual void OperateKeystream(KeystreamOperation operation, byte *output, const byte *input, unsigned int iterationCount) {assert(false);}
-	virtual void CipherSetKey(const NameValuePairs &params, const byte *key, unsigned int length) =0;
-	virtual void CipherResynchronize(byte *keystreamBuffer, const byte *iv) {throw NotImplemented("StreamTransformation: this object doesn't support resynchronization");}
-	virtual bool IsRandomAccess() const =0;
-	virtual void SeekToIteration(dword iterationCount) {assert(!IsRandomAccess()); throw NotImplemented("StreamTransformation: this object doesn't support random access");}
-};
-
-template <typename WT, unsigned int W, unsigned int X = 1, class BASE = AdditiveCipherAbstractPolicy>
-struct AdditiveCipherConcretePolicy : public BASE
-{
-	typedef WT WordType;
-
-	unsigned int GetAlignment() const {return sizeof(WordType);}
-	unsigned int GetBytesPerIteration() const {return sizeof(WordType) * W;}
-	unsigned int GetIterationsToBuffer() const {return X;}
-	void WriteKeystream(byte *buffer, unsigned int iterationCount)
-		{OperateKeystream(WRITE_KEYSTREAM, buffer, NULL, iterationCount);}
-	bool CanOperateKeystream() const {return true;}
-	virtual void OperateKeystream(KeystreamOperation operation, byte *output, const byte *input, unsigned int iterationCount) =0;
-
-	template <class B>
-	struct KeystreamOutput
-	{
-		KeystreamOutput(KeystreamOperation operation, byte *output, const byte *input)
-			: m_operation(operation), m_output(output), m_input(input) {}
-
-		inline KeystreamOutput & operator()(WordType keystreamWord)
-		{
-			assert(IsAligned<WordType>(m_input));
-			assert(IsAligned<WordType>(m_output));
-
-			if (!NativeByteOrderIs(B::ToEnum()))
-				keystreamWord = ByteReverse(keystreamWord);
-
-			if (m_operation == WRITE_KEYSTREAM)
-				*(WordType*)m_output = keystreamWord;
-			else if (m_operation == XOR_KEYSTREAM)
-			{
-				*(WordType*)m_output = keystreamWord ^ *(WordType*)m_input;
-				m_input += sizeof(WordType);
-			}
-			else if (m_operation == XOR_KEYSTREAM_INPLACE)
-				*(WordType*)m_output ^= keystreamWord;
-
-			m_output += sizeof(WordType);
-
-			return *this;
-		}
-
-		KeystreamOperation m_operation;
-		byte *m_output;
-		const byte *m_input;
-	};
-};
-
-template <class BASE = AbstractPolicyHolder<AdditiveCipherAbstractPolicy, TwoBases<SymmetricCipher, RandomNumberGenerator> > >
-class AdditiveCipherTemplate : public BASE
-{
-public:
-    byte GenerateByte();
-    void ProcessData(byte *outString, const byte *inString, unsigned int length);
-	void Resynchronize(const byte *iv);
-	unsigned int OptimalBlockSize() const {return GetPolicy().GetBytesPerIteration();}
-	unsigned int GetOptimalNextBlockSize() const {return m_leftOver;}
-	unsigned int OptimalDataAlignment() const {return GetPolicy().GetAlignment();}
-	bool IsSelfInverting() const {return true;}
-	bool IsForwardTransformation() const {return true;}
-	bool IsRandomAccess() const {return GetPolicy().IsRandomAccess();}
-	void Seek(dword position);
-
-	typedef typename BASE::PolicyInterface PolicyInterface;
-
-protected:
-	void UncheckedSetKey(const NameValuePairs &params, const byte *key, unsigned int length);
-
-	unsigned int GetBufferByteSize(const PolicyInterface &policy) const {return policy.GetBytesPerIteration() * policy.GetIterationsToBuffer();}
-
-	inline byte * KeystreamBufferBegin() {return m_buffer.data();}
-	inline byte * KeystreamBufferEnd() {return (m_buffer.data() + m_buffer.size());}
-
-	SecByteBlock m_buffer;
-	unsigned int m_leftOver;
-};
-
-struct CFB_CipherAbstractPolicy
-{
-	virtual unsigned int GetAlignment() const =0;
-	virtual unsigned int GetBytesPerIteration() const =0;
-	virtual byte * GetRegisterBegin() =0;
-	virtual void TransformRegister() =0;
-	virtual bool CanIterate() const {return false;}
-	virtual void Iterate(byte *output, const byte *input, CipherDir dir, unsigned int iterationCount) {assert(false);}
-	virtual void CipherSetKey(const NameValuePairs &params, const byte *key, unsigned int length) =0;
-	virtual void CipherResynchronize(const byte *iv) {throw NotImplemented("StreamTransformation: this object doesn't support resynchronization");}
-};
-
-template <typename WT, unsigned int W, class BASE = CFB_CipherAbstractPolicy>
-struct CFB_CipherConcretePolicy : public BASE
-{
-	typedef WT WordType;
-
-	unsigned int GetAlignment() const {return sizeof(WordType);}
-	unsigned int GetBytesPerIteration() const {return sizeof(WordType) * W;}
-	bool CanIterate() const {return true;}
-	void TransformRegister() {Iterate(NULL, NULL, ENCRYPTION, 1);}
-
-	template <class B>
-	struct RegisterOutput
-	{
-		RegisterOutput(byte *output, const byte *input, CipherDir dir)
-			: m_output(output), m_input(input), m_dir(dir) {}
-
-		inline RegisterOutput& operator()(WordType &registerWord)
-		{
-			assert(IsAligned<WordType>(m_output));
-			assert(IsAligned<WordType>(m_input));
-
-			if (!NativeByteOrderIs(B::ToEnum()))
-				registerWord = ByteReverse(registerWord);
-
-			if (m_dir == ENCRYPTION)
-			{
-				WordType ct = *(const WordType *)m_input ^ registerWord;
-				registerWord = ct;
-				*(WordType*)m_output = ct;
-				m_input += sizeof(WordType);
-				m_output += sizeof(WordType);
-			}
-			else
-			{
-				WordType ct = *(const WordType *)m_input;
-				*(WordType*)m_output = registerWord ^ ct;
-				registerWord = ct;
-				m_input += sizeof(WordType);
-				m_output += sizeof(WordType);
-			}
-
-			// registerWord is left unreversed so it can be xor-ed with further input
-
-			return *this;
-		}
-
-		byte *m_output;
-		const byte *m_input;
-		CipherDir m_dir;
-	};
-};
-
-template <class BASE>
-class CFB_CipherTemplate : public BASE
-{
-public:
-	void ProcessData(byte *outString, const byte *inString, unsigned int length);
-	void Resynchronize(const byte *iv);
-	unsigned int OptimalBlockSize() const {return GetPolicy().GetBytesPerIteration();}
-	unsigned int GetOptimalNextBlockSize() const {return m_leftOver;}
-	unsigned int OptimalDataAlignment() const {return GetPolicy().GetAlignment();}
-	bool IsRandomAccess() const {return false;}
-	bool IsSelfInverting() const {return false;}
-
-	typedef typename BASE::PolicyInterface PolicyInterface;
-
-protected:
-	virtual void CombineMessageAndShiftRegister(byte *output, byte *reg, const byte *message, unsigned int length) =0;
-
-	void UncheckedSetKey(const NameValuePairs &params, const byte *key, unsigned int length);
-
-	unsigned int m_leftOver;
-};
-
-template <class BASE = AbstractPolicyHolder<CFB_CipherAbstractPolicy, SymmetricCipher> >
-class CFB_EncryptionTemplate : public CFB_CipherTemplate<BASE>
-{
-	bool IsForwardTransformation() const {return true;}
-	void CombineMessageAndShiftRegister(byte *output, byte *reg, const byte *message, unsigned int length);
-};
-
-template <class BASE = AbstractPolicyHolder<CFB_CipherAbstractPolicy, SymmetricCipher> >
-class CFB_DecryptionTemplate : public CFB_CipherTemplate<BASE>
-{
-	bool IsForwardTransformation() const {return false;}
-	void CombineMessageAndShiftRegister(byte *output, byte *reg, const byte *message, unsigned int length);
-};
-
-template <class BASE, class INFO = BASE>
-class SymmetricCipherFinalTemplate : public AlgorithmImpl<SimpleKeyingInterfaceImpl<BASE, INFO>, INFO>
-{
-public:
- 	SymmetricCipherFinalTemplate() {}
-	SymmetricCipherFinalTemplate(const byte *key)
-		{SetKey(key, DEFAULT_KEYLENGTH);}
-	SymmetricCipherFinalTemplate(const byte *key, unsigned int length)
-		{SetKey(key, length);}
-	SymmetricCipherFinalTemplate(const byte *key, unsigned int length, const byte *iv)
-		{SetKey(key, length); Resynchronize(iv);}
-
-	void SetKey(const byte *key, unsigned int length, const NameValuePairs &params = g_nullNameValuePairs)
-	{
-		ThrowIfInvalidKeyLength(length);
-		UncheckedSetKey(params, key, length);
-	}
-
-	Clonable * Clone() const {return static_cast<SymmetricCipher *>(new SymmetricCipherFinalTemplate<BASE, INFO>(*this));}
-};
-
-template <class S>
-void AdditiveCipherTemplate<S>::UncheckedSetKey(const NameValuePairs &params, const byte *key, unsigned int length)
-{
-	PolicyInterface &policy = AccessPolicy();
-	policy.CipherSetKey(params, key, length);
-	m_buffer.New(GetBufferByteSize(policy));
-	m_leftOver = 0;
-}
-
-template <class BASE>
-void CFB_CipherTemplate<BASE>::UncheckedSetKey(const NameValuePairs &params, const byte *key, unsigned int length)
-{
-	PolicyInterface &policy = AccessPolicy();
-	policy.CipherSetKey(params, key, length);
-	m_leftOver = policy.GetBytesPerIteration();
-}
-
-NAMESPACE_END
-
-#endif
+/*! \file
+ 	This file contains helper classes for implementing stream ciphers.
+
+	All this infrastructure may look very complex compared to what's in Crypto++ 4.x,
+	but stream ciphers implementations now support a lot of new functionality,
+	including better performance (minimizing copying), resetting of keys and IVs, and methods to
+	query which features are supported by a cipher.
+
+	Here's an explanation of these classes. The word "policy" is used here to mean a class with a
+	set of methods that must be implemented by individual stream cipher implementations.
+	This is usually much simpler than the full stream cipher API, which is implemented by
+	either AdditiveCipherTemplate or CFB_CipherTemplate using the policy. So for example, an
+	implementation of SEAL only needs to implement the AdditiveCipherAbstractPolicy interface
+	(since it's an additive cipher, i.e., it xors a keystream into the plaintext).
+	See this line in seal.h:
+
+	typedef SymmetricCipherFinal\<ConcretePolicyHolder\<SEAL_Policy\<B\>, AdditiveCipherTemplate\<\> \> \> Encryption;
+
+	AdditiveCipherTemplate and CFB_CipherTemplate are designed so that they don't need
+	to take a policy class as a template parameter (although this is allowed), so that
+	their code is not duplicated for each new cipher. Instead they each
+	get a reference to an abstract policy interface by calling AccessPolicy() on itself, so
+	AccessPolicy() must be overriden to return the actual policy reference. This is done
+	by the ConceretePolicyHolder class. Finally, SymmetricCipherFinal implements the constructors and
+	other functions that must be implemented by the most derived class.
+*/
+
+#ifndef CRYPTOPP_STRCIPHR_H
+#define CRYPTOPP_STRCIPHR_H
+
+#include "seckey.h"
+#include "secblock.h"
+#include "argnames.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+template <class POLICY_INTERFACE, class BASE = Empty>
+class CRYPTOPP_NO_VTABLE AbstractPolicyHolder : public BASE
+{
+public:
+	typedef POLICY_INTERFACE PolicyInterface;
+	virtual ~AbstractPolicyHolder() {}
+
+protected:
+	virtual const POLICY_INTERFACE & GetPolicy() const =0;
+	virtual POLICY_INTERFACE & AccessPolicy() =0;
+};
+
+template <class POLICY, class BASE, class POLICY_INTERFACE = CPP_TYPENAME BASE::PolicyInterface>
+class ConcretePolicyHolder : public BASE, protected POLICY
+{
+protected:
+	const POLICY_INTERFACE & GetPolicy() const {return *this;}
+	POLICY_INTERFACE & AccessPolicy() {return *this;}
+};
+
+enum KeystreamOperationFlags {OUTPUT_ALIGNED=1, INPUT_ALIGNED=2, INPUT_NULL = 4};
+enum KeystreamOperation {
+	WRITE_KEYSTREAM				= INPUT_NULL, 
+	WRITE_KEYSTREAM_ALIGNED		= INPUT_NULL | OUTPUT_ALIGNED, 
+	XOR_KEYSTREAM				= 0, 
+	XOR_KEYSTREAM_INPUT_ALIGNED = INPUT_ALIGNED, 
+	XOR_KEYSTREAM_OUTPUT_ALIGNED= OUTPUT_ALIGNED, 
+	XOR_KEYSTREAM_BOTH_ALIGNED	= OUTPUT_ALIGNED | INPUT_ALIGNED};
+
+struct CRYPTOPP_DLL CRYPTOPP_NO_VTABLE AdditiveCipherAbstractPolicy
+{
+	virtual ~AdditiveCipherAbstractPolicy() {}
+	virtual unsigned int GetAlignment() const {return 1;}
+	virtual unsigned int GetBytesPerIteration() const =0;
+	virtual unsigned int GetOptimalBlockSize() const {return GetBytesPerIteration();}
+	virtual unsigned int GetIterationsToBuffer() const =0;
+	virtual void WriteKeystream(byte *keystream, size_t iterationCount)
+		{OperateKeystream(KeystreamOperation(INPUT_NULL | (KeystreamOperationFlags)IsAlignedOn(keystream, GetAlignment())), keystream, NULL, iterationCount);}
+	virtual bool CanOperateKeystream() const {return false;}
+	virtual void OperateKeystream(KeystreamOperation operation, byte *output, const byte *input, size_t iterationCount) {assert(false);}
+	virtual void CipherSetKey(const NameValuePairs &params, const byte *key, size_t length) =0;
+	virtual void CipherResynchronize(byte *keystreamBuffer, const byte *iv, size_t length) {throw NotImplemented("SimpleKeyingInterface: this object doesn't support resynchronization");}
+	virtual bool CipherIsRandomAccess() const =0;
+	virtual void SeekToIteration(lword iterationCount) {assert(!CipherIsRandomAccess()); throw NotImplemented("StreamTransformation: this object doesn't support random access");}
+};
+
+template <typename WT, unsigned int W, unsigned int X = 1, class BASE = AdditiveCipherAbstractPolicy>
+struct CRYPTOPP_NO_VTABLE AdditiveCipherConcretePolicy : public BASE
+{
+	typedef WT WordType;
+	CRYPTOPP_CONSTANT(BYTES_PER_ITERATION = sizeof(WordType) * W)
+
+#if !(CRYPTOPP_BOOL_X86 || CRYPTOPP_BOOL_X64)
+	unsigned int GetAlignment() const {return GetAlignmentOf<WordType>();}
+#endif
+	unsigned int GetBytesPerIteration() const {return BYTES_PER_ITERATION;}
+	unsigned int GetIterationsToBuffer() const {return X;}
+	bool CanOperateKeystream() const {return true;}
+	virtual void OperateKeystream(KeystreamOperation operation, byte *output, const byte *input, size_t iterationCount) =0;
+};
+
+// use these to implement OperateKeystream
+#define CRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, b, i, a)	\
+	PutWord(bool(x & OUTPUT_ALIGNED), b, output+i*sizeof(WordType), (x & INPUT_NULL) ? a : a ^ GetWord<WordType>(bool(x & INPUT_ALIGNED), b, input+i*sizeof(WordType)));
+#define CRYPTOPP_KEYSTREAM_OUTPUT_XMM(x, i, a)	{\
+	__m128i t = (x & INPUT_NULL) ? a : _mm_xor_si128(a, (x & INPUT_ALIGNED) ? _mm_load_si128((__m128i *)input+i) : _mm_loadu_si128((__m128i *)input+i));\
+	if (x & OUTPUT_ALIGNED) _mm_store_si128((__m128i *)output+i, t);\
+	else _mm_storeu_si128((__m128i *)output+i, t);}
+#define CRYPTOPP_KEYSTREAM_OUTPUT_SWITCH(x, y)	\
+	switch (operation)							\
+	{											\
+		case WRITE_KEYSTREAM:					\
+			x(WRITE_KEYSTREAM)					\
+			break;								\
+		case XOR_KEYSTREAM:						\
+			x(XOR_KEYSTREAM)					\
+			input += y;							\
+			break;								\
+		case XOR_KEYSTREAM_INPUT_ALIGNED:		\
+			x(XOR_KEYSTREAM_INPUT_ALIGNED)		\
+			input += y;							\
+			break;								\
+		case XOR_KEYSTREAM_OUTPUT_ALIGNED:		\
+			x(XOR_KEYSTREAM_OUTPUT_ALIGNED)		\
+			input += y;							\
+			break;								\
+		case WRITE_KEYSTREAM_ALIGNED:			\
+			x(WRITE_KEYSTREAM_ALIGNED)			\
+			break;								\
+		case XOR_KEYSTREAM_BOTH_ALIGNED:		\
+			x(XOR_KEYSTREAM_BOTH_ALIGNED)		\
+			input += y;							\
+			break;								\
+	}											\
+	output += y;
+
+template <class BASE = AbstractPolicyHolder<AdditiveCipherAbstractPolicy, SymmetricCipher> >
+class CRYPTOPP_NO_VTABLE AdditiveCipherTemplate : public BASE, public RandomNumberGenerator
+{
+public:
+	void GenerateBlock(byte *output, size_t size);
+    void ProcessData(byte *outString, const byte *inString, size_t length);
+	void Resynchronize(const byte *iv, int length=-1);
+	unsigned int OptimalBlockSize() const {return this->GetPolicy().GetOptimalBlockSize();}
+	unsigned int GetOptimalNextBlockSize() const {return (unsigned int)this->m_leftOver;}
+	unsigned int OptimalDataAlignment() const {return this->GetPolicy().GetAlignment();}
+	bool IsSelfInverting() const {return true;}
+	bool IsForwardTransformation() const {return true;}
+	bool IsRandomAccess() const {return this->GetPolicy().CipherIsRandomAccess();}
+	void Seek(lword position);
+
+	typedef typename BASE::PolicyInterface PolicyInterface;
+
+protected:
+	void UncheckedSetKey(const byte *key, unsigned int length, const NameValuePairs &params);
+
+	unsigned int GetBufferByteSize(const PolicyInterface &policy) const {return policy.GetBytesPerIteration() * policy.GetIterationsToBuffer();}
+
+	inline byte * KeystreamBufferBegin() {return this->m_buffer.data();}
+	inline byte * KeystreamBufferEnd() {return (this->m_buffer.data() + this->m_buffer.size());}
+
+	SecByteBlock m_buffer;
+	size_t m_leftOver;
+};
+
+class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE CFB_CipherAbstractPolicy
+{
+public:
+	virtual ~CFB_CipherAbstractPolicy() {}
+	virtual unsigned int GetAlignment() const =0;
+	virtual unsigned int GetBytesPerIteration() const =0;
+	virtual byte * GetRegisterBegin() =0;
+	virtual void TransformRegister() =0;
+	virtual bool CanIterate() const {return false;}
+	virtual void Iterate(byte *output, const byte *input, CipherDir dir, size_t iterationCount) {assert(false); throw 0;}
+	virtual void CipherSetKey(const NameValuePairs &params, const byte *key, size_t length) =0;
+	virtual void CipherResynchronize(const byte *iv, size_t length) {throw NotImplemented("SimpleKeyingInterface: this object doesn't support resynchronization");}
+};
+
+template <typename WT, unsigned int W, class BASE = CFB_CipherAbstractPolicy>
+struct CRYPTOPP_NO_VTABLE CFB_CipherConcretePolicy : public BASE
+{
+	typedef WT WordType;
+
+	unsigned int GetAlignment() const {return sizeof(WordType);}
+	unsigned int GetBytesPerIteration() const {return sizeof(WordType) * W;}
+	bool CanIterate() const {return true;}
+	void TransformRegister() {this->Iterate(NULL, NULL, ENCRYPTION, 1);}
+
+	template <class B>
+	struct RegisterOutput
+	{
+		RegisterOutput(byte *output, const byte *input, CipherDir dir)
+			: m_output(output), m_input(input), m_dir(dir) {}
+
+		inline RegisterOutput& operator()(WordType &registerWord)
+		{
+			assert(IsAligned<WordType>(m_output));
+			assert(IsAligned<WordType>(m_input));
+
+			if (!NativeByteOrderIs(B::ToEnum()))
+				registerWord = ByteReverse(registerWord);
+
+			if (m_dir == ENCRYPTION)
+			{
+				if (m_input == NULL)
+					assert(m_output == NULL);
+				else
+				{
+					WordType ct = *(const WordType *)m_input ^ registerWord;
+					registerWord = ct;
+					*(WordType*)m_output = ct;
+					m_input += sizeof(WordType);
+					m_output += sizeof(WordType);
+				}
+			}
+			else
+			{
+				WordType ct = *(const WordType *)m_input;
+				*(WordType*)m_output = registerWord ^ ct;
+				registerWord = ct;
+				m_input += sizeof(WordType);
+				m_output += sizeof(WordType);
+			}
+
+			// registerWord is left unreversed so it can be xor-ed with further input
+
+			return *this;
+		}
+
+		byte *m_output;
+		const byte *m_input;
+		CipherDir m_dir;
+	};
+};
+
+template <class BASE>
+class CRYPTOPP_NO_VTABLE CFB_CipherTemplate : public BASE
+{
+public:
+	void ProcessData(byte *outString, const byte *inString, size_t length);
+	void Resynchronize(const byte *iv, int length=-1);
+	unsigned int OptimalBlockSize() const {return this->GetPolicy().GetBytesPerIteration();}
+	unsigned int GetOptimalNextBlockSize() const {return (unsigned int)m_leftOver;}
+	unsigned int OptimalDataAlignment() const {return this->GetPolicy().GetAlignment();}
+	bool IsRandomAccess() const {return false;}
+	bool IsSelfInverting() const {return false;}
+
+	typedef typename BASE::PolicyInterface PolicyInterface;
+
+protected:
+	virtual void CombineMessageAndShiftRegister(byte *output, byte *reg, const byte *message, size_t length) =0;
+
+	void UncheckedSetKey(const byte *key, unsigned int length, const NameValuePairs &params);
+
+	size_t m_leftOver;
+};
+
+template <class BASE = AbstractPolicyHolder<CFB_CipherAbstractPolicy, SymmetricCipher> >
+class CRYPTOPP_NO_VTABLE CFB_EncryptionTemplate : public CFB_CipherTemplate<BASE>
+{
+	bool IsForwardTransformation() const {return true;}
+	void CombineMessageAndShiftRegister(byte *output, byte *reg, const byte *message, size_t length);
+};
+
+template <class BASE = AbstractPolicyHolder<CFB_CipherAbstractPolicy, SymmetricCipher> >
+class CRYPTOPP_NO_VTABLE CFB_DecryptionTemplate : public CFB_CipherTemplate<BASE>
+{
+	bool IsForwardTransformation() const {return false;}
+	void CombineMessageAndShiftRegister(byte *output, byte *reg, const byte *message, size_t length);
+};
+
+template <class BASE>
+class CFB_RequireFullDataBlocks : public BASE
+{
+public:
+	unsigned int MandatoryBlockSize() const {return this->OptimalBlockSize();}
+};
+
+//! _
+template <class BASE, class INFO = BASE>
+class SymmetricCipherFinal : public AlgorithmImpl<SimpleKeyingInterfaceImpl<BASE, INFO>, INFO>
+{
+public:
+ 	SymmetricCipherFinal() {}
+	SymmetricCipherFinal(const byte *key)
+		{this->SetKey(key, this->DEFAULT_KEYLENGTH);}
+	SymmetricCipherFinal(const byte *key, size_t length)
+		{this->SetKey(key, length);}
+	SymmetricCipherFinal(const byte *key, size_t length, const byte *iv)
+		{this->SetKeyWithIV(key, length, iv);}
+
+	Clonable * Clone() const {return static_cast<SymmetricCipher *>(new SymmetricCipherFinal<BASE, INFO>(*this));}
+};
+
+NAMESPACE_END
+
+#ifdef CRYPTOPP_MANUALLY_INSTANTIATE_TEMPLATES
+#include "strciphr.cpp"
+#endif
+
+NAMESPACE_BEGIN(CryptoPP)
+CRYPTOPP_DLL_TEMPLATE_CLASS AbstractPolicyHolder<AdditiveCipherAbstractPolicy, SymmetricCipher>;
+CRYPTOPP_DLL_TEMPLATE_CLASS AdditiveCipherTemplate<AbstractPolicyHolder<AdditiveCipherAbstractPolicy, SymmetricCipher> >;
+CRYPTOPP_DLL_TEMPLATE_CLASS CFB_CipherTemplate<AbstractPolicyHolder<CFB_CipherAbstractPolicy, SymmetricCipher> >;
+CRYPTOPP_DLL_TEMPLATE_CLASS CFB_EncryptionTemplate<AbstractPolicyHolder<CFB_CipherAbstractPolicy, SymmetricCipher> >;
+CRYPTOPP_DLL_TEMPLATE_CLASS CFB_DecryptionTemplate<AbstractPolicyHolder<CFB_CipherAbstractPolicy, SymmetricCipher> >;
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/trdlocal.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/trdlocal.h
new file mode 100644
index 00000000..92d244a0
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/trdlocal.h
@@ -0,0 +1,44 @@
+#ifndef CRYPTOPP_TRDLOCAL_H
+#define CRYPTOPP_TRDLOCAL_H
+
+#include "config.h"
+
+#ifdef THREADS_AVAILABLE
+
+#include "misc.h"
+
+#ifdef HAS_WINTHREADS
+typedef unsigned long ThreadLocalIndexType;
+#else
+#include <pthread.h>
+typedef pthread_key_t ThreadLocalIndexType;
+#endif
+
+NAMESPACE_BEGIN(CryptoPP)
+
+//! thread local storage
+class CRYPTOPP_DLL ThreadLocalStorage : public NotCopyable
+{
+public:
+	//! exception thrown by ThreadLocalStorage class
+	class Err : public OS_Error
+	{
+	public:
+		Err(const std::string& operation, int error);
+	};
+
+	ThreadLocalStorage();
+	~ThreadLocalStorage();
+
+	void SetValue(void *value);
+	void *GetValue() const;
+
+private:
+	ThreadLocalIndexType m_index;
+};
+
+NAMESPACE_END
+
+#endif	// #ifdef THREADS_AVAILABLE
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/words.h b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/words.h
index f75b867d..d5fda71d 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/inc/words.h
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/inc/words.h
@@ -1,103 +1,103 @@
-#ifndef CRYPTOPP_WORDS_H
-#define CRYPTOPP_WORDS_H
-
-#include "misc.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-inline unsigned int CountWords(const word *X, unsigned int N)
-{
-	while (N && X[N-1]==0)
-		N--;
-	return N;
-}
-
-inline void SetWords(word *r, word a, unsigned int n)
-{
-	for (unsigned int i=0; i<n; i++)
-		r[i] = a;
-}
-
-inline void CopyWords(word *r, const word *a, unsigned int n)
-{
-	for (unsigned int i=0; i<n; i++)
-		r[i] = a[i];
-}
-
-inline void XorWords(word *r, const word *a, const word *b, unsigned int n)
-{
-	for (unsigned int i=0; i<n; i++)
-		r[i] = a[i] ^ b[i];
-}
-
-inline void XorWords(word *r, const word *a, unsigned int n)
-{
-	for (unsigned int i=0; i<n; i++)
-		r[i] ^= a[i];
-}
-
-inline void AndWords(word *r, const word *a, const word *b, unsigned int n)
-{
-	for (unsigned int i=0; i<n; i++)
-		r[i] = a[i] & b[i];
-}
-
-inline void AndWords(word *r, const word *a, unsigned int n)
-{
-	for (unsigned int i=0; i<n; i++)
-		r[i] &= a[i];
-}
-
-inline word ShiftWordsLeftByBits(word *r, unsigned int n, unsigned int shiftBits)
-{
-	assert (shiftBits<WORD_BITS);
-	word u, carry=0;
-	if (shiftBits)
-		for (unsigned int i=0; i<n; i++)
-		{
-			u = r[i];
-			r[i] = (u << shiftBits) | carry;
-			carry = u >> (WORD_BITS-shiftBits);
-		}
-	return carry;
-}
-
-inline word ShiftWordsRightByBits(word *r, unsigned int n, unsigned int shiftBits)
-{
-	assert (shiftBits<WORD_BITS);
-	word u, carry=0;
-	if (shiftBits)
-		for (int i=n-1; i>=0; i--)
-		{
-			u = r[i];
-			r[i] = (u >> shiftBits) | carry;
-			carry = u << (WORD_BITS-shiftBits);
-		}
-	return carry;
-}
-
-inline void ShiftWordsLeftByWords(word *r, unsigned int n, unsigned int shiftWords)
-{
-	shiftWords = STDMIN(shiftWords, n);
-	if (shiftWords)
-	{
-		for (unsigned int i=n-1; i>=shiftWords; i--)
-			r[i] = r[i-shiftWords];
-		SetWords(r, 0, shiftWords);
-	}
-}
-
-inline void ShiftWordsRightByWords(word *r, unsigned int n, unsigned int shiftWords)
-{
-	shiftWords = STDMIN(shiftWords, n);
-	if (shiftWords)
-	{
-		for (unsigned int i=0; i+shiftWords<n; i++)
-			r[i] = r[i+shiftWords];
-		SetWords(r+n-shiftWords, 0, shiftWords);
-	}
-}
-
-NAMESPACE_END
-
-#endif
+#ifndef CRYPTOPP_WORDS_H
+#define CRYPTOPP_WORDS_H
+
+#include "misc.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+inline size_t CountWords(const word *X, size_t N)
+{
+	while (N && X[N-1]==0)
+		N--;
+	return N;
+}
+
+inline void SetWords(word *r, word a, size_t n)
+{
+	for (size_t i=0; i<n; i++)
+		r[i] = a;
+}
+
+inline void CopyWords(word *r, const word *a, size_t n)
+{
+	if (r != a)
+		memcpy(r, a, n*WORD_SIZE);
+}
+
+inline void XorWords(word *r, const word *a, const word *b, size_t n)
+{
+	for (size_t i=0; i<n; i++)
+		r[i] = a[i] ^ b[i];
+}
+
+inline void XorWords(word *r, const word *a, size_t n)
+{
+	for (size_t i=0; i<n; i++)
+		r[i] ^= a[i];
+}
+
+inline void AndWords(word *r, const word *a, const word *b, size_t n)
+{
+	for (size_t i=0; i<n; i++)
+		r[i] = a[i] & b[i];
+}
+
+inline void AndWords(word *r, const word *a, size_t n)
+{
+	for (size_t i=0; i<n; i++)
+		r[i] &= a[i];
+}
+
+inline word ShiftWordsLeftByBits(word *r, size_t n, unsigned int shiftBits)
+{
+	assert (shiftBits<WORD_BITS);
+	word u, carry=0;
+	if (shiftBits)
+		for (size_t i=0; i<n; i++)
+		{
+			u = r[i];
+			r[i] = (u << shiftBits) | carry;
+			carry = u >> (WORD_BITS-shiftBits);
+		}
+	return carry;
+}
+
+inline word ShiftWordsRightByBits(word *r, size_t n, unsigned int shiftBits)
+{
+	assert (shiftBits<WORD_BITS);
+	word u, carry=0;
+	if (shiftBits)
+		for (size_t i=n; i>0; i--)
+		{
+			u = r[i-1];
+			r[i-1] = (u >> shiftBits) | carry;
+			carry = u << (WORD_BITS-shiftBits);
+		}
+	return carry;
+}
+
+inline void ShiftWordsLeftByWords(word *r, size_t n, size_t shiftWords)
+{
+	shiftWords = STDMIN(shiftWords, n);
+	if (shiftWords)
+	{
+		for (size_t i=n-1; i>=shiftWords; i--)
+			r[i] = r[i-shiftWords];
+		SetWords(r, 0, shiftWords);
+	}
+}
+
+inline void ShiftWordsRightByWords(word *r, size_t n, size_t shiftWords)
+{
+	shiftWords = STDMIN(shiftWords, n);
+	if (shiftWords)
+	{
+		for (size_t i=0; i+shiftWords<n; i++)
+			r[i] = r[i+shiftWords];
+		SetWords(r+n-shiftWords, 0, shiftWords);
+	}
+}
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/makefile.mak b/SelfServiceCommon/Massai/cpp/Mcrypt/makefile.mak
index 08de71f0..c4f92238 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/makefile.mak
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/makefile.mak
@@ -7,8 +7,7 @@
 !include $(BUILDROOT)\Build\cpp\makefile.common.mak
 
 MY_CFLAGS = \
-    -Gi -GR -G5 -Gy \
-    $(INC_ACETAO) \
+    $(MY_CFLAGS_1) \
     $(INC_INTERFACES)
 
 MY_LIB1 = \
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/algebra.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/algebra.cpp
index f9465b6a..78c3947b 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/src/algebra.cpp
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/algebra.cpp
@@ -1,340 +1,340 @@
-// algebra.cpp - written and placed in the public domain by Wei Dai
-
-//#include "pch.h"
-#include "algebra.h"
-#include "integer.h"
-
-#include <vector>
-
-NAMESPACE_BEGIN(CryptoPP)
-
-template <class T> const T& AbstractGroup<T>::Double(const Element &a) const
-{
-	return Add(a, a);
-}
-
-template <class T> const T& AbstractGroup<T>::Subtract(const Element &a, const Element &b) const
-{
-	// make copy of a in case Inverse() overwrites it
-	Element a1(a);
-	return Add(a1, Inverse(b));
-}
-
-template <class T> T& AbstractGroup<T>::Accumulate(Element &a, const Element &b) const
-{
-	return a = Add(a, b);
-}
-
-template <class T> T& AbstractGroup<T>::Reduce(Element &a, const Element &b) const
-{
-	return a = Subtract(a, b);
-}
-
-template <class T> const T& AbstractRing<T>::Square(const Element &a) const
-{
-	return Multiply(a, a);
-}
-
-template <class T> const T& AbstractRing<T>::Divide(const Element &a, const Element &b) const
-{
-	// make copy of a in case MultiplicativeInverse() overwrites it
-	Element a1(a);
-	return Multiply(a1, MultiplicativeInverse(b));
-}
-
-template <class T> const T& AbstractEuclideanDomain<T>::Mod(const Element &a, const Element &b) const
-{
-	Element q;
-	DivisionAlgorithm(result, q, a, b);
-	return result;
-}
-
-template <class T> const T& AbstractEuclideanDomain<T>::Gcd(const Element &a, const Element &b) const
-{
-	Element g[3]={b, a};
-	unsigned int i0=0, i1=1, i2=2;
-
-	while (!Equal(g[i1], Identity()))
-	{
-		g[i2] = Mod(g[i0], g[i1]);
-		unsigned int t = i0; i0 = i1; i1 = i2; i2 = t;
-	}
-
-	return result = g[i0];
-}
-
-template <class T> const typename QuotientRing<T>::Element& QuotientRing<T>::MultiplicativeInverse(const Element &a) const
-{
-	Element g[3]={m_modulus, a};
-#ifdef __BCPLUSPLUS__
-    // BC++50 workaround          
-	Element v[3];
-    v[0]=m_domain.Identity();
-    v[1]=m_domain.MultiplicativeIdentity();
-#else
-	Element v[3]={m_domain.Identity(), m_domain.MultiplicativeIdentity()};
-#endif
-	Element y;
-	unsigned int i0=0, i1=1, i2=2;
-
-	while (!Equal(g[i1], Identity()))
-	{
-		// y = g[i0] / g[i1];
-		// g[i2] = g[i0] % g[i1];
-		m_domain.DivisionAlgorithm(g[i2], y, g[i0], g[i1]);
-		// v[i2] = v[i0] - (v[i1] * y);
-		v[i2] = m_domain.Subtract(v[i0], m_domain.Multiply(v[i1], y));
-		unsigned int t = i0; i0 = i1; i1 = i2; i2 = t;
-	}
-
-	return m_domain.IsUnit(g[i0]) ? m_domain.Divide(v[i0], g[i0]) : m_domain.Identity();
-}
-
-template <class T> T AbstractGroup<T>::ScalarMultiply(const Element &base, const Integer &exponent) const
-{
-	Element result;
-	SimultaneousMultiply(&result, base, &exponent, 1);
-	return result;
-}
-
-template <class T> T AbstractGroup<T>::CascadeScalarMultiply(const Element &x, const Integer &e1, const Element &y, const Integer &e2) const
-{
-	const unsigned expLen = STDMAX(e1.BitCount(), e2.BitCount());
-	if (expLen==0)
-		return Identity();
-
-	const unsigned w = (expLen <= 46 ? 1 : (expLen <= 260 ? 2 : 3));
-	const unsigned tableSize = 1<<w;
-	std::vector<Element> powerTable(tableSize << w);
-
-	powerTable[1] = x;
-	powerTable[tableSize] = y;
-	if (w==1)
-		powerTable[3] = Add(x,y);
-	else
-	{
-		powerTable[2] = Double(x);
-		powerTable[2*tableSize] = Double(y);
-
-		unsigned i, j;
-
-		for (i=3; i<tableSize; i+=2)
-			powerTable[i] = Add(powerTable[i-2], powerTable[2]);
-		for (i=1; i<tableSize; i+=2)
-			for (j=i+tableSize; j<(tableSize<<w); j+=tableSize)
-				powerTable[j] = Add(powerTable[j-tableSize], y);
-
-		for (i=3*tableSize; i<(tableSize<<w); i+=2*tableSize)
-			powerTable[i] = Add(powerTable[i-2*tableSize], powerTable[2*tableSize]);
-		for (i=tableSize; i<(tableSize<<w); i+=2*tableSize)
-			for (j=i+2; j<i+tableSize; j+=2)
-				powerTable[j] = Add(powerTable[j-1], x);
-	}
-
-	Element result;
-	unsigned power1 = 0, power2 = 0, prevPosition = expLen-1;
-	bool firstTime = true;
-
-	for (int i = expLen-1; i>=0; i--)
-	{
-		power1 = 2*power1 + e1.GetBit(i);
-		power2 = 2*power2 + e2.GetBit(i);
-
-		if (i==0 || 2*power1 >= tableSize || 2*power2 >= tableSize)
-		{
-			unsigned squaresBefore = prevPosition-i;
-			unsigned squaresAfter = 0;
-			prevPosition = i;
-			while ((power1 || power2) && power1%2 == 0 && power2%2==0)
-			{
-				power1 /= 2;
-				power2 /= 2;
-				squaresBefore--;
-				squaresAfter++;
-			}
-			if (firstTime)
-			{
-				result = powerTable[(power2<<w) + power1];
-				firstTime = false;
-			}
-			else
-			{
-				while (squaresBefore--)
-					result = Double(result);
-				if (power1 || power2)
-					Accumulate(result, powerTable[(power2<<w) + power1]);
-			}
-			while (squaresAfter--)
-				result = Double(result);
-			power1 = power2 = 0;
-		}
-	}
-	return result;
-}
-
-template <class Element, class Iterator> Element GeneralCascadeMultiplication(const AbstractGroup<Element> &group, Iterator begin, Iterator end)
-{
-	if (end-begin == 1)
-		return group.ScalarMultiply(begin->base, begin->exponent);
-	else if (end-begin == 2)
-		return group.CascadeScalarMultiply(begin->base, begin->exponent, (begin+1)->base, (begin+1)->exponent);
-	else
-	{
-		Integer q, t;
-		Iterator last = end;
-		--last;
-
-		std::make_heap(begin, end);
-		std::pop_heap(begin, end);
-
-		while (!!begin->exponent)
-		{
-			// last->exponent is largest exponent, begin->exponent is next largest
-			t = last->exponent;
-			Integer::Divide(last->exponent, q, t, begin->exponent);
-
-			if (q == Integer::One())
-				group.Accumulate(begin->base, last->base);	// avoid overhead of ScalarMultiply()
-			else
-				group.Accumulate(begin->base, group.ScalarMultiply(last->base, q));
-
-			std::push_heap(begin, end);
-			std::pop_heap(begin, end);
-		}
-
-		return group.ScalarMultiply(last->base, last->exponent);
-	}
-}
-
-struct WindowSlider
-{
-	WindowSlider(const Integer &exp, bool fastNegate, unsigned int windowSizeIn=0)
-		: exp(exp), windowModulus(Integer::One()), windowSize(windowSizeIn), windowBegin(0), fastNegate(fastNegate), firstTime(true), finished(false)
-	{
-		if (windowSize == 0)
-		{
-			unsigned int expLen = exp.BitCount();
-			windowSize = expLen <= 17 ? 1 : (expLen <= 24 ? 2 : (expLen <= 70 ? 3 : (expLen <= 197 ? 4 : (expLen <= 539 ? 5 : (expLen <= 1434 ? 6 : 7)))));
-		}
-		windowModulus <<= windowSize;
-	}
-
-	void FindNextWindow()
-	{
-		unsigned int expLen = exp.WordCount() * WORD_BITS;
-		unsigned int skipCount = firstTime ? 0 : windowSize;
-		firstTime = false;
-		while (!exp.GetBit(skipCount))
-		{
-			if (skipCount >= expLen)
-			{
-				finished = true;
-				return;
-			}
-			skipCount++;
-		}
-
-		exp >>= skipCount;
-		windowBegin += skipCount;
-		expWindow = exp % (1 << windowSize);
-
-		if (fastNegate && exp.GetBit(windowSize))
-		{
-			negateNext = true;
-			expWindow = (1 << windowSize) - expWindow;
-			exp += windowModulus;
-		}
-		else
-			negateNext = false;
-	}
-
-	Integer exp, windowModulus;
-	unsigned int windowSize, windowBegin, expWindow;
-	bool fastNegate, negateNext, firstTime, finished;
-};
-
-template <class T>
-void AbstractGroup<T>::SimultaneousMultiply(T *results, const T &base, const Integer *expBegin, unsigned int expCount) const
-{
-	std::vector<std::vector<Element> > buckets(expCount);
-	std::vector<WindowSlider> exponents;
-	exponents.reserve(expCount);
-	unsigned int i;
-
-	for (i=0; i<expCount; i++)
-	{
-		assert(expBegin->NotNegative());
-		exponents.push_back(WindowSlider(*expBegin++, InversionIsFast(), 0));
-		exponents[i].FindNextWindow();
-		buckets[i].resize(1<<(exponents[i].windowSize-1), Identity());
-	}
-
-	unsigned int expBitPosition = 0;
-	Element g = base;
-	bool notDone = true;
-
-	while (notDone)
-	{
-		notDone = false;
-		for (i=0; i<expCount; i++)
-		{
-			if (!exponents[i].finished && expBitPosition == exponents[i].windowBegin)
-			{
-				Element &bucket = buckets[i][exponents[i].expWindow/2];
-				if (exponents[i].negateNext)
-					Accumulate(bucket, Inverse(g));
-				else
-					Accumulate(bucket, g);
-				exponents[i].FindNextWindow();
-			}
-			notDone = notDone || !exponents[i].finished;
-		}
-
-		if (notDone)
-		{
-			g = Double(g);
-			expBitPosition++;
-		}
-	}
-
-	for (i=0; i<expCount; i++)
-	{
-		Element &r = *results++;
-		r = buckets[i][buckets[i].size()-1];
-		if (buckets[i].size() > 1)
-		{
-			for (int j = buckets[i].size()-2; j >= 1; j--)
-			{
-				Accumulate(buckets[i][j], buckets[i][j+1]);
-				Accumulate(r, buckets[i][j]);
-			}
-			Accumulate(buckets[i][0], buckets[i][1]);
-			r = Add(Double(r), buckets[i][0]);
-		}
-	}
-}
-
-template <class T> T AbstractRing<T>::Exponentiate(const Element &base, const Integer &exponent) const
-{
-	Element result;
-	SimultaneousExponentiate(&result, base, &exponent, 1);
-	return result;
-}
-
-template <class T> T AbstractRing<T>::CascadeExponentiate(const Element &x, const Integer &e1, const Element &y, const Integer &e2) const
-{
-	return MultiplicativeGroup().AbstractGroup<T>::CascadeScalarMultiply(x, e1, y, e2);
-}
-
-template <class Element, class Iterator> Element GeneralCascadeExponentiation(const AbstractRing<Element> &ring, Iterator begin, Iterator end)
-{
-	return GeneralCascadeMultiplication<Element>(ring.MultiplicativeGroup(), begin, end);
-}
-
-template <class T>
-void AbstractRing<T>::SimultaneousExponentiate(T *results, const T &base, const Integer *exponents, unsigned int expCount) const
-{
-	MultiplicativeGroup().AbstractGroup<T>::SimultaneousMultiply(results, base, exponents, expCount);
-}
-
-NAMESPACE_END
+// algebra.cpp - written and placed in the public domain by Wei Dai
+
+#include "pch.h"
+
+#ifndef CRYPTOPP_ALGEBRA_CPP	// SunCC workaround: compiler could cause this file to be included twice
+#define CRYPTOPP_ALGEBRA_CPP
+
+#include "algebra.h"
+#include "integer.h"
+
+#include <vector>
+
+NAMESPACE_BEGIN(CryptoPP)
+
+template <class T> const T& AbstractGroup<T>::Double(const Element &a) const
+{
+	return Add(a, a);
+}
+
+template <class T> const T& AbstractGroup<T>::Subtract(const Element &a, const Element &b) const
+{
+	// make copy of a in case Inverse() overwrites it
+	Element a1(a);
+	return Add(a1, Inverse(b));
+}
+
+template <class T> T& AbstractGroup<T>::Accumulate(Element &a, const Element &b) const
+{
+	return a = Add(a, b);
+}
+
+template <class T> T& AbstractGroup<T>::Reduce(Element &a, const Element &b) const
+{
+	return a = Subtract(a, b);
+}
+
+template <class T> const T& AbstractRing<T>::Square(const Element &a) const
+{
+	return Multiply(a, a);
+}
+
+template <class T> const T& AbstractRing<T>::Divide(const Element &a, const Element &b) const
+{
+	// make copy of a in case MultiplicativeInverse() overwrites it
+	Element a1(a);
+	return Multiply(a1, MultiplicativeInverse(b));
+}
+
+template <class T> const T& AbstractEuclideanDomain<T>::Mod(const Element &a, const Element &b) const
+{
+	Element q;
+	DivisionAlgorithm(result, q, a, b);
+	return result;
+}
+
+template <class T> const T& AbstractEuclideanDomain<T>::Gcd(const Element &a, const Element &b) const
+{
+	Element g[3]={b, a};
+	unsigned int i0=0, i1=1, i2=2;
+
+	while (!Equal(g[i1], this->Identity()))
+	{
+		g[i2] = Mod(g[i0], g[i1]);
+		unsigned int t = i0; i0 = i1; i1 = i2; i2 = t;
+	}
+
+	return result = g[i0];
+}
+
+template <class T> const typename QuotientRing<T>::Element& QuotientRing<T>::MultiplicativeInverse(const Element &a) const
+{
+	Element g[3]={m_modulus, a};
+	Element v[3]={m_domain.Identity(), m_domain.MultiplicativeIdentity()};
+	Element y;
+	unsigned int i0=0, i1=1, i2=2;
+
+	while (!Equal(g[i1], Identity()))
+	{
+		// y = g[i0] / g[i1];
+		// g[i2] = g[i0] % g[i1];
+		m_domain.DivisionAlgorithm(g[i2], y, g[i0], g[i1]);
+		// v[i2] = v[i0] - (v[i1] * y);
+		v[i2] = m_domain.Subtract(v[i0], m_domain.Multiply(v[i1], y));
+		unsigned int t = i0; i0 = i1; i1 = i2; i2 = t;
+	}
+
+	return m_domain.IsUnit(g[i0]) ? m_domain.Divide(v[i0], g[i0]) : m_domain.Identity();
+}
+
+template <class T> T AbstractGroup<T>::ScalarMultiply(const Element &base, const Integer &exponent) const
+{
+	Element result;
+	SimultaneousMultiply(&result, base, &exponent, 1);
+	return result;
+}
+
+template <class T> T AbstractGroup<T>::CascadeScalarMultiply(const Element &x, const Integer &e1, const Element &y, const Integer &e2) const
+{
+	const unsigned expLen = STDMAX(e1.BitCount(), e2.BitCount());
+	if (expLen==0)
+		return Identity();
+
+	const unsigned w = (expLen <= 46 ? 1 : (expLen <= 260 ? 2 : 3));
+	const unsigned tableSize = 1<<w;
+	std::vector<Element> powerTable(tableSize << w);
+
+	powerTable[1] = x;
+	powerTable[tableSize] = y;
+	if (w==1)
+		powerTable[3] = Add(x,y);
+	else
+	{
+		powerTable[2] = Double(x);
+		powerTable[2*tableSize] = Double(y);
+
+		unsigned i, j;
+
+		for (i=3; i<tableSize; i+=2)
+			powerTable[i] = Add(powerTable[i-2], powerTable[2]);
+		for (i=1; i<tableSize; i+=2)
+			for (j=i+tableSize; j<(tableSize<<w); j+=tableSize)
+				powerTable[j] = Add(powerTable[j-tableSize], y);
+
+		for (i=3*tableSize; i<(tableSize<<w); i+=2*tableSize)
+			powerTable[i] = Add(powerTable[i-2*tableSize], powerTable[2*tableSize]);
+		for (i=tableSize; i<(tableSize<<w); i+=2*tableSize)
+			for (j=i+2; j<i+tableSize; j+=2)
+				powerTable[j] = Add(powerTable[j-1], x);
+	}
+
+	Element result;
+	unsigned power1 = 0, power2 = 0, prevPosition = expLen-1;
+	bool firstTime = true;
+
+	for (int i = expLen-1; i>=0; i--)
+	{
+		power1 = 2*power1 + e1.GetBit(i);
+		power2 = 2*power2 + e2.GetBit(i);
+
+		if (i==0 || 2*power1 >= tableSize || 2*power2 >= tableSize)
+		{
+			unsigned squaresBefore = prevPosition-i;
+			unsigned squaresAfter = 0;
+			prevPosition = i;
+			while ((power1 || power2) && power1%2 == 0 && power2%2==0)
+			{
+				power1 /= 2;
+				power2 /= 2;
+				squaresBefore--;
+				squaresAfter++;
+			}
+			if (firstTime)
+			{
+				result = powerTable[(power2<<w) + power1];
+				firstTime = false;
+			}
+			else
+			{
+				while (squaresBefore--)
+					result = Double(result);
+				if (power1 || power2)
+					Accumulate(result, powerTable[(power2<<w) + power1]);
+			}
+			while (squaresAfter--)
+				result = Double(result);
+			power1 = power2 = 0;
+		}
+	}
+	return result;
+}
+
+template <class Element, class Iterator> Element GeneralCascadeMultiplication(const AbstractGroup<Element> &group, Iterator begin, Iterator end)
+{
+	if (end-begin == 1)
+		return group.ScalarMultiply(begin->base, begin->exponent);
+	else if (end-begin == 2)
+		return group.CascadeScalarMultiply(begin->base, begin->exponent, (begin+1)->base, (begin+1)->exponent);
+	else
+	{
+		Integer q, t;
+		Iterator last = end;
+		--last;
+
+		std::make_heap(begin, end);
+		std::pop_heap(begin, end);
+
+		while (!!begin->exponent)
+		{
+			// last->exponent is largest exponent, begin->exponent is next largest
+			t = last->exponent;
+			Integer::Divide(last->exponent, q, t, begin->exponent);
+
+			if (q == Integer::One())
+				group.Accumulate(begin->base, last->base);	// avoid overhead of ScalarMultiply()
+			else
+				group.Accumulate(begin->base, group.ScalarMultiply(last->base, q));
+
+			std::push_heap(begin, end);
+			std::pop_heap(begin, end);
+		}
+
+		return group.ScalarMultiply(last->base, last->exponent);
+	}
+}
+
+struct WindowSlider
+{
+	WindowSlider(const Integer &expIn, bool fastNegate, unsigned int windowSizeIn=0)
+		: exp(expIn), windowModulus(Integer::One()), windowSize(windowSizeIn), windowBegin(0), fastNegate(fastNegate), firstTime(true), finished(false)
+	{
+		if (windowSize == 0)
+		{
+			unsigned int expLen = exp.BitCount();
+			windowSize = expLen <= 17 ? 1 : (expLen <= 24 ? 2 : (expLen <= 70 ? 3 : (expLen <= 197 ? 4 : (expLen <= 539 ? 5 : (expLen <= 1434 ? 6 : 7)))));
+		}
+		windowModulus <<= windowSize;
+	}
+
+	void FindNextWindow()
+	{
+		unsigned int expLen = exp.WordCount() * WORD_BITS;
+		unsigned int skipCount = firstTime ? 0 : windowSize;
+		firstTime = false;
+		while (!exp.GetBit(skipCount))
+		{
+			if (skipCount >= expLen)
+			{
+				finished = true;
+				return;
+			}
+			skipCount++;
+		}
+
+		exp >>= skipCount;
+		windowBegin += skipCount;
+		expWindow = word32(exp % (word(1) << windowSize));
+
+		if (fastNegate && exp.GetBit(windowSize))
+		{
+			negateNext = true;
+			expWindow = (word32(1) << windowSize) - expWindow;
+			exp += windowModulus;
+		}
+		else
+			negateNext = false;
+	}
+
+	Integer exp, windowModulus;
+	unsigned int windowSize, windowBegin;
+	word32 expWindow;
+	bool fastNegate, negateNext, firstTime, finished;
+};
+
+template <class T>
+void AbstractGroup<T>::SimultaneousMultiply(T *results, const T &base, const Integer *expBegin, unsigned int expCount) const
+{
+	std::vector<std::vector<Element> > buckets(expCount);
+	std::vector<WindowSlider> exponents;
+	exponents.reserve(expCount);
+	unsigned int i;
+
+	for (i=0; i<expCount; i++)
+	{
+		assert(expBegin->NotNegative());
+		exponents.push_back(WindowSlider(*expBegin++, InversionIsFast(), 0));
+		exponents[i].FindNextWindow();
+		buckets[i].resize(1<<(exponents[i].windowSize-1), Identity());
+	}
+
+	unsigned int expBitPosition = 0;
+	Element g = base;
+	bool notDone = true;
+
+	while (notDone)
+	{
+		notDone = false;
+		for (i=0; i<expCount; i++)
+		{
+			if (!exponents[i].finished && expBitPosition == exponents[i].windowBegin)
+			{
+				Element &bucket = buckets[i][exponents[i].expWindow/2];
+				if (exponents[i].negateNext)
+					Accumulate(bucket, Inverse(g));
+				else
+					Accumulate(bucket, g);
+				exponents[i].FindNextWindow();
+			}
+			notDone = notDone || !exponents[i].finished;
+		}
+
+		if (notDone)
+		{
+			g = Double(g);
+			expBitPosition++;
+		}
+	}
+
+	for (i=0; i<expCount; i++)
+	{
+		Element &r = *results++;
+		r = buckets[i][buckets[i].size()-1];
+		if (buckets[i].size() > 1)
+		{
+			for (int j = (int)buckets[i].size()-2; j >= 1; j--)
+			{
+				Accumulate(buckets[i][j], buckets[i][j+1]);
+				Accumulate(r, buckets[i][j]);
+			}
+			Accumulate(buckets[i][0], buckets[i][1]);
+			r = Add(Double(r), buckets[i][0]);
+		}
+	}
+}
+
+template <class T> T AbstractRing<T>::Exponentiate(const Element &base, const Integer &exponent) const
+{
+	Element result;
+	SimultaneousExponentiate(&result, base, &exponent, 1);
+	return result;
+}
+
+template <class T> T AbstractRing<T>::CascadeExponentiate(const Element &x, const Integer &e1, const Element &y, const Integer &e2) const
+{
+	return MultiplicativeGroup().AbstractGroup<T>::CascadeScalarMultiply(x, e1, y, e2);
+}
+
+template <class Element, class Iterator> Element GeneralCascadeExponentiation(const AbstractRing<Element> &ring, Iterator begin, Iterator end)
+{
+	return GeneralCascadeMultiplication<Element>(ring.MultiplicativeGroup(), begin, end);
+}
+
+template <class T>
+void AbstractRing<T>::SimultaneousExponentiate(T *results, const T &base, const Integer *exponents, unsigned int expCount) const
+{
+	MultiplicativeGroup().AbstractGroup<T>::SimultaneousMultiply(results, base, exponents, expCount);
+}
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/algparam.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/algparam.cpp
index e93a1446..a70d5dd9 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/src/algparam.cpp
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/algparam.cpp
@@ -1,10 +1,75 @@
-// algparam.cpp - written and placed in the public domain by Wei Dai
-
-//#include "pch.h"
-#include "algparam.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-bool (*AssignIntToInteger)(const std::type_info &valueType, void *pInteger, const void *pInt) = NULL;
-
-NAMESPACE_END
+// algparam.cpp - written and placed in the public domain by Wei Dai
+
+#include "pch.h"
+
+#ifndef CRYPTOPP_IMPORTS
+
+#include "algparam.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+PAssignIntToInteger g_pAssignIntToInteger = NULL;
+
+bool CombinedNameValuePairs::GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const
+{
+	if (strcmp(name, "ValueNames") == 0)
+		return m_pairs1.GetVoidValue(name, valueType, pValue) && m_pairs2.GetVoidValue(name, valueType, pValue);
+	else
+		return m_pairs1.GetVoidValue(name, valueType, pValue) || m_pairs2.GetVoidValue(name, valueType, pValue);
+}
+
+void AlgorithmParametersBase::operator=(const AlgorithmParametersBase& rhs)
+{
+	assert(false);
+}
+
+bool AlgorithmParametersBase::GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const
+{
+	if (strcmp(name, "ValueNames") == 0)
+	{
+		NameValuePairs::ThrowIfTypeMismatch(name, typeid(std::string), valueType);
+		if (m_next.get())
+		    m_next->GetVoidValue(name, valueType, pValue);
+		(*reinterpret_cast<std::string *>(pValue) += m_name) += ";";
+		return true;
+	}
+	else if (strcmp(name, m_name) == 0)
+	{
+		AssignValue(name, valueType, pValue);
+		m_used = true;
+		return true;
+	}
+	else if (m_next.get())
+		return m_next->GetVoidValue(name, valueType, pValue);
+	else
+	    return false;
+}
+
+AlgorithmParameters::AlgorithmParameters()
+	: m_defaultThrowIfNotUsed(true)
+{
+}
+
+AlgorithmParameters::AlgorithmParameters(const AlgorithmParameters &x)
+	: m_defaultThrowIfNotUsed(x.m_defaultThrowIfNotUsed)
+{
+	m_next.reset(const_cast<AlgorithmParameters &>(x).m_next.release());
+}
+
+AlgorithmParameters & AlgorithmParameters::operator=(const AlgorithmParameters &x)
+{
+	m_next.reset(const_cast<AlgorithmParameters &>(x).m_next.release());
+	return *this;
+}
+
+bool AlgorithmParameters::GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const
+{
+	if (m_next.get())
+		return m_next->GetVoidValue(name, valueType, pValue);
+	else
+		return false;
+}
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/basecode.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/basecode.cpp
index eb05a41a..0c98b227 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/src/basecode.cpp
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/basecode.cpp
@@ -1,228 +1,238 @@
-// basecode.cpp - written and placed in the public domain by Wei Dai
-
-////#include "pch.h"
-#include "basecode.h"
-#include "fltrimpl.h"
-#include <ctype.h>
-
-NAMESPACE_BEGIN(CryptoPP)
-
-void BaseN_Encoder::IsolatedInitialize(const NameValuePairs &parameters)
-{
-	parameters.GetRequiredParameter("BaseN_Encoder", "EncodingLookupArray", m_alphabet);
-
-	parameters.GetRequiredIntParameter("BaseN_Encoder", "Log2Base", m_bitsPerChar);
-	if (m_bitsPerChar <= 0 || m_bitsPerChar >= 8)
-		throw InvalidArgument("BaseN_Encoder: Log2Base must be between 1 and 7 inclusive");
-
-	byte padding;
-	bool pad;
-	if (parameters.GetValue("PaddingByte", padding))
-		pad = parameters.GetValueWithDefault("Pad", true);
-	else
-		pad = false;
-	m_padding = pad ? padding : -1;
-
-	m_bytePos = m_bitPos = 0;
-
-	int i = 8;
-	while (i%m_bitsPerChar != 0)
-		i += 8;
-	m_outputBlockSize = i/m_bitsPerChar;
-
-	m_outBuf.New(m_outputBlockSize);
-}
-
-unsigned int BaseN_Encoder::Put2(const byte *begin, unsigned int length, int messageEnd, bool blocking)
-{
-	FILTER_BEGIN;
-	while (m_inputPosition < length)
-	{
-		if (m_bytePos == 0)
-			memset(m_outBuf, 0, m_outputBlockSize);
-
-		{
-		unsigned int b = begin[m_inputPosition++], bitsLeftInSource = 8;
-		while (true)
-		{
-			assert(m_bitPos < m_bitsPerChar);
-			unsigned int bitsLeftInTarget = m_bitsPerChar-m_bitPos;
-			m_outBuf[m_bytePos] |= b >> (8-bitsLeftInTarget);
-			if (bitsLeftInSource >= bitsLeftInTarget)
-			{
-				m_bitPos = 0;
-				++m_bytePos;
-				bitsLeftInSource -= bitsLeftInTarget;
-				if (bitsLeftInSource == 0)
-					break;
-				b <<= bitsLeftInTarget;
-				b &= 0xff;
-			}
-			else
-			{
-				m_bitPos += bitsLeftInSource;
-				break;
-			}
-		}
-		}
-
-		assert(m_bytePos <= m_outputBlockSize);
-		if (m_bytePos == m_outputBlockSize)
-		{
-			int i;
-			for (i=0; i<m_bytePos; i++)
-			{
-				assert(m_outBuf[i] < (1 << m_bitsPerChar));
-				m_outBuf[i] = m_alphabet[m_outBuf[i]];
-			}
-			FILTER_OUTPUT(1, m_outBuf, m_outputBlockSize, 0);
-			
-			m_bytePos = m_bitPos = 0;
-		}
-	}
-	if (messageEnd)
-	{
-		if (m_bitPos > 0)
-			++m_bytePos;
-
-		int i;
-		for (i=0; i<m_bytePos; i++)
-			m_outBuf[i] = m_alphabet[m_outBuf[i]];
-
-		if (m_padding != -1 && m_bytePos > 0)
-		{
-			memset(m_outBuf+m_bytePos, m_padding, m_outputBlockSize-m_bytePos);
-			m_bytePos = m_outputBlockSize;
-		}
-		FILTER_OUTPUT(2, m_outBuf, m_bytePos, messageEnd);
-		m_bytePos = m_bitPos = 0;
-	}
-	FILTER_END_NO_MESSAGE_END;
-}
-
-void BaseN_Decoder::IsolatedInitialize(const NameValuePairs &parameters)
-{
-	parameters.GetRequiredParameter("BaseN_Decoder", "DecodingLookupArray", m_lookup);
-
-	parameters.GetRequiredIntParameter("BaseN_Decoder", "Log2Base", m_bitsPerChar);
-	if (m_bitsPerChar <= 0 || m_bitsPerChar >= 8)
-		throw InvalidArgument("BaseN_Decoder: Log2Base must be between 1 and 7 inclusive");
-
-	m_bytePos = m_bitPos = 0;
-
-	int i = m_bitsPerChar;
-	while (i%8 != 0)
-		i += m_bitsPerChar;
-	m_outputBlockSize = i/8;
-
-	m_outBuf.New(m_outputBlockSize);
-}
-
-unsigned int BaseN_Decoder::Put2(const byte *begin, unsigned int length, int messageEnd, bool blocking)
-{
-	FILTER_BEGIN;
-	while (m_inputPosition < length)
-	{
-		unsigned int value;
-		value = m_lookup[begin[m_inputPosition++]];
-		if (value >= 256)
-			continue;
-
-		if (m_bytePos == 0 && m_bitPos == 0)
-			memset(m_outBuf, 0, m_outputBlockSize);
-
-		{
-			int newBitPos = m_bitPos + m_bitsPerChar;
-			if (newBitPos <= 8)
-				m_outBuf[m_bytePos] |= value << (8-newBitPos);
-			else
-			{
-				m_outBuf[m_bytePos] |= value >> (newBitPos-8);
-				m_outBuf[m_bytePos+1] |= value << (16-newBitPos);
-			}
-
-			m_bitPos = newBitPos;
-			while (m_bitPos >= 8)
-			{
-				m_bitPos -= 8;
-				++m_bytePos;
-			}
-		}
-
-		if (m_bytePos == m_outputBlockSize)
-		{
-			FILTER_OUTPUT(1, m_outBuf, m_outputBlockSize, 0);
-			m_bytePos = m_bitPos = 0;
-		}
-	}
-	if (messageEnd)
-	{
-		FILTER_OUTPUT(2, m_outBuf, m_bytePos, messageEnd);
-		m_bytePos = m_bitPos = 0;
-	}
-	FILTER_END_NO_MESSAGE_END;
-}
-
-void BaseN_Decoder::InitializeDecodingLookupArray(int *lookup, const byte *alphabet, unsigned int base, bool caseInsensitive)
-{
-	std::fill(lookup, lookup+256, -1);
-
-	for (unsigned int i=0; i<base; i++)
-	{
-		if (caseInsensitive && isalpha(alphabet[i]))
-		{
-			assert(lookup[toupper(alphabet[i])] == -1);
-			lookup[toupper(alphabet[i])] = i;
-			assert(lookup[tolower(alphabet[i])] == -1);
-			lookup[tolower(alphabet[i])] = i;
-		}
-		else
-		{
-			assert(lookup[alphabet[i]] == -1);
-			lookup[alphabet[i]] = i;
-		}
-	}
-}
-
-void Grouper::IsolatedInitialize(const NameValuePairs &parameters)
-{
-	m_groupSize = parameters.GetIntValueWithDefault("GroupSize", 0);
-	ConstByteArrayParameter separator, terminator;
-	if (m_groupSize)
-		parameters.GetRequiredParameter("Grouper", "Separator", separator);
-	parameters.GetValue("Terminator", terminator);
-
-	m_separator.Assign(separator.begin(), separator.size());
-	m_terminator.Assign(terminator.begin(), terminator.size());
-	m_counter = 0;
-}
-
-unsigned int Grouper::Put2(const byte *begin, unsigned int length, int messageEnd, bool blocking)
-{
-	FILTER_BEGIN;
-	if (m_groupSize)
-	{
-		while (m_inputPosition < length)
-		{
-			if (m_counter == m_groupSize)
-			{
-				FILTER_OUTPUT(1, m_separator, m_separator.size(), 0);
-				m_counter = 0;
-			}
-
-			unsigned int len;
-			FILTER_OUTPUT2(2, len = STDMIN(length-m_inputPosition, m_groupSize-m_counter),
-				begin+m_inputPosition, len, 0);
-			m_inputPosition += len;
-			m_counter += len;
-		}
-	}
-	else
-		FILTER_OUTPUT(3, begin, length, 0);
-
-	if (messageEnd)
-		FILTER_OUTPUT(4, m_terminator, m_terminator.size(), messageEnd);
-	FILTER_END_NO_MESSAGE_END
-}
-
-NAMESPACE_END
+// basecode.cpp - written and placed in the public domain by Wei Dai
+
+#include "pch.h"
+
+#ifndef CRYPTOPP_IMPORTS
+
+#include "basecode.h"
+#include "fltrimpl.h"
+#include <ctype.h>
+
+NAMESPACE_BEGIN(CryptoPP)
+
+void BaseN_Encoder::IsolatedInitialize(const NameValuePairs &parameters)
+{
+	parameters.GetRequiredParameter("BaseN_Encoder", Name::EncodingLookupArray(), m_alphabet);
+
+	parameters.GetRequiredIntParameter("BaseN_Encoder", Name::Log2Base(), m_bitsPerChar);
+	if (m_bitsPerChar <= 0 || m_bitsPerChar >= 8)
+		throw InvalidArgument("BaseN_Encoder: Log2Base must be between 1 and 7 inclusive");
+
+	byte padding;
+	bool pad;
+	if (parameters.GetValue(Name::PaddingByte(), padding))
+		pad = parameters.GetValueWithDefault(Name::Pad(), true);
+	else
+		pad = false;
+	m_padding = pad ? padding : -1;
+
+	m_bytePos = m_bitPos = 0;
+
+	int i = 8;
+	while (i%m_bitsPerChar != 0)
+		i += 8;
+	m_outputBlockSize = i/m_bitsPerChar;
+
+	m_outBuf.New(m_outputBlockSize);
+}
+
+size_t BaseN_Encoder::Put2(const byte *begin, size_t length, int messageEnd, bool blocking)
+{
+	FILTER_BEGIN;
+	while (m_inputPosition < length)
+	{
+		if (m_bytePos == 0)
+			memset(m_outBuf, 0, m_outputBlockSize);
+
+		{
+		unsigned int b = begin[m_inputPosition++], bitsLeftInSource = 8;
+		while (true)
+		{
+			assert(m_bitPos < m_bitsPerChar);
+			unsigned int bitsLeftInTarget = m_bitsPerChar-m_bitPos;
+			m_outBuf[m_bytePos] |= b >> (8-bitsLeftInTarget);
+			if (bitsLeftInSource >= bitsLeftInTarget)
+			{
+				m_bitPos = 0;
+				++m_bytePos;
+				bitsLeftInSource -= bitsLeftInTarget;
+				if (bitsLeftInSource == 0)
+					break;
+				b <<= bitsLeftInTarget;
+				b &= 0xff;
+			}
+			else
+			{
+				m_bitPos += bitsLeftInSource;
+				break;
+			}
+		}
+		}
+
+		assert(m_bytePos <= m_outputBlockSize);
+		if (m_bytePos == m_outputBlockSize)
+		{
+			int i;
+			for (i=0; i<m_bytePos; i++)
+			{
+				assert(m_outBuf[i] < (1 << m_bitsPerChar));
+				m_outBuf[i] = m_alphabet[m_outBuf[i]];
+			}
+			FILTER_OUTPUT(1, m_outBuf, m_outputBlockSize, 0);
+			
+			m_bytePos = m_bitPos = 0;
+		}
+	}
+	if (messageEnd)
+	{
+		if (m_bitPos > 0)
+			++m_bytePos;
+
+		int i;
+		for (i=0; i<m_bytePos; i++)
+			m_outBuf[i] = m_alphabet[m_outBuf[i]];
+
+		if (m_padding != -1 && m_bytePos > 0)
+		{
+			memset(m_outBuf+m_bytePos, m_padding, m_outputBlockSize-m_bytePos);
+			m_bytePos = m_outputBlockSize;
+		}
+		FILTER_OUTPUT(2, m_outBuf, m_bytePos, messageEnd);
+		m_bytePos = m_bitPos = 0;
+	}
+	FILTER_END_NO_MESSAGE_END;
+}
+
+void BaseN_Decoder::IsolatedInitialize(const NameValuePairs &parameters)
+{
+	parameters.GetRequiredParameter("BaseN_Decoder", Name::DecodingLookupArray(), m_lookup);
+
+	parameters.GetRequiredIntParameter("BaseN_Decoder", Name::Log2Base(), m_bitsPerChar);
+	if (m_bitsPerChar <= 0 || m_bitsPerChar >= 8)
+		throw InvalidArgument("BaseN_Decoder: Log2Base must be between 1 and 7 inclusive");
+
+	m_bytePos = m_bitPos = 0;
+
+	int i = m_bitsPerChar;
+	while (i%8 != 0)
+		i += m_bitsPerChar;
+	m_outputBlockSize = i/8;
+
+	m_outBuf.New(m_outputBlockSize);
+}
+
+size_t BaseN_Decoder::Put2(const byte *begin, size_t length, int messageEnd, bool blocking)
+{
+	FILTER_BEGIN;
+	while (m_inputPosition < length)
+	{
+		unsigned int value;
+		value = m_lookup[begin[m_inputPosition++]];
+		if (value >= 256)
+			continue;
+
+		if (m_bytePos == 0 && m_bitPos == 0)
+			memset(m_outBuf, 0, m_outputBlockSize);
+
+		{
+			int newBitPos = m_bitPos + m_bitsPerChar;
+			if (newBitPos <= 8)
+				m_outBuf[m_bytePos] |= value << (8-newBitPos);
+			else
+			{
+				m_outBuf[m_bytePos] |= value >> (newBitPos-8);
+				m_outBuf[m_bytePos+1] |= value << (16-newBitPos);
+			}
+
+			m_bitPos = newBitPos;
+			while (m_bitPos >= 8)
+			{
+				m_bitPos -= 8;
+				++m_bytePos;
+			}
+		}
+
+		if (m_bytePos == m_outputBlockSize)
+		{
+			FILTER_OUTPUT(1, m_outBuf, m_outputBlockSize, 0);
+			m_bytePos = m_bitPos = 0;
+		}
+	}
+	if (messageEnd)
+	{
+		FILTER_OUTPUT(2, m_outBuf, m_bytePos, messageEnd);
+		m_bytePos = m_bitPos = 0;
+	}
+	FILTER_END_NO_MESSAGE_END;
+}
+
+void BaseN_Decoder::InitializeDecodingLookupArray(int *lookup, const byte *alphabet, unsigned int base, bool caseInsensitive)
+{
+	std::fill(lookup, lookup+256, -1);
+
+	for (unsigned int i=0; i<base; i++)
+	{
+		if (caseInsensitive && isalpha(alphabet[i]))
+		{
+			assert(lookup[toupper(alphabet[i])] == -1);
+			lookup[toupper(alphabet[i])] = i;
+			assert(lookup[tolower(alphabet[i])] == -1);
+			lookup[tolower(alphabet[i])] = i;
+		}
+		else
+		{
+			assert(lookup[alphabet[i]] == -1);
+			lookup[alphabet[i]] = i;
+		}
+	}
+}
+
+void Grouper::IsolatedInitialize(const NameValuePairs &parameters)
+{
+	m_groupSize = parameters.GetIntValueWithDefault(Name::GroupSize(), 0);
+	ConstByteArrayParameter separator, terminator;
+	if (m_groupSize)
+		parameters.GetRequiredParameter("Grouper", Name::Separator(), separator);
+	else
+		parameters.GetValue(Name::Separator(), separator);
+	parameters.GetValue(Name::Terminator(), terminator);
+
+	m_separator.Assign(separator.begin(), separator.size());
+	m_terminator.Assign(terminator.begin(), terminator.size());
+	m_counter = 0;
+}
+
+size_t Grouper::Put2(const byte *begin, size_t length, int messageEnd, bool blocking)
+{
+	FILTER_BEGIN;
+	if (m_groupSize)
+	{
+		while (m_inputPosition < length)
+		{
+			if (m_counter == m_groupSize)
+			{
+				FILTER_OUTPUT(1, m_separator, m_separator.size(), 0);
+				m_counter = 0;
+			}
+
+			size_t len;
+			FILTER_OUTPUT2(2, len = STDMIN(length-m_inputPosition, m_groupSize-m_counter),
+				begin+m_inputPosition, len, 0);
+			m_inputPosition += len;
+			m_counter += len;
+		}
+	}
+	else
+		FILTER_OUTPUT(3, begin, length, 0);
+
+	if (messageEnd)
+	{
+		FILTER_OUTPUT(4, m_terminator, m_terminator.size(), messageEnd);
+		m_counter = 0;
+	}
+	FILTER_END_NO_MESSAGE_END
+}
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/cpu.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/cpu.cpp
new file mode 100644
index 00000000..3610a7c8
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/cpu.cpp
@@ -0,0 +1,199 @@
+// cpu.cpp - written and placed in the public domain by Wei Dai
+
+#include "pch.h"
+
+#ifndef CRYPTOPP_IMPORTS
+
+#include "cpu.h"
+#include "misc.h"
+#include <algorithm>
+
+#ifndef CRYPTOPP_MS_STYLE_INLINE_ASSEMBLY
+#include <signal.h>
+#include <setjmp.h>
+#endif
+
+#if CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE
+#include <emmintrin.h>
+#endif
+
+NAMESPACE_BEGIN(CryptoPP)
+
+#ifdef CRYPTOPP_CPUID_AVAILABLE
+
+#if _MSC_VER >= 1400 && CRYPTOPP_BOOL_X64
+
+bool CpuId(word32 input, word32 *output)
+{
+	__cpuid((int *)output, input);
+	return true;
+}
+
+#else
+
+#ifndef CRYPTOPP_MS_STYLE_INLINE_ASSEMBLY
+extern "C" {
+typedef void (*SigHandler)(int);
+
+static jmp_buf s_jmpNoCPUID;
+static void SigIllHandlerCPUID(int)
+{
+	longjmp(s_jmpNoCPUID, 1);
+}
+
+static jmp_buf s_jmpNoSSE2;
+static void SigIllHandlerSSE2(int)
+{
+	longjmp(s_jmpNoSSE2, 1);
+}
+}
+#endif
+
+bool CpuId(word32 input, word32 *output)
+{
+#ifdef CRYPTOPP_MS_STYLE_INLINE_ASSEMBLY
+    __try
+	{
+		__asm
+		{
+			mov eax, input
+			cpuid
+			mov edi, output
+			mov [edi], eax
+			mov [edi+4], ebx
+			mov [edi+8], ecx
+			mov [edi+12], edx
+		}
+	}
+    __except (1)
+	{
+		return false;
+    }
+	return true;
+#else
+	SigHandler oldHandler = signal(SIGILL, SigIllHandlerCPUID);
+	if (oldHandler == SIG_ERR)
+		return false;
+
+	bool result = true;
+	if (setjmp(s_jmpNoCPUID))
+		result = false;
+	else
+	{
+		asm
+		(
+			// save ebx in case -fPIC is being used
+#if CRYPTOPP_BOOL_X86
+			"push %%ebx; cpuid; mov %%ebx, %%edi; pop %%ebx"
+#else
+			"pushq %%rbx; cpuid; mov %%ebx, %%edi; popq %%rbx"
+#endif
+			: "=a" (output[0]), "=D" (output[1]), "=c" (output[2]), "=d" (output[3])
+			: "a" (input)
+		);
+	}
+
+	signal(SIGILL, oldHandler);
+	return result;
+#endif
+}
+
+#endif
+
+static bool TrySSE2()
+{
+#if CRYPTOPP_BOOL_X64
+	return true;
+#elif defined(CRYPTOPP_MS_STYLE_INLINE_ASSEMBLY)
+    __try
+	{
+#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE
+        AS2(por xmm0, xmm0)        // executing SSE2 instruction
+#elif CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE
+		__m128i x = _mm_setzero_si128();
+		return _mm_cvtsi128_si32(x) == 0;
+#endif
+	}
+    __except (1)
+	{
+		return false;
+    }
+	return true;
+#else
+	SigHandler oldHandler = signal(SIGILL, SigIllHandlerSSE2);
+	if (oldHandler == SIG_ERR)
+		return false;
+
+	bool result = true;
+	if (setjmp(s_jmpNoSSE2))
+		result = false;
+	else
+	{
+#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE
+		__asm __volatile ("por %xmm0, %xmm0");
+#elif CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE
+		__m128i x = _mm_setzero_si128();
+		result = _mm_cvtsi128_si32(x) == 0;
+#endif
+	}
+
+	signal(SIGILL, oldHandler);
+	return result;
+#endif
+}
+
+bool g_x86DetectionDone = false;
+bool g_hasISSE = false, g_hasSSE2 = false, g_hasSSSE3 = false, g_hasMMX = false, g_hasAESNI = false, g_hasCLMUL = false, g_isP4 = false;
+word32 g_cacheLineSize = CRYPTOPP_L1_CACHE_LINE_SIZE;
+
+void DetectX86Features()
+{
+	word32 cpuid[4], cpuid1[4];
+	if (!CpuId(0, cpuid))
+		return;
+	if (!CpuId(1, cpuid1))
+		return;
+
+	g_hasMMX = (cpuid1[3] & (1 << 23)) != 0;
+	if ((cpuid1[3] & (1 << 26)) != 0)
+		g_hasSSE2 = TrySSE2();
+	g_hasSSSE3 = g_hasSSE2 && (cpuid1[2] & (1<<9));
+	g_hasAESNI = g_hasSSE2 && (cpuid1[2] & (1<<25));
+	g_hasCLMUL = g_hasSSE2 && (cpuid1[2] & (1<<1));
+
+	if ((cpuid1[3] & (1 << 25)) != 0)
+		g_hasISSE = true;
+	else
+	{
+		word32 cpuid2[4];
+		CpuId(0x080000000, cpuid2);
+		if (cpuid2[0] >= 0x080000001)
+		{
+			CpuId(0x080000001, cpuid2);
+			g_hasISSE = (cpuid2[3] & (1 << 22)) != 0;
+		}
+	}
+
+	std::swap(cpuid[2], cpuid[3]);
+	if (memcmp(cpuid+1, "GenuineIntel", 12) == 0)
+	{
+		g_isP4 = ((cpuid1[0] >> 8) & 0xf) == 0xf;
+		g_cacheLineSize = 8 * GETBYTE(cpuid1[1], 1);
+	}
+	else if (memcmp(cpuid+1, "AuthenticAMD", 12) == 0)
+	{
+		CpuId(0x80000005, cpuid);
+		g_cacheLineSize = GETBYTE(cpuid[2], 0);
+	}
+
+	if (!g_cacheLineSize)
+		g_cacheLineSize = CRYPTOPP_L1_CACHE_LINE_SIZE;
+
+	g_x86DetectionDone = true;
+}
+
+#endif
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/cryptlib.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/cryptlib.cpp
index de0de475..df138ddb 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/src/cryptlib.cpp
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/cryptlib.cpp
@@ -1,690 +1,828 @@
-// cryptlib.cpp - written and placed in the public domain by Wei Dai
-
-//#include "pch.h"
-#include "cryptlib.h"
-#include "misc.h"
-#include "filters.h"
-#include "algparam.h"
-//#include "fips140.h"
-#include "argnames.h"
-
-#include <memory>
-
-NAMESPACE_BEGIN(CryptoPP)
-
-CRYPTOPP_COMPILE_ASSERT(sizeof(byte) == 1);
-CRYPTOPP_COMPILE_ASSERT(sizeof(word16) == 2);
-CRYPTOPP_COMPILE_ASSERT(sizeof(word32) == 4);
-#ifdef WORD64_AVAILABLE
-CRYPTOPP_COMPILE_ASSERT(sizeof(word64) == 8);
-#endif
-CRYPTOPP_COMPILE_ASSERT(sizeof(dword) == 2*sizeof(word));
-
-const std::string BufferedTransformation::NULL_CHANNEL;
-const NullNameValuePairs g_nullNameValuePairs;
-
-BufferedTransformation & TheBitBucket()
-{
-	static BitBucket bitBucket;
-	return bitBucket;
-}
-
-Algorithm::Algorithm(bool checkSelfTestStatus)
-{
-	
-    /* disabled
-    if (checkSelfTestStatus && FIPS_140_2_ComplianceEnabled())
-	{
-		if (GetPowerUpSelfTestStatus() == POWER_UP_SELF_TEST_NOT_DONE && !PowerUpSelfTestInProgressOnThisThread())
-			throw SelfTestFailure("Cryptographic algorithms are disabled before the power-up self tests are performed.");
-
-		if (GetPowerUpSelfTestStatus() == POWER_UP_SELF_TEST_FAILED)
-			throw SelfTestFailure("Cryptographic algorithms are disabled after power-up a self test failed.");
-	}
-    */
-}
-
-void SimpleKeyingInterface::SetKeyWithRounds(const byte *key, unsigned int length, int rounds)
-{
-	SetKey(key, length, MakeParameters(Name::Rounds(), rounds));
-}
-
-void SimpleKeyingInterface::SetKeyWithIV(const byte *key, unsigned int length, const byte *iv)
-{
-	SetKey(key, length, MakeParameters(Name::IV(), iv));
-}
-
-void SimpleKeyingInterface::ThrowIfInvalidKeyLength(const Algorithm &algorithm, unsigned int length)
-{
-	if (!IsValidKeyLength(length))
-		throw InvalidKeyLength(algorithm.AlgorithmName(), length);
-}
-
-void BlockTransformation::ProcessAndXorMultipleBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, unsigned int numberOfBlocks) const
-{
-	unsigned int blockSize = BlockSize();
-	while (numberOfBlocks--)
-	{
-		ProcessAndXorBlock(inBlocks, xorBlocks, outBlocks);
-		inBlocks += blockSize;
-		outBlocks += blockSize;
-		if (xorBlocks)
-			xorBlocks += blockSize;
-	}
-}
-
-void StreamTransformation::ProcessLastBlock(byte *outString, const byte *inString, unsigned int length)
-{
-	assert(MinLastBlockSize() == 0);	// this function should be overriden otherwise
-
-	if (length == MandatoryBlockSize())
-		ProcessData(outString, inString, length);
-	else if (length != 0)
-		throw NotImplemented("StreamTransformation: this object does't support a special last block");
-}
-
-unsigned int RandomNumberGenerator::GenerateBit()
-{
-	return Parity(GenerateByte());
-}
-
-void RandomNumberGenerator::GenerateBlock(byte *output, unsigned int size)
-{
-	while (size--)
-		*output++ = GenerateByte();
-}
-
-word32 RandomNumberGenerator::GenerateWord32(word32 min, word32 max)
-{
-	word32 range = max-min;
-	const int maxBytes = BytePrecision(range);
-	const int maxBits = BitPrecision(range);
-
-	word32 value;
-
-	do
-	{
-		value = 0;
-		for (int i=0; i<maxBytes; i++)
-			value = (value << 8) | GenerateByte();
-
-		value = Crop(value, maxBits);
-	} while (value > range);
-
-	return value+min;
-}
-
-void RandomNumberGenerator::DiscardBytes(unsigned int n)
-{
-	while (n--)
-		GenerateByte();
-}
-
-RandomNumberGenerator & NullRNG()
-{
-	class NullRNG : public RandomNumberGenerator
-	{
-	public:
-		std::string AlgorithmName() const {return "NullRNG";}
-		byte GenerateByte() {throw NotImplemented("NullRNG: NullRNG should only be passed to functions that don't need to generate random bytes");}
-	};
-
-	static NullRNG s_nullRNG;
-	return s_nullRNG;
-}
-
-bool HashTransformation::TruncatedVerify(const byte *digestIn, unsigned int digestLength)
-{
-	ThrowIfInvalidTruncatedSize(digestLength);
-	SecByteBlock digest(digestLength);
-	TruncatedFinal(digest, digestLength);
-	return memcmp(digest, digestIn, digestLength) == 0;
-}
-
-void HashTransformation::ThrowIfInvalidTruncatedSize(unsigned int size) const
-{
-	if (size > DigestSize())
-		throw InvalidArgument("HashTransformation: can't truncate a " + IntToString(DigestSize()) + " byte digest to " + IntToString(size) + " bytes");
-}
-
-unsigned int BufferedTransformation::GetMaxWaitObjectCount() const
-{
-	const BufferedTransformation *t = AttachedTransformation();
-	return t ? t->GetMaxWaitObjectCount() : 0;
-}
-
-void BufferedTransformation::GetWaitObjects(WaitObjectContainer &container)
-{
-	BufferedTransformation *t = AttachedTransformation();
-	if (t)
-		t->GetWaitObjects(container);
-}
-
-void BufferedTransformation::Initialize(const NameValuePairs &parameters, int propagation)
-{
-	assert(!AttachedTransformation());
-	IsolatedInitialize(parameters);
-}
-
-bool BufferedTransformation::Flush(bool hardFlush, int propagation, bool blocking)
-{
-	assert(!AttachedTransformation());
-	return IsolatedFlush(hardFlush, blocking);
-}
-
-bool BufferedTransformation::MessageSeriesEnd(int propagation, bool blocking)
-{
-	assert(!AttachedTransformation());
-	return IsolatedMessageSeriesEnd(blocking);
-}
-
-byte * BufferedTransformation::ChannelCreatePutSpace(const std::string &channel, unsigned int &size)
-{
-	if (channel.empty())
-		return CreatePutSpace(size);
-	else
-		throw NoChannelSupport();
-}
-
-unsigned int BufferedTransformation::ChannelPut2(const std::string &channel, const byte *begin, unsigned int length, int messageEnd, bool blocking)
-{
-	if (channel.empty())
-		return Put2(begin, length, messageEnd, blocking);
-	else
-		throw NoChannelSupport();
-}
-
-unsigned int BufferedTransformation::ChannelPutModifiable2(const std::string &channel, byte *begin, unsigned int length, int messageEnd, bool blocking)
-{
-	if (channel.empty())
-		return PutModifiable2(begin, length, messageEnd, blocking);
-	else
-		return ChannelPut2(channel, begin, length, messageEnd, blocking);
-}
-
-void BufferedTransformation::ChannelInitialize(const std::string &channel, const NameValuePairs &parameters, int propagation)
-{
-	if (channel.empty())
-		Initialize(parameters, propagation);
-	else
-		throw NoChannelSupport();
-}
-
-bool BufferedTransformation::ChannelFlush(const std::string &channel, bool completeFlush, int propagation, bool blocking)
-{
-	if (channel.empty())
-		return Flush(completeFlush, propagation, blocking);
-	else
-		throw NoChannelSupport();
-}
-
-bool BufferedTransformation::ChannelMessageSeriesEnd(const std::string &channel, int propagation, bool blocking)
-{
-	if (channel.empty())
-		return MessageSeriesEnd(propagation, blocking);
-	else
-		throw NoChannelSupport();
-}
-
-unsigned long BufferedTransformation::MaxRetrievable() const
-{
-	if (AttachedTransformation())
-		return AttachedTransformation()->MaxRetrievable();
-	else
-		return CopyTo(TheBitBucket());
-}
-
-bool BufferedTransformation::AnyRetrievable() const
-{
-	if (AttachedTransformation())
-		return AttachedTransformation()->AnyRetrievable();
-	else
-	{
-		byte b;
-		return Peek(b) != 0;
-	}
-}
-
-unsigned int BufferedTransformation::Get(byte &outByte)
-{
-	if (AttachedTransformation())
-		return AttachedTransformation()->Get(outByte);
-	else
-		return Get(&outByte, 1);
-}
-
-unsigned int BufferedTransformation::Get(byte *outString, unsigned int getMax)
-{
-	if (AttachedTransformation())
-		return AttachedTransformation()->Get(outString, getMax);
-	else
-	{
-		ArraySink arraySink(outString, getMax);
-		return TransferTo(arraySink, getMax);
-	}
-}
-
-unsigned int BufferedTransformation::Peek(byte &outByte) const
-{
-	if (AttachedTransformation())
-		return AttachedTransformation()->Peek(outByte);
-	else
-		return Peek(&outByte, 1);
-}
-
-unsigned int BufferedTransformation::Peek(byte *outString, unsigned int peekMax) const
-{
-	if (AttachedTransformation())
-		return AttachedTransformation()->Peek(outString, peekMax);
-	else
-	{
-		ArraySink arraySink(outString, peekMax);
-		return CopyTo(arraySink, peekMax);
-	}
-}
-
-unsigned long BufferedTransformation::Skip(unsigned long skipMax)
-{
-	if (AttachedTransformation())
-		return AttachedTransformation()->Skip(skipMax);
-	else
-		return TransferTo(TheBitBucket(), skipMax);
-}
-
-unsigned long BufferedTransformation::TotalBytesRetrievable() const
-{
-	if (AttachedTransformation())
-		return AttachedTransformation()->TotalBytesRetrievable();
-	else
-		return MaxRetrievable();
-}
-
-unsigned int BufferedTransformation::NumberOfMessages() const
-{
-	if (AttachedTransformation())
-		return AttachedTransformation()->NumberOfMessages();
-	else
-		return CopyMessagesTo(TheBitBucket());
-}
-
-bool BufferedTransformation::AnyMessages() const
-{
-	if (AttachedTransformation())
-		return AttachedTransformation()->AnyMessages();
-	else
-		return NumberOfMessages() != 0;
-}
-
-bool BufferedTransformation::GetNextMessage()
-{
-	if (AttachedTransformation())
-		return AttachedTransformation()->GetNextMessage();
-	else
-	{
-		assert(!AnyMessages());
-		return false;
-	}
-}
-
-unsigned int BufferedTransformation::SkipMessages(unsigned int count)
-{
-	if (AttachedTransformation())
-		return AttachedTransformation()->SkipMessages(count);
-	else
-		return TransferMessagesTo(TheBitBucket(), count);
-}
-
-unsigned int BufferedTransformation::TransferMessagesTo2(BufferedTransformation &target, unsigned int &messageCount, const std::string &channel, bool blocking)
-{
-	if (AttachedTransformation())
-		return AttachedTransformation()->TransferMessagesTo2(target, messageCount, channel, blocking);
-	else
-	{
-		unsigned int maxMessages = messageCount;
-		for (messageCount=0; messageCount < maxMessages && AnyMessages(); messageCount++)
-		{
-			unsigned int blockedBytes;
-			unsigned long transferedBytes;
-
-			while (AnyRetrievable())
-			{
-				transferedBytes = ULONG_MAX;
-				blockedBytes = TransferTo2(target, transferedBytes, channel, blocking);
-				if (blockedBytes > 0)
-					return blockedBytes;
-			}
-
-			if (target.ChannelMessageEnd(channel, GetAutoSignalPropagation(), blocking))
-				return 1;
-
-			bool result = GetNextMessage();
-			assert(result);
-		}
-		return 0;
-	}
-}
-
-unsigned int BufferedTransformation::CopyMessagesTo(BufferedTransformation &target, unsigned int count, const std::string &channel) const
-{
-	if (AttachedTransformation())
-		return AttachedTransformation()->CopyMessagesTo(target, count, channel);
-	else
-		return 0;
-}
-
-void BufferedTransformation::SkipAll()
-{
-	if (AttachedTransformation())
-		AttachedTransformation()->SkipAll();
-	else
-	{
-		while (SkipMessages()) {}
-		while (Skip()) {}
-	}
-}
-
-unsigned int BufferedTransformation::TransferAllTo2(BufferedTransformation &target, const std::string &channel, bool blocking)
-{
-	if (AttachedTransformation())
-		return AttachedTransformation()->TransferAllTo2(target, channel, blocking);
-	else
-	{
-		assert(!NumberOfMessageSeries());
-
-		unsigned int messageCount;
-		do
-		{
-			messageCount = UINT_MAX;
-			unsigned int blockedBytes = TransferMessagesTo2(target, messageCount, channel, blocking);
-			if (blockedBytes)
-				return blockedBytes;
-		}
-		while (messageCount != 0);
-
-		unsigned long byteCount;
-		do
-		{
-			byteCount = ULONG_MAX;
-			unsigned int blockedBytes = TransferTo2(target, byteCount, channel, blocking);
-			if (blockedBytes)
-				return blockedBytes;
-		}
-		while (byteCount != 0);
-
-		return 0;
-	}
-}
-
-void BufferedTransformation::CopyAllTo(BufferedTransformation &target, const std::string &channel) const
-{
-	if (AttachedTransformation())
-		AttachedTransformation()->CopyAllTo(target, channel);
-	else
-	{
-		assert(!NumberOfMessageSeries());
-		while (CopyMessagesTo(target, UINT_MAX, channel)) {}
-	}
-}
-
-void BufferedTransformation::SetRetrievalChannel(const std::string &channel)
-{
-	if (AttachedTransformation())
-		AttachedTransformation()->SetRetrievalChannel(channel);
-}
-
-unsigned int BufferedTransformation::ChannelPutWord16(const std::string &channel, word16 value, ByteOrder order, bool blocking)
-{
-	FixedSizeSecBlock<byte, 2> buf;
-	PutWord(false, order, buf, value);
-	return ChannelPut(channel, buf, 2, blocking);
-}
-
-unsigned int BufferedTransformation::ChannelPutWord32(const std::string &channel, word32 value, ByteOrder order, bool blocking)
-{
-	FixedSizeSecBlock<byte, 4> buf;
-	PutWord(false, order, buf, value);
-	return ChannelPut(channel, buf, 4, blocking);
-}
-
-unsigned int BufferedTransformation::PutWord16(word16 value, ByteOrder order, bool blocking)
-{
-	return ChannelPutWord16(NULL_CHANNEL, value, order, blocking);
-}
-
-unsigned int BufferedTransformation::PutWord32(word32 value, ByteOrder order, bool blocking)
-{
-	return ChannelPutWord32(NULL_CHANNEL, value, order, blocking);
-}
-
-unsigned int BufferedTransformation::PeekWord16(word16 &value, ByteOrder order)
-{
-	byte buf[2] = {0, 0};
-	unsigned int len = Peek(buf, 2);
-
-	if (order)
-		value = (buf[0] << 8) | buf[1];
-	else
-		value = (buf[1] << 8) | buf[0];
-
-	return len;
-}
-
-unsigned int BufferedTransformation::PeekWord32(word32 &value, ByteOrder order)
-{
-	byte buf[4] = {0, 0, 0, 0};
-	unsigned int len = Peek(buf, 4);
-
-	if (order)
-		value = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf [3];
-	else
-		value = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf [0];
-
-	return len;
-}
-
-unsigned int BufferedTransformation::GetWord16(word16 &value, ByteOrder order)
-{
-	return Skip(PeekWord16(value, order));
-}
-
-unsigned int BufferedTransformation::GetWord32(word32 &value, ByteOrder order)
-{
-	return Skip(PeekWord32(value, order));
-}
-
-void BufferedTransformation::Attach(BufferedTransformation *newOut)
-{
-	if (AttachedTransformation() && AttachedTransformation()->Attachable())
-		AttachedTransformation()->Attach(newOut);
-	else
-		Detach(newOut);
-}
-
-void GeneratableCryptoMaterial::GenerateRandomWithKeySize(RandomNumberGenerator &rng, unsigned int keySize)
-{
-	GenerateRandom(rng, MakeParameters("KeySize", (int)keySize));
-}
-
-BufferedTransformation * PK_Encryptor::CreateEncryptionFilter(RandomNumberGenerator &rng, BufferedTransformation *attachment) const
-{
-	struct EncryptionFilter : public Unflushable<FilterWithInputQueue>
-	{
-		// VC60 complains if this function is missing
-		EncryptionFilter(const EncryptionFilter &x) : Unflushable<FilterWithInputQueue>(NULL), m_rng(x.m_rng), m_encryptor(x.m_encryptor) {}
-
-		EncryptionFilter(RandomNumberGenerator &rng, const PK_Encryptor &encryptor, BufferedTransformation *attachment)
-			: Unflushable<FilterWithInputQueue>(attachment), m_rng(rng), m_encryptor(encryptor)
-		{
-		}
-
-		bool IsolatedMessageEnd(bool blocking)
-		{
-			switch (m_continueAt)
-			{
-			case 0:
-				{
-				unsigned int plaintextLength = m_inQueue.CurrentSize();
-				m_ciphertextLength = m_encryptor.CiphertextLength(plaintextLength);
-
-				SecByteBlock plaintext(plaintextLength);
-				m_inQueue.Get(plaintext, plaintextLength);
-				m_ciphertext.resize(m_ciphertextLength);
-				m_encryptor.Encrypt(m_rng, plaintext, plaintextLength, m_ciphertext);
-				}
-
-			case 1:
-				if (!Output(1, m_ciphertext, m_ciphertextLength, 0, blocking))
-					return false;
-			};
-			return true;
-		}
-
-		RandomNumberGenerator &m_rng;
-		const PK_Encryptor &m_encryptor;
-		unsigned int m_ciphertextLength;
-		SecByteBlock m_ciphertext;
-	};
-
-	return new EncryptionFilter(rng, *this, attachment);
-}
-
-BufferedTransformation * PK_Decryptor::CreateDecryptionFilter(RandomNumberGenerator &rng, BufferedTransformation *attachment) const
-{
-	struct DecryptionFilter : public Unflushable<FilterWithInputQueue>
-	{
-		// VC60 complains if this function is missing
-		DecryptionFilter(const DecryptionFilter &x) : Unflushable<FilterWithInputQueue>(NULL), m_rng(x.m_rng), m_decryptor(x.m_decryptor) {}
-
-		DecryptionFilter(RandomNumberGenerator &rng, const PK_Decryptor &decryptor, BufferedTransformation *attachment)
-			: Unflushable<FilterWithInputQueue>(attachment), m_rng(rng), m_decryptor(decryptor)
-		{
-		}
-
-		bool IsolatedMessageEnd(bool blocking)
-		{
-			switch (m_continueAt)
-			{
-			case 0:
-				{
-				unsigned int ciphertextLength = m_inQueue.CurrentSize();
-				unsigned int maxPlaintextLength = m_decryptor.MaxPlaintextLength(ciphertextLength);
-
-				SecByteBlock ciphertext(ciphertextLength);
-				m_inQueue.Get(ciphertext, ciphertextLength);
-				m_plaintext.resize(maxPlaintextLength);
-				m_result = m_decryptor.Decrypt(m_rng, ciphertext, ciphertextLength, m_plaintext);
-				if (!m_result.isValidCoding)
-					throw InvalidCiphertext(m_decryptor.AlgorithmName() + ": invalid ciphertext");
-				}
-
-			case 1:
-				if (!Output(1, m_plaintext, m_result.messageLength, 0, blocking))
-					return false;
-			}
-			return true;
-		}
-
-		RandomNumberGenerator &m_rng;
-		const PK_Decryptor &m_decryptor;
-		SecByteBlock m_plaintext;
-		DecodingResult m_result;
-	};
-
-	return new DecryptionFilter(rng, *this, attachment);
-}
-
-unsigned int PK_FixedLengthCryptoSystem::MaxPlaintextLength(unsigned int cipherTextLength) const
-{
-	if (cipherTextLength == FixedCiphertextLength())
-		return FixedMaxPlaintextLength();
-	else
-		return 0;
-}
-
-unsigned int PK_FixedLengthCryptoSystem::CiphertextLength(unsigned int plainTextLength) const
-{
-	if (plainTextLength <= FixedMaxPlaintextLength())
-		return FixedCiphertextLength();
-	else
-		return 0;
-}
-
-DecodingResult PK_FixedLengthDecryptor::Decrypt(RandomNumberGenerator &rng, const byte *cipherText, unsigned int cipherTextLength, byte *plainText) const
-{
-	if (cipherTextLength != FixedCiphertextLength())
-		return DecodingResult();
-
-	return FixedLengthDecrypt(rng, cipherText, plainText);
-}
-
-unsigned int PK_Signer::Sign(RandomNumberGenerator &rng, PK_MessageAccumulator *messageAccumulator, byte *signature) const
-{
-	std::auto_ptr<PK_MessageAccumulator> m(messageAccumulator);
-	return SignAndRestart(rng, *m, signature, false);
-}
-
-unsigned int PK_Signer::SignMessage(RandomNumberGenerator &rng, const byte *message, unsigned int messageLen, byte *signature) const
-{
-	std::auto_ptr<PK_MessageAccumulator> m(NewSignatureAccumulator(rng));
-	m->Update(message, messageLen);
-	return SignAndRestart(rng, *m, signature, false);
-}
-
-unsigned int PK_Signer::SignMessageWithRecovery(RandomNumberGenerator &rng, const byte *recoverableMessage, unsigned int recoverableMessageLength, 
-	const byte *nonrecoverableMessage, unsigned int nonrecoverableMessageLength, byte *signature) const
-{
-	std::auto_ptr<PK_MessageAccumulator> m(NewSignatureAccumulator(rng));
-	InputRecoverableMessage(*m, recoverableMessage, recoverableMessageLength);
-	m->Update(nonrecoverableMessage, nonrecoverableMessageLength);
-	return SignAndRestart(rng, *m, signature, false);
-}
-
-bool PK_Verifier::Verify(PK_MessageAccumulator *messageAccumulator) const
-{
-	std::auto_ptr<PK_MessageAccumulator> m(messageAccumulator);
-	return VerifyAndRestart(*m);
-}
-
-bool PK_Verifier::VerifyMessage(const byte *message, unsigned int messageLen, const byte *signature, unsigned int signatureLength) const
-{
-	std::auto_ptr<PK_MessageAccumulator> m(NewVerificationAccumulator());
-	InputSignature(*m, signature, signatureLength);
-	m->Update(message, messageLen);
-	return VerifyAndRestart(*m);
-}
-
-DecodingResult PK_Verifier::Recover(byte *recoveredMessage, PK_MessageAccumulator *messageAccumulator) const
-{
-	std::auto_ptr<PK_MessageAccumulator> m(messageAccumulator);
-	return RecoverAndRestart(recoveredMessage, *m);
-}
-
-DecodingResult PK_Verifier::RecoverMessage(byte *recoveredMessage, 
-	const byte *nonrecoverableMessage, unsigned int nonrecoverableMessageLength, 
-	const byte *signature, unsigned int signatureLength) const
-{
-	std::auto_ptr<PK_MessageAccumulator> m(NewVerificationAccumulator());
-	InputSignature(*m, signature, signatureLength);
-	m->Update(nonrecoverableMessage, nonrecoverableMessageLength);
-	return RecoverAndRestart(recoveredMessage, *m);
-}
-
-void SimpleKeyAgreementDomain::GenerateKeyPair(RandomNumberGenerator &rng, byte *privateKey, byte *publicKey) const
-{
-	GeneratePrivateKey(rng, privateKey);
-	GeneratePublicKey(rng, privateKey, publicKey);
-}
-
-void AuthenticatedKeyAgreementDomain::GenerateStaticKeyPair(RandomNumberGenerator &rng, byte *privateKey, byte *publicKey) const
-{
-	GenerateStaticPrivateKey(rng, privateKey);
-	GenerateStaticPublicKey(rng, privateKey, publicKey);
-}
-
-void AuthenticatedKeyAgreementDomain::GenerateEphemeralKeyPair(RandomNumberGenerator &rng, byte *privateKey, byte *publicKey) const
-{
-	GenerateEphemeralPrivateKey(rng, privateKey);
-	GenerateEphemeralPublicKey(rng, privateKey, publicKey);
-}
-
-NAMESPACE_END
+// cryptlib.cpp - written and placed in the public domain by Wei Dai
+
+#include "pch.h"
+
+#ifndef CRYPTOPP_IMPORTS
+
+#include "cryptlib.h"
+#include "misc.h"
+#include "filters.h"
+#include "algparam.h"
+#include "fips140.h"
+#include "argnames.h"
+#include "fltrimpl.h"
+#include "trdlocal.h"
+#include "osrng.h"
+
+#include <memory>
+
+NAMESPACE_BEGIN(CryptoPP)
+
+CRYPTOPP_COMPILE_ASSERT(sizeof(byte) == 1);
+CRYPTOPP_COMPILE_ASSERT(sizeof(word16) == 2);
+CRYPTOPP_COMPILE_ASSERT(sizeof(word32) == 4);
+CRYPTOPP_COMPILE_ASSERT(sizeof(word64) == 8);
+#ifdef CRYPTOPP_NATIVE_DWORD_AVAILABLE
+CRYPTOPP_COMPILE_ASSERT(sizeof(dword) == 2*sizeof(word));
+#endif
+
+const std::string DEFAULT_CHANNEL;
+const std::string AAD_CHANNEL = "AAD";
+const std::string &BufferedTransformation::NULL_CHANNEL = DEFAULT_CHANNEL;
+
+class NullNameValuePairs : public NameValuePairs
+{
+public:
+	bool GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const {return false;}
+};
+
+simple_ptr<NullNameValuePairs> s_pNullNameValuePairs(new NullNameValuePairs);
+const NameValuePairs &g_nullNameValuePairs = *s_pNullNameValuePairs.m_p;
+
+BufferedTransformation & TheBitBucket()
+{
+	static BitBucket bitBucket;
+	return bitBucket;
+}
+
+Algorithm::Algorithm(bool checkSelfTestStatus)
+{
+	if (checkSelfTestStatus && FIPS_140_2_ComplianceEnabled())
+	{
+		if (GetPowerUpSelfTestStatus() == POWER_UP_SELF_TEST_NOT_DONE && !PowerUpSelfTestInProgressOnThisThread())
+			throw SelfTestFailure("Cryptographic algorithms are disabled before the power-up self tests are performed.");
+
+		if (GetPowerUpSelfTestStatus() == POWER_UP_SELF_TEST_FAILED)
+			throw SelfTestFailure("Cryptographic algorithms are disabled after a power-up self test failed.");
+	}
+}
+
+void SimpleKeyingInterface::SetKey(const byte *key, size_t length, const NameValuePairs &params)
+{
+	this->ThrowIfInvalidKeyLength(length);
+	this->UncheckedSetKey(key, (unsigned int)length, params);
+}
+
+void SimpleKeyingInterface::SetKeyWithRounds(const byte *key, size_t length, int rounds)
+{
+	SetKey(key, length, MakeParameters(Name::Rounds(), rounds));
+}
+
+void SimpleKeyingInterface::SetKeyWithIV(const byte *key, size_t length, const byte *iv, size_t ivLength)
+{
+	SetKey(key, length, MakeParameters(Name::IV(), ConstByteArrayParameter(iv, ivLength)));
+}
+
+void SimpleKeyingInterface::ThrowIfInvalidKeyLength(size_t length)
+{
+	if (!IsValidKeyLength(length))
+		throw InvalidKeyLength(GetAlgorithm().AlgorithmName(), length);
+}
+
+void SimpleKeyingInterface::ThrowIfResynchronizable()
+{
+	if (IsResynchronizable())
+		throw InvalidArgument(GetAlgorithm().AlgorithmName() + ": this object requires an IV");
+}
+
+void SimpleKeyingInterface::ThrowIfInvalidIV(const byte *iv)
+{
+	if (!iv && IVRequirement() == UNPREDICTABLE_RANDOM_IV)
+		throw InvalidArgument(GetAlgorithm().AlgorithmName() + ": this object cannot use a null IV");
+}
+
+size_t SimpleKeyingInterface::ThrowIfInvalidIVLength(int size)
+{
+	if (size < 0)
+		return IVSize();
+	else if ((size_t)size < MinIVLength())
+		throw InvalidArgument(GetAlgorithm().AlgorithmName() + ": IV length " + IntToString(size) + " is less than the minimum of " + IntToString(MinIVLength()));
+	else if ((size_t)size > MaxIVLength())
+		throw InvalidArgument(GetAlgorithm().AlgorithmName() + ": IV length " + IntToString(size) + " exceeds the maximum of " + IntToString(MaxIVLength()));
+	else
+		return size;
+}
+
+const byte * SimpleKeyingInterface::GetIVAndThrowIfInvalid(const NameValuePairs &params, size_t &size)
+{
+	ConstByteArrayParameter ivWithLength;
+	const byte *iv;
+	bool found = false;
+
+	try {found = params.GetValue(Name::IV(), ivWithLength);}
+	catch (const NameValuePairs::ValueTypeMismatch &) {}
+
+	if (found)
+	{
+		iv = ivWithLength.begin();
+		ThrowIfInvalidIV(iv);
+		size = ThrowIfInvalidIVLength((int)ivWithLength.size());
+		return iv;
+	}
+	else if (params.GetValue(Name::IV(), iv))
+	{
+		ThrowIfInvalidIV(iv);
+		size = IVSize();
+		return iv;
+	}
+	else
+	{
+		ThrowIfResynchronizable();
+		size = 0;
+		return NULL;
+	}
+}
+
+void SimpleKeyingInterface::GetNextIV(RandomNumberGenerator &rng, byte *IV)
+{
+	rng.GenerateBlock(IV, IVSize());
+}
+
+size_t BlockTransformation::AdvancedProcessBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags) const
+{
+	size_t blockSize = BlockSize();
+	size_t inIncrement = (flags & (BT_InBlockIsCounter|BT_DontIncrementInOutPointers)) ? 0 : blockSize;
+	size_t xorIncrement = xorBlocks ? blockSize : 0;
+	size_t outIncrement = (flags & BT_DontIncrementInOutPointers) ? 0 : blockSize;
+
+	if (flags & BT_ReverseDirection)
+	{
+		assert(length % blockSize == 0);
+		inBlocks += length - blockSize;
+		xorBlocks += length - blockSize;
+		outBlocks += length - blockSize;
+		inIncrement = 0-inIncrement;
+		xorIncrement = 0-xorIncrement;
+		outIncrement = 0-outIncrement;
+	}
+
+	while (length >= blockSize)
+	{
+		if (flags & BT_XorInput)
+		{
+			xorbuf(outBlocks, xorBlocks, inBlocks, blockSize);
+			ProcessBlock(outBlocks);
+		}
+		else
+			ProcessAndXorBlock(inBlocks, xorBlocks, outBlocks);
+		if (flags & BT_InBlockIsCounter)
+			const_cast<byte *>(inBlocks)[blockSize-1]++;
+		inBlocks += inIncrement;
+		outBlocks += outIncrement;
+		xorBlocks += xorIncrement;
+		length -= blockSize;
+	}
+
+	return length;
+}
+
+unsigned int BlockTransformation::OptimalDataAlignment() const
+{
+	return GetAlignmentOf<word32>();
+}
+
+unsigned int StreamTransformation::OptimalDataAlignment() const
+{
+	return GetAlignmentOf<word32>();
+}
+
+unsigned int HashTransformation::OptimalDataAlignment() const
+{
+	return GetAlignmentOf<word32>();
+}
+
+void StreamTransformation::ProcessLastBlock(byte *outString, const byte *inString, size_t length)
+{
+	assert(MinLastBlockSize() == 0);	// this function should be overriden otherwise
+
+	if (length == MandatoryBlockSize())
+		ProcessData(outString, inString, length);
+	else if (length != 0)
+		throw NotImplemented(AlgorithmName() + ": this object does't support a special last block");
+}
+
+void AuthenticatedSymmetricCipher::SpecifyDataLengths(lword headerLength, lword messageLength, lword footerLength)
+{
+	if (headerLength > MaxHeaderLength())
+		throw InvalidArgument(GetAlgorithm().AlgorithmName() + ": header length " + IntToString(headerLength) + " exceeds the maximum of " + IntToString(MaxHeaderLength()));
+
+	if (messageLength > MaxMessageLength())
+		throw InvalidArgument(GetAlgorithm().AlgorithmName() + ": message length " + IntToString(messageLength) + " exceeds the maximum of " + IntToString(MaxMessageLength()));
+		
+	if (footerLength > MaxFooterLength())
+		throw InvalidArgument(GetAlgorithm().AlgorithmName() + ": footer length " + IntToString(footerLength) + " exceeds the maximum of " + IntToString(MaxFooterLength()));
+
+	UncheckedSpecifyDataLengths(headerLength, messageLength, footerLength);
+}
+
+void AuthenticatedSymmetricCipher::EncryptAndAuthenticate(byte *ciphertext, byte *mac, size_t macSize, const byte *iv, int ivLength, const byte *header, size_t headerLength, const byte *message, size_t messageLength)
+{
+	Resynchronize(iv, ivLength);
+	SpecifyDataLengths(headerLength, messageLength);
+	Update(header, headerLength);
+	ProcessString(ciphertext, message, messageLength);
+	TruncatedFinal(mac, macSize);
+}
+
+bool AuthenticatedSymmetricCipher::DecryptAndVerify(byte *message, const byte *mac, size_t macLength, const byte *iv, int ivLength, const byte *header, size_t headerLength, const byte *ciphertext, size_t ciphertextLength)
+{
+	Resynchronize(iv, ivLength);
+	SpecifyDataLengths(headerLength, ciphertextLength);
+	Update(header, headerLength);
+	ProcessString(message, ciphertext, ciphertextLength);
+	return TruncatedVerify(mac, macLength);
+}
+
+unsigned int RandomNumberGenerator::GenerateBit()
+{
+	return GenerateByte() & 1;
+}
+
+byte RandomNumberGenerator::GenerateByte()
+{
+	byte b;
+	GenerateBlock(&b, 1);
+	return b;
+}
+
+word32 RandomNumberGenerator::GenerateWord32(word32 min, word32 max)
+{
+	word32 range = max-min;
+	const int maxBits = BitPrecision(range);
+
+	word32 value;
+
+	do
+	{
+		GenerateBlock((byte *)&value, sizeof(value));
+		value = Crop(value, maxBits);
+	} while (value > range);
+
+	return value+min;
+}
+
+void RandomNumberGenerator::GenerateBlock(byte *output, size_t size)
+{
+	ArraySink s(output, size);
+	GenerateIntoBufferedTransformation(s, DEFAULT_CHANNEL, size);
+}
+
+void RandomNumberGenerator::DiscardBytes(size_t n)
+{
+	GenerateIntoBufferedTransformation(TheBitBucket(), DEFAULT_CHANNEL, n);
+}
+
+void RandomNumberGenerator::GenerateIntoBufferedTransformation(BufferedTransformation &target, const std::string &channel, lword length)
+{
+	FixedSizeSecBlock<byte, 256> buffer;
+	while (length)
+	{
+		size_t len = UnsignedMin(buffer.size(), length);
+		GenerateBlock(buffer, len);
+		target.ChannelPut(channel, buffer, len);
+		length -= len;
+	}
+}
+
+//! see NullRNG()
+class ClassNullRNG : public RandomNumberGenerator
+{
+public:
+	std::string AlgorithmName() const {return "NullRNG";}
+	void GenerateBlock(byte *output, size_t size) {throw NotImplemented("NullRNG: NullRNG should only be passed to functions that don't need to generate random bytes");}
+};
+
+RandomNumberGenerator & NullRNG()
+{
+	static ClassNullRNG s_nullRNG;
+	return s_nullRNG;
+}
+
+bool HashTransformation::TruncatedVerify(const byte *digestIn, size_t digestLength)
+{
+	ThrowIfInvalidTruncatedSize(digestLength);
+	SecByteBlock digest(digestLength);
+	TruncatedFinal(digest, digestLength);
+	return VerifyBufsEqual(digest, digestIn, digestLength);
+}
+
+void HashTransformation::ThrowIfInvalidTruncatedSize(size_t size) const
+{
+	if (size > DigestSize())
+		throw InvalidArgument("HashTransformation: can't truncate a " + IntToString(DigestSize()) + " byte digest to " + IntToString(size) + " bytes");
+}
+
+unsigned int BufferedTransformation::GetMaxWaitObjectCount() const
+{
+	const BufferedTransformation *t = AttachedTransformation();
+	return t ? t->GetMaxWaitObjectCount() : 0;
+}
+
+void BufferedTransformation::GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack)
+{
+	BufferedTransformation *t = AttachedTransformation();
+	if (t)
+		t->GetWaitObjects(container, callStack);  // reduce clutter by not adding to stack here
+}
+
+void BufferedTransformation::Initialize(const NameValuePairs &parameters, int propagation)
+{
+	assert(!AttachedTransformation());
+	IsolatedInitialize(parameters);
+}
+
+bool BufferedTransformation::Flush(bool hardFlush, int propagation, bool blocking)
+{
+	assert(!AttachedTransformation());
+	return IsolatedFlush(hardFlush, blocking);
+}
+
+bool BufferedTransformation::MessageSeriesEnd(int propagation, bool blocking)
+{
+	assert(!AttachedTransformation());
+	return IsolatedMessageSeriesEnd(blocking);
+}
+
+byte * BufferedTransformation::ChannelCreatePutSpace(const std::string &channel, size_t &size)
+{
+	if (channel.empty())
+		return CreatePutSpace(size);
+	else
+		throw NoChannelSupport(AlgorithmName());
+}
+
+size_t BufferedTransformation::ChannelPut2(const std::string &channel, const byte *begin, size_t length, int messageEnd, bool blocking)
+{
+	if (channel.empty())
+		return Put2(begin, length, messageEnd, blocking);
+	else
+		throw NoChannelSupport(AlgorithmName());
+}
+
+size_t BufferedTransformation::ChannelPutModifiable2(const std::string &channel, byte *begin, size_t length, int messageEnd, bool blocking)
+{
+	if (channel.empty())
+		return PutModifiable2(begin, length, messageEnd, blocking);
+	else
+		return ChannelPut2(channel, begin, length, messageEnd, blocking);
+}
+
+bool BufferedTransformation::ChannelFlush(const std::string &channel, bool completeFlush, int propagation, bool blocking)
+{
+	if (channel.empty())
+		return Flush(completeFlush, propagation, blocking);
+	else
+		throw NoChannelSupport(AlgorithmName());
+}
+
+bool BufferedTransformation::ChannelMessageSeriesEnd(const std::string &channel, int propagation, bool blocking)
+{
+	if (channel.empty())
+		return MessageSeriesEnd(propagation, blocking);
+	else
+		throw NoChannelSupport(AlgorithmName());
+}
+
+lword BufferedTransformation::MaxRetrievable() const
+{
+	if (AttachedTransformation())
+		return AttachedTransformation()->MaxRetrievable();
+	else
+		return CopyTo(TheBitBucket());
+}
+
+bool BufferedTransformation::AnyRetrievable() const
+{
+	if (AttachedTransformation())
+		return AttachedTransformation()->AnyRetrievable();
+	else
+	{
+		byte b;
+		return Peek(b) != 0;
+	}
+}
+
+size_t BufferedTransformation::Get(byte &outByte)
+{
+	if (AttachedTransformation())
+		return AttachedTransformation()->Get(outByte);
+	else
+		return Get(&outByte, 1);
+}
+
+size_t BufferedTransformation::Get(byte *outString, size_t getMax)
+{
+	if (AttachedTransformation())
+		return AttachedTransformation()->Get(outString, getMax);
+	else
+	{
+		ArraySink arraySink(outString, getMax);
+		return (size_t)TransferTo(arraySink, getMax);
+	}
+}
+
+size_t BufferedTransformation::Peek(byte &outByte) const
+{
+	if (AttachedTransformation())
+		return AttachedTransformation()->Peek(outByte);
+	else
+		return Peek(&outByte, 1);
+}
+
+size_t BufferedTransformation::Peek(byte *outString, size_t peekMax) const
+{
+	if (AttachedTransformation())
+		return AttachedTransformation()->Peek(outString, peekMax);
+	else
+	{
+		ArraySink arraySink(outString, peekMax);
+		return (size_t)CopyTo(arraySink, peekMax);
+	}
+}
+
+lword BufferedTransformation::Skip(lword skipMax)
+{
+	if (AttachedTransformation())
+		return AttachedTransformation()->Skip(skipMax);
+	else
+		return TransferTo(TheBitBucket(), skipMax);
+}
+
+lword BufferedTransformation::TotalBytesRetrievable() const
+{
+	if (AttachedTransformation())
+		return AttachedTransformation()->TotalBytesRetrievable();
+	else
+		return MaxRetrievable();
+}
+
+unsigned int BufferedTransformation::NumberOfMessages() const
+{
+	if (AttachedTransformation())
+		return AttachedTransformation()->NumberOfMessages();
+	else
+		return CopyMessagesTo(TheBitBucket());
+}
+
+bool BufferedTransformation::AnyMessages() const
+{
+	if (AttachedTransformation())
+		return AttachedTransformation()->AnyMessages();
+	else
+		return NumberOfMessages() != 0;
+}
+
+bool BufferedTransformation::GetNextMessage()
+{
+	if (AttachedTransformation())
+		return AttachedTransformation()->GetNextMessage();
+	else
+	{
+		assert(!AnyMessages());
+		return false;
+	}
+}
+
+unsigned int BufferedTransformation::SkipMessages(unsigned int count)
+{
+	if (AttachedTransformation())
+		return AttachedTransformation()->SkipMessages(count);
+	else
+		return TransferMessagesTo(TheBitBucket(), count);
+}
+
+size_t BufferedTransformation::TransferMessagesTo2(BufferedTransformation &target, unsigned int &messageCount, const std::string &channel, bool blocking)
+{
+	if (AttachedTransformation())
+		return AttachedTransformation()->TransferMessagesTo2(target, messageCount, channel, blocking);
+	else
+	{
+		unsigned int maxMessages = messageCount;
+		for (messageCount=0; messageCount < maxMessages && AnyMessages(); messageCount++)
+		{
+			size_t blockedBytes;
+			lword transferredBytes;
+
+			while (AnyRetrievable())
+			{
+				transferredBytes = LWORD_MAX;
+				blockedBytes = TransferTo2(target, transferredBytes, channel, blocking);
+				if (blockedBytes > 0)
+					return blockedBytes;
+			}
+
+			if (target.ChannelMessageEnd(channel, GetAutoSignalPropagation(), blocking))
+				return 1;
+
+			bool result = GetNextMessage();
+			assert(result);
+		}
+		return 0;
+	}
+}
+
+unsigned int BufferedTransformation::CopyMessagesTo(BufferedTransformation &target, unsigned int count, const std::string &channel) const
+{
+	if (AttachedTransformation())
+		return AttachedTransformation()->CopyMessagesTo(target, count, channel);
+	else
+		return 0;
+}
+
+void BufferedTransformation::SkipAll()
+{
+	if (AttachedTransformation())
+		AttachedTransformation()->SkipAll();
+	else
+	{
+		while (SkipMessages()) {}
+		while (Skip()) {}
+	}
+}
+
+size_t BufferedTransformation::TransferAllTo2(BufferedTransformation &target, const std::string &channel, bool blocking)
+{
+	if (AttachedTransformation())
+		return AttachedTransformation()->TransferAllTo2(target, channel, blocking);
+	else
+	{
+		assert(!NumberOfMessageSeries());
+
+		unsigned int messageCount;
+		do
+		{
+			messageCount = UINT_MAX;
+			size_t blockedBytes = TransferMessagesTo2(target, messageCount, channel, blocking);
+			if (blockedBytes)
+				return blockedBytes;
+		}
+		while (messageCount != 0);
+
+		lword byteCount;
+		do
+		{
+			byteCount = ULONG_MAX;
+			size_t blockedBytes = TransferTo2(target, byteCount, channel, blocking);
+			if (blockedBytes)
+				return blockedBytes;
+		}
+		while (byteCount != 0);
+
+		return 0;
+	}
+}
+
+void BufferedTransformation::CopyAllTo(BufferedTransformation &target, const std::string &channel) const
+{
+	if (AttachedTransformation())
+		AttachedTransformation()->CopyAllTo(target, channel);
+	else
+	{
+		assert(!NumberOfMessageSeries());
+		while (CopyMessagesTo(target, UINT_MAX, channel)) {}
+	}
+}
+
+void BufferedTransformation::SetRetrievalChannel(const std::string &channel)
+{
+	if (AttachedTransformation())
+		AttachedTransformation()->SetRetrievalChannel(channel);
+}
+
+size_t BufferedTransformation::ChannelPutWord16(const std::string &channel, word16 value, ByteOrder order, bool blocking)
+{
+	PutWord(false, order, m_buf, value);
+	return ChannelPut(channel, m_buf, 2, blocking);
+}
+
+size_t BufferedTransformation::ChannelPutWord32(const std::string &channel, word32 value, ByteOrder order, bool blocking)
+{
+	PutWord(false, order, m_buf, value);
+	return ChannelPut(channel, m_buf, 4, blocking);
+}
+
+size_t BufferedTransformation::PutWord16(word16 value, ByteOrder order, bool blocking)
+{
+	return ChannelPutWord16(DEFAULT_CHANNEL, value, order, blocking);
+}
+
+size_t BufferedTransformation::PutWord32(word32 value, ByteOrder order, bool blocking)
+{
+	return ChannelPutWord32(DEFAULT_CHANNEL, value, order, blocking);
+}
+
+size_t BufferedTransformation::PeekWord16(word16 &value, ByteOrder order) const
+{
+	byte buf[2] = {0, 0};
+	size_t len = Peek(buf, 2);
+
+	if (order)
+		value = (buf[0] << 8) | buf[1];
+	else
+		value = (buf[1] << 8) | buf[0];
+
+	return len;
+}
+
+size_t BufferedTransformation::PeekWord32(word32 &value, ByteOrder order) const
+{
+	byte buf[4] = {0, 0, 0, 0};
+	size_t len = Peek(buf, 4);
+
+	if (order)
+		value = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf [3];
+	else
+		value = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf [0];
+
+	return len;
+}
+
+size_t BufferedTransformation::GetWord16(word16 &value, ByteOrder order)
+{
+	return (size_t)Skip(PeekWord16(value, order));
+}
+
+size_t BufferedTransformation::GetWord32(word32 &value, ByteOrder order)
+{
+	return (size_t)Skip(PeekWord32(value, order));
+}
+
+void BufferedTransformation::Attach(BufferedTransformation *newOut)
+{
+	if (AttachedTransformation() && AttachedTransformation()->Attachable())
+		AttachedTransformation()->Attach(newOut);
+	else
+		Detach(newOut);
+}
+
+void GeneratableCryptoMaterial::GenerateRandomWithKeySize(RandomNumberGenerator &rng, unsigned int keySize)
+{
+	GenerateRandom(rng, MakeParameters("KeySize", (int)keySize));
+}
+
+class PK_DefaultEncryptionFilter : public Unflushable<Filter>
+{
+public:
+	PK_DefaultEncryptionFilter(RandomNumberGenerator &rng, const PK_Encryptor &encryptor, BufferedTransformation *attachment, const NameValuePairs &parameters)
+		: m_rng(rng), m_encryptor(encryptor), m_parameters(parameters)
+	{
+		Detach(attachment);
+	}
+
+	size_t Put2(const byte *inString, size_t length, int messageEnd, bool blocking)
+	{
+		FILTER_BEGIN;
+		m_plaintextQueue.Put(inString, length);
+
+		if (messageEnd)
+		{
+			{
+			size_t plaintextLength;
+			if (!SafeConvert(m_plaintextQueue.CurrentSize(), plaintextLength))
+				throw InvalidArgument("PK_DefaultEncryptionFilter: plaintext too long");
+			size_t ciphertextLength = m_encryptor.CiphertextLength(plaintextLength);
+
+			SecByteBlock plaintext(plaintextLength);
+			m_plaintextQueue.Get(plaintext, plaintextLength);
+			m_ciphertext.resize(ciphertextLength);
+			m_encryptor.Encrypt(m_rng, plaintext, plaintextLength, m_ciphertext, m_parameters);
+			}
+			
+			FILTER_OUTPUT(1, m_ciphertext, m_ciphertext.size(), messageEnd);
+		}
+		FILTER_END_NO_MESSAGE_END;
+	}
+
+	RandomNumberGenerator &m_rng;
+	const PK_Encryptor &m_encryptor;
+	const NameValuePairs &m_parameters;
+	ByteQueue m_plaintextQueue;
+	SecByteBlock m_ciphertext;
+};
+
+BufferedTransformation * PK_Encryptor::CreateEncryptionFilter(RandomNumberGenerator &rng, BufferedTransformation *attachment, const NameValuePairs &parameters) const
+{
+	return new PK_DefaultEncryptionFilter(rng, *this, attachment, parameters);
+}
+
+class PK_DefaultDecryptionFilter : public Unflushable<Filter>
+{
+public:
+	PK_DefaultDecryptionFilter(RandomNumberGenerator &rng, const PK_Decryptor &decryptor, BufferedTransformation *attachment, const NameValuePairs &parameters)
+		: m_rng(rng), m_decryptor(decryptor), m_parameters(parameters)
+	{
+		Detach(attachment);
+	}
+
+	size_t Put2(const byte *inString, size_t length, int messageEnd, bool blocking)
+	{
+		FILTER_BEGIN;
+		m_ciphertextQueue.Put(inString, length);
+
+		if (messageEnd)
+		{
+			{
+			size_t ciphertextLength;
+			if (!SafeConvert(m_ciphertextQueue.CurrentSize(), ciphertextLength))
+				throw InvalidArgument("PK_DefaultDecryptionFilter: ciphertext too long");
+			size_t maxPlaintextLength = m_decryptor.MaxPlaintextLength(ciphertextLength);
+
+			SecByteBlock ciphertext(ciphertextLength);
+			m_ciphertextQueue.Get(ciphertext, ciphertextLength);
+			m_plaintext.resize(maxPlaintextLength);
+			m_result = m_decryptor.Decrypt(m_rng, ciphertext, ciphertextLength, m_plaintext, m_parameters);
+			if (!m_result.isValidCoding)
+				throw InvalidCiphertext(m_decryptor.AlgorithmName() + ": invalid ciphertext");
+			}
+
+			FILTER_OUTPUT(1, m_plaintext, m_result.messageLength, messageEnd);
+		}
+		FILTER_END_NO_MESSAGE_END;
+	}
+
+	RandomNumberGenerator &m_rng;
+	const PK_Decryptor &m_decryptor;
+	const NameValuePairs &m_parameters;
+	ByteQueue m_ciphertextQueue;
+	SecByteBlock m_plaintext;
+	DecodingResult m_result;
+};
+
+BufferedTransformation * PK_Decryptor::CreateDecryptionFilter(RandomNumberGenerator &rng, BufferedTransformation *attachment, const NameValuePairs &parameters) const
+{
+	return new PK_DefaultDecryptionFilter(rng, *this, attachment, parameters);
+}
+
+size_t PK_Signer::Sign(RandomNumberGenerator &rng, PK_MessageAccumulator *messageAccumulator, byte *signature) const
+{
+	std::auto_ptr<PK_MessageAccumulator> m(messageAccumulator);
+	return SignAndRestart(rng, *m, signature, false);
+}
+
+size_t PK_Signer::SignMessage(RandomNumberGenerator &rng, const byte *message, size_t messageLen, byte *signature) const
+{
+	std::auto_ptr<PK_MessageAccumulator> m(NewSignatureAccumulator(rng));
+	m->Update(message, messageLen);
+	return SignAndRestart(rng, *m, signature, false);
+}
+
+size_t PK_Signer::SignMessageWithRecovery(RandomNumberGenerator &rng, const byte *recoverableMessage, size_t recoverableMessageLength, 
+	const byte *nonrecoverableMessage, size_t nonrecoverableMessageLength, byte *signature) const
+{
+	std::auto_ptr<PK_MessageAccumulator> m(NewSignatureAccumulator(rng));
+	InputRecoverableMessage(*m, recoverableMessage, recoverableMessageLength);
+	m->Update(nonrecoverableMessage, nonrecoverableMessageLength);
+	return SignAndRestart(rng, *m, signature, false);
+}
+
+bool PK_Verifier::Verify(PK_MessageAccumulator *messageAccumulator) const
+{
+	std::auto_ptr<PK_MessageAccumulator> m(messageAccumulator);
+	return VerifyAndRestart(*m);
+}
+
+bool PK_Verifier::VerifyMessage(const byte *message, size_t messageLen, const byte *signature, size_t signatureLength) const
+{
+	std::auto_ptr<PK_MessageAccumulator> m(NewVerificationAccumulator());
+	InputSignature(*m, signature, signatureLength);
+	m->Update(message, messageLen);
+	return VerifyAndRestart(*m);
+}
+
+DecodingResult PK_Verifier::Recover(byte *recoveredMessage, PK_MessageAccumulator *messageAccumulator) const
+{
+	std::auto_ptr<PK_MessageAccumulator> m(messageAccumulator);
+	return RecoverAndRestart(recoveredMessage, *m);
+}
+
+DecodingResult PK_Verifier::RecoverMessage(byte *recoveredMessage, 
+	const byte *nonrecoverableMessage, size_t nonrecoverableMessageLength, 
+	const byte *signature, size_t signatureLength) const
+{
+	std::auto_ptr<PK_MessageAccumulator> m(NewVerificationAccumulator());
+	InputSignature(*m, signature, signatureLength);
+	m->Update(nonrecoverableMessage, nonrecoverableMessageLength);
+	return RecoverAndRestart(recoveredMessage, *m);
+}
+
+void SimpleKeyAgreementDomain::GenerateKeyPair(RandomNumberGenerator &rng, byte *privateKey, byte *publicKey) const
+{
+	GeneratePrivateKey(rng, privateKey);
+	GeneratePublicKey(rng, privateKey, publicKey);
+}
+
+void AuthenticatedKeyAgreementDomain::GenerateStaticKeyPair(RandomNumberGenerator &rng, byte *privateKey, byte *publicKey) const
+{
+	GenerateStaticPrivateKey(rng, privateKey);
+	GenerateStaticPublicKey(rng, privateKey, publicKey);
+}
+
+void AuthenticatedKeyAgreementDomain::GenerateEphemeralKeyPair(RandomNumberGenerator &rng, byte *privateKey, byte *publicKey) const
+{
+	GenerateEphemeralPrivateKey(rng, privateKey);
+	GenerateEphemeralPublicKey(rng, privateKey, publicKey);
+}
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/default.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/default.cpp
index 2ac03246..72940784 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/src/default.cpp
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/default.cpp
@@ -1,258 +1,258 @@
-// default.cpp - written and placed in the public domain by Wei Dai
-
-//#include "pch.h"
-#include "default.h"
-#include "queue.h"
-#include <time.h>
-#include <memory>
-
-NAMESPACE_BEGIN(CryptoPP)
-
-static const unsigned int MASH_ITERATIONS = 200;
-static const unsigned int SALTLENGTH = 8;
-static const unsigned int BLOCKSIZE = Default_BlockCipher::Encryption::BLOCKSIZE;
-static const unsigned int KEYLENGTH = Default_BlockCipher::Encryption::DEFAULT_KEYLENGTH;
-
-// The purpose of this function Mash() is to take an arbitrary length input
-// string and *deterministicly* produce an arbitrary length output string such
-// that (1) it looks random, (2) no information about the input is
-// deducible from it, and (3) it contains as much entropy as it can hold, or
-// the amount of entropy in the input string, whichever is smaller.
-
-static void Mash(const byte *in, word16 inLen, byte *out, word16 outLen, int iterations)
-{
-	unsigned int bufSize = (outLen-1+DefaultHashModule::DIGESTSIZE-((outLen-1)%DefaultHashModule::DIGESTSIZE));
-
-	// ASSERT: bufSize == (the smallest multiple of DIGESTSIZE that is >= outLen)
-
-	byte b[2];
-	SecByteBlock buf(bufSize);
-	SecByteBlock outBuf(bufSize);
-	DefaultHashModule hash;
-
-	unsigned int i;
-	for(i=0; i<outLen; i+=DefaultHashModule::DIGESTSIZE)
-	{
-		b[0] = (byte) i >> 8;
-		b[1] = (byte) i;
-		hash.Update(b, 2);
-		hash.Update(in, inLen);
-		hash.Final(outBuf+i);
-	}
-
-	while (iterations-- > 1)
-	{
-		memcpy(buf, outBuf, bufSize);
-		for (i=0; i<bufSize; i+=DefaultHashModule::DIGESTSIZE)
-		{
-			b[0] = (byte) i >> 8;
-			b[1] = (byte) i;
-			hash.Update(b, 2);
-			hash.Update(buf, bufSize);
-			hash.Final(outBuf+i);
-		}
-	}
-
-	memcpy(out, outBuf, outLen);
-}
-
-static void GenerateKeyIV(const byte *passphrase, unsigned int passphraseLength, const byte *salt, unsigned int saltLength, byte *key, byte *IV)
-{
-	SecByteBlock temp(passphraseLength+saltLength);
-	memcpy(temp, passphrase, passphraseLength);
-	memcpy(temp+passphraseLength, salt, saltLength);
-	SecByteBlock keyIV(KEYLENGTH+BLOCKSIZE);
-	Mash(temp, passphraseLength + saltLength, keyIV, KEYLENGTH+BLOCKSIZE, MASH_ITERATIONS);
-	memcpy(key, keyIV, KEYLENGTH);
-	memcpy(IV, keyIV+KEYLENGTH, BLOCKSIZE);
-}
-
-// ********************************************************
-
-DefaultEncryptor::DefaultEncryptor(const char *passphrase, BufferedTransformation *attachment)
-	: ProxyFilter(NULL, 0, 0, attachment), m_passphrase((const byte *)passphrase, strlen(passphrase))
-{
-}
-
-DefaultEncryptor::DefaultEncryptor(const byte *passphrase, unsigned int passphraseLength, BufferedTransformation *attachment)
-	: ProxyFilter(NULL, 0, 0, attachment), m_passphrase(passphrase, passphraseLength)
-{
-}
-
-
-void DefaultEncryptor::FirstPut(const byte *)
-{
-	// VC60 workaround: __LINE__ expansion bug
-	CRYPTOPP_COMPILE_ASSERT_INSTANCE(SALTLENGTH <= DefaultHashModule::DIGESTSIZE, 1);
-	CRYPTOPP_COMPILE_ASSERT_INSTANCE(BLOCKSIZE <= DefaultHashModule::DIGESTSIZE, 2);
-
-	SecByteBlock salt(DefaultHashModule::DIGESTSIZE), keyCheck(DefaultHashModule::DIGESTSIZE);
-	DefaultHashModule hash;
-
-	// use hash(passphrase | time | clock) as salt
-	hash.Update(m_passphrase, m_passphrase.size());
-	time_t t=time(0);
-	hash.Update((byte *)&t, sizeof(t));
-	clock_t c=clock();
-	hash.Update((byte *)&c, sizeof(c));
-	hash.Final(salt);
-
-	// use hash(passphrase | salt) as key check
-	hash.Update(m_passphrase, m_passphrase.size());
-	hash.Update(salt, SALTLENGTH);
-	hash.Final(keyCheck);
-
-	AttachedTransformation()->Put(salt, SALTLENGTH);
-
-	// mash passphrase and salt together into key and IV
-	SecByteBlock key(KEYLENGTH);
-	SecByteBlock IV(BLOCKSIZE);
-	GenerateKeyIV(m_passphrase, m_passphrase.size(), salt, SALTLENGTH, key, IV);
-
-	m_cipher.SetKeyWithIV(key, key.size(), IV);
-	SetFilter(new StreamTransformationFilter(m_cipher));
-
-	m_filter->Put(keyCheck, BLOCKSIZE);
-}
-
-void DefaultEncryptor::LastPut(const byte *inString, unsigned int length)
-{
-	m_filter->MessageEnd();
-}
-
-// ********************************************************
-
-DefaultDecryptor::DefaultDecryptor(const char *p, BufferedTransformation *attachment, bool throwException)
-	: ProxyFilter(NULL, SALTLENGTH+BLOCKSIZE, 0, attachment)
-	, m_state(WAITING_FOR_KEYCHECK)
-	, m_passphrase((const byte *)p, strlen(p))
-	, m_throwException(throwException)
-{
-}
-
-DefaultDecryptor::DefaultDecryptor(const byte *passphrase, unsigned int passphraseLength, BufferedTransformation *attachment, bool throwException)
-	: ProxyFilter(NULL, SALTLENGTH+BLOCKSIZE, 0, attachment)
-	, m_state(WAITING_FOR_KEYCHECK)
-	, m_passphrase(passphrase, passphraseLength)
-	, m_throwException(throwException)
-{
-}
-
-void DefaultDecryptor::FirstPut(const byte *inString)
-{
-	CheckKey(inString, inString+SALTLENGTH);
-}
-
-void DefaultDecryptor::LastPut(const byte *inString, unsigned int length)
-{
-	if (m_filter.get() == NULL)
-	{
-		m_state = KEY_BAD;
-		if (m_throwException)
-			throw KeyBadErr();
-	}
-	else
-	{
-		m_filter->MessageEnd();
-		m_state = WAITING_FOR_KEYCHECK;
-	}
-}
-
-void DefaultDecryptor::CheckKey(const byte *salt, const byte *keyCheck)
-{
-	SecByteBlock check(STDMAX((unsigned int)2*BLOCKSIZE, (unsigned int)DefaultHashModule::DIGESTSIZE));
-
-	DefaultHashModule hash;
-	hash.Update(m_passphrase, m_passphrase.size());
-	hash.Update(salt, SALTLENGTH);
-	hash.Final(check);
-
-	SecByteBlock key(KEYLENGTH);
-	SecByteBlock IV(BLOCKSIZE);
-	GenerateKeyIV(m_passphrase, m_passphrase.size(), salt, SALTLENGTH, key, IV);
-
-	m_cipher.SetKeyWithIV(key, key.size(), IV);
-	std::auto_ptr<StreamTransformationFilter> decryptor(new StreamTransformationFilter(m_cipher));
-
-	decryptor->Put(keyCheck, BLOCKSIZE);
-	decryptor->ForceNextPut();
-	decryptor->Get(check+BLOCKSIZE, BLOCKSIZE);
-
-	SetFilter(decryptor.release());
-
-	if (memcmp(check, check+BLOCKSIZE, BLOCKSIZE))
-	{
-		m_state = KEY_BAD;
-		if (m_throwException)
-			throw KeyBadErr();
-	}
-	else
-		m_state = KEY_GOOD;
-}
-
-// ********************************************************
-
-static DefaultMAC * NewDefaultEncryptorMAC(const byte *passphrase, unsigned int passphraseLength)
-{
-	unsigned int macKeyLength = DefaultMAC::StaticGetValidKeyLength(16);
-	SecByteBlock macKey(macKeyLength);
-	// since the MAC is encrypted there is no reason to mash the passphrase for many iterations
-	Mash(passphrase, passphraseLength, macKey, macKeyLength, 1);
-	return new DefaultMAC(macKey, macKeyLength);
-}
-
-DefaultEncryptorWithMAC::DefaultEncryptorWithMAC(const char *passphrase, BufferedTransformation *attachment)
-	: ProxyFilter(NULL, 0, 0, attachment)
-	, m_mac(NewDefaultEncryptorMAC((const byte *)passphrase, strlen(passphrase)))
-{
-	SetFilter(new HashFilter(*m_mac, new DefaultEncryptor(passphrase), true));
-}
-
-DefaultEncryptorWithMAC::DefaultEncryptorWithMAC(const byte *passphrase, unsigned int passphraseLength, BufferedTransformation *attachment)
-	: ProxyFilter(NULL, 0, 0, attachment)
-	, m_mac(NewDefaultEncryptorMAC(passphrase, passphraseLength))
-{
-	SetFilter(new HashFilter(*m_mac, new DefaultEncryptor(passphrase, passphraseLength), true));
-}
-
-void DefaultEncryptorWithMAC::LastPut(const byte *inString, unsigned int length)
-{
-	m_filter->MessageEnd();
-}
-
-// ********************************************************
-
-DefaultDecryptorWithMAC::DefaultDecryptorWithMAC(const char *passphrase, BufferedTransformation *attachment, bool throwException)
-	: ProxyFilter(NULL, 0, 0, attachment)
-	, m_mac(NewDefaultEncryptorMAC((const byte *)passphrase, strlen(passphrase)))
-	, m_throwException(throwException)
-{
-	SetFilter(new DefaultDecryptor(passphrase, m_hashVerifier=new HashVerifier(*m_mac, NULL, HashVerifier::PUT_MESSAGE), throwException));
-}
-
-DefaultDecryptorWithMAC::DefaultDecryptorWithMAC(const byte *passphrase, unsigned int passphraseLength, BufferedTransformation *attachment, bool throwException)
-	: ProxyFilter(NULL, 0, 0, attachment)
-	, m_mac(NewDefaultEncryptorMAC(passphrase, passphraseLength))
-	, m_throwException(throwException)
-{
-	SetFilter(new DefaultDecryptor(passphrase, passphraseLength, m_hashVerifier=new HashVerifier(*m_mac, NULL, HashVerifier::PUT_MESSAGE), throwException));
-}
-
-DefaultDecryptor::State DefaultDecryptorWithMAC::CurrentState() const
-{
-	return static_cast<const DefaultDecryptor *>(m_filter.get())->CurrentState();
-}
-
-bool DefaultDecryptorWithMAC::CheckLastMAC() const
-{
-	return m_hashVerifier->GetLastResult();
-}
-
-void DefaultDecryptorWithMAC::LastPut(const byte *inString, unsigned int length)
-{
-	m_filter->MessageEnd();
-	if (m_throwException && !CheckLastMAC())
-		throw MACBadErr();
-}
-
-NAMESPACE_END
+// default.cpp - written and placed in the public domain by Wei Dai
+
+#include "pch.h"
+#include "default.h"
+#include "queue.h"
+#include <time.h>
+#include <memory>
+
+NAMESPACE_BEGIN(CryptoPP)
+
+static const unsigned int MASH_ITERATIONS = 200;
+static const unsigned int SALTLENGTH = 8;
+static const unsigned int BLOCKSIZE = Default_BlockCipher::Encryption::BLOCKSIZE;
+static const unsigned int KEYLENGTH = Default_BlockCipher::Encryption::DEFAULT_KEYLENGTH;
+
+// The purpose of this function Mash() is to take an arbitrary length input
+// string and *deterministicly* produce an arbitrary length output string such
+// that (1) it looks random, (2) no information about the input is
+// deducible from it, and (3) it contains as much entropy as it can hold, or
+// the amount of entropy in the input string, whichever is smaller.
+
+static void Mash(const byte *in, size_t inLen, byte *out, size_t outLen, int iterations)
+{
+	if (BytePrecision(outLen) > 2)
+		throw InvalidArgument("Mash: output legnth too large");
+
+	size_t bufSize = RoundUpToMultipleOf(outLen, (size_t)DefaultHashModule::DIGESTSIZE);
+	byte b[2];
+	SecByteBlock buf(bufSize);
+	SecByteBlock outBuf(bufSize);
+	DefaultHashModule hash;
+
+	unsigned int i;
+	for(i=0; i<outLen; i+=DefaultHashModule::DIGESTSIZE)
+	{
+		b[0] = (byte) (i >> 8);
+		b[1] = (byte) i;
+		hash.Update(b, 2);
+		hash.Update(in, inLen);
+		hash.Final(outBuf+i);
+	}
+
+	while (iterations-- > 1)
+	{
+		memcpy(buf, outBuf, bufSize);
+		for (i=0; i<bufSize; i+=DefaultHashModule::DIGESTSIZE)
+		{
+			b[0] = (byte) (i >> 8);
+			b[1] = (byte) i;
+			hash.Update(b, 2);
+			hash.Update(buf, bufSize);
+			hash.Final(outBuf+i);
+		}
+	}
+
+	memcpy(out, outBuf, outLen);
+}
+
+static void GenerateKeyIV(const byte *passphrase, size_t passphraseLength, const byte *salt, size_t saltLength, byte *key, byte *IV)
+{
+	SecByteBlock temp(passphraseLength+saltLength);
+	memcpy(temp, passphrase, passphraseLength);
+	memcpy(temp+passphraseLength, salt, saltLength);
+	SecByteBlock keyIV(KEYLENGTH+BLOCKSIZE);
+	Mash(temp, passphraseLength + saltLength, keyIV, KEYLENGTH+BLOCKSIZE, MASH_ITERATIONS);
+	memcpy(key, keyIV, KEYLENGTH);
+	memcpy(IV, keyIV+KEYLENGTH, BLOCKSIZE);
+}
+
+// ********************************************************
+
+DefaultEncryptor::DefaultEncryptor(const char *passphrase, BufferedTransformation *attachment)
+	: ProxyFilter(NULL, 0, 0, attachment), m_passphrase((const byte *)passphrase, strlen(passphrase))
+{
+}
+
+DefaultEncryptor::DefaultEncryptor(const byte *passphrase, size_t passphraseLength, BufferedTransformation *attachment)
+	: ProxyFilter(NULL, 0, 0, attachment), m_passphrase(passphrase, passphraseLength)
+{
+}
+
+
+void DefaultEncryptor::FirstPut(const byte *)
+{
+	// VC60 workaround: __LINE__ expansion bug
+	CRYPTOPP_COMPILE_ASSERT_INSTANCE(SALTLENGTH <= DefaultHashModule::DIGESTSIZE, 1);
+	CRYPTOPP_COMPILE_ASSERT_INSTANCE(BLOCKSIZE <= DefaultHashModule::DIGESTSIZE, 2);
+
+	SecByteBlock salt(DefaultHashModule::DIGESTSIZE), keyCheck(DefaultHashModule::DIGESTSIZE);
+	DefaultHashModule hash;
+
+	// use hash(passphrase | time | clock) as salt
+	hash.Update(m_passphrase, m_passphrase.size());
+	time_t t=time(0);
+	hash.Update((byte *)&t, sizeof(t));
+	clock_t c=clock();
+	hash.Update((byte *)&c, sizeof(c));
+	hash.Final(salt);
+
+	// use hash(passphrase | salt) as key check
+	hash.Update(m_passphrase, m_passphrase.size());
+	hash.Update(salt, SALTLENGTH);
+	hash.Final(keyCheck);
+
+	AttachedTransformation()->Put(salt, SALTLENGTH);
+
+	// mash passphrase and salt together into key and IV
+	SecByteBlock key(KEYLENGTH);
+	SecByteBlock IV(BLOCKSIZE);
+	GenerateKeyIV(m_passphrase, m_passphrase.size(), salt, SALTLENGTH, key, IV);
+
+	m_cipher.SetKeyWithIV(key, key.size(), IV);
+	SetFilter(new StreamTransformationFilter(m_cipher));
+
+	m_filter->Put(keyCheck, BLOCKSIZE);
+}
+
+void DefaultEncryptor::LastPut(const byte *inString, size_t length)
+{
+	m_filter->MessageEnd();
+}
+
+// ********************************************************
+
+DefaultDecryptor::DefaultDecryptor(const char *p, BufferedTransformation *attachment, bool throwException)
+	: ProxyFilter(NULL, SALTLENGTH+BLOCKSIZE, 0, attachment)
+	, m_state(WAITING_FOR_KEYCHECK)
+	, m_passphrase((const byte *)p, strlen(p))
+	, m_throwException(throwException)
+{
+}
+
+DefaultDecryptor::DefaultDecryptor(const byte *passphrase, size_t passphraseLength, BufferedTransformation *attachment, bool throwException)
+	: ProxyFilter(NULL, SALTLENGTH+BLOCKSIZE, 0, attachment)
+	, m_state(WAITING_FOR_KEYCHECK)
+	, m_passphrase(passphrase, passphraseLength)
+	, m_throwException(throwException)
+{
+}
+
+void DefaultDecryptor::FirstPut(const byte *inString)
+{
+	CheckKey(inString, inString+SALTLENGTH);
+}
+
+void DefaultDecryptor::LastPut(const byte *inString, size_t length)
+{
+	if (m_filter.get() == NULL)
+	{
+		m_state = KEY_BAD;
+		if (m_throwException)
+			throw KeyBadErr();
+	}
+	else
+	{
+		m_filter->MessageEnd();
+		m_state = WAITING_FOR_KEYCHECK;
+	}
+}
+
+void DefaultDecryptor::CheckKey(const byte *salt, const byte *keyCheck)
+{
+	SecByteBlock check(STDMAX((unsigned int)2*BLOCKSIZE, (unsigned int)DefaultHashModule::DIGESTSIZE));
+
+	DefaultHashModule hash;
+	hash.Update(m_passphrase, m_passphrase.size());
+	hash.Update(salt, SALTLENGTH);
+	hash.Final(check);
+
+	SecByteBlock key(KEYLENGTH);
+	SecByteBlock IV(BLOCKSIZE);
+	GenerateKeyIV(m_passphrase, m_passphrase.size(), salt, SALTLENGTH, key, IV);
+
+	m_cipher.SetKeyWithIV(key, key.size(), IV);
+	std::auto_ptr<StreamTransformationFilter> decryptor(new StreamTransformationFilter(m_cipher));
+
+	decryptor->Put(keyCheck, BLOCKSIZE);
+	decryptor->ForceNextPut();
+	decryptor->Get(check+BLOCKSIZE, BLOCKSIZE);
+
+	SetFilter(decryptor.release());
+
+	if (!VerifyBufsEqual(check, check+BLOCKSIZE, BLOCKSIZE))
+	{
+		m_state = KEY_BAD;
+		if (m_throwException)
+			throw KeyBadErr();
+	}
+	else
+		m_state = KEY_GOOD;
+}
+
+// ********************************************************
+
+static DefaultMAC * NewDefaultEncryptorMAC(const byte *passphrase, size_t passphraseLength)
+{
+	size_t macKeyLength = DefaultMAC::StaticGetValidKeyLength(16);
+	SecByteBlock macKey(macKeyLength);
+	// since the MAC is encrypted there is no reason to mash the passphrase for many iterations
+	Mash(passphrase, passphraseLength, macKey, macKeyLength, 1);
+	return new DefaultMAC(macKey, macKeyLength);
+}
+
+DefaultEncryptorWithMAC::DefaultEncryptorWithMAC(const char *passphrase, BufferedTransformation *attachment)
+	: ProxyFilter(NULL, 0, 0, attachment)
+	, m_mac(NewDefaultEncryptorMAC((const byte *)passphrase, strlen(passphrase)))
+{
+	SetFilter(new HashFilter(*m_mac, new DefaultEncryptor(passphrase), true));
+}
+
+DefaultEncryptorWithMAC::DefaultEncryptorWithMAC(const byte *passphrase, size_t passphraseLength, BufferedTransformation *attachment)
+	: ProxyFilter(NULL, 0, 0, attachment)
+	, m_mac(NewDefaultEncryptorMAC(passphrase, passphraseLength))
+{
+	SetFilter(new HashFilter(*m_mac, new DefaultEncryptor(passphrase, passphraseLength), true));
+}
+
+void DefaultEncryptorWithMAC::LastPut(const byte *inString, size_t length)
+{
+	m_filter->MessageEnd();
+}
+
+// ********************************************************
+
+DefaultDecryptorWithMAC::DefaultDecryptorWithMAC(const char *passphrase, BufferedTransformation *attachment, bool throwException)
+	: ProxyFilter(NULL, 0, 0, attachment)
+	, m_mac(NewDefaultEncryptorMAC((const byte *)passphrase, strlen(passphrase)))
+	, m_throwException(throwException)
+{
+	SetFilter(new DefaultDecryptor(passphrase, m_hashVerifier=new HashVerifier(*m_mac, NULL, HashVerifier::PUT_MESSAGE), throwException));
+}
+
+DefaultDecryptorWithMAC::DefaultDecryptorWithMAC(const byte *passphrase, size_t passphraseLength, BufferedTransformation *attachment, bool throwException)
+	: ProxyFilter(NULL, 0, 0, attachment)
+	, m_mac(NewDefaultEncryptorMAC(passphrase, passphraseLength))
+	, m_throwException(throwException)
+{
+	SetFilter(new DefaultDecryptor(passphrase, passphraseLength, m_hashVerifier=new HashVerifier(*m_mac, NULL, HashVerifier::PUT_MESSAGE), throwException));
+}
+
+DefaultDecryptor::State DefaultDecryptorWithMAC::CurrentState() const
+{
+	return static_cast<const DefaultDecryptor *>(m_filter.get())->CurrentState();
+}
+
+bool DefaultDecryptorWithMAC::CheckLastMAC() const
+{
+	return m_hashVerifier->GetLastResult();
+}
+
+void DefaultDecryptorWithMAC::LastPut(const byte *inString, size_t length)
+{
+	m_filter->MessageEnd();
+	if (m_throwException && !CheckLastMAC())
+		throw MACBadErr();
+}
+
+NAMESPACE_END
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/des.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/des.cpp
index f8f2e5f4..a6e0c514 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/src/des.cpp
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/des.cpp
@@ -1,464 +1,449 @@
-// des.cpp - modified by Wei Dai from Phil Karn's des.c
-// The original code and all modifications are in the public domain.
-
-/*
- * This is a major rewrite of my old public domain DES code written
- * circa 1987, which in turn borrowed heavily from Jim Gillogly's 1977
- * public domain code. I pretty much kept my key scheduling code, but
- * the actual encrypt/decrypt routines are taken from from Richard
- * Outerbridge's DES code as printed in Schneier's "Applied Cryptography."
- *
- * This code is in the public domain. I would appreciate bug reports and
- * enhancements.
- *
- * Phil Karn KA9Q, karn@unix.ka9q.ampr.org, August 1994.
- */
-
-//#include "pch.h"
-#include "misc.h"
-#include "des.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-static inline bool CheckParity(byte b)
-{
-	unsigned int a = b ^ (b >> 4);
-	return ((a ^ (a>>1) ^ (a>>2) ^ (a>>3)) & 1) == 1;
-}
-
-bool DES::CheckKeyParityBits(const byte *key)
-{
-	for (unsigned int i=0; i<8; i++)
-		if (!CheckParity(key[i]))
-			return false;
-	return true;
-}
-
-void DES::CorrectKeyParityBits(byte *key)
-{
-	for (unsigned int i=0; i<8; i++)
-		if (!CheckParity(key[i]))
-			key[i] ^= 1;
-}
-
-/* Tables defined in the Data Encryption Standard documents
- * Three of these tables, the initial permutation, the final
- * permutation and the expansion operator, are regular enough that
- * for speed, we hard-code them. They're here for reference only.
- * Also, the S and P boxes are used by a separate program, gensp.c,
- * to build the combined SP box, Spbox[]. They're also here just
- * for reference.
- */
-#ifdef notdef
-/* initial permutation IP */
-static byte ip[] = {
-	   58, 50, 42, 34, 26, 18, 10,  2,
-	   60, 52, 44, 36, 28, 20, 12,  4,
-	   62, 54, 46, 38, 30, 22, 14,  6,
-	   64, 56, 48, 40, 32, 24, 16,  8,
-	   57, 49, 41, 33, 25, 17,  9,  1,
-	   59, 51, 43, 35, 27, 19, 11,  3,
-	   61, 53, 45, 37, 29, 21, 13,  5,
-	   63, 55, 47, 39, 31, 23, 15,  7
-};
-
-/* final permutation IP^-1 */
-static byte fp[] = {
-	   40,  8, 48, 16, 56, 24, 64, 32,
-	   39,  7, 47, 15, 55, 23, 63, 31,
-	   38,  6, 46, 14, 54, 22, 62, 30,
-	   37,  5, 45, 13, 53, 21, 61, 29,
-	   36,  4, 44, 12, 52, 20, 60, 28,
-	   35,  3, 43, 11, 51, 19, 59, 27,
-	   34,  2, 42, 10, 50, 18, 58, 26,
-	   33,  1, 41,  9, 49, 17, 57, 25
-};
-/* expansion operation matrix */
-static byte ei[] = {
-	   32,  1,  2,  3,  4,  5,
-		4,  5,  6,  7,  8,  9,
-		8,  9, 10, 11, 12, 13,
-	   12, 13, 14, 15, 16, 17,
-	   16, 17, 18, 19, 20, 21,
-	   20, 21, 22, 23, 24, 25,
-	   24, 25, 26, 27, 28, 29,
-	   28, 29, 30, 31, 32,  1
-};
-/* The (in)famous S-boxes */
-static byte sbox[8][64] = {
-	   /* S1 */
-	   14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7,
-		0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8,
-		4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0,
-	   15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13,
-
-	   /* S2 */
-	   15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10,
-		3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5,
-		0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15,
-	   13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9,
-
-	   /* S3 */
-	   10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8,
-	   13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1,
-	   13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7,
-		1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12,
-
-	   /* S4 */
-		7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15,
-	   13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9,
-	   10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4,
-		3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14,
-
-	   /* S5 */
-		2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9,
-	   14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6,
-		4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14,
-	   11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3,
-
-	   /* S6 */
-	   12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11,
-	   10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8,
-		9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6,
-		4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13,
-
-	   /* S7 */
-		4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1,
-	   13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6,
-		1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2,
-		6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12,
-
-	   /* S8 */
-	   13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7,
-		1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2,
-		7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8,
-		2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11
-};
-
-/* 32-bit permutation function P used on the output of the S-boxes */
-static byte p32i[] = {
-	   16,  7, 20, 21,
-	   29, 12, 28, 17,
-		1, 15, 23, 26,
-		5, 18, 31, 10,
-		2,  8, 24, 14,
-	   32, 27,  3,  9,
-	   19, 13, 30,  6,
-	   22, 11,  4, 25
-};
-#endif
-
-/* permuted choice table (key) */
-static const byte pc1[] = {
-	   57, 49, 41, 33, 25, 17,  9,
-		1, 58, 50, 42, 34, 26, 18,
-	   10,  2, 59, 51, 43, 35, 27,
-	   19, 11,  3, 60, 52, 44, 36,
-
-	   63, 55, 47, 39, 31, 23, 15,
-		7, 62, 54, 46, 38, 30, 22,
-	   14,  6, 61, 53, 45, 37, 29,
-	   21, 13,  5, 28, 20, 12,  4
-};
-
-/* number left rotations of pc1 */
-static const byte totrot[] = {
-	   1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28
-};
-
-/* permuted choice key (table) */
-static const byte pc2[] = {
-	   14, 17, 11, 24,  1,  5,
-		3, 28, 15,  6, 21, 10,
-	   23, 19, 12,  4, 26,  8,
-	   16,  7, 27, 20, 13,  2,
-	   41, 52, 31, 37, 47, 55,
-	   30, 40, 51, 45, 33, 48,
-	   44, 49, 39, 56, 34, 53,
-	   46, 42, 50, 36, 29, 32
-};
-
-/* End of DES-defined tables */
-
-/* bit 0 is left-most in byte */
-static const int bytebit[] = {
-	   0200,0100,040,020,010,04,02,01
-};
-
-/* Set key (initialize key schedule array) */
-void DES::Base::UncheckedSetKey(CipherDir dir, const byte *key, unsigned int length)
-{
-	AssertValidKeyLength(length);
-
-	SecByteBlock buffer(56+56+8);
-	byte *const pc1m=buffer;                 /* place to modify pc1 into */
-	byte *const pcr=pc1m+56;                 /* place to rotate pc1 into */
-	byte *const ks=pcr+56;
-	register int i,j,l;
-	int m;
-	
-	for (j=0; j<56; j++) {          /* convert pc1 to bits of key */
-		l=pc1[j]-1;             /* integer bit location  */
-		m = l & 07;             /* find bit              */
-		pc1m[j]=(key[l>>3] &    /* find which key byte l is in */
-			bytebit[m])     /* and which bit of that byte */
-			? 1 : 0;        /* and store 1-bit result */
-	}
-	for (i=0; i<16; i++) {          /* key chunk for each iteration */
-		memset(ks,0,8);         /* Clear key schedule */
-		for (j=0; j<56; j++)    /* rotate pc1 the right amount */
-			pcr[j] = pc1m[(l=j+totrot[i])<(j<28? 28 : 56) ? l: l-28];
-		/* rotate left and right halves independently */
-		for (j=0; j<48; j++){   /* select bits individually */
-			/* check bit that goes to ks[j] */
-			if (pcr[pc2[j]-1]){
-				/* mask it in if it's there */
-				l= j % 6;
-				ks[j/6] |= bytebit[l] >> 2;
-			}
-		}
-		/* Now convert to odd/even interleaved form for use in F */
-		k[2*i] = ((word32)ks[0] << 24)
-			| ((word32)ks[2] << 16)
-			| ((word32)ks[4] << 8)
-			| ((word32)ks[6]);
-		k[2*i+1] = ((word32)ks[1] << 24)
-			| ((word32)ks[3] << 16)
-			| ((word32)ks[5] << 8)
-			| ((word32)ks[7]);
-	}
-	
-	if (dir==DECRYPTION)     // reverse key schedule order
-		for (i=0; i<16; i+=2)
-		{
-			std::swap(k[i], k[32-2-i]);
-			std::swap(k[i+1], k[32-1-i]);
-		}
-}
-
-// Richard Outerbridge's initial permutation algorithm
-/*
-inline void IPERM(word32 &left, word32 &right)
-{
-	word32 work;
-
-	work = ((left >> 4) ^ right) & 0x0f0f0f0f;
-	right ^= work;
-	left ^= work << 4;
-	work = ((left >> 16) ^ right) & 0xffff;
-	right ^= work;
-	left ^= work << 16;
-	work = ((right >> 2) ^ left) & 0x33333333;
-	left ^= work;
-	right ^= (work << 2);
-	work = ((right >> 8) ^ left) & 0xff00ff;
-	left ^= work;
-	right ^= (work << 8);
-	right = rotl(right, 1);
-	work = (left ^ right) & 0xaaaaaaaa;
-	left ^= work;
-	right ^= work;
-	left = rotl(left, 1);
-}
-inline void FPERM(word32 &left, word32 &right)
-{
-	word32 work;
-
-	right = rotr(right, 1);
-	work = (left ^ right) & 0xaaaaaaaa;
-	left ^= work;
-	right ^= work;
-	left = rotr(left, 1);
-	work = ((left >> 8) ^ right) & 0xff00ff;
-	right ^= work;
-	left ^= work << 8;
-	work = ((left >> 2) ^ right) & 0x33333333;
-	right ^= work;
-	left ^= work << 2;
-	work = ((right >> 16) ^ left) & 0xffff;
-	left ^= work;
-	right ^= work << 16;
-	work = ((right >> 4) ^ left) & 0x0f0f0f0f;
-	left ^= work;
-	right ^= work << 4;
-}
-*/
-
-// Wei Dai's modification to Richard Outerbridge's initial permutation 
-// algorithm, this one is faster if you have access to rotate instructions 
-// (like in MSVC)
-static inline void IPERM(word32 &left, word32 &right)
-{
-	word32 work;
-
-	right = rotlFixed(right, 4U);
-	work = (left ^ right) & 0xf0f0f0f0;
-	left ^= work;
-	right = rotrFixed(right^work, 20U);
-	work = (left ^ right) & 0xffff0000;
-	left ^= work;
-	right = rotrFixed(right^work, 18U);
-	work = (left ^ right) & 0x33333333;
-	left ^= work;
-	right = rotrFixed(right^work, 6U);
-	work = (left ^ right) & 0x00ff00ff;
-	left ^= work;
-	right = rotlFixed(right^work, 9U);
-	work = (left ^ right) & 0xaaaaaaaa;
-	left = rotlFixed(left^work, 1U);
-	right ^= work;
-}
-
-static inline void FPERM(word32 &left, word32 &right)
-{
-	word32 work;
-
-	right = rotrFixed(right, 1U);
-	work = (left ^ right) & 0xaaaaaaaa;
-	right ^= work;
-	left = rotrFixed(left^work, 9U);
-	work = (left ^ right) & 0x00ff00ff;
-	right ^= work;
-	left = rotlFixed(left^work, 6U);
-	work = (left ^ right) & 0x33333333;
-	right ^= work;
-	left = rotlFixed(left^work, 18U);
-	work = (left ^ right) & 0xffff0000;
-	right ^= work;
-	left = rotlFixed(left^work, 20U);
-	work = (left ^ right) & 0xf0f0f0f0;
-	right ^= work;
-	left = rotrFixed(left^work, 4U);
-}
-
-void DES::Base::RawProcessBlock(word32 &l_, word32 &r_) const
-{
-	word32 l = l_, r = r_;
-	const word32 *kptr=k;
-
-	for (unsigned i=0; i<8; i++)
-	{
-		word32 work = rotrFixed(r, 4U) ^ kptr[4*i+0];
-		l ^= Spbox[6][(work) & 0x3f]
-		  ^  Spbox[4][(work >> 8) & 0x3f]
-		  ^  Spbox[2][(work >> 16) & 0x3f]
-		  ^  Spbox[0][(work >> 24) & 0x3f];
-		work = r ^ kptr[4*i+1];
-		l ^= Spbox[7][(work) & 0x3f]
-		  ^  Spbox[5][(work >> 8) & 0x3f]
-		  ^  Spbox[3][(work >> 16) & 0x3f]
-		  ^  Spbox[1][(work >> 24) & 0x3f];
-
-		work = rotrFixed(l, 4U) ^ kptr[4*i+2];
-		r ^= Spbox[6][(work) & 0x3f]
-		  ^  Spbox[4][(work >> 8) & 0x3f]
-		  ^  Spbox[2][(work >> 16) & 0x3f]
-		  ^  Spbox[0][(work >> 24) & 0x3f];
-		work = l ^ kptr[4*i+3];
-		r ^= Spbox[7][(work) & 0x3f]
-		  ^  Spbox[5][(work >> 8) & 0x3f]
-		  ^  Spbox[3][(work >> 16) & 0x3f]
-		  ^  Spbox[1][(work >> 24) & 0x3f];
-	}
-
-	l_ = l; r_ = r;
-}
-
-typedef BlockGetAndPut<word32, BigEndian> Block;
-
-// Encrypt or decrypt a block of data in ECB mode
-void DES::Base::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const
-{
-	word32 l,r;
-	Block::Get(inBlock)(l)(r);
-	IPERM(l,r);
-
-	const word32 *kptr=k;
-
-	for (unsigned i=0; i<8; i++)
-	{
-		word32 work = rotrFixed(r, 4U) ^ kptr[4*i+0];
-		l ^= Spbox[6][(work) & 0x3f]
-		  ^  Spbox[4][(work >> 8) & 0x3f]
-		  ^  Spbox[2][(work >> 16) & 0x3f]
-		  ^  Spbox[0][(work >> 24) & 0x3f];
-		work = r ^ kptr[4*i+1];
-		l ^= Spbox[7][(work) & 0x3f]
-		  ^  Spbox[5][(work >> 8) & 0x3f]
-		  ^  Spbox[3][(work >> 16) & 0x3f]
-		  ^  Spbox[1][(work >> 24) & 0x3f];
-
-		work = rotrFixed(l, 4U) ^ kptr[4*i+2];
-		r ^= Spbox[6][(work) & 0x3f]
-		  ^  Spbox[4][(work >> 8) & 0x3f]
-		  ^  Spbox[2][(work >> 16) & 0x3f]
-		  ^  Spbox[0][(work >> 24) & 0x3f];
-		work = l ^ kptr[4*i+3];
-		r ^= Spbox[7][(work) & 0x3f]
-		  ^  Spbox[5][(work >> 8) & 0x3f]
-		  ^  Spbox[3][(work >> 16) & 0x3f]
-		  ^  Spbox[1][(work >> 24) & 0x3f];
-	}
-
-	FPERM(l,r);
-	Block::Put(xorBlock, outBlock)(r)(l);
-}
-
-void DES_EDE2::Base::UncheckedSetKey(CipherDir dir, const byte *key, unsigned int length)
-{
-	AssertValidKeyLength(length);
-
-	m_des1.UncheckedSetKey(dir, key);
-	m_des2.UncheckedSetKey(ReverseCipherDir(dir), key+8);
-}
-
-void DES_EDE2::Base::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const
-{
-	word32 l,r;
-	Block::Get(inBlock)(l)(r);
-	IPERM(l,r);
-	m_des1.RawProcessBlock(l, r);
-	m_des2.RawProcessBlock(r, l);
-	m_des1.RawProcessBlock(l, r);
-	FPERM(l,r);
-	Block::Put(xorBlock, outBlock)(r)(l);
-}
-
-void DES_EDE3::Base::UncheckedSetKey(CipherDir dir, const byte *key, unsigned int length)
-{
-	AssertValidKeyLength(length);
-
-	m_des1.UncheckedSetKey(dir, key+(dir==ENCRYPTION?0:2*8));
-	m_des2.UncheckedSetKey(ReverseCipherDir(dir), key+8);
-	m_des3.UncheckedSetKey(dir, key+(dir==DECRYPTION?0:2*8));
-}
-
-void DES_EDE3::Base::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const
-{
-	word32 l,r;
-	Block::Get(inBlock)(l)(r);
-	IPERM(l,r);
-	m_des1.RawProcessBlock(l, r);
-	m_des2.RawProcessBlock(r, l);
-	m_des3.RawProcessBlock(l, r);
-	FPERM(l,r);
-	Block::Put(xorBlock, outBlock)(r)(l);
-}
-
-void DES_XEX3::Base::UncheckedSetKey(CipherDir dir, const byte *key, unsigned int length)
-{
-	AssertValidKeyLength(length);
-
-	memcpy(m_x1, key+(dir==ENCRYPTION?0:2*8), BLOCKSIZE);
-	m_des.UncheckedSetKey(dir, key+8);
-	memcpy(m_x3, key+(dir==DECRYPTION?0:2*8), BLOCKSIZE);
-}
-
-void DES_XEX3::Base::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const
-{
-	xorbuf(outBlock, inBlock, m_x1, BLOCKSIZE);
-	m_des.ProcessAndXorBlock(outBlock, xorBlock, outBlock);
-	xorbuf(outBlock, m_x3, BLOCKSIZE);
-}
-
-NAMESPACE_END
+// des.cpp - modified by Wei Dai from Phil Karn's des.c
+// The original code and all modifications are in the public domain.
+
+/*
+ * This is a major rewrite of my old public domain DES code written
+ * circa 1987, which in turn borrowed heavily from Jim Gillogly's 1977
+ * public domain code. I pretty much kept my key scheduling code, but
+ * the actual encrypt/decrypt routines are taken from from Richard
+ * Outerbridge's DES code as printed in Schneier's "Applied Cryptography."
+ *
+ * This code is in the public domain. I would appreciate bug reports and
+ * enhancements.
+ *
+ * Phil Karn KA9Q, karn@unix.ka9q.ampr.org, August 1994.
+ */
+
+#include "pch.h"
+#include "misc.h"
+#include "des.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+typedef BlockGetAndPut<word32, BigEndian> Block;
+
+// Richard Outerbridge's initial permutation algorithm
+/*
+inline void IPERM(word32 &left, word32 &right)
+{
+	word32 work;
+
+	work = ((left >> 4) ^ right) & 0x0f0f0f0f;
+	right ^= work;
+	left ^= work << 4;
+	work = ((left >> 16) ^ right) & 0xffff;
+	right ^= work;
+	left ^= work << 16;
+	work = ((right >> 2) ^ left) & 0x33333333;
+	left ^= work;
+	right ^= (work << 2);
+	work = ((right >> 8) ^ left) & 0xff00ff;
+	left ^= work;
+	right ^= (work << 8);
+	right = rotl(right, 1);
+	work = (left ^ right) & 0xaaaaaaaa;
+	left ^= work;
+	right ^= work;
+	left = rotl(left, 1);
+}
+inline void FPERM(word32 &left, word32 &right)
+{
+	word32 work;
+
+	right = rotr(right, 1);
+	work = (left ^ right) & 0xaaaaaaaa;
+	left ^= work;
+	right ^= work;
+	left = rotr(left, 1);
+	work = ((left >> 8) ^ right) & 0xff00ff;
+	right ^= work;
+	left ^= work << 8;
+	work = ((left >> 2) ^ right) & 0x33333333;
+	right ^= work;
+	left ^= work << 2;
+	work = ((right >> 16) ^ left) & 0xffff;
+	left ^= work;
+	right ^= work << 16;
+	work = ((right >> 4) ^ left) & 0x0f0f0f0f;
+	left ^= work;
+	right ^= work << 4;
+}
+*/
+
+// Wei Dai's modification to Richard Outerbridge's initial permutation 
+// algorithm, this one is faster if you have access to rotate instructions 
+// (like in MSVC)
+static inline void IPERM(word32 &left, word32 &right)
+{
+	word32 work;
+
+	right = rotlFixed(right, 4U);
+	work = (left ^ right) & 0xf0f0f0f0;
+	left ^= work;
+	right = rotrFixed(right^work, 20U);
+	work = (left ^ right) & 0xffff0000;
+	left ^= work;
+	right = rotrFixed(right^work, 18U);
+	work = (left ^ right) & 0x33333333;
+	left ^= work;
+	right = rotrFixed(right^work, 6U);
+	work = (left ^ right) & 0x00ff00ff;
+	left ^= work;
+	right = rotlFixed(right^work, 9U);
+	work = (left ^ right) & 0xaaaaaaaa;
+	left = rotlFixed(left^work, 1U);
+	right ^= work;
+}
+
+static inline void FPERM(word32 &left, word32 &right)
+{
+	word32 work;
+
+	right = rotrFixed(right, 1U);
+	work = (left ^ right) & 0xaaaaaaaa;
+	right ^= work;
+	left = rotrFixed(left^work, 9U);
+	work = (left ^ right) & 0x00ff00ff;
+	right ^= work;
+	left = rotlFixed(left^work, 6U);
+	work = (left ^ right) & 0x33333333;
+	right ^= work;
+	left = rotlFixed(left^work, 18U);
+	work = (left ^ right) & 0xffff0000;
+	right ^= work;
+	left = rotlFixed(left^work, 20U);
+	work = (left ^ right) & 0xf0f0f0f0;
+	right ^= work;
+	left = rotrFixed(left^work, 4U);
+}
+
+void DES::Base::UncheckedSetKey(const byte *userKey, unsigned int length, const NameValuePairs &)
+{
+	AssertValidKeyLength(length);
+
+	RawSetKey(GetCipherDirection(), userKey);
+}
+
+#ifndef CRYPTOPP_IMPORTS
+
+/* Tables defined in the Data Encryption Standard documents
+ * Three of these tables, the initial permutation, the final
+ * permutation and the expansion operator, are regular enough that
+ * for speed, we hard-code them. They're here for reference only.
+ * Also, the S and P boxes are used by a separate program, gensp.c,
+ * to build the combined SP box, Spbox[]. They're also here just
+ * for reference.
+ */
+#ifdef notdef
+/* initial permutation IP */
+static byte ip[] = {
+	   58, 50, 42, 34, 26, 18, 10,  2,
+	   60, 52, 44, 36, 28, 20, 12,  4,
+	   62, 54, 46, 38, 30, 22, 14,  6,
+	   64, 56, 48, 40, 32, 24, 16,  8,
+	   57, 49, 41, 33, 25, 17,  9,  1,
+	   59, 51, 43, 35, 27, 19, 11,  3,
+	   61, 53, 45, 37, 29, 21, 13,  5,
+	   63, 55, 47, 39, 31, 23, 15,  7
+};
+
+/* final permutation IP^-1 */
+static byte fp[] = {
+	   40,  8, 48, 16, 56, 24, 64, 32,
+	   39,  7, 47, 15, 55, 23, 63, 31,
+	   38,  6, 46, 14, 54, 22, 62, 30,
+	   37,  5, 45, 13, 53, 21, 61, 29,
+	   36,  4, 44, 12, 52, 20, 60, 28,
+	   35,  3, 43, 11, 51, 19, 59, 27,
+	   34,  2, 42, 10, 50, 18, 58, 26,
+	   33,  1, 41,  9, 49, 17, 57, 25
+};
+/* expansion operation matrix */
+static byte ei[] = {
+	   32,  1,  2,  3,  4,  5,
+		4,  5,  6,  7,  8,  9,
+		8,  9, 10, 11, 12, 13,
+	   12, 13, 14, 15, 16, 17,
+	   16, 17, 18, 19, 20, 21,
+	   20, 21, 22, 23, 24, 25,
+	   24, 25, 26, 27, 28, 29,
+	   28, 29, 30, 31, 32,  1
+};
+/* The (in)famous S-boxes */
+static byte sbox[8][64] = {
+	   /* S1 */
+	   14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7,
+		0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8,
+		4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0,
+	   15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13,
+
+	   /* S2 */
+	   15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10,
+		3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5,
+		0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15,
+	   13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9,
+
+	   /* S3 */
+	   10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8,
+	   13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1,
+	   13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7,
+		1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12,
+
+	   /* S4 */
+		7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15,
+	   13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9,
+	   10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4,
+		3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14,
+
+	   /* S5 */
+		2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9,
+	   14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6,
+		4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14,
+	   11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3,
+
+	   /* S6 */
+	   12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11,
+	   10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8,
+		9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6,
+		4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13,
+
+	   /* S7 */
+		4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1,
+	   13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6,
+		1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2,
+		6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12,
+
+	   /* S8 */
+	   13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7,
+		1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2,
+		7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8,
+		2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11
+};
+
+/* 32-bit permutation function P used on the output of the S-boxes */
+static byte p32i[] = {
+	   16,  7, 20, 21,
+	   29, 12, 28, 17,
+		1, 15, 23, 26,
+		5, 18, 31, 10,
+		2,  8, 24, 14,
+	   32, 27,  3,  9,
+	   19, 13, 30,  6,
+	   22, 11,  4, 25
+};
+#endif
+
+/* permuted choice table (key) */
+static const byte pc1[] = {
+	   57, 49, 41, 33, 25, 17,  9,
+		1, 58, 50, 42, 34, 26, 18,
+	   10,  2, 59, 51, 43, 35, 27,
+	   19, 11,  3, 60, 52, 44, 36,
+
+	   63, 55, 47, 39, 31, 23, 15,
+		7, 62, 54, 46, 38, 30, 22,
+	   14,  6, 61, 53, 45, 37, 29,
+	   21, 13,  5, 28, 20, 12,  4
+};
+
+/* number left rotations of pc1 */
+static const byte totrot[] = {
+	   1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28
+};
+
+/* permuted choice key (table) */
+static const byte pc2[] = {
+	   14, 17, 11, 24,  1,  5,
+		3, 28, 15,  6, 21, 10,
+	   23, 19, 12,  4, 26,  8,
+	   16,  7, 27, 20, 13,  2,
+	   41, 52, 31, 37, 47, 55,
+	   30, 40, 51, 45, 33, 48,
+	   44, 49, 39, 56, 34, 53,
+	   46, 42, 50, 36, 29, 32
+};
+
+/* End of DES-defined tables */
+
+/* bit 0 is left-most in byte */
+static const int bytebit[] = {
+	   0200,0100,040,020,010,04,02,01
+};
+
+/* Set key (initialize key schedule array) */
+void RawDES::RawSetKey(CipherDir dir, const byte *key)
+{
+	SecByteBlock buffer(56+56+8);
+	byte *const pc1m=buffer;                 /* place to modify pc1 into */
+	byte *const pcr=pc1m+56;                 /* place to rotate pc1 into */
+	byte *const ks=pcr+56;
+	register int i,j,l;
+	int m;
+	
+	for (j=0; j<56; j++) {          /* convert pc1 to bits of key */
+		l=pc1[j]-1;             /* integer bit location  */
+		m = l & 07;             /* find bit              */
+		pc1m[j]=(key[l>>3] &    /* find which key byte l is in */
+			bytebit[m])     /* and which bit of that byte */
+			? 1 : 0;        /* and store 1-bit result */
+	}
+	for (i=0; i<16; i++) {          /* key chunk for each iteration */
+		memset(ks,0,8);         /* Clear key schedule */
+		for (j=0; j<56; j++)    /* rotate pc1 the right amount */
+			pcr[j] = pc1m[(l=j+totrot[i])<(j<28? 28 : 56) ? l: l-28];
+		/* rotate left and right halves independently */
+		for (j=0; j<48; j++){   /* select bits individually */
+			/* check bit that goes to ks[j] */
+			if (pcr[pc2[j]-1]){
+				/* mask it in if it's there */
+				l= j % 6;
+				ks[j/6] |= bytebit[l] >> 2;
+			}
+		}
+		/* Now convert to odd/even interleaved form for use in F */
+		k[2*i] = ((word32)ks[0] << 24)
+			| ((word32)ks[2] << 16)
+			| ((word32)ks[4] << 8)
+			| ((word32)ks[6]);
+		k[2*i+1] = ((word32)ks[1] << 24)
+			| ((word32)ks[3] << 16)
+			| ((word32)ks[5] << 8)
+			| ((word32)ks[7]);
+	}
+	
+	if (dir==DECRYPTION)     // reverse key schedule order
+		for (i=0; i<16; i+=2)
+		{
+			std::swap(k[i], k[32-2-i]);
+			std::swap(k[i+1], k[32-1-i]);
+		}
+}
+
+void RawDES::RawProcessBlock(word32 &l_, word32 &r_) const
+{
+	word32 l = l_, r = r_;
+	const word32 *kptr=k;
+
+	for (unsigned i=0; i<8; i++)
+	{
+		word32 work = rotrFixed(r, 4U) ^ kptr[4*i+0];
+		l ^= Spbox[6][(work) & 0x3f]
+		  ^  Spbox[4][(work >> 8) & 0x3f]
+		  ^  Spbox[2][(work >> 16) & 0x3f]
+		  ^  Spbox[0][(work >> 24) & 0x3f];
+		work = r ^ kptr[4*i+1];
+		l ^= Spbox[7][(work) & 0x3f]
+		  ^  Spbox[5][(work >> 8) & 0x3f]
+		  ^  Spbox[3][(work >> 16) & 0x3f]
+		  ^  Spbox[1][(work >> 24) & 0x3f];
+
+		work = rotrFixed(l, 4U) ^ kptr[4*i+2];
+		r ^= Spbox[6][(work) & 0x3f]
+		  ^  Spbox[4][(work >> 8) & 0x3f]
+		  ^  Spbox[2][(work >> 16) & 0x3f]
+		  ^  Spbox[0][(work >> 24) & 0x3f];
+		work = l ^ kptr[4*i+3];
+		r ^= Spbox[7][(work) & 0x3f]
+		  ^  Spbox[5][(work >> 8) & 0x3f]
+		  ^  Spbox[3][(work >> 16) & 0x3f]
+		  ^  Spbox[1][(work >> 24) & 0x3f];
+	}
+
+	l_ = l; r_ = r;
+}
+
+void DES_EDE2::Base::UncheckedSetKey(const byte *userKey, unsigned int length, const NameValuePairs &)
+{
+	AssertValidKeyLength(length);
+
+	m_des1.RawSetKey(GetCipherDirection(), userKey);
+	m_des2.RawSetKey(ReverseCipherDir(GetCipherDirection()), userKey+8);
+}
+
+void DES_EDE2::Base::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const
+{
+	word32 l,r;
+	Block::Get(inBlock)(l)(r);
+	IPERM(l,r);
+	m_des1.RawProcessBlock(l, r);
+	m_des2.RawProcessBlock(r, l);
+	m_des1.RawProcessBlock(l, r);
+	FPERM(l,r);
+	Block::Put(xorBlock, outBlock)(r)(l);
+}
+
+void DES_EDE3::Base::UncheckedSetKey(const byte *userKey, unsigned int length, const NameValuePairs &)
+{
+	AssertValidKeyLength(length);
+
+	m_des1.RawSetKey(GetCipherDirection(), userKey + (IsForwardTransformation() ? 0 : 16));
+	m_des2.RawSetKey(ReverseCipherDir(GetCipherDirection()), userKey + 8);
+	m_des3.RawSetKey(GetCipherDirection(), userKey + (IsForwardTransformation() ? 16 : 0));
+}
+
+void DES_EDE3::Base::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const
+{
+	word32 l,r;
+	Block::Get(inBlock)(l)(r);
+	IPERM(l,r);
+	m_des1.RawProcessBlock(l, r);
+	m_des2.RawProcessBlock(r, l);
+	m_des3.RawProcessBlock(l, r);
+	FPERM(l,r);
+	Block::Put(xorBlock, outBlock)(r)(l);
+}
+
+#endif	// #ifndef CRYPTOPP_IMPORTS
+
+static inline bool CheckParity(byte b)
+{
+	unsigned int a = b ^ (b >> 4);
+	return ((a ^ (a>>1) ^ (a>>2) ^ (a>>3)) & 1) == 1;
+}
+
+bool DES::CheckKeyParityBits(const byte *key)
+{
+	for (unsigned int i=0; i<8; i++)
+		if (!CheckParity(key[i]))
+			return false;
+	return true;
+}
+
+void DES::CorrectKeyParityBits(byte *key)
+{
+	for (unsigned int i=0; i<8; i++)
+		if (!CheckParity(key[i]))
+			key[i] ^= 1;
+}
+
+// Encrypt or decrypt a block of data in ECB mode
+void DES::Base::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const
+{
+	word32 l,r;
+	Block::Get(inBlock)(l)(r);
+	IPERM(l,r);
+	RawProcessBlock(l, r);
+	FPERM(l,r);
+	Block::Put(xorBlock, outBlock)(r)(l);
+}
+
+void DES_XEX3::Base::UncheckedSetKey(const byte *key, unsigned int length, const NameValuePairs &)
+{
+	AssertValidKeyLength(length);
+
+	if (!m_des.get())
+		m_des.reset(new DES::Encryption);
+
+	memcpy(m_x1, key + (IsForwardTransformation() ? 0 : 16), BLOCKSIZE);
+	m_des->RawSetKey(GetCipherDirection(), key + 8);
+	memcpy(m_x3, key + (IsForwardTransformation() ? 16 : 0), BLOCKSIZE);
+}
+
+void DES_XEX3::Base::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const
+{
+	xorbuf(outBlock, inBlock, m_x1, BLOCKSIZE);
+	m_des->ProcessAndXorBlock(outBlock, xorBlock, outBlock);
+	xorbuf(outBlock, m_x3, BLOCKSIZE);
+}
+
+NAMESPACE_END
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/dessp.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/dessp.cpp
index 4e1898fb..49ed1d26 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/src/dessp.cpp
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/dessp.cpp
@@ -1,90 +1,95 @@
-// This file is mostly generated by Phil Karn's gensp.c
-
-//#include "pch.h"
-#include "des.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-// VC60 workaround: gives a C4786 warning without this function
-// when runtime lib is set to multithread debug DLL
-// even though warning 4786 is disabled!
-void DES_VC60Workaround()
-{
-}
-
-const word32 DES::Base::Spbox[8][64] = {
-{
-0x01010400,0x00000000,0x00010000,0x01010404, 0x01010004,0x00010404,0x00000004,0x00010000,
-0x00000400,0x01010400,0x01010404,0x00000400, 0x01000404,0x01010004,0x01000000,0x00000004,
-0x00000404,0x01000400,0x01000400,0x00010400, 0x00010400,0x01010000,0x01010000,0x01000404,
-0x00010004,0x01000004,0x01000004,0x00010004, 0x00000000,0x00000404,0x00010404,0x01000000,
-0x00010000,0x01010404,0x00000004,0x01010000, 0x01010400,0x01000000,0x01000000,0x00000400,
-0x01010004,0x00010000,0x00010400,0x01000004, 0x00000400,0x00000004,0x01000404,0x00010404,
-0x01010404,0x00010004,0x01010000,0x01000404, 0x01000004,0x00000404,0x00010404,0x01010400,
-0x00000404,0x01000400,0x01000400,0x00000000, 0x00010004,0x00010400,0x00000000,0x01010004},
-{
-0x80108020,0x80008000,0x00008000,0x00108020, 0x00100000,0x00000020,0x80100020,0x80008020,
-0x80000020,0x80108020,0x80108000,0x80000000, 0x80008000,0x00100000,0x00000020,0x80100020,
-0x00108000,0x00100020,0x80008020,0x00000000, 0x80000000,0x00008000,0x00108020,0x80100000,
-0x00100020,0x80000020,0x00000000,0x00108000, 0x00008020,0x80108000,0x80100000,0x00008020,
-0x00000000,0x00108020,0x80100020,0x00100000, 0x80008020,0x80100000,0x80108000,0x00008000,
-0x80100000,0x80008000,0x00000020,0x80108020, 0x00108020,0x00000020,0x00008000,0x80000000,
-0x00008020,0x80108000,0x00100000,0x80000020, 0x00100020,0x80008020,0x80000020,0x00100020,
-0x00108000,0x00000000,0x80008000,0x00008020, 0x80000000,0x80100020,0x80108020,0x00108000},
-{
-0x00000208,0x08020200,0x00000000,0x08020008, 0x08000200,0x00000000,0x00020208,0x08000200,
-0x00020008,0x08000008,0x08000008,0x00020000, 0x08020208,0x00020008,0x08020000,0x00000208,
-0x08000000,0x00000008,0x08020200,0x00000200, 0x00020200,0x08020000,0x08020008,0x00020208,
-0x08000208,0x00020200,0x00020000,0x08000208, 0x00000008,0x08020208,0x00000200,0x08000000,
-0x08020200,0x08000000,0x00020008,0x00000208, 0x00020000,0x08020200,0x08000200,0x00000000,
-0x00000200,0x00020008,0x08020208,0x08000200, 0x08000008,0x00000200,0x00000000,0x08020008,
-0x08000208,0x00020000,0x08000000,0x08020208, 0x00000008,0x00020208,0x00020200,0x08000008,
-0x08020000,0x08000208,0x00000208,0x08020000, 0x00020208,0x00000008,0x08020008,0x00020200},
-{
-0x00802001,0x00002081,0x00002081,0x00000080, 0x00802080,0x00800081,0x00800001,0x00002001,
-0x00000000,0x00802000,0x00802000,0x00802081, 0x00000081,0x00000000,0x00800080,0x00800001,
-0x00000001,0x00002000,0x00800000,0x00802001, 0x00000080,0x00800000,0x00002001,0x00002080,
-0x00800081,0x00000001,0x00002080,0x00800080, 0x00002000,0x00802080,0x00802081,0x00000081,
-0x00800080,0x00800001,0x00802000,0x00802081, 0x00000081,0x00000000,0x00000000,0x00802000,
-0x00002080,0x00800080,0x00800081,0x00000001, 0x00802001,0x00002081,0x00002081,0x00000080,
-0x00802081,0x00000081,0x00000001,0x00002000, 0x00800001,0x00002001,0x00802080,0x00800081,
-0x00002001,0x00002080,0x00800000,0x00802001, 0x00000080,0x00800000,0x00002000,0x00802080},
-{
-0x00000100,0x02080100,0x02080000,0x42000100, 0x00080000,0x00000100,0x40000000,0x02080000,
-0x40080100,0x00080000,0x02000100,0x40080100, 0x42000100,0x42080000,0x00080100,0x40000000,
-0x02000000,0x40080000,0x40080000,0x00000000, 0x40000100,0x42080100,0x42080100,0x02000100,
-0x42080000,0x40000100,0x00000000,0x42000000, 0x02080100,0x02000000,0x42000000,0x00080100,
-0x00080000,0x42000100,0x00000100,0x02000000, 0x40000000,0x02080000,0x42000100,0x40080100,
-0x02000100,0x40000000,0x42080000,0x02080100, 0x40080100,0x00000100,0x02000000,0x42080000,
-0x42080100,0x00080100,0x42000000,0x42080100, 0x02080000,0x00000000,0x40080000,0x42000000,
-0x00080100,0x02000100,0x40000100,0x00080000, 0x00000000,0x40080000,0x02080100,0x40000100},
-{
-0x20000010,0x20400000,0x00004000,0x20404010, 0x20400000,0x00000010,0x20404010,0x00400000,
-0x20004000,0x00404010,0x00400000,0x20000010, 0x00400010,0x20004000,0x20000000,0x00004010,
-0x00000000,0x00400010,0x20004010,0x00004000, 0x00404000,0x20004010,0x00000010,0x20400010,
-0x20400010,0x00000000,0x00404010,0x20404000, 0x00004010,0x00404000,0x20404000,0x20000000,
-0x20004000,0x00000010,0x20400010,0x00404000, 0x20404010,0x00400000,0x00004010,0x20000010,
-0x00400000,0x20004000,0x20000000,0x00004010, 0x20000010,0x20404010,0x00404000,0x20400000,
-0x00404010,0x20404000,0x00000000,0x20400010, 0x00000010,0x00004000,0x20400000,0x00404010,
-0x00004000,0x00400010,0x20004010,0x00000000, 0x20404000,0x20000000,0x00400010,0x20004010},
-{
-0x00200000,0x04200002,0x04000802,0x00000000, 0x00000800,0x04000802,0x00200802,0x04200800,
-0x04200802,0x00200000,0x00000000,0x04000002, 0x00000002,0x04000000,0x04200002,0x00000802,
-0x04000800,0x00200802,0x00200002,0x04000800, 0x04000002,0x04200000,0x04200800,0x00200002,
-0x04200000,0x00000800,0x00000802,0x04200802, 0x00200800,0x00000002,0x04000000,0x00200800,
-0x04000000,0x00200800,0x00200000,0x04000802, 0x04000802,0x04200002,0x04200002,0x00000002,
-0x00200002,0x04000000,0x04000800,0x00200000, 0x04200800,0x00000802,0x00200802,0x04200800,
-0x00000802,0x04000002,0x04200802,0x04200000, 0x00200800,0x00000000,0x00000002,0x04200802,
-0x00000000,0x00200802,0x04200000,0x00000800, 0x04000002,0x04000800,0x00000800,0x00200002},
-{
-0x10001040,0x00001000,0x00040000,0x10041040, 0x10000000,0x10001040,0x00000040,0x10000000,
-0x00040040,0x10040000,0x10041040,0x00041000, 0x10041000,0x00041040,0x00001000,0x00000040,
-0x10040000,0x10000040,0x10001000,0x00001040, 0x00041000,0x00040040,0x10040040,0x10041000,
-0x00001040,0x00000000,0x00000000,0x10040040, 0x10000040,0x10001000,0x00041040,0x00040000,
-0x00041040,0x00040000,0x10041000,0x00001000, 0x00000040,0x10040040,0x00001000,0x00041040,
-0x10001000,0x00000040,0x10000040,0x10040000, 0x10040040,0x10000000,0x00040000,0x10001040,
-0x00000000,0x10041040,0x00040040,0x10000040, 0x10040000,0x10001000,0x10001040,0x00000000,
-0x10041040,0x00041000,0x00041000,0x00001040, 0x00001040,0x00040040,0x10000000,0x10041000}
-};
-
-NAMESPACE_END
+// This file is mostly generated by Phil Karn's gensp.c
+
+#include "pch.h"
+
+#ifndef CRYPTOPP_IMPORTS
+
+#include "des.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+// VC60 workaround: gives a C4786 warning without this function
+// when runtime lib is set to multithread debug DLL
+// even though warning 4786 is disabled!
+void DES_VC60Workaround()
+{
+}
+
+const word32 RawDES::Spbox[8][64] = {
+{
+0x01010400,0x00000000,0x00010000,0x01010404, 0x01010004,0x00010404,0x00000004,0x00010000,
+0x00000400,0x01010400,0x01010404,0x00000400, 0x01000404,0x01010004,0x01000000,0x00000004,
+0x00000404,0x01000400,0x01000400,0x00010400, 0x00010400,0x01010000,0x01010000,0x01000404,
+0x00010004,0x01000004,0x01000004,0x00010004, 0x00000000,0x00000404,0x00010404,0x01000000,
+0x00010000,0x01010404,0x00000004,0x01010000, 0x01010400,0x01000000,0x01000000,0x00000400,
+0x01010004,0x00010000,0x00010400,0x01000004, 0x00000400,0x00000004,0x01000404,0x00010404,
+0x01010404,0x00010004,0x01010000,0x01000404, 0x01000004,0x00000404,0x00010404,0x01010400,
+0x00000404,0x01000400,0x01000400,0x00000000, 0x00010004,0x00010400,0x00000000,0x01010004},
+{
+0x80108020,0x80008000,0x00008000,0x00108020, 0x00100000,0x00000020,0x80100020,0x80008020,
+0x80000020,0x80108020,0x80108000,0x80000000, 0x80008000,0x00100000,0x00000020,0x80100020,
+0x00108000,0x00100020,0x80008020,0x00000000, 0x80000000,0x00008000,0x00108020,0x80100000,
+0x00100020,0x80000020,0x00000000,0x00108000, 0x00008020,0x80108000,0x80100000,0x00008020,
+0x00000000,0x00108020,0x80100020,0x00100000, 0x80008020,0x80100000,0x80108000,0x00008000,
+0x80100000,0x80008000,0x00000020,0x80108020, 0x00108020,0x00000020,0x00008000,0x80000000,
+0x00008020,0x80108000,0x00100000,0x80000020, 0x00100020,0x80008020,0x80000020,0x00100020,
+0x00108000,0x00000000,0x80008000,0x00008020, 0x80000000,0x80100020,0x80108020,0x00108000},
+{
+0x00000208,0x08020200,0x00000000,0x08020008, 0x08000200,0x00000000,0x00020208,0x08000200,
+0x00020008,0x08000008,0x08000008,0x00020000, 0x08020208,0x00020008,0x08020000,0x00000208,
+0x08000000,0x00000008,0x08020200,0x00000200, 0x00020200,0x08020000,0x08020008,0x00020208,
+0x08000208,0x00020200,0x00020000,0x08000208, 0x00000008,0x08020208,0x00000200,0x08000000,
+0x08020200,0x08000000,0x00020008,0x00000208, 0x00020000,0x08020200,0x08000200,0x00000000,
+0x00000200,0x00020008,0x08020208,0x08000200, 0x08000008,0x00000200,0x00000000,0x08020008,
+0x08000208,0x00020000,0x08000000,0x08020208, 0x00000008,0x00020208,0x00020200,0x08000008,
+0x08020000,0x08000208,0x00000208,0x08020000, 0x00020208,0x00000008,0x08020008,0x00020200},
+{
+0x00802001,0x00002081,0x00002081,0x00000080, 0x00802080,0x00800081,0x00800001,0x00002001,
+0x00000000,0x00802000,0x00802000,0x00802081, 0x00000081,0x00000000,0x00800080,0x00800001,
+0x00000001,0x00002000,0x00800000,0x00802001, 0x00000080,0x00800000,0x00002001,0x00002080,
+0x00800081,0x00000001,0x00002080,0x00800080, 0x00002000,0x00802080,0x00802081,0x00000081,
+0x00800080,0x00800001,0x00802000,0x00802081, 0x00000081,0x00000000,0x00000000,0x00802000,
+0x00002080,0x00800080,0x00800081,0x00000001, 0x00802001,0x00002081,0x00002081,0x00000080,
+0x00802081,0x00000081,0x00000001,0x00002000, 0x00800001,0x00002001,0x00802080,0x00800081,
+0x00002001,0x00002080,0x00800000,0x00802001, 0x00000080,0x00800000,0x00002000,0x00802080},
+{
+0x00000100,0x02080100,0x02080000,0x42000100, 0x00080000,0x00000100,0x40000000,0x02080000,
+0x40080100,0x00080000,0x02000100,0x40080100, 0x42000100,0x42080000,0x00080100,0x40000000,
+0x02000000,0x40080000,0x40080000,0x00000000, 0x40000100,0x42080100,0x42080100,0x02000100,
+0x42080000,0x40000100,0x00000000,0x42000000, 0x02080100,0x02000000,0x42000000,0x00080100,
+0x00080000,0x42000100,0x00000100,0x02000000, 0x40000000,0x02080000,0x42000100,0x40080100,
+0x02000100,0x40000000,0x42080000,0x02080100, 0x40080100,0x00000100,0x02000000,0x42080000,
+0x42080100,0x00080100,0x42000000,0x42080100, 0x02080000,0x00000000,0x40080000,0x42000000,
+0x00080100,0x02000100,0x40000100,0x00080000, 0x00000000,0x40080000,0x02080100,0x40000100},
+{
+0x20000010,0x20400000,0x00004000,0x20404010, 0x20400000,0x00000010,0x20404010,0x00400000,
+0x20004000,0x00404010,0x00400000,0x20000010, 0x00400010,0x20004000,0x20000000,0x00004010,
+0x00000000,0x00400010,0x20004010,0x00004000, 0x00404000,0x20004010,0x00000010,0x20400010,
+0x20400010,0x00000000,0x00404010,0x20404000, 0x00004010,0x00404000,0x20404000,0x20000000,
+0x20004000,0x00000010,0x20400010,0x00404000, 0x20404010,0x00400000,0x00004010,0x20000010,
+0x00400000,0x20004000,0x20000000,0x00004010, 0x20000010,0x20404010,0x00404000,0x20400000,
+0x00404010,0x20404000,0x00000000,0x20400010, 0x00000010,0x00004000,0x20400000,0x00404010,
+0x00004000,0x00400010,0x20004010,0x00000000, 0x20404000,0x20000000,0x00400010,0x20004010},
+{
+0x00200000,0x04200002,0x04000802,0x00000000, 0x00000800,0x04000802,0x00200802,0x04200800,
+0x04200802,0x00200000,0x00000000,0x04000002, 0x00000002,0x04000000,0x04200002,0x00000802,
+0x04000800,0x00200802,0x00200002,0x04000800, 0x04000002,0x04200000,0x04200800,0x00200002,
+0x04200000,0x00000800,0x00000802,0x04200802, 0x00200800,0x00000002,0x04000000,0x00200800,
+0x04000000,0x00200800,0x00200000,0x04000802, 0x04000802,0x04200002,0x04200002,0x00000002,
+0x00200002,0x04000000,0x04000800,0x00200000, 0x04200800,0x00000802,0x00200802,0x04200800,
+0x00000802,0x04000002,0x04200802,0x04200000, 0x00200800,0x00000000,0x00000002,0x04200802,
+0x00000000,0x00200802,0x04200000,0x00000800, 0x04000002,0x04000800,0x00000800,0x00200002},
+{
+0x10001040,0x00001000,0x00040000,0x10041040, 0x10000000,0x10001040,0x00000040,0x10000000,
+0x00040040,0x10040000,0x10041040,0x00041000, 0x10041000,0x00041040,0x00001000,0x00000040,
+0x10040000,0x10000040,0x10001000,0x00001040, 0x00041000,0x00040040,0x10040040,0x10041000,
+0x00001040,0x00000000,0x00000000,0x10040040, 0x10000040,0x10001000,0x00041040,0x00040000,
+0x00041040,0x00040000,0x10041000,0x00001000, 0x00000040,0x10040040,0x00001000,0x00041040,
+0x10001000,0x00000040,0x10000040,0x10040000, 0x10040040,0x10000000,0x00040000,0x10001040,
+0x00000000,0x10041040,0x00040040,0x10000040, 0x10040000,0x10001000,0x10001040,0x00000000,
+0x10041040,0x00041000,0x00041000,0x00001040, 0x00001040,0x00040040,0x10000000,0x10041000}
+};
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/eprecomp.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/eprecomp.cpp
index 004f564f..a061cf6c 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/src/eprecomp.cpp
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/eprecomp.cpp
@@ -1,107 +1,112 @@
-// eprecomp.cpp - written and placed in the public domain by Wei Dai
-
-//#include "pch.h"
-#include "eprecomp.h"
-#include "asn.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-template <class T> void DL_FixedBasePrecomputationImpl<T>::SetBase(const DL_GroupPrecomputation<Element> &group, const Element &i_base)
-{
-	m_base = group.NeedConversions() ? group.ConvertIn(i_base) : i_base;
-
-	if (m_bases.empty() || !(m_base == m_bases[0]))
-	{
-		m_bases.resize(1);
-		m_bases[0] = m_base;
-	}
-
-	if (group.NeedConversions())
-		m_base = i_base;
-}
-
-template <class T> void DL_FixedBasePrecomputationImpl<T>::Precompute(const DL_GroupPrecomputation<Element> &group, unsigned int maxExpBits, unsigned int storage)
-{
-	assert(m_bases.size() > 0);
-	assert(storage <= maxExpBits);
-
-	if (storage > 1)
-	{
-		m_windowSize = (maxExpBits+storage-1)/storage;
-		m_exponentBase = Integer::Power2(m_windowSize);
-	}
-
-	m_bases.resize(storage);
-	for (unsigned i=1; i<storage; i++)
-		m_bases[i] = group.GetGroup().ScalarMultiply(m_bases[i-1], m_exponentBase);
-}
-
-template <class T> void DL_FixedBasePrecomputationImpl<T>::Load(const DL_GroupPrecomputation<Element> &group, BufferedTransformation &bt)
-{
-	BERSequenceDecoder seq(bt);
-	word32 version;
-	BERDecodeUnsigned<word32>(seq, version, INTEGER, 1, 1);
-	m_exponentBase.BERDecode(seq);
-	m_windowSize = m_exponentBase.BitCount() - 1;
-	m_bases.clear();
-	while (!seq.EndReached())
-		m_bases.push_back(group.BERDecodeElement(seq));
-	if (!m_bases.empty() && group.NeedConversions())
-		m_base = group.ConvertOut(m_bases[0]);
-	seq.MessageEnd();
-}
-
-template <class T> void DL_FixedBasePrecomputationImpl<T>::Save(const DL_GroupPrecomputation<Element> &group, BufferedTransformation &bt) const
-{
-	DERSequenceEncoder seq(bt);
-	DEREncodeUnsigned<word32>(seq, 1);	// version
-	m_exponentBase.DEREncode(seq);
-	for (unsigned i=0; i<m_bases.size(); i++)
-		group.DEREncodeElement(seq, m_bases[i]);
-	seq.MessageEnd();
-}
-
-template <class T> void DL_FixedBasePrecomputationImpl<T>::PrepareCascade(const DL_GroupPrecomputation<Element> &i_group, std::vector<BaseAndExponent<Element> > &eb, const Integer &exponent) const
-{
-	const AbstractGroup<T> &group = i_group.GetGroup();
-
-	Integer r, q, e = exponent;
-	bool fastNegate = group.InversionIsFast() && m_windowSize > 1;
-	unsigned int i;
-
-	for (i=0; i+1<m_bases.size(); i++)
-	{
-		Integer::DivideByPowerOf2(r, q, e, m_windowSize);
-		std::swap(q, e);
-		if (fastNegate && r.GetBit(m_windowSize-1))
-		{
-			++e;
-			eb.push_back(BaseAndExponent<Element>(group.Inverse(m_bases[i]), m_exponentBase - r));
-		}
-		else
-			eb.push_back(BaseAndExponent<Element>(m_bases[i], r));
-	}
-	eb.push_back(BaseAndExponent<Element>(m_bases[i], e));
-}
-
-template <class T> T DL_FixedBasePrecomputationImpl<T>::Exponentiate(const DL_GroupPrecomputation<Element> &group, const Integer &exponent) const
-{
-	std::vector<BaseAndExponent<Element> > eb;	// array of segments of the exponent and precalculated bases
-	eb.reserve(m_bases.size());
-	PrepareCascade(group, eb, exponent);
-	return group.ConvertOut(GeneralCascadeMultiplication<Element>(group.GetGroup(), eb.begin(), eb.end()));
-}
-
-template <class T> T 
-	DL_FixedBasePrecomputationImpl<T>::CascadeExponentiate(const DL_GroupPrecomputation<Element> &group, const Integer &exponent, 
-		const DL_FixedBasePrecomputation<T> &i_pc2, const Integer &exponent2) const
-{
-	std::vector<BaseAndExponent<Element> > eb;	// array of segments of the exponent and precalculated bases
-	const DL_FixedBasePrecomputationImpl<T> &pc2 = static_cast<const DL_FixedBasePrecomputationImpl<T> &>(i_pc2);
-	eb.reserve(m_bases.size() + pc2.m_bases.size());
-	PrepareCascade(group, eb, exponent);
-	pc2.PrepareCascade(group, eb, exponent2);
-	return group.ConvertOut(GeneralCascadeMultiplication<Element>(group.GetGroup(), eb.begin(), eb.end()));
-}
-
-NAMESPACE_END
+// eprecomp.cpp - written and placed in the public domain by Wei Dai
+
+#include "pch.h"
+
+#ifndef CRYPTOPP_IMPORTS
+
+#include "eprecomp.h"
+#include "asn.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+template <class T> void DL_FixedBasePrecomputationImpl<T>::SetBase(const DL_GroupPrecomputation<Element> &group, const Element &i_base)
+{
+	m_base = group.NeedConversions() ? group.ConvertIn(i_base) : i_base;
+
+	if (m_bases.empty() || !(m_base == m_bases[0]))
+	{
+		m_bases.resize(1);
+		m_bases[0] = m_base;
+	}
+
+	if (group.NeedConversions())
+		m_base = i_base;
+}
+
+template <class T> void DL_FixedBasePrecomputationImpl<T>::Precompute(const DL_GroupPrecomputation<Element> &group, unsigned int maxExpBits, unsigned int storage)
+{
+	assert(m_bases.size() > 0);
+	assert(storage <= maxExpBits);
+
+	if (storage > 1)
+	{
+		m_windowSize = (maxExpBits+storage-1)/storage;
+		m_exponentBase = Integer::Power2(m_windowSize);
+	}
+
+	m_bases.resize(storage);
+	for (unsigned i=1; i<storage; i++)
+		m_bases[i] = group.GetGroup().ScalarMultiply(m_bases[i-1], m_exponentBase);
+}
+
+template <class T> void DL_FixedBasePrecomputationImpl<T>::Load(const DL_GroupPrecomputation<Element> &group, BufferedTransformation &bt)
+{
+	BERSequenceDecoder seq(bt);
+	word32 version;
+	BERDecodeUnsigned<word32>(seq, version, INTEGER, 1, 1);
+	m_exponentBase.BERDecode(seq);
+	m_windowSize = m_exponentBase.BitCount() - 1;
+	m_bases.clear();
+	while (!seq.EndReached())
+		m_bases.push_back(group.BERDecodeElement(seq));
+	if (!m_bases.empty() && group.NeedConversions())
+		m_base = group.ConvertOut(m_bases[0]);
+	seq.MessageEnd();
+}
+
+template <class T> void DL_FixedBasePrecomputationImpl<T>::Save(const DL_GroupPrecomputation<Element> &group, BufferedTransformation &bt) const
+{
+	DERSequenceEncoder seq(bt);
+	DEREncodeUnsigned<word32>(seq, 1);	// version
+	m_exponentBase.DEREncode(seq);
+	for (unsigned i=0; i<m_bases.size(); i++)
+		group.DEREncodeElement(seq, m_bases[i]);
+	seq.MessageEnd();
+}
+
+template <class T> void DL_FixedBasePrecomputationImpl<T>::PrepareCascade(const DL_GroupPrecomputation<Element> &i_group, std::vector<BaseAndExponent<Element> > &eb, const Integer &exponent) const
+{
+	const AbstractGroup<T> &group = i_group.GetGroup();
+
+	Integer r, q, e = exponent;
+	bool fastNegate = group.InversionIsFast() && m_windowSize > 1;
+	unsigned int i;
+
+	for (i=0; i+1<m_bases.size(); i++)
+	{
+		Integer::DivideByPowerOf2(r, q, e, m_windowSize);
+		std::swap(q, e);
+		if (fastNegate && r.GetBit(m_windowSize-1))
+		{
+			++e;
+			eb.push_back(BaseAndExponent<Element>(group.Inverse(m_bases[i]), m_exponentBase - r));
+		}
+		else
+			eb.push_back(BaseAndExponent<Element>(m_bases[i], r));
+	}
+	eb.push_back(BaseAndExponent<Element>(m_bases[i], e));
+}
+
+template <class T> T DL_FixedBasePrecomputationImpl<T>::Exponentiate(const DL_GroupPrecomputation<Element> &group, const Integer &exponent) const
+{
+	std::vector<BaseAndExponent<Element> > eb;	// array of segments of the exponent and precalculated bases
+	eb.reserve(m_bases.size());
+	PrepareCascade(group, eb, exponent);
+	return group.ConvertOut(GeneralCascadeMultiplication<Element>(group.GetGroup(), eb.begin(), eb.end()));
+}
+
+template <class T> T 
+	DL_FixedBasePrecomputationImpl<T>::CascadeExponentiate(const DL_GroupPrecomputation<Element> &group, const Integer &exponent, 
+		const DL_FixedBasePrecomputation<T> &i_pc2, const Integer &exponent2) const
+{
+	std::vector<BaseAndExponent<Element> > eb;	// array of segments of the exponent and precalculated bases
+	const DL_FixedBasePrecomputationImpl<T> &pc2 = static_cast<const DL_FixedBasePrecomputationImpl<T> &>(i_pc2);
+	eb.reserve(m_bases.size() + pc2.m_bases.size());
+	PrepareCascade(group, eb, exponent);
+	pc2.PrepareCascade(group, eb, exponent2);
+	return group.ConvertOut(GeneralCascadeMultiplication<Element>(group.GetGroup(), eb.begin(), eb.end()));
+}
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/files.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/files.cpp
index ab90e183..453b5624 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/src/files.cpp
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/files.cpp
@@ -1,186 +1,259 @@
-// files.cpp - written and placed in the public domain by Wei Dai
-
-//#include "pch.h"
-#include "files.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-using namespace std;
-
-void Files_TestInstantiations()
-{
-	FileStore f0;
-	FileSource f1;
-	FileSink f2;
-}
-
-void FileStore::StoreInitialize(const NameValuePairs &parameters)
-{
-	const char *fileName;
-	if (parameters.GetValue("InputFileName", fileName))
-	{
-		ios::openmode binary = parameters.GetValueWithDefault("InputBinaryMode", true) ? ios::binary : ios::openmode(0);
-		m_file.open(fileName, ios::in | binary);
-		if (!m_file)
-			throw OpenErr(fileName);
-		m_stream = &m_file;
-	}
-	else
-	{
-		m_stream = NULL;
-		parameters.GetValue("InputStreamPointer", m_stream);
-	}
-	m_waiting = false;
-}
-
-unsigned long FileStore::MaxRetrievable() const
-{
-	if (!m_stream)
-		return 0;
-
-	streampos current = m_stream->tellg();
-	streampos end = m_stream->seekg(0, ios::end).tellg();
-	m_stream->seekg(current);
-	return end-current;
-}
-
-unsigned int FileStore::TransferTo2(BufferedTransformation &target, unsigned long &transferBytes, const std::string &channel, bool blocking)
-{
-	if (!m_stream)
-	{
-		transferBytes = 0;
-		return 0;
-	}
-
-	unsigned long size=transferBytes;
-	transferBytes = 0;
-
-	if (m_waiting)
-		goto output;
-
-	while (size && m_stream->good())
-	{
-		{
-		unsigned int spaceSize = 1024;
-		m_space = HelpCreatePutSpace(target, channel, 1, (unsigned int)STDMIN(size, (unsigned long)UINT_MAX), spaceSize);
-
-		m_stream->read((char *)m_space, STDMIN(size, (unsigned long)spaceSize));
-		}
-		m_len = m_stream->gcount();
-		unsigned int blockedBytes;
-output:
-		blockedBytes = target.ChannelPutModifiable2(channel, m_space, m_len, 0, blocking);
-		m_waiting = blockedBytes > 0;
-		if (m_waiting)
-			return blockedBytes;
-		size -= m_len;
-		transferBytes += m_len;
-	}
-
-	if (!m_stream->good() && !m_stream->eof())
-		throw ReadErr();
-
-	return 0;
-}
-
-unsigned int FileStore::CopyRangeTo2(BufferedTransformation &target, unsigned long &begin, unsigned long end, const std::string &channel, bool blocking) const
-{
-	if (!m_stream)
-		return 0;
-
-	if (begin == 0 && end == 1)
-	{
-		int result = m_stream->peek();
-		if (result == EOF)	// GCC workaround: 2.95.2 doesn't have char_traits<char>::eof()
-			return 0;
-		else
-		{
-			unsigned int blockedBytes = target.ChannelPut(channel, byte(result), blocking);
-			begin += 1-blockedBytes;
-			return blockedBytes;
-		}
-	}
-
-	// TODO: figure out what happens on cin
-	streampos current = m_stream->tellg();
-	streampos endPosition = m_stream->seekg(0, ios::end).tellg();
-	streampos newPosition = current + (streamoff)begin;
-
-	if (newPosition >= endPosition)
-	{
-		m_stream->seekg(current);
-		return 0;	// don't try to seek beyond the end of file
-	}
-	m_stream->seekg(newPosition);
-	unsigned long total = 0;
-	try
-	{
-		assert(!m_waiting);
-		unsigned long copyMax = end-begin;
-		unsigned int blockedBytes = const_cast<FileStore *>(this)->TransferTo2(target, copyMax, channel, blocking);
-		begin += copyMax;
-		if (blockedBytes)
-		{
-			const_cast<FileStore *>(this)->m_waiting = false;
-			return blockedBytes;
-		}
-	}
-	catch(...)
-	{
-		m_stream->clear();
-		m_stream->seekg(current);
-		throw;
-	}
-	m_stream->clear();
-	m_stream->seekg(current);
-
-	return 0;
-}
-
-void FileSink::IsolatedInitialize(const NameValuePairs &parameters)
-{
-	const char *fileName;
-	if (parameters.GetValue("OutputFileName", fileName))
-	{
-		ios::openmode binary = parameters.GetValueWithDefault("OutputBinaryMode", true) ? ios::binary : ios::openmode(0);
-		m_file.open(fileName, ios::out | ios::trunc | binary);
-		if (!m_file)
-			throw OpenErr(fileName);
-		m_stream = &m_file;
-	}
-	else
-	{
-		m_stream = NULL;
-		parameters.GetValue("OutputStreamPointer", m_stream);
-	}
-}
-
-bool FileSink::IsolatedFlush(bool hardFlush, bool blocking)
-{
-	if (!m_stream)
-		throw Err("FileSink: output stream not opened");
-
-	m_stream->flush();
-	if (!m_stream->good())
-		throw WriteErr();
-
-	return false;
-}
-
-unsigned int FileSink::Put2(const byte *inString, unsigned int length, int messageEnd, bool blocking)
-{
-	if (!m_stream)
-		throw Err("FileSink: output stream not opened");
-
-	m_stream->write((const char *)inString, length);
-
-	if (messageEnd)
-		m_stream->flush();
-
-	if (!m_stream->good())
-		throw WriteErr();
-
-	return 0;
-}
-
-NAMESPACE_END
+// files.cpp - written and placed in the public domain by Wei Dai
+
+#include "pch.h"
+
+#ifndef CRYPTOPP_IMPORTS
+
+#include "files.h"
+
+#include <limits>
+
+NAMESPACE_BEGIN(CryptoPP)
+
+using namespace std;
+
+#ifndef NDEBUG
+void Files_TestInstantiations()
+{
+	FileStore f0;
+	FileSource f1;
+	FileSink f2;
+}
+#endif
+
+void FileStore::StoreInitialize(const NameValuePairs &parameters)
+{
+	m_waiting = false;
+	m_stream = NULL;
+	m_file.release();
+
+	const char *fileName = NULL;
+#if defined(CRYPTOPP_UNIX_AVAILABLE) || _MSC_VER >= 1400
+	const wchar_t *fileNameWide = NULL;
+	if (!parameters.GetValue(Name::InputFileNameWide(), fileNameWide))
+#endif
+		if (!parameters.GetValue(Name::InputFileName(), fileName))
+		{
+			parameters.GetValue(Name::InputStreamPointer(), m_stream);
+			return;
+		}
+
+	ios::openmode binary = parameters.GetValueWithDefault(Name::InputBinaryMode(), true) ? ios::binary : ios::openmode(0);
+	m_file.reset(new std::ifstream);
+#ifdef CRYPTOPP_UNIX_AVAILABLE
+	std::string narrowed;
+	if (fileNameWide)
+		fileName = (narrowed = StringNarrow(fileNameWide)).c_str();
+#endif
+#if _MSC_VER >= 1400
+	if (fileNameWide)
+	{
+		m_file->open(fileNameWide, ios::in | binary);
+		if (!*m_file)
+			throw OpenErr(StringNarrow(fileNameWide, false));
+	}
+#endif
+	if (fileName)
+	{
+		m_file->open(fileName, ios::in | binary);
+		if (!*m_file)
+			throw OpenErr(fileName);
+	}
+	m_stream = m_file.get();
+}
+
+lword FileStore::MaxRetrievable() const
+{
+	if (!m_stream)
+		return 0;
+
+	streampos current = m_stream->tellg();
+	streampos end = m_stream->seekg(0, ios::end).tellg();
+	m_stream->seekg(current);
+	return end-current;
+}
+
+size_t FileStore::TransferTo2(BufferedTransformation &target, lword &transferBytes, const std::string &channel, bool blocking)
+{
+	if (!m_stream)
+	{
+		transferBytes = 0;
+		return 0;
+	}
+
+	lword size=transferBytes;
+	transferBytes = 0;
+
+	if (m_waiting)
+		goto output;
+
+	while (size && m_stream->good())
+	{
+		{
+		size_t spaceSize = 1024;
+		m_space = HelpCreatePutSpace(target, channel, 1, UnsignedMin(size_t(0)-1, size), spaceSize);
+
+		m_stream->read((char *)m_space, (unsigned int)STDMIN(size, (lword)spaceSize));
+		}
+		m_len = (size_t)m_stream->gcount();
+		size_t blockedBytes;
+output:
+		blockedBytes = target.ChannelPutModifiable2(channel, m_space, m_len, 0, blocking);
+		m_waiting = blockedBytes > 0;
+		if (m_waiting)
+			return blockedBytes;
+		size -= m_len;
+		transferBytes += m_len;
+	}
+
+	if (!m_stream->good() && !m_stream->eof())
+		throw ReadErr();
+
+	return 0;
+}
+
+size_t FileStore::CopyRangeTo2(BufferedTransformation &target, lword &begin, lword end, const std::string &channel, bool blocking) const
+{
+	if (!m_stream)
+		return 0;
+
+	if (begin == 0 && end == 1)
+	{
+		int result = m_stream->peek();
+		if (result == char_traits<char>::eof())
+			return 0;
+		else
+		{
+			size_t blockedBytes = target.ChannelPut(channel, byte(result), blocking);
+			begin += 1-blockedBytes;
+			return blockedBytes;
+		}
+	}
+
+	// TODO: figure out what happens on cin
+	streampos current = m_stream->tellg();
+	streampos endPosition = m_stream->seekg(0, ios::end).tellg();
+	streampos newPosition = current + (streamoff)begin;
+
+	if (newPosition >= endPosition)
+	{
+		m_stream->seekg(current);
+		return 0;	// don't try to seek beyond the end of file
+	}
+	m_stream->seekg(newPosition);
+	try
+	{
+		assert(!m_waiting);
+		lword copyMax = end-begin;
+		size_t blockedBytes = const_cast<FileStore *>(this)->TransferTo2(target, copyMax, channel, blocking);
+		begin += copyMax;
+		if (blockedBytes)
+		{
+			const_cast<FileStore *>(this)->m_waiting = false;
+			return blockedBytes;
+		}
+	}
+	catch(...)
+	{
+		m_stream->clear();
+		m_stream->seekg(current);
+		throw;
+	}
+	m_stream->clear();
+	m_stream->seekg(current);
+
+	return 0;
+}
+
+lword FileStore::Skip(lword skipMax)
+{
+	if (!m_stream)
+		return 0;
+
+	lword oldPos = m_stream->tellg();
+	std::istream::off_type offset;
+	if (!SafeConvert(skipMax, offset))
+		throw InvalidArgument("FileStore: maximum seek offset exceeded");
+	m_stream->seekg(offset, ios::cur);
+	return (lword)m_stream->tellg() - oldPos;
+}
+
+void FileSink::IsolatedInitialize(const NameValuePairs &parameters)
+{
+	m_stream = NULL;
+	m_file.release();
+
+	const char *fileName = NULL;
+#if defined(CRYPTOPP_UNIX_AVAILABLE) || _MSC_VER >= 1400
+	const wchar_t *fileNameWide = NULL;
+	if (!parameters.GetValue(Name::OutputFileNameWide(), fileNameWide))
+#endif
+		if (!parameters.GetValue(Name::OutputFileName(), fileName))
+		{
+			parameters.GetValue(Name::OutputStreamPointer(), m_stream);
+			return;
+		}
+
+	ios::openmode binary = parameters.GetValueWithDefault(Name::OutputBinaryMode(), true) ? ios::binary : ios::openmode(0);
+	m_file.reset(new std::ofstream);
+#ifdef CRYPTOPP_UNIX_AVAILABLE
+	std::string narrowed;
+	if (fileNameWide)
+		fileName = (narrowed = StringNarrow(fileNameWide)).c_str();
+#endif
+#if _MSC_VER >= 1400
+	if (fileNameWide)
+	{
+		m_file->open(fileNameWide, ios::out | ios::trunc | binary);
+		if (!*m_file)
+			throw OpenErr(StringNarrow(fileNameWide, false));
+	}
+#endif
+	if (fileName)
+	{
+		m_file->open(fileName, ios::out | ios::trunc | binary);
+		if (!*m_file)
+			throw OpenErr(fileName);
+	}
+	m_stream = m_file.get();
+}
+
+bool FileSink::IsolatedFlush(bool hardFlush, bool blocking)
+{
+	if (!m_stream)
+		throw Err("FileSink: output stream not opened");
+
+	m_stream->flush();
+	if (!m_stream->good())
+		throw WriteErr();
+
+	return false;
+}
+
+size_t FileSink::Put2(const byte *inString, size_t length, int messageEnd, bool blocking)
+{
+	if (!m_stream)
+		throw Err("FileSink: output stream not opened");
+
+	while (length > 0)
+	{
+		std::streamsize size;
+		if (!SafeConvert(length, size))
+			size = numeric_limits<std::streamsize>::max();
+		m_stream->write((const char *)inString, size);
+		inString += size;
+		length -= (size_t)size;
+	}
+
+	if (messageEnd)
+		m_stream->flush();
+
+	if (!m_stream->good())
+		throw WriteErr();
+
+	return 0;
+}
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/filters.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/filters.cpp
index a3b31041..083dfd36 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/src/filters.cpp
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/filters.cpp
@@ -1,897 +1,1120 @@
-// filters.cpp - written and placed in the public domain by Wei Dai
-
-//#include "pch.h"
-#include "filters.h"
-#include "mqueue.h"
-#include "fltrimpl.h"
-#include "argnames.h"
-#include <memory>
-#include <functional>
-
-NAMESPACE_BEGIN(CryptoPP)
-
-Filter::Filter(BufferedTransformation *attachment)
-	: m_attachment(attachment), m_continueAt(0)
-{
-}
-
-BufferedTransformation * Filter::NewDefaultAttachment() const
-{
-	return new MessageQueue;
-}
-
-BufferedTransformation * Filter::AttachedTransformation()
-{
-	if (m_attachment.get() == NULL)
-		m_attachment.reset(NewDefaultAttachment());
-	return m_attachment.get();
-}
-
-const BufferedTransformation *Filter::AttachedTransformation() const
-{
-	if (m_attachment.get() == NULL)
-		const_cast<Filter *>(this)->m_attachment.reset(NewDefaultAttachment());
-	return m_attachment.get();
-}
-
-void Filter::Detach(BufferedTransformation *newOut)
-{
-	m_attachment.reset(newOut);
-	NotifyAttachmentChange();
-}
-
-void Filter::Insert(Filter *filter)
-{
-	filter->m_attachment.reset(m_attachment.release());
-	m_attachment.reset(filter);
-	NotifyAttachmentChange();
-}
-
-unsigned int Filter::CopyRangeTo2(BufferedTransformation &target, unsigned long &begin, unsigned long end, const std::string &channel, bool blocking) const
-{
-	return AttachedTransformation()->CopyRangeTo2(target, begin, end, channel, blocking);
-}
-
-unsigned int Filter::TransferTo2(BufferedTransformation &target, unsigned long &transferBytes, const std::string &channel, bool blocking)
-{
-	return AttachedTransformation()->TransferTo2(target, transferBytes, channel, blocking);
-}
-
-void Filter::Initialize(const NameValuePairs &parameters, int propagation)
-{
-	m_continueAt = 0;
-	IsolatedInitialize(parameters);
-	PropagateInitialize(parameters, propagation);
-}
-
-bool Filter::Flush(bool hardFlush, int propagation, bool blocking)
-{
-	switch (m_continueAt)
-	{
-	case 0:
-		if (IsolatedFlush(hardFlush, blocking))
-			return true;
-	case 1:
-		if (OutputFlush(1, hardFlush, propagation, blocking))
-			return true;
-	}
-	return false;
-}
-
-bool Filter::MessageSeriesEnd(int propagation, bool blocking)
-{
-	switch (m_continueAt)
-	{
-	case 0:
-		if (IsolatedMessageSeriesEnd(blocking))
-			return true;
-	case 1:
-		if (ShouldPropagateMessageSeriesEnd() && OutputMessageSeriesEnd(1, propagation, blocking))
-			return true;
-	}
-	return false;
-}
-
-void Filter::PropagateInitialize(const NameValuePairs &parameters, int propagation, const std::string &channel)
-{
-	if (propagation)
-		AttachedTransformation()->ChannelInitialize(channel, parameters, propagation-1);
-}
-
-unsigned int Filter::Output(int outputSite, const byte *inString, unsigned int length, int messageEnd, bool blocking, const std::string &channel)
-{
-	if (messageEnd)
-		messageEnd--;
-	unsigned int result = AttachedTransformation()->Put2(inString, length, messageEnd, blocking);
-	m_continueAt = result ? outputSite : 0;
-	return result;
-}
-
-bool Filter::OutputFlush(int outputSite, bool hardFlush, int propagation, bool blocking, const std::string &channel)
-{
-	if (propagation && AttachedTransformation()->ChannelFlush(channel, hardFlush, propagation-1, blocking))
-	{
-		m_continueAt = outputSite;
-		return true;
-	}
-	m_continueAt = 0;
-	return false;
-}
-
-bool Filter::OutputMessageSeriesEnd(int outputSite, int propagation, bool blocking, const std::string &channel)
-{
-	if (propagation && AttachedTransformation()->ChannelMessageSeriesEnd(channel, propagation-1, blocking))
-	{
-		m_continueAt = outputSite;
-		return true;
-	}
-	m_continueAt = 0;
-	return false;
-}
-
-// *************************************************************
-
-unsigned int MeterFilter::Put2(const byte *begin, unsigned int length, int messageEnd, bool blocking)
-{
-	if (m_transparent)
-	{
-		FILTER_BEGIN;
-		m_currentMessageBytes += length;
-		m_totalBytes += length;
-
-		if (messageEnd)
-		{
-			m_currentMessageBytes = 0;
-			m_currentSeriesMessages++;
-			m_totalMessages++;
-		}
-		
-		FILTER_OUTPUT(1, begin, length, messageEnd);
-		FILTER_END_NO_MESSAGE_END;
-	}
-	return 0;
-}
-
-bool MeterFilter::IsolatedMessageSeriesEnd(bool blocking)
-{
-	m_currentMessageBytes = 0;
-	m_currentSeriesMessages = 0;
-	m_totalMessageSeries++;
-	return false;
-}
-
-// *************************************************************
-
-void FilterWithBufferedInput::BlockQueue::ResetQueue(unsigned int blockSize, unsigned int maxBlocks)
-{
-	m_buffer.New(blockSize * maxBlocks);
-	m_blockSize = blockSize;
-	m_maxBlocks = maxBlocks;
-	m_size = 0;
-	m_begin = m_buffer;
-}
-
-byte *FilterWithBufferedInput::BlockQueue::GetBlock()
-{
-	if (m_size >= m_blockSize)
-	{
-		byte *ptr = m_begin;
-		if ((m_begin+=m_blockSize) == m_buffer.end())
-			m_begin = m_buffer;
-		m_size -= m_blockSize;
-		return ptr;
-	}
-	else
-		return NULL;
-}
-
-byte *FilterWithBufferedInput::BlockQueue::GetContigousBlocks(unsigned int &numberOfBytes)
-{
-	numberOfBytes = STDMIN(numberOfBytes, STDMIN((unsigned int)(m_buffer.end()-m_begin), m_size));
-	byte *ptr = m_begin;
-	m_begin += numberOfBytes;
-	m_size -= numberOfBytes;
-	if (m_size == 0 || m_begin == m_buffer.end())
-		m_begin = m_buffer;
-	return ptr;
-}
-
-unsigned int FilterWithBufferedInput::BlockQueue::GetAll(byte *outString)
-{
-	unsigned int size = m_size;
-	unsigned int numberOfBytes = m_maxBlocks*m_blockSize;
-	const byte *ptr = GetContigousBlocks(numberOfBytes);
-	memcpy(outString, ptr, numberOfBytes);
-	memcpy(outString+numberOfBytes, m_begin, m_size);
-	m_size = 0;
-	return size;
-}
-
-void FilterWithBufferedInput::BlockQueue::Put(const byte *inString, unsigned int length)
-{
-	assert(m_size + length <= m_buffer.size());
-	byte *end = (m_size < (unsigned int)(m_buffer.end()-m_begin)) ? m_begin + m_size : m_begin + m_size - m_buffer.size();
-	unsigned int len = STDMIN(length, (unsigned int)(m_buffer.end()-end));
-	memcpy(end, inString, len);
-	if (len < length)
-		memcpy(m_buffer, inString+len, length-len);
-	m_size += length;
-}
-
-FilterWithBufferedInput::FilterWithBufferedInput(BufferedTransformation *attachment)
-	: Filter(attachment)
-{
-}
-
-FilterWithBufferedInput::FilterWithBufferedInput(unsigned int firstSize, unsigned int blockSize, unsigned int lastSize, BufferedTransformation *attachment)
-	: Filter(attachment), m_firstSize(firstSize), m_blockSize(blockSize), m_lastSize(lastSize)
-	, m_firstInputDone(false)
-{
-	if (m_firstSize < 0 || m_blockSize < 1 || m_lastSize < 0)
-		throw InvalidArgument("FilterWithBufferedInput: invalid buffer size");
-
-	m_queue.ResetQueue(1, m_firstSize);
-}
-
-void FilterWithBufferedInput::IsolatedInitialize(const NameValuePairs &parameters)
-{
-	InitializeDerivedAndReturnNewSizes(parameters, m_firstSize, m_blockSize, m_lastSize);
-	if (m_firstSize < 0 || m_blockSize < 1 || m_lastSize < 0)
-		throw InvalidArgument("FilterWithBufferedInput: invalid buffer size");
-	m_queue.ResetQueue(1, m_firstSize);
-	m_firstInputDone = false;
-}
-
-bool FilterWithBufferedInput::IsolatedFlush(bool hardFlush, bool blocking)
-{
-	if (!blocking)
-		throw BlockingInputOnly("FilterWithBufferedInput");
-	
-	if (hardFlush)
-		ForceNextPut();
-	FlushDerived();
-	
-	return false;
-}
-
-unsigned int FilterWithBufferedInput::PutMaybeModifiable(byte *inString, unsigned int length, int messageEnd, bool blocking, bool modifiable)
-{
-	if (!blocking)
-		throw BlockingInputOnly("FilterWithBufferedInput");
-
-	if (length != 0)
-	{
-		unsigned int newLength = m_queue.CurrentSize() + length;
-
-		if (!m_firstInputDone && newLength >= m_firstSize)
-		{
-			unsigned int len = m_firstSize - m_queue.CurrentSize();
-			m_queue.Put(inString, len);
-			FirstPut(m_queue.GetContigousBlocks(m_firstSize));
-			assert(m_queue.CurrentSize() == 0);
-			m_queue.ResetQueue(m_blockSize, (2*m_blockSize+m_lastSize-2)/m_blockSize);
-
-			inString += len;
-			newLength -= m_firstSize;
-			m_firstInputDone = true;
-		}
-
-		if (m_firstInputDone)
-		{
-			if (m_blockSize == 1)
-			{
-				while (newLength > m_lastSize && m_queue.CurrentSize() > 0)
-				{
-					unsigned int len = newLength - m_lastSize;
-					byte *ptr = m_queue.GetContigousBlocks(len);
-					NextPutModifiable(ptr, len);
-					newLength -= len;
-				}
-
-				if (newLength > m_lastSize)
-				{
-					unsigned int len = newLength - m_lastSize;
-					NextPutMaybeModifiable(inString, len, modifiable);
-					inString += len;
-					newLength -= len;
-				}
-			}
-			else
-			{
-				while (newLength >= m_blockSize + m_lastSize && m_queue.CurrentSize() >= m_blockSize)
-				{
-					NextPutModifiable(m_queue.GetBlock(), m_blockSize);
-					newLength -= m_blockSize;
-				}
-
-				if (newLength >= m_blockSize + m_lastSize && m_queue.CurrentSize() > 0)
-				{
-					assert(m_queue.CurrentSize() < m_blockSize);
-					unsigned int len = m_blockSize - m_queue.CurrentSize();
-					m_queue.Put(inString, len);
-					inString += len;
-					NextPutModifiable(m_queue.GetBlock(), m_blockSize);
-					newLength -= m_blockSize;
-				}
-
-				if (newLength >= m_blockSize + m_lastSize)
-				{
-					unsigned int len = RoundDownToMultipleOf(newLength - m_lastSize, m_blockSize);
-					NextPutMaybeModifiable(inString, len, modifiable);
-					inString += len;
-					newLength -= len;
-				}
-			}
-		}
-
-		m_queue.Put(inString, newLength - m_queue.CurrentSize());
-	}
-
-	if (messageEnd)
-	{
-		if (!m_firstInputDone && m_firstSize==0)
-			FirstPut(NULL);
-
-		SecByteBlock temp(m_queue.CurrentSize());
-		m_queue.GetAll(temp);
-		LastPut(temp, temp.size());
-
-		m_firstInputDone = false;
-		m_queue.ResetQueue(1, m_firstSize);
-
-		Output(1, NULL, 0, messageEnd, blocking);
-	}
-	return 0;
-}
-
-void FilterWithBufferedInput::ForceNextPut()
-{
-	if (!m_firstInputDone)
-		return;
-	
-	if (m_blockSize > 1)
-	{
-		while (m_queue.CurrentSize() >= m_blockSize)
-			NextPutModifiable(m_queue.GetBlock(), m_blockSize);
-	}
-	else
-	{
-		unsigned int len;
-		while ((len = m_queue.CurrentSize()) > 0)
-			NextPutModifiable(m_queue.GetContigousBlocks(len), len);
-	}
-}
-
-void FilterWithBufferedInput::NextPutMultiple(const byte *inString, unsigned int length)
-{
-	assert(m_blockSize > 1);	// m_blockSize = 1 should always override this function
-	while (length > 0)
-	{
-		assert(length >= m_blockSize);
-		NextPutSingle(inString);
-		inString += m_blockSize;
-		length -= m_blockSize;
-	}
-}
-
-// *************************************************************
-
-void Redirector::ChannelInitialize(const std::string &channel, const NameValuePairs &parameters, int propagation)
-{
-	if (channel.empty())
-	{
-		m_target = parameters.GetValueWithDefault("RedirectionTargetPointer", (BufferedTransformation*)NULL);
-		m_passSignal = parameters.GetValueWithDefault("PassSignal", true);
-	}
-
-	if (m_target && m_passSignal)
-		m_target->ChannelInitialize(channel, parameters, propagation);
-}
-
-// *************************************************************
-
-ProxyFilter::ProxyFilter(BufferedTransformation *filter, unsigned int firstSize, unsigned int lastSize, BufferedTransformation *attachment)
-	: FilterWithBufferedInput(firstSize, 1, lastSize, attachment), m_filter(filter)
-{
-	if (m_filter.get())
-		m_filter->Attach(new OutputProxy(*this, false));
-}
-
-bool ProxyFilter::IsolatedFlush(bool hardFlush, bool blocking)
-{
-	return m_filter.get() ? m_filter->Flush(hardFlush, -1, blocking) : false;
-}
-
-void ProxyFilter::SetFilter(Filter *filter)
-{
-	m_filter.reset(filter);
-	if (filter)
-	{
-		OutputProxy *proxy;
-		std::auto_ptr<OutputProxy> temp(proxy = new OutputProxy(*this, false));
-		m_filter->TransferAllTo(*proxy);
-		m_filter->Attach(temp.release());
-	}
-}
-
-void ProxyFilter::NextPutMultiple(const byte *s, unsigned int len) 
-{
-	if (m_filter.get())
-		m_filter->Put(s, len);
-}
-
-// *************************************************************
-
-unsigned int ArraySink::Put2(const byte *begin, unsigned int length, int messageEnd, bool blocking)
-{
-	memcpy(m_buf+m_total, begin, STDMIN(length, SaturatingSubtract(m_size, m_total)));
-	m_total += length;
-	return 0;
-}
-
-byte * ArraySink::CreatePutSpace(unsigned int &size)
-{
-	size = m_size - m_total;
-	return m_buf + m_total;
-}
-
-void ArraySink::IsolatedInitialize(const NameValuePairs &parameters)
-{
-	ByteArrayParameter array;
-	if (!parameters.GetValue(Name::OutputBuffer(), array))
-		throw InvalidArgument("ArraySink: missing OutputBuffer argument");
-	m_buf = array.begin();
-	m_size = array.size();
-	m_total = 0;
-}
-
-unsigned int ArrayXorSink::Put2(const byte *begin, unsigned int length, int messageEnd, bool blocking)
-{
-	xorbuf(m_buf+m_total, begin, STDMIN(length, SaturatingSubtract(m_size, m_total)));
-	m_total += length;
-	return 0;
-}
-
-// *************************************************************
-
-unsigned int StreamTransformationFilter::LastBlockSize(StreamTransformation &c, BlockPaddingScheme padding)
-{
-	if (c.MinLastBlockSize() > 0)
-		return c.MinLastBlockSize();
-	else if (c.MandatoryBlockSize() > 1 && !c.IsForwardTransformation() && padding != NO_PADDING && padding != ZEROS_PADDING)
-		return c.MandatoryBlockSize();
-	else
-		return 0;
-}
-
-StreamTransformationFilter::StreamTransformationFilter(StreamTransformation &c, BufferedTransformation *attachment, BlockPaddingScheme padding)
-   : FilterWithBufferedInput(0, c.MandatoryBlockSize(), LastBlockSize(c, padding), attachment)
-	, m_cipher(c)
-{
-	assert(c.MinLastBlockSize() == 0 || c.MinLastBlockSize() > c.MandatoryBlockSize());
-
-	bool isBlockCipher = (c.MandatoryBlockSize() > 1 && c.MinLastBlockSize() == 0);
-
-	if (padding == DEFAULT_PADDING)
-	{
-		if (isBlockCipher)
-			m_padding = PKCS_PADDING;
-		else
-			m_padding = NO_PADDING;
-	}
-	else
-		m_padding = padding;
-
-	if (!isBlockCipher && (m_padding == PKCS_PADDING || m_padding == ONE_AND_ZEROS_PADDING))
-		throw InvalidArgument("StreamTransformationFilter: PKCS_PADDING and ONE_AND_ZEROS_PADDING cannot be used with " + c.AlgorithmName());
-}
-
-void StreamTransformationFilter::FirstPut(const byte *inString)
-{
-	m_optimalBufferSize = m_cipher.OptimalBlockSize();
-	m_optimalBufferSize = STDMAX(m_optimalBufferSize, RoundDownToMultipleOf(4096U, m_optimalBufferSize));
-}
-
-void StreamTransformationFilter::NextPutMultiple(const byte *inString, unsigned int length)
-{
-	if (!length)
-		return;
-
-	unsigned int s = m_cipher.MandatoryBlockSize();
-
-	do
-	{
-		unsigned int len = m_optimalBufferSize;
-		byte *space = HelpCreatePutSpace(*AttachedTransformation(), NULL_CHANNEL, s, length, len);
-		if (len < length)
-		{
-			if (len == m_optimalBufferSize)
-				len -= m_cipher.GetOptimalBlockSizeUsed();
-			len = RoundDownToMultipleOf(len, s);
-		}
-		else
-			len = length;
-		m_cipher.ProcessString(space, inString, len);
-		AttachedTransformation()->PutModifiable(space, len);
-		inString += len;
-		length -= len;
-	}
-	while (length > 0);
-}
-
-void StreamTransformationFilter::NextPutModifiable(byte *inString, unsigned int length)
-{
-	m_cipher.ProcessString(inString, length);
-	AttachedTransformation()->PutModifiable(inString, length);
-}
-
-void StreamTransformationFilter::LastPut(const byte *inString, unsigned int length)
-{
-	byte *space = NULL;
-	
-	switch (m_padding)
-	{
-	case NO_PADDING:
-	case ZEROS_PADDING:
-		if (length > 0)
-		{
-			unsigned int minLastBlockSize = m_cipher.MinLastBlockSize();
-			bool isForwardTransformation = m_cipher.IsForwardTransformation();
-
-			if (isForwardTransformation && m_padding == ZEROS_PADDING && (minLastBlockSize == 0 || length < minLastBlockSize))
-			{
-				// do padding
-				unsigned int blockSize = STDMAX(minLastBlockSize, m_cipher.MandatoryBlockSize());
-				space = HelpCreatePutSpace(*AttachedTransformation(), NULL_CHANNEL, blockSize);
-				memcpy(space, inString, length);
-				memset(space + length, 0, blockSize - length);
-				m_cipher.ProcessLastBlock(space, space, blockSize);
-				AttachedTransformation()->Put(space, blockSize);
-			}
-			else
-			{
-				if (minLastBlockSize == 0)
-				{
-					if (isForwardTransformation)
-						throw InvalidDataFormat("StreamTransformationFilter: plaintext length is not a multiple of block size and NO_PADDING is specified");
-					else
-						throw InvalidCiphertext("StreamTransformationFilter: ciphertext length is not a multiple of block size");
-				}
-
-				space = HelpCreatePutSpace(*AttachedTransformation(), NULL_CHANNEL, length, m_optimalBufferSize);
-				m_cipher.ProcessLastBlock(space, inString, length);
-				AttachedTransformation()->Put(space, length);
-			}
-		}
-		break;
-
-	case PKCS_PADDING:
-	case ONE_AND_ZEROS_PADDING:
-		unsigned int s;
-		s = m_cipher.MandatoryBlockSize();
-		assert(s > 1);
-		space = HelpCreatePutSpace(*AttachedTransformation(), NULL_CHANNEL, s, m_optimalBufferSize);
-		if (m_cipher.IsForwardTransformation())
-		{
-			assert(length < s);
-			memcpy(space, inString, length);
-			if (m_padding == PKCS_PADDING)
-			{
-				assert(s < 256);
-				byte pad = s-length;
-				memset(space+length, pad, s-length);
-			}
-			else
-			{
-				space[length] = 1;
-				memset(space+length+1, 0, s-length-1);
-			}
-			m_cipher.ProcessData(space, space, s);
-			AttachedTransformation()->Put(space, s);
-		}
-		else
-		{
-			if (length != s)
-				throw InvalidCiphertext("StreamTransformationFilter: ciphertext length is not a multiple of block size");
-			m_cipher.ProcessData(space, inString, s);
-			if (m_padding == PKCS_PADDING)
-			{
-				byte pad = space[s-1];
-				if (pad < 1 || pad > s || std::find_if(space+s-pad, space+s, std::bind2nd(std::not_equal_to<byte>(), pad)) != space+s)
-					throw InvalidCiphertext("StreamTransformationFilter: invalid PKCS #7 block padding found");
-				length = s-pad;
-			}
-			else
-			{
-				while (length > 1 && space[length-1] == '\0')
-					--length;
-				if (space[--length] != '\1')
-					throw InvalidCiphertext("StreamTransformationFilter: invalid ones-and-zeros padding found");
-			}
-			AttachedTransformation()->Put(space, length);
-		}
-		break;
-
-	default:
-		assert(false);
-	}
-}
-
-// *************************************************************
-
-void HashFilter::IsolatedInitialize(const NameValuePairs &parameters)
-{
-	m_putMessage = parameters.GetValueWithDefault(Name::PutMessage(), false);
-	m_hashModule.Restart();
-}
-
-unsigned int HashFilter::Put2(const byte *inString, unsigned int length, int messageEnd, bool blocking)
-{
-	FILTER_BEGIN;
-	m_hashModule.Update(inString, length);
-	if (m_putMessage)
-		FILTER_OUTPUT(1, inString, length, 0);
-	if (messageEnd)
-	{
-		{
-			unsigned int size, digestSize = m_hashModule.DigestSize();
-			m_space = HelpCreatePutSpace(*AttachedTransformation(), NULL_CHANNEL, digestSize, digestSize, size = digestSize);
-			m_hashModule.Final(m_space);
-		}
-		FILTER_OUTPUT(2, m_space, m_hashModule.DigestSize(), messageEnd);
-	}
-	FILTER_END_NO_MESSAGE_END;
-}
-
-// *************************************************************
-
-HashVerificationFilter::HashVerificationFilter(HashTransformation &hm, BufferedTransformation *attachment, word32 flags)
-	: FilterWithBufferedInput(attachment)
-	, m_hashModule(hm)
-{
-	IsolatedInitialize(MakeParameters(Name::HashVerificationFilterFlags(), flags));
-}
-
-void HashVerificationFilter::InitializeDerivedAndReturnNewSizes(const NameValuePairs &parameters, unsigned int &firstSize, unsigned int &blockSize, unsigned int &lastSize)
-{
-	m_flags = parameters.GetValueWithDefault(Name::HashVerificationFilterFlags(), (word32)DEFAULT_FLAGS);
-	m_hashModule.Restart();
-	unsigned int size = m_hashModule.DigestSize();
-	m_verified = false;
-	firstSize = m_flags & HASH_AT_BEGIN ? size : 0;
-	blockSize = 1;
-	lastSize = m_flags & HASH_AT_BEGIN ? 0 : size;
-}
-
-void HashVerificationFilter::FirstPut(const byte *inString)
-{
-	if (m_flags & HASH_AT_BEGIN)
-	{
-		m_expectedHash.New(m_hashModule.DigestSize());
-		memcpy(m_expectedHash, inString, m_expectedHash.size());
-		if (m_flags & PUT_HASH)
-			AttachedTransformation()->Put(inString, m_expectedHash.size());
-	}
-}
-
-void HashVerificationFilter::NextPutMultiple(const byte *inString, unsigned int length)
-{
-	m_hashModule.Update(inString, length);
-	if (m_flags & PUT_MESSAGE)
-		AttachedTransformation()->Put(inString, length);
-}
-
-void HashVerificationFilter::LastPut(const byte *inString, unsigned int length)
-{
-	if (m_flags & HASH_AT_BEGIN)
-	{
-		assert(length == 0);
-		m_verified = m_hashModule.Verify(m_expectedHash);
-	}
-	else
-	{
-		m_verified = (length==m_hashModule.DigestSize() && m_hashModule.Verify(inString));
-		if (m_flags & PUT_HASH)
-			AttachedTransformation()->Put(inString, length);
-	}
-
-	if (m_flags & PUT_RESULT)
-		AttachedTransformation()->Put(m_verified);
-
-	if ((m_flags & THROW_EXCEPTION) && !m_verified)
-		throw HashVerificationFailed();
-}
-
-// *************************************************************
-
-void SignerFilter::IsolatedInitialize(const NameValuePairs &parameters)
-{
-	m_putMessage = parameters.GetValueWithDefault(Name::PutMessage(), false);
-	m_messageAccumulator.reset(m_signer.NewSignatureAccumulator());
-}
-
-unsigned int SignerFilter::Put2(const byte *inString, unsigned int length, int messageEnd, bool blocking)
-{
-	FILTER_BEGIN;
-	m_messageAccumulator->Update(inString, length);
-	if (m_putMessage)
-		FILTER_OUTPUT(1, inString, length, 0);
-	if (messageEnd)
-	{
-		m_buf.New(m_signer.SignatureLength());
-		m_signer.Sign(m_rng, m_messageAccumulator.release(), m_buf);
-		FILTER_OUTPUT(2, m_buf, m_buf.size(), messageEnd);
-		m_messageAccumulator.reset(m_signer.NewSignatureAccumulator());
-	}
-	FILTER_END_NO_MESSAGE_END;
-}
-
-SignatureVerificationFilter::SignatureVerificationFilter(const PK_Verifier &verifier, BufferedTransformation *attachment, word32 flags)
-	: FilterWithBufferedInput(attachment)
-	, m_verifier(verifier)
-{
-	IsolatedInitialize(MakeParameters(Name::SignatureVerificationFilterFlags(), flags));
-}
-
-void SignatureVerificationFilter::InitializeDerivedAndReturnNewSizes(const NameValuePairs &parameters, unsigned int &firstSize, unsigned int &blockSize, unsigned int &lastSize)
-{
-	m_flags = parameters.GetValueWithDefault(Name::SignatureVerificationFilterFlags(), (word32)DEFAULT_FLAGS);
-	m_messageAccumulator.reset(m_verifier.NewVerificationAccumulator());
-	unsigned int size =	m_verifier.SignatureLength();
-	assert(size != 0);	// TODO: handle recoverable signature scheme
-	m_verified = false;
-	firstSize = m_flags & SIGNATURE_AT_BEGIN ? size : 0;
-	blockSize = 1;
-	lastSize = m_flags & SIGNATURE_AT_BEGIN ? 0 : size;
-}
-
-void SignatureVerificationFilter::FirstPut(const byte *inString)
-{
-	if (m_flags & SIGNATURE_AT_BEGIN)
-	{
-		if (m_verifier.SignatureUpfront())
-			m_verifier.InputSignature(*m_messageAccumulator, inString, m_verifier.SignatureLength());
-		else
-		{
-			m_signature.New(m_verifier.SignatureLength());
-			memcpy(m_signature, inString, m_signature.size());
-		}
-
-		if (m_flags & PUT_SIGNATURE)
-			AttachedTransformation()->Put(inString, m_signature.size());
-	}
-	else
-	{
-		assert(!m_verifier.SignatureUpfront());
-	}
-}
-
-void SignatureVerificationFilter::NextPutMultiple(const byte *inString, unsigned int length)
-{
-	m_messageAccumulator->Update(inString, length);
-	if (m_flags & PUT_MESSAGE)
-		AttachedTransformation()->Put(inString, length);
-}
-
-void SignatureVerificationFilter::LastPut(const byte *inString, unsigned int length)
-{
-	if (m_flags & SIGNATURE_AT_BEGIN)
-	{
-		assert(length == 0);
-		m_verifier.InputSignature(*m_messageAccumulator, m_signature, m_signature.size());
-		m_verified = m_verifier.VerifyAndRestart(*m_messageAccumulator);
-	}
-	else
-	{
-		m_verifier.InputSignature(*m_messageAccumulator, inString, length);
-		m_verified = m_verifier.VerifyAndRestart(*m_messageAccumulator);
-		if (m_flags & PUT_SIGNATURE)
-			AttachedTransformation()->Put(inString, length);
-	}
-
-	if (m_flags & PUT_RESULT)
-		AttachedTransformation()->Put(m_verified);
-
-	if ((m_flags & THROW_EXCEPTION) && !m_verified)
-		throw SignatureVerificationFailed();
-}
-
-// *************************************************************
-
-unsigned int Source::PumpAll2(bool blocking)
-{
-	// TODO: switch length type
-	unsigned long i = UINT_MAX;
-	RETURN_IF_NONZERO(Pump2(i, blocking));
-	unsigned int j = UINT_MAX;
-	return PumpMessages2(j, blocking);
-}
-
-bool Store::GetNextMessage()
-{
-	if (!m_messageEnd && !AnyRetrievable())
-	{
-		m_messageEnd=true;
-		return true;
-	}
-	else
-		return false;
-}
-
-unsigned int Store::CopyMessagesTo(BufferedTransformation &target, unsigned int count, const std::string &channel) const
-{
-	if (m_messageEnd || count == 0)
-		return 0;
-	else
-	{
-		CopyTo(target, ULONG_MAX, channel);
-		if (GetAutoSignalPropagation())
-			target.ChannelMessageEnd(channel, GetAutoSignalPropagation()-1);
-		return 1;
-	}
-}
-
-void StringStore::StoreInitialize(const NameValuePairs &parameters)
-{
-	ConstByteArrayParameter array;
-	if (!parameters.GetValue(Name::InputBuffer(), array))
-		throw InvalidArgument("StringStore: missing InputBuffer argument");
-	m_store = array.begin();
-	m_length = array.size();
-	m_count = 0;
-}
-
-unsigned int StringStore::TransferTo2(BufferedTransformation &target, unsigned long &transferBytes, const std::string &channel, bool blocking)
-{
-	unsigned long position = 0;
-	unsigned int blockedBytes = CopyRangeTo2(target, position, transferBytes, channel, blocking);
-	m_count += position;
-	transferBytes = position;
-	return blockedBytes;
-}
-
-unsigned int StringStore::CopyRangeTo2(BufferedTransformation &target, unsigned long &begin, unsigned long end, const std::string &channel, bool blocking) const
-{
-	unsigned int i = (unsigned int)STDMIN((unsigned long)m_count+begin, (unsigned long)m_length);
-	unsigned int len = (unsigned int)STDMIN((unsigned long)m_length-i, end-begin);
-	unsigned int blockedBytes = target.ChannelPut2(channel, m_store+i, len, 0, blocking);
-	if (!blockedBytes)
-		begin += len;
-	return blockedBytes;
-}
-
-unsigned int RandomNumberStore::TransferTo2(BufferedTransformation &target, unsigned long &transferBytes, const std::string &channel, bool blocking)
-{
-	if (!blocking)
-		throw NotImplemented("RandomNumberStore: nonblocking transfer is not implemented by this object");
-
-	unsigned long transferMax = transferBytes;
-	for (transferBytes = 0; transferBytes<transferMax && m_count < m_length; ++transferBytes, ++m_count)
-		target.ChannelPut(channel, m_rng.GenerateByte());
-	return 0;
-}
-
-unsigned int NullStore::CopyRangeTo2(BufferedTransformation &target, unsigned long &begin, unsigned long end, const std::string &channel, bool blocking) const
-{
-	static const byte nullBytes[128] = {0};
-	while (begin < end)
-	{
-		unsigned int len = STDMIN(end-begin, 128UL);
-		unsigned int blockedBytes = target.ChannelPut2(channel, nullBytes, len, 0, blocking);
-		if (blockedBytes)
-			return blockedBytes;
-		begin += len;
-	}
-	return 0;
-}
-
-unsigned int NullStore::TransferTo2(BufferedTransformation &target, unsigned long &transferBytes, const std::string &channel, bool blocking)
-{
-	unsigned long begin = 0;
-	unsigned int blockedBytes = NullStore::CopyRangeTo2(target, begin, transferBytes, channel, blocking);
-	transferBytes = begin;
-	m_size -= begin;
-	return blockedBytes;
-}
-
-NAMESPACE_END
+// filters.cpp - written and placed in the public domain by Wei Dai
+
+#include "pch.h"
+
+#ifndef CRYPTOPP_IMPORTS
+
+#include "filters.h"
+#include "mqueue.h"
+#include "fltrimpl.h"
+#include "argnames.h"
+#include <memory>
+#include <functional>
+
+NAMESPACE_BEGIN(CryptoPP)
+
+Filter::Filter(BufferedTransformation *attachment)
+	: m_attachment(attachment), m_continueAt(0)
+{
+}
+
+BufferedTransformation * Filter::NewDefaultAttachment() const
+{
+	return new MessageQueue;
+}
+
+BufferedTransformation * Filter::AttachedTransformation()
+{
+	if (m_attachment.get() == NULL)
+		m_attachment.reset(NewDefaultAttachment());
+	return m_attachment.get();
+}
+
+const BufferedTransformation *Filter::AttachedTransformation() const
+{
+	if (m_attachment.get() == NULL)
+		const_cast<Filter *>(this)->m_attachment.reset(NewDefaultAttachment());
+	return m_attachment.get();
+}
+
+void Filter::Detach(BufferedTransformation *newOut)
+{
+	m_attachment.reset(newOut);
+}
+
+void Filter::Insert(Filter *filter)
+{
+	filter->m_attachment.reset(m_attachment.release());
+	m_attachment.reset(filter);
+}
+
+size_t Filter::CopyRangeTo2(BufferedTransformation &target, lword &begin, lword end, const std::string &channel, bool blocking) const
+{
+	return AttachedTransformation()->CopyRangeTo2(target, begin, end, channel, blocking);
+}
+
+size_t Filter::TransferTo2(BufferedTransformation &target, lword &transferBytes, const std::string &channel, bool blocking)
+{
+	return AttachedTransformation()->TransferTo2(target, transferBytes, channel, blocking);
+}
+
+void Filter::Initialize(const NameValuePairs &parameters, int propagation)
+{
+	m_continueAt = 0;
+	IsolatedInitialize(parameters);
+	PropagateInitialize(parameters, propagation);
+}
+
+bool Filter::Flush(bool hardFlush, int propagation, bool blocking)
+{
+	switch (m_continueAt)
+	{
+	case 0:
+		if (IsolatedFlush(hardFlush, blocking))
+			return true;
+	case 1:
+		if (OutputFlush(1, hardFlush, propagation, blocking))
+			return true;
+	}
+	return false;
+}
+
+bool Filter::MessageSeriesEnd(int propagation, bool blocking)
+{
+	switch (m_continueAt)
+	{
+	case 0:
+		if (IsolatedMessageSeriesEnd(blocking))
+			return true;
+	case 1:
+		if (ShouldPropagateMessageSeriesEnd() && OutputMessageSeriesEnd(1, propagation, blocking))
+			return true;
+	}
+	return false;
+}
+
+void Filter::PropagateInitialize(const NameValuePairs &parameters, int propagation)
+{
+	if (propagation)
+		AttachedTransformation()->Initialize(parameters, propagation-1);
+}
+
+size_t Filter::OutputModifiable(int outputSite, byte *inString, size_t length, int messageEnd, bool blocking, const std::string &channel)
+{
+	if (messageEnd)
+		messageEnd--;
+	size_t result = AttachedTransformation()->ChannelPutModifiable2(channel, inString, length, messageEnd, blocking);
+	m_continueAt = result ? outputSite : 0;
+	return result;
+}
+
+size_t Filter::Output(int outputSite, const byte *inString, size_t length, int messageEnd, bool blocking, const std::string &channel)
+{
+	if (messageEnd)
+		messageEnd--;
+	size_t result = AttachedTransformation()->ChannelPut2(channel, inString, length, messageEnd, blocking);
+	m_continueAt = result ? outputSite : 0;
+	return result;
+}
+
+bool Filter::OutputFlush(int outputSite, bool hardFlush, int propagation, bool blocking, const std::string &channel)
+{
+	if (propagation && AttachedTransformation()->ChannelFlush(channel, hardFlush, propagation-1, blocking))
+	{
+		m_continueAt = outputSite;
+		return true;
+	}
+	m_continueAt = 0;
+	return false;
+}
+
+bool Filter::OutputMessageSeriesEnd(int outputSite, int propagation, bool blocking, const std::string &channel)
+{
+	if (propagation && AttachedTransformation()->ChannelMessageSeriesEnd(channel, propagation-1, blocking))
+	{
+		m_continueAt = outputSite;
+		return true;
+	}
+	m_continueAt = 0;
+	return false;
+}
+
+// *************************************************************
+
+void MeterFilter::ResetMeter()
+{
+	m_currentMessageBytes = m_totalBytes = m_currentSeriesMessages = m_totalMessages = m_totalMessageSeries = 0;
+	m_rangesToSkip.clear();
+}
+
+void MeterFilter::AddRangeToSkip(unsigned int message, lword position, lword size, bool sortNow)
+{
+	MessageRange r = {message, position, size};
+	m_rangesToSkip.push_back(r);
+	if (sortNow)
+		std::sort(m_rangesToSkip.begin(), m_rangesToSkip.end());
+}
+
+size_t MeterFilter::PutMaybeModifiable(byte *begin, size_t length, int messageEnd, bool blocking, bool modifiable)
+{
+	if (!m_transparent)
+		return 0;
+
+	size_t t;
+	FILTER_BEGIN;
+
+	m_begin = begin;
+	m_length = length;
+
+	while (m_length > 0 || messageEnd)
+	{
+		if (m_length > 0  && !m_rangesToSkip.empty() && m_rangesToSkip.front().message == m_totalMessages && m_currentMessageBytes + m_length > m_rangesToSkip.front().position)
+		{
+			FILTER_OUTPUT_MAYBE_MODIFIABLE(1, m_begin, t = (size_t)SaturatingSubtract(m_rangesToSkip.front().position, m_currentMessageBytes), false, modifiable);
+
+			assert(t < m_length);
+			m_begin += t;
+			m_length -= t;
+			m_currentMessageBytes += t;
+			m_totalBytes += t;
+
+			if (m_currentMessageBytes + m_length < m_rangesToSkip.front().position + m_rangesToSkip.front().size)
+				t = m_length;
+			else
+			{
+				t = (size_t)SaturatingSubtract(m_rangesToSkip.front().position + m_rangesToSkip.front().size, m_currentMessageBytes);
+				assert(t <= m_length);
+				m_rangesToSkip.pop_front();
+			}
+
+			m_begin += t;
+			m_length -= t;
+			m_currentMessageBytes += t;
+			m_totalBytes += t;
+		}
+		else
+		{
+			FILTER_OUTPUT_MAYBE_MODIFIABLE(2, m_begin, m_length, messageEnd, modifiable);
+
+			m_currentMessageBytes += m_length;
+			m_totalBytes += m_length;
+			m_length = 0;
+
+			if (messageEnd)
+			{
+				m_currentMessageBytes = 0;
+				m_currentSeriesMessages++;
+				m_totalMessages++;
+				messageEnd = false;
+			}
+		}
+	}
+
+	FILTER_END_NO_MESSAGE_END;
+}
+
+size_t MeterFilter::Put2(const byte *begin, size_t length, int messageEnd, bool blocking)
+{
+	return PutMaybeModifiable(const_cast<byte *>(begin), length, messageEnd, blocking, false);
+}
+
+size_t MeterFilter::PutModifiable2(byte *begin, size_t length, int messageEnd, bool blocking)
+{
+	return PutMaybeModifiable(begin, length, messageEnd, blocking, true);
+}
+
+bool MeterFilter::IsolatedMessageSeriesEnd(bool blocking)
+{
+	m_currentMessageBytes = 0;
+	m_currentSeriesMessages = 0;
+	m_totalMessageSeries++;
+	return false;
+}
+
+// *************************************************************
+
+void FilterWithBufferedInput::BlockQueue::ResetQueue(size_t blockSize, size_t maxBlocks)
+{
+	m_buffer.New(blockSize * maxBlocks);
+	m_blockSize = blockSize;
+	m_maxBlocks = maxBlocks;
+	m_size = 0;
+	m_begin = m_buffer;
+}
+
+byte *FilterWithBufferedInput::BlockQueue::GetBlock()
+{
+	if (m_size >= m_blockSize)
+	{
+		byte *ptr = m_begin;
+		if ((m_begin+=m_blockSize) == m_buffer.end())
+			m_begin = m_buffer;
+		m_size -= m_blockSize;
+		return ptr;
+	}
+	else
+		return NULL;
+}
+
+byte *FilterWithBufferedInput::BlockQueue::GetContigousBlocks(size_t &numberOfBytes)
+{
+	numberOfBytes = STDMIN(numberOfBytes, STDMIN(size_t(m_buffer.end()-m_begin), m_size));
+	byte *ptr = m_begin;
+	m_begin += numberOfBytes;
+	m_size -= numberOfBytes;
+	if (m_size == 0 || m_begin == m_buffer.end())
+		m_begin = m_buffer;
+	return ptr;
+}
+
+size_t FilterWithBufferedInput::BlockQueue::GetAll(byte *outString)
+{
+	size_t size = m_size;
+	size_t numberOfBytes = m_maxBlocks*m_blockSize;
+	const byte *ptr = GetContigousBlocks(numberOfBytes);
+	memcpy(outString, ptr, numberOfBytes);
+	memcpy(outString+numberOfBytes, m_begin, m_size);
+	m_size = 0;
+	return size;
+}
+
+void FilterWithBufferedInput::BlockQueue::Put(const byte *inString, size_t length)
+{
+	assert(m_size + length <= m_buffer.size());
+	byte *end = (m_size < size_t(m_buffer.end()-m_begin)) ? m_begin + m_size : m_begin + m_size - m_buffer.size();
+	size_t len = STDMIN(length, size_t(m_buffer.end()-end));
+	memcpy(end, inString, len);
+	if (len < length)
+		memcpy(m_buffer, inString+len, length-len);
+	m_size += length;
+}
+
+FilterWithBufferedInput::FilterWithBufferedInput(BufferedTransformation *attachment)
+	: Filter(attachment)
+{
+}
+
+FilterWithBufferedInput::FilterWithBufferedInput(size_t firstSize, size_t blockSize, size_t lastSize, BufferedTransformation *attachment)
+	: Filter(attachment), m_firstSize(firstSize), m_blockSize(blockSize), m_lastSize(lastSize)
+	, m_firstInputDone(false)
+{
+	if (m_firstSize < 0 || m_blockSize < 1 || m_lastSize < 0)
+		throw InvalidArgument("FilterWithBufferedInput: invalid buffer size");
+
+	m_queue.ResetQueue(1, m_firstSize);
+}
+
+void FilterWithBufferedInput::IsolatedInitialize(const NameValuePairs &parameters)
+{
+	InitializeDerivedAndReturnNewSizes(parameters, m_firstSize, m_blockSize, m_lastSize);
+	if (m_firstSize < 0 || m_blockSize < 1 || m_lastSize < 0)
+		throw InvalidArgument("FilterWithBufferedInput: invalid buffer size");
+	m_queue.ResetQueue(1, m_firstSize);
+	m_firstInputDone = false;
+}
+
+bool FilterWithBufferedInput::IsolatedFlush(bool hardFlush, bool blocking)
+{
+	if (!blocking)
+		throw BlockingInputOnly("FilterWithBufferedInput");
+	
+	if (hardFlush)
+		ForceNextPut();
+	FlushDerived();
+	
+	return false;
+}
+
+size_t FilterWithBufferedInput::PutMaybeModifiable(byte *inString, size_t length, int messageEnd, bool blocking, bool modifiable)
+{
+	if (!blocking)
+		throw BlockingInputOnly("FilterWithBufferedInput");
+
+	if (length != 0)
+	{
+		size_t newLength = m_queue.CurrentSize() + length;
+
+		if (!m_firstInputDone && newLength >= m_firstSize)
+		{
+			size_t len = m_firstSize - m_queue.CurrentSize();
+			m_queue.Put(inString, len);
+			FirstPut(m_queue.GetContigousBlocks(m_firstSize));
+			assert(m_queue.CurrentSize() == 0);
+			m_queue.ResetQueue(m_blockSize, (2*m_blockSize+m_lastSize-2)/m_blockSize);
+
+			inString += len;
+			newLength -= m_firstSize;
+			m_firstInputDone = true;
+		}
+
+		if (m_firstInputDone)
+		{
+			if (m_blockSize == 1)
+			{
+				while (newLength > m_lastSize && m_queue.CurrentSize() > 0)
+				{
+					size_t len = newLength - m_lastSize;
+					byte *ptr = m_queue.GetContigousBlocks(len);
+					NextPutModifiable(ptr, len);
+					newLength -= len;
+				}
+
+				if (newLength > m_lastSize)
+				{
+					size_t len = newLength - m_lastSize;
+					NextPutMaybeModifiable(inString, len, modifiable);
+					inString += len;
+					newLength -= len;
+				}
+			}
+			else
+			{
+				while (newLength >= m_blockSize + m_lastSize && m_queue.CurrentSize() >= m_blockSize)
+				{
+					NextPutModifiable(m_queue.GetBlock(), m_blockSize);
+					newLength -= m_blockSize;
+				}
+
+				if (newLength >= m_blockSize + m_lastSize && m_queue.CurrentSize() > 0)
+				{
+					assert(m_queue.CurrentSize() < m_blockSize);
+					size_t len = m_blockSize - m_queue.CurrentSize();
+					m_queue.Put(inString, len);
+					inString += len;
+					NextPutModifiable(m_queue.GetBlock(), m_blockSize);
+					newLength -= m_blockSize;
+				}
+
+				if (newLength >= m_blockSize + m_lastSize)
+				{
+					size_t len = RoundDownToMultipleOf(newLength - m_lastSize, m_blockSize);
+					NextPutMaybeModifiable(inString, len, modifiable);
+					inString += len;
+					newLength -= len;
+				}
+			}
+		}
+
+		m_queue.Put(inString, newLength - m_queue.CurrentSize());
+	}
+
+	if (messageEnd)
+	{
+		if (!m_firstInputDone && m_firstSize==0)
+			FirstPut(NULL);
+
+		SecByteBlock temp(m_queue.CurrentSize());
+		m_queue.GetAll(temp);
+		LastPut(temp, temp.size());
+
+		m_firstInputDone = false;
+		m_queue.ResetQueue(1, m_firstSize);
+
+		Output(1, NULL, 0, messageEnd, blocking);
+	}
+	return 0;
+}
+
+void FilterWithBufferedInput::ForceNextPut()
+{
+	if (!m_firstInputDone)
+		return;
+	
+	if (m_blockSize > 1)
+	{
+		while (m_queue.CurrentSize() >= m_blockSize)
+			NextPutModifiable(m_queue.GetBlock(), m_blockSize);
+	}
+	else
+	{
+		size_t len;
+		while ((len = m_queue.CurrentSize()) > 0)
+			NextPutModifiable(m_queue.GetContigousBlocks(len), len);
+	}
+}
+
+void FilterWithBufferedInput::NextPutMultiple(const byte *inString, size_t length)
+{
+	assert(m_blockSize > 1);	// m_blockSize = 1 should always override this function
+	while (length > 0)
+	{
+		assert(length >= m_blockSize);
+		NextPutSingle(inString);
+		inString += m_blockSize;
+		length -= m_blockSize;
+	}
+}
+
+// *************************************************************
+
+void Redirector::Initialize(const NameValuePairs &parameters, int propagation)
+{
+	m_target = parameters.GetValueWithDefault("RedirectionTargetPointer", (BufferedTransformation*)NULL);
+	m_behavior = parameters.GetIntValueWithDefault("RedirectionBehavior", PASS_EVERYTHING);
+
+	if (m_target && GetPassSignals())
+		m_target->Initialize(parameters, propagation);
+}
+
+// *************************************************************
+
+ProxyFilter::ProxyFilter(BufferedTransformation *filter, size_t firstSize, size_t lastSize, BufferedTransformation *attachment)
+	: FilterWithBufferedInput(firstSize, 1, lastSize, attachment), m_filter(filter)
+{
+	if (m_filter.get())
+		m_filter->Attach(new OutputProxy(*this, false));
+}
+
+bool ProxyFilter::IsolatedFlush(bool hardFlush, bool blocking)
+{
+	return m_filter.get() ? m_filter->Flush(hardFlush, -1, blocking) : false;
+}
+
+void ProxyFilter::SetFilter(Filter *filter)
+{
+	m_filter.reset(filter);
+	if (filter)
+	{
+		OutputProxy *proxy;
+		std::auto_ptr<OutputProxy> temp(proxy = new OutputProxy(*this, false));
+		m_filter->TransferAllTo(*proxy);
+		m_filter->Attach(temp.release());
+	}
+}
+
+void ProxyFilter::NextPutMultiple(const byte *s, size_t len)
+{
+	if (m_filter.get())
+		m_filter->Put(s, len);
+}
+
+void ProxyFilter::NextPutModifiable(byte *s, size_t len)
+{
+	if (m_filter.get())
+		m_filter->PutModifiable(s, len);
+}
+
+// *************************************************************
+
+void RandomNumberSink::IsolatedInitialize(const NameValuePairs &parameters)
+{
+	parameters.GetRequiredParameter("RandomNumberSink", "RandomNumberGeneratorPointer", m_rng);
+}
+
+size_t RandomNumberSink::Put2(const byte *begin, size_t length, int messageEnd, bool blocking)
+{
+	m_rng->IncorporateEntropy(begin, length);
+	return 0;
+}
+
+size_t ArraySink::Put2(const byte *begin, size_t length, int messageEnd, bool blocking)
+{
+	if (m_buf+m_total != begin)
+		memcpy(m_buf+m_total, begin, STDMIN(length, SaturatingSubtract(m_size, m_total)));
+	m_total += length;
+	return 0;
+}
+
+byte * ArraySink::CreatePutSpace(size_t &size)
+{
+	size = SaturatingSubtract(m_size, m_total);
+	return m_buf + m_total;
+}
+
+void ArraySink::IsolatedInitialize(const NameValuePairs &parameters)
+{
+	ByteArrayParameter array;
+	if (!parameters.GetValue(Name::OutputBuffer(), array))
+		throw InvalidArgument("ArraySink: missing OutputBuffer argument");
+	m_buf = array.begin();
+	m_size = array.size();
+	m_total = 0;
+}
+
+size_t ArrayXorSink::Put2(const byte *begin, size_t length, int messageEnd, bool blocking)
+{
+	xorbuf(m_buf+m_total, begin, STDMIN(length, SaturatingSubtract(m_size, m_total)));
+	m_total += length;
+	return 0;
+}
+
+// *************************************************************
+
+StreamTransformationFilter::StreamTransformationFilter(StreamTransformation &c, BufferedTransformation *attachment, BlockPaddingScheme padding, bool allowAuthenticatedSymmetricCipher)
+   : FilterWithBufferedInput(attachment)
+	, m_cipher(c)
+{
+	assert(c.MinLastBlockSize() == 0 || c.MinLastBlockSize() > c.MandatoryBlockSize());
+
+	if (!allowAuthenticatedSymmetricCipher && dynamic_cast<AuthenticatedSymmetricCipher *>(&c) != 0)
+		throw InvalidArgument("StreamTransformationFilter: please use AuthenticatedEncryptionFilter and AuthenticatedDecryptionFilter for AuthenticatedSymmetricCipher");
+
+	IsolatedInitialize(MakeParameters(Name::BlockPaddingScheme(), padding));
+}
+
+size_t StreamTransformationFilter::LastBlockSize(StreamTransformation &c, BlockPaddingScheme padding)
+{
+	if (c.MinLastBlockSize() > 0)
+		return c.MinLastBlockSize();
+	else if (c.MandatoryBlockSize() > 1 && !c.IsForwardTransformation() && padding != NO_PADDING && padding != ZEROS_PADDING)
+		return c.MandatoryBlockSize();
+	else
+		return 0;
+}
+
+void StreamTransformationFilter::InitializeDerivedAndReturnNewSizes(const NameValuePairs &parameters, size_t &firstSize, size_t &blockSize, size_t &lastSize)
+{
+	BlockPaddingScheme padding = parameters.GetValueWithDefault(Name::BlockPaddingScheme(), DEFAULT_PADDING);
+	bool isBlockCipher = (m_cipher.MandatoryBlockSize() > 1 && m_cipher.MinLastBlockSize() == 0);
+
+	if (padding == DEFAULT_PADDING)
+		m_padding = isBlockCipher ? PKCS_PADDING : NO_PADDING;
+	else
+		m_padding = padding;
+
+	if (!isBlockCipher && (m_padding == PKCS_PADDING || m_padding == ONE_AND_ZEROS_PADDING))
+		throw InvalidArgument("StreamTransformationFilter: PKCS_PADDING and ONE_AND_ZEROS_PADDING cannot be used with " + m_cipher.AlgorithmName());
+
+	firstSize = 0;
+	blockSize = m_cipher.MandatoryBlockSize();
+	lastSize = LastBlockSize(m_cipher, m_padding);
+}
+
+void StreamTransformationFilter::FirstPut(const byte *inString)
+{
+	m_optimalBufferSize = m_cipher.OptimalBlockSize();
+	m_optimalBufferSize = (unsigned int)STDMAX(m_optimalBufferSize, RoundDownToMultipleOf(4096U, m_optimalBufferSize));
+}
+
+void StreamTransformationFilter::NextPutMultiple(const byte *inString, size_t length)
+{
+	if (!length)
+		return;
+
+	size_t s = m_cipher.MandatoryBlockSize();
+
+	do
+	{
+		size_t len = m_optimalBufferSize;
+		byte *space = HelpCreatePutSpace(*AttachedTransformation(), DEFAULT_CHANNEL, s, length, len);
+		if (len < length)
+		{
+			if (len == m_optimalBufferSize)
+				len -= m_cipher.GetOptimalBlockSizeUsed();
+			len = RoundDownToMultipleOf(len, s);
+		}
+		else
+			len = length;
+		m_cipher.ProcessString(space, inString, len);
+		AttachedTransformation()->PutModifiable(space, len);
+		inString += len;
+		length -= len;
+	}
+	while (length > 0);
+}
+
+void StreamTransformationFilter::NextPutModifiable(byte *inString, size_t length)
+{
+	m_cipher.ProcessString(inString, length);
+	AttachedTransformation()->PutModifiable(inString, length);
+}
+
+void StreamTransformationFilter::LastPut(const byte *inString, size_t length)
+{
+	byte *space = NULL;
+	
+	switch (m_padding)
+	{
+	case NO_PADDING:
+	case ZEROS_PADDING:
+		if (length > 0)
+		{
+			size_t minLastBlockSize = m_cipher.MinLastBlockSize();
+			bool isForwardTransformation = m_cipher.IsForwardTransformation();
+
+			if (isForwardTransformation && m_padding == ZEROS_PADDING && (minLastBlockSize == 0 || length < minLastBlockSize))
+			{
+				// do padding
+				size_t blockSize = STDMAX(minLastBlockSize, (size_t)m_cipher.MandatoryBlockSize());
+				space = HelpCreatePutSpace(*AttachedTransformation(), DEFAULT_CHANNEL, blockSize);
+				memcpy(space, inString, length);
+				memset(space + length, 0, blockSize - length);
+				m_cipher.ProcessLastBlock(space, space, blockSize);
+				AttachedTransformation()->Put(space, blockSize);
+			}
+			else
+			{
+				if (minLastBlockSize == 0)
+				{
+					if (isForwardTransformation)
+						throw InvalidDataFormat("StreamTransformationFilter: plaintext length is not a multiple of block size and NO_PADDING is specified");
+					else
+						throw InvalidCiphertext("StreamTransformationFilter: ciphertext length is not a multiple of block size");
+				}
+
+				space = HelpCreatePutSpace(*AttachedTransformation(), DEFAULT_CHANNEL, length, m_optimalBufferSize);
+				m_cipher.ProcessLastBlock(space, inString, length);
+				AttachedTransformation()->Put(space, length);
+			}
+		}
+		break;
+
+	case PKCS_PADDING:
+	case ONE_AND_ZEROS_PADDING:
+		unsigned int s;
+		s = m_cipher.MandatoryBlockSize();
+		assert(s > 1);
+		space = HelpCreatePutSpace(*AttachedTransformation(), DEFAULT_CHANNEL, s, m_optimalBufferSize);
+		if (m_cipher.IsForwardTransformation())
+		{
+			assert(length < s);
+			memcpy(space, inString, length);
+			if (m_padding == PKCS_PADDING)
+			{
+				assert(s < 256);
+				byte pad = byte(s-length);
+				memset(space+length, pad, s-length);
+			}
+			else
+			{
+				space[length] = 0x80;
+				memset(space+length+1, 0, s-length-1);
+			}
+			m_cipher.ProcessData(space, space, s);
+			AttachedTransformation()->Put(space, s);
+		}
+		else
+		{
+			if (length != s)
+				throw InvalidCiphertext("StreamTransformationFilter: ciphertext length is not a multiple of block size");
+			m_cipher.ProcessData(space, inString, s);
+			if (m_padding == PKCS_PADDING)
+			{
+				byte pad = space[s-1];
+				if (pad < 1 || pad > s || std::find_if(space+s-pad, space+s, std::bind2nd(std::not_equal_to<byte>(), pad)) != space+s)
+					throw InvalidCiphertext("StreamTransformationFilter: invalid PKCS #7 block padding found");
+				length = s-pad;
+			}
+			else
+			{
+				while (length > 1 && space[length-1] == 0)
+					--length;
+				if (space[--length] != 0x80)
+					throw InvalidCiphertext("StreamTransformationFilter: invalid ones-and-zeros padding found");
+			}
+			AttachedTransformation()->Put(space, length);
+		}
+		break;
+
+	default:
+		assert(false);
+	}
+}
+
+// *************************************************************
+
+HashFilter::HashFilter(HashTransformation &hm, BufferedTransformation *attachment, bool putMessage, int truncatedDigestSize, const std::string &messagePutChannel, const std::string &hashPutChannel)
+	: m_hashModule(hm), m_putMessage(putMessage), m_messagePutChannel(messagePutChannel), m_hashPutChannel(hashPutChannel)
+{
+	m_digestSize = truncatedDigestSize < 0 ? m_hashModule.DigestSize() : truncatedDigestSize;
+	Detach(attachment);
+}
+
+void HashFilter::IsolatedInitialize(const NameValuePairs &parameters)
+{
+	m_putMessage = parameters.GetValueWithDefault(Name::PutMessage(), false);
+	int s = parameters.GetIntValueWithDefault(Name::TruncatedDigestSize(), -1);
+	m_digestSize = s < 0 ? m_hashModule.DigestSize() : s;
+}
+
+size_t HashFilter::Put2(const byte *inString, size_t length, int messageEnd, bool blocking)
+{
+	FILTER_BEGIN;
+	if (m_putMessage)
+		FILTER_OUTPUT3(1, 0, inString, length, 0, m_messagePutChannel);
+	m_hashModule.Update(inString, length);
+	if (messageEnd)
+	{
+		{
+			size_t size;
+			m_space = HelpCreatePutSpace(*AttachedTransformation(), m_hashPutChannel, m_digestSize, m_digestSize, size = m_digestSize);
+			m_hashModule.TruncatedFinal(m_space, m_digestSize);
+		}
+		FILTER_OUTPUT3(2, 0, m_space, m_digestSize, messageEnd, m_hashPutChannel);
+	}
+	FILTER_END_NO_MESSAGE_END;
+}
+
+// *************************************************************
+
+HashVerificationFilter::HashVerificationFilter(HashTransformation &hm, BufferedTransformation *attachment, word32 flags, int truncatedDigestSize)
+	: FilterWithBufferedInput(attachment)
+	, m_hashModule(hm)
+{
+	IsolatedInitialize(MakeParameters(Name::HashVerificationFilterFlags(), flags)(Name::TruncatedDigestSize(), truncatedDigestSize));
+}
+
+void HashVerificationFilter::InitializeDerivedAndReturnNewSizes(const NameValuePairs &parameters, size_t &firstSize, size_t &blockSize, size_t &lastSize)
+{
+	m_flags = parameters.GetValueWithDefault(Name::HashVerificationFilterFlags(), (word32)DEFAULT_FLAGS);
+	int s = parameters.GetIntValueWithDefault(Name::TruncatedDigestSize(), -1);
+	m_digestSize = s < 0 ? m_hashModule.DigestSize() : s;
+	m_verified = false;
+	firstSize = m_flags & HASH_AT_BEGIN ? m_digestSize : 0;
+	blockSize = 1;
+	lastSize = m_flags & HASH_AT_BEGIN ? 0 : m_digestSize;
+}
+
+void HashVerificationFilter::FirstPut(const byte *inString)
+{
+	if (m_flags & HASH_AT_BEGIN)
+	{
+		m_expectedHash.New(m_digestSize);
+		memcpy(m_expectedHash, inString, m_expectedHash.size());
+		if (m_flags & PUT_HASH)
+			AttachedTransformation()->Put(inString, m_expectedHash.size());
+	}
+}
+
+void HashVerificationFilter::NextPutMultiple(const byte *inString, size_t length)
+{
+	m_hashModule.Update(inString, length);
+	if (m_flags & PUT_MESSAGE)
+		AttachedTransformation()->Put(inString, length);
+}
+
+void HashVerificationFilter::LastPut(const byte *inString, size_t length)
+{
+	if (m_flags & HASH_AT_BEGIN)
+	{
+		assert(length == 0);
+		m_verified = m_hashModule.TruncatedVerify(m_expectedHash, m_digestSize);
+	}
+	else
+	{
+		m_verified = (length==m_digestSize && m_hashModule.TruncatedVerify(inString, length));
+		if (m_flags & PUT_HASH)
+			AttachedTransformation()->Put(inString, length);
+	}
+
+	if (m_flags & PUT_RESULT)
+		AttachedTransformation()->Put(m_verified);
+
+	if ((m_flags & THROW_EXCEPTION) && !m_verified)
+		throw HashVerificationFailed();
+}
+
+// *************************************************************
+
+AuthenticatedEncryptionFilter::AuthenticatedEncryptionFilter(AuthenticatedSymmetricCipher &c, BufferedTransformation *attachment, 
+								bool putAAD, int truncatedDigestSize, const std::string &macChannel, BlockPaddingScheme padding)
+	: StreamTransformationFilter(c, attachment, padding, true)
+	, m_hf(c, new OutputProxy(*this, false), putAAD, truncatedDigestSize, AAD_CHANNEL, macChannel)
+{
+	assert(c.IsForwardTransformation());
+}
+
+void AuthenticatedEncryptionFilter::IsolatedInitialize(const NameValuePairs &parameters)
+{
+	m_hf.IsolatedInitialize(parameters);
+	StreamTransformationFilter::IsolatedInitialize(parameters);
+}
+
+byte * AuthenticatedEncryptionFilter::ChannelCreatePutSpace(const std::string &channel, size_t &size)
+{
+	if (channel.empty())
+		return StreamTransformationFilter::CreatePutSpace(size);
+
+	if (channel == AAD_CHANNEL)
+		return m_hf.CreatePutSpace(size);
+
+	throw InvalidChannelName("AuthenticatedEncryptionFilter", channel);
+}
+
+size_t AuthenticatedEncryptionFilter::ChannelPut2(const std::string &channel, const byte *begin, size_t length, int messageEnd, bool blocking)
+{
+	if (channel.empty())
+		return StreamTransformationFilter::Put2(begin, length, messageEnd, blocking);
+
+	if (channel == AAD_CHANNEL)
+		return m_hf.Put2(begin, length, 0, blocking);
+
+	throw InvalidChannelName("AuthenticatedEncryptionFilter", channel);
+}
+
+void AuthenticatedEncryptionFilter::LastPut(const byte *inString, size_t length)
+{
+	StreamTransformationFilter::LastPut(inString, length);
+	m_hf.MessageEnd();
+}
+
+// *************************************************************
+
+AuthenticatedDecryptionFilter::AuthenticatedDecryptionFilter(AuthenticatedSymmetricCipher &c, BufferedTransformation *attachment, word32 flags, int truncatedDigestSize, BlockPaddingScheme padding)
+	: FilterWithBufferedInput(attachment)
+	, m_hashVerifier(c, new OutputProxy(*this, false))
+	, m_streamFilter(c, new OutputProxy(*this, false), padding, true)
+{
+	assert(!c.IsForwardTransformation() || c.IsSelfInverting());
+	IsolatedInitialize(MakeParameters(Name::BlockPaddingScheme(), padding)(Name::AuthenticatedDecryptionFilterFlags(), flags)(Name::TruncatedDigestSize(), truncatedDigestSize));
+}
+
+void AuthenticatedDecryptionFilter::InitializeDerivedAndReturnNewSizes(const NameValuePairs &parameters, size_t &firstSize, size_t &blockSize, size_t &lastSize)
+{
+	word32 flags = parameters.GetValueWithDefault(Name::AuthenticatedDecryptionFilterFlags(), (word32)DEFAULT_FLAGS);
+
+	m_hashVerifier.Initialize(CombinedNameValuePairs(parameters, MakeParameters(Name::HashVerificationFilterFlags(), flags)));
+	m_streamFilter.Initialize(parameters);
+
+	firstSize = m_hashVerifier.m_firstSize;
+	blockSize = 1;
+	lastSize = m_hashVerifier.m_lastSize;
+}
+
+byte * AuthenticatedDecryptionFilter::ChannelCreatePutSpace(const std::string &channel, size_t &size)
+{
+	if (channel.empty())
+		return m_streamFilter.CreatePutSpace(size);
+
+	if (channel == AAD_CHANNEL)
+		return m_hashVerifier.CreatePutSpace(size);
+
+	throw InvalidChannelName("AuthenticatedDecryptionFilter", channel);
+}
+
+size_t AuthenticatedDecryptionFilter::ChannelPut2(const std::string &channel, const byte *begin, size_t length, int messageEnd, bool blocking)
+{
+	if (channel.empty())
+	{
+		if (m_lastSize > 0)
+			m_hashVerifier.ForceNextPut();
+		return FilterWithBufferedInput::Put2(begin, length, messageEnd, blocking);
+	}
+
+	if (channel == AAD_CHANNEL)
+		return m_hashVerifier.Put2(begin, length, 0, blocking);
+
+	throw InvalidChannelName("AuthenticatedDecryptionFilter", channel);
+}
+
+void AuthenticatedDecryptionFilter::FirstPut(const byte *inString)
+{
+	m_hashVerifier.Put(inString, m_firstSize);
+}
+
+void AuthenticatedDecryptionFilter::NextPutMultiple(const byte *inString, size_t length)
+{
+	m_streamFilter.Put(inString, length);
+}
+
+void AuthenticatedDecryptionFilter::LastPut(const byte *inString, size_t length)
+{
+	m_streamFilter.MessageEnd();
+	m_hashVerifier.PutMessageEnd(inString, length);
+}
+
+// *************************************************************
+
+void SignerFilter::IsolatedInitialize(const NameValuePairs &parameters)
+{
+	m_putMessage = parameters.GetValueWithDefault(Name::PutMessage(), false);
+	m_messageAccumulator.reset(m_signer.NewSignatureAccumulator(m_rng));
+}
+
+size_t SignerFilter::Put2(const byte *inString, size_t length, int messageEnd, bool blocking)
+{
+	FILTER_BEGIN;
+	m_messageAccumulator->Update(inString, length);
+	if (m_putMessage)
+		FILTER_OUTPUT(1, inString, length, 0);
+	if (messageEnd)
+	{
+		m_buf.New(m_signer.SignatureLength());
+		m_signer.Sign(m_rng, m_messageAccumulator.release(), m_buf);
+		FILTER_OUTPUT(2, m_buf, m_buf.size(), messageEnd);
+		m_messageAccumulator.reset(m_signer.NewSignatureAccumulator(m_rng));
+	}
+	FILTER_END_NO_MESSAGE_END;
+}
+
+SignatureVerificationFilter::SignatureVerificationFilter(const PK_Verifier &verifier, BufferedTransformation *attachment, word32 flags)
+	: FilterWithBufferedInput(attachment)
+	, m_verifier(verifier)
+{
+	IsolatedInitialize(MakeParameters(Name::SignatureVerificationFilterFlags(), flags));
+}
+
+void SignatureVerificationFilter::InitializeDerivedAndReturnNewSizes(const NameValuePairs &parameters, size_t &firstSize, size_t &blockSize, size_t &lastSize)
+{
+	m_flags = parameters.GetValueWithDefault(Name::SignatureVerificationFilterFlags(), (word32)DEFAULT_FLAGS);
+	m_messageAccumulator.reset(m_verifier.NewVerificationAccumulator());
+	size_t size = m_verifier.SignatureLength();
+	assert(size != 0);	// TODO: handle recoverable signature scheme
+	m_verified = false;
+	firstSize = m_flags & SIGNATURE_AT_BEGIN ? size : 0;
+	blockSize = 1;
+	lastSize = m_flags & SIGNATURE_AT_BEGIN ? 0 : size;
+}
+
+void SignatureVerificationFilter::FirstPut(const byte *inString)
+{
+	if (m_flags & SIGNATURE_AT_BEGIN)
+	{
+		if (m_verifier.SignatureUpfront())
+			m_verifier.InputSignature(*m_messageAccumulator, inString, m_verifier.SignatureLength());
+		else
+		{
+			m_signature.New(m_verifier.SignatureLength());
+			memcpy(m_signature, inString, m_signature.size());
+		}
+
+		if (m_flags & PUT_SIGNATURE)
+			AttachedTransformation()->Put(inString, m_signature.size());
+	}
+	else
+	{
+		assert(!m_verifier.SignatureUpfront());
+	}
+}
+
+void SignatureVerificationFilter::NextPutMultiple(const byte *inString, size_t length)
+{
+	m_messageAccumulator->Update(inString, length);
+	if (m_flags & PUT_MESSAGE)
+		AttachedTransformation()->Put(inString, length);
+}
+
+void SignatureVerificationFilter::LastPut(const byte *inString, size_t length)
+{
+	if (m_flags & SIGNATURE_AT_BEGIN)
+	{
+		assert(length == 0);
+		m_verifier.InputSignature(*m_messageAccumulator, m_signature, m_signature.size());
+		m_verified = m_verifier.VerifyAndRestart(*m_messageAccumulator);
+	}
+	else
+	{
+		m_verifier.InputSignature(*m_messageAccumulator, inString, length);
+		m_verified = m_verifier.VerifyAndRestart(*m_messageAccumulator);
+		if (m_flags & PUT_SIGNATURE)
+			AttachedTransformation()->Put(inString, length);
+	}
+
+	if (m_flags & PUT_RESULT)
+		AttachedTransformation()->Put(m_verified);
+
+	if ((m_flags & THROW_EXCEPTION) && !m_verified)
+		throw SignatureVerificationFailed();
+}
+
+// *************************************************************
+
+size_t Source::PumpAll2(bool blocking)
+{
+	unsigned int messageCount = UINT_MAX;
+	do {
+		RETURN_IF_NONZERO(PumpMessages2(messageCount, blocking));
+	} while(messageCount == UINT_MAX);
+
+	return 0;
+}
+
+bool Store::GetNextMessage()
+{
+	if (!m_messageEnd && !AnyRetrievable())
+	{
+		m_messageEnd=true;
+		return true;
+	}
+	else
+		return false;
+}
+
+unsigned int Store::CopyMessagesTo(BufferedTransformation &target, unsigned int count, const std::string &channel) const
+{
+	if (m_messageEnd || count == 0)
+		return 0;
+	else
+	{
+		CopyTo(target, ULONG_MAX, channel);
+		if (GetAutoSignalPropagation())
+			target.ChannelMessageEnd(channel, GetAutoSignalPropagation()-1);
+		return 1;
+	}
+}
+
+void StringStore::StoreInitialize(const NameValuePairs &parameters)
+{
+	ConstByteArrayParameter array;
+	if (!parameters.GetValue(Name::InputBuffer(), array))
+		throw InvalidArgument("StringStore: missing InputBuffer argument");
+	m_store = array.begin();
+	m_length = array.size();
+	m_count = 0;
+}
+
+size_t StringStore::TransferTo2(BufferedTransformation &target, lword &transferBytes, const std::string &channel, bool blocking)
+{
+	lword position = 0;
+	size_t blockedBytes = CopyRangeTo2(target, position, transferBytes, channel, blocking);
+	m_count += (size_t)position;
+	transferBytes = position;
+	return blockedBytes;
+}
+
+size_t StringStore::CopyRangeTo2(BufferedTransformation &target, lword &begin, lword end, const std::string &channel, bool blocking) const
+{
+	size_t i = UnsignedMin(m_length, m_count+begin);
+	size_t len = UnsignedMin(m_length-i, end-begin);
+	size_t blockedBytes = target.ChannelPut2(channel, m_store+i, len, 0, blocking);
+	if (!blockedBytes)
+		begin += len;
+	return blockedBytes;
+}
+
+void RandomNumberStore::StoreInitialize(const NameValuePairs &parameters)
+{
+	parameters.GetRequiredParameter("RandomNumberStore", "RandomNumberGeneratorPointer", m_rng);
+	int length;
+	parameters.GetRequiredIntParameter("RandomNumberStore", "RandomNumberStoreSize", length);
+	m_length = length;
+}
+
+size_t RandomNumberStore::TransferTo2(BufferedTransformation &target, lword &transferBytes, const std::string &channel, bool blocking)
+{
+	if (!blocking)
+		throw NotImplemented("RandomNumberStore: nonblocking transfer is not implemented by this object");
+
+	transferBytes = UnsignedMin(transferBytes, m_length - m_count);
+	m_rng->GenerateIntoBufferedTransformation(target, channel, transferBytes);
+	m_count += transferBytes;
+
+	return 0;
+}
+
+size_t NullStore::CopyRangeTo2(BufferedTransformation &target, lword &begin, lword end, const std::string &channel, bool blocking) const
+{
+	static const byte nullBytes[128] = {0};
+	while (begin < end)
+	{
+		size_t len = (size_t)STDMIN(end-begin, lword(128));
+		size_t blockedBytes = target.ChannelPut2(channel, nullBytes, len, 0, blocking);
+		if (blockedBytes)
+			return blockedBytes;
+		begin += len;
+	}
+	return 0;
+}
+
+size_t NullStore::TransferTo2(BufferedTransformation &target, lword &transferBytes, const std::string &channel, bool blocking)
+{
+	lword begin = 0;
+	size_t blockedBytes = NullStore::CopyRangeTo2(target, begin, transferBytes, channel, blocking);
+	transferBytes = begin;
+	m_size -= begin;
+	return blockedBytes;
+}
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/hex.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/hex.cpp
index a870a946..5731df55 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/src/hex.cpp
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/hex.cpp
@@ -1,32 +1,44 @@
-// hex.cpp - written and placed in the public domain by Wei Dai
-
-//#include "pch.h"
-#include "hex.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-static const byte s_vecUpper[] = "0123456789ABCDEF";
-static const byte s_vecLower[] = "0123456789abcdef";
-
-void HexEncoder::IsolatedInitialize(const NameValuePairs &parameters)
-{
-	bool uppercase = parameters.GetValueWithDefault("Uppercase", true);
-	m_filter->Initialize(CombinedNameValuePairs(
-		parameters,
-		MakeParameters("EncodingLookupArray", uppercase ? &s_vecUpper[0] : &s_vecLower[0])("Log2Base", 4)));
-}
-
-const int *HexDecoder::GetDecodingLookupArray()
-{
-	static bool s_initialized = false;
-	static int s_array[256];
-
-	if (!s_initialized)
-	{
-		InitializeDecodingLookupArray(s_array, s_vecUpper, 16, true);
-		s_initialized = true;
-	}
-	return s_array;
-}
-
-NAMESPACE_END
+// hex.cpp - written and placed in the public domain by Wei Dai
+
+#include "pch.h"
+
+#ifndef CRYPTOPP_IMPORTS
+
+#include "hex.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+static const byte s_vecUpper[] = "0123456789ABCDEF";
+static const byte s_vecLower[] = "0123456789abcdef";
+
+void HexEncoder::IsolatedInitialize(const NameValuePairs &parameters)
+{
+	bool uppercase = parameters.GetValueWithDefault(Name::Uppercase(), true);
+	m_filter->Initialize(CombinedNameValuePairs(
+		parameters,
+		MakeParameters(Name::EncodingLookupArray(), uppercase ? &s_vecUpper[0] : &s_vecLower[0], false)(Name::Log2Base(), 4, true)));
+}
+
+void HexDecoder::IsolatedInitialize(const NameValuePairs &parameters)
+{
+	BaseN_Decoder::IsolatedInitialize(CombinedNameValuePairs(
+		parameters,
+		MakeParameters(Name::DecodingLookupArray(), GetDefaultDecodingLookupArray(), false)(Name::Log2Base(), 4, true)));
+}
+
+const int *HexDecoder::GetDefaultDecodingLookupArray()
+{
+	static volatile bool s_initialized = false;
+	static int s_array[256];
+
+	if (!s_initialized)
+	{
+		InitializeDecodingLookupArray(s_array, s_vecUpper, 16, true);
+		s_initialized = true;
+	}
+	return s_array;
+}
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/integer.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/integer.cpp
index cb6f155e..f07cce87 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/src/integer.cpp
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/integer.cpp
@@ -1,4004 +1,4235 @@
-// integer.cpp - written and placed in the public domain by Wei Dai
-// contains public domain code contributed by Alister Lee and Leonard Janke
-
-//#include "pch.h"
-#include "integer.h"
-#include "modarith.h"
-#include "nbtheory.h"
-#include "asn.h"
-#include "oids.h"
-#include "words.h"
-#include "algparam.h"
-#include "pubkey.h"		// for P1363_KDF2
-#include "sha.h"
-
-#include <iostream>
-
-#ifdef SSE2_INTRINSICS_AVAILABLE
-#include <emmintrin.h>
-#endif
-
-#include "algebra.cpp"
-#include "eprecomp.cpp"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-bool FunctionAssignIntToInteger(const std::type_info &valueType, void *pInteger, const void *pInt)
-{
-	if (valueType != typeid(Integer))
-		return false;
-	*reinterpret_cast<Integer *>(pInteger) = *reinterpret_cast<const int *>(pInt);
-	return true;
-}
-
-static int DummyAssignIntToInteger = (AssignIntToInteger = FunctionAssignIntToInteger, 0);
-
-#ifdef SSE2_INTRINSICS_AVAILABLE
-template <class T>
-AllocatorBase<T>::pointer AlignedAllocator<T>::allocate(size_type n, const void *)
-{
-	if (n < 4)
-		return new T[n];
-	else
-		return (T *)_mm_malloc(sizeof(T)*n, 16);
-
-}
-
-template <class T>
-void AlignedAllocator<T>::deallocate(void *p, size_type n)
-{
-	memset(p, 0, n*sizeof(T));
-	if (n < 4)
-		delete [] p;
-	else
-		_mm_free(p);
-}
-
-template class AlignedAllocator<word>;
-#endif
-
-#define MAKE_DWORD(lowWord, highWord) ((dword(highWord)<<WORD_BITS) | (lowWord))
-
-static int Compare(const word *A, const word *B, unsigned int N)
-{
-	while (N--)
-		if (A[N] > B[N])
-			return 1;
-		else if (A[N] < B[N])
-			return -1;
-
-	return 0;
-}
-
-static word Increment(word *A, unsigned int N, word B=1)
-{
-	assert(N);
-	word t = A[0];
-	A[0] = t+B;
-	if (A[0] >= t)
-		return 0;
-	for (unsigned i=1; i<N; i++)
-		if (++A[i])
-			return 0;
-	return 1;
-}
-
-static word Decrement(word *A, unsigned int N, word B=1)
-{
-	assert(N);
-	word t = A[0];
-	A[0] = t-B;
-	if (A[0] <= t)
-		return 0;
-	for (unsigned i=1; i<N; i++)
-		if (A[i]--)
-			return 0;
-	return 1;
-}
-
-static void TwosComplement(word *A, unsigned int N)
-{
-	Decrement(A, N);
-	for (unsigned i=0; i<N; i++)
-		A[i] = ~A[i];
-}
-
-static word LinearMultiply(word *C, const word *A, word B, unsigned int N)
-{
-	word carry=0;
-	for(unsigned i=0; i<N; i++)
-	{
-		dword p = (dword)A[i] * B + carry;
-		C[i] = LOW_WORD(p);
-		carry = HIGH_WORD(p);
-	}
-	return carry;
-}
-
-static void AtomicInverseModPower2(word *C, word A0, word A1)
-{
-	assert(A0%2==1);
-
-	dword A=MAKE_DWORD(A0, A1), R=A0%8;
-
-	for (unsigned i=3; i<2*WORD_BITS; i*=2)
-		R = R*(2-R*A);
-
-	assert(R*A==1);
-
-	C[0] = LOW_WORD(R);
-	C[1] = HIGH_WORD(R);
-}
-
-// ********************************************************
-
-class Portable
-{
-public:
-	static word Add(word *C, const word *A, const word *B, unsigned int N);
-	static word Subtract(word *C, const word *A, const word *B, unsigned int N);
-
-	static inline void Multiply2(word *C, const word *A, const word *B);
-	static inline word Multiply2Add(word *C, const word *A, const word *B);
-	static void Multiply4(word *C, const word *A, const word *B);
-	static void Multiply8(word *C, const word *A, const word *B);
-	static inline unsigned int MultiplyRecursionLimit() {return 8;}
-
-	static inline void Multiply2Bottom(word *C, const word *A, const word *B);
-	static void Multiply4Bottom(word *C, const word *A, const word *B);
-	static void Multiply8Bottom(word *C, const word *A, const word *B);
-	static inline unsigned int MultiplyBottomRecursionLimit() {return 8;}
-
-	static void Square2(word *R, const word *A);
-	static void Square4(word *R, const word *A);
-	static void Square8(word *R, const word *A) {assert(false);}
-	static inline unsigned int SquareRecursionLimit() {return 4;}
-};
-
-word Portable::Add(word *C, const word *A, const word *B, unsigned int N)
-{
-	assert (N%2 == 0);
-
-#ifdef IS_LITTLE_ENDIAN
-	if (sizeof(dword) == sizeof(size_t))	// dword is only register size
-	{
-		dword carry = 0;
-		N >>= 1;
-		for (unsigned int i = 0; i < N; i++)
-		{
-			dword a = ((const dword *)A)[i] + carry;
-			dword c = a + ((const dword *)B)[i];
-			((dword *)C)[i] = c;
-			carry = (a < carry) | (c < a);
-		}
-		return (word)carry;
-	}
-	else
-#endif
-	{
-		word carry = 0;
-		for (unsigned int i = 0; i < N; i+=2)
-		{
-			dword u = (dword) carry + A[i] + B[i];
-			C[i] = LOW_WORD(u);
-			u = (dword) HIGH_WORD(u) + A[i+1] + B[i+1];
-			C[i+1] = LOW_WORD(u);
-			carry = HIGH_WORD(u);
-		}
-		return carry;
-	}
-}
-
-word Portable::Subtract(word *C, const word *A, const word *B, unsigned int N)
-{
-	assert (N%2 == 0);
-
-#ifdef IS_LITTLE_ENDIAN
-	if (sizeof(dword) == sizeof(size_t))	// dword is only register size
-	{
-		dword borrow = 0;
-		N >>= 1;
-		for (unsigned int i = 0; i < N; i++)
-		{
-			dword a = ((const dword *)A)[i];
-			dword b = a - borrow;
-			dword c = b - ((const dword *)B)[i];
-			((dword *)C)[i] = c;
-			borrow = (b > a) | (c > b);
-		}
-		return (word)borrow;
-	}
-	else
-#endif
-	{
-		word borrow=0;
-		for (unsigned i = 0; i < N; i+=2)
-		{
-			dword u = (dword) A[i] - B[i] - borrow;
-			C[i] = LOW_WORD(u);
-			u = (dword) A[i+1] - B[i+1] - (word)(0-HIGH_WORD(u));
-			C[i+1] = LOW_WORD(u);
-			borrow = 0-HIGH_WORD(u);
-		}
-		return borrow;
-	}
-}
-
-void Portable::Multiply2(word *C, const word *A, const word *B)
-{
-/*
-	word s;
-	dword d;
-
-	if (A1 >= A0)
-		if (B0 >= B1)
-		{
-			s = 0;
-			d = (dword)(A1-A0)*(B0-B1);
-		}
-		else
-		{
-			s = (A1-A0);
-			d = (dword)s*(word)(B0-B1);
-		}
-	else
-		if (B0 > B1)
-		{
-			s = (B0-B1);
-			d = (word)(A1-A0)*(dword)s;
-		}
-		else
-		{
-			s = 0;
-			d = (dword)(A0-A1)*(B1-B0);
-		}
-*/
-	// this segment is the branchless equivalent of above
-	word D[4] = {A[1]-A[0], A[0]-A[1], B[0]-B[1], B[1]-B[0]};
-	unsigned int ai = A[1] < A[0];
-	unsigned int bi = B[0] < B[1];
-	unsigned int di = ai & bi;
-	dword d = (dword)D[di]*D[di+2];
-	D[1] = D[3] = 0;
-	unsigned int si = ai + !bi;
-	word s = D[si];
-
-	dword A0B0 = (dword)A[0]*B[0];
-	C[0] = LOW_WORD(A0B0);
-
-	dword A1B1 = (dword)A[1]*B[1];
-	dword t = (dword) HIGH_WORD(A0B0) + LOW_WORD(A0B0) + LOW_WORD(d) + LOW_WORD(A1B1);
-	C[1] = LOW_WORD(t);
-
-	t = A1B1 + HIGH_WORD(t) + HIGH_WORD(A0B0) + HIGH_WORD(d) + HIGH_WORD(A1B1) - s;
-	C[2] = LOW_WORD(t);
-	C[3] = HIGH_WORD(t);
-}
-
-inline void Portable::Multiply2Bottom(word *C, const word *A, const word *B)
-{
-#ifdef IS_LITTLE_ENDIAN
-	if (sizeof(dword) == sizeof(size_t))
-	{
-		dword a = *(const dword *)A, b = *(const dword *)B;
-		((dword *)C)[0] = a*b;
-	}
-	else
-#endif
-	{
-		dword t = (dword)A[0]*B[0];
-		C[0] = LOW_WORD(t);
-		C[1] = HIGH_WORD(t) + A[0]*B[1] + A[1]*B[0];
-	}
-}
-
-word Portable::Multiply2Add(word *C, const word *A, const word *B)
-{
-	word D[4] = {A[1]-A[0], A[0]-A[1], B[0]-B[1], B[1]-B[0]};
-	unsigned int ai = A[1] < A[0];
-	unsigned int bi = B[0] < B[1];
-	unsigned int di = ai & bi;
-	dword d = (dword)D[di]*D[di+2];
-	D[1] = D[3] = 0;
-	unsigned int si = ai + !bi;
-	word s = D[si];
-
-	dword A0B0 = (dword)A[0]*B[0];
-	dword t = A0B0 + C[0];
-	C[0] = LOW_WORD(t);
-
-	dword A1B1 = (dword)A[1]*B[1];
-	t = (dword) HIGH_WORD(t) + LOW_WORD(A0B0) + LOW_WORD(d) + LOW_WORD(A1B1) + C[1];
-	C[1] = LOW_WORD(t);
-
-	t = (dword) HIGH_WORD(t) + LOW_WORD(A1B1) + HIGH_WORD(A0B0) + HIGH_WORD(d) + HIGH_WORD(A1B1) - s + C[2];
-	C[2] = LOW_WORD(t);
-
-	t = (dword) HIGH_WORD(t) + HIGH_WORD(A1B1) + C[3];
-	C[3] = LOW_WORD(t);
-	return HIGH_WORD(t);
-}
-
-#define MulAcc(x, y)								\
-	p = (dword)A[x] * B[y] + c; 					\
-	c = LOW_WORD(p);								\
-	p = (dword)d + HIGH_WORD(p);					\
-	d = LOW_WORD(p);								\
-	e += HIGH_WORD(p);
-
-#define SaveMulAcc(s, x, y) 						\
-	R[s] = c;										\
-	p = (dword)A[x] * B[y] + d; 					\
-	c = LOW_WORD(p);								\
-	p = (dword)e + HIGH_WORD(p);					\
-	d = LOW_WORD(p);								\
-	e = HIGH_WORD(p);
-
-#define SquAcc(x, y)								\
-	q = (dword)A[x] * A[y];	\
-	p = q + c; 					\
-	c = LOW_WORD(p);								\
-	p = (dword)d + HIGH_WORD(p);					\
-	d = LOW_WORD(p);								\
-	e += HIGH_WORD(p);			\
-	p = q + c; 					\
-	c = LOW_WORD(p);								\
-	p = (dword)d + HIGH_WORD(p);					\
-	d = LOW_WORD(p);								\
-	e += HIGH_WORD(p);
-
-#define SaveSquAcc(s, x, y) 						\
-	R[s] = c;										\
-	q = (dword)A[x] * A[y];	\
-	p = q + d; 					\
-	c = LOW_WORD(p);								\
-	p = (dword)e + HIGH_WORD(p);					\
-	d = LOW_WORD(p);								\
-	e = HIGH_WORD(p);			\
-	p = q + c; 					\
-	c = LOW_WORD(p);								\
-	p = (dword)d + HIGH_WORD(p);					\
-	d = LOW_WORD(p);								\
-	e += HIGH_WORD(p);
-
-void Portable::Multiply4(word *R, const word *A, const word *B)
-{
-	dword p;
-	word c, d, e;
-
-	p = (dword)A[0] * B[0];
-	R[0] = LOW_WORD(p);
-	c = HIGH_WORD(p);
-	d = e = 0;
-
-	MulAcc(0, 1);
-	MulAcc(1, 0);
-
-	SaveMulAcc(1, 2, 0);
-	MulAcc(1, 1);
-	MulAcc(0, 2);
-
-	SaveMulAcc(2, 0, 3);
-	MulAcc(1, 2);
-	MulAcc(2, 1);
-	MulAcc(3, 0);
-
-	SaveMulAcc(3, 3, 1);
-	MulAcc(2, 2);
-	MulAcc(1, 3);
-
-	SaveMulAcc(4, 2, 3);
-	MulAcc(3, 2);
-
-	R[5] = c;
-	p = (dword)A[3] * B[3] + d;
-	R[6] = LOW_WORD(p);
-	R[7] = e + HIGH_WORD(p);
-}
-
-void Portable::Square2(word *R, const word *A)
-{
-	dword p, q;
-	word c, d, e;
-
-	p = (dword)A[0] * A[0];
-	R[0] = LOW_WORD(p);
-	c = HIGH_WORD(p);
-	d = e = 0;
-
-	SquAcc(0, 1);
-
-	R[1] = c;
-	p = (dword)A[1] * A[1] + d;
-	R[2] = LOW_WORD(p);
-	R[3] = e + HIGH_WORD(p);
-}
-
-void Portable::Square4(word *R, const word *A)
-{
-	const word *B = A;
-	dword p, q;
-	word c, d, e;
-
-	p = (dword)A[0] * A[0];
-	R[0] = LOW_WORD(p);
-	c = HIGH_WORD(p);
-	d = e = 0;
-
-	SquAcc(0, 1);
-
-	SaveSquAcc(1, 2, 0);
-	MulAcc(1, 1);
-
-	SaveSquAcc(2, 0, 3);
-	SquAcc(1, 2);
-
-	SaveSquAcc(3, 3, 1);
-	MulAcc(2, 2);
-
-	SaveSquAcc(4, 2, 3);
-
-	R[5] = c;
-	p = (dword)A[3] * A[3] + d;
-	R[6] = LOW_WORD(p);
-	R[7] = e + HIGH_WORD(p);
-}
-
-void Portable::Multiply8(word *R, const word *A, const word *B)
-{
-	dword p;
-	word c, d, e;
-
-	p = (dword)A[0] * B[0];
-	R[0] = LOW_WORD(p);
-	c = HIGH_WORD(p);
-	d = e = 0;
-
-	MulAcc(0, 1);
-	MulAcc(1, 0);
-
-	SaveMulAcc(1, 2, 0);
-	MulAcc(1, 1);
-	MulAcc(0, 2);
-
-	SaveMulAcc(2, 0, 3);
-	MulAcc(1, 2);
-	MulAcc(2, 1);
-	MulAcc(3, 0);
-
-	SaveMulAcc(3, 0, 4);
-	MulAcc(1, 3);
-	MulAcc(2, 2);
-	MulAcc(3, 1);
-	MulAcc(4, 0);
-
-	SaveMulAcc(4, 0, 5);
-	MulAcc(1, 4);
-	MulAcc(2, 3);
-	MulAcc(3, 2);
-	MulAcc(4, 1);
-	MulAcc(5, 0);
-
-	SaveMulAcc(5, 0, 6);
-	MulAcc(1, 5);
-	MulAcc(2, 4);
-	MulAcc(3, 3);
-	MulAcc(4, 2);
-	MulAcc(5, 1);
-	MulAcc(6, 0);
-
-	SaveMulAcc(6, 0, 7);
-	MulAcc(1, 6);
-	MulAcc(2, 5);
-	MulAcc(3, 4);
-	MulAcc(4, 3);
-	MulAcc(5, 2);
-	MulAcc(6, 1);
-	MulAcc(7, 0);
-
-	SaveMulAcc(7, 1, 7);
-	MulAcc(2, 6);
-	MulAcc(3, 5);
-	MulAcc(4, 4);
-	MulAcc(5, 3);
-	MulAcc(6, 2);
-	MulAcc(7, 1);
-
-	SaveMulAcc(8, 2, 7);
-	MulAcc(3, 6);
-	MulAcc(4, 5);
-	MulAcc(5, 4);
-	MulAcc(6, 3);
-	MulAcc(7, 2);
-
-	SaveMulAcc(9, 3, 7);
-	MulAcc(4, 6);
-	MulAcc(5, 5);
-	MulAcc(6, 4);
-	MulAcc(7, 3);
-
-	SaveMulAcc(10, 4, 7);
-	MulAcc(5, 6);
-	MulAcc(6, 5);
-	MulAcc(7, 4);
-
-	SaveMulAcc(11, 5, 7);
-	MulAcc(6, 6);
-	MulAcc(7, 5);
-
-	SaveMulAcc(12, 6, 7);
-	MulAcc(7, 6);
-
-	R[13] = c;
-	p = (dword)A[7] * B[7] + d;
-	R[14] = LOW_WORD(p);
-	R[15] = e + HIGH_WORD(p);
-}
-
-void Portable::Multiply4Bottom(word *R, const word *A, const word *B)
-{
-	dword p;
-	word c, d, e;
-
-	p = (dword)A[0] * B[0];
-	R[0] = LOW_WORD(p);
-	c = HIGH_WORD(p);
-	d = e = 0;
-
-	MulAcc(0, 1);
-	MulAcc(1, 0);
-
-	SaveMulAcc(1, 2, 0);
-	MulAcc(1, 1);
-	MulAcc(0, 2);
-
-	R[2] = c;
-	R[3] = d + A[0] * B[3] + A[1] * B[2] + A[2] * B[1] + A[3] * B[0];
-}
-
-void Portable::Multiply8Bottom(word *R, const word *A, const word *B)
-{
-	dword p;
-	word c, d, e;
-
-	p = (dword)A[0] * B[0];
-	R[0] = LOW_WORD(p);
-	c = HIGH_WORD(p);
-	d = e = 0;
-
-	MulAcc(0, 1);
-	MulAcc(1, 0);
-
-	SaveMulAcc(1, 2, 0);
-	MulAcc(1, 1);
-	MulAcc(0, 2);
-
-	SaveMulAcc(2, 0, 3);
-	MulAcc(1, 2);
-	MulAcc(2, 1);
-	MulAcc(3, 0);
-
-	SaveMulAcc(3, 0, 4);
-	MulAcc(1, 3);
-	MulAcc(2, 2);
-	MulAcc(3, 1);
-	MulAcc(4, 0);
-
-	SaveMulAcc(4, 0, 5);
-	MulAcc(1, 4);
-	MulAcc(2, 3);
-	MulAcc(3, 2);
-	MulAcc(4, 1);
-	MulAcc(5, 0);
-
-	SaveMulAcc(5, 0, 6);
-	MulAcc(1, 5);
-	MulAcc(2, 4);
-	MulAcc(3, 3);
-	MulAcc(4, 2);
-	MulAcc(5, 1);
-	MulAcc(6, 0);
-
-	R[6] = c;
-	R[7] = d + A[0] * B[7] + A[1] * B[6] + A[2] * B[5] + A[3] * B[4] +
-				A[4] * B[3] + A[5] * B[2] + A[6] * B[1] + A[7] * B[0];
-}
-
-#undef MulAcc
-#undef SaveMulAcc
-#undef SquAcc
-#undef SaveSquAcc
-
-// CodeWarrior defines _MSC_VER
-#if defined(_MSC_VER) && !defined(__MWERKS__) && defined(_M_IX86) && (_M_IX86<=700)
-
-class PentiumOptimized : public Portable
-{
-public:
-	static word __fastcall Add(word *C, const word *A, const word *B, unsigned int N);
-	static word __fastcall Subtract(word *C, const word *A, const word *B, unsigned int N);
-	static inline void Square4(word *R, const word *A)
-	{
-		// VC60 workaround: MSVC 6.0 has an optimization bug that makes
-		// (dword)A*B where either A or B has been cast to a dword before
-		// very expensive. Revisit this function when this
-		// bug is fixed.
-		Multiply4(R, A, A);
-	}
-};
-
-typedef PentiumOptimized LowLevel;
-
-__declspec(naked) word __fastcall PentiumOptimized::Add(word *C, const word *A, const word *B, unsigned int N)
-{
-	__asm
-	{
-		push ebp
-		push ebx
-		push esi
-		push edi
-
-		mov esi, [esp+24]	; N
-		mov ebx, [esp+20]	; B
-
-		// now: ebx = B, ecx = C, edx = A, esi = N
-
-		sub ecx, edx	// hold the distance between C & A so we can add this to A to get C
-		xor eax, eax	// clear eax
-
-		sub eax, esi	// eax is a negative index from end of B
-		lea ebx, [ebx+4*esi]	// ebx is end of B
-
-		sar eax, 1		// unit of eax is now dwords; this also clears the carry flag
-		jz	loopend		// if no dwords then nothing to do
-
-loopstart:
-		mov    esi,[edx]			// load lower word of A
-		mov    ebp,[edx+4]			// load higher word of A
-
-		mov    edi,[ebx+8*eax]		// load lower word of B
-		lea    edx,[edx+8]			// advance A and C
-
-		adc    esi,edi				// add lower words
-		mov    edi,[ebx+8*eax+4]	// load higher word of B
-
-		adc    ebp,edi				// add higher words
-		inc    eax					// advance B
-
-		mov    [edx+ecx-8],esi		// store lower word result
-		mov    [edx+ecx-4],ebp		// store higher word result
-
-		jnz    loopstart			// loop until eax overflows and becomes zero
-
-loopend:
-		adc eax, 0		// store carry into eax (return result register)
-		pop edi
-		pop esi
-		pop ebx
-		pop ebp
-		ret 8
-	}
-}
-
-__declspec(naked) word __fastcall PentiumOptimized::Subtract(word *C, const word *A, const word *B, unsigned int N)
-{
-	__asm
-	{
-		push ebp
-		push ebx
-		push esi
-		push edi
-
-		mov esi, [esp+24]	; N
-		mov ebx, [esp+20]	; B
-
-		sub ecx, edx
-		xor eax, eax
-
-		sub eax, esi
-		lea ebx, [ebx+4*esi]
-
-		sar eax, 1
-		jz	loopend
-
-loopstart:
-		mov    esi,[edx]
-		mov    ebp,[edx+4]
-
-		mov    edi,[ebx+8*eax]
-		lea    edx,[edx+8]
-
-		sbb    esi,edi
-		mov    edi,[ebx+8*eax+4]
-
-		sbb    ebp,edi
-		inc    eax
-
-		mov    [edx+ecx-8],esi
-		mov    [edx+ecx-4],ebp
-
-		jnz    loopstart
-
-loopend:
-		adc eax, 0
-		pop edi
-		pop esi
-		pop ebx
-		pop ebp
-		ret 8
-	}
-}
-
-#ifdef SSE2_INTRINSICS_AVAILABLE
-
-static bool GetSSE2Capability()
-{
-	word32 b;
-
-	__asm
-	{
-		mov		eax, 1
-		cpuid
-		mov		b, edx
-	}
-
-	return (b & (1 << 26)) != 0;
-}
-
-bool g_sse2DetectionDone = false, g_sse2Detected, g_sse2Enabled = true;
-
-static inline bool HasSSE2()
-{
-	if (g_sse2Enabled && !g_sse2DetectionDone)
-	{
-		g_sse2Detected = GetSSE2Capability();
-		g_sse2DetectionDone = true;
-	}
-	return g_sse2Enabled && g_sse2Detected;
-}
-
-class P4Optimized : public PentiumOptimized
-{
-public:
-	static word __fastcall Add(word *C, const word *A, const word *B, unsigned int N);
-	static word __fastcall Subtract(word *C, const word *A, const word *B, unsigned int N);
-	static void Multiply4(word *C, const word *A, const word *B);
-	static void Multiply8(word *C, const word *A, const word *B);
-	static inline void Square4(word *R, const word *A)
-	{
-		Multiply4(R, A, A);
-	}
-	static void Multiply8Bottom(word *C, const word *A, const word *B);
-};
-
-static void __fastcall P4_Mul(__m128i *C, const __m128i *A, const __m128i *B)
-{
-	__m128i a3210 = _mm_load_si128(A);
-	__m128i b3210 = _mm_load_si128(B);
-
-	__m128i sum;
-
-	__m128i z = _mm_setzero_si128();
-	__m128i a2b2_a0b0 = _mm_mul_epu32(a3210, b3210);
-	C[0] = a2b2_a0b0;
-
-	__m128i a3120 = _mm_shuffle_epi32(a3210, _MM_SHUFFLE(3, 1, 2, 0));
-	__m128i b3021 = _mm_shuffle_epi32(b3210, _MM_SHUFFLE(3, 0, 2, 1));
-	__m128i a1b0_a0b1 = _mm_mul_epu32(a3120, b3021);
-	__m128i a1b0 = _mm_unpackhi_epi32(a1b0_a0b1, z);
-	__m128i a0b1 = _mm_unpacklo_epi32(a1b0_a0b1, z);
-	C[1] = _mm_add_epi64(a1b0, a0b1);
-
-	__m128i a31 = _mm_srli_epi64(a3210, 32);
-	__m128i b31 = _mm_srli_epi64(b3210, 32);
-	__m128i a3b3_a1b1 = _mm_mul_epu32(a31, b31);
-	C[6] = a3b3_a1b1;
-
-	__m128i a1b1 = _mm_unpacklo_epi32(a3b3_a1b1, z);
-	__m128i b3012 = _mm_shuffle_epi32(b3210, _MM_SHUFFLE(3, 0, 1, 2));
-	__m128i a2b0_a0b2 = _mm_mul_epu32(a3210, b3012);
-	__m128i a0b2 = _mm_unpacklo_epi32(a2b0_a0b2, z);
-	__m128i a2b0 = _mm_unpackhi_epi32(a2b0_a0b2, z);
-	sum = _mm_add_epi64(a1b1, a0b2);
-	C[2] = _mm_add_epi64(sum, a2b0);
-
-	__m128i a2301 = _mm_shuffle_epi32(a3210, _MM_SHUFFLE(2, 3, 0, 1));
-	__m128i b2103 = _mm_shuffle_epi32(b3210, _MM_SHUFFLE(2, 1, 0, 3));
-	__m128i a3b0_a1b2 = _mm_mul_epu32(a2301, b3012);
-	__m128i a2b1_a0b3 = _mm_mul_epu32(a3210, b2103);
-	__m128i a3b0 = _mm_unpackhi_epi32(a3b0_a1b2, z);
-	__m128i a1b2 = _mm_unpacklo_epi32(a3b0_a1b2, z);
-	__m128i a2b1 = _mm_unpackhi_epi32(a2b1_a0b3, z);
-	__m128i a0b3 = _mm_unpacklo_epi32(a2b1_a0b3, z);
-	__m128i sum1 = _mm_add_epi64(a3b0, a1b2);
-	sum = _mm_add_epi64(a2b1, a0b3);
-	C[3] = _mm_add_epi64(sum, sum1);
-
-	__m128i	a3b1_a1b3 = _mm_mul_epu32(a2301, b2103);
-	__m128i a2b2 = _mm_unpackhi_epi32(a2b2_a0b0, z);
-	__m128i a3b1 = _mm_unpackhi_epi32(a3b1_a1b3, z);
-	__m128i a1b3 = _mm_unpacklo_epi32(a3b1_a1b3, z);
-	sum = _mm_add_epi64(a2b2, a3b1);
-	C[4] = _mm_add_epi64(sum, a1b3);
-
-	__m128i a1302 = _mm_shuffle_epi32(a3210, _MM_SHUFFLE(1, 3, 0, 2));
-	__m128i b1203 = _mm_shuffle_epi32(b3210, _MM_SHUFFLE(1, 2, 0, 3));
-	__m128i a3b2_a2b3 = _mm_mul_epu32(a1302, b1203);
-	__m128i a3b2 = _mm_unpackhi_epi32(a3b2_a2b3, z);
-	__m128i a2b3 = _mm_unpacklo_epi32(a3b2_a2b3, z);
-	C[5] = _mm_add_epi64(a3b2, a2b3);
-}
-
-void P4Optimized::Multiply4(word *C, const word *A, const word *B)
-{
-	__m128i temp[7];
-	const word *w = (word *)temp;
-	const __m64 *mw = (__m64 *)w;
-
-	P4_Mul(temp, (__m128i *)A, (__m128i *)B);
-
-	C[0] = w[0];
-
-	__m64 s1, s2;
-
-	__m64 w1 = _m_from_int(w[1]);
-	__m64 w4 = mw[2];
-	__m64 w6 = mw[3];
-	__m64 w8 = mw[4];
-	__m64 w10 = mw[5];
-	__m64 w12 = mw[6];
-	__m64 w14 = mw[7];
-	__m64 w16 = mw[8];
-	__m64 w18 = mw[9];
-	__m64 w20 = mw[10];
-	__m64 w22 = mw[11];
-	__m64 w26 = _m_from_int(w[26]);
-
-	s1 = _mm_add_si64(w1, w4);
-	C[1] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	s2 = _mm_add_si64(w6, w8);
-	s1 = _mm_add_si64(s1, s2);
-	C[2] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	s2 = _mm_add_si64(w10, w12);
-	s1 = _mm_add_si64(s1, s2);
-	C[3] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	s2 = _mm_add_si64(w14, w16);
-	s1 = _mm_add_si64(s1, s2);
-	C[4] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	s2 = _mm_add_si64(w18, w20);
-	s1 = _mm_add_si64(s1, s2);
-	C[5] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	s2 = _mm_add_si64(w22, w26);
-	s1 = _mm_add_si64(s1, s2);
-	C[6] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	C[7] = _m_to_int(s1) + w[27];
-	_mm_empty();
-}
-
-void P4Optimized::Multiply8(word *C, const word *A, const word *B)
-{
-	__m128i temp[28];
-	const word *w = (word *)temp;
-	const __m64 *mw = (__m64 *)w;
-	const word *x = (word *)temp+7*4;
-	const __m64 *mx = (__m64 *)x;
-	const word *y = (word *)temp+7*4*2;
-	const __m64 *my = (__m64 *)y;
-	const word *z = (word *)temp+7*4*3;
-	const __m64 *mz = (__m64 *)z;
-
-	P4_Mul(temp, (__m128i *)A, (__m128i *)B);
-
-	P4_Mul(temp+7, (__m128i *)A+1, (__m128i *)B);
-
-	P4_Mul(temp+14, (__m128i *)A, (__m128i *)B+1);
-
-	P4_Mul(temp+21, (__m128i *)A+1, (__m128i *)B+1);
-
-	C[0] = w[0];
-
-	__m64 s1, s2, s3, s4;
-
-	__m64 w1 = _m_from_int(w[1]);
-	__m64 w4 = mw[2];
-	__m64 w6 = mw[3];
-	__m64 w8 = mw[4];
-	__m64 w10 = mw[5];
-	__m64 w12 = mw[6];
-	__m64 w14 = mw[7];
-	__m64 w16 = mw[8];
-	__m64 w18 = mw[9];
-	__m64 w20 = mw[10];
-	__m64 w22 = mw[11];
-	__m64 w26 = _m_from_int(w[26]);
-	__m64 w27 = _m_from_int(w[27]);
-
-	__m64 x0 = _m_from_int(x[0]);
-	__m64 x1 = _m_from_int(x[1]);
-	__m64 x4 = mx[2];
-	__m64 x6 = mx[3];
-	__m64 x8 = mx[4];
-	__m64 x10 = mx[5];
-	__m64 x12 = mx[6];
-	__m64 x14 = mx[7];
-	__m64 x16 = mx[8];
-	__m64 x18 = mx[9];
-	__m64 x20 = mx[10];
-	__m64 x22 = mx[11];
-	__m64 x26 = _m_from_int(x[26]);
-	__m64 x27 = _m_from_int(x[27]);
-
-	__m64 y0 = _m_from_int(y[0]);
-	__m64 y1 = _m_from_int(y[1]);
-	__m64 y4 = my[2];
-	__m64 y6 = my[3];
-	__m64 y8 = my[4];
-	__m64 y10 = my[5];
-	__m64 y12 = my[6];
-	__m64 y14 = my[7];
-	__m64 y16 = my[8];
-	__m64 y18 = my[9];
-	__m64 y20 = my[10];
-	__m64 y22 = my[11];
-	__m64 y26 = _m_from_int(y[26]);
-	__m64 y27 = _m_from_int(y[27]);
-
-	__m64 z0 = _m_from_int(z[0]);
-	__m64 z1 = _m_from_int(z[1]);
-	__m64 z4 = mz[2];
-	__m64 z6 = mz[3];
-	__m64 z8 = mz[4];
-	__m64 z10 = mz[5];
-	__m64 z12 = mz[6];
-	__m64 z14 = mz[7];
-	__m64 z16 = mz[8];
-	__m64 z18 = mz[9];
-	__m64 z20 = mz[10];
-	__m64 z22 = mz[11];
-	__m64 z26 = _m_from_int(z[26]);
-
-	s1 = _mm_add_si64(w1, w4);
-	C[1] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	s2 = _mm_add_si64(w6, w8);
-	s1 = _mm_add_si64(s1, s2);
-	C[2] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	s2 = _mm_add_si64(w10, w12);
-	s1 = _mm_add_si64(s1, s2);
-	C[3] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	s3 = _mm_add_si64(x0, y0);
-	s2 = _mm_add_si64(w14, w16);
-	s1 = _mm_add_si64(s1, s3);
-	s1 = _mm_add_si64(s1, s2);
-	C[4] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	s3 = _mm_add_si64(x1, y1);
-	s4 = _mm_add_si64(x4, y4);
-	s1 = _mm_add_si64(s1, w18);
-	s3 = _mm_add_si64(s3, s4);
-	s1 = _mm_add_si64(s1, w20);
-	s1 = _mm_add_si64(s1, s3);
-	C[5] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	s3 = _mm_add_si64(x6, y6);
-	s4 = _mm_add_si64(x8, y8);
-	s1 = _mm_add_si64(s1, w22);
-	s3 = _mm_add_si64(s3, s4);
-	s1 = _mm_add_si64(s1, w26);
-	s1 = _mm_add_si64(s1, s3);
-	C[6] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	s3 = _mm_add_si64(x10, y10);
-	s4 = _mm_add_si64(x12, y12);
-	s1 = _mm_add_si64(s1, w27);
-	s3 = _mm_add_si64(s3, s4);
-	s1 = _mm_add_si64(s1, s3);
-	C[7] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	s3 = _mm_add_si64(x14, y14);
-	s4 = _mm_add_si64(x16, y16);
-	s1 = _mm_add_si64(s1, z0);
-	s3 = _mm_add_si64(s3, s4);
-	s1 = _mm_add_si64(s1, s3);
-	C[8] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	s3 = _mm_add_si64(x18, y18);
-	s4 = _mm_add_si64(x20, y20);
-	s1 = _mm_add_si64(s1, z1);
-	s3 = _mm_add_si64(s3, s4);
-	s1 = _mm_add_si64(s1, z4);
-	s1 = _mm_add_si64(s1, s3);
-	C[9] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	s3 = _mm_add_si64(x22, y22);
-	s4 = _mm_add_si64(x26, y26);
-	s1 = _mm_add_si64(s1, z6);
-	s3 = _mm_add_si64(s3, s4);
-	s1 = _mm_add_si64(s1, z8);
-	s1 = _mm_add_si64(s1, s3);
-	C[10] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	s3 = _mm_add_si64(x27, y27);
-	s1 = _mm_add_si64(s1, z10);
-	s1 = _mm_add_si64(s1, z12);
-	s1 = _mm_add_si64(s1, s3);
-	C[11] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	s3 = _mm_add_si64(z14, z16);
-	s1 = _mm_add_si64(s1, s3);
-	C[12] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	s3 = _mm_add_si64(z18, z20);
-	s1 = _mm_add_si64(s1, s3);
-	C[13] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	s3 = _mm_add_si64(z22, z26);
-	s1 = _mm_add_si64(s1, s3);
-	C[14] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	C[15] = z[27] + _m_to_int(s1);
-	_mm_empty();
-}
-
-void P4Optimized::Multiply8Bottom(word *C, const word *A, const word *B)
-{
-	__m128i temp[21];
-	const word *w = (word *)temp;
-	const __m64 *mw = (__m64 *)w;
-	const word *x = (word *)temp+7*4;
-	const __m64 *mx = (__m64 *)x;
-	const word *y = (word *)temp+7*4*2;
-	const __m64 *my = (__m64 *)y;
-
-	P4_Mul(temp, (__m128i *)A, (__m128i *)B);
-
-	P4_Mul(temp+7, (__m128i *)A+1, (__m128i *)B);
-
-	P4_Mul(temp+14, (__m128i *)A, (__m128i *)B+1);
-
-	C[0] = w[0];
-
-	__m64 s1, s2, s3, s4;
-
-	__m64 w1 = _m_from_int(w[1]);
-	__m64 w4 = mw[2];
-	__m64 w6 = mw[3];
-	__m64 w8 = mw[4];
-	__m64 w10 = mw[5];
-	__m64 w12 = mw[6];
-	__m64 w14 = mw[7];
-	__m64 w16 = mw[8];
-	__m64 w18 = mw[9];
-	__m64 w20 = mw[10];
-	__m64 w22 = mw[11];
-	__m64 w26 = _m_from_int(w[26]);
-
-	__m64 x0 = _m_from_int(x[0]);
-	__m64 x1 = _m_from_int(x[1]);
-	__m64 x4 = mx[2];
-	__m64 x6 = mx[3];
-	__m64 x8 = mx[4];
-
-	__m64 y0 = _m_from_int(y[0]);
-	__m64 y1 = _m_from_int(y[1]);
-	__m64 y4 = my[2];
-	__m64 y6 = my[3];
-	__m64 y8 = my[4];
-
-	s1 = _mm_add_si64(w1, w4);
-	C[1] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	s2 = _mm_add_si64(w6, w8);
-	s1 = _mm_add_si64(s1, s2);
-	C[2] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	s2 = _mm_add_si64(w10, w12);
-	s1 = _mm_add_si64(s1, s2);
-	C[3] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	s3 = _mm_add_si64(x0, y0);
-	s2 = _mm_add_si64(w14, w16);
-	s1 = _mm_add_si64(s1, s3);
-	s1 = _mm_add_si64(s1, s2);
-	C[4] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	s3 = _mm_add_si64(x1, y1);
-	s4 = _mm_add_si64(x4, y4);
-	s1 = _mm_add_si64(s1, w18);
-	s3 = _mm_add_si64(s3, s4);
-	s1 = _mm_add_si64(s1, w20);
-	s1 = _mm_add_si64(s1, s3);
-	C[5] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	s3 = _mm_add_si64(x6, y6);
-	s4 = _mm_add_si64(x8, y8);
-	s1 = _mm_add_si64(s1, w22);
-	s3 = _mm_add_si64(s3, s4);
-	s1 = _mm_add_si64(s1, w26);
-	s1 = _mm_add_si64(s1, s3);
-	C[6] = _m_to_int(s1);
-	s1 = _m_psrlqi(s1, 32);
-
-	C[7] = _m_to_int(s1) + w[27] + x[10] + y[10] + x[12] + y[12];
-	_mm_empty();
-}
-
-__declspec(naked) word __fastcall P4Optimized::Add(word *C, const word *A, const word *B, unsigned int N)
-{
-	__asm
-	{
-		sub		esp, 16
-		xor		eax, eax
-		mov		[esp], edi
-		mov		[esp+4], esi
-		mov		[esp+8], ebx
-		mov		[esp+12], ebp
-
-		mov		ebx, [esp+20]	// B
-		mov		esi, [esp+24]	// N
-
-		// now: ebx = B, ecx = C, edx = A, esi = N
-
-		neg		esi
-		jz		loopend		// if no dwords then nothing to do
-
-		mov		edi, [edx]
-		mov		ebp, [ebx]
-
-loopstart:
-		add		edi, eax
-		jc		carry1
-
-		xor		eax, eax
-
-carry1continue:
-		add		edi, ebp
-		mov		ebp, 1
-		mov		[ecx], edi
-		mov		edi, [edx+4]
-		cmovc	eax, ebp
-		mov		ebp, [ebx+4]
-		lea		ebx, [ebx+8]
-		add		edi, eax
-		jc		carry2
-
-		xor		eax, eax
-
-carry2continue:
-		add		edi, ebp
-		mov		ebp, 1
-		cmovc	eax, ebp
-		mov		[ecx+4], edi
-		add		ecx, 8
-		mov		edi, [edx+8]
-		add		edx, 8
-		add		esi, 2
-		mov		ebp, [ebx]
-		jnz		loopstart
-
-loopend:
-		mov		edi, [esp]
-		mov		esi, [esp+4]
-		mov		ebx, [esp+8]
-		mov		ebp, [esp+12]
-		add		esp, 16
-		ret		8
-
-carry1:
-		mov		eax, 1
-		jmp		carry1continue
-
-carry2:
-		mov		eax, 1
-		jmp		carry2continue
-	}
-}
-
-__declspec(naked) word __fastcall P4Optimized::Subtract(word *C, const word *A, const word *B, unsigned int N)
-{
-	__asm
-	{
-		sub		esp, 16
-		xor		eax, eax
-		mov		[esp], edi
-		mov		[esp+4], esi
-		mov		[esp+8], ebx
-		mov		[esp+12], ebp
-
-		mov		ebx, [esp+20]	// B
-		mov		esi, [esp+24]	// N
-
-		// now: ebx = B, ecx = C, edx = A, esi = N
-
-		neg		esi
-		jz		loopend		// if no dwords then nothing to do
-
-		mov		edi, [edx]
-		mov		ebp, [ebx]
-
-loopstart:
-		sub		edi, eax
-		jc		carry1
-
-		xor		eax, eax
-
-carry1continue:
-		sub		edi, ebp
-		mov		ebp, 1
-		mov		[ecx], edi
-		mov		edi, [edx+4]
-		cmovc	eax, ebp
-		mov		ebp, [ebx+4]
-		lea		ebx, [ebx+8]
-		sub		edi, eax
-		jc		carry2
-
-		xor		eax, eax
-
-carry2continue:
-		sub		edi, ebp
-		mov		ebp, 1
-		cmovc	eax, ebp
-		mov		[ecx+4], edi
-		add		ecx, 8
-		mov		edi, [edx+8]
-		add		edx, 8
-		add		esi, 2
-		mov		ebp, [ebx]
-		jnz		loopstart
-
-loopend:
-		mov		edi, [esp]
-		mov		esi, [esp+4]
-		mov		ebx, [esp+8]
-		mov		ebp, [esp+12]
-		add		esp, 16
-		ret		8
-
-carry1:
-		mov		eax, 1
-		jmp		carry1continue
-
-carry2:
-		mov		eax, 1
-		jmp		carry2continue
-	}
-}
-
-#endif	// #ifdef SSE2_INTRINSICS_AVAILABLE
-
-#elif defined(__GNUC__) && defined(__i386__)
-
-class PentiumOptimized : public Portable
-{
-public:
-#ifndef __pic__		// -fpic uses up a register, leaving too few for the asm code
-	static word Add(word *C, const word *A, const word *B, unsigned int N);
-	static word Subtract(word *C, const word *A, const word *B, unsigned int N);
-#endif
-	static void Square4(word *R, const word *A);
-	static void Multiply4(word *C, const word *A, const word *B);
-	static void Multiply8(word *C, const word *A, const word *B);
-};
-
-typedef PentiumOptimized LowLevel;
-
-// Add and Subtract assembly code originally contributed by Alister Lee
-
-#ifndef __pic__
-__attribute__((regparm(3))) word PentiumOptimized::Add(word *C, const word *A, const word *B, unsigned int N)
-{
-	assert (N%2 == 0);
-
-	register word carry, temp;
-
-	__asm__ __volatile__(
-			"push %%ebp;"
-			"sub %3, %2;"
-			"xor %0, %0;"
-			"sub %4, %0;"
-			"lea (%1,%4,4), %1;"
-			"sar $1, %0;"
-			"jz 1f;"
-
-		"0:;"
-			"mov 0(%3), %4;"
-			"mov 4(%3), %%ebp;"
-			"mov (%1,%0,8), %5;"
-			"lea 8(%3), %3;"
-			"adc %5, %4;"
-			"mov 4(%1,%0,8), %5;"
-			"adc %5, %%ebp;"
-			"inc %0;"
-			"mov %4, -8(%3, %2);"
-			"mov %%ebp, -4(%3, %2);"
-			"jnz 0b;"
-
-		"1:;"
-			"adc $0, %0;"
-			"pop %%ebp;"
-
-		: "=aSD" (carry), "+r" (B), "+r" (C), "+r" (A), "+r" (N), "=r" (temp)
-		: : "cc", "memory");
-
-	return carry;
-}
-
-__attribute__((regparm(3))) word PentiumOptimized::Subtract(word *C, const word *A, const word *B, unsigned int N)
-{
-	assert (N%2 == 0);
-
-	register word carry, temp;
-
-	__asm__ __volatile__(
-			"push %%ebp;"
-			"sub %3, %2;"
-			"xor %0, %0;"
-			"sub %4, %0;"
-			"lea (%1,%4,4), %1;"
-			"sar $1, %0;"
-			"jz 1f;"
-
-		"0:;"
-			"mov 0(%3), %4;"
-			"mov 4(%3), %%ebp;"
-			"mov (%1,%0,8), %5;"
-			"lea 8(%3), %3;"
-			"sbb %5, %4;"
-			"mov 4(%1,%0,8), %5;"
-			"sbb %5, %%ebp;"
-			"inc %0;"
-			"mov %4, -8(%3, %2);"
-			"mov %%ebp, -4(%3, %2);"
-			"jnz 0b;"
-
-		"1:;"
-			"adc $0, %0;"
-			"pop %%ebp;"
-
-		: "=aSD" (carry), "+r" (B), "+r" (C), "+r" (A), "+r" (N), "=r" (temp)
-		: : "cc", "memory");
-
-	return carry;
-}
-#endif	// __pic__
-
-// Comba square and multiply assembly code originally contributed by Leonard Janke
-
-#define SqrStartup \
-  "push %%ebp\n\t" \
-  "push %%esi\n\t" \
-  "push %%ebx\n\t" \
-  "xor %%ebp, %%ebp\n\t" \
-  "xor %%ebx, %%ebx\n\t" \
-  "xor %%ecx, %%ecx\n\t" 
-
-#define SqrShiftCarry \
-  "mov %%ebx, %%ebp\n\t" \
-  "mov %%ecx, %%ebx\n\t" \
-  "xor %%ecx, %%ecx\n\t"
-
-#define SqrAccumulate(i,j) \
-  "mov 4*"#j"(%%esi), %%eax\n\t" \
-  "mull 4*"#i"(%%esi)\n\t" \
-  "add %%eax, %%ebp\n\t" \
-  "adc %%edx, %%ebx\n\t" \
-  "adc %%ch, %%cl\n\t" \
-  "add %%eax, %%ebp\n\t" \
-  "adc %%edx, %%ebx\n\t" \
-  "adc %%ch, %%cl\n\t"
-
-#define SqrAccumulateCentre(i) \
-  "mov 4*"#i"(%%esi), %%eax\n\t" \
-  "mull 4*"#i"(%%esi)\n\t" \
-  "add %%eax, %%ebp\n\t" \
-  "adc %%edx, %%ebx\n\t" \
-  "adc %%ch, %%cl\n\t" 
-
-#define SqrStoreDigit(X)  \
-  "mov %%ebp, 4*"#X"(%%edi)\n\t" \
-
-#define SqrLastDiagonal(digits) \
-  "mov 4*("#digits"-1)(%%esi), %%eax\n\t" \
-  "mull 4*("#digits"-1)(%%esi)\n\t" \
-  "add %%eax, %%ebp\n\t" \
-  "adc %%edx, %%ebx\n\t" \
-  "mov %%ebp, 4*(2*"#digits"-2)(%%edi)\n\t" \
-  "mov %%ebx, 4*(2*"#digits"-1)(%%edi)\n\t" 
-
-#define SqrCleanup \
-  "pop %%ebx\n\t" \
-  "pop %%esi\n\t" \
-  "pop %%ebp\n\t" 
-
-void PentiumOptimized::Square4(word* Y, const word* X)
-{
-	__asm__ __volatile__(
-		SqrStartup
-
-		SqrAccumulateCentre(0)
-		SqrStoreDigit(0)
-		SqrShiftCarry
-
-		SqrAccumulate(1,0)
-		SqrStoreDigit(1)
-		SqrShiftCarry
-
-		SqrAccumulate(2,0)
-		SqrAccumulateCentre(1)
-		SqrStoreDigit(2)
-		SqrShiftCarry
-
-		SqrAccumulate(3,0)
-		SqrAccumulate(2,1)
-		SqrStoreDigit(3)
-		SqrShiftCarry
-
-		SqrAccumulate(3,1)
-		SqrAccumulateCentre(2)
-		SqrStoreDigit(4)
-		SqrShiftCarry
-
-		SqrAccumulate(3,2)
-		SqrStoreDigit(5)
-		SqrShiftCarry
-
-		SqrLastDiagonal(4)
-
-		SqrCleanup
-
-		:
-		: "D" (Y), "S" (X)
-		: "eax",  "ecx", "edx", "ebp",   "memory"
-	);
-}
-
-#define MulStartup \
-  "push %%ebp\n\t" \
-  "push %%esi\n\t" \
-  "push %%ebx\n\t" \
-  "push %%edi\n\t" \
-  "mov %%eax, %%ebx \n\t" \
-  "xor %%ebp, %%ebp\n\t" \
-  "xor %%edi, %%edi\n\t" \
-  "xor %%ecx, %%ecx\n\t" 
-
-#define MulShiftCarry \
-  "mov %%edx, %%ebp\n\t" \
-  "mov %%ecx, %%edi\n\t" \
-  "xor %%ecx, %%ecx\n\t"
-
-#define MulAccumulate(i,j) \
-  "mov 4*"#j"(%%ebx), %%eax\n\t" \
-  "mull 4*"#i"(%%esi)\n\t" \
-  "add %%eax, %%ebp\n\t" \
-  "adc %%edx, %%edi\n\t" \
-  "adc %%ch, %%cl\n\t"
-
-#define MulStoreDigit(X)  \
-  "mov %%edi, %%edx \n\t" \
-  "mov (%%esp), %%edi \n\t" \
-  "mov %%ebp, 4*"#X"(%%edi)\n\t" \
-  "mov %%edi, (%%esp)\n\t" 
-
-#define MulLastDiagonal(digits) \
-  "mov 4*("#digits"-1)(%%ebx), %%eax\n\t" \
-  "mull 4*("#digits"-1)(%%esi)\n\t" \
-  "add %%eax, %%ebp\n\t" \
-  "adc %%edi, %%edx\n\t" \
-  "mov (%%esp), %%edi\n\t" \
-  "mov %%ebp, 4*(2*"#digits"-2)(%%edi)\n\t" \
-  "mov %%edx, 4*(2*"#digits"-1)(%%edi)\n\t" 
-
-#define MulCleanup \
-  "pop %%edi\n\t" \
-  "pop %%ebx\n\t" \
-  "pop %%esi\n\t" \
-  "pop %%ebp\n\t" 
-
-void PentiumOptimized::Multiply4(word* Z, const word* X, const word* Y)
-{
-	__asm__ __volatile__(
-		MulStartup
-		MulAccumulate(0,0)
-		MulStoreDigit(0)
-		MulShiftCarry
-
-		MulAccumulate(1,0)
-		MulAccumulate(0,1)
-		MulStoreDigit(1)
-		MulShiftCarry
-
-		MulAccumulate(2,0)
-		MulAccumulate(1,1)
-		MulAccumulate(0,2)
-		MulStoreDigit(2)
-		MulShiftCarry
-
-		MulAccumulate(3,0)
-		MulAccumulate(2,1)
-		MulAccumulate(1,2)
-		MulAccumulate(0,3)
-		MulStoreDigit(3)
-		MulShiftCarry
-
-		MulAccumulate(3,1)
-		MulAccumulate(2,2)
-		MulAccumulate(1,3)
-		MulStoreDigit(4)
-		MulShiftCarry
-
-		MulAccumulate(3,2)
-		MulAccumulate(2,3)
-		MulStoreDigit(5)
-		MulShiftCarry
-
-		MulLastDiagonal(4)
-
-		MulCleanup
-
-		: 
-		: "D" (Z), "S" (X), "a" (Y)
-		: "%ecx", "%edx",  "memory"
-	);
-}
-
-void PentiumOptimized::Multiply8(word* Z, const word* X, const word* Y)
-{
-	__asm__ __volatile__(
-		MulStartup
-		MulAccumulate(0,0)
-		MulStoreDigit(0)
-		MulShiftCarry
-
-		MulAccumulate(1,0)
-		MulAccumulate(0,1)
-		MulStoreDigit(1)
-		MulShiftCarry
-
-		MulAccumulate(2,0)
-		MulAccumulate(1,1)
-		MulAccumulate(0,2)
-		MulStoreDigit(2)
-		MulShiftCarry
-
-		MulAccumulate(3,0)
-		MulAccumulate(2,1)
-		MulAccumulate(1,2)
-		MulAccumulate(0,3)
-		MulStoreDigit(3)
-		MulShiftCarry
-
-		MulAccumulate(4,0)
-		MulAccumulate(3,1)
-		MulAccumulate(2,2)
-		MulAccumulate(1,3)
-		MulAccumulate(0,4)
-		MulStoreDigit(4)
-		MulShiftCarry
-
-		MulAccumulate(5,0)
-		MulAccumulate(4,1)
-		MulAccumulate(3,2)
-		MulAccumulate(2,3)
-		MulAccumulate(1,4)
-		MulAccumulate(0,5)
-		MulStoreDigit(5)
-		MulShiftCarry
-
-		MulAccumulate(6,0)
-		MulAccumulate(5,1)
-		MulAccumulate(4,2)
-		MulAccumulate(3,3)
-		MulAccumulate(2,4)
-		MulAccumulate(1,5)
-		MulAccumulate(0,6)
-		MulStoreDigit(6)
-		MulShiftCarry
-
-		MulAccumulate(7,0)
-		MulAccumulate(6,1)
-		MulAccumulate(5,2)
-		MulAccumulate(4,3)
-		MulAccumulate(3,4)
-		MulAccumulate(2,5)
-		MulAccumulate(1,6)
-		MulAccumulate(0,7)
-		MulStoreDigit(7)
-		MulShiftCarry
-
-		MulAccumulate(7,1)
-		MulAccumulate(6,2)
-		MulAccumulate(5,3)
-		MulAccumulate(4,4)
-		MulAccumulate(3,5)
-		MulAccumulate(2,6)
-		MulAccumulate(1,7)
-		MulStoreDigit(8)
-		MulShiftCarry
-
-		MulAccumulate(7,2)
-		MulAccumulate(6,3)
-		MulAccumulate(5,4)
-		MulAccumulate(4,5)
-		MulAccumulate(3,6)
-		MulAccumulate(2,7)
-		MulStoreDigit(9)
-		MulShiftCarry
-
-		MulAccumulate(7,3)
-		MulAccumulate(6,4)
-		MulAccumulate(5,5)
-		MulAccumulate(4,6)
-		MulAccumulate(3,7)
-		MulStoreDigit(10)
-		MulShiftCarry
-
-		MulAccumulate(7,4)
-		MulAccumulate(6,5)
-		MulAccumulate(5,6)
-		MulAccumulate(4,7)
-		MulStoreDigit(11)
-		MulShiftCarry
-
-		MulAccumulate(7,5)
-		MulAccumulate(6,6)
-		MulAccumulate(5,7)
-		MulStoreDigit(12)
-		MulShiftCarry
-
-		MulAccumulate(7,6)
-		MulAccumulate(6,7)
-		MulStoreDigit(13)
-		MulShiftCarry
-
-		MulLastDiagonal(8)
-
-		MulCleanup
-
-		: 
-		: "D" (Z), "S" (X), "a" (Y)
-		: "%ecx", "%edx",  "memory"
-	);
-}
-
-#elif defined(__GNUC__) && defined(__alpha__)
-
-class AlphaOptimized : public Portable
-{
-public:
-	static inline void Multiply2(word *C, const word *A, const word *B);
-	static inline word Multiply2Add(word *C, const word *A, const word *B);
-	static inline void Multiply4(word *C, const word *A, const word *B);
-	static inline unsigned int MultiplyRecursionLimit() {return 4;}
-
-	static inline void Multiply4Bottom(word *C, const word *A, const word *B);
-	static inline unsigned int MultiplyBottomRecursionLimit() {return 4;}
-
-	static inline void Square4(word *R, const word *A)
-	{
-		Multiply4(R, A, A);
-	}
-};
-
-typedef AlphaOptimized LowLevel;
-
-inline void AlphaOptimized::Multiply2(word *C, const word *A, const word *B)
-{
-	register dword c, a = *(const dword *)A, b = *(const dword *)B;
-	((dword *)C)[0] = a*b;
-	__asm__("umulh %1,%2,%0" : "=r" (c) : "r" (a), "r" (b));
-	((dword *)C)[1] = c;
-}
-
-inline word AlphaOptimized::Multiply2Add(word *C, const word *A, const word *B)
-{
-	register dword c, d, e, a = *(const dword *)A, b = *(const dword *)B;
-	c = ((dword *)C)[0];
-	d = a*b + c;
-	__asm__("umulh %1,%2,%0" : "=r" (e) : "r" (a), "r" (b));
-	((dword *)C)[0] = d;
-	d = (d < c);
-	c = ((dword *)C)[1] + d;
-	d = (c < d);
-	c += e;
-	((dword *)C)[1] = c;
-	d |= (c < e);
-	return d;
-}
-
-inline void AlphaOptimized::Multiply4(word *R, const word *A, const word *B)
-{
-	Multiply2(R, A, B);
-	Multiply2(R+4, A+2, B+2);
-	word carry = Multiply2Add(R+2, A+0, B+2);
-	carry += Multiply2Add(R+2, A+2, B+0);
-	Increment(R+6, 2, carry);
-}
-
-static inline void Multiply2BottomAdd(word *C, const word *A, const word *B)
-{
-	register dword a = *(const dword *)A, b = *(const dword *)B;
-	((dword *)C)[0] = a*b + ((dword *)C)[0];
-}
-
-inline void AlphaOptimized::Multiply4Bottom(word *R, const word *A, const word *B)
-{
-	Multiply2(R, A, B);
-	Multiply2BottomAdd(R+2, A+0, B+2);
-	Multiply2BottomAdd(R+2, A+2, B+0);
-}
-
-#else	// no processor specific code available
-
-typedef Portable LowLevel;
-
-#endif
-
-// ********************************************************
-
-#define A0		A
-#define A1		(A+N2)
-#define B0		B
-#define B1		(B+N2)
-
-#define T0		T
-#define T1		(T+N2)
-#define T2		(T+N)
-#define T3		(T+N+N2)
-
-#define R0		R
-#define R1		(R+N2)
-#define R2		(R+N)
-#define R3		(R+N+N2)
-
-//VC60 workaround: compiler bug triggered without the extra dummy parameters
-
-// R[2*N] - result = A*B
-// T[2*N] - temporary work space
-// A[N] --- multiplier
-// B[N] --- multiplicant
-
-template <class P>
-void DoRecursiveMultiply(word *R, word *T, const word *A, const word *B, unsigned int N, const P *dummy=NULL);
-
-template <class P>
-inline void RecursiveMultiply(word *R, word *T, const word *A, const word *B, unsigned int N, const P *dummy=NULL)
-{
-	assert(N>=2 && N%2==0);
-
-	if (P::MultiplyRecursionLimit() >= 8 && N==8)
-		P::Multiply8(R, A, B);
-	else if (P::MultiplyRecursionLimit() >= 4 && N==4)
-		P::Multiply4(R, A, B);
-	else if (N==2)
-		P::Multiply2(R, A, B);
-	else
-		DoRecursiveMultiply<P>(R, T, A, B, N, NULL);	// VC60 workaround: needs this NULL
-}
-
-template <class P>
-void DoRecursiveMultiply(word *R, word *T, const word *A, const word *B, unsigned int N, const P *dummy)
-{
-	const unsigned int N2 = N/2;
-	int carry;
-
-	int aComp = Compare(A0, A1, N2);
-	int bComp = Compare(B0, B1, N2);
-
-	switch (2*aComp + aComp + bComp)
-	{
-	case -4:
-		P::Subtract(R0, A1, A0, N2);
-		P::Subtract(R1, B0, B1, N2);
-		RecursiveMultiply<P>(T0, T2, R0, R1, N2);
-		P::Subtract(T1, T1, R0, N2);
-		carry = -1;
-		break;
-	case -2:
-		P::Subtract(R0, A1, A0, N2);
-		P::Subtract(R1, B0, B1, N2);
-		RecursiveMultiply<P>(T0, T2, R0, R1, N2);
-		carry = 0;
-		break;
-	case 2:
-		P::Subtract(R0, A0, A1, N2);
-		P::Subtract(R1, B1, B0, N2);
-		RecursiveMultiply<P>(T0, T2, R0, R1, N2);
-		carry = 0;
-		break;
-	case 4:
-		P::Subtract(R0, A1, A0, N2);
-		P::Subtract(R1, B0, B1, N2);
-		RecursiveMultiply<P>(T0, T2, R0, R1, N2);
-		P::Subtract(T1, T1, R1, N2);
-		carry = -1;
-		break;
-	default:
-		SetWords(T0, 0, N);
-		carry = 0;
-	}
-
-	RecursiveMultiply<P>(R0, T2, A0, B0, N2);
-	RecursiveMultiply<P>(R2, T2, A1, B1, N2);
-
-	// now T[01] holds (A1-A0)*(B0-B1), R[01] holds A0*B0, R[23] holds A1*B1
-
-	carry += P::Add(T0, T0, R0, N);
-	carry += P::Add(T0, T0, R2, N);
-	carry += P::Add(R1, R1, T0, N);
-
-	assert (carry >= 0 && carry <= 2);
-	Increment(R3, N2, carry);
-}
-
-// R[2*N] - result = A*A
-// T[2*N] - temporary work space
-// A[N] --- number to be squared
-
-template <class P>
-void DoRecursiveSquare(word *R, word *T, const word *A, unsigned int N, const P *dummy=NULL);
-
-template <class P>
-inline void RecursiveSquare(word *R, word *T, const word *A, unsigned int N, const P *dummy=NULL)
-{
-	assert(N && N%2==0);
-	if (P::SquareRecursionLimit() >= 8 && N==8)
-		P::Square8(R, A);
-	if (P::SquareRecursionLimit() >= 4 && N==4)
-		P::Square4(R, A);
-	else if (N==2)
-		P::Square2(R, A);
-	else
-		DoRecursiveSquare<P>(R, T, A, N, NULL);	// VC60 workaround: needs this NULL
-}
-
-template <class P>
-void DoRecursiveSquare(word *R, word *T, const word *A, unsigned int N, const P *dummy)
-{
-	const unsigned int N2 = N/2;
-
-	RecursiveSquare<P>(R0, T2, A0, N2);
-	RecursiveSquare<P>(R2, T2, A1, N2);
-	RecursiveMultiply<P>(T0, T2, A0, A1, N2);
-
-	word carry = P::Add(R1, R1, T0, N);
-	carry += P::Add(R1, R1, T0, N);
-	Increment(R3, N2, carry);
-}
-
-// R[N] - bottom half of A*B
-// T[N] - temporary work space
-// A[N] - multiplier
-// B[N] - multiplicant
-
-template <class P>
-void DoRecursiveMultiplyBottom(word *R, word *T, const word *A, const word *B, unsigned int N, const P *dummy=NULL);
-
-template <class P>
-inline void RecursiveMultiplyBottom(word *R, word *T, const word *A, const word *B, unsigned int N, const P *dummy=NULL)
-{
-	assert(N>=2 && N%2==0);
-	if (P::MultiplyBottomRecursionLimit() >= 8 && N==8)
-		P::Multiply8Bottom(R, A, B);
-	else if (P::MultiplyBottomRecursionLimit() >= 4 && N==4)
-		P::Multiply4Bottom(R, A, B);
-	else if (N==2)
-		P::Multiply2Bottom(R, A, B);
-	else
-		DoRecursiveMultiplyBottom<P>(R, T, A, B, N, NULL);
-}
-
-template <class P>
-void DoRecursiveMultiplyBottom(word *R, word *T, const word *A, const word *B, unsigned int N, const P *dummy)
-{
-	const unsigned int N2 = N/2;
-
-	RecursiveMultiply<P>(R, T, A0, B0, N2);
-	RecursiveMultiplyBottom<P>(T0, T1, A1, B0, N2);
-	P::Add(R1, R1, T0, N2);
-	RecursiveMultiplyBottom<P>(T0, T1, A0, B1, N2);
-	P::Add(R1, R1, T0, N2);
-}
-
-// R[N] --- upper half of A*B
-// T[2*N] - temporary work space
-// L[N] --- lower half of A*B
-// A[N] --- multiplier
-// B[N] --- multiplicant
-
-template <class P>
-void RecursiveMultiplyTop(word *R, word *T, const word *L, const word *A, const word *B, unsigned int N, const P *dummy=NULL)
-{
-	assert(N>=2 && N%2==0);
-
-	if (N==4)
-	{
-		P::Multiply4(T, A, B);
-		((dword *)R)[0] = ((dword *)T)[2];
-		((dword *)R)[1] = ((dword *)T)[3];
-	}
-	else if (N==2)
-	{
-		P::Multiply2(T, A, B);
-		((dword *)R)[0] = ((dword *)T)[1];
-	}
-	else
-	{
-		const unsigned int N2 = N/2;
-		int carry;
-
-		int aComp = Compare(A0, A1, N2);
-		int bComp = Compare(B0, B1, N2);
-
-		switch (2*aComp + aComp + bComp)
-		{
-		case -4:
-			P::Subtract(R0, A1, A0, N2);
-			P::Subtract(R1, B0, B1, N2);
-			RecursiveMultiply<P>(T0, T2, R0, R1, N2);
-			P::Subtract(T1, T1, R0, N2);
-			carry = -1;
-			break;
-		case -2:
-			P::Subtract(R0, A1, A0, N2);
-			P::Subtract(R1, B0, B1, N2);
-			RecursiveMultiply<P>(T0, T2, R0, R1, N2);
-			carry = 0;
-			break;
-		case 2:
-			P::Subtract(R0, A0, A1, N2);
-			P::Subtract(R1, B1, B0, N2);
-			RecursiveMultiply<P>(T0, T2, R0, R1, N2);
-			carry = 0;
-			break;
-		case 4:
-			P::Subtract(R0, A1, A0, N2);
-			P::Subtract(R1, B0, B1, N2);
-			RecursiveMultiply<P>(T0, T2, R0, R1, N2);
-			P::Subtract(T1, T1, R1, N2);
-			carry = -1;
-			break;
-		default:
-			SetWords(T0, 0, N);
-			carry = 0;
-		}
-
-		RecursiveMultiply<P>(T2, R0, A1, B1, N2);
-
-		// now T[01] holds (A1-A0)*(B0-B1), T[23] holds A1*B1
-
-		word c2 = P::Subtract(R0, L+N2, L, N2);
-		c2 += P::Subtract(R0, R0, T0, N2);
-		word t = (Compare(R0, T2, N2) == -1);
-
-		carry += t;
-		carry += Increment(R0, N2, c2+t);
-		carry += P::Add(R0, R0, T1, N2);
-		carry += P::Add(R0, R0, T3, N2);
-		assert (carry >= 0 && carry <= 2);
-
-		CopyWords(R1, T3, N2);
-		Increment(R1, N2, carry);
-	}
-}
-
-inline word Add(word *C, const word *A, const word *B, unsigned int N)
-{
-	return LowLevel::Add(C, A, B, N);
-}
-
-inline word Subtract(word *C, const word *A, const word *B, unsigned int N)
-{
-	return LowLevel::Subtract(C, A, B, N);
-}
-
-inline void Multiply(word *R, word *T, const word *A, const word *B, unsigned int N)
-{
-#ifdef SSE2_INTRINSICS_AVAILABLE
-	if (HasSSE2())
-		RecursiveMultiply<P4Optimized>(R, T, A, B, N);
-	else
-#endif
-		RecursiveMultiply<LowLevel>(R, T, A, B, N);
-}
-
-inline void Square(word *R, word *T, const word *A, unsigned int N)
-{
-#ifdef SSE2_INTRINSICS_AVAILABLE
-	if (HasSSE2())
-		RecursiveSquare<P4Optimized>(R, T, A, N);
-	else
-#endif
-		RecursiveSquare<LowLevel>(R, T, A, N);
-}
-
-inline void MultiplyBottom(word *R, word *T, const word *A, const word *B, unsigned int N)
-{
-#ifdef SSE2_INTRINSICS_AVAILABLE
-	if (HasSSE2())
-		RecursiveMultiplyBottom<P4Optimized>(R, T, A, B, N);
-	else
-#endif
-		RecursiveMultiplyBottom<LowLevel>(R, T, A, B, N);
-}
-
-inline void MultiplyTop(word *R, word *T, const word *L, const word *A, const word *B, unsigned int N)
-{
-#ifdef SSE2_INTRINSICS_AVAILABLE
-	if (HasSSE2())
-		RecursiveMultiplyTop<P4Optimized>(R, T, L, A, B, N);
-	else
-#endif
-		RecursiveMultiplyTop<LowLevel>(R, T, L, A, B, N);
-}
-
-// R[NA+NB] - result = A*B
-// T[NA+NB] - temporary work space
-// A[NA] ---- multiplier
-// B[NB] ---- multiplicant
-
-void AsymmetricMultiply(word *R, word *T, const word *A, unsigned int NA, const word *B, unsigned int NB)
-{
-	if (NA == NB)
-	{
-		if (A == B)
-			Square(R, T, A, NA);
-		else
-			Multiply(R, T, A, B, NA);
-
-		return;
-	}
-
-	if (NA > NB)
-	{
-		std::swap(A, B);
-		std::swap(NA, NB);
-	}
-
-	assert(NB % NA == 0);
-	assert((NB/NA)%2 == 0); 	// NB is an even multiple of NA
-
-	if (NA==2 && !A[1])
-	{
-		switch (A[0])
-		{
-		case 0:
-			SetWords(R, 0, NB+2);
-			return;
-		case 1:
-			CopyWords(R, B, NB);
-			R[NB] = R[NB+1] = 0;
-			return;
-		default:
-			R[NB] = LinearMultiply(R, B, A[0], NB);
-			R[NB+1] = 0;
-			return;
-		}
-	}
-
-	Multiply(R, T, A, B, NA);
-	CopyWords(T+2*NA, R+NA, NA);
-
-	unsigned i;
-
-	for (i=2*NA; i<NB; i+=2*NA)
-		Multiply(T+NA+i, T, A, B+i, NA);
-	for (i=NA; i<NB; i+=2*NA)
-		Multiply(R+i, T, A, B+i, NA);
-
-	if (Add(R+NA, R+NA, T+2*NA, NB-NA))
-		Increment(R+NB, NA);
-}
-
-// R[N] ----- result = A inverse mod 2**(WORD_BITS*N)
-// T[3*N/2] - temporary work space
-// A[N] ----- an odd number as input
-
-void RecursiveInverseModPower2(word *R, word *T, const word *A, unsigned int N)
-{
-	if (N==2)
-		AtomicInverseModPower2(R, A[0], A[1]);
-	else
-	{
-		const unsigned int N2 = N/2;
-		RecursiveInverseModPower2(R0, T0, A0, N2);
-		T0[0] = 1;
-		SetWords(T0+1, 0, N2-1);
-		MultiplyTop(R1, T1, T0, R0, A0, N2);
-		MultiplyBottom(T0, T1, R0, A1, N2);
-		Add(T0, R1, T0, N2);
-		TwosComplement(T0, N2);
-		MultiplyBottom(R1, T1, R0, T0, N2);
-	}
-}
-
-// R[N] --- result = X/(2**(WORD_BITS*N)) mod M
-// T[3*N] - temporary work space
-// X[2*N] - number to be reduced
-// M[N] --- modulus
-// U[N] --- multiplicative inverse of M mod 2**(WORD_BITS*N)
-
-void MontgomeryReduce(word *R, word *T, const word *X, const word *M, const word *U, unsigned int N)
-{
-	MultiplyBottom(R, T, X, U, N);
-	MultiplyTop(T, T+N, X, R, M, N);
-	word borrow = Subtract(T, X+N, T, N);
-	// defend against timing attack by doing this Add even when not needed
-	word carry = Add(T+N, T, M, N);
-	assert(carry || !borrow);
-	CopyWords(R, T + (borrow ? N : 0), N);
-}
-
-// R[N] --- result = X/(2**(WORD_BITS*N/2)) mod M
-// T[2*N] - temporary work space
-// X[2*N] - number to be reduced
-// M[N] --- modulus
-// U[N/2] - multiplicative inverse of M mod 2**(WORD_BITS*N/2)
-// V[N] --- 2**(WORD_BITS*3*N/2) mod M
-
-void HalfMontgomeryReduce(word *R, word *T, const word *X, const word *M, const word *U, const word *V, unsigned int N)
-{
-	assert(N%2==0 && N>=4);
-
-#define M0		M
-#define M1		(M+N2)
-#define V0		V
-#define V1		(V+N2)
-
-#define X0		X
-#define X1		(X+N2)
-#define X2		(X+N)
-#define X3		(X+N+N2)
-
-	const unsigned int N2 = N/2;
-	Multiply(T0, T2, V0, X3, N2);
-	int c2 = Add(T0, T0, X0, N);
-	MultiplyBottom(T3, T2, T0, U, N2);
-	MultiplyTop(T2, R, T0, T3, M0, N2);
-	c2 -= Subtract(T2, T1, T2, N2);
-	Multiply(T0, R, T3, M1, N2);
-	c2 -= Subtract(T0, T2, T0, N2);
-	int c3 = -(int)Subtract(T1, X2, T1, N2);
-	Multiply(R0, T2, V1, X3, N2);
-	c3 += Add(R, R, T, N);
-
-	if (c2>0)
-		c3 += Increment(R1, N2);
-	else if (c2<0)
-		c3 -= Decrement(R1, N2, -c2);
-
-	assert(c3>=-1 && c3<=1);
-	if (c3>0)
-		Subtract(R, R, M, N);
-	else if (c3<0)
-		Add(R, R, M, N);
-
-#undef M0
-#undef M1
-#undef V0
-#undef V1
-
-#undef X0
-#undef X1
-#undef X2
-#undef X3
-}
-
-#undef A0
-#undef A1
-#undef B0
-#undef B1
-
-#undef T0
-#undef T1
-#undef T2
-#undef T3
-
-#undef R0
-#undef R1
-#undef R2
-#undef R3
-
-// do a 3 word by 2 word divide, returns quotient and leaves remainder in A
-static word SubatomicDivide(word *A, word B0, word B1)
-{
-	// assert {A[2],A[1]} < {B1,B0}, so quotient can fit in a word
-	assert(A[2] < B1 || (A[2]==B1 && A[1] < B0));
-
-	dword p, u;
-	word Q;
-
-	// estimate the quotient: do a 2 word by 1 word divide
-	if (B1+1 == 0)
-		Q = A[2];
-	else
-		Q = word(MAKE_DWORD(A[1], A[2]) / (B1+1));
-
-	// now subtract Q*B from A
-	p = (dword) B0*Q;
-	u = (dword) A[0] - LOW_WORD(p);
-	A[0] = LOW_WORD(u);
-	u = (dword) A[1] - HIGH_WORD(p) - (word)(0-HIGH_WORD(u)) - (dword)B1*Q;
-	A[1] = LOW_WORD(u);
-	A[2] += HIGH_WORD(u);
-
-	// Q <= actual quotient, so fix it
-	while (A[2] || A[1] > B1 || (A[1]==B1 && A[0]>=B0))
-	{
-		u = (dword) A[0] - B0;
-		A[0] = LOW_WORD(u);
-		u = (dword) A[1] - B1 - (word)(0-HIGH_WORD(u));
-		A[1] = LOW_WORD(u);
-		A[2] += HIGH_WORD(u);
-		Q++;
-		assert(Q);	// shouldn't overflow
-	}
-
-	return Q;
-}
-
-// do a 4 word by 2 word divide, returns 2 word quotient in Q0 and Q1
-static inline void AtomicDivide(word *Q, const word *A, const word *B)
-{
-	if (!B[0] && !B[1]) // if divisor is 0, we assume divisor==2**(2*WORD_BITS)
-	{
-		Q[0] = A[2];
-		Q[1] = A[3];
-	}
-	else
-	{
-		word T[4];
-		T[0] = A[0]; T[1] = A[1]; T[2] = A[2]; T[3] = A[3];
-		Q[1] = SubatomicDivide(T+1, B[0], B[1]);
-		Q[0] = SubatomicDivide(T, B[0], B[1]);
-
-#ifndef NDEBUG
-		// multiply quotient and divisor and add remainder, make sure it equals dividend
-		assert(!T[2] && !T[3] && (T[1] < B[1] || (T[1]==B[1] && T[0]<B[0])));
-		word P[4];
-		LowLevel::Multiply2(P, Q, B);
-		Add(P, P, T, 4);
-		assert(memcmp(P, A, 4*WORD_SIZE)==0);
-#endif
-	}
-}
-
-// for use by Divide(), corrects the underestimated quotient {Q1,Q0}
-static void CorrectQuotientEstimate(word *R, word *T, word *Q, const word *B, unsigned int N)
-{
-	assert(N && N%2==0);
-
-	if (Q[1])
-	{
-		T[N] = T[N+1] = 0;
-		unsigned i;
-		for (i=0; i<N; i+=4)
-			LowLevel::Multiply2(T+i, Q, B+i);
-		for (i=2; i<N; i+=4)
-			if (LowLevel::Multiply2Add(T+i, Q, B+i))
-				T[i+5] += (++T[i+4]==0);
-	}
-	else
-	{
-		T[N] = LinearMultiply(T, B, Q[0], N);
-		T[N+1] = 0;
-	}
-
-	word borrow = Subtract(R, R, T, N+2);
-	assert(!borrow && !R[N+1]);
-
-	while (R[N] || Compare(R, B, N) >= 0)
-	{
-		R[N] -= Subtract(R, R, B, N);
-		Q[1] += (++Q[0]==0);
-		assert(Q[0] || Q[1]); // no overflow
-	}
-}
-
-// R[NB] -------- remainder = A%B
-// Q[NA-NB+2] --- quotient	= A/B
-// T[NA+2*NB+4] - temp work space
-// A[NA] -------- dividend
-// B[NB] -------- divisor
-
-void Divide(word *R, word *Q, word *T, const word *A, unsigned int NA, const word *B, unsigned int NB)
-{
-	assert(NA && NB && NA%2==0 && NB%2==0);
-	assert(B[NB-1] || B[NB-2]);
-	assert(NB <= NA);
-
-	// set up temporary work space
-	word *const TA=T;
-	word *const TB=T+NA+2;
-	word *const TP=T+NA+2+NB;
-
-	// copy B into TB and normalize it so that TB has highest bit set to 1
-	unsigned shiftWords = (B[NB-1]==0);
-	TB[0] = TB[NB-1] = 0;
-	CopyWords(TB+shiftWords, B, NB-shiftWords);
-	unsigned shiftBits = WORD_BITS - BitPrecision(TB[NB-1]);
-	assert(shiftBits < WORD_BITS);
-	ShiftWordsLeftByBits(TB, NB, shiftBits);
-
-	// copy A into TA and normalize it
-	TA[0] = TA[NA] = TA[NA+1] = 0;
-	CopyWords(TA+shiftWords, A, NA);
-	ShiftWordsLeftByBits(TA, NA+2, shiftBits);
-
-	if (TA[NA+1]==0 && TA[NA] <= 1)
-	{
-		Q[NA-NB+1] = Q[NA-NB] = 0;
-		while (TA[NA] || Compare(TA+NA-NB, TB, NB) >= 0)
-		{
-			TA[NA] -= Subtract(TA+NA-NB, TA+NA-NB, TB, NB);
-			++Q[NA-NB];
-		}
-	}
-	else
-	{
-		NA+=2;
-		assert(Compare(TA+NA-NB, TB, NB) < 0);
-	}
-
-	word BT[2];
-	BT[0] = TB[NB-2] + 1;
-	BT[1] = TB[NB-1] + (BT[0]==0);
-
-	// start reducing TA mod TB, 2 words at a time
-	for (unsigned i=NA-2; i>=NB; i-=2)
-	{
-		AtomicDivide(Q+i-NB, TA+i-2, BT);
-		CorrectQuotientEstimate(TA+i-NB, TP, Q+i-NB, TB, NB);
-	}
-
-	// copy TA into R, and denormalize it
-	CopyWords(R, TA+shiftWords, NB);
-	ShiftWordsRightByBits(R, NB, shiftBits);
-}
-
-static inline unsigned int EvenWordCount(const word *X, unsigned int N)
-{
-	while (N && X[N-2]==0 && X[N-1]==0)
-		N-=2;
-	return N;
-}
-
-// return k
-// R[N] --- result = A^(-1) * 2^k mod M
-// T[4*N] - temporary work space
-// A[NA] -- number to take inverse of
-// M[N] --- modulus
-
-unsigned int AlmostInverse(word *R, word *T, const word *A, unsigned int NA, const word *M, unsigned int N)
-{
-	assert(NA<=N && N && N%2==0);
-
-	word *b = T;
-	word *c = T+N;
-	word *f = T+2*N;
-	word *g = T+3*N;
-	unsigned int bcLen=2, fgLen=EvenWordCount(M, N);
-	unsigned int k=0, s=0;
-
-	SetWords(T, 0, 3*N);
-	b[0]=1;
-	CopyWords(f, A, NA);
-	CopyWords(g, M, N);
-
-	while (1)
-	{
-		word t=f[0];
-		while (!t)
-		{
-			if (EvenWordCount(f, fgLen)==0)
-			{
-				SetWords(R, 0, N);
-				return 0;
-			}
-
-			ShiftWordsRightByWords(f, fgLen, 1);
-			if (c[bcLen-1]) bcLen+=2;
-			assert(bcLen <= N);
-			ShiftWordsLeftByWords(c, bcLen, 1);
-			k+=WORD_BITS;
-			t=f[0];
-		}
-
-		unsigned int i=0;
-		while (t%2 == 0)
-		{
-			t>>=1;
-			i++;
-		}
-		k+=i;
-
-		if (t==1 && f[1]==0 && EvenWordCount(f, fgLen)==2)
-		{
-			if (s%2==0)
-				CopyWords(R, b, N);
-			else
-				Subtract(R, M, b, N);
-			return k;
-		}
-
-		ShiftWordsRightByBits(f, fgLen, i);
-		t=ShiftWordsLeftByBits(c, bcLen, i);
-		if (t)
-		{
-			c[bcLen] = t;
-			bcLen+=2;
-			assert(bcLen <= N);
-		}
-
-		if (f[fgLen-2]==0 && g[fgLen-2]==0 && f[fgLen-1]==0 && g[fgLen-1]==0)
-			fgLen-=2;
-
-		if (Compare(f, g, fgLen)==-1)
-		{
-			std::swap(f, g);
-			std::swap(b, c);
-			s++;
-		}
-
-		Subtract(f, f, g, fgLen);
-
-		if (Add(b, b, c, bcLen))
-		{
-			b[bcLen] = 1;
-			bcLen+=2;
-			assert(bcLen <= N);
-		}
-	}
-}
-
-// R[N] - result = A/(2^k) mod M
-// A[N] - input
-// M[N] - modulus
-
-void DivideByPower2Mod(word *R, const word *A, unsigned int k, const word *M, unsigned int N)
-{
-	CopyWords(R, A, N);
-
-	while (k--)
-	{
-		if (R[0]%2==0)
-			ShiftWordsRightByBits(R, N, 1);
-		else
-		{
-			word carry = Add(R, R, M, N);
-			ShiftWordsRightByBits(R, N, 1);
-			R[N-1] += carry<<(WORD_BITS-1);
-		}
-	}
-}
-
-// R[N] - result = A*(2^k) mod M
-// A[N] - input
-// M[N] - modulus
-
-void MultiplyByPower2Mod(word *R, const word *A, unsigned int k, const word *M, unsigned int N)
-{
-	CopyWords(R, A, N);
-
-	while (k--)
-		if (ShiftWordsLeftByBits(R, N, 1) || Compare(R, M, N)>=0)
-			Subtract(R, R, M, N);
-}
-
-// ******************************************************************
-
-static const unsigned int RoundupSizeTable[] = {2, 2, 2, 4, 4, 8, 8, 8, 8};
-
-static inline unsigned int RoundupSize(unsigned int n)
-{
-	if (n<=8)
-		return RoundupSizeTable[n];
-	else if (n<=16)
-		return 16;
-	else if (n<=32)
-		return 32;
-	else if (n<=64)
-		return 64;
-	else return 1U << BitPrecision(n-1);
-}
-
-Integer::Integer()
-	: reg(2), sign(POSITIVE)
-{
-	reg[0] = reg[1] = 0;
-}
-
-Integer::Integer(const Integer& t)
-	: reg(RoundupSize(t.WordCount())), sign(t.sign)
-{
-	CopyWords(reg, t.reg, reg.size());
-}
-
-Integer::Integer(signed long value)
-	: reg(2)
-{
-	if (value >= 0)
-		sign = POSITIVE;
-	else
-	{
-		sign = NEGATIVE;
-		value = -value;
-	}
-	reg[0] = word(value);
-	reg[1] = word(SafeRightShift<WORD_BITS, unsigned long>(value));
-}
-
-Integer::Integer(Sign s, word high, word low)
-	: reg(2), sign(s)
-{
-	reg[0] = low;
-	reg[1] = high;
-}
-
-bool Integer::IsConvertableToLong() const
-{
-	if (ByteCount() > sizeof(long))
-		return false;
-
-	unsigned long value = reg[0];
-	value += SafeLeftShift<WORD_BITS, unsigned long>(reg[1]);
-
-	if (sign==POSITIVE)
-		return (signed long)value >= 0;
-	else
-		return -(signed long)value < 0;
-}
-
-signed long Integer::ConvertToLong() const
-{
-	assert(IsConvertableToLong());
-
-	unsigned long value = reg[0];
-	value += SafeLeftShift<WORD_BITS, unsigned long>(reg[1]);
-	return sign==POSITIVE ? value : -(signed long)value;
-}
-
-Integer::Integer(BufferedTransformation &encodedInteger, unsigned int byteCount, Signedness s)
-{
-	Decode(encodedInteger, byteCount, s);
-}
-
-Integer::Integer(const byte *encodedInteger, unsigned int byteCount, Signedness s)
-{
-	Decode(encodedInteger, byteCount, s);
-}
-
-Integer::Integer(BufferedTransformation &bt)
-{
-	BERDecode(bt);
-}
-
-Integer::Integer(RandomNumberGenerator &rng, unsigned int bitcount)
-{
-	Randomize(rng, bitcount);
-}
-
-Integer::Integer(RandomNumberGenerator &rng, const Integer &min, const Integer &max, RandomNumberType rnType, const Integer &equiv, const Integer &mod)
-{
-	if (!Randomize(rng, min, max, rnType, equiv, mod))
-		throw Integer::RandomNumberNotFound();
-}
-
-Integer Integer::Power2(unsigned int e)
-{
-	Integer r((word)0, BitsToWords(e+1));
-	r.SetBit(e);
-	return r;
-}
-
-const Integer &Integer::Zero()
-{
-	static const Integer zero;
-	return zero;
-}
-
-const Integer &Integer::One()
-{
-	static const Integer one(1,2);
-	return one;
-}
-
-const Integer &Integer::Two()
-{
-	static const Integer two(2,2);
-	return two;
-}
-
-bool Integer::operator!() const
-{
-	return IsNegative() ? false : (reg[0]==0 && WordCount()==0);
-}
-
-Integer& Integer::operator=(const Integer& t)
-{
-	if (this != &t)
-	{
-		reg.New(RoundupSize(t.WordCount()));
-		CopyWords(reg, t.reg, reg.size());
-		sign = t.sign;
-	}
-	return *this;
-}
-
-bool Integer::GetBit(unsigned int n) const
-{
-	if (n/WORD_BITS >= reg.size())
-		return 0;
-	else
-		return bool((reg[n/WORD_BITS] >> (n % WORD_BITS)) & 1);
-}
-
-void Integer::SetBit(unsigned int n, bool value)
-{
-	if (value)
-	{
-		reg.CleanGrow(RoundupSize(BitsToWords(n+1)));
-		reg[n/WORD_BITS] |= (word(1) << (n%WORD_BITS));
-	}
-	else
-	{
-		if (n/WORD_BITS < reg.size())
-			reg[n/WORD_BITS] &= ~(word(1) << (n%WORD_BITS));
-	}
-}
-
-byte Integer::GetByte(unsigned int n) const
-{
-	if (n/WORD_SIZE >= reg.size())
-		return 0;
-	else
-		return byte(reg[n/WORD_SIZE] >> ((n%WORD_SIZE)*8));
-}
-
-void Integer::SetByte(unsigned int n, byte value)
-{
-	reg.CleanGrow(RoundupSize(BytesToWords(n+1)));
-	reg[n/WORD_SIZE] &= ~(word(0xff) << 8*(n%WORD_SIZE));
-	reg[n/WORD_SIZE] |= (word(value) << 8*(n%WORD_SIZE));
-}
-
-unsigned long Integer::GetBits(unsigned int i, unsigned int n) const
-{
-	assert(n <= sizeof(unsigned long)*8);
-	unsigned long v = 0;
-	for (unsigned int j=0; j<n; j++)
-		v |= GetBit(i+j) << j;
-	return v;
-}
-
-Integer Integer::operator-() const
-{
-	Integer result(*this);
-	result.Negate();
-	return result;
-}
-
-Integer Integer::AbsoluteValue() const
-{
-	Integer result(*this);
-	result.sign = POSITIVE;
-	return result;
-}
-
-void Integer::swap(Integer &a)
-{
-	reg.swap(a.reg);
-	std::swap(sign, a.sign);
-}
-
-Integer::Integer(word value, unsigned int length)
-	: reg(RoundupSize(length)), sign(POSITIVE)
-{
-	reg[0] = value;
-	SetWords(reg+1, 0, reg.size()-1);
-}
-
-template <class T>
-static Integer StringToInteger(const T *str)
-{
-	word radix;
-#if (defined(__GNUC__) && __GNUC__ <= 3)		// GCC workaround
-	// std::char_traits doesn't exist in GCC 2.x
-	// std::char_traits<wchar_t>::length() not defined in GCC 3.2
-	unsigned int length;
-	for (length = 0; str[length] != 0; length++) {}
-#else
-	unsigned int length = std::char_traits<T>::length(str);
-#endif
-
-	Integer v;
-
-	if (length == 0)
-		return v;
-
-	switch (str[length-1])
-	{
-	case 'h':
-	case 'H':
-		radix=16;
-		break;
-	case 'o':
-	case 'O':
-		radix=8;
-		break;
-	case 'b':
-	case 'B':
-		radix=2;
-		break;
-	default:
-		radix=10;
-	}
-
-	if (length > 2 && str[0] == '0' && str[1] == 'x')
-		radix = 16;
-
-	for (unsigned i=0; i<length; i++)
-	{
-		word digit;
-
-		if (str[i] >= '0' && str[i] <= '9')
-			digit = str[i] - '0';
-		else if (str[i] >= 'A' && str[i] <= 'F')
-			digit = str[i] - 'A' + 10;
-		else if (str[i] >= 'a' && str[i] <= 'f')
-			digit = str[i] - 'a' + 10;
-		else
-			digit = radix;
-
-		if (digit < radix)
-		{
-			v *= radix;
-			v += digit;
-		}
-	}
-
-	if (str[0] == '-')
-		v.Negate();
-
-	return v;
-}
-
-Integer::Integer(const char *str)
-	: reg(2), sign(POSITIVE)
-{
-	*this = StringToInteger(str);
-}
-
-Integer::Integer(const wchar_t *str)
-	: reg(2), sign(POSITIVE)
-{
-	*this = StringToInteger(str);
-}
-
-unsigned int Integer::WordCount() const
-{
-	return CountWords(reg, reg.size());
-}
-
-unsigned int Integer::ByteCount() const
-{
-	unsigned wordCount = WordCount();
-	if (wordCount)
-		return (wordCount-1)*WORD_SIZE + BytePrecision(reg[wordCount-1]);
-	else
-		return 0;
-}
-
-unsigned int Integer::BitCount() const
-{
-	unsigned wordCount = WordCount();
-	if (wordCount)
-		return (wordCount-1)*WORD_BITS + BitPrecision(reg[wordCount-1]);
-	else
-		return 0;
-}
-
-void Integer::Decode(const byte *input, unsigned int inputLen, Signedness s)
-{
-	StringStore store(input, inputLen);
-	Decode(store, inputLen, s);
-}
-
-void Integer::Decode(BufferedTransformation &bt, unsigned int inputLen, Signedness s)
-{
-	assert(bt.MaxRetrievable() >= inputLen);
-
-	byte b;
-	bt.Peek(b);
-	sign = ((s==SIGNED) && (b & 0x80)) ? NEGATIVE : POSITIVE;
-
-	while (inputLen>0 && (sign==POSITIVE ? b==0 : b==0xff))
-	{
-		bt.Skip(1);
-		inputLen--;
-		bt.Peek(b);
-	}
-
-	reg.CleanNew(RoundupSize(BytesToWords(inputLen)));
-
-	for (unsigned int i=inputLen; i > 0; i--)
-	{
-		bt.Get(b);
-		reg[(i-1)/WORD_SIZE] |= b << ((i-1)%WORD_SIZE)*8;
-	}
-
-	if (sign == NEGATIVE)
-	{
-		for (unsigned i=inputLen; i<reg.size()*WORD_SIZE; i++)
-			reg[i/WORD_SIZE] |= 0xff << (i%WORD_SIZE)*8;
-		TwosComplement(reg, reg.size());
-	}
-}
-
-unsigned int Integer::MinEncodedSize(Signedness signedness) const
-{
-	unsigned int outputLen = STDMAX(1U, ByteCount());
-	if (signedness == UNSIGNED)
-		return outputLen;
-	if (NotNegative() && (GetByte(outputLen-1) & 0x80))
-		outputLen++;
-	if (IsNegative() && *this < -Power2(outputLen*8-1))
-		outputLen++;
-	return outputLen;
-}
-
-unsigned int Integer::Encode(byte *output, unsigned int outputLen, Signedness signedness) const
-{
-	ArraySink sink(output, outputLen);
-	return Encode(sink, outputLen, signedness);
-}
-
-unsigned int Integer::Encode(BufferedTransformation &bt, unsigned int outputLen, Signedness signedness) const
-{
-	if (signedness == UNSIGNED || NotNegative())
-	{
-		for (unsigned int i=outputLen; i > 0; i--)
-			bt.Put(GetByte(i-1));
-	}
-	else
-	{
-		// take two's complement of *this
-		Integer temp = Integer::Power2(8*STDMAX(ByteCount(), outputLen)) + *this;
-		for (unsigned i=0; i<outputLen; i++)
-			bt.Put(temp.GetByte(outputLen-i-1));
-	}
-	return outputLen;
-}
-
-void Integer::DEREncode(BufferedTransformation &bt) const
-{
-	DERGeneralEncoder enc(bt, INTEGER);
-	Encode(enc, MinEncodedSize(SIGNED), SIGNED);
-	enc.MessageEnd();
-}
-
-void Integer::BERDecode(const byte *input, unsigned int len)
-{
-	StringStore store(input, len);
-	BERDecode(store);
-}
-
-void Integer::BERDecode(BufferedTransformation &bt)
-{
-	BERGeneralDecoder dec(bt, INTEGER);
-	if (!dec.IsDefiniteLength() || dec.MaxRetrievable() < dec.RemainingLength())
-		BERDecodeError();
-	Decode(dec, dec.RemainingLength(), SIGNED);
-	dec.MessageEnd();
-}
-
-void Integer::DEREncodeAsOctetString(BufferedTransformation &bt, unsigned int length) const
-{
-	DERGeneralEncoder enc(bt, OCTET_STRING);
-	Encode(enc, length);
-	enc.MessageEnd();
-}
-
-void Integer::BERDecodeAsOctetString(BufferedTransformation &bt, unsigned int length)
-{
-	BERGeneralDecoder dec(bt, OCTET_STRING);
-	if (!dec.IsDefiniteLength() || dec.RemainingLength() != length)
-		BERDecodeError();
-	Decode(dec, length);
-	dec.MessageEnd();
-}
-
-unsigned int Integer::OpenPGPEncode(byte *output, unsigned int len) const
-{
-	ArraySink sink(output, len);
-	return OpenPGPEncode(sink);
-}
-
-unsigned int Integer::OpenPGPEncode(BufferedTransformation &bt) const
-{
-	word16 bitCount = BitCount();
-	bt.PutWord16(bitCount);
-	return 2 + Encode(bt, BitsToBytes(bitCount));
-}
-
-void Integer::OpenPGPDecode(const byte *input, unsigned int len)
-{
-	StringStore store(input, len);
-	OpenPGPDecode(store);
-}
-
-void Integer::OpenPGPDecode(BufferedTransformation &bt)
-{
-	word16 bitCount;
-	if (bt.GetWord16(bitCount) != 2 || bt.MaxRetrievable() < BitsToBytes(bitCount))
-		throw OpenPGPDecodeErr();
-	Decode(bt, BitsToBytes(bitCount));
-}
-
-void Integer::Randomize(RandomNumberGenerator &rng, unsigned int nbits)
-{
-	const unsigned int nbytes = nbits/8 + 1;
-	SecByteBlock buf(nbytes);
-	rng.GenerateBlock(buf, nbytes);
-	if (nbytes)
-		buf[0] = (byte)Crop(buf[0], nbits % 8);
-	Decode(buf, nbytes, UNSIGNED);
-}
-
-void Integer::Randomize(RandomNumberGenerator &rng, const Integer &min, const Integer &max)
-{
-	if (min > max)
-		throw InvalidArgument("Integer: Min must be no greater than Max");
-
-	Integer range = max - min;
-	const unsigned int nbits = range.BitCount();
-
-	do
-	{
-		Randomize(rng, nbits);
-	}
-	while (*this > range);
-
-	*this += min;
-}
-
-bool Integer::Randomize(RandomNumberGenerator &rng, const Integer &min, const Integer &max, RandomNumberType rnType, const Integer &equiv, const Integer &mod)
-{
-	return GenerateRandomNoThrow(rng, MakeParameters("Min", min)("Max", max)("RandomNumberType", rnType)("EquivalentTo", equiv)("Mod", mod));
-}
-
-class KDF2_RNG : public RandomNumberGenerator
-{
-public:
-	KDF2_RNG(const byte *seed, unsigned int seedSize)
-		: m_counter(0), m_counterAndSeed(seedSize + 4)
-	{
-		memcpy(m_counterAndSeed + 4, seed, seedSize);
-	}
-
-	byte GenerateByte()
-	{
-		byte b;
-		GenerateBlock(&b, 1);
-		return b;
-	}
-
-	void GenerateBlock(byte *output, unsigned int size)
-	{
-		UnalignedPutWord(BIG_ENDIAN_ORDER, m_counterAndSeed, m_counter);
-		++m_counter;
-		P1363_KDF2<SHA1>::DeriveKey(output, size, m_counterAndSeed, m_counterAndSeed.size());
-	}
-
-private:
-	word32 m_counter;
-	SecByteBlock m_counterAndSeed;
-};
-
-bool Integer::GenerateRandomNoThrow(RandomNumberGenerator &i_rng, const NameValuePairs &params)
-{
-	Integer min = params.GetValueWithDefault("Min", Integer::Zero());
-	Integer max;
-	if (!params.GetValue("Max", max))
-	{
-		int bitLength;
-		if (params.GetIntValue("BitLength", bitLength))
-			max = Integer::Power2(bitLength);
-		else
-			throw InvalidArgument("Integer: missing Max argument");
-	}
-	if (min > max)
-		throw InvalidArgument("Integer: Min must be no greater than Max");
-
-	Integer equiv = params.GetValueWithDefault("EquivalentTo", Integer::Zero());
-	Integer mod = params.GetValueWithDefault("Mod", Integer::One());
-
-	if (equiv.IsNegative() || equiv >= mod)
-		throw InvalidArgument("Integer: invalid EquivalentTo and/or Mod argument");
-
-	Integer::RandomNumberType rnType = params.GetValueWithDefault("RandomNumberType", Integer::ANY);
-
-	member_ptr<KDF2_RNG> kdf2Rng;
-	ConstByteArrayParameter seed;
-	if (params.GetValue("Seed", seed))
-	{
-		ByteQueue bq;
-		DERSequenceEncoder seq(bq);
-		min.DEREncode(seq);
-		max.DEREncode(seq);
-		equiv.DEREncode(seq);
-		mod.DEREncode(seq);
-		DEREncodeUnsigned(seq, rnType);
-		DEREncodeOctetString(seq, seed.begin(), seed.size());
-		seq.MessageEnd();
-
-		SecByteBlock finalSeed(bq.MaxRetrievable());
-		bq.Get(finalSeed, finalSeed.size());
-		kdf2Rng.reset(new KDF2_RNG(finalSeed.begin(), finalSeed.size()));
-	}
-	RandomNumberGenerator &rng = kdf2Rng.get() ? (RandomNumberGenerator &)*kdf2Rng : i_rng;
-
-	switch (rnType)
-	{
-		case ANY:
-			if (mod == One())
-				Randomize(rng, min, max);
-			else
-			{
-				Integer min1 = min + (equiv-min)%mod;
-				if (max < min1)
-					return false;
-				Randomize(rng, Zero(), (max - min1) / mod);
-				*this *= mod;
-				*this += min1;
-			}
-			return true;
-
-		case PRIME:
-		{
-			const PrimeSelector *pSelector = params.GetValueWithDefault("PointerToPrimeSelector", (const PrimeSelector *)NULL);
-
-			int i;
-			i = 0;
-			while (1)
-			{
-				if (++i==16)
-				{
-					// check if there are any suitable primes in [min, max]
-					Integer first = min;
-					if (FirstPrime(first, max, equiv, mod, pSelector))
-					{
-						// if there is only one suitable prime, we're done
-						*this = first;
-						if (!FirstPrime(first, max, equiv, mod, pSelector))
-							return true;
-					}
-					else
-						return false;
-				}
-
-				Randomize(rng, min, max);
-				if (FirstPrime(*this, STDMIN(*this+mod*PrimeSearchInterval(max), max), equiv, mod, pSelector))
-					return true;
-			}
-		}
-
-		default:
-			throw InvalidArgument("Integer: invalid RandomNumberType argument");
-	}
-}
-
-std::istream& operator>>(std::istream& in, Integer &a)
-{
-	char c;
-	unsigned int length = 0;
-	SecBlock<char> str(length + 16);
-
-	std::ws(in);
-
-	do
-	{
-		in.read(&c, 1);
-		str[length++] = c;
-		if (length >= str.size())
-			str.Grow(length + 16);
-	}
-	while (in && (c=='-' || c=='x' || (c>='0' && c<='9') || (c>='a' && c<='f') || (c>='A' && c<='F') || c=='h' || c=='H' || c=='o' || c=='O' || c==',' || c=='.'));
-
-	if (in.gcount())
-		in.putback(c);
-	str[length-1] = '\0';
-	a = Integer(str);
-
-	return in;
-}
-
-std::ostream& operator<<(std::ostream& out, const Integer &a)
-{
-	// Get relevant conversion specifications from ostream.
-	long f = out.flags() & std::ios::basefield; // Get base digits.
-	int base, block;
-	char suffix;
-	switch(f)
-	{
-	case std::ios::oct :
-		base = 8;
-		block = 8;
-		suffix = 'o';
-		break;
-	case std::ios::hex :
-		base = 16;
-		block = 4;
-		suffix = 'h';
-		break;
-	default :
-		base = 10;
-		block = 3;
-		suffix = '.';
-	}
-
-	SecBlock<char> s(a.BitCount() / (BitPrecision(base)-1) + 1);
-	Integer temp1=a, temp2;
-	unsigned i=0;
-	const char vec[]="0123456789ABCDEF";
-
-	if (a.IsNegative())
-	{
-		out << '-';
-		temp1.Negate();
-	}
-
-	if (!a)
-		out << '0';
-
-	while (!!temp1)
-	{
-		word digit;
-		Integer::Divide(digit, temp2, temp1, base);
-		s[i++]=vec[digit];
-		temp1=temp2;
-	}
-
-	while (i--)
-	{
-		out << s[i];
-//		if (i && !(i%block))
-//			out << ",";
-	}
-	return out << suffix;
-}
-
-Integer& Integer::operator++()
-{
-	if (NotNegative())
-	{
-		if (Increment(reg, reg.size()))
-		{
-			reg.CleanGrow(2*reg.size());
-			reg[reg.size()/2]=1;
-		}
-	}
-	else
-	{
-		word borrow = Decrement(reg, reg.size());
-		assert(!borrow);
-		if (WordCount()==0)
-			*this = Zero();
-	}
-	return *this;
-}
-
-Integer& Integer::operator--()
-{
-	if (IsNegative())
-	{
-		if (Increment(reg, reg.size()))
-		{
-			reg.CleanGrow(2*reg.size());
-			reg[reg.size()/2]=1;
-		}
-	}
-	else
-	{
-		if (Decrement(reg, reg.size()))
-			*this = -One();
-	}
-	return *this;
-}
-
-void PositiveAdd(Integer &sum, const Integer &a, const Integer& b)
-{
-	word carry;
-	if (a.reg.size() == b.reg.size())
-		carry = Add(sum.reg, a.reg, b.reg, a.reg.size());
-	else if (a.reg.size() > b.reg.size())
-	{
-		carry = Add(sum.reg, a.reg, b.reg, b.reg.size());
-		CopyWords(sum.reg+b.reg.size(), a.reg+b.reg.size(), a.reg.size()-b.reg.size());
-		carry = Increment(sum.reg+b.reg.size(), a.reg.size()-b.reg.size(), carry);
-	}
-	else
-	{
-		carry = Add(sum.reg, a.reg, b.reg, a.reg.size());
-		CopyWords(sum.reg+a.reg.size(), b.reg+a.reg.size(), b.reg.size()-a.reg.size());
-		carry = Increment(sum.reg+a.reg.size(), b.reg.size()-a.reg.size(), carry);
-	}
-
-	if (carry)
-	{
-		sum.reg.CleanGrow(2*sum.reg.size());
-		sum.reg[sum.reg.size()/2] = 1;
-	}
-	sum.sign = Integer::POSITIVE;
-}
-
-void PositiveSubtract(Integer &diff, const Integer &a, const Integer& b)
-{
-	unsigned aSize = a.WordCount();
-	aSize += aSize%2;
-	unsigned bSize = b.WordCount();
-	bSize += bSize%2;
-
-	if (aSize == bSize)
-	{
-		if (Compare(a.reg, b.reg, aSize) >= 0)
-		{
-			Subtract(diff.reg, a.reg, b.reg, aSize);
-			diff.sign = Integer::POSITIVE;
-		}
-		else
-		{
-			Subtract(diff.reg, b.reg, a.reg, aSize);
-			diff.sign = Integer::NEGATIVE;
-		}
-	}
-	else if (aSize > bSize)
-	{
-		word borrow = Subtract(diff.reg, a.reg, b.reg, bSize);
-		CopyWords(diff.reg+bSize, a.reg+bSize, aSize-bSize);
-		borrow = Decrement(diff.reg+bSize, aSize-bSize, borrow);
-		assert(!borrow);
-		diff.sign = Integer::POSITIVE;
-	}
-	else
-	{
-		word borrow = Subtract(diff.reg, b.reg, a.reg, aSize);
-		CopyWords(diff.reg+aSize, b.reg+aSize, bSize-aSize);
-		borrow = Decrement(diff.reg+aSize, bSize-aSize, borrow);
-		assert(!borrow);
-		diff.sign = Integer::NEGATIVE;
-	}
-}
-
-Integer Integer::Plus(const Integer& b) const
-{
-	Integer sum((word)0, STDMAX(reg.size(), b.reg.size()));
-	if (NotNegative())
-	{
-		if (b.NotNegative())
-			PositiveAdd(sum, *this, b);
-		else
-			PositiveSubtract(sum, *this, b);
-	}
-	else
-	{
-		if (b.NotNegative())
-			PositiveSubtract(sum, b, *this);
-		else
-		{
-			PositiveAdd(sum, *this, b);
-			sum.sign = Integer::NEGATIVE;
-		}
-	}
-	return sum;
-}
-
-Integer& Integer::operator+=(const Integer& t)
-{
-	reg.CleanGrow(t.reg.size());
-	if (NotNegative())
-	{
-		if (t.NotNegative())
-			PositiveAdd(*this, *this, t);
-		else
-			PositiveSubtract(*this, *this, t);
-	}
-	else
-	{
-		if (t.NotNegative())
-			PositiveSubtract(*this, t, *this);
-		else
-		{
-			PositiveAdd(*this, *this, t);
-			sign = Integer::NEGATIVE;
-		}
-	}
-	return *this;
-}
-
-Integer Integer::Minus(const Integer& b) const
-{
-	Integer diff((word)0, STDMAX(reg.size(), b.reg.size()));
-	if (NotNegative())
-	{
-		if (b.NotNegative())
-			PositiveSubtract(diff, *this, b);
-		else
-			PositiveAdd(diff, *this, b);
-	}
-	else
-	{
-		if (b.NotNegative())
-		{
-			PositiveAdd(diff, *this, b);
-			diff.sign = Integer::NEGATIVE;
-		}
-		else
-			PositiveSubtract(diff, b, *this);
-	}
-	return diff;
-}
-
-Integer& Integer::operator-=(const Integer& t)
-{
-	reg.CleanGrow(t.reg.size());
-	if (NotNegative())
-	{
-		if (t.NotNegative())
-			PositiveSubtract(*this, *this, t);
-		else
-			PositiveAdd(*this, *this, t);
-	}
-	else
-	{
-		if (t.NotNegative())
-		{
-			PositiveAdd(*this, *this, t);
-			sign = Integer::NEGATIVE;
-		}
-		else
-			PositiveSubtract(*this, t, *this);
-	}
-	return *this;
-}
-
-Integer& Integer::operator<<=(unsigned int n)
-{
-	const unsigned int wordCount = WordCount();
-	const unsigned int shiftWords = n / WORD_BITS;
-	const unsigned int shiftBits = n % WORD_BITS;
-
-	reg.CleanGrow(RoundupSize(wordCount+BitsToWords(n)));
-	ShiftWordsLeftByWords(reg, wordCount + shiftWords, shiftWords);
-	ShiftWordsLeftByBits(reg+shiftWords, wordCount+BitsToWords(shiftBits), shiftBits);
-	return *this;
-}
-
-Integer& Integer::operator>>=(unsigned int n)
-{
-	const unsigned int wordCount = WordCount();
-	const unsigned int shiftWords = n / WORD_BITS;
-	const unsigned int shiftBits = n % WORD_BITS;
-
-	ShiftWordsRightByWords(reg, wordCount, shiftWords);
-	if (wordCount > shiftWords)
-		ShiftWordsRightByBits(reg, wordCount-shiftWords, shiftBits);
-	if (IsNegative() && WordCount()==0)   // avoid -0
-		*this = Zero();
-	return *this;
-}
-
-void PositiveMultiply(Integer &product, const Integer &a, const Integer &b)
-{
-	unsigned aSize = RoundupSize(a.WordCount());
-	unsigned bSize = RoundupSize(b.WordCount());
-
-	product.reg.CleanNew(RoundupSize(aSize+bSize));
-	product.sign = Integer::POSITIVE;
-
-	SecAlignedWordBlock workspace(aSize + bSize);
-	AsymmetricMultiply(product.reg, workspace, a.reg, aSize, b.reg, bSize);
-}
-
-void Multiply(Integer &product, const Integer &a, const Integer &b)
-{
-	PositiveMultiply(product, a, b);
-
-	if (a.NotNegative() != b.NotNegative())
-		product.Negate();
-}
-
-Integer Integer::Times(const Integer &b) const
-{
-	Integer product;
-	Multiply(product, *this, b);
-	return product;
-}
-
-/*
-void PositiveDivide(Integer &remainder, Integer &quotient,
-				   const Integer &dividend, const Integer &divisor)
-{
-	remainder.reg.CleanNew(divisor.reg.size());
-	remainder.sign = Integer::POSITIVE;
-	quotient.reg.New(0);
-	quotient.sign = Integer::POSITIVE;
-	unsigned i=dividend.BitCount();
-	while (i--)
-	{
-		word overflow = ShiftWordsLeftByBits(remainder.reg, remainder.reg.size(), 1);
-		remainder.reg[0] |= dividend[i];
-		if (overflow || remainder >= divisor)
-		{
-			Subtract(remainder.reg, remainder.reg, divisor.reg, remainder.reg.size());
-			quotient.SetBit(i);
-		}
-	}
-}
-*/
-
-void PositiveDivide(Integer &remainder, Integer &quotient,
-				   const Integer &a, const Integer &b)
-{
-	unsigned aSize = a.WordCount();
-	unsigned bSize = b.WordCount();
-
-	if (!bSize)
-		throw Integer::DivideByZero();
-
-	if (a.PositiveCompare(b) == -1)
-	{
-		remainder = a;
-		remainder.sign = Integer::POSITIVE;
-		quotient = Integer::Zero();
-		return;
-	}
-
-	aSize += aSize%2;	// round up to next even number
-	bSize += bSize%2;
-
-	remainder.reg.CleanNew(RoundupSize(bSize));
-	remainder.sign = Integer::POSITIVE;
-	quotient.reg.CleanNew(RoundupSize(aSize-bSize+2));
-	quotient.sign = Integer::POSITIVE;
-
-	SecAlignedWordBlock T(aSize+2*bSize+4);
-	Divide(remainder.reg, quotient.reg, T, a.reg, aSize, b.reg, bSize);
-}
-
-void Integer::Divide(Integer &remainder, Integer &quotient, const Integer &dividend, const Integer &divisor)
-{
-	PositiveDivide(remainder, quotient, dividend, divisor);
-
-	if (dividend.IsNegative())
-	{
-		quotient.Negate();
-		if (remainder.NotZero())
-		{
-			--quotient;
-			remainder = divisor.AbsoluteValue() - remainder;
-		}
-	}
-
-	if (divisor.IsNegative())
-		quotient.Negate();
-}
-
-void Integer::DivideByPowerOf2(Integer &r, Integer &q, const Integer &a, unsigned int n)
-{
-	q = a;
-	q >>= n;
-
-	const unsigned int wordCount = BitsToWords(n);
-	if (wordCount <= a.WordCount())
-	{
-		r.reg.resize(RoundupSize(wordCount));
-		CopyWords(r.reg, a.reg, wordCount);
-		SetWords(r.reg+wordCount, 0, r.reg.size()-wordCount);
-		if (n % WORD_BITS != 0)
-			r.reg[wordCount-1] %= (1 << (n % WORD_BITS));
-	}
-	else
-	{
-		r.reg.resize(RoundupSize(a.WordCount()));
-		CopyWords(r.reg, a.reg, r.reg.size());
-	}
-	r.sign = POSITIVE;
-
-	if (a.IsNegative() && r.NotZero())
-	{
-		--q;
-		r = Power2(n) - r;
-	}
-}
-
-Integer Integer::DividedBy(const Integer &b) const
-{
-	Integer remainder, quotient;
-	Integer::Divide(remainder, quotient, *this, b);
-	return quotient;
-}
-
-Integer Integer::Modulo(const Integer &b) const
-{
-	Integer remainder, quotient;
-	Integer::Divide(remainder, quotient, *this, b);
-	return remainder;
-}
-
-void Integer::Divide(word &remainder, Integer &quotient, const Integer &dividend, word divisor)
-{
-	if (!divisor)
-		throw Integer::DivideByZero();
-
-	assert(divisor);
-
-	if ((divisor & (divisor-1)) == 0)	// divisor is a power of 2
-	{
-		quotient = dividend >> (BitPrecision(divisor)-1);
-		remainder = dividend.reg[0] & (divisor-1);
-		return;
-	}
-
-	unsigned int i = dividend.WordCount();
-	quotient.reg.CleanNew(RoundupSize(i));
-	remainder = 0;
-	while (i--)
-	{
-		quotient.reg[i] = word(MAKE_DWORD(dividend.reg[i], remainder) / divisor);
-		remainder = word(MAKE_DWORD(dividend.reg[i], remainder) % divisor);
-	}
-
-	if (dividend.NotNegative())
-		quotient.sign = POSITIVE;
-	else
-	{
-		quotient.sign = NEGATIVE;
-		if (remainder)
-		{
-			--quotient;
-			remainder = divisor - remainder;
-		}
-	}
-}
-
-Integer Integer::DividedBy(word b) const
-{
-	word remainder;
-	Integer quotient;
-	Integer::Divide(remainder, quotient, *this, b);
-	return quotient;
-}
-
-word Integer::Modulo(word divisor) const
-{
-	if (!divisor)
-		throw Integer::DivideByZero();
-
-	assert(divisor);
-
-	word remainder;
-
-	if ((divisor & (divisor-1)) == 0)	// divisor is a power of 2
-		remainder = reg[0] & (divisor-1);
-	else
-	{
-		unsigned int i = WordCount();
-
-		if (divisor <= 5)
-		{
-			dword sum=0;
-			while (i--)
-				sum += reg[i];
-			remainder = word(sum%divisor);
-		}
-		else
-		{
-			remainder = 0;
-			while (i--)
-				remainder = word(MAKE_DWORD(reg[i], remainder) % divisor);
-		}
-	}
-
-	if (IsNegative() && remainder)
-		remainder = divisor - remainder;
-
-	return remainder;
-}
-
-void Integer::Negate()
-{
-	if (!!(*this))	// don't flip sign if *this==0
-		sign = Sign(1-sign);
-}
-
-int Integer::PositiveCompare(const Integer& t) const
-{
-	unsigned size = WordCount(), tSize = t.WordCount();
-
-	if (size == tSize)
-		return CryptoPP::Compare(reg, t.reg, size);
-	else
-		return size > tSize ? 1 : -1;
-}
-
-int Integer::Compare(const Integer& t) const
-{
-	if (NotNegative())
-	{
-		if (t.NotNegative())
-			return PositiveCompare(t);
-		else
-			return 1;
-	}
-	else
-	{
-		if (t.NotNegative())
-			return -1;
-		else
-			return -PositiveCompare(t);
-	}
-}
-
-Integer Integer::SquareRoot() const
-{
-	if (!IsPositive())
-		return Zero();
-
-	// overestimate square root
-	Integer x, y = Power2((BitCount()+1)/2);
-	assert(y*y >= *this);
-
-	do
-	{
-		x = y;
-		y = (x + *this/x) >> 1;
-	} while (y<x);
-
-	return x;
-}
-
-bool Integer::IsSquare() const
-{
-	Integer r = SquareRoot();
-	return *this == r.Squared();
-}
-
-bool Integer::IsUnit() const
-{
-	return (WordCount() == 1) && (reg[0] == 1);
-}
-
-Integer Integer::MultiplicativeInverse() const
-{
-	return IsUnit() ? *this : Zero();
-}
-
-Integer a_times_b_mod_c(const Integer &x, const Integer& y, const Integer& m)
-{
-	return x*y%m;
-}
-
-Integer a_exp_b_mod_c(const Integer &x, const Integer& e, const Integer& m)
-{
-	ModularArithmetic mr(m);
-	return mr.Exponentiate(x, e);
-}
-
-Integer Integer::Gcd(const Integer &a, const Integer &b)
-{
-	return EuclideanDomainOf<Integer>().Gcd(a, b);
-}
-
-Integer Integer::InverseMod(const Integer &m) const
-{
-	assert(m.NotNegative());
-
-	if (IsNegative() || *this>=m)
-		return (*this%m).InverseMod(m);
-
-	if (m.IsEven())
-	{
-		if (!m || IsEven())
-			return Zero();	// no inverse
-		if (*this == One())
-			return One();
-
-		Integer u = m.InverseMod(*this);
-		return !u ? Zero() : (m*(*this-u)+1)/(*this);
-	}
-
-	SecBlock<word> T(m.reg.size() * 4);
-	Integer r((word)0, m.reg.size());
-	unsigned k = AlmostInverse(r.reg, T, reg, reg.size(), m.reg, m.reg.size());
-	DivideByPower2Mod(r.reg, r.reg, k, m.reg, m.reg.size());
-	return r;
-}
-
-word Integer::InverseMod(const word mod) const
-{
-	word g0 = mod, g1 = *this % mod;
-	word v0 = 0, v1 = 1;
-	word y;
-
-	while (g1)
-	{
-		if (g1 == 1)
-			return v1;
-		y = g0 / g1;
-		g0 = g0 % g1;
-		v0 += y * v1;
-
-		if (!g0)
-			break;
-		if (g0 == 1)
-			return mod-v0;
-		y = g1 / g0;
-		g1 = g1 % g0;
-		v1 += y * v0;
-	}
-	return 0;
-}
-
-// ********************************************************
-
-ModularArithmetic::ModularArithmetic(BufferedTransformation &bt)
-{
-	BERSequenceDecoder seq(bt);
-	OID oid(seq);
-	if (oid != ASN1::prime_field())
-		BERDecodeError();
-	modulus.BERDecode(seq);
-	seq.MessageEnd();
-	result.reg.resize(modulus.reg.size());
-}
-
-void ModularArithmetic::DEREncode(BufferedTransformation &bt) const
-{
-	DERSequenceEncoder seq(bt);
-	ASN1::prime_field().DEREncode(seq);
-	modulus.DEREncode(seq);
-	seq.MessageEnd();
-}
-
-void ModularArithmetic::DEREncodeElement(BufferedTransformation &out, const Element &a) const
-{
-	a.DEREncodeAsOctetString(out, MaxElementByteLength());
-}
-
-void ModularArithmetic::BERDecodeElement(BufferedTransformation &in, Element &a) const
-{
-	a.BERDecodeAsOctetString(in, MaxElementByteLength());
-}
-
-const Integer& ModularArithmetic::Half(const Integer &a) const
-{
-	if (a.reg.size()==modulus.reg.size())
-	{
-		CryptoPP::DivideByPower2Mod(result.reg.begin(), a.reg, 1, modulus.reg, a.reg.size());
-		return result;
-	}
-	else
-		return result1 = (a.IsEven() ? (a >> 1) : ((a+modulus) >> 1));
-}
-
-const Integer& ModularArithmetic::Add(const Integer &a, const Integer &b) const
-{
-	if (a.reg.size()==modulus.reg.size() && b.reg.size()==modulus.reg.size())
-	{
-		if (CryptoPP::Add(result.reg.begin(), a.reg, b.reg, a.reg.size())
-			|| Compare(result.reg, modulus.reg, a.reg.size()) >= 0)
-		{
-			CryptoPP::Subtract(result.reg.begin(), result.reg, modulus.reg, a.reg.size());
-		}
-		return result;
-	}
-	else
-	{
-		result1 = a+b;
-		if (result1 >= modulus)
-			result1 -= modulus;
-		return result1;
-	}
-}
-
-Integer& ModularArithmetic::Accumulate(Integer &a, const Integer &b) const
-{
-	if (a.reg.size()==modulus.reg.size() && b.reg.size()==modulus.reg.size())
-	{
-		if (CryptoPP::Add(a.reg, a.reg, b.reg, a.reg.size())
-			|| Compare(a.reg, modulus.reg, a.reg.size()) >= 0)
-		{
-			CryptoPP::Subtract(a.reg, a.reg, modulus.reg, a.reg.size());
-		}
-	}
-	else
-	{
-		a+=b;
-		if (a>=modulus)
-			a-=modulus;
-	}
-
-	return a;
-}
-
-const Integer& ModularArithmetic::Subtract(const Integer &a, const Integer &b) const
-{
-	if (a.reg.size()==modulus.reg.size() && b.reg.size()==modulus.reg.size())
-	{
-		if (CryptoPP::Subtract(result.reg.begin(), a.reg, b.reg, a.reg.size()))
-			CryptoPP::Add(result.reg.begin(), result.reg, modulus.reg, a.reg.size());
-		return result;
-	}
-	else
-	{
-		result1 = a-b;
-		if (result1.IsNegative())
-			result1 += modulus;
-		return result1;
-	}
-}
-
-Integer& ModularArithmetic::Reduce(Integer &a, const Integer &b) const
-{
-	if (a.reg.size()==modulus.reg.size() && b.reg.size()==modulus.reg.size())
-	{
-		if (CryptoPP::Subtract(a.reg, a.reg, b.reg, a.reg.size()))
-			CryptoPP::Add(a.reg, a.reg, modulus.reg, a.reg.size());
-	}
-	else
-	{
-		a-=b;
-		if (a.IsNegative())
-			a+=modulus;
-	}
-
-	return a;
-}
-
-const Integer& ModularArithmetic::Inverse(const Integer &a) const
-{
-	if (!a)
-		return a;
-
-	CopyWords(result.reg.begin(), modulus.reg, modulus.reg.size());
-	if (CryptoPP::Subtract(result.reg.begin(), result.reg, a.reg, a.reg.size()))
-		Decrement(result.reg.begin()+a.reg.size(), 1, modulus.reg.size()-a.reg.size());
-
-	return result;
-}
-
-Integer ModularArithmetic::CascadeExponentiate(const Integer &x, const Integer &e1, const Integer &y, const Integer &e2) const
-{
-	if (modulus.IsOdd())
-	{
-		MontgomeryRepresentation dr(modulus);
-		return dr.ConvertOut(dr.CascadeExponentiate(dr.ConvertIn(x), e1, dr.ConvertIn(y), e2));
-	}
-	else
-		return AbstractRing<Integer>::CascadeExponentiate(x, e1, y, e2);
-}
-
-void ModularArithmetic::SimultaneousExponentiate(Integer *results, const Integer &base, const Integer *exponents, unsigned int exponentsCount) const
-{
-	if (modulus.IsOdd())
-	{
-		MontgomeryRepresentation dr(modulus);
-		dr.SimultaneousExponentiate(results, dr.ConvertIn(base), exponents, exponentsCount);
-		for (unsigned int i=0; i<exponentsCount; i++)
-			results[i] = dr.ConvertOut(results[i]);
-	}
-	else
-		AbstractRing<Integer>::SimultaneousExponentiate(results, base, exponents, exponentsCount);
-}
-
-MontgomeryRepresentation::MontgomeryRepresentation(const Integer &m)	// modulus must be odd
-	: ModularArithmetic(m),
-	  u((word)0, modulus.reg.size()),
-	  workspace(5*modulus.reg.size())
-{
-	if (!modulus.IsOdd())
-		throw InvalidArgument("MontgomeryRepresentation: Montgomery representation requires an odd modulus");
-
-	RecursiveInverseModPower2(u.reg, workspace, modulus.reg, modulus.reg.size());
-}
-
-const Integer& MontgomeryRepresentation::Multiply(const Integer &a, const Integer &b) const
-{
-	word *const T = workspace.begin();
-	word *const R = result.reg.begin();
-	const unsigned int N = modulus.reg.size();
-	assert(a.reg.size()<=N && b.reg.size()<=N);
-
-	AsymmetricMultiply(T, T+2*N, a.reg, a.reg.size(), b.reg, b.reg.size());
-	SetWords(T+a.reg.size()+b.reg.size(), 0, 2*N-a.reg.size()-b.reg.size());
-	MontgomeryReduce(R, T+2*N, T, modulus.reg, u.reg, N);
-	return result;
-}
-
-const Integer& MontgomeryRepresentation::Square(const Integer &a) const
-{
-	word *const T = workspace.begin();
-	word *const R = result.reg.begin();
-	const unsigned int N = modulus.reg.size();
-	assert(a.reg.size()<=N);
-
-	CryptoPP::Square(T, T+2*N, a.reg, a.reg.size());
-	SetWords(T+2*a.reg.size(), 0, 2*N-2*a.reg.size());
-	MontgomeryReduce(R, T+2*N, T, modulus.reg, u.reg, N);
-	return result;
-}
-
-Integer MontgomeryRepresentation::ConvertOut(const Integer &a) const
-{
-	word *const T = workspace.begin();
-	word *const R = result.reg.begin();
-	const unsigned int N = modulus.reg.size();
-	assert(a.reg.size()<=N);
-
-	CopyWords(T, a.reg, a.reg.size());
-	SetWords(T+a.reg.size(), 0, 2*N-a.reg.size());
-	MontgomeryReduce(R, T+2*N, T, modulus.reg, u.reg, N);
-	return result;
-}
-
-const Integer& MontgomeryRepresentation::MultiplicativeInverse(const Integer &a) const
-{
-//	  return (EuclideanMultiplicativeInverse(a, modulus)<<(2*WORD_BITS*modulus.reg.size()))%modulus;
-	word *const T = workspace.begin();
-	word *const R = result.reg.begin();
-	const unsigned int N = modulus.reg.size();
-	assert(a.reg.size()<=N);
-
-	CopyWords(T, a.reg, a.reg.size());
-	SetWords(T+a.reg.size(), 0, 2*N-a.reg.size());
-	MontgomeryReduce(R, T+2*N, T, modulus.reg, u.reg, N);
-	unsigned k = AlmostInverse(R, T, R, N, modulus.reg, N);
-
-//	cout << "k=" << k << " N*32=" << 32*N << endl;
-
-	if (k>N*WORD_BITS)
-		DivideByPower2Mod(R, R, k-N*WORD_BITS, modulus.reg, N);
-	else
-		MultiplyByPower2Mod(R, R, N*WORD_BITS-k, modulus.reg, N);
-
-	return result;
-}
-
-template class AbstractRing<Integer>;    
-
-NAMESPACE_END
+// integer.cpp - written and placed in the public domain by Wei Dai
+// contains public domain code contributed by Alister Lee and Leonard Janke
+
+#include "pch.h"
+
+#ifndef CRYPTOPP_IMPORTS
+
+#include "integer.h"
+#include "modarith.h"
+#include "nbtheory.h"
+#include "asn.h"
+#include "oids.h"
+#include "words.h"
+#include "algparam.h"
+#include "pubkey.h"		// for P1363_KDF2
+#include "sha.h"
+#include "cpu.h"
+
+#include <iostream>
+
+#if _MSC_VER >= 1400
+	#include <intrin.h>
+#endif
+
+#ifdef __DECCXX
+	#include <c_asm.h>
+#endif
+
+#ifdef CRYPTOPP_MSVC6_NO_PP
+	#pragma message("You do not seem to have the Visual C++ Processor Pack installed, so use of SSE2 instructions will be disabled.")
+#endif
+
+#define CRYPTOPP_INTEGER_SSE2 (CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE && CRYPTOPP_BOOL_X86)
+
+NAMESPACE_BEGIN(CryptoPP)
+
+bool AssignIntToInteger(const std::type_info &valueType, void *pInteger, const void *pInt)
+{
+	if (valueType != typeid(Integer))
+		return false;
+	*reinterpret_cast<Integer *>(pInteger) = *reinterpret_cast<const int *>(pInt);
+	return true;
+}
+
+inline static int Compare(const word *A, const word *B, size_t N)
+{
+	while (N--)
+		if (A[N] > B[N])
+			return 1;
+		else if (A[N] < B[N])
+			return -1;
+
+	return 0;
+}
+
+inline static int Increment(word *A, size_t N, word B=1)
+{
+	assert(N);
+	word t = A[0];
+	A[0] = t+B;
+	if (A[0] >= t)
+		return 0;
+	for (unsigned i=1; i<N; i++)
+		if (++A[i])
+			return 0;
+	return 1;
+}
+
+inline static int Decrement(word *A, size_t N, word B=1)
+{
+	assert(N);
+	word t = A[0];
+	A[0] = t-B;
+	if (A[0] <= t)
+		return 0;
+	for (unsigned i=1; i<N; i++)
+		if (A[i]--)
+			return 0;
+	return 1;
+}
+
+static void TwosComplement(word *A, size_t N)
+{
+	Decrement(A, N);
+	for (unsigned i=0; i<N; i++)
+		A[i] = ~A[i];
+}
+
+static word AtomicInverseModPower2(word A)
+{
+	assert(A%2==1);
+
+	word R=A%8;
+
+	for (unsigned i=3; i<WORD_BITS; i*=2)
+		R = R*(2-R*A);
+
+	assert(R*A==1);
+	return R;
+}
+
+// ********************************************************
+
+#if !defined(CRYPTOPP_NATIVE_DWORD_AVAILABLE) || (defined(__x86_64__) && defined(CRYPTOPP_WORD128_AVAILABLE))
+	#define Declare2Words(x)			word x##0, x##1;
+	#define AssignWord(a, b)			a##0 = b; a##1 = 0;
+	#define Add2WordsBy1(a, b, c)		a##0 = b##0 + c; a##1 = b##1 + (a##0 < c);
+	#define LowWord(a)					a##0
+	#define HighWord(a)					a##1
+	#ifdef _MSC_VER
+		#define MultiplyWordsLoHi(p0, p1, a, b)		p0 = _umul128(a, b, &p1);
+		#ifndef __INTEL_COMPILER
+			#define Double3Words(c, d)		d##1 = __shiftleft128(d##0, d##1, 1); d##0 = __shiftleft128(c, d##0, 1); c *= 2;
+		#endif
+	#elif defined(__DECCXX)
+		#define MultiplyWordsLoHi(p0, p1, a, b)		p0 = a*b; p1 = asm("umulh %a0, %a1, %v0", a, b);
+	#elif defined(__x86_64__)
+		#if defined(__SUNPRO_CC) && __SUNPRO_CC < 0x5100
+			// Sun Studio's gcc-style inline assembly is heavily bugged as of version 5.9 Patch 124864-09 2008/12/16, but this one works
+			#define MultiplyWordsLoHi(p0, p1, a, b)		asm ("mulq %3" : "=a"(p0), "=d"(p1) : "a"(a), "r"(b) : "cc");
+		#else
+			#define MultiplyWordsLoHi(p0, p1, a, b)		asm ("mulq %3" : "=a"(p0), "=d"(p1) : "a"(a), "g"(b) : "cc");
+			#define MulAcc(c, d, a, b)		asm ("mulq %6; addq %3, %0; adcq %4, %1; adcq $0, %2;" : "+r"(c), "+r"(d##0), "+r"(d##1), "=a"(p0), "=d"(p1) : "a"(a), "g"(b) : "cc");
+			#define Double3Words(c, d)		asm ("addq %0, %0; adcq %1, %1; adcq %2, %2;" : "+r"(c), "+r"(d##0), "+r"(d##1) : : "cc");
+			#define Acc2WordsBy1(a, b)		asm ("addq %2, %0; adcq $0, %1;" : "+r"(a##0), "+r"(a##1) : "r"(b) : "cc");
+			#define Acc2WordsBy2(a, b)		asm ("addq %2, %0; adcq %3, %1;" : "+r"(a##0), "+r"(a##1) : "r"(b##0), "r"(b##1) : "cc");
+			#define Acc3WordsBy2(c, d, e)	asm ("addq %5, %0; adcq %6, %1; adcq $0, %2;" : "+r"(c), "=r"(e##0), "=r"(e##1) : "1"(d##0), "2"(d##1), "r"(e##0), "r"(e##1) : "cc");
+		#endif
+	#endif
+	#define MultiplyWords(p, a, b)		MultiplyWordsLoHi(p##0, p##1, a, b)
+	#ifndef Double3Words
+		#define Double3Words(c, d)		d##1 = 2*d##1 + (d##0>>(WORD_BITS-1)); d##0 = 2*d##0 + (c>>(WORD_BITS-1)); c *= 2;
+	#endif
+	#ifndef Acc2WordsBy2
+		#define Acc2WordsBy2(a, b)		a##0 += b##0; a##1 += a##0 < b##0; a##1 += b##1;
+	#endif
+	#define AddWithCarry(u, a, b)		{word t = a+b; u##0 = t + u##1; u##1 = (t<a) + (u##0<t);}
+	#define SubtractWithBorrow(u, a, b)	{word t = a-b; u##0 = t - u##1; u##1 = (t>a) + (u##0>t);}
+	#define GetCarry(u)					u##1
+	#define GetBorrow(u)				u##1
+#else
+	#define Declare2Words(x)			dword x;
+	#if _MSC_VER >= 1400 && !defined(__INTEL_COMPILER)
+		#define MultiplyWords(p, a, b)		p = __emulu(a, b);
+	#else
+		#define MultiplyWords(p, a, b)		p = (dword)a*b;
+	#endif
+	#define AssignWord(a, b)			a = b;
+	#define Add2WordsBy1(a, b, c)		a = b + c;
+	#define Acc2WordsBy2(a, b)			a += b;
+	#define LowWord(a)					word(a)
+	#define HighWord(a)					word(a>>WORD_BITS)
+	#define Double3Words(c, d)			d = 2*d + (c>>(WORD_BITS-1)); c *= 2;
+	#define AddWithCarry(u, a, b)		u = dword(a) + b + GetCarry(u);
+	#define SubtractWithBorrow(u, a, b)	u = dword(a) - b - GetBorrow(u);
+	#define GetCarry(u)					HighWord(u)
+	#define GetBorrow(u)				word(u>>(WORD_BITS*2-1))
+#endif
+#ifndef MulAcc
+	#define MulAcc(c, d, a, b)			MultiplyWords(p, a, b); Acc2WordsBy1(p, c); c = LowWord(p); Acc2WordsBy1(d, HighWord(p));
+#endif
+#ifndef Acc2WordsBy1
+	#define Acc2WordsBy1(a, b)			Add2WordsBy1(a, a, b)
+#endif
+#ifndef Acc3WordsBy2
+	#define Acc3WordsBy2(c, d, e)		Acc2WordsBy1(e, c); c = LowWord(e); Add2WordsBy1(e, d, HighWord(e));
+#endif
+
+class DWord
+{
+public:
+	DWord() {}
+
+#ifdef CRYPTOPP_NATIVE_DWORD_AVAILABLE
+	explicit DWord(word low)
+	{
+		m_whole = low;
+	}
+#else
+	explicit DWord(word low)
+	{
+		m_halfs.low = low;
+		m_halfs.high = 0;
+	}
+#endif
+
+	DWord(word low, word high)
+	{
+		m_halfs.low = low;
+		m_halfs.high = high;
+	}
+
+	static DWord Multiply(word a, word b)
+	{
+		DWord r;
+		#ifdef CRYPTOPP_NATIVE_DWORD_AVAILABLE
+			r.m_whole = (dword)a * b;
+		#elif defined(MultiplyWordsLoHi)
+			MultiplyWordsLoHi(r.m_halfs.low, r.m_halfs.high, a, b);
+		#endif
+		return r;
+	}
+
+	static DWord MultiplyAndAdd(word a, word b, word c)
+	{
+		DWord r = Multiply(a, b);
+		return r += c;
+	}
+
+	DWord & operator+=(word a)
+	{
+		#ifdef CRYPTOPP_NATIVE_DWORD_AVAILABLE
+			m_whole = m_whole + a;
+		#else
+			m_halfs.low += a;
+			m_halfs.high += (m_halfs.low < a);
+		#endif
+		return *this;
+	}
+
+	DWord operator+(word a)
+	{
+		DWord r;
+		#ifdef CRYPTOPP_NATIVE_DWORD_AVAILABLE
+			r.m_whole = m_whole + a;
+		#else
+			r.m_halfs.low = m_halfs.low + a;
+			r.m_halfs.high = m_halfs.high + (r.m_halfs.low < a);
+		#endif
+		return r;
+	}
+
+	DWord operator-(DWord a)
+	{
+		DWord r;
+		#ifdef CRYPTOPP_NATIVE_DWORD_AVAILABLE
+			r.m_whole = m_whole - a.m_whole;
+		#else
+			r.m_halfs.low = m_halfs.low - a.m_halfs.low;
+			r.m_halfs.high = m_halfs.high - a.m_halfs.high - (r.m_halfs.low > m_halfs.low);
+		#endif
+		return r;
+	}
+
+	DWord operator-(word a)
+	{
+		DWord r;
+		#ifdef CRYPTOPP_NATIVE_DWORD_AVAILABLE
+			r.m_whole = m_whole - a;
+		#else
+			r.m_halfs.low = m_halfs.low - a;
+			r.m_halfs.high = m_halfs.high - (r.m_halfs.low > m_halfs.low);
+		#endif
+		return r;
+	}
+
+	// returns quotient, which must fit in a word
+	word operator/(word divisor);
+
+	word operator%(word a);
+
+	bool operator!() const
+	{
+	#ifdef CRYPTOPP_NATIVE_DWORD_AVAILABLE
+		return !m_whole;
+	#else
+		return !m_halfs.high && !m_halfs.low;
+	#endif
+	}
+
+	word GetLowHalf() const {return m_halfs.low;}
+	word GetHighHalf() const {return m_halfs.high;}
+	word GetHighHalfAsBorrow() const {return 0-m_halfs.high;}
+
+private:
+	union
+	{
+	#ifdef CRYPTOPP_NATIVE_DWORD_AVAILABLE
+		dword m_whole;
+	#endif
+		struct
+		{
+		#ifdef IS_LITTLE_ENDIAN
+			word low;
+			word high;
+		#else
+			word high;
+			word low;
+		#endif
+		} m_halfs;
+	};
+};
+
+class Word
+{
+public:
+	Word() {}
+
+	Word(word value)
+	{
+		m_whole = value;
+	}
+
+	Word(hword low, hword high)
+	{
+		m_whole = low | (word(high) << (WORD_BITS/2));
+	}
+
+	static Word Multiply(hword a, hword b)
+	{
+		Word r;
+		r.m_whole = (word)a * b;
+		return r;
+	}
+
+	Word operator-(Word a)
+	{
+		Word r;
+		r.m_whole = m_whole - a.m_whole;
+		return r;
+	}
+
+	Word operator-(hword a)
+	{
+		Word r;
+		r.m_whole = m_whole - a;
+		return r;
+	}
+
+	// returns quotient, which must fit in a word
+	hword operator/(hword divisor)
+	{
+		return hword(m_whole / divisor);
+	}
+
+	bool operator!() const
+	{
+		return !m_whole;
+	}
+
+	word GetWhole() const {return m_whole;}
+	hword GetLowHalf() const {return hword(m_whole);}
+	hword GetHighHalf() const {return hword(m_whole>>(WORD_BITS/2));}
+	hword GetHighHalfAsBorrow() const {return 0-hword(m_whole>>(WORD_BITS/2));}
+	
+private:
+	word m_whole;
+};
+
+// do a 3 word by 2 word divide, returns quotient and leaves remainder in A
+template <class S, class D>
+S DivideThreeWordsByTwo(S *A, S B0, S B1, D *dummy=NULL)
+{
+	// assert {A[2],A[1]} < {B1,B0}, so quotient can fit in a S
+	assert(A[2] < B1 || (A[2]==B1 && A[1] < B0));
+
+	// estimate the quotient: do a 2 S by 1 S divide
+	S Q;
+	if (S(B1+1) == 0)
+		Q = A[2];
+	else if (B1 > 0)
+		Q = D(A[1], A[2]) / S(B1+1);
+	else
+		Q = D(A[0], A[1]) / B0;
+
+	// now subtract Q*B from A
+	D p = D::Multiply(B0, Q);
+	D u = (D) A[0] - p.GetLowHalf();
+	A[0] = u.GetLowHalf();
+	u = (D) A[1] - p.GetHighHalf() - u.GetHighHalfAsBorrow() - D::Multiply(B1, Q);
+	A[1] = u.GetLowHalf();
+	A[2] += u.GetHighHalf();
+
+	// Q <= actual quotient, so fix it
+	while (A[2] || A[1] > B1 || (A[1]==B1 && A[0]>=B0))
+	{
+		u = (D) A[0] - B0;
+		A[0] = u.GetLowHalf();
+		u = (D) A[1] - B1 - u.GetHighHalfAsBorrow();
+		A[1] = u.GetLowHalf();
+		A[2] += u.GetHighHalf();
+		Q++;
+		assert(Q);	// shouldn't overflow
+	}
+
+	return Q;
+}
+
+// do a 4 word by 2 word divide, returns 2 word quotient in Q0 and Q1
+template <class S, class D>
+inline D DivideFourWordsByTwo(S *T, const D &Al, const D &Ah, const D &B)
+{
+	if (!B) // if divisor is 0, we assume divisor==2**(2*WORD_BITS)
+		return D(Ah.GetLowHalf(), Ah.GetHighHalf());
+	else
+	{
+		S Q[2];
+		T[0] = Al.GetLowHalf();
+		T[1] = Al.GetHighHalf(); 
+		T[2] = Ah.GetLowHalf();
+		T[3] = Ah.GetHighHalf();
+		Q[1] = DivideThreeWordsByTwo<S, D>(T+1, B.GetLowHalf(), B.GetHighHalf());
+		Q[0] = DivideThreeWordsByTwo<S, D>(T, B.GetLowHalf(), B.GetHighHalf());
+		return D(Q[0], Q[1]);
+	}
+}
+
+// returns quotient, which must fit in a word
+inline word DWord::operator/(word a)
+{
+	#ifdef CRYPTOPP_NATIVE_DWORD_AVAILABLE
+		return word(m_whole / a);
+	#else
+		hword r[4];
+		return DivideFourWordsByTwo<hword, Word>(r, m_halfs.low, m_halfs.high, a).GetWhole();
+	#endif
+}
+
+inline word DWord::operator%(word a)
+{
+	#ifdef CRYPTOPP_NATIVE_DWORD_AVAILABLE
+		return word(m_whole % a);
+	#else
+		if (a < (word(1) << (WORD_BITS/2)))
+		{
+			hword h = hword(a);
+			word r = m_halfs.high % h;
+			r = ((m_halfs.low >> (WORD_BITS/2)) + (r << (WORD_BITS/2))) % h;
+			return hword((hword(m_halfs.low) + (r << (WORD_BITS/2))) % h);
+		}
+		else
+		{
+			hword r[4];
+			DivideFourWordsByTwo<hword, Word>(r, m_halfs.low, m_halfs.high, a);
+			return Word(r[0], r[1]).GetWhole();
+		}
+	#endif
+}
+
+// ********************************************************
+
+// use some tricks to share assembly code between MSVC and GCC
+#if defined(__GNUC__)
+	#define AddPrologue \
+		int result;	\
+		__asm__ __volatile__ \
+		( \
+			".intel_syntax noprefix;"
+	#define AddEpilogue \
+			".att_syntax prefix;" \
+					: "=a" (result)\
+					: "d" (C), "a" (A), "D" (B), "c" (N) \
+					: "%esi", "memory", "cc" \
+		);\
+		return result;
+	#define MulPrologue \
+		__asm__ __volatile__ \
+		( \
+			".intel_syntax noprefix;" \
+			AS1(	push	ebx) \
+			AS2(	mov		ebx, edx)
+	#define MulEpilogue \
+			AS1(	pop		ebx) \
+			".att_syntax prefix;" \
+			: \
+			: "d" (s_maskLow16), "c" (C), "a" (A), "D" (B) \
+			: "%esi", "memory", "cc" \
+		);
+	#define SquPrologue		MulPrologue
+	#define SquEpilogue	\
+			AS1(	pop		ebx) \
+			".att_syntax prefix;" \
+			: \
+			: "d" (s_maskLow16), "c" (C), "a" (A) \
+			: "%esi", "%edi", "memory", "cc" \
+		);
+	#define TopPrologue		MulPrologue
+	#define TopEpilogue	\
+			AS1(	pop		ebx) \
+			".att_syntax prefix;" \
+			: \
+			: "d" (s_maskLow16), "c" (C), "a" (A), "D" (B), "S" (L) \
+			: "memory", "cc" \
+		);
+#else
+	#define AddPrologue \
+		__asm	push edi \
+		__asm	push esi \
+		__asm	mov		eax, [esp+12] \
+		__asm	mov		edi, [esp+16]
+	#define AddEpilogue \
+		__asm	pop esi \
+		__asm	pop edi \
+		__asm	ret 8
+#if _MSC_VER < 1300
+	#define SaveEBX		__asm push ebx
+	#define RestoreEBX	__asm pop ebx
+#else
+	#define SaveEBX
+	#define RestoreEBX
+#endif
+	#define SquPrologue					\
+		AS2(	mov		eax, A)			\
+		AS2(	mov		ecx, C)			\
+		SaveEBX							\
+		AS2(	lea		ebx, s_maskLow16)
+	#define MulPrologue					\
+		AS2(	mov		eax, A)			\
+		AS2(	mov		edi, B)			\
+		AS2(	mov		ecx, C)			\
+		SaveEBX							\
+		AS2(	lea		ebx, s_maskLow16)
+	#define TopPrologue					\
+		AS2(	mov		eax, A)			\
+		AS2(	mov		edi, B)			\
+		AS2(	mov		ecx, C)			\
+		AS2(	mov		esi, L)			\
+		SaveEBX							\
+		AS2(	lea		ebx, s_maskLow16)
+	#define SquEpilogue		RestoreEBX
+	#define MulEpilogue		RestoreEBX
+	#define TopEpilogue		RestoreEBX
+#endif
+
+#ifdef CRYPTOPP_X64_MASM_AVAILABLE
+extern "C" {
+int Baseline_Add(size_t N, word *C, const word *A, const word *B);
+int Baseline_Sub(size_t N, word *C, const word *A, const word *B);
+}
+#elif defined(CRYPTOPP_X64_ASM_AVAILABLE) && defined(__GNUC__) && defined(CRYPTOPP_WORD128_AVAILABLE)
+int Baseline_Add(size_t N, word *C, const word *A, const word *B)
+{
+	word result;
+	__asm__ __volatile__
+	(
+	".intel_syntax;"
+	AS1(	neg		%1)
+	ASJ(	jz,		1, f)
+	AS2(	mov		%0,[%3+8*%1])
+	AS2(	add		%0,[%4+8*%1])
+	AS2(	mov		[%2+8*%1],%0)
+	ASL(0)
+	AS2(	mov		%0,[%3+8*%1+8])
+	AS2(	adc		%0,[%4+8*%1+8])
+	AS2(	mov		[%2+8*%1+8],%0)
+	AS2(	lea		%1,[%1+2])
+	ASJ(	jrcxz,	1, f)
+	AS2(	mov		%0,[%3+8*%1])
+	AS2(	adc		%0,[%4+8*%1])
+	AS2(	mov		[%2+8*%1],%0)
+	ASJ(	jmp,	0, b)
+	ASL(1)
+	AS2(	mov		%0, 0)
+	AS2(	adc		%0, %0)
+	".att_syntax;"
+	: "=&r" (result), "+c" (N)
+	: "r" (C+N), "r" (A+N), "r" (B+N)
+	: "memory", "cc"
+	);
+	return (int)result;
+}
+
+int Baseline_Sub(size_t N, word *C, const word *A, const word *B)
+{
+	word result;
+	__asm__ __volatile__
+	(
+	".intel_syntax;"
+	AS1(	neg		%1)
+	ASJ(	jz,		1, f)
+	AS2(	mov		%0,[%3+8*%1])
+	AS2(	sub		%0,[%4+8*%1])
+	AS2(	mov		[%2+8*%1],%0)
+	ASL(0)
+	AS2(	mov		%0,[%3+8*%1+8])
+	AS2(	sbb		%0,[%4+8*%1+8])
+	AS2(	mov		[%2+8*%1+8],%0)
+	AS2(	lea		%1,[%1+2])
+	ASJ(	jrcxz,	1, f)
+	AS2(	mov		%0,[%3+8*%1])
+	AS2(	sbb		%0,[%4+8*%1])
+	AS2(	mov		[%2+8*%1],%0)
+	ASJ(	jmp,	0, b)
+	ASL(1)
+	AS2(	mov		%0, 0)
+	AS2(	adc		%0, %0)
+	".att_syntax;"
+	: "=&r" (result), "+c" (N)
+	: "r" (C+N), "r" (A+N), "r" (B+N)
+	: "memory", "cc"
+	);
+	return (int)result;
+}
+#elif defined(CRYPTOPP_X86_ASM_AVAILABLE) && CRYPTOPP_BOOL_X86
+CRYPTOPP_NAKED int CRYPTOPP_FASTCALL Baseline_Add(size_t N, word *C, const word *A, const word *B)
+{
+	AddPrologue
+
+	// now: eax = A, edi = B, edx = C, ecx = N
+	AS2(	lea		eax, [eax+4*ecx])
+	AS2(	lea		edi, [edi+4*ecx])
+	AS2(	lea		edx, [edx+4*ecx])
+
+	AS1(	neg		ecx)				// ecx is negative index
+	AS2(	test	ecx, 2)				// this clears carry flag
+	ASJ(	jz,		0, f)
+	AS2(	sub		ecx, 2)
+	ASJ(	jmp,	1, f)
+
+	ASL(0)
+	ASJ(	jecxz,	2, f)				// loop until ecx overflows and becomes zero
+	AS2(	mov		esi,[eax+4*ecx])
+	AS2(	adc		esi,[edi+4*ecx])
+	AS2(	mov		[edx+4*ecx],esi)
+	AS2(	mov		esi,[eax+4*ecx+4])
+	AS2(	adc		esi,[edi+4*ecx+4])
+	AS2(	mov		[edx+4*ecx+4],esi)
+	ASL(1)
+	AS2(	mov		esi,[eax+4*ecx+8])
+	AS2(	adc		esi,[edi+4*ecx+8])
+	AS2(	mov		[edx+4*ecx+8],esi)
+	AS2(	mov		esi,[eax+4*ecx+12])
+	AS2(	adc		esi,[edi+4*ecx+12])
+	AS2(	mov		[edx+4*ecx+12],esi)
+
+	AS2(	lea		ecx,[ecx+4])		// advance index, avoid inc which causes slowdown on Intel Core 2
+	ASJ(	jmp,	0, b)
+
+	ASL(2)
+	AS2(	mov		eax, 0)
+	AS1(	setc	al)					// store carry into eax (return result register)
+
+	AddEpilogue
+}
+
+CRYPTOPP_NAKED int CRYPTOPP_FASTCALL Baseline_Sub(size_t N, word *C, const word *A, const word *B)
+{
+	AddPrologue
+
+	// now: eax = A, edi = B, edx = C, ecx = N
+	AS2(	lea		eax, [eax+4*ecx])
+	AS2(	lea		edi, [edi+4*ecx])
+	AS2(	lea		edx, [edx+4*ecx])
+
+	AS1(	neg		ecx)				// ecx is negative index
+	AS2(	test	ecx, 2)				// this clears carry flag
+	ASJ(	jz,		0, f)
+	AS2(	sub		ecx, 2)
+	ASJ(	jmp,	1, f)
+
+	ASL(0)
+	ASJ(	jecxz,	2, f)				// loop until ecx overflows and becomes zero
+	AS2(	mov		esi,[eax+4*ecx])
+	AS2(	sbb		esi,[edi+4*ecx])
+	AS2(	mov		[edx+4*ecx],esi)
+	AS2(	mov		esi,[eax+4*ecx+4])
+	AS2(	sbb		esi,[edi+4*ecx+4])
+	AS2(	mov		[edx+4*ecx+4],esi)
+	ASL(1)
+	AS2(	mov		esi,[eax+4*ecx+8])
+	AS2(	sbb		esi,[edi+4*ecx+8])
+	AS2(	mov		[edx+4*ecx+8],esi)
+	AS2(	mov		esi,[eax+4*ecx+12])
+	AS2(	sbb		esi,[edi+4*ecx+12])
+	AS2(	mov		[edx+4*ecx+12],esi)
+
+	AS2(	lea		ecx,[ecx+4])		// advance index, avoid inc which causes slowdown on Intel Core 2
+	ASJ(	jmp,	0, b)
+
+	ASL(2)
+	AS2(	mov		eax, 0)
+	AS1(	setc	al)					// store carry into eax (return result register)
+
+	AddEpilogue
+}
+
+#if CRYPTOPP_INTEGER_SSE2
+CRYPTOPP_NAKED int CRYPTOPP_FASTCALL SSE2_Add(size_t N, word *C, const word *A, const word *B)
+{
+	AddPrologue
+
+	// now: eax = A, edi = B, edx = C, ecx = N
+	AS2(	lea		eax, [eax+4*ecx])
+	AS2(	lea		edi, [edi+4*ecx])
+	AS2(	lea		edx, [edx+4*ecx])
+
+	AS1(	neg		ecx)				// ecx is negative index
+	AS2(	pxor    mm2, mm2)
+	ASJ(	jz,		2, f)
+	AS2(	test	ecx, 2)				// this clears carry flag
+	ASJ(	jz,		0, f)
+	AS2(	sub		ecx, 2)
+	ASJ(	jmp,	1, f)
+
+	ASL(0)
+	AS2(	movd     mm0, DWORD PTR [eax+4*ecx])
+	AS2(	movd     mm1, DWORD PTR [edi+4*ecx])
+	AS2(	paddq    mm0, mm1)
+	AS2(	paddq	 mm2, mm0)
+	AS2(	movd	 DWORD PTR [edx+4*ecx], mm2)
+	AS2(	psrlq    mm2, 32)
+
+	AS2(	movd     mm0, DWORD PTR [eax+4*ecx+4])
+	AS2(	movd     mm1, DWORD PTR [edi+4*ecx+4])
+	AS2(	paddq    mm0, mm1)
+	AS2(	paddq	 mm2, mm0)
+	AS2(	movd	 DWORD PTR [edx+4*ecx+4], mm2)
+	AS2(	psrlq    mm2, 32)
+
+	ASL(1)
+	AS2(	movd     mm0, DWORD PTR [eax+4*ecx+8])
+	AS2(	movd     mm1, DWORD PTR [edi+4*ecx+8])
+	AS2(	paddq    mm0, mm1)
+	AS2(	paddq	 mm2, mm0)
+	AS2(	movd	 DWORD PTR [edx+4*ecx+8], mm2)
+	AS2(	psrlq    mm2, 32)
+
+	AS2(	movd     mm0, DWORD PTR [eax+4*ecx+12])
+	AS2(	movd     mm1, DWORD PTR [edi+4*ecx+12])
+	AS2(	paddq    mm0, mm1)
+	AS2(	paddq	 mm2, mm0)
+	AS2(	movd	 DWORD PTR [edx+4*ecx+12], mm2)
+	AS2(	psrlq    mm2, 32)
+
+	AS2(	add		ecx, 4)
+	ASJ(	jnz,	0, b)
+
+	ASL(2)
+	AS2(	movd	eax, mm2)
+	AS1(	emms)
+
+	AddEpilogue
+}
+CRYPTOPP_NAKED int CRYPTOPP_FASTCALL SSE2_Sub(size_t N, word *C, const word *A, const word *B)
+{
+	AddPrologue
+
+	// now: eax = A, edi = B, edx = C, ecx = N
+	AS2(	lea		eax, [eax+4*ecx])
+	AS2(	lea		edi, [edi+4*ecx])
+	AS2(	lea		edx, [edx+4*ecx])
+
+	AS1(	neg		ecx)				// ecx is negative index
+	AS2(	pxor    mm2, mm2)
+	ASJ(	jz,		2, f)
+	AS2(	test	ecx, 2)				// this clears carry flag
+	ASJ(	jz,		0, f)
+	AS2(	sub		ecx, 2)
+	ASJ(	jmp,	1, f)
+
+	ASL(0)
+	AS2(	movd     mm0, DWORD PTR [eax+4*ecx])
+	AS2(	movd     mm1, DWORD PTR [edi+4*ecx])
+	AS2(	psubq    mm0, mm1)
+	AS2(	psubq	 mm0, mm2)
+	AS2(	movd	 DWORD PTR [edx+4*ecx], mm0)
+	AS2(	psrlq    mm0, 63)
+
+	AS2(	movd     mm2, DWORD PTR [eax+4*ecx+4])
+	AS2(	movd     mm1, DWORD PTR [edi+4*ecx+4])
+	AS2(	psubq    mm2, mm1)
+	AS2(	psubq	 mm2, mm0)
+	AS2(	movd	 DWORD PTR [edx+4*ecx+4], mm2)
+	AS2(	psrlq    mm2, 63)
+
+	ASL(1)
+	AS2(	movd     mm0, DWORD PTR [eax+4*ecx+8])
+	AS2(	movd     mm1, DWORD PTR [edi+4*ecx+8])
+	AS2(	psubq    mm0, mm1)
+	AS2(	psubq	 mm0, mm2)
+	AS2(	movd	 DWORD PTR [edx+4*ecx+8], mm0)
+	AS2(	psrlq    mm0, 63)
+
+	AS2(	movd     mm2, DWORD PTR [eax+4*ecx+12])
+	AS2(	movd     mm1, DWORD PTR [edi+4*ecx+12])
+	AS2(	psubq    mm2, mm1)
+	AS2(	psubq	 mm2, mm0)
+	AS2(	movd	 DWORD PTR [edx+4*ecx+12], mm2)
+	AS2(	psrlq    mm2, 63)
+
+	AS2(	add		ecx, 4)
+	ASJ(	jnz,	0, b)
+
+	ASL(2)
+	AS2(	movd	eax, mm2)
+	AS1(	emms)
+
+	AddEpilogue
+}
+#endif	// #if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE
+#else
+int CRYPTOPP_FASTCALL Baseline_Add(size_t N, word *C, const word *A, const word *B)
+{
+	assert (N%2 == 0);
+
+	Declare2Words(u);
+	AssignWord(u, 0);
+	for (size_t i=0; i<N; i+=2)
+	{
+		AddWithCarry(u, A[i], B[i]);
+		C[i] = LowWord(u);
+		AddWithCarry(u, A[i+1], B[i+1]);
+		C[i+1] = LowWord(u);
+	}
+	return int(GetCarry(u));
+}
+
+int CRYPTOPP_FASTCALL Baseline_Sub(size_t N, word *C, const word *A, const word *B)
+{
+	assert (N%2 == 0);
+
+	Declare2Words(u);
+	AssignWord(u, 0);
+	for (size_t i=0; i<N; i+=2)
+	{
+		SubtractWithBorrow(u, A[i], B[i]);
+		C[i] = LowWord(u);
+		SubtractWithBorrow(u, A[i+1], B[i+1]);
+		C[i+1] = LowWord(u);
+	}
+	return int(GetBorrow(u));
+}
+#endif
+
+static word LinearMultiply(word *C, const word *A, word B, size_t N)
+{
+	word carry=0;
+	for(unsigned i=0; i<N; i++)
+	{
+		Declare2Words(p);
+		MultiplyWords(p, A[i], B);
+		Acc2WordsBy1(p, carry);
+		C[i] = LowWord(p);
+		carry = HighWord(p);
+	}
+	return carry;
+}
+
+#ifndef CRYPTOPP_DOXYGEN_PROCESSING
+
+#define Mul_2 \
+	Mul_Begin(2) \
+	Mul_SaveAcc(0, 0, 1) Mul_Acc(1, 0) \
+	Mul_End(1, 1)
+
+#define Mul_4 \
+	Mul_Begin(4) \
+	Mul_SaveAcc(0, 0, 1) Mul_Acc(1, 0) \
+	Mul_SaveAcc(1, 0, 2) Mul_Acc(1, 1) Mul_Acc(2, 0)  \
+	Mul_SaveAcc(2, 0, 3) Mul_Acc(1, 2) Mul_Acc(2, 1) Mul_Acc(3, 0)  \
+	Mul_SaveAcc(3, 1, 3) Mul_Acc(2, 2) Mul_Acc(3, 1)  \
+	Mul_SaveAcc(4, 2, 3) Mul_Acc(3, 2) \
+	Mul_End(5, 3)
+
+#define Mul_8 \
+	Mul_Begin(8) \
+	Mul_SaveAcc(0, 0, 1) Mul_Acc(1, 0) \
+	Mul_SaveAcc(1, 0, 2) Mul_Acc(1, 1) Mul_Acc(2, 0)  \
+	Mul_SaveAcc(2, 0, 3) Mul_Acc(1, 2) Mul_Acc(2, 1) Mul_Acc(3, 0)  \
+	Mul_SaveAcc(3, 0, 4) Mul_Acc(1, 3) Mul_Acc(2, 2) Mul_Acc(3, 1) Mul_Acc(4, 0) \
+	Mul_SaveAcc(4, 0, 5) Mul_Acc(1, 4) Mul_Acc(2, 3) Mul_Acc(3, 2) Mul_Acc(4, 1) Mul_Acc(5, 0) \
+	Mul_SaveAcc(5, 0, 6) Mul_Acc(1, 5) Mul_Acc(2, 4) Mul_Acc(3, 3) Mul_Acc(4, 2) Mul_Acc(5, 1) Mul_Acc(6, 0) \
+	Mul_SaveAcc(6, 0, 7) Mul_Acc(1, 6) Mul_Acc(2, 5) Mul_Acc(3, 4) Mul_Acc(4, 3) Mul_Acc(5, 2) Mul_Acc(6, 1) Mul_Acc(7, 0) \
+	Mul_SaveAcc(7, 1, 7) Mul_Acc(2, 6) Mul_Acc(3, 5) Mul_Acc(4, 4) Mul_Acc(5, 3) Mul_Acc(6, 2) Mul_Acc(7, 1) \
+	Mul_SaveAcc(8, 2, 7) Mul_Acc(3, 6) Mul_Acc(4, 5) Mul_Acc(5, 4) Mul_Acc(6, 3) Mul_Acc(7, 2) \
+	Mul_SaveAcc(9, 3, 7) Mul_Acc(4, 6) Mul_Acc(5, 5) Mul_Acc(6, 4) Mul_Acc(7, 3) \
+	Mul_SaveAcc(10, 4, 7) Mul_Acc(5, 6) Mul_Acc(6, 5) Mul_Acc(7, 4) \
+	Mul_SaveAcc(11, 5, 7) Mul_Acc(6, 6) Mul_Acc(7, 5) \
+	Mul_SaveAcc(12, 6, 7) Mul_Acc(7, 6) \
+	Mul_End(13, 7)
+
+#define Mul_16 \
+	Mul_Begin(16) \
+	Mul_SaveAcc(0, 0, 1) Mul_Acc(1, 0) \
+	Mul_SaveAcc(1, 0, 2) Mul_Acc(1, 1) Mul_Acc(2, 0) \
+	Mul_SaveAcc(2, 0, 3) Mul_Acc(1, 2) Mul_Acc(2, 1) Mul_Acc(3, 0) \
+	Mul_SaveAcc(3, 0, 4) Mul_Acc(1, 3) Mul_Acc(2, 2) Mul_Acc(3, 1) Mul_Acc(4, 0) \
+	Mul_SaveAcc(4, 0, 5) Mul_Acc(1, 4) Mul_Acc(2, 3) Mul_Acc(3, 2) Mul_Acc(4, 1) Mul_Acc(5, 0) \
+	Mul_SaveAcc(5, 0, 6) Mul_Acc(1, 5) Mul_Acc(2, 4) Mul_Acc(3, 3) Mul_Acc(4, 2) Mul_Acc(5, 1) Mul_Acc(6, 0) \
+	Mul_SaveAcc(6, 0, 7) Mul_Acc(1, 6) Mul_Acc(2, 5) Mul_Acc(3, 4) Mul_Acc(4, 3) Mul_Acc(5, 2) Mul_Acc(6, 1) Mul_Acc(7, 0) \
+	Mul_SaveAcc(7, 0, 8) Mul_Acc(1, 7) Mul_Acc(2, 6) Mul_Acc(3, 5) Mul_Acc(4, 4) Mul_Acc(5, 3) Mul_Acc(6, 2) Mul_Acc(7, 1) Mul_Acc(8, 0) \
+	Mul_SaveAcc(8, 0, 9) Mul_Acc(1, 8) Mul_Acc(2, 7) Mul_Acc(3, 6) Mul_Acc(4, 5) Mul_Acc(5, 4) Mul_Acc(6, 3) Mul_Acc(7, 2) Mul_Acc(8, 1) Mul_Acc(9, 0) \
+	Mul_SaveAcc(9, 0, 10) Mul_Acc(1, 9) Mul_Acc(2, 8) Mul_Acc(3, 7) Mul_Acc(4, 6) Mul_Acc(5, 5) Mul_Acc(6, 4) Mul_Acc(7, 3) Mul_Acc(8, 2) Mul_Acc(9, 1) Mul_Acc(10, 0) \
+	Mul_SaveAcc(10, 0, 11) Mul_Acc(1, 10) Mul_Acc(2, 9) Mul_Acc(3, 8) Mul_Acc(4, 7) Mul_Acc(5, 6) Mul_Acc(6, 5) Mul_Acc(7, 4) Mul_Acc(8, 3) Mul_Acc(9, 2) Mul_Acc(10, 1) Mul_Acc(11, 0) \
+	Mul_SaveAcc(11, 0, 12) Mul_Acc(1, 11) Mul_Acc(2, 10) Mul_Acc(3, 9) Mul_Acc(4, 8) Mul_Acc(5, 7) Mul_Acc(6, 6) Mul_Acc(7, 5) Mul_Acc(8, 4) Mul_Acc(9, 3) Mul_Acc(10, 2) Mul_Acc(11, 1) Mul_Acc(12, 0) \
+	Mul_SaveAcc(12, 0, 13) Mul_Acc(1, 12) Mul_Acc(2, 11) Mul_Acc(3, 10) Mul_Acc(4, 9) Mul_Acc(5, 8) Mul_Acc(6, 7) Mul_Acc(7, 6) Mul_Acc(8, 5) Mul_Acc(9, 4) Mul_Acc(10, 3) Mul_Acc(11, 2) Mul_Acc(12, 1) Mul_Acc(13, 0) \
+	Mul_SaveAcc(13, 0, 14) Mul_Acc(1, 13) Mul_Acc(2, 12) Mul_Acc(3, 11) Mul_Acc(4, 10) Mul_Acc(5, 9) Mul_Acc(6, 8) Mul_Acc(7, 7) Mul_Acc(8, 6) Mul_Acc(9, 5) Mul_Acc(10, 4) Mul_Acc(11, 3) Mul_Acc(12, 2) Mul_Acc(13, 1) Mul_Acc(14, 0) \
+	Mul_SaveAcc(14, 0, 15) Mul_Acc(1, 14) Mul_Acc(2, 13) Mul_Acc(3, 12) Mul_Acc(4, 11) Mul_Acc(5, 10) Mul_Acc(6, 9) Mul_Acc(7, 8) Mul_Acc(8, 7) Mul_Acc(9, 6) Mul_Acc(10, 5) Mul_Acc(11, 4) Mul_Acc(12, 3) Mul_Acc(13, 2) Mul_Acc(14, 1) Mul_Acc(15, 0) \
+	Mul_SaveAcc(15, 1, 15) Mul_Acc(2, 14) Mul_Acc(3, 13) Mul_Acc(4, 12) Mul_Acc(5, 11) Mul_Acc(6, 10) Mul_Acc(7, 9) Mul_Acc(8, 8) Mul_Acc(9, 7) Mul_Acc(10, 6) Mul_Acc(11, 5) Mul_Acc(12, 4) Mul_Acc(13, 3) Mul_Acc(14, 2) Mul_Acc(15, 1) \
+	Mul_SaveAcc(16, 2, 15) Mul_Acc(3, 14) Mul_Acc(4, 13) Mul_Acc(5, 12) Mul_Acc(6, 11) Mul_Acc(7, 10) Mul_Acc(8, 9) Mul_Acc(9, 8) Mul_Acc(10, 7) Mul_Acc(11, 6) Mul_Acc(12, 5) Mul_Acc(13, 4) Mul_Acc(14, 3) Mul_Acc(15, 2) \
+	Mul_SaveAcc(17, 3, 15) Mul_Acc(4, 14) Mul_Acc(5, 13) Mul_Acc(6, 12) Mul_Acc(7, 11) Mul_Acc(8, 10) Mul_Acc(9, 9) Mul_Acc(10, 8) Mul_Acc(11, 7) Mul_Acc(12, 6) Mul_Acc(13, 5) Mul_Acc(14, 4) Mul_Acc(15, 3) \
+	Mul_SaveAcc(18, 4, 15) Mul_Acc(5, 14) Mul_Acc(6, 13) Mul_Acc(7, 12) Mul_Acc(8, 11) Mul_Acc(9, 10) Mul_Acc(10, 9) Mul_Acc(11, 8) Mul_Acc(12, 7) Mul_Acc(13, 6) Mul_Acc(14, 5) Mul_Acc(15, 4) \
+	Mul_SaveAcc(19, 5, 15) Mul_Acc(6, 14) Mul_Acc(7, 13) Mul_Acc(8, 12) Mul_Acc(9, 11) Mul_Acc(10, 10) Mul_Acc(11, 9) Mul_Acc(12, 8) Mul_Acc(13, 7) Mul_Acc(14, 6) Mul_Acc(15, 5) \
+	Mul_SaveAcc(20, 6, 15) Mul_Acc(7, 14) Mul_Acc(8, 13) Mul_Acc(9, 12) Mul_Acc(10, 11) Mul_Acc(11, 10) Mul_Acc(12, 9) Mul_Acc(13, 8) Mul_Acc(14, 7) Mul_Acc(15, 6) \
+	Mul_SaveAcc(21, 7, 15) Mul_Acc(8, 14) Mul_Acc(9, 13) Mul_Acc(10, 12) Mul_Acc(11, 11) Mul_Acc(12, 10) Mul_Acc(13, 9) Mul_Acc(14, 8) Mul_Acc(15, 7) \
+	Mul_SaveAcc(22, 8, 15) Mul_Acc(9, 14) Mul_Acc(10, 13) Mul_Acc(11, 12) Mul_Acc(12, 11) Mul_Acc(13, 10) Mul_Acc(14, 9) Mul_Acc(15, 8) \
+	Mul_SaveAcc(23, 9, 15) Mul_Acc(10, 14) Mul_Acc(11, 13) Mul_Acc(12, 12) Mul_Acc(13, 11) Mul_Acc(14, 10) Mul_Acc(15, 9) \
+	Mul_SaveAcc(24, 10, 15) Mul_Acc(11, 14) Mul_Acc(12, 13) Mul_Acc(13, 12) Mul_Acc(14, 11) Mul_Acc(15, 10) \
+	Mul_SaveAcc(25, 11, 15) Mul_Acc(12, 14) Mul_Acc(13, 13) Mul_Acc(14, 12) Mul_Acc(15, 11) \
+	Mul_SaveAcc(26, 12, 15) Mul_Acc(13, 14) Mul_Acc(14, 13) Mul_Acc(15, 12) \
+	Mul_SaveAcc(27, 13, 15) Mul_Acc(14, 14) Mul_Acc(15, 13) \
+	Mul_SaveAcc(28, 14, 15) Mul_Acc(15, 14) \
+	Mul_End(29, 15)
+
+#define Squ_2 \
+	Squ_Begin(2) \
+	Squ_End(2)
+
+#define Squ_4 \
+	Squ_Begin(4) \
+	Squ_SaveAcc(1, 0, 2) Squ_Diag(1) \
+	Squ_SaveAcc(2, 0, 3) Squ_Acc(1, 2) Squ_NonDiag \
+	Squ_SaveAcc(3, 1, 3) Squ_Diag(2) \
+	Squ_SaveAcc(4, 2, 3) Squ_NonDiag \
+	Squ_End(4)
+
+#define Squ_8 \
+	Squ_Begin(8) \
+	Squ_SaveAcc(1, 0, 2) Squ_Diag(1) \
+	Squ_SaveAcc(2, 0, 3) Squ_Acc(1, 2) Squ_NonDiag \
+	Squ_SaveAcc(3, 0, 4) Squ_Acc(1, 3) Squ_Diag(2) \
+	Squ_SaveAcc(4, 0, 5) Squ_Acc(1, 4) Squ_Acc(2, 3) Squ_NonDiag \
+	Squ_SaveAcc(5, 0, 6) Squ_Acc(1, 5) Squ_Acc(2, 4) Squ_Diag(3) \
+	Squ_SaveAcc(6, 0, 7) Squ_Acc(1, 6) Squ_Acc(2, 5) Squ_Acc(3, 4) Squ_NonDiag \
+	Squ_SaveAcc(7, 1, 7) Squ_Acc(2, 6) Squ_Acc(3, 5) Squ_Diag(4) \
+	Squ_SaveAcc(8, 2, 7) Squ_Acc(3, 6) Squ_Acc(4, 5)  Squ_NonDiag \
+	Squ_SaveAcc(9, 3, 7) Squ_Acc(4, 6) Squ_Diag(5) \
+	Squ_SaveAcc(10, 4, 7) Squ_Acc(5, 6) Squ_NonDiag \
+	Squ_SaveAcc(11, 5, 7) Squ_Diag(6) \
+	Squ_SaveAcc(12, 6, 7) Squ_NonDiag \
+	Squ_End(8)
+
+#define Squ_16 \
+	Squ_Begin(16) \
+	Squ_SaveAcc(1, 0, 2) Squ_Diag(1) \
+	Squ_SaveAcc(2, 0, 3) Squ_Acc(1, 2) Squ_NonDiag \
+	Squ_SaveAcc(3, 0, 4) Squ_Acc(1, 3) Squ_Diag(2) \
+	Squ_SaveAcc(4, 0, 5) Squ_Acc(1, 4) Squ_Acc(2, 3) Squ_NonDiag \
+	Squ_SaveAcc(5, 0, 6) Squ_Acc(1, 5) Squ_Acc(2, 4) Squ_Diag(3) \
+	Squ_SaveAcc(6, 0, 7) Squ_Acc(1, 6) Squ_Acc(2, 5) Squ_Acc(3, 4) Squ_NonDiag \
+	Squ_SaveAcc(7, 0, 8) Squ_Acc(1, 7) Squ_Acc(2, 6) Squ_Acc(3, 5) Squ_Diag(4) \
+	Squ_SaveAcc(8, 0, 9) Squ_Acc(1, 8) Squ_Acc(2, 7) Squ_Acc(3, 6) Squ_Acc(4, 5) Squ_NonDiag \
+	Squ_SaveAcc(9, 0, 10) Squ_Acc(1, 9) Squ_Acc(2, 8) Squ_Acc(3, 7) Squ_Acc(4, 6) Squ_Diag(5) \
+	Squ_SaveAcc(10, 0, 11) Squ_Acc(1, 10) Squ_Acc(2, 9) Squ_Acc(3, 8) Squ_Acc(4, 7) Squ_Acc(5, 6) Squ_NonDiag \
+	Squ_SaveAcc(11, 0, 12) Squ_Acc(1, 11) Squ_Acc(2, 10) Squ_Acc(3, 9) Squ_Acc(4, 8) Squ_Acc(5, 7) Squ_Diag(6) \
+	Squ_SaveAcc(12, 0, 13) Squ_Acc(1, 12) Squ_Acc(2, 11) Squ_Acc(3, 10) Squ_Acc(4, 9) Squ_Acc(5, 8) Squ_Acc(6, 7) Squ_NonDiag \
+	Squ_SaveAcc(13, 0, 14) Squ_Acc(1, 13) Squ_Acc(2, 12) Squ_Acc(3, 11) Squ_Acc(4, 10) Squ_Acc(5, 9) Squ_Acc(6, 8) Squ_Diag(7) \
+	Squ_SaveAcc(14, 0, 15) Squ_Acc(1, 14) Squ_Acc(2, 13) Squ_Acc(3, 12) Squ_Acc(4, 11) Squ_Acc(5, 10) Squ_Acc(6, 9) Squ_Acc(7, 8) Squ_NonDiag \
+	Squ_SaveAcc(15, 1, 15) Squ_Acc(2, 14) Squ_Acc(3, 13) Squ_Acc(4, 12) Squ_Acc(5, 11) Squ_Acc(6, 10) Squ_Acc(7, 9) Squ_Diag(8) \
+	Squ_SaveAcc(16, 2, 15) Squ_Acc(3, 14) Squ_Acc(4, 13) Squ_Acc(5, 12) Squ_Acc(6, 11) Squ_Acc(7, 10) Squ_Acc(8, 9) Squ_NonDiag \
+	Squ_SaveAcc(17, 3, 15) Squ_Acc(4, 14) Squ_Acc(5, 13) Squ_Acc(6, 12) Squ_Acc(7, 11) Squ_Acc(8, 10) Squ_Diag(9) \
+	Squ_SaveAcc(18, 4, 15) Squ_Acc(5, 14) Squ_Acc(6, 13) Squ_Acc(7, 12) Squ_Acc(8, 11) Squ_Acc(9, 10) Squ_NonDiag \
+	Squ_SaveAcc(19, 5, 15) Squ_Acc(6, 14) Squ_Acc(7, 13) Squ_Acc(8, 12) Squ_Acc(9, 11) Squ_Diag(10) \
+	Squ_SaveAcc(20, 6, 15) Squ_Acc(7, 14) Squ_Acc(8, 13) Squ_Acc(9, 12) Squ_Acc(10, 11) Squ_NonDiag \
+	Squ_SaveAcc(21, 7, 15) Squ_Acc(8, 14) Squ_Acc(9, 13) Squ_Acc(10, 12) Squ_Diag(11) \
+	Squ_SaveAcc(22, 8, 15) Squ_Acc(9, 14) Squ_Acc(10, 13) Squ_Acc(11, 12) Squ_NonDiag \
+	Squ_SaveAcc(23, 9, 15) Squ_Acc(10, 14) Squ_Acc(11, 13) Squ_Diag(12) \
+	Squ_SaveAcc(24, 10, 15) Squ_Acc(11, 14) Squ_Acc(12, 13) Squ_NonDiag \
+	Squ_SaveAcc(25, 11, 15) Squ_Acc(12, 14) Squ_Diag(13) \
+	Squ_SaveAcc(26, 12, 15) Squ_Acc(13, 14) Squ_NonDiag \
+	Squ_SaveAcc(27, 13, 15) Squ_Diag(14) \
+	Squ_SaveAcc(28, 14, 15) Squ_NonDiag \
+	Squ_End(16)
+
+#define Bot_2 \
+	Mul_Begin(2) \
+	Bot_SaveAcc(0, 0, 1) Bot_Acc(1, 0) \
+	Bot_End(2)
+
+#define Bot_4 \
+	Mul_Begin(4) \
+	Mul_SaveAcc(0, 0, 1) Mul_Acc(1, 0) \
+	Mul_SaveAcc(1, 2, 0) Mul_Acc(1, 1) Mul_Acc(0, 2)  \
+	Bot_SaveAcc(2, 0, 3) Bot_Acc(1, 2) Bot_Acc(2, 1) Bot_Acc(3, 0)  \
+	Bot_End(4)
+
+#define Bot_8 \
+	Mul_Begin(8) \
+	Mul_SaveAcc(0, 0, 1) Mul_Acc(1, 0) \
+	Mul_SaveAcc(1, 0, 2) Mul_Acc(1, 1) Mul_Acc(2, 0)  \
+	Mul_SaveAcc(2, 0, 3) Mul_Acc(1, 2) Mul_Acc(2, 1) Mul_Acc(3, 0)  \
+	Mul_SaveAcc(3, 0, 4) Mul_Acc(1, 3) Mul_Acc(2, 2) Mul_Acc(3, 1) Mul_Acc(4, 0) \
+	Mul_SaveAcc(4, 0, 5) Mul_Acc(1, 4) Mul_Acc(2, 3) Mul_Acc(3, 2) Mul_Acc(4, 1) Mul_Acc(5, 0) \
+	Mul_SaveAcc(5, 0, 6) Mul_Acc(1, 5) Mul_Acc(2, 4) Mul_Acc(3, 3) Mul_Acc(4, 2) Mul_Acc(5, 1) Mul_Acc(6, 0) \
+	Bot_SaveAcc(6, 0, 7) Bot_Acc(1, 6) Bot_Acc(2, 5) Bot_Acc(3, 4) Bot_Acc(4, 3) Bot_Acc(5, 2) Bot_Acc(6, 1) Bot_Acc(7, 0) \
+	Bot_End(8)
+
+#define Bot_16 \
+	Mul_Begin(16) \
+	Mul_SaveAcc(0, 0, 1) Mul_Acc(1, 0) \
+	Mul_SaveAcc(1, 0, 2) Mul_Acc(1, 1) Mul_Acc(2, 0) \
+	Mul_SaveAcc(2, 0, 3) Mul_Acc(1, 2) Mul_Acc(2, 1) Mul_Acc(3, 0) \
+	Mul_SaveAcc(3, 0, 4) Mul_Acc(1, 3) Mul_Acc(2, 2) Mul_Acc(3, 1) Mul_Acc(4, 0) \
+	Mul_SaveAcc(4, 0, 5) Mul_Acc(1, 4) Mul_Acc(2, 3) Mul_Acc(3, 2) Mul_Acc(4, 1) Mul_Acc(5, 0) \
+	Mul_SaveAcc(5, 0, 6) Mul_Acc(1, 5) Mul_Acc(2, 4) Mul_Acc(3, 3) Mul_Acc(4, 2) Mul_Acc(5, 1) Mul_Acc(6, 0) \
+	Mul_SaveAcc(6, 0, 7) Mul_Acc(1, 6) Mul_Acc(2, 5) Mul_Acc(3, 4) Mul_Acc(4, 3) Mul_Acc(5, 2) Mul_Acc(6, 1) Mul_Acc(7, 0) \
+	Mul_SaveAcc(7, 0, 8) Mul_Acc(1, 7) Mul_Acc(2, 6) Mul_Acc(3, 5) Mul_Acc(4, 4) Mul_Acc(5, 3) Mul_Acc(6, 2) Mul_Acc(7, 1) Mul_Acc(8, 0) \
+	Mul_SaveAcc(8, 0, 9) Mul_Acc(1, 8) Mul_Acc(2, 7) Mul_Acc(3, 6) Mul_Acc(4, 5) Mul_Acc(5, 4) Mul_Acc(6, 3) Mul_Acc(7, 2) Mul_Acc(8, 1) Mul_Acc(9, 0) \
+	Mul_SaveAcc(9, 0, 10) Mul_Acc(1, 9) Mul_Acc(2, 8) Mul_Acc(3, 7) Mul_Acc(4, 6) Mul_Acc(5, 5) Mul_Acc(6, 4) Mul_Acc(7, 3) Mul_Acc(8, 2) Mul_Acc(9, 1) Mul_Acc(10, 0) \
+	Mul_SaveAcc(10, 0, 11) Mul_Acc(1, 10) Mul_Acc(2, 9) Mul_Acc(3, 8) Mul_Acc(4, 7) Mul_Acc(5, 6) Mul_Acc(6, 5) Mul_Acc(7, 4) Mul_Acc(8, 3) Mul_Acc(9, 2) Mul_Acc(10, 1) Mul_Acc(11, 0) \
+	Mul_SaveAcc(11, 0, 12) Mul_Acc(1, 11) Mul_Acc(2, 10) Mul_Acc(3, 9) Mul_Acc(4, 8) Mul_Acc(5, 7) Mul_Acc(6, 6) Mul_Acc(7, 5) Mul_Acc(8, 4) Mul_Acc(9, 3) Mul_Acc(10, 2) Mul_Acc(11, 1) Mul_Acc(12, 0) \
+	Mul_SaveAcc(12, 0, 13) Mul_Acc(1, 12) Mul_Acc(2, 11) Mul_Acc(3, 10) Mul_Acc(4, 9) Mul_Acc(5, 8) Mul_Acc(6, 7) Mul_Acc(7, 6) Mul_Acc(8, 5) Mul_Acc(9, 4) Mul_Acc(10, 3) Mul_Acc(11, 2) Mul_Acc(12, 1) Mul_Acc(13, 0) \
+	Mul_SaveAcc(13, 0, 14) Mul_Acc(1, 13) Mul_Acc(2, 12) Mul_Acc(3, 11) Mul_Acc(4, 10) Mul_Acc(5, 9) Mul_Acc(6, 8) Mul_Acc(7, 7) Mul_Acc(8, 6) Mul_Acc(9, 5) Mul_Acc(10, 4) Mul_Acc(11, 3) Mul_Acc(12, 2) Mul_Acc(13, 1) Mul_Acc(14, 0) \
+	Bot_SaveAcc(14, 0, 15) Bot_Acc(1, 14) Bot_Acc(2, 13) Bot_Acc(3, 12) Bot_Acc(4, 11) Bot_Acc(5, 10) Bot_Acc(6, 9) Bot_Acc(7, 8) Bot_Acc(8, 7) Bot_Acc(9, 6) Bot_Acc(10, 5) Bot_Acc(11, 4) Bot_Acc(12, 3) Bot_Acc(13, 2) Bot_Acc(14, 1) Bot_Acc(15, 0) \
+	Bot_End(16)
+	
+#endif
+
+#if 0
+#define Mul_Begin(n)				\
+	Declare2Words(p)				\
+	Declare2Words(c)				\
+	Declare2Words(d)				\
+	MultiplyWords(p, A[0], B[0])	\
+	AssignWord(c, LowWord(p))		\
+	AssignWord(d, HighWord(p))
+
+#define Mul_Acc(i, j)				\
+	MultiplyWords(p, A[i], B[j])	\
+	Acc2WordsBy1(c, LowWord(p))		\
+	Acc2WordsBy1(d, HighWord(p))
+
+#define Mul_SaveAcc(k, i, j) 		\
+	R[k] = LowWord(c);				\
+	Add2WordsBy1(c, d, HighWord(c))	\
+	MultiplyWords(p, A[i], B[j])	\
+	AssignWord(d, HighWord(p))		\
+	Acc2WordsBy1(c, LowWord(p))
+
+#define Mul_End(n)					\
+	R[2*n-3] = LowWord(c);			\
+	Acc2WordsBy1(d, HighWord(c))	\
+	MultiplyWords(p, A[n-1], B[n-1])\
+	Acc2WordsBy2(d, p)				\
+	R[2*n-2] = LowWord(d);			\
+	R[2*n-1] = HighWord(d);
+
+#define Bot_SaveAcc(k, i, j)		\
+	R[k] = LowWord(c);				\
+	word e = LowWord(d) + HighWord(c);	\
+	e += A[i] * B[j];
+
+#define Bot_Acc(i, j)	\
+	e += A[i] * B[j];
+
+#define Bot_End(n)		\
+	R[n-1] = e;
+#else
+#define Mul_Begin(n)				\
+	Declare2Words(p)				\
+	word c;	\
+	Declare2Words(d)				\
+	MultiplyWords(p, A[0], B[0])	\
+	c = LowWord(p);		\
+	AssignWord(d, HighWord(p))
+
+#define Mul_Acc(i, j)				\
+	MulAcc(c, d, A[i], B[j])
+
+#define Mul_SaveAcc(k, i, j) 		\
+	R[k] = c;				\
+	c = LowWord(d);	\
+	AssignWord(d, HighWord(d))	\
+	MulAcc(c, d, A[i], B[j])
+
+#define Mul_End(k, i)					\
+	R[k] = c;			\
+	MultiplyWords(p, A[i], B[i])	\
+	Acc2WordsBy2(p, d)				\
+	R[k+1] = LowWord(p);			\
+	R[k+2] = HighWord(p);
+
+#define Bot_SaveAcc(k, i, j)		\
+	R[k] = c;				\
+	c = LowWord(d);	\
+	c += A[i] * B[j];
+
+#define Bot_Acc(i, j)	\
+	c += A[i] * B[j];
+
+#define Bot_End(n)		\
+	R[n-1] = c;
+#endif
+
+#define Squ_Begin(n)				\
+	Declare2Words(p)				\
+	word c;				\
+	Declare2Words(d)				\
+	Declare2Words(e)				\
+	MultiplyWords(p, A[0], A[0])	\
+	R[0] = LowWord(p);				\
+	AssignWord(e, HighWord(p))		\
+	MultiplyWords(p, A[0], A[1])	\
+	c = LowWord(p);		\
+	AssignWord(d, HighWord(p))		\
+	Squ_NonDiag						\
+
+#define Squ_NonDiag				\
+	Double3Words(c, d)
+
+#define Squ_SaveAcc(k, i, j) 		\
+	Acc3WordsBy2(c, d, e)			\
+	R[k] = c;				\
+	MultiplyWords(p, A[i], A[j])	\
+	c = LowWord(p);		\
+	AssignWord(d, HighWord(p))		\
+
+#define Squ_Acc(i, j)				\
+	MulAcc(c, d, A[i], A[j])
+
+#define Squ_Diag(i)					\
+	Squ_NonDiag						\
+	MulAcc(c, d, A[i], A[i])
+
+#define Squ_End(n)					\
+	Acc3WordsBy2(c, d, e)			\
+	R[2*n-3] = c;			\
+	MultiplyWords(p, A[n-1], A[n-1])\
+	Acc2WordsBy2(p, e)				\
+	R[2*n-2] = LowWord(p);			\
+	R[2*n-1] = HighWord(p);
+
+void Baseline_Multiply2(word *R, const word *A, const word *B)
+{
+	Mul_2
+}
+
+void Baseline_Multiply4(word *R, const word *A, const word *B)
+{
+	Mul_4
+}
+
+void Baseline_Multiply8(word *R, const word *A, const word *B)
+{
+	Mul_8
+}
+
+void Baseline_Square2(word *R, const word *A)
+{
+	Squ_2
+}
+
+void Baseline_Square4(word *R, const word *A)
+{
+	Squ_4
+}
+
+void Baseline_Square8(word *R, const word *A)
+{
+	Squ_8
+}
+
+void Baseline_MultiplyBottom2(word *R, const word *A, const word *B)
+{
+	Bot_2
+}
+
+void Baseline_MultiplyBottom4(word *R, const word *A, const word *B)
+{
+	Bot_4
+}
+
+void Baseline_MultiplyBottom8(word *R, const word *A, const word *B)
+{
+	Bot_8
+}
+
+#define Top_Begin(n)				\
+	Declare2Words(p)				\
+	word c;	\
+	Declare2Words(d)				\
+	MultiplyWords(p, A[0], B[n-2]);\
+	AssignWord(d, HighWord(p));
+
+#define Top_Acc(i, j)	\
+	MultiplyWords(p, A[i], B[j]);\
+	Acc2WordsBy1(d, HighWord(p));
+
+#define Top_SaveAcc0(i, j) 		\
+	c = LowWord(d);	\
+	AssignWord(d, HighWord(d))	\
+	MulAcc(c, d, A[i], B[j])
+
+#define Top_SaveAcc1(i, j) 		\
+	c = L<c; \
+	Acc2WordsBy1(d, c);	\
+	c = LowWord(d);	\
+	AssignWord(d, HighWord(d))	\
+	MulAcc(c, d, A[i], B[j])
+
+void Baseline_MultiplyTop2(word *R, const word *A, const word *B, word L)
+{
+	word T[4];
+	Baseline_Multiply2(T, A, B);
+	R[0] = T[2];
+	R[1] = T[3];
+}
+
+void Baseline_MultiplyTop4(word *R, const word *A, const word *B, word L)
+{
+	Top_Begin(4)
+	Top_Acc(1, 1) Top_Acc(2, 0)  \
+	Top_SaveAcc0(0, 3) Mul_Acc(1, 2) Mul_Acc(2, 1) Mul_Acc(3, 0)  \
+	Top_SaveAcc1(1, 3) Mul_Acc(2, 2) Mul_Acc(3, 1)  \
+	Mul_SaveAcc(0, 2, 3) Mul_Acc(3, 2) \
+	Mul_End(1, 3)
+}
+
+void Baseline_MultiplyTop8(word *R, const word *A, const word *B, word L)
+{
+	Top_Begin(8)
+	Top_Acc(1, 5) Top_Acc(2, 4) Top_Acc(3, 3) Top_Acc(4, 2) Top_Acc(5, 1) Top_Acc(6, 0) \
+	Top_SaveAcc0(0, 7) Mul_Acc(1, 6) Mul_Acc(2, 5) Mul_Acc(3, 4) Mul_Acc(4, 3) Mul_Acc(5, 2) Mul_Acc(6, 1) Mul_Acc(7, 0) \
+	Top_SaveAcc1(1, 7) Mul_Acc(2, 6) Mul_Acc(3, 5) Mul_Acc(4, 4) Mul_Acc(5, 3) Mul_Acc(6, 2) Mul_Acc(7, 1) \
+	Mul_SaveAcc(0, 2, 7) Mul_Acc(3, 6) Mul_Acc(4, 5) Mul_Acc(5, 4) Mul_Acc(6, 3) Mul_Acc(7, 2) \
+	Mul_SaveAcc(1, 3, 7) Mul_Acc(4, 6) Mul_Acc(5, 5) Mul_Acc(6, 4) Mul_Acc(7, 3) \
+	Mul_SaveAcc(2, 4, 7) Mul_Acc(5, 6) Mul_Acc(6, 5) Mul_Acc(7, 4) \
+	Mul_SaveAcc(3, 5, 7) Mul_Acc(6, 6) Mul_Acc(7, 5) \
+	Mul_SaveAcc(4, 6, 7) Mul_Acc(7, 6) \
+	Mul_End(5, 7)
+}
+
+#if !CRYPTOPP_INTEGER_SSE2	// save memory by not compiling these functions when SSE2 is available
+void Baseline_Multiply16(word *R, const word *A, const word *B)
+{
+	Mul_16
+}
+
+void Baseline_Square16(word *R, const word *A)
+{
+	Squ_16
+}
+
+void Baseline_MultiplyBottom16(word *R, const word *A, const word *B)
+{
+	Bot_16
+}
+
+void Baseline_MultiplyTop16(word *R, const word *A, const word *B, word L)
+{
+	Top_Begin(16)
+	Top_Acc(1, 13) Top_Acc(2, 12) Top_Acc(3, 11) Top_Acc(4, 10) Top_Acc(5, 9) Top_Acc(6, 8) Top_Acc(7, 7) Top_Acc(8, 6) Top_Acc(9, 5) Top_Acc(10, 4) Top_Acc(11, 3) Top_Acc(12, 2) Top_Acc(13, 1) Top_Acc(14, 0) \
+	Top_SaveAcc0(0, 15) Mul_Acc(1, 14) Mul_Acc(2, 13) Mul_Acc(3, 12) Mul_Acc(4, 11) Mul_Acc(5, 10) Mul_Acc(6, 9) Mul_Acc(7, 8) Mul_Acc(8, 7) Mul_Acc(9, 6) Mul_Acc(10, 5) Mul_Acc(11, 4) Mul_Acc(12, 3) Mul_Acc(13, 2) Mul_Acc(14, 1) Mul_Acc(15, 0) \
+	Top_SaveAcc1(1, 15) Mul_Acc(2, 14) Mul_Acc(3, 13) Mul_Acc(4, 12) Mul_Acc(5, 11) Mul_Acc(6, 10) Mul_Acc(7, 9) Mul_Acc(8, 8) Mul_Acc(9, 7) Mul_Acc(10, 6) Mul_Acc(11, 5) Mul_Acc(12, 4) Mul_Acc(13, 3) Mul_Acc(14, 2) Mul_Acc(15, 1) \
+	Mul_SaveAcc(0, 2, 15) Mul_Acc(3, 14) Mul_Acc(4, 13) Mul_Acc(5, 12) Mul_Acc(6, 11) Mul_Acc(7, 10) Mul_Acc(8, 9) Mul_Acc(9, 8) Mul_Acc(10, 7) Mul_Acc(11, 6) Mul_Acc(12, 5) Mul_Acc(13, 4) Mul_Acc(14, 3) Mul_Acc(15, 2) \
+	Mul_SaveAcc(1, 3, 15) Mul_Acc(4, 14) Mul_Acc(5, 13) Mul_Acc(6, 12) Mul_Acc(7, 11) Mul_Acc(8, 10) Mul_Acc(9, 9) Mul_Acc(10, 8) Mul_Acc(11, 7) Mul_Acc(12, 6) Mul_Acc(13, 5) Mul_Acc(14, 4) Mul_Acc(15, 3) \
+	Mul_SaveAcc(2, 4, 15) Mul_Acc(5, 14) Mul_Acc(6, 13) Mul_Acc(7, 12) Mul_Acc(8, 11) Mul_Acc(9, 10) Mul_Acc(10, 9) Mul_Acc(11, 8) Mul_Acc(12, 7) Mul_Acc(13, 6) Mul_Acc(14, 5) Mul_Acc(15, 4) \
+	Mul_SaveAcc(3, 5, 15) Mul_Acc(6, 14) Mul_Acc(7, 13) Mul_Acc(8, 12) Mul_Acc(9, 11) Mul_Acc(10, 10) Mul_Acc(11, 9) Mul_Acc(12, 8) Mul_Acc(13, 7) Mul_Acc(14, 6) Mul_Acc(15, 5) \
+	Mul_SaveAcc(4, 6, 15) Mul_Acc(7, 14) Mul_Acc(8, 13) Mul_Acc(9, 12) Mul_Acc(10, 11) Mul_Acc(11, 10) Mul_Acc(12, 9) Mul_Acc(13, 8) Mul_Acc(14, 7) Mul_Acc(15, 6) \
+	Mul_SaveAcc(5, 7, 15) Mul_Acc(8, 14) Mul_Acc(9, 13) Mul_Acc(10, 12) Mul_Acc(11, 11) Mul_Acc(12, 10) Mul_Acc(13, 9) Mul_Acc(14, 8) Mul_Acc(15, 7) \
+	Mul_SaveAcc(6, 8, 15) Mul_Acc(9, 14) Mul_Acc(10, 13) Mul_Acc(11, 12) Mul_Acc(12, 11) Mul_Acc(13, 10) Mul_Acc(14, 9) Mul_Acc(15, 8) \
+	Mul_SaveAcc(7, 9, 15) Mul_Acc(10, 14) Mul_Acc(11, 13) Mul_Acc(12, 12) Mul_Acc(13, 11) Mul_Acc(14, 10) Mul_Acc(15, 9) \
+	Mul_SaveAcc(8, 10, 15) Mul_Acc(11, 14) Mul_Acc(12, 13) Mul_Acc(13, 12) Mul_Acc(14, 11) Mul_Acc(15, 10) \
+	Mul_SaveAcc(9, 11, 15) Mul_Acc(12, 14) Mul_Acc(13, 13) Mul_Acc(14, 12) Mul_Acc(15, 11) \
+	Mul_SaveAcc(10, 12, 15) Mul_Acc(13, 14) Mul_Acc(14, 13) Mul_Acc(15, 12) \
+	Mul_SaveAcc(11, 13, 15) Mul_Acc(14, 14) Mul_Acc(15, 13) \
+	Mul_SaveAcc(12, 14, 15) Mul_Acc(15, 14) \
+	Mul_End(13, 15)
+}
+#endif
+
+// ********************************************************
+
+#if CRYPTOPP_INTEGER_SSE2
+
+CRYPTOPP_ALIGN_DATA(16) static const word32 s_maskLow16[4] CRYPTOPP_SECTION_ALIGN16 = {0xffff,0xffff,0xffff,0xffff};
+
+#undef Mul_Begin
+#undef Mul_Acc
+#undef Top_Begin
+#undef Top_Acc
+#undef Squ_Acc
+#undef Squ_NonDiag
+#undef Squ_Diag
+#undef Squ_SaveAcc
+#undef Squ_Begin
+#undef Mul_SaveAcc
+#undef Bot_Acc
+#undef Bot_SaveAcc
+#undef Bot_End
+#undef Squ_End
+#undef Mul_End
+
+#define SSE2_FinalSave(k)			\
+	AS2(	psllq		xmm5, 16)	\
+	AS2(	paddq		xmm4, xmm5)	\
+	AS2(	movq		QWORD PTR [ecx+8*(k)], xmm4)
+
+#define SSE2_SaveShift(k)			\
+	AS2(	movq		xmm0, xmm6)	\
+	AS2(	punpckhqdq	xmm6, xmm0)	\
+	AS2(	movq		xmm1, xmm7)	\
+	AS2(	punpckhqdq	xmm7, xmm1)	\
+	AS2(	paddd		xmm6, xmm0)	\
+	AS2(	pslldq		xmm6, 4)	\
+	AS2(	paddd		xmm7, xmm1)	\
+	AS2(	paddd		xmm4, xmm6)	\
+	AS2(	pslldq		xmm7, 4)	\
+	AS2(	movq		xmm6, xmm4)	\
+	AS2(	paddd		xmm5, xmm7)	\
+	AS2(	movq		xmm7, xmm5)	\
+	AS2(	movd		DWORD PTR [ecx+8*(k)], xmm4)	\
+	AS2(	psrlq		xmm6, 16)	\
+	AS2(	paddq		xmm6, xmm7)	\
+	AS2(	punpckhqdq	xmm4, xmm0)	\
+	AS2(	punpckhqdq	xmm5, xmm0)	\
+	AS2(	movq		QWORD PTR [ecx+8*(k)+2], xmm6)	\
+	AS2(	psrlq		xmm6, 3*16)	\
+	AS2(	paddd		xmm4, xmm6)	\
+
+#define Squ_SSE2_SaveShift(k)			\
+	AS2(	movq		xmm0, xmm6)	\
+	AS2(	punpckhqdq	xmm6, xmm0)	\
+	AS2(	movq		xmm1, xmm7)	\
+	AS2(	punpckhqdq	xmm7, xmm1)	\
+	AS2(	paddd		xmm6, xmm0)	\
+	AS2(	pslldq		xmm6, 4)	\
+	AS2(	paddd		xmm7, xmm1)	\
+	AS2(	paddd		xmm4, xmm6)	\
+	AS2(	pslldq		xmm7, 4)	\
+	AS2(	movhlps		xmm6, xmm4)	\
+	AS2(	movd		DWORD PTR [ecx+8*(k)], xmm4)	\
+	AS2(	paddd		xmm5, xmm7)	\
+	AS2(	movhps		QWORD PTR [esp+12], xmm5)\
+	AS2(	psrlq		xmm4, 16)	\
+	AS2(	paddq		xmm4, xmm5)	\
+	AS2(	movq		QWORD PTR [ecx+8*(k)+2], xmm4)	\
+	AS2(	psrlq		xmm4, 3*16)	\
+	AS2(	paddd		xmm4, xmm6)	\
+	AS2(	movq		QWORD PTR [esp+4], xmm4)\
+
+#define SSE2_FirstMultiply(i)				\
+	AS2(	movdqa		xmm7, [esi+(i)*16])\
+	AS2(	movdqa		xmm5, [edi-(i)*16])\
+	AS2(	pmuludq		xmm5, xmm7)		\
+	AS2(	movdqa		xmm4, [ebx])\
+	AS2(	movdqa		xmm6, xmm4)		\
+	AS2(	pand		xmm4, xmm5)		\
+	AS2(	psrld		xmm5, 16)		\
+	AS2(	pmuludq		xmm7, [edx-(i)*16])\
+	AS2(	pand		xmm6, xmm7)		\
+	AS2(	psrld		xmm7, 16)
+
+#define Squ_Begin(n)							\
+	SquPrologue									\
+	AS2(	mov		esi, esp)\
+	AS2(	and		esp, 0xfffffff0)\
+	AS2(	lea		edi, [esp-32*n])\
+	AS2(	sub		esp, 32*n+16)\
+	AS1(	push	esi)\
+	AS2(	mov		esi, edi)					\
+	AS2(	xor		edx, edx)					\
+	ASL(1)										\
+	ASS(	pshufd	xmm0, [eax+edx], 3,1,2,0)	\
+	ASS(	pshufd	xmm1, [eax+edx], 2,0,3,1)	\
+	AS2(	movdqa	[edi+2*edx], xmm0)		\
+	AS2(	psrlq	xmm0, 32)					\
+	AS2(	movdqa	[edi+2*edx+16], xmm0)	\
+	AS2(	movdqa	[edi+16*n+2*edx], xmm1)		\
+	AS2(	psrlq	xmm1, 32)					\
+	AS2(	movdqa	[edi+16*n+2*edx+16], xmm1)	\
+	AS2(	add		edx, 16)					\
+	AS2(	cmp		edx, 8*(n))					\
+	ASJ(	jne,	1, b)						\
+	AS2(	lea		edx, [edi+16*n])\
+	SSE2_FirstMultiply(0)							\
+
+#define Squ_Acc(i)								\
+	ASL(LSqu##i)								\
+	AS2(	movdqa		xmm1, [esi+(i)*16])	\
+	AS2(	movdqa		xmm0, [edi-(i)*16])	\
+	AS2(	movdqa		xmm2, [ebx])	\
+	AS2(	pmuludq		xmm0, xmm1)				\
+	AS2(	pmuludq		xmm1, [edx-(i)*16])	\
+	AS2(	movdqa		xmm3, xmm2)			\
+	AS2(	pand		xmm2, xmm0)			\
+	AS2(	psrld		xmm0, 16)			\
+	AS2(	paddd		xmm4, xmm2)			\
+	AS2(	paddd		xmm5, xmm0)			\
+	AS2(	pand		xmm3, xmm1)			\
+	AS2(	psrld		xmm1, 16)			\
+	AS2(	paddd		xmm6, xmm3)			\
+	AS2(	paddd		xmm7, xmm1)		\
+
+#define Squ_Acc1(i)		
+#define Squ_Acc2(i)		ASC(call, LSqu##i)
+#define Squ_Acc3(i)		Squ_Acc2(i)
+#define Squ_Acc4(i)		Squ_Acc2(i)
+#define Squ_Acc5(i)		Squ_Acc2(i)
+#define Squ_Acc6(i)		Squ_Acc2(i)
+#define Squ_Acc7(i)		Squ_Acc2(i)
+#define Squ_Acc8(i)		Squ_Acc2(i)
+
+#define SSE2_End(E, n)					\
+	SSE2_SaveShift(2*(n)-3)			\
+	AS2(	movdqa		xmm7, [esi+16])	\
+	AS2(	movdqa		xmm0, [edi])	\
+	AS2(	pmuludq		xmm0, xmm7)				\
+	AS2(	movdqa		xmm2, [ebx])		\
+	AS2(	pmuludq		xmm7, [edx])	\
+	AS2(	movdqa		xmm6, xmm2)				\
+	AS2(	pand		xmm2, xmm0)				\
+	AS2(	psrld		xmm0, 16)				\
+	AS2(	paddd		xmm4, xmm2)				\
+	AS2(	paddd		xmm5, xmm0)				\
+	AS2(	pand		xmm6, xmm7)				\
+	AS2(	psrld		xmm7, 16)	\
+	SSE2_SaveShift(2*(n)-2)			\
+	SSE2_FinalSave(2*(n)-1)			\
+	AS1(	pop		esp)\
+	E
+
+#define Squ_End(n)		SSE2_End(SquEpilogue, n)
+#define Mul_End(n)		SSE2_End(MulEpilogue, n)
+#define Top_End(n)		SSE2_End(TopEpilogue, n)
+
+#define Squ_Column1(k, i)	\
+	Squ_SSE2_SaveShift(k)					\
+	AS2(	add			esi, 16)	\
+	SSE2_FirstMultiply(1)\
+	Squ_Acc##i(i)	\
+	AS2(	paddd		xmm4, xmm4)		\
+	AS2(	paddd		xmm5, xmm5)		\
+	AS2(	movdqa		xmm3, [esi])				\
+	AS2(	movq		xmm1, QWORD PTR [esi+8])	\
+	AS2(	pmuludq		xmm1, xmm3)		\
+	AS2(	pmuludq		xmm3, xmm3)		\
+	AS2(	movdqa		xmm0, [ebx])\
+	AS2(	movdqa		xmm2, xmm0)		\
+	AS2(	pand		xmm0, xmm1)		\
+	AS2(	psrld		xmm1, 16)		\
+	AS2(	paddd		xmm6, xmm0)		\
+	AS2(	paddd		xmm7, xmm1)		\
+	AS2(	pand		xmm2, xmm3)		\
+	AS2(	psrld		xmm3, 16)		\
+	AS2(	paddd		xmm6, xmm6)		\
+	AS2(	paddd		xmm7, xmm7)		\
+	AS2(	paddd		xmm4, xmm2)		\
+	AS2(	paddd		xmm5, xmm3)		\
+	AS2(	movq		xmm0, QWORD PTR [esp+4])\
+	AS2(	movq		xmm1, QWORD PTR [esp+12])\
+	AS2(	paddd		xmm4, xmm0)\
+	AS2(	paddd		xmm5, xmm1)\
+
+#define Squ_Column0(k, i)	\
+	Squ_SSE2_SaveShift(k)					\
+	AS2(	add			edi, 16)	\
+	AS2(	add			edx, 16)	\
+	SSE2_FirstMultiply(1)\
+	Squ_Acc##i(i)	\
+	AS2(	paddd		xmm6, xmm6)		\
+	AS2(	paddd		xmm7, xmm7)		\
+	AS2(	paddd		xmm4, xmm4)		\
+	AS2(	paddd		xmm5, xmm5)		\
+	AS2(	movq		xmm0, QWORD PTR [esp+4])\
+	AS2(	movq		xmm1, QWORD PTR [esp+12])\
+	AS2(	paddd		xmm4, xmm0)\
+	AS2(	paddd		xmm5, xmm1)\
+
+#define SSE2_MulAdd45						\
+	AS2(	movdqa		xmm7, [esi])	\
+	AS2(	movdqa		xmm0, [edi])	\
+	AS2(	pmuludq		xmm0, xmm7)				\
+	AS2(	movdqa		xmm2, [ebx])		\
+	AS2(	pmuludq		xmm7, [edx])	\
+	AS2(	movdqa		xmm6, xmm2)				\
+	AS2(	pand		xmm2, xmm0)				\
+	AS2(	psrld		xmm0, 16)				\
+	AS2(	paddd		xmm4, xmm2)				\
+	AS2(	paddd		xmm5, xmm0)				\
+	AS2(	pand		xmm6, xmm7)				\
+	AS2(	psrld		xmm7, 16)
+
+#define Mul_Begin(n)							\
+	MulPrologue									\
+	AS2(	mov		esi, esp)\
+	AS2(	and		esp, 0xfffffff0)\
+	AS2(	sub		esp, 48*n+16)\
+	AS1(	push	esi)\
+	AS2(	xor		edx, edx)					\
+	ASL(1)										\
+	ASS(	pshufd	xmm0, [eax+edx], 3,1,2,0)	\
+	ASS(	pshufd	xmm1, [eax+edx], 2,0,3,1)	\
+	ASS(	pshufd	xmm2, [edi+edx], 3,1,2,0)	\
+	AS2(	movdqa	[esp+20+2*edx], xmm0)		\
+	AS2(	psrlq	xmm0, 32)					\
+	AS2(	movdqa	[esp+20+2*edx+16], xmm0)	\
+	AS2(	movdqa	[esp+20+16*n+2*edx], xmm1)		\
+	AS2(	psrlq	xmm1, 32)					\
+	AS2(	movdqa	[esp+20+16*n+2*edx+16], xmm1)	\
+	AS2(	movdqa	[esp+20+32*n+2*edx], xmm2)		\
+	AS2(	psrlq	xmm2, 32)					\
+	AS2(	movdqa	[esp+20+32*n+2*edx+16], xmm2)	\
+	AS2(	add		edx, 16)					\
+	AS2(	cmp		edx, 8*(n))					\
+	ASJ(	jne,	1, b)						\
+	AS2(	lea		edi, [esp+20])\
+	AS2(	lea		edx, [esp+20+16*n])\
+	AS2(	lea		esi, [esp+20+32*n])\
+	SSE2_FirstMultiply(0)							\
+
+#define Mul_Acc(i)								\
+	ASL(LMul##i)										\
+	AS2(	movdqa		xmm1, [esi+i/2*(1-(i-2*(i/2))*2)*16])	\
+	AS2(	movdqa		xmm0, [edi-i/2*(1-(i-2*(i/2))*2)*16])	\
+	AS2(	movdqa		xmm2, [ebx])	\
+	AS2(	pmuludq		xmm0, xmm1)				\
+	AS2(	pmuludq		xmm1, [edx-i/2*(1-(i-2*(i/2))*2)*16])	\
+	AS2(	movdqa		xmm3, xmm2)			\
+	AS2(	pand		xmm2, xmm0)			\
+	AS2(	psrld		xmm0, 16)			\
+	AS2(	paddd		xmm4, xmm2)			\
+	AS2(	paddd		xmm5, xmm0)			\
+	AS2(	pand		xmm3, xmm1)			\
+	AS2(	psrld		xmm1, 16)			\
+	AS2(	paddd		xmm6, xmm3)			\
+	AS2(	paddd		xmm7, xmm1)		\
+
+#define Mul_Acc1(i)		
+#define Mul_Acc2(i)		ASC(call, LMul##i)
+#define Mul_Acc3(i)		Mul_Acc2(i)
+#define Mul_Acc4(i)		Mul_Acc2(i)
+#define Mul_Acc5(i)		Mul_Acc2(i)
+#define Mul_Acc6(i)		Mul_Acc2(i)
+#define Mul_Acc7(i)		Mul_Acc2(i)
+#define Mul_Acc8(i)		Mul_Acc2(i)
+#define Mul_Acc9(i)		Mul_Acc2(i)
+#define Mul_Acc10(i)	Mul_Acc2(i)
+#define Mul_Acc11(i)	Mul_Acc2(i)
+#define Mul_Acc12(i)	Mul_Acc2(i)
+#define Mul_Acc13(i)	Mul_Acc2(i)
+#define Mul_Acc14(i)	Mul_Acc2(i)
+#define Mul_Acc15(i)	Mul_Acc2(i)
+#define Mul_Acc16(i)	Mul_Acc2(i)
+
+#define Mul_Column1(k, i)	\
+	SSE2_SaveShift(k)					\
+	AS2(	add			esi, 16)	\
+	SSE2_MulAdd45\
+	Mul_Acc##i(i)	\
+
+#define Mul_Column0(k, i)	\
+	SSE2_SaveShift(k)					\
+	AS2(	add			edi, 16)	\
+	AS2(	add			edx, 16)	\
+	SSE2_MulAdd45\
+	Mul_Acc##i(i)	\
+
+#define Bot_Acc(i)							\
+	AS2(	movdqa		xmm1, [esi+i/2*(1-(i-2*(i/2))*2)*16])	\
+	AS2(	movdqa		xmm0, [edi-i/2*(1-(i-2*(i/2))*2)*16])	\
+	AS2(	pmuludq		xmm0, xmm1)				\
+	AS2(	pmuludq		xmm1, [edx-i/2*(1-(i-2*(i/2))*2)*16])		\
+	AS2(	paddq		xmm4, xmm0)				\
+	AS2(	paddd		xmm6, xmm1)
+
+#define Bot_SaveAcc(k)					\
+	SSE2_SaveShift(k)							\
+	AS2(	add			edi, 16)	\
+	AS2(	add			edx, 16)	\
+	AS2(	movdqa		xmm6, [esi])	\
+	AS2(	movdqa		xmm0, [edi])	\
+	AS2(	pmuludq		xmm0, xmm6)				\
+	AS2(	paddq		xmm4, xmm0)				\
+	AS2(	psllq		xmm5, 16)				\
+	AS2(	paddq		xmm4, xmm5)				\
+	AS2(	pmuludq		xmm6, [edx])
+
+#define Bot_End(n)							\
+	AS2(	movhlps		xmm7, xmm6)			\
+	AS2(	paddd		xmm6, xmm7)			\
+	AS2(	psllq		xmm6, 32)			\
+	AS2(	paddd		xmm4, xmm6)			\
+	AS2(	movq		QWORD PTR [ecx+8*((n)-1)], xmm4)	\
+	AS1(	pop		esp)\
+	MulEpilogue
+
+#define Top_Begin(n)							\
+	TopPrologue									\
+	AS2(	mov		edx, esp)\
+	AS2(	and		esp, 0xfffffff0)\
+	AS2(	sub		esp, 48*n+16)\
+	AS1(	push	edx)\
+	AS2(	xor		edx, edx)					\
+	ASL(1)										\
+	ASS(	pshufd	xmm0, [eax+edx], 3,1,2,0)	\
+	ASS(	pshufd	xmm1, [eax+edx], 2,0,3,1)	\
+	ASS(	pshufd	xmm2, [edi+edx], 3,1,2,0)	\
+	AS2(	movdqa	[esp+20+2*edx], xmm0)		\
+	AS2(	psrlq	xmm0, 32)					\
+	AS2(	movdqa	[esp+20+2*edx+16], xmm0)	\
+	AS2(	movdqa	[esp+20+16*n+2*edx], xmm1)		\
+	AS2(	psrlq	xmm1, 32)					\
+	AS2(	movdqa	[esp+20+16*n+2*edx+16], xmm1)	\
+	AS2(	movdqa	[esp+20+32*n+2*edx], xmm2)		\
+	AS2(	psrlq	xmm2, 32)					\
+	AS2(	movdqa	[esp+20+32*n+2*edx+16], xmm2)	\
+	AS2(	add		edx, 16)					\
+	AS2(	cmp		edx, 8*(n))					\
+	ASJ(	jne,	1, b)						\
+	AS2(	mov		eax, esi)					\
+	AS2(	lea		edi, [esp+20+00*n+16*(n/2-1)])\
+	AS2(	lea		edx, [esp+20+16*n+16*(n/2-1)])\
+	AS2(	lea		esi, [esp+20+32*n+16*(n/2-1)])\
+	AS2(	pxor	xmm4, xmm4)\
+	AS2(	pxor	xmm5, xmm5)
+
+#define Top_Acc(i)							\
+	AS2(	movq		xmm0, QWORD PTR [esi+i/2*(1-(i-2*(i/2))*2)*16+8])	\
+	AS2(	pmuludq		xmm0, [edx-i/2*(1-(i-2*(i/2))*2)*16])	\
+	AS2(	psrlq		xmm0, 48)				\
+	AS2(	paddd		xmm5, xmm0)\
+
+#define Top_Column0(i)	\
+	AS2(	psllq		xmm5, 32)				\
+	AS2(	add			edi, 16)	\
+	AS2(	add			edx, 16)	\
+	SSE2_MulAdd45\
+	Mul_Acc##i(i)	\
+
+#define Top_Column1(i)	\
+	SSE2_SaveShift(0)					\
+	AS2(	add			esi, 16)	\
+	SSE2_MulAdd45\
+	Mul_Acc##i(i)	\
+	AS2(	shr			eax, 16)	\
+	AS2(	movd		xmm0, eax)\
+	AS2(	movd		xmm1, [ecx+4])\
+	AS2(	psrld		xmm1, 16)\
+	AS2(	pcmpgtd		xmm1, xmm0)\
+	AS2(	psrld		xmm1, 31)\
+	AS2(	paddd		xmm4, xmm1)\
+
+void SSE2_Square4(word *C, const word *A)
+{
+	Squ_Begin(2)
+	Squ_Column0(0, 1)
+	Squ_End(2)
+}
+
+void SSE2_Square8(word *C, const word *A)
+{
+	Squ_Begin(4)
+#ifndef __GNUC__
+	ASJ(	jmp,	0, f)
+	Squ_Acc(2)
+	AS1(	ret) ASL(0)
+#endif
+	Squ_Column0(0, 1)
+	Squ_Column1(1, 1)
+	Squ_Column0(2, 2)
+	Squ_Column1(3, 1)
+	Squ_Column0(4, 1)
+	Squ_End(4)
+}
+
+void SSE2_Square16(word *C, const word *A)
+{
+	Squ_Begin(8)
+#ifndef __GNUC__
+	ASJ(	jmp,	0, f)
+	Squ_Acc(4) Squ_Acc(3) Squ_Acc(2)
+	AS1(	ret) ASL(0)
+#endif
+	Squ_Column0(0, 1)
+	Squ_Column1(1, 1)
+	Squ_Column0(2, 2)
+	Squ_Column1(3, 2)
+	Squ_Column0(4, 3)
+	Squ_Column1(5, 3)
+	Squ_Column0(6, 4)
+	Squ_Column1(7, 3)
+	Squ_Column0(8, 3)
+	Squ_Column1(9, 2)
+	Squ_Column0(10, 2)
+	Squ_Column1(11, 1)
+	Squ_Column0(12, 1)
+	Squ_End(8)
+}
+
+void SSE2_Square32(word *C, const word *A)
+{
+	Squ_Begin(16)
+	ASJ(	jmp,	0, f)
+	Squ_Acc(8) Squ_Acc(7) Squ_Acc(6) Squ_Acc(5) Squ_Acc(4) Squ_Acc(3) Squ_Acc(2)
+	AS1(	ret) ASL(0)
+	Squ_Column0(0, 1)
+	Squ_Column1(1, 1)
+	Squ_Column0(2, 2)
+	Squ_Column1(3, 2)
+	Squ_Column0(4, 3)
+	Squ_Column1(5, 3)
+	Squ_Column0(6, 4)
+	Squ_Column1(7, 4)
+	Squ_Column0(8, 5)
+	Squ_Column1(9, 5)
+	Squ_Column0(10, 6)
+	Squ_Column1(11, 6)
+	Squ_Column0(12, 7)
+	Squ_Column1(13, 7)
+	Squ_Column0(14, 8)
+	Squ_Column1(15, 7)
+	Squ_Column0(16, 7)
+	Squ_Column1(17, 6)
+	Squ_Column0(18, 6)
+	Squ_Column1(19, 5)
+	Squ_Column0(20, 5)
+	Squ_Column1(21, 4)
+	Squ_Column0(22, 4)
+	Squ_Column1(23, 3)
+	Squ_Column0(24, 3)
+	Squ_Column1(25, 2)
+	Squ_Column0(26, 2)
+	Squ_Column1(27, 1)
+	Squ_Column0(28, 1)
+	Squ_End(16)
+}
+
+void SSE2_Multiply4(word *C, const word *A, const word *B)
+{
+	Mul_Begin(2)
+#ifndef __GNUC__
+	ASJ(	jmp,	0, f)
+	Mul_Acc(2)
+	AS1(	ret) ASL(0)
+#endif
+	Mul_Column0(0, 2)
+	Mul_End(2)
+}
+
+void SSE2_Multiply8(word *C, const word *A, const word *B)
+{
+	Mul_Begin(4)
+#ifndef __GNUC__
+	ASJ(	jmp,	0, f)
+	Mul_Acc(4) Mul_Acc(3) Mul_Acc(2)
+	AS1(	ret) ASL(0)
+#endif
+	Mul_Column0(0, 2)
+	Mul_Column1(1, 3)
+	Mul_Column0(2, 4)
+	Mul_Column1(3, 3)
+	Mul_Column0(4, 2)
+	Mul_End(4)
+}
+
+void SSE2_Multiply16(word *C, const word *A, const word *B)
+{
+	Mul_Begin(8)
+#ifndef __GNUC__
+	ASJ(	jmp,	0, f)
+	Mul_Acc(8) Mul_Acc(7) Mul_Acc(6) Mul_Acc(5) Mul_Acc(4) Mul_Acc(3) Mul_Acc(2)
+	AS1(	ret) ASL(0)
+#endif
+	Mul_Column0(0, 2)
+	Mul_Column1(1, 3)
+	Mul_Column0(2, 4)
+	Mul_Column1(3, 5)
+	Mul_Column0(4, 6)
+	Mul_Column1(5, 7)
+	Mul_Column0(6, 8)
+	Mul_Column1(7, 7)
+	Mul_Column0(8, 6)
+	Mul_Column1(9, 5)
+	Mul_Column0(10, 4)
+	Mul_Column1(11, 3)
+	Mul_Column0(12, 2)
+	Mul_End(8)
+}
+
+void SSE2_Multiply32(word *C, const word *A, const word *B)
+{
+	Mul_Begin(16)
+	ASJ(	jmp,	0, f)
+	Mul_Acc(16) Mul_Acc(15) Mul_Acc(14) Mul_Acc(13) Mul_Acc(12) Mul_Acc(11) Mul_Acc(10) Mul_Acc(9) Mul_Acc(8) Mul_Acc(7) Mul_Acc(6) Mul_Acc(5) Mul_Acc(4) Mul_Acc(3) Mul_Acc(2)
+	AS1(	ret) ASL(0)
+	Mul_Column0(0, 2)
+	Mul_Column1(1, 3)
+	Mul_Column0(2, 4)
+	Mul_Column1(3, 5)
+	Mul_Column0(4, 6)
+	Mul_Column1(5, 7)
+	Mul_Column0(6, 8)
+	Mul_Column1(7, 9)
+	Mul_Column0(8, 10)
+	Mul_Column1(9, 11)
+	Mul_Column0(10, 12)
+	Mul_Column1(11, 13)
+	Mul_Column0(12, 14)
+	Mul_Column1(13, 15)
+	Mul_Column0(14, 16)
+	Mul_Column1(15, 15)
+	Mul_Column0(16, 14)
+	Mul_Column1(17, 13)
+	Mul_Column0(18, 12)
+	Mul_Column1(19, 11)
+	Mul_Column0(20, 10)
+	Mul_Column1(21, 9)
+	Mul_Column0(22, 8)
+	Mul_Column1(23, 7)
+	Mul_Column0(24, 6)
+	Mul_Column1(25, 5)
+	Mul_Column0(26, 4)
+	Mul_Column1(27, 3)
+	Mul_Column0(28, 2)
+	Mul_End(16)
+}
+
+void SSE2_MultiplyBottom4(word *C, const word *A, const word *B)
+{
+	Mul_Begin(2)
+	Bot_SaveAcc(0) Bot_Acc(2)
+	Bot_End(2)
+}
+
+void SSE2_MultiplyBottom8(word *C, const word *A, const word *B)
+{
+	Mul_Begin(4)
+#ifndef __GNUC__
+	ASJ(	jmp,	0, f)
+	Mul_Acc(3) Mul_Acc(2)
+	AS1(	ret) ASL(0)
+#endif
+	Mul_Column0(0, 2)
+	Mul_Column1(1, 3)
+	Bot_SaveAcc(2) Bot_Acc(4) Bot_Acc(3) Bot_Acc(2)
+	Bot_End(4)
+}
+
+void SSE2_MultiplyBottom16(word *C, const word *A, const word *B)
+{
+	Mul_Begin(8)
+#ifndef __GNUC__
+	ASJ(	jmp,	0, f)
+	Mul_Acc(7) Mul_Acc(6) Mul_Acc(5) Mul_Acc(4) Mul_Acc(3) Mul_Acc(2)
+	AS1(	ret) ASL(0)
+#endif
+	Mul_Column0(0, 2)
+	Mul_Column1(1, 3)
+	Mul_Column0(2, 4)
+	Mul_Column1(3, 5)
+	Mul_Column0(4, 6)
+	Mul_Column1(5, 7)
+	Bot_SaveAcc(6) Bot_Acc(8) Bot_Acc(7) Bot_Acc(6) Bot_Acc(5) Bot_Acc(4) Bot_Acc(3) Bot_Acc(2)
+	Bot_End(8)
+}
+
+void SSE2_MultiplyBottom32(word *C, const word *A, const word *B)
+{
+	Mul_Begin(16)
+#ifndef __GNUC__
+	ASJ(	jmp,	0, f)
+	Mul_Acc(15) Mul_Acc(14) Mul_Acc(13) Mul_Acc(12) Mul_Acc(11) Mul_Acc(10) Mul_Acc(9) Mul_Acc(8) Mul_Acc(7) Mul_Acc(6) Mul_Acc(5) Mul_Acc(4) Mul_Acc(3) Mul_Acc(2)
+	AS1(	ret) ASL(0)
+#endif
+	Mul_Column0(0, 2)
+	Mul_Column1(1, 3)
+	Mul_Column0(2, 4)
+	Mul_Column1(3, 5)
+	Mul_Column0(4, 6)
+	Mul_Column1(5, 7)
+	Mul_Column0(6, 8)
+	Mul_Column1(7, 9)
+	Mul_Column0(8, 10)
+	Mul_Column1(9, 11)
+	Mul_Column0(10, 12)
+	Mul_Column1(11, 13)
+	Mul_Column0(12, 14)
+	Mul_Column1(13, 15)
+	Bot_SaveAcc(14) Bot_Acc(16) Bot_Acc(15) Bot_Acc(14) Bot_Acc(13) Bot_Acc(12) Bot_Acc(11) Bot_Acc(10) Bot_Acc(9) Bot_Acc(8) Bot_Acc(7) Bot_Acc(6) Bot_Acc(5) Bot_Acc(4) Bot_Acc(3) Bot_Acc(2)
+	Bot_End(16)
+}
+
+void SSE2_MultiplyTop8(word *C, const word *A, const word *B, word L)
+{
+	Top_Begin(4)
+	Top_Acc(3) Top_Acc(2) Top_Acc(1)
+#ifndef __GNUC__
+	ASJ(	jmp,	0, f)
+	Mul_Acc(4) Mul_Acc(3) Mul_Acc(2)
+	AS1(	ret) ASL(0)
+#endif
+	Top_Column0(4)
+	Top_Column1(3)
+	Mul_Column0(0, 2)
+	Top_End(2)
+}
+
+void SSE2_MultiplyTop16(word *C, const word *A, const word *B, word L)
+{
+	Top_Begin(8)
+	Top_Acc(7) Top_Acc(6) Top_Acc(5) Top_Acc(4) Top_Acc(3) Top_Acc(2) Top_Acc(1)
+#ifndef __GNUC__
+	ASJ(	jmp,	0, f)
+	Mul_Acc(8) Mul_Acc(7) Mul_Acc(6) Mul_Acc(5) Mul_Acc(4) Mul_Acc(3) Mul_Acc(2)
+	AS1(	ret) ASL(0)
+#endif
+	Top_Column0(8)
+	Top_Column1(7)
+	Mul_Column0(0, 6)
+	Mul_Column1(1, 5)
+	Mul_Column0(2, 4)
+	Mul_Column1(3, 3)
+	Mul_Column0(4, 2)
+	Top_End(4)
+}
+
+void SSE2_MultiplyTop32(word *C, const word *A, const word *B, word L)
+{
+	Top_Begin(16)
+	Top_Acc(15) Top_Acc(14) Top_Acc(13) Top_Acc(12) Top_Acc(11) Top_Acc(10) Top_Acc(9) Top_Acc(8) Top_Acc(7) Top_Acc(6) Top_Acc(5) Top_Acc(4) Top_Acc(3) Top_Acc(2) Top_Acc(1)
+#ifndef __GNUC__
+	ASJ(	jmp,	0, f)
+	Mul_Acc(16) Mul_Acc(15) Mul_Acc(14) Mul_Acc(13) Mul_Acc(12) Mul_Acc(11) Mul_Acc(10) Mul_Acc(9) Mul_Acc(8) Mul_Acc(7) Mul_Acc(6) Mul_Acc(5) Mul_Acc(4) Mul_Acc(3) Mul_Acc(2)
+	AS1(	ret) ASL(0)
+#endif
+	Top_Column0(16)
+	Top_Column1(15)
+	Mul_Column0(0, 14)
+	Mul_Column1(1, 13)
+	Mul_Column0(2, 12)
+	Mul_Column1(3, 11)
+	Mul_Column0(4, 10)
+	Mul_Column1(5, 9)
+	Mul_Column0(6, 8)
+	Mul_Column1(7, 7)
+	Mul_Column0(8, 6)
+	Mul_Column1(9, 5)
+	Mul_Column0(10, 4)
+	Mul_Column1(11, 3)
+	Mul_Column0(12, 2)
+	Top_End(8)
+}
+
+#endif	// #if CRYPTOPP_INTEGER_SSE2
+
+// ********************************************************
+
+typedef int (CRYPTOPP_FASTCALL * PAdd)(size_t N, word *C, const word *A, const word *B);
+typedef void (* PMul)(word *C, const word *A, const word *B);
+typedef void (* PSqu)(word *C, const word *A);
+typedef void (* PMulTop)(word *C, const word *A, const word *B, word L);
+
+#if CRYPTOPP_INTEGER_SSE2
+static PAdd s_pAdd = &Baseline_Add, s_pSub = &Baseline_Sub;
+static size_t s_recursionLimit = 8;
+#else
+static const size_t s_recursionLimit = 16;
+#endif
+
+static PMul s_pMul[9], s_pBot[9];
+static PSqu s_pSqu[9];
+static PMulTop s_pTop[9];
+
+static void SetFunctionPointers()
+{
+	s_pMul[0] = &Baseline_Multiply2;
+	s_pBot[0] = &Baseline_MultiplyBottom2;
+	s_pSqu[0] = &Baseline_Square2;
+	s_pTop[0] = &Baseline_MultiplyTop2;
+	s_pTop[1] = &Baseline_MultiplyTop4;
+
+#if CRYPTOPP_INTEGER_SSE2
+	if (HasSSE2())
+	{
+#if _MSC_VER != 1200 || defined(NDEBUG)
+		if (IsP4())
+		{
+			s_pAdd = &SSE2_Add;
+			s_pSub = &SSE2_Sub;
+		}
+#endif
+
+		s_recursionLimit = 32;
+
+		s_pMul[1] = &SSE2_Multiply4;
+		s_pMul[2] = &SSE2_Multiply8;
+		s_pMul[4] = &SSE2_Multiply16;
+		s_pMul[8] = &SSE2_Multiply32;
+
+		s_pBot[1] = &SSE2_MultiplyBottom4;
+		s_pBot[2] = &SSE2_MultiplyBottom8;
+		s_pBot[4] = &SSE2_MultiplyBottom16;
+		s_pBot[8] = &SSE2_MultiplyBottom32;
+
+		s_pSqu[1] = &SSE2_Square4;
+		s_pSqu[2] = &SSE2_Square8;
+		s_pSqu[4] = &SSE2_Square16;
+		s_pSqu[8] = &SSE2_Square32;
+
+		s_pTop[2] = &SSE2_MultiplyTop8;
+		s_pTop[4] = &SSE2_MultiplyTop16;
+		s_pTop[8] = &SSE2_MultiplyTop32;
+	}
+	else
+#endif
+	{
+		s_pMul[1] = &Baseline_Multiply4;
+		s_pMul[2] = &Baseline_Multiply8;
+
+		s_pBot[1] = &Baseline_MultiplyBottom4;
+		s_pBot[2] = &Baseline_MultiplyBottom8;
+
+		s_pSqu[1] = &Baseline_Square4;
+		s_pSqu[2] = &Baseline_Square8;
+
+		s_pTop[2] = &Baseline_MultiplyTop8;
+
+#if	!CRYPTOPP_INTEGER_SSE2
+		s_pMul[4] = &Baseline_Multiply16;
+		s_pBot[4] = &Baseline_MultiplyBottom16;
+		s_pSqu[4] = &Baseline_Square16;
+		s_pTop[4] = &Baseline_MultiplyTop16;
+#endif
+	}
+}
+
+inline int Add(word *C, const word *A, const word *B, size_t N)
+{
+#if CRYPTOPP_INTEGER_SSE2
+	return s_pAdd(N, C, A, B);
+#else
+	return Baseline_Add(N, C, A, B);
+#endif
+}
+
+inline int Subtract(word *C, const word *A, const word *B, size_t N)
+{
+#if CRYPTOPP_INTEGER_SSE2
+	return s_pSub(N, C, A, B);
+#else
+	return Baseline_Sub(N, C, A, B);
+#endif
+}
+
+// ********************************************************
+
+
+#define A0		A
+#define A1		(A+N2)
+#define B0		B
+#define B1		(B+N2)
+
+#define T0		T
+#define T1		(T+N2)
+#define T2		(T+N)
+#define T3		(T+N+N2)
+
+#define R0		R
+#define R1		(R+N2)
+#define R2		(R+N)
+#define R3		(R+N+N2)
+
+// R[2*N] - result = A*B
+// T[2*N] - temporary work space
+// A[N] --- multiplier
+// B[N] --- multiplicant
+
+void RecursiveMultiply(word *R, word *T, const word *A, const word *B, size_t N)
+{
+	assert(N>=2 && N%2==0);
+
+	if (N <= s_recursionLimit)
+		s_pMul[N/4](R, A, B);
+	else
+	{
+		const size_t N2 = N/2;
+
+		size_t AN2 = Compare(A0, A1, N2) > 0 ?  0 : N2;
+		Subtract(R0, A + AN2, A + (N2 ^ AN2), N2);
+
+		size_t BN2 = Compare(B0, B1, N2) > 0 ?  0 : N2;
+		Subtract(R1, B + BN2, B + (N2 ^ BN2), N2);
+
+		RecursiveMultiply(R2, T2, A1, B1, N2);
+		RecursiveMultiply(T0, T2, R0, R1, N2);
+		RecursiveMultiply(R0, T2, A0, B0, N2);
+
+		// now T[01] holds (A1-A0)*(B0-B1), R[01] holds A0*B0, R[23] holds A1*B1
+
+		int c2 = Add(R2, R2, R1, N2);
+		int c3 = c2;
+		c2 += Add(R1, R2, R0, N2);
+		c3 += Add(R2, R2, R3, N2);
+
+		if (AN2 == BN2)
+			c3 -= Subtract(R1, R1, T0, N);
+		else
+			c3 += Add(R1, R1, T0, N);
+
+		c3 += Increment(R2, N2, c2);
+		assert (c3 >= 0 && c3 <= 2);
+		Increment(R3, N2, c3);
+	}
+}
+
+// R[2*N] - result = A*A
+// T[2*N] - temporary work space
+// A[N] --- number to be squared
+
+void RecursiveSquare(word *R, word *T, const word *A, size_t N)
+{
+	assert(N && N%2==0);
+
+	if (N <= s_recursionLimit)
+		s_pSqu[N/4](R, A);
+	else
+	{
+		const size_t N2 = N/2;
+
+		RecursiveSquare(R0, T2, A0, N2);
+		RecursiveSquare(R2, T2, A1, N2);
+		RecursiveMultiply(T0, T2, A0, A1, N2);
+
+		int carry = Add(R1, R1, T0, N);
+		carry += Add(R1, R1, T0, N);
+		Increment(R3, N2, carry);
+	}
+}
+
+// R[N] - bottom half of A*B
+// T[3*N/2] - temporary work space
+// A[N] - multiplier
+// B[N] - multiplicant
+
+void RecursiveMultiplyBottom(word *R, word *T, const word *A, const word *B, size_t N)
+{
+	assert(N>=2 && N%2==0);
+
+	if (N <= s_recursionLimit)
+		s_pBot[N/4](R, A, B);
+	else
+	{
+		const size_t N2 = N/2;
+
+		RecursiveMultiply(R, T, A0, B0, N2);
+		RecursiveMultiplyBottom(T0, T1, A1, B0, N2);
+		Add(R1, R1, T0, N2);
+		RecursiveMultiplyBottom(T0, T1, A0, B1, N2);
+		Add(R1, R1, T0, N2);
+	}
+}
+
+// R[N] --- upper half of A*B
+// T[2*N] - temporary work space
+// L[N] --- lower half of A*B
+// A[N] --- multiplier
+// B[N] --- multiplicant
+
+void MultiplyTop(word *R, word *T, const word *L, const word *A, const word *B, size_t N)
+{
+	assert(N>=2 && N%2==0);
+
+	if (N <= s_recursionLimit)
+		s_pTop[N/4](R, A, B, L[N-1]);
+	else
+	{
+		const size_t N2 = N/2;
+
+		size_t AN2 = Compare(A0, A1, N2) > 0 ?  0 : N2;
+		Subtract(R0, A + AN2, A + (N2 ^ AN2), N2);
+
+		size_t BN2 = Compare(B0, B1, N2) > 0 ?  0 : N2;
+		Subtract(R1, B + BN2, B + (N2 ^ BN2), N2);
+
+		RecursiveMultiply(T0, T2, R0, R1, N2);
+		RecursiveMultiply(R0, T2, A1, B1, N2);
+
+		// now T[01] holds (A1-A0)*(B0-B1) = A1*B0+A0*B1-A1*B1-A0*B0, R[01] holds A1*B1
+
+		int t, c3;
+		int c2 = Subtract(T2, L+N2, L, N2);
+
+		if (AN2 == BN2)
+		{
+			c2 -= Add(T2, T2, T0, N2);
+			t = (Compare(T2, R0, N2) == -1);
+			c3 = t - Subtract(T2, T2, T1, N2);
+		}
+		else
+		{
+			c2 += Subtract(T2, T2, T0, N2);
+			t = (Compare(T2, R0, N2) == -1);
+			c3 = t + Add(T2, T2, T1, N2);
+		}
+
+		c2 += t;
+		if (c2 >= 0)
+			c3 += Increment(T2, N2, c2);
+		else
+			c3 -= Decrement(T2, N2, -c2);
+		c3 += Add(R0, T2, R1, N2);
+
+		assert (c3 >= 0 && c3 <= 2);
+		Increment(R1, N2, c3);
+	}
+}
+
+inline void Multiply(word *R, word *T, const word *A, const word *B, size_t N)
+{
+	RecursiveMultiply(R, T, A, B, N);
+}
+
+inline void Square(word *R, word *T, const word *A, size_t N)
+{
+	RecursiveSquare(R, T, A, N);
+}
+
+inline void MultiplyBottom(word *R, word *T, const word *A, const word *B, size_t N)
+{
+	RecursiveMultiplyBottom(R, T, A, B, N);
+}
+
+// R[NA+NB] - result = A*B
+// T[NA+NB] - temporary work space
+// A[NA] ---- multiplier
+// B[NB] ---- multiplicant
+
+void AsymmetricMultiply(word *R, word *T, const word *A, size_t NA, const word *B, size_t NB)
+{
+	if (NA == NB)
+	{
+		if (A == B)
+			Square(R, T, A, NA);
+		else
+			Multiply(R, T, A, B, NA);
+
+		return;
+	}
+
+	if (NA > NB)
+	{
+		std::swap(A, B);
+		std::swap(NA, NB);
+	}
+
+	assert(NB % NA == 0);
+
+	if (NA==2 && !A[1])
+	{
+		switch (A[0])
+		{
+		case 0:
+			SetWords(R, 0, NB+2);
+			return;
+		case 1:
+			CopyWords(R, B, NB);
+			R[NB] = R[NB+1] = 0;
+			return;
+		default:
+			R[NB] = LinearMultiply(R, B, A[0], NB);
+			R[NB+1] = 0;
+			return;
+		}
+	}
+
+	size_t i;
+	if ((NB/NA)%2 == 0)
+	{
+		Multiply(R, T, A, B, NA);
+		CopyWords(T+2*NA, R+NA, NA);
+
+		for (i=2*NA; i<NB; i+=2*NA)
+			Multiply(T+NA+i, T, A, B+i, NA);
+		for (i=NA; i<NB; i+=2*NA)
+			Multiply(R+i, T, A, B+i, NA);
+	}
+	else
+	{
+		for (i=0; i<NB; i+=2*NA)
+			Multiply(R+i, T, A, B+i, NA);
+		for (i=NA; i<NB; i+=2*NA)
+			Multiply(T+NA+i, T, A, B+i, NA);
+	}
+
+	if (Add(R+NA, R+NA, T+2*NA, NB-NA))
+		Increment(R+NB, NA);
+}
+
+// R[N] ----- result = A inverse mod 2**(WORD_BITS*N)
+// T[3*N/2] - temporary work space
+// A[N] ----- an odd number as input
+
+void RecursiveInverseModPower2(word *R, word *T, const word *A, size_t N)
+{
+	if (N==2)
+	{
+		T[0] = AtomicInverseModPower2(A[0]);
+		T[1] = 0;
+		s_pBot[0](T+2, T, A);
+		TwosComplement(T+2, 2);
+		Increment(T+2, 2, 2);
+		s_pBot[0](R, T, T+2);
+	}
+	else
+	{
+		const size_t N2 = N/2;
+		RecursiveInverseModPower2(R0, T0, A0, N2);
+		T0[0] = 1;
+		SetWords(T0+1, 0, N2-1);
+		MultiplyTop(R1, T1, T0, R0, A0, N2);
+		MultiplyBottom(T0, T1, R0, A1, N2);
+		Add(T0, R1, T0, N2);
+		TwosComplement(T0, N2);
+		MultiplyBottom(R1, T1, R0, T0, N2);
+	}
+}
+
+// R[N] --- result = X/(2**(WORD_BITS*N)) mod M
+// T[3*N] - temporary work space
+// X[2*N] - number to be reduced
+// M[N] --- modulus
+// U[N] --- multiplicative inverse of M mod 2**(WORD_BITS*N)
+
+void MontgomeryReduce(word *R, word *T, word *X, const word *M, const word *U, size_t N)
+{
+#if 1
+	MultiplyBottom(R, T, X, U, N);
+	MultiplyTop(T, T+N, X, R, M, N);
+	word borrow = Subtract(T, X+N, T, N);
+	// defend against timing attack by doing this Add even when not needed
+	word carry = Add(T+N, T, M, N);
+	assert(carry | !borrow);
+	CopyWords(R, T + ((0-borrow) & N), N);
+#elif 0
+	const word u = 0-U[0];
+	Declare2Words(p)
+	for (size_t i=0; i<N; i++)
+	{
+		const word t = u * X[i];
+		word c = 0;
+		for (size_t j=0; j<N; j+=2)
+		{
+			MultiplyWords(p, t, M[j]);
+			Acc2WordsBy1(p, X[i+j]);
+			Acc2WordsBy1(p, c);
+			X[i+j] = LowWord(p);
+			c = HighWord(p);
+			MultiplyWords(p, t, M[j+1]);
+			Acc2WordsBy1(p, X[i+j+1]);
+			Acc2WordsBy1(p, c);
+			X[i+j+1] = LowWord(p);
+			c = HighWord(p);
+		}
+
+		if (Increment(X+N+i, N-i, c))
+			while (!Subtract(X+N, X+N, M, N)) {}
+	}
+
+	memcpy(R, X+N, N*WORD_SIZE);
+#else
+	__m64 u = _mm_cvtsi32_si64(0-U[0]), p;
+	for (size_t i=0; i<N; i++)
+	{
+		__m64 t = _mm_cvtsi32_si64(X[i]);
+		t = _mm_mul_su32(t, u);
+		__m64 c = _mm_setzero_si64();
+		for (size_t j=0; j<N; j+=2)
+		{
+			p = _mm_mul_su32(t, _mm_cvtsi32_si64(M[j]));
+			p = _mm_add_si64(p, _mm_cvtsi32_si64(X[i+j]));
+			c = _mm_add_si64(c, p);
+			X[i+j] = _mm_cvtsi64_si32(c);
+			c = _mm_srli_si64(c, 32);
+			p = _mm_mul_su32(t, _mm_cvtsi32_si64(M[j+1]));
+			p = _mm_add_si64(p, _mm_cvtsi32_si64(X[i+j+1]));
+			c = _mm_add_si64(c, p);
+			X[i+j+1] = _mm_cvtsi64_si32(c);
+			c = _mm_srli_si64(c, 32);
+		}
+
+		if (Increment(X+N+i, N-i, _mm_cvtsi64_si32(c)))
+			while (!Subtract(X+N, X+N, M, N)) {}
+	}
+
+	memcpy(R, X+N, N*WORD_SIZE);
+	_mm_empty();
+#endif
+}
+
+// R[N] --- result = X/(2**(WORD_BITS*N/2)) mod M
+// T[2*N] - temporary work space
+// X[2*N] - number to be reduced
+// M[N] --- modulus
+// U[N/2] - multiplicative inverse of M mod 2**(WORD_BITS*N/2)
+// V[N] --- 2**(WORD_BITS*3*N/2) mod M
+
+void HalfMontgomeryReduce(word *R, word *T, const word *X, const word *M, const word *U, const word *V, size_t N)
+{
+	assert(N%2==0 && N>=4);
+
+#define M0		M
+#define M1		(M+N2)
+#define V0		V
+#define V1		(V+N2)
+
+#define X0		X
+#define X1		(X+N2)
+#define X2		(X+N)
+#define X3		(X+N+N2)
+
+	const size_t N2 = N/2;
+	Multiply(T0, T2, V0, X3, N2);
+	int c2 = Add(T0, T0, X0, N);
+	MultiplyBottom(T3, T2, T0, U, N2);
+	MultiplyTop(T2, R, T0, T3, M0, N2);
+	c2 -= Subtract(T2, T1, T2, N2);
+	Multiply(T0, R, T3, M1, N2);
+	c2 -= Subtract(T0, T2, T0, N2);
+	int c3 = -(int)Subtract(T1, X2, T1, N2);
+	Multiply(R0, T2, V1, X3, N2);
+	c3 += Add(R, R, T, N);
+
+	if (c2>0)
+		c3 += Increment(R1, N2);
+	else if (c2<0)
+		c3 -= Decrement(R1, N2, -c2);
+
+	assert(c3>=-1 && c3<=1);
+	if (c3>0)
+		Subtract(R, R, M, N);
+	else if (c3<0)
+		Add(R, R, M, N);
+
+#undef M0
+#undef M1
+#undef V0
+#undef V1
+
+#undef X0
+#undef X1
+#undef X2
+#undef X3
+}
+
+#undef A0
+#undef A1
+#undef B0
+#undef B1
+
+#undef T0
+#undef T1
+#undef T2
+#undef T3
+
+#undef R0
+#undef R1
+#undef R2
+#undef R3
+
+/*
+// do a 3 word by 2 word divide, returns quotient and leaves remainder in A
+static word SubatomicDivide(word *A, word B0, word B1)
+{
+	// assert {A[2],A[1]} < {B1,B0}, so quotient can fit in a word
+	assert(A[2] < B1 || (A[2]==B1 && A[1] < B0));
+
+	// estimate the quotient: do a 2 word by 1 word divide
+	word Q;
+	if (B1+1 == 0)
+		Q = A[2];
+	else
+		Q = DWord(A[1], A[2]).DividedBy(B1+1);
+
+	// now subtract Q*B from A
+	DWord p = DWord::Multiply(B0, Q);
+	DWord u = (DWord) A[0] - p.GetLowHalf();
+	A[0] = u.GetLowHalf();
+	u = (DWord) A[1] - p.GetHighHalf() - u.GetHighHalfAsBorrow() - DWord::Multiply(B1, Q);
+	A[1] = u.GetLowHalf();
+	A[2] += u.GetHighHalf();
+
+	// Q <= actual quotient, so fix it
+	while (A[2] || A[1] > B1 || (A[1]==B1 && A[0]>=B0))
+	{
+		u = (DWord) A[0] - B0;
+		A[0] = u.GetLowHalf();
+		u = (DWord) A[1] - B1 - u.GetHighHalfAsBorrow();
+		A[1] = u.GetLowHalf();
+		A[2] += u.GetHighHalf();
+		Q++;
+		assert(Q);	// shouldn't overflow
+	}
+
+	return Q;
+}
+
+// do a 4 word by 2 word divide, returns 2 word quotient in Q0 and Q1
+static inline void AtomicDivide(word *Q, const word *A, const word *B)
+{
+	if (!B[0] && !B[1]) // if divisor is 0, we assume divisor==2**(2*WORD_BITS)
+	{
+		Q[0] = A[2];
+		Q[1] = A[3];
+	}
+	else
+	{
+		word T[4];
+		T[0] = A[0]; T[1] = A[1]; T[2] = A[2]; T[3] = A[3];
+		Q[1] = SubatomicDivide(T+1, B[0], B[1]);
+		Q[0] = SubatomicDivide(T, B[0], B[1]);
+
+#ifndef NDEBUG
+		// multiply quotient and divisor and add remainder, make sure it equals dividend
+		assert(!T[2] && !T[3] && (T[1] < B[1] || (T[1]==B[1] && T[0]<B[0])));
+		word P[4];
+		LowLevel::Multiply2(P, Q, B);
+		Add(P, P, T, 4);
+		assert(memcmp(P, A, 4*WORD_SIZE)==0);
+#endif
+	}
+}
+*/
+
+static inline void AtomicDivide(word *Q, const word *A, const word *B)
+{
+	word T[4];
+	DWord q = DivideFourWordsByTwo<word, DWord>(T, DWord(A[0], A[1]), DWord(A[2], A[3]), DWord(B[0], B[1]));
+	Q[0] = q.GetLowHalf();
+	Q[1] = q.GetHighHalf();
+
+#ifndef NDEBUG
+	if (B[0] || B[1])
+	{
+		// multiply quotient and divisor and add remainder, make sure it equals dividend
+		assert(!T[2] && !T[3] && (T[1] < B[1] || (T[1]==B[1] && T[0]<B[0])));
+		word P[4];
+		s_pMul[0](P, Q, B);
+		Add(P, P, T, 4);
+		assert(memcmp(P, A, 4*WORD_SIZE)==0);
+	}
+#endif
+}
+
+// for use by Divide(), corrects the underestimated quotient {Q1,Q0}
+static void CorrectQuotientEstimate(word *R, word *T, word *Q, const word *B, size_t N)
+{
+	assert(N && N%2==0);
+
+	AsymmetricMultiply(T, T+N+2, Q, 2, B, N);
+
+	word borrow = Subtract(R, R, T, N+2);
+	assert(!borrow && !R[N+1]);
+
+	while (R[N] || Compare(R, B, N) >= 0)
+	{
+		R[N] -= Subtract(R, R, B, N);
+		Q[1] += (++Q[0]==0);
+		assert(Q[0] || Q[1]); // no overflow
+	}
+}
+
+// R[NB] -------- remainder = A%B
+// Q[NA-NB+2] --- quotient	= A/B
+// T[NA+3*(NB+2)] - temp work space
+// A[NA] -------- dividend
+// B[NB] -------- divisor
+
+void Divide(word *R, word *Q, word *T, const word *A, size_t NA, const word *B, size_t NB)
+{
+	assert(NA && NB && NA%2==0 && NB%2==0);
+	assert(B[NB-1] || B[NB-2]);
+	assert(NB <= NA);
+
+	// set up temporary work space
+	word *const TA=T;
+	word *const TB=T+NA+2;
+	word *const TP=T+NA+2+NB;
+
+	// copy B into TB and normalize it so that TB has highest bit set to 1
+	unsigned shiftWords = (B[NB-1]==0);
+	TB[0] = TB[NB-1] = 0;
+	CopyWords(TB+shiftWords, B, NB-shiftWords);
+	unsigned shiftBits = WORD_BITS - BitPrecision(TB[NB-1]);
+	assert(shiftBits < WORD_BITS);
+	ShiftWordsLeftByBits(TB, NB, shiftBits);
+
+	// copy A into TA and normalize it
+	TA[0] = TA[NA] = TA[NA+1] = 0;
+	CopyWords(TA+shiftWords, A, NA);
+	ShiftWordsLeftByBits(TA, NA+2, shiftBits);
+
+	if (TA[NA+1]==0 && TA[NA] <= 1)
+	{
+		Q[NA-NB+1] = Q[NA-NB] = 0;
+		while (TA[NA] || Compare(TA+NA-NB, TB, NB) >= 0)
+		{
+			TA[NA] -= Subtract(TA+NA-NB, TA+NA-NB, TB, NB);
+			++Q[NA-NB];
+		}
+	}
+	else
+	{
+		NA+=2;
+		assert(Compare(TA+NA-NB, TB, NB) < 0);
+	}
+
+	word BT[2];
+	BT[0] = TB[NB-2] + 1;
+	BT[1] = TB[NB-1] + (BT[0]==0);
+
+	// start reducing TA mod TB, 2 words at a time
+	for (size_t i=NA-2; i>=NB; i-=2)
+	{
+		AtomicDivide(Q+i-NB, TA+i-2, BT);
+		CorrectQuotientEstimate(TA+i-NB, TP, Q+i-NB, TB, NB);
+	}
+
+	// copy TA into R, and denormalize it
+	CopyWords(R, TA+shiftWords, NB);
+	ShiftWordsRightByBits(R, NB, shiftBits);
+}
+
+static inline size_t EvenWordCount(const word *X, size_t N)
+{
+	while (N && X[N-2]==0 && X[N-1]==0)
+		N-=2;
+	return N;
+}
+
+// return k
+// R[N] --- result = A^(-1) * 2^k mod M
+// T[4*N] - temporary work space
+// A[NA] -- number to take inverse of
+// M[N] --- modulus
+
+unsigned int AlmostInverse(word *R, word *T, const word *A, size_t NA, const word *M, size_t N)
+{
+	assert(NA<=N && N && N%2==0);
+
+	word *b = T;
+	word *c = T+N;
+	word *f = T+2*N;
+	word *g = T+3*N;
+	size_t bcLen=2, fgLen=EvenWordCount(M, N);
+	unsigned int k=0;
+	bool s=false;
+
+	SetWords(T, 0, 3*N);
+	b[0]=1;
+	CopyWords(f, A, NA);
+	CopyWords(g, M, N);
+
+	while (1)
+	{
+		word t=f[0];
+		while (!t)
+		{
+			if (EvenWordCount(f, fgLen)==0)
+			{
+				SetWords(R, 0, N);
+				return 0;
+			}
+
+			ShiftWordsRightByWords(f, fgLen, 1);
+			bcLen += 2 * (c[bcLen-1] != 0);
+			assert(bcLen <= N);
+			ShiftWordsLeftByWords(c, bcLen, 1);
+			k+=WORD_BITS;
+			t=f[0];
+		}
+
+		unsigned int i = TrailingZeros(t);
+		t >>= i;
+		k += i;
+
+		if (t==1 && f[1]==0 && EvenWordCount(f+2, fgLen-2)==0)
+		{
+			if (s)
+				Subtract(R, M, b, N);
+			else
+				CopyWords(R, b, N);
+			return k;
+		}
+
+		ShiftWordsRightByBits(f, fgLen, i);
+		t = ShiftWordsLeftByBits(c, bcLen, i);
+		c[bcLen] += t;
+		bcLen += 2 * (t!=0);
+		assert(bcLen <= N);
+
+		bool swap = Compare(f, g, fgLen)==-1;
+		ConditionalSwapPointers(swap, f, g);
+		ConditionalSwapPointers(swap, b, c);
+		s ^= swap;
+
+		fgLen -= 2 * !(f[fgLen-2] | f[fgLen-1]);
+
+		Subtract(f, f, g, fgLen);
+		t = Add(b, b, c, bcLen);
+		b[bcLen] += t;
+		bcLen += 2*t;
+		assert(bcLen <= N);
+	}
+}
+
+// R[N] - result = A/(2^k) mod M
+// A[N] - input
+// M[N] - modulus
+
+void DivideByPower2Mod(word *R, const word *A, size_t k, const word *M, size_t N)
+{
+	CopyWords(R, A, N);
+
+	while (k--)
+	{
+		if (R[0]%2==0)
+			ShiftWordsRightByBits(R, N, 1);
+		else
+		{
+			word carry = Add(R, R, M, N);
+			ShiftWordsRightByBits(R, N, 1);
+			R[N-1] += carry<<(WORD_BITS-1);
+		}
+	}
+}
+
+// R[N] - result = A*(2^k) mod M
+// A[N] - input
+// M[N] - modulus
+
+void MultiplyByPower2Mod(word *R, const word *A, size_t k, const word *M, size_t N)
+{
+	CopyWords(R, A, N);
+
+	while (k--)
+		if (ShiftWordsLeftByBits(R, N, 1) || Compare(R, M, N)>=0)
+			Subtract(R, R, M, N);
+}
+
+// ******************************************************************
+
+InitializeInteger::InitializeInteger()
+{
+	if (!g_pAssignIntToInteger)
+	{
+		SetFunctionPointers();
+		g_pAssignIntToInteger = AssignIntToInteger;
+	}
+}
+
+static const unsigned int RoundupSizeTable[] = {2, 2, 2, 4, 4, 8, 8, 8, 8};
+
+static inline size_t RoundupSize(size_t n)
+{
+	if (n<=8)
+		return RoundupSizeTable[n];
+	else if (n<=16)
+		return 16;
+	else if (n<=32)
+		return 32;
+	else if (n<=64)
+		return 64;
+	else return size_t(1) << BitPrecision(n-1);
+}
+
+Integer::Integer()
+	: reg(2), sign(POSITIVE)
+{
+	reg[0] = reg[1] = 0;
+}
+
+Integer::Integer(const Integer& t)
+	: reg(RoundupSize(t.WordCount())), sign(t.sign)
+{
+	CopyWords(reg, t.reg, reg.size());
+}
+
+Integer::Integer(Sign s, lword value)
+	: reg(2), sign(s)
+{
+	reg[0] = word(value);
+	reg[1] = word(SafeRightShift<WORD_BITS>(value));
+}
+
+Integer::Integer(signed long value)
+	: reg(2)
+{
+	if (value >= 0)
+		sign = POSITIVE;
+	else
+	{
+		sign = NEGATIVE;
+		value = -value;
+	}
+	reg[0] = word(value);
+	reg[1] = word(SafeRightShift<WORD_BITS>((unsigned long)value));
+}
+
+Integer::Integer(Sign s, word high, word low)
+	: reg(2), sign(s)
+{
+	reg[0] = low;
+	reg[1] = high;
+}
+
+bool Integer::IsConvertableToLong() const
+{
+	if (ByteCount() > sizeof(long))
+		return false;
+
+	unsigned long value = (unsigned long)reg[0];
+	value += SafeLeftShift<WORD_BITS, unsigned long>((unsigned long)reg[1]);
+
+	if (sign==POSITIVE)
+		return (signed long)value >= 0;
+	else
+		return -(signed long)value < 0;
+}
+
+signed long Integer::ConvertToLong() const
+{
+	assert(IsConvertableToLong());
+
+	unsigned long value = (unsigned long)reg[0];
+	value += SafeLeftShift<WORD_BITS, unsigned long>((unsigned long)reg[1]);
+	return sign==POSITIVE ? value : -(signed long)value;
+}
+
+Integer::Integer(BufferedTransformation &encodedInteger, size_t byteCount, Signedness s)
+{
+	Decode(encodedInteger, byteCount, s);
+}
+
+Integer::Integer(const byte *encodedInteger, size_t byteCount, Signedness s)
+{
+	Decode(encodedInteger, byteCount, s);
+}
+
+Integer::Integer(BufferedTransformation &bt)
+{
+	BERDecode(bt);
+}
+
+Integer::Integer(RandomNumberGenerator &rng, size_t bitcount)
+{
+	Randomize(rng, bitcount);
+}
+
+Integer::Integer(RandomNumberGenerator &rng, const Integer &min, const Integer &max, RandomNumberType rnType, const Integer &equiv, const Integer &mod)
+{
+	if (!Randomize(rng, min, max, rnType, equiv, mod))
+		throw Integer::RandomNumberNotFound();
+}
+
+Integer Integer::Power2(size_t e)
+{
+	Integer r((word)0, BitsToWords(e+1));
+	r.SetBit(e);
+	return r;
+}
+
+template <long i>
+struct NewInteger
+{
+	Integer * operator()() const
+	{
+		return new Integer(i);
+	}
+};
+
+const Integer &Integer::Zero()
+{
+	return Singleton<Integer>().Ref();
+}
+
+const Integer &Integer::One()
+{
+	return Singleton<Integer, NewInteger<1> >().Ref();
+}
+
+const Integer &Integer::Two()
+{
+	return Singleton<Integer, NewInteger<2> >().Ref();
+}
+
+bool Integer::operator!() const
+{
+	return IsNegative() ? false : (reg[0]==0 && WordCount()==0);
+}
+
+Integer& Integer::operator=(const Integer& t)
+{
+	if (this != &t)
+	{
+		if (reg.size() != t.reg.size() || t.reg[t.reg.size()/2] == 0)
+			reg.New(RoundupSize(t.WordCount()));
+		CopyWords(reg, t.reg, reg.size());
+		sign = t.sign;
+	}
+	return *this;
+}
+
+bool Integer::GetBit(size_t n) const
+{
+	if (n/WORD_BITS >= reg.size())
+		return 0;
+	else
+		return bool((reg[n/WORD_BITS] >> (n % WORD_BITS)) & 1);
+}
+
+void Integer::SetBit(size_t n, bool value)
+{
+	if (value)
+	{
+		reg.CleanGrow(RoundupSize(BitsToWords(n+1)));
+		reg[n/WORD_BITS] |= (word(1) << (n%WORD_BITS));
+	}
+	else
+	{
+		if (n/WORD_BITS < reg.size())
+			reg[n/WORD_BITS] &= ~(word(1) << (n%WORD_BITS));
+	}
+}
+
+byte Integer::GetByte(size_t n) const
+{
+	if (n/WORD_SIZE >= reg.size())
+		return 0;
+	else
+		return byte(reg[n/WORD_SIZE] >> ((n%WORD_SIZE)*8));
+}
+
+void Integer::SetByte(size_t n, byte value)
+{
+	reg.CleanGrow(RoundupSize(BytesToWords(n+1)));
+	reg[n/WORD_SIZE] &= ~(word(0xff) << 8*(n%WORD_SIZE));
+	reg[n/WORD_SIZE] |= (word(value) << 8*(n%WORD_SIZE));
+}
+
+lword Integer::GetBits(size_t i, size_t n) const
+{
+	lword v = 0;
+	assert(n <= sizeof(v)*8);
+	for (unsigned int j=0; j<n; j++)
+		v |= lword(GetBit(i+j)) << j;
+	return v;
+}
+
+Integer Integer::operator-() const
+{
+	Integer result(*this);
+	result.Negate();
+	return result;
+}
+
+Integer Integer::AbsoluteValue() const
+{
+	Integer result(*this);
+	result.sign = POSITIVE;
+	return result;
+}
+
+void Integer::swap(Integer &a)
+{
+	reg.swap(a.reg);
+	std::swap(sign, a.sign);
+}
+
+Integer::Integer(word value, size_t length)
+	: reg(RoundupSize(length)), sign(POSITIVE)
+{
+	reg[0] = value;
+	SetWords(reg+1, 0, reg.size()-1);
+}
+
+template <class T>
+static Integer StringToInteger(const T *str)
+{
+	int radix;
+	// GCC workaround
+	// std::char_traits<wchar_t>::length() not defined in GCC 3.2 and STLport 4.5.3
+	unsigned int length;
+	for (length = 0; str[length] != 0; length++) {}
+
+	Integer v;
+
+	if (length == 0)
+		return v;
+
+	switch (str[length-1])
+	{
+	case 'h':
+	case 'H':
+		radix=16;
+		break;
+	case 'o':
+	case 'O':
+		radix=8;
+		break;
+	case 'b':
+	case 'B':
+		radix=2;
+		break;
+	default:
+		radix=10;
+	}
+
+	if (length > 2 && str[0] == '0' && str[1] == 'x')
+		radix = 16;
+
+	for (unsigned i=0; i<length; i++)
+	{
+		int digit;
+
+		if (str[i] >= '0' && str[i] <= '9')
+			digit = str[i] - '0';
+		else if (str[i] >= 'A' && str[i] <= 'F')
+			digit = str[i] - 'A' + 10;
+		else if (str[i] >= 'a' && str[i] <= 'f')
+			digit = str[i] - 'a' + 10;
+		else
+			digit = radix;
+
+		if (digit < radix)
+		{
+			v *= radix;
+			v += digit;
+		}
+	}
+
+	if (str[0] == '-')
+		v.Negate();
+
+	return v;
+}
+
+Integer::Integer(const char *str)
+	: reg(2), sign(POSITIVE)
+{
+	*this = StringToInteger(str);
+}
+
+Integer::Integer(const wchar_t *str)
+	: reg(2), sign(POSITIVE)
+{
+	*this = StringToInteger(str);
+}
+
+unsigned int Integer::WordCount() const
+{
+	return (unsigned int)CountWords(reg, reg.size());
+}
+
+unsigned int Integer::ByteCount() const
+{
+	unsigned wordCount = WordCount();
+	if (wordCount)
+		return (wordCount-1)*WORD_SIZE + BytePrecision(reg[wordCount-1]);
+	else
+		return 0;
+}
+
+unsigned int Integer::BitCount() const
+{
+	unsigned wordCount = WordCount();
+	if (wordCount)
+		return (wordCount-1)*WORD_BITS + BitPrecision(reg[wordCount-1]);
+	else
+		return 0;
+}
+
+void Integer::Decode(const byte *input, size_t inputLen, Signedness s)
+{
+	StringStore store(input, inputLen);
+	Decode(store, inputLen, s);
+}
+
+void Integer::Decode(BufferedTransformation &bt, size_t inputLen, Signedness s)
+{
+	assert(bt.MaxRetrievable() >= inputLen);
+
+	byte b;
+	bt.Peek(b);
+	sign = ((s==SIGNED) && (b & 0x80)) ? NEGATIVE : POSITIVE;
+
+	while (inputLen>0 && (sign==POSITIVE ? b==0 : b==0xff))
+	{
+		bt.Skip(1);
+		inputLen--;
+		bt.Peek(b);
+	}
+
+	reg.CleanNew(RoundupSize(BytesToWords(inputLen)));
+
+	for (size_t i=inputLen; i > 0; i--)
+	{
+		bt.Get(b);
+		reg[(i-1)/WORD_SIZE] |= word(b) << ((i-1)%WORD_SIZE)*8;
+	}
+
+	if (sign == NEGATIVE)
+	{
+		for (size_t i=inputLen; i<reg.size()*WORD_SIZE; i++)
+			reg[i/WORD_SIZE] |= word(0xff) << (i%WORD_SIZE)*8;
+		TwosComplement(reg, reg.size());
+	}
+}
+
+size_t Integer::MinEncodedSize(Signedness signedness) const
+{
+	unsigned int outputLen = STDMAX(1U, ByteCount());
+	if (signedness == UNSIGNED)
+		return outputLen;
+	if (NotNegative() && (GetByte(outputLen-1) & 0x80))
+		outputLen++;
+	if (IsNegative() && *this < -Power2(outputLen*8-1))
+		outputLen++;
+	return outputLen;
+}
+
+void Integer::Encode(byte *output, size_t outputLen, Signedness signedness) const
+{
+	ArraySink sink(output, outputLen);
+	Encode(sink, outputLen, signedness);
+}
+
+void Integer::Encode(BufferedTransformation &bt, size_t outputLen, Signedness signedness) const
+{
+	if (signedness == UNSIGNED || NotNegative())
+	{
+		for (size_t i=outputLen; i > 0; i--)
+			bt.Put(GetByte(i-1));
+	}
+	else
+	{
+		// take two's complement of *this
+		Integer temp = Integer::Power2(8*STDMAX((size_t)ByteCount(), outputLen)) + *this;
+		temp.Encode(bt, outputLen, UNSIGNED);
+	}
+}
+
+void Integer::DEREncode(BufferedTransformation &bt) const
+{
+	DERGeneralEncoder enc(bt, INTEGER);
+	Encode(enc, MinEncodedSize(SIGNED), SIGNED);
+	enc.MessageEnd();
+}
+
+void Integer::BERDecode(const byte *input, size_t len)
+{
+	StringStore store(input, len);
+	BERDecode(store);
+}
+
+void Integer::BERDecode(BufferedTransformation &bt)
+{
+	BERGeneralDecoder dec(bt, INTEGER);
+	if (!dec.IsDefiniteLength() || dec.MaxRetrievable() < dec.RemainingLength())
+		BERDecodeError();
+	Decode(dec, (size_t)dec.RemainingLength(), SIGNED);
+	dec.MessageEnd();
+}
+
+void Integer::DEREncodeAsOctetString(BufferedTransformation &bt, size_t length) const
+{
+	DERGeneralEncoder enc(bt, OCTET_STRING);
+	Encode(enc, length);
+	enc.MessageEnd();
+}
+
+void Integer::BERDecodeAsOctetString(BufferedTransformation &bt, size_t length)
+{
+	BERGeneralDecoder dec(bt, OCTET_STRING);
+	if (!dec.IsDefiniteLength() || dec.RemainingLength() != length)
+		BERDecodeError();
+	Decode(dec, length);
+	dec.MessageEnd();
+}
+
+size_t Integer::OpenPGPEncode(byte *output, size_t len) const
+{
+	ArraySink sink(output, len);
+	return OpenPGPEncode(sink);
+}
+
+size_t Integer::OpenPGPEncode(BufferedTransformation &bt) const
+{
+	word16 bitCount = BitCount();
+	bt.PutWord16(bitCount);
+	size_t byteCount = BitsToBytes(bitCount);
+	Encode(bt, byteCount);
+	return 2 + byteCount;
+}
+
+void Integer::OpenPGPDecode(const byte *input, size_t len)
+{
+	StringStore store(input, len);
+	OpenPGPDecode(store);
+}
+
+void Integer::OpenPGPDecode(BufferedTransformation &bt)
+{
+	word16 bitCount;
+	if (bt.GetWord16(bitCount) != 2 || bt.MaxRetrievable() < BitsToBytes(bitCount))
+		throw OpenPGPDecodeErr();
+	Decode(bt, BitsToBytes(bitCount));
+}
+
+void Integer::Randomize(RandomNumberGenerator &rng, size_t nbits)
+{
+	const size_t nbytes = nbits/8 + 1;
+	SecByteBlock buf(nbytes);
+	rng.GenerateBlock(buf, nbytes);
+	if (nbytes)
+		buf[0] = (byte)Crop(buf[0], nbits % 8);
+	Decode(buf, nbytes, UNSIGNED);
+}
+
+void Integer::Randomize(RandomNumberGenerator &rng, const Integer &min, const Integer &max)
+{
+	if (min > max)
+		throw InvalidArgument("Integer: Min must be no greater than Max");
+
+	Integer range = max - min;
+	const unsigned int nbits = range.BitCount();
+
+	do
+	{
+		Randomize(rng, nbits);
+	}
+	while (*this > range);
+
+	*this += min;
+}
+
+bool Integer::Randomize(RandomNumberGenerator &rng, const Integer &min, const Integer &max, RandomNumberType rnType, const Integer &equiv, const Integer &mod)
+{
+	return GenerateRandomNoThrow(rng, MakeParameters("Min", min)("Max", max)("RandomNumberType", rnType)("EquivalentTo", equiv)("Mod", mod));
+}
+
+class KDF2_RNG : public RandomNumberGenerator
+{
+public:
+	KDF2_RNG(const byte *seed, size_t seedSize)
+		: m_counter(0), m_counterAndSeed(seedSize + 4)
+	{
+		memcpy(m_counterAndSeed + 4, seed, seedSize);
+	}
+
+	void GenerateBlock(byte *output, size_t size)
+	{
+		PutWord(false, BIG_ENDIAN_ORDER, m_counterAndSeed, m_counter);
+		++m_counter;
+		P1363_KDF2<SHA1>::DeriveKey(output, size, m_counterAndSeed, m_counterAndSeed.size(), NULL, 0);
+	}
+
+private:
+	word32 m_counter;
+	SecByteBlock m_counterAndSeed;
+};
+
+bool Integer::GenerateRandomNoThrow(RandomNumberGenerator &i_rng, const NameValuePairs &params)
+{
+	Integer min = params.GetValueWithDefault("Min", Integer::Zero());
+	Integer max;
+	if (!params.GetValue("Max", max))
+	{
+		int bitLength;
+		if (params.GetIntValue("BitLength", bitLength))
+			max = Integer::Power2(bitLength);
+		else
+			throw InvalidArgument("Integer: missing Max argument");
+	}
+	if (min > max)
+		throw InvalidArgument("Integer: Min must be no greater than Max");
+
+	Integer equiv = params.GetValueWithDefault("EquivalentTo", Integer::Zero());
+	Integer mod = params.GetValueWithDefault("Mod", Integer::One());
+
+	if (equiv.IsNegative() || equiv >= mod)
+		throw InvalidArgument("Integer: invalid EquivalentTo and/or Mod argument");
+
+	Integer::RandomNumberType rnType = params.GetValueWithDefault("RandomNumberType", Integer::ANY);
+
+	member_ptr<KDF2_RNG> kdf2Rng;
+	ConstByteArrayParameter seed;
+	if (params.GetValue(Name::Seed(), seed))
+	{
+		ByteQueue bq;
+		DERSequenceEncoder seq(bq);
+		min.DEREncode(seq);
+		max.DEREncode(seq);
+		equiv.DEREncode(seq);
+		mod.DEREncode(seq);
+		DEREncodeUnsigned(seq, rnType);
+		DEREncodeOctetString(seq, seed.begin(), seed.size());
+		seq.MessageEnd();
+
+		SecByteBlock finalSeed((size_t)bq.MaxRetrievable());
+		bq.Get(finalSeed, finalSeed.size());
+		kdf2Rng.reset(new KDF2_RNG(finalSeed.begin(), finalSeed.size()));
+	}
+	RandomNumberGenerator &rng = kdf2Rng.get() ? (RandomNumberGenerator &)*kdf2Rng : i_rng;
+
+	switch (rnType)
+	{
+		case ANY:
+			if (mod == One())
+				Randomize(rng, min, max);
+			else
+			{
+				Integer min1 = min + (equiv-min)%mod;
+				if (max < min1)
+					return false;
+				Randomize(rng, Zero(), (max - min1) / mod);
+				*this *= mod;
+				*this += min1;
+			}
+			return true;
+
+		case PRIME:
+		{
+			const PrimeSelector *pSelector = params.GetValueWithDefault(Name::PointerToPrimeSelector(), (const PrimeSelector *)NULL);
+
+			int i;
+			i = 0;
+			while (1)
+			{
+				if (++i==16)
+				{
+					// check if there are any suitable primes in [min, max]
+					Integer first = min;
+					if (FirstPrime(first, max, equiv, mod, pSelector))
+					{
+						// if there is only one suitable prime, we're done
+						*this = first;
+						if (!FirstPrime(first, max, equiv, mod, pSelector))
+							return true;
+					}
+					else
+						return false;
+				}
+
+				Randomize(rng, min, max);
+				if (FirstPrime(*this, STDMIN(*this+mod*PrimeSearchInterval(max), max), equiv, mod, pSelector))
+					return true;
+			}
+		}
+
+		default:
+			throw InvalidArgument("Integer: invalid RandomNumberType argument");
+	}
+}
+
+std::istream& operator>>(std::istream& in, Integer &a)
+{
+	char c;
+	unsigned int length = 0;
+	SecBlock<char> str(length + 16);
+
+	std::ws(in);
+
+	do
+	{
+		in.read(&c, 1);
+		str[length++] = c;
+		if (length >= str.size())
+			str.Grow(length + 16);
+	}
+	while (in && (c=='-' || c=='x' || (c>='0' && c<='9') || (c>='a' && c<='f') || (c>='A' && c<='F') || c=='h' || c=='H' || c=='o' || c=='O' || c==',' || c=='.'));
+
+	if (in.gcount())
+		in.putback(c);
+	str[length-1] = '\0';
+	a = Integer(str);
+
+	return in;
+}
+
+std::ostream& operator<<(std::ostream& out, const Integer &a)
+{
+	// Get relevant conversion specifications from ostream.
+	long f = out.flags() & std::ios::basefield; // Get base digits.
+	int base, block;
+	char suffix;
+	switch(f)
+	{
+	case std::ios::oct :
+		base = 8;
+		block = 8;
+		suffix = 'o';
+		break;
+	case std::ios::hex :
+		base = 16;
+		block = 4;
+		suffix = 'h';
+		break;
+	default :
+		base = 10;
+		block = 3;
+		suffix = '.';
+	}
+
+	Integer temp1=a, temp2;
+    
+	if (a.IsNegative())
+	{
+		out << '-';
+		temp1.Negate();
+	}
+
+	if (!a)
+		out << '0';
+
+	static const char upper[]="0123456789ABCDEF";
+	static const char lower[]="0123456789abcdef";
+
+	const char* vec = (out.flags() & std::ios::uppercase) ? upper : lower;
+	unsigned i=0;
+	SecBlock<char> s(a.BitCount() / (BitPrecision(base)-1) + 1);
+
+	while (!!temp1)
+	{
+		word digit;
+		Integer::Divide(digit, temp2, temp1, base);
+		s[i++]=vec[digit];
+		temp1.swap(temp2);
+	}
+
+	while (i--)
+	{
+		out << s[i];
+//		if (i && !(i%block))
+//			out << ",";
+	}
+	return out << suffix;
+}
+
+Integer& Integer::operator++()
+{
+	if (NotNegative())
+	{
+		if (Increment(reg, reg.size()))
+		{
+			reg.CleanGrow(2*reg.size());
+			reg[reg.size()/2]=1;
+		}
+	}
+	else
+	{
+		word borrow = Decrement(reg, reg.size());
+		assert(!borrow);
+		if (WordCount()==0)
+			*this = Zero();
+	}
+	return *this;
+}
+
+Integer& Integer::operator--()
+{
+	if (IsNegative())
+	{
+		if (Increment(reg, reg.size()))
+		{
+			reg.CleanGrow(2*reg.size());
+			reg[reg.size()/2]=1;
+		}
+	}
+	else
+	{
+		if (Decrement(reg, reg.size()))
+			*this = -One();
+	}
+	return *this;
+}
+
+void PositiveAdd(Integer &sum, const Integer &a, const Integer& b)
+{
+	int carry;
+	if (a.reg.size() == b.reg.size())
+		carry = Add(sum.reg, a.reg, b.reg, a.reg.size());
+	else if (a.reg.size() > b.reg.size())
+	{
+		carry = Add(sum.reg, a.reg, b.reg, b.reg.size());
+		CopyWords(sum.reg+b.reg.size(), a.reg+b.reg.size(), a.reg.size()-b.reg.size());
+		carry = Increment(sum.reg+b.reg.size(), a.reg.size()-b.reg.size(), carry);
+	}
+	else
+	{
+		carry = Add(sum.reg, a.reg, b.reg, a.reg.size());
+		CopyWords(sum.reg+a.reg.size(), b.reg+a.reg.size(), b.reg.size()-a.reg.size());
+		carry = Increment(sum.reg+a.reg.size(), b.reg.size()-a.reg.size(), carry);
+	}
+
+	if (carry)
+	{
+		sum.reg.CleanGrow(2*sum.reg.size());
+		sum.reg[sum.reg.size()/2] = 1;
+	}
+	sum.sign = Integer::POSITIVE;
+}
+
+void PositiveSubtract(Integer &diff, const Integer &a, const Integer& b)
+{
+	unsigned aSize = a.WordCount();
+	aSize += aSize%2;
+	unsigned bSize = b.WordCount();
+	bSize += bSize%2;
+
+	if (aSize == bSize)
+	{
+		if (Compare(a.reg, b.reg, aSize) >= 0)
+		{
+			Subtract(diff.reg, a.reg, b.reg, aSize);
+			diff.sign = Integer::POSITIVE;
+		}
+		else
+		{
+			Subtract(diff.reg, b.reg, a.reg, aSize);
+			diff.sign = Integer::NEGATIVE;
+		}
+	}
+	else if (aSize > bSize)
+	{
+		word borrow = Subtract(diff.reg, a.reg, b.reg, bSize);
+		CopyWords(diff.reg+bSize, a.reg+bSize, aSize-bSize);
+		borrow = Decrement(diff.reg+bSize, aSize-bSize, borrow);
+		assert(!borrow);
+		diff.sign = Integer::POSITIVE;
+	}
+	else
+	{
+		word borrow = Subtract(diff.reg, b.reg, a.reg, aSize);
+		CopyWords(diff.reg+aSize, b.reg+aSize, bSize-aSize);
+		borrow = Decrement(diff.reg+aSize, bSize-aSize, borrow);
+		assert(!borrow);
+		diff.sign = Integer::NEGATIVE;
+	}
+}
+
+// MSVC .NET 2003 workaround
+template <class T> inline const T& STDMAX2(const T& a, const T& b)
+{
+	return a < b ? b : a;
+}
+
+Integer Integer::Plus(const Integer& b) const
+{
+	Integer sum((word)0, STDMAX2(reg.size(), b.reg.size()));
+	if (NotNegative())
+	{
+		if (b.NotNegative())
+			PositiveAdd(sum, *this, b);
+		else
+			PositiveSubtract(sum, *this, b);
+	}
+	else
+	{
+		if (b.NotNegative())
+			PositiveSubtract(sum, b, *this);
+		else
+		{
+			PositiveAdd(sum, *this, b);
+			sum.sign = Integer::NEGATIVE;
+		}
+	}
+	return sum;
+}
+
+Integer& Integer::operator+=(const Integer& t)
+{
+	reg.CleanGrow(t.reg.size());
+	if (NotNegative())
+	{
+		if (t.NotNegative())
+			PositiveAdd(*this, *this, t);
+		else
+			PositiveSubtract(*this, *this, t);
+	}
+	else
+	{
+		if (t.NotNegative())
+			PositiveSubtract(*this, t, *this);
+		else
+		{
+			PositiveAdd(*this, *this, t);
+			sign = Integer::NEGATIVE;
+		}
+	}
+	return *this;
+}
+
+Integer Integer::Minus(const Integer& b) const
+{
+	Integer diff((word)0, STDMAX2(reg.size(), b.reg.size()));
+	if (NotNegative())
+	{
+		if (b.NotNegative())
+			PositiveSubtract(diff, *this, b);
+		else
+			PositiveAdd(diff, *this, b);
+	}
+	else
+	{
+		if (b.NotNegative())
+		{
+			PositiveAdd(diff, *this, b);
+			diff.sign = Integer::NEGATIVE;
+		}
+		else
+			PositiveSubtract(diff, b, *this);
+	}
+	return diff;
+}
+
+Integer& Integer::operator-=(const Integer& t)
+{
+	reg.CleanGrow(t.reg.size());
+	if (NotNegative())
+	{
+		if (t.NotNegative())
+			PositiveSubtract(*this, *this, t);
+		else
+			PositiveAdd(*this, *this, t);
+	}
+	else
+	{
+		if (t.NotNegative())
+		{
+			PositiveAdd(*this, *this, t);
+			sign = Integer::NEGATIVE;
+		}
+		else
+			PositiveSubtract(*this, t, *this);
+	}
+	return *this;
+}
+
+Integer& Integer::operator<<=(size_t n)
+{
+	const size_t wordCount = WordCount();
+	const size_t shiftWords = n / WORD_BITS;
+	const unsigned int shiftBits = (unsigned int)(n % WORD_BITS);
+
+	reg.CleanGrow(RoundupSize(wordCount+BitsToWords(n)));
+	ShiftWordsLeftByWords(reg, wordCount + shiftWords, shiftWords);
+	ShiftWordsLeftByBits(reg+shiftWords, wordCount+BitsToWords(shiftBits), shiftBits);
+	return *this;
+}
+
+Integer& Integer::operator>>=(size_t n)
+{
+	const size_t wordCount = WordCount();
+	const size_t shiftWords = n / WORD_BITS;
+	const unsigned int shiftBits = (unsigned int)(n % WORD_BITS);
+
+	ShiftWordsRightByWords(reg, wordCount, shiftWords);
+	if (wordCount > shiftWords)
+		ShiftWordsRightByBits(reg, wordCount-shiftWords, shiftBits);
+	if (IsNegative() && WordCount()==0)   // avoid -0
+		*this = Zero();
+	return *this;
+}
+
+void PositiveMultiply(Integer &product, const Integer &a, const Integer &b)
+{
+	size_t aSize = RoundupSize(a.WordCount());
+	size_t bSize = RoundupSize(b.WordCount());
+
+	product.reg.CleanNew(RoundupSize(aSize+bSize));
+	product.sign = Integer::POSITIVE;
+
+	IntegerSecBlock workspace(aSize + bSize);
+	AsymmetricMultiply(product.reg, workspace, a.reg, aSize, b.reg, bSize);
+}
+
+void Multiply(Integer &product, const Integer &a, const Integer &b)
+{
+	PositiveMultiply(product, a, b);
+
+	if (a.NotNegative() != b.NotNegative())
+		product.Negate();
+}
+
+Integer Integer::Times(const Integer &b) const
+{
+	Integer product;
+	Multiply(product, *this, b);
+	return product;
+}
+
+/*
+void PositiveDivide(Integer &remainder, Integer &quotient,
+				   const Integer &dividend, const Integer &divisor)
+{
+	remainder.reg.CleanNew(divisor.reg.size());
+	remainder.sign = Integer::POSITIVE;
+	quotient.reg.New(0);
+	quotient.sign = Integer::POSITIVE;
+	unsigned i=dividend.BitCount();
+	while (i--)
+	{
+		word overflow = ShiftWordsLeftByBits(remainder.reg, remainder.reg.size(), 1);
+		remainder.reg[0] |= dividend[i];
+		if (overflow || remainder >= divisor)
+		{
+			Subtract(remainder.reg, remainder.reg, divisor.reg, remainder.reg.size());
+			quotient.SetBit(i);
+		}
+	}
+}
+*/
+
+void PositiveDivide(Integer &remainder, Integer &quotient,
+				   const Integer &a, const Integer &b)
+{
+	unsigned aSize = a.WordCount();
+	unsigned bSize = b.WordCount();
+
+	if (!bSize)
+		throw Integer::DivideByZero();
+
+	if (aSize < bSize)
+	{
+		remainder = a;
+		remainder.sign = Integer::POSITIVE;
+		quotient = Integer::Zero();
+		return;
+	}
+
+	aSize += aSize%2;	// round up to next even number
+	bSize += bSize%2;
+
+	remainder.reg.CleanNew(RoundupSize(bSize));
+	remainder.sign = Integer::POSITIVE;
+	quotient.reg.CleanNew(RoundupSize(aSize-bSize+2));
+	quotient.sign = Integer::POSITIVE;
+
+	IntegerSecBlock T(aSize+3*(bSize+2));
+	Divide(remainder.reg, quotient.reg, T, a.reg, aSize, b.reg, bSize);
+}
+
+void Integer::Divide(Integer &remainder, Integer &quotient, const Integer &dividend, const Integer &divisor)
+{
+	PositiveDivide(remainder, quotient, dividend, divisor);
+
+	if (dividend.IsNegative())
+	{
+		quotient.Negate();
+		if (remainder.NotZero())
+		{
+			--quotient;
+			remainder = divisor.AbsoluteValue() - remainder;
+		}
+	}
+
+	if (divisor.IsNegative())
+		quotient.Negate();
+}
+
+void Integer::DivideByPowerOf2(Integer &r, Integer &q, const Integer &a, unsigned int n)
+{
+	q = a;
+	q >>= n;
+
+	const size_t wordCount = BitsToWords(n);
+	if (wordCount <= a.WordCount())
+	{
+		r.reg.resize(RoundupSize(wordCount));
+		CopyWords(r.reg, a.reg, wordCount);
+		SetWords(r.reg+wordCount, 0, r.reg.size()-wordCount);
+		if (n % WORD_BITS != 0)
+			r.reg[wordCount-1] %= (word(1) << (n % WORD_BITS));
+	}
+	else
+	{
+		r.reg.resize(RoundupSize(a.WordCount()));
+		CopyWords(r.reg, a.reg, r.reg.size());
+	}
+	r.sign = POSITIVE;
+
+	if (a.IsNegative() && r.NotZero())
+	{
+		--q;
+		r = Power2(n) - r;
+	}
+}
+
+Integer Integer::DividedBy(const Integer &b) const
+{
+	Integer remainder, quotient;
+	Integer::Divide(remainder, quotient, *this, b);
+	return quotient;
+}
+
+Integer Integer::Modulo(const Integer &b) const
+{
+	Integer remainder, quotient;
+	Integer::Divide(remainder, quotient, *this, b);
+	return remainder;
+}
+
+void Integer::Divide(word &remainder, Integer &quotient, const Integer &dividend, word divisor)
+{
+	if (!divisor)
+		throw Integer::DivideByZero();
+
+	assert(divisor);
+
+	if ((divisor & (divisor-1)) == 0)	// divisor is a power of 2
+	{
+		quotient = dividend >> (BitPrecision(divisor)-1);
+		remainder = dividend.reg[0] & (divisor-1);
+		return;
+	}
+
+	unsigned int i = dividend.WordCount();
+	quotient.reg.CleanNew(RoundupSize(i));
+	remainder = 0;
+	while (i--)
+	{
+		quotient.reg[i] = DWord(dividend.reg[i], remainder) / divisor;
+		remainder = DWord(dividend.reg[i], remainder) % divisor;
+	}
+
+	if (dividend.NotNegative())
+		quotient.sign = POSITIVE;
+	else
+	{
+		quotient.sign = NEGATIVE;
+		if (remainder)
+		{
+			--quotient;
+			remainder = divisor - remainder;
+		}
+	}
+}
+
+Integer Integer::DividedBy(word b) const
+{
+	word remainder;
+	Integer quotient;
+	Integer::Divide(remainder, quotient, *this, b);
+	return quotient;
+}
+
+word Integer::Modulo(word divisor) const
+{
+	if (!divisor)
+		throw Integer::DivideByZero();
+
+	assert(divisor);
+
+	word remainder;
+
+	if ((divisor & (divisor-1)) == 0)	// divisor is a power of 2
+		remainder = reg[0] & (divisor-1);
+	else
+	{
+		unsigned int i = WordCount();
+
+		if (divisor <= 5)
+		{
+			DWord sum(0, 0);
+			while (i--)
+				sum += reg[i];
+			remainder = sum % divisor;
+		}
+		else
+		{
+			remainder = 0;
+			while (i--)
+				remainder = DWord(reg[i], remainder) % divisor;
+		}
+	}
+
+	if (IsNegative() && remainder)
+		remainder = divisor - remainder;
+
+	return remainder;
+}
+
+void Integer::Negate()
+{
+	if (!!(*this))	// don't flip sign if *this==0
+		sign = Sign(1-sign);
+}
+
+int Integer::PositiveCompare(const Integer& t) const
+{
+	unsigned size = WordCount(), tSize = t.WordCount();
+
+	if (size == tSize)
+		return CryptoPP::Compare(reg, t.reg, size);
+	else
+		return size > tSize ? 1 : -1;
+}
+
+int Integer::Compare(const Integer& t) const
+{
+	if (NotNegative())
+	{
+		if (t.NotNegative())
+			return PositiveCompare(t);
+		else
+			return 1;
+	}
+	else
+	{
+		if (t.NotNegative())
+			return -1;
+		else
+			return -PositiveCompare(t);
+	}
+}
+
+Integer Integer::SquareRoot() const
+{
+	if (!IsPositive())
+		return Zero();
+
+	// overestimate square root
+	Integer x, y = Power2((BitCount()+1)/2);
+	assert(y*y >= *this);
+
+	do
+	{
+		x = y;
+		y = (x + *this/x) >> 1;
+	} while (y<x);
+
+	return x;
+}
+
+bool Integer::IsSquare() const
+{
+	Integer r = SquareRoot();
+	return *this == r.Squared();
+}
+
+bool Integer::IsUnit() const
+{
+	return (WordCount() == 1) && (reg[0] == 1);
+}
+
+Integer Integer::MultiplicativeInverse() const
+{
+	return IsUnit() ? *this : Zero();
+}
+
+Integer a_times_b_mod_c(const Integer &x, const Integer& y, const Integer& m)
+{
+	return x*y%m;
+}
+
+Integer a_exp_b_mod_c(const Integer &x, const Integer& e, const Integer& m)
+{
+	ModularArithmetic mr(m);
+	return mr.Exponentiate(x, e);
+}
+
+Integer Integer::Gcd(const Integer &a, const Integer &b)
+{
+	return EuclideanDomainOf<Integer>().Gcd(a, b);
+}
+
+Integer Integer::InverseMod(const Integer &m) const
+{
+	assert(m.NotNegative());
+
+	if (IsNegative())
+		return Modulo(m).InverseMod(m);
+
+	if (m.IsEven())
+	{
+		if (!m || IsEven())
+			return Zero();	// no inverse
+		if (*this == One())
+			return One();
+
+		Integer u = m.Modulo(*this).InverseMod(*this);
+		return !u ? Zero() : (m*(*this-u)+1)/(*this);
+	}
+
+	SecBlock<word> T(m.reg.size() * 4);
+	Integer r((word)0, m.reg.size());
+	unsigned k = AlmostInverse(r.reg, T, reg, reg.size(), m.reg, m.reg.size());
+	DivideByPower2Mod(r.reg, r.reg, k, m.reg, m.reg.size());
+	return r;
+}
+
+word Integer::InverseMod(word mod) const
+{
+	word g0 = mod, g1 = *this % mod;
+	word v0 = 0, v1 = 1;
+	word y;
+
+	while (g1)
+	{
+		if (g1 == 1)
+			return v1;
+		y = g0 / g1;
+		g0 = g0 % g1;
+		v0 += y * v1;
+
+		if (!g0)
+			break;
+		if (g0 == 1)
+			return mod-v0;
+		y = g1 / g0;
+		g1 = g1 % g0;
+		v1 += y * v0;
+	}
+	return 0;
+}
+
+// ********************************************************
+
+ModularArithmetic::ModularArithmetic(BufferedTransformation &bt)
+{
+	BERSequenceDecoder seq(bt);
+	OID oid(seq);
+	if (oid != ASN1::prime_field())
+		BERDecodeError();
+	m_modulus.BERDecode(seq);
+	seq.MessageEnd();
+	m_result.reg.resize(m_modulus.reg.size());
+}
+
+void ModularArithmetic::DEREncode(BufferedTransformation &bt) const
+{
+	DERSequenceEncoder seq(bt);
+	ASN1::prime_field().DEREncode(seq);
+	m_modulus.DEREncode(seq);
+	seq.MessageEnd();
+}
+
+void ModularArithmetic::DEREncodeElement(BufferedTransformation &out, const Element &a) const
+{
+	a.DEREncodeAsOctetString(out, MaxElementByteLength());
+}
+
+void ModularArithmetic::BERDecodeElement(BufferedTransformation &in, Element &a) const
+{
+	a.BERDecodeAsOctetString(in, MaxElementByteLength());
+}
+
+const Integer& ModularArithmetic::Half(const Integer &a) const
+{
+	if (a.reg.size()==m_modulus.reg.size())
+	{
+		CryptoPP::DivideByPower2Mod(m_result.reg.begin(), a.reg, 1, m_modulus.reg, a.reg.size());
+		return m_result;
+	}
+	else
+		return m_result1 = (a.IsEven() ? (a >> 1) : ((a+m_modulus) >> 1));
+}
+
+const Integer& ModularArithmetic::Add(const Integer &a, const Integer &b) const
+{
+	if (a.reg.size()==m_modulus.reg.size() && b.reg.size()==m_modulus.reg.size())
+	{
+		if (CryptoPP::Add(m_result.reg.begin(), a.reg, b.reg, a.reg.size())
+			|| Compare(m_result.reg, m_modulus.reg, a.reg.size()) >= 0)
+		{
+			CryptoPP::Subtract(m_result.reg.begin(), m_result.reg, m_modulus.reg, a.reg.size());
+		}
+		return m_result;
+	}
+	else
+	{
+		m_result1 = a+b;
+		if (m_result1 >= m_modulus)
+			m_result1 -= m_modulus;
+		return m_result1;
+	}
+}
+
+Integer& ModularArithmetic::Accumulate(Integer &a, const Integer &b) const
+{
+	if (a.reg.size()==m_modulus.reg.size() && b.reg.size()==m_modulus.reg.size())
+	{
+		if (CryptoPP::Add(a.reg, a.reg, b.reg, a.reg.size())
+			|| Compare(a.reg, m_modulus.reg, a.reg.size()) >= 0)
+		{
+			CryptoPP::Subtract(a.reg, a.reg, m_modulus.reg, a.reg.size());
+		}
+	}
+	else
+	{
+		a+=b;
+		if (a>=m_modulus)
+			a-=m_modulus;
+	}
+
+	return a;
+}
+
+const Integer& ModularArithmetic::Subtract(const Integer &a, const Integer &b) const
+{
+	if (a.reg.size()==m_modulus.reg.size() && b.reg.size()==m_modulus.reg.size())
+	{
+		if (CryptoPP::Subtract(m_result.reg.begin(), a.reg, b.reg, a.reg.size()))
+			CryptoPP::Add(m_result.reg.begin(), m_result.reg, m_modulus.reg, a.reg.size());
+		return m_result;
+	}
+	else
+	{
+		m_result1 = a-b;
+		if (m_result1.IsNegative())
+			m_result1 += m_modulus;
+		return m_result1;
+	}
+}
+
+Integer& ModularArithmetic::Reduce(Integer &a, const Integer &b) const
+{
+	if (a.reg.size()==m_modulus.reg.size() && b.reg.size()==m_modulus.reg.size())
+	{
+		if (CryptoPP::Subtract(a.reg, a.reg, b.reg, a.reg.size()))
+			CryptoPP::Add(a.reg, a.reg, m_modulus.reg, a.reg.size());
+	}
+	else
+	{
+		a-=b;
+		if (a.IsNegative())
+			a+=m_modulus;
+	}
+
+	return a;
+}
+
+const Integer& ModularArithmetic::Inverse(const Integer &a) const
+{
+	if (!a)
+		return a;
+
+	CopyWords(m_result.reg.begin(), m_modulus.reg, m_modulus.reg.size());
+	if (CryptoPP::Subtract(m_result.reg.begin(), m_result.reg, a.reg, a.reg.size()))
+		Decrement(m_result.reg.begin()+a.reg.size(), m_modulus.reg.size()-a.reg.size());
+
+	return m_result;
+}
+
+Integer ModularArithmetic::CascadeExponentiate(const Integer &x, const Integer &e1, const Integer &y, const Integer &e2) const
+{
+	if (m_modulus.IsOdd())
+	{
+		MontgomeryRepresentation dr(m_modulus);
+		return dr.ConvertOut(dr.CascadeExponentiate(dr.ConvertIn(x), e1, dr.ConvertIn(y), e2));
+	}
+	else
+		return AbstractRing<Integer>::CascadeExponentiate(x, e1, y, e2);
+}
+
+void ModularArithmetic::SimultaneousExponentiate(Integer *results, const Integer &base, const Integer *exponents, unsigned int exponentsCount) const
+{
+	if (m_modulus.IsOdd())
+	{
+		MontgomeryRepresentation dr(m_modulus);
+		dr.SimultaneousExponentiate(results, dr.ConvertIn(base), exponents, exponentsCount);
+		for (unsigned int i=0; i<exponentsCount; i++)
+			results[i] = dr.ConvertOut(results[i]);
+	}
+	else
+		AbstractRing<Integer>::SimultaneousExponentiate(results, base, exponents, exponentsCount);
+}
+
+MontgomeryRepresentation::MontgomeryRepresentation(const Integer &m)	// modulus must be odd
+	: ModularArithmetic(m),
+	  m_u((word)0, m_modulus.reg.size()),
+	  m_workspace(5*m_modulus.reg.size())
+{
+	if (!m_modulus.IsOdd())
+		throw InvalidArgument("MontgomeryRepresentation: Montgomery representation requires an odd modulus");
+
+	RecursiveInverseModPower2(m_u.reg, m_workspace, m_modulus.reg, m_modulus.reg.size());
+}
+
+const Integer& MontgomeryRepresentation::Multiply(const Integer &a, const Integer &b) const
+{
+	word *const T = m_workspace.begin();
+	word *const R = m_result.reg.begin();
+	const size_t N = m_modulus.reg.size();
+	assert(a.reg.size()<=N && b.reg.size()<=N);
+
+	AsymmetricMultiply(T, T+2*N, a.reg, a.reg.size(), b.reg, b.reg.size());
+	SetWords(T+a.reg.size()+b.reg.size(), 0, 2*N-a.reg.size()-b.reg.size());
+	MontgomeryReduce(R, T+2*N, T, m_modulus.reg, m_u.reg, N);
+	return m_result;
+}
+
+const Integer& MontgomeryRepresentation::Square(const Integer &a) const
+{
+	word *const T = m_workspace.begin();
+	word *const R = m_result.reg.begin();
+	const size_t N = m_modulus.reg.size();
+	assert(a.reg.size()<=N);
+
+	CryptoPP::Square(T, T+2*N, a.reg, a.reg.size());
+	SetWords(T+2*a.reg.size(), 0, 2*N-2*a.reg.size());
+	MontgomeryReduce(R, T+2*N, T, m_modulus.reg, m_u.reg, N);
+	return m_result;
+}
+
+Integer MontgomeryRepresentation::ConvertOut(const Integer &a) const
+{
+	word *const T = m_workspace.begin();
+	word *const R = m_result.reg.begin();
+	const size_t N = m_modulus.reg.size();
+	assert(a.reg.size()<=N);
+
+	CopyWords(T, a.reg, a.reg.size());
+	SetWords(T+a.reg.size(), 0, 2*N-a.reg.size());
+	MontgomeryReduce(R, T+2*N, T, m_modulus.reg, m_u.reg, N);
+	return m_result;
+}
+
+const Integer& MontgomeryRepresentation::MultiplicativeInverse(const Integer &a) const
+{
+//	  return (EuclideanMultiplicativeInverse(a, modulus)<<(2*WORD_BITS*modulus.reg.size()))%modulus;
+	word *const T = m_workspace.begin();
+	word *const R = m_result.reg.begin();
+	const size_t N = m_modulus.reg.size();
+	assert(a.reg.size()<=N);
+
+	CopyWords(T, a.reg, a.reg.size());
+	SetWords(T+a.reg.size(), 0, 2*N-a.reg.size());
+	MontgomeryReduce(R, T+2*N, T, m_modulus.reg, m_u.reg, N);
+	unsigned k = AlmostInverse(R, T, R, N, m_modulus.reg, N);
+
+//	cout << "k=" << k << " N*32=" << 32*N << endl;
+
+	if (k>N*WORD_BITS)
+		DivideByPower2Mod(R, R, k-N*WORD_BITS, m_modulus.reg, N);
+	else
+		MultiplyByPower2Mod(R, R, N*WORD_BITS-k, m_modulus.reg, N);
+
+	return m_result;
+}
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/iterhash.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/iterhash.cpp
index f7390137..1e31e9fb 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/src/iterhash.cpp
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/iterhash.cpp
@@ -1,122 +1,160 @@
-// iterhash.cpp - written and placed in the public domain by Wei Dai
-
-//#include "pch.h"
-#include "iterhash.h"
-#include "misc.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-template <class T, class BASE>
-IteratedHashBase<T, BASE>::IteratedHashBase(unsigned int blockSize, unsigned int digestSize)
-	: m_data(blockSize/sizeof(T)), m_digest(digestSize/sizeof(T))
-	, m_countHi(0), m_countLo(0)
-{
-}
-
-template <class T, class BASE> void IteratedHashBase<T, BASE>::Update(const byte *input, unsigned int len)
-{
-	HashWordType tmp = m_countLo;
-	if ((m_countLo = tmp + len) < tmp)
-		m_countHi++;             // carry from low to high
-	m_countHi += SafeRightShift<8*sizeof(HashWordType)>(len);
-
-	unsigned int blockSize = BlockSize();
-	unsigned int num = ModPowerOf2(tmp, blockSize);
-
-	if (num != 0)	// process left over data
-	{
-		if ((num+len) >= blockSize)
-		{
-			memcpy((byte *)m_data.begin()+num, input, blockSize-num);
-			HashBlock(m_data);
-			input += (blockSize-num);
-			len-=(blockSize - num);
-			num=0;
-			// drop through and do the rest
-		}
-		else
-		{
-			memcpy((byte *)m_data.begin()+num, input, len);
-			return;
-		}
-	}
-
-	// now process the input data in blocks of blockSize bytes and save the leftovers to m_data
-	if (len >= blockSize)
-	{
-		if (input == (byte *)m_data.begin())
-		{
-			assert(len == blockSize);
-			HashBlock(m_data);
-			return;
-		}
-		else if (IsAligned<T>(input))
-		{
-			unsigned int leftOver = HashMultipleBlocks((T *)input, len);
-			input += (len - leftOver);
-			len = leftOver;
-		}
-		else
-			do
-			{   // copy input first if it's not aligned correctly
-				memcpy(m_data, input, blockSize);
-				HashBlock(m_data);
-				input+=blockSize;
-				len-=blockSize;
-			} while (len >= blockSize);
-	}
-
-	memcpy(m_data, input, len);
-}
-
-template <class T, class BASE> byte * IteratedHashBase<T, BASE>::CreateUpdateSpace(unsigned int &size)
-{
-	unsigned int blockSize = BlockSize();
-	unsigned int num = ModPowerOf2(m_countLo, blockSize);
-	size = blockSize - num;
-	return (byte *)m_data.begin() + num;
-}
-
-template <class T, class BASE> unsigned int IteratedHashBase<T, BASE>::HashMultipleBlocks(const T *input, unsigned int length)
-{
-	unsigned int blockSize = BlockSize();
-	do
-	{
-		HashBlock(input);
-		input += blockSize/sizeof(T);
-		length -= blockSize;
-	}
-	while (length >= blockSize);
-	return length;
-}
-
-template <class T, class BASE> void IteratedHashBase<T, BASE>::PadLastBlock(unsigned int lastBlockSize, byte padFirst)
-{
-	unsigned int blockSize = BlockSize();
-	unsigned int num = ModPowerOf2(m_countLo, blockSize);
-	((byte *)m_data.begin())[num++]=padFirst;
-	if (num <= lastBlockSize)
-		memset((byte *)m_data.begin()+num, 0, lastBlockSize-num);
-	else
-	{
-		memset((byte *)m_data.begin()+num, 0, blockSize-num);
-		HashBlock(m_data);
-		memset(m_data, 0, lastBlockSize);
-	}
-}
-
-template <class T, class BASE> void IteratedHashBase<T, BASE>::Restart()
-{
-	m_countLo = m_countHi = 0;
-	Init();
-}
-
-#ifdef WORD64_AVAILABLE
-template class IteratedHashBase<word64, HashTransformation>;
-template class IteratedHashBase<word64, MessageAuthenticationCode>;
-#endif
-
-template class IteratedHashBase<word32, HashTransformation>;
-template class IteratedHashBase<word32, MessageAuthenticationCode>;
-
-NAMESPACE_END
+// iterhash.cpp - written and placed in the public domain by Wei Dai
+
+#ifndef __GNUC__
+#define CRYPTOPP_MANUALLY_INSTANTIATE_TEMPLATES
+#endif
+
+#include "iterhash.h"
+#include "misc.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+template <class T, class BASE> void IteratedHashBase<T, BASE>::Update(const byte *input, size_t len)
+{
+	HashWordType oldCountLo = m_countLo, oldCountHi = m_countHi;
+	if ((m_countLo = oldCountLo + HashWordType(len)) < oldCountLo)
+		m_countHi++;             // carry from low to high
+	m_countHi += (HashWordType)SafeRightShift<8*sizeof(HashWordType)>(len);
+	if (m_countHi < oldCountHi || SafeRightShift<2*8*sizeof(HashWordType)>(len) != 0)
+		throw HashInputTooLong(this->AlgorithmName());
+
+	unsigned int blockSize = this->BlockSize();
+	unsigned int num = ModPowerOf2(oldCountLo, blockSize);
+	T* dataBuf = this->DataBuf();
+	byte* data = (byte *)dataBuf;
+
+	if (num != 0)	// process left over data
+	{
+		if (num+len >= blockSize)
+		{
+			memcpy(data+num, input, blockSize-num);
+			HashBlock(dataBuf);
+			input += (blockSize-num);
+			len -= (blockSize-num);
+			num = 0;
+			// drop through and do the rest
+		}
+		else
+		{
+			memcpy(data+num, input, len);
+			return;
+		}
+	}
+
+	// now process the input data in blocks of blockSize bytes and save the leftovers to m_data
+	if (len >= blockSize)
+	{
+		if (input == data)
+		{
+			assert(len == blockSize);
+			HashBlock(dataBuf);
+			return;
+		}
+		else if (IsAligned<T>(input))
+		{
+			size_t leftOver = HashMultipleBlocks((T *)input, len);
+			input += (len - leftOver);
+			len = leftOver;
+		}
+		else
+			do
+			{   // copy input first if it's not aligned correctly
+				memcpy(data, input, blockSize);
+				HashBlock(dataBuf);
+				input+=blockSize;
+				len-=blockSize;
+			} while (len >= blockSize);
+	}
+
+	if (len && data != input)
+		memcpy(data, input, len);
+}
+
+template <class T, class BASE> byte * IteratedHashBase<T, BASE>::CreateUpdateSpace(size_t &size)
+{
+	unsigned int blockSize = this->BlockSize();
+	unsigned int num = ModPowerOf2(m_countLo, blockSize);
+	size = blockSize - num;
+	return (byte *)DataBuf() + num;
+}
+
+template <class T, class BASE> size_t IteratedHashBase<T, BASE>::HashMultipleBlocks(const T *input, size_t length)
+{
+	unsigned int blockSize = this->BlockSize();
+	bool noReverse = NativeByteOrderIs(this->GetByteOrder());
+	T* dataBuf = this->DataBuf();
+	do
+	{
+		if (noReverse)
+			this->HashEndianCorrectedBlock(input);
+		else
+		{
+			ByteReverse(dataBuf, input, this->BlockSize());
+			this->HashEndianCorrectedBlock(dataBuf);
+		}
+
+		input += blockSize/sizeof(T);
+		length -= blockSize;
+	}
+	while (length >= blockSize);
+	return length;
+}
+
+template <class T, class BASE> void IteratedHashBase<T, BASE>::PadLastBlock(unsigned int lastBlockSize, byte padFirst)
+{
+	unsigned int blockSize = this->BlockSize();
+	unsigned int num = ModPowerOf2(m_countLo, blockSize);
+	T* dataBuf = this->DataBuf();
+	byte* data = (byte *)dataBuf;
+	data[num++] = padFirst;
+	if (num <= lastBlockSize)
+		memset(data+num, 0, lastBlockSize-num);
+	else
+	{
+		memset(data+num, 0, blockSize-num);
+		HashBlock(dataBuf);
+		memset(data, 0, lastBlockSize);
+	}
+}
+
+template <class T, class BASE> void IteratedHashBase<T, BASE>::Restart()
+{
+	m_countLo = m_countHi = 0;
+	Init();
+}
+
+template <class T, class BASE> void IteratedHashBase<T, BASE>::TruncatedFinal(byte *digest, size_t size)
+{
+	this->ThrowIfInvalidTruncatedSize(size);
+
+	T* dataBuf = this->DataBuf();
+	T* stateBuf = this->StateBuf();
+	unsigned int blockSize = this->BlockSize();
+	ByteOrder order = this->GetByteOrder();
+
+	PadLastBlock(blockSize - 2*sizeof(HashWordType));
+	dataBuf[blockSize/sizeof(T)-2+order] = ConditionalByteReverse(order, this->GetBitCountLo());
+	dataBuf[blockSize/sizeof(T)-1-order] = ConditionalByteReverse(order, this->GetBitCountHi());
+
+	HashBlock(dataBuf);
+
+	if (IsAligned<HashWordType>(digest) && size%sizeof(HashWordType)==0)
+		ConditionalByteReverse<HashWordType>(order, (HashWordType *)digest, stateBuf, size);
+	else
+	{
+		ConditionalByteReverse<HashWordType>(order, stateBuf, stateBuf, this->DigestSize());
+		memcpy(digest, stateBuf, size);
+	}
+
+	this->Restart();		// reinit for next use
+}
+
+#ifdef __GNUC__
+	template class IteratedHashBase<word64, HashTransformation>;
+	template class IteratedHashBase<word64, MessageAuthenticationCode>;
+
+	template class IteratedHashBase<word32, HashTransformation>;
+	template class IteratedHashBase<word32, MessageAuthenticationCode>;
+#endif
+
+NAMESPACE_END
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/misc.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/misc.cpp
index a2223d3a..3c2c2a5f 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/src/misc.cpp
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/misc.cpp
@@ -1,83 +1,187 @@
-// misc.cpp - written and placed in the public domain by Wei Dai
-
-//#include "pch.h"
-#include "misc.h"
-#include "words.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-byte OAEP_P_DEFAULT[1];
-
-template<> void ByteReverse(word16 *, const word16 *, unsigned int);
-template<> void ByteReverse(word32 *, const word32 *, unsigned int);
-#ifdef WORD64_AVAILABLE
-template<> void ByteReverse(word64 *, const word64 *, unsigned int);
-#endif
-
-void xorbuf(byte *buf, const byte *mask, unsigned int count)
-{
-	if (((unsigned int)buf | (unsigned int)mask | count) % WORD_SIZE == 0)
-		XorWords((word *)buf, (const word *)mask, count/WORD_SIZE);
-	else
-	{
-		for (unsigned int i=0; i<count; i++)
-			buf[i] ^= mask[i];
-	}
-}
-
-void xorbuf(byte *output, const byte *input, const byte *mask, unsigned int count)
-{
-	if (((unsigned int)output | (unsigned int)input | (unsigned int)mask | count) % WORD_SIZE == 0)
-		XorWords((word *)output, (const word *)input, (const word *)mask, count/WORD_SIZE);
-	else
-	{
-		for (unsigned int i=0; i<count; i++)
-			output[i] = input[i] ^ mask[i];
-	}
-}
-
-unsigned int Parity(unsigned long value)
-{
-	for (unsigned int i=8*sizeof(value)/2; i>0; i/=2)
-		value ^= value >> i;
-	return (unsigned int)value&1;
-}
-
-unsigned int BytePrecision(unsigned long value)
-{
-	unsigned int i;
-	for (i=sizeof(value); i; --i)
-		if (value >> (i-1)*8)
-			break;
-
-	return i;
-}
-
-unsigned int BitPrecision(unsigned long value)
-{
-	if (!value)
-		return 0;
-
-	unsigned int l=0, h=8*sizeof(value);
-
-	while (h-l > 1)
-	{
-		unsigned int t = (l+h)/2;
-		if (value >> t)
-			l = t;
-		else
-			h = t;
-	}
-
-	return h;
-}
-
-unsigned long Crop(unsigned long value, unsigned int size)
-{
-	if (size < 8*sizeof(value))
-    	return (value & ((1L << size) - 1));
-	else
-		return value;
-}
-
-NAMESPACE_END
+// misc.cpp - written and placed in the public domain by Wei Dai
+
+#include "pch.h"
+
+#ifndef CRYPTOPP_IMPORTS
+
+#include "misc.h"
+#include "words.h"
+#include <new>
+
+#if defined(CRYPTOPP_MEMALIGN_AVAILABLE) || defined(CRYPTOPP_MM_MALLOC_AVAILABLE) || defined(QNX)
+#include <malloc.h>
+#endif
+
+NAMESPACE_BEGIN(CryptoPP)
+
+void xorbuf(byte *buf, const byte *mask, size_t count)
+{
+	size_t i;
+
+	if (IsAligned<word32>(buf) && IsAligned<word32>(mask))
+	{
+		if (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))
+		{
+			for (i=0; i<count/8; i++)
+				((word64*)buf)[i] ^= ((word64*)mask)[i];
+			count -= 8*i;
+			if (!count)
+				return;
+			buf += 8*i;
+			mask += 8*i;
+		}
+
+		for (i=0; i<count/4; i++)
+			((word32*)buf)[i] ^= ((word32*)mask)[i];
+		count -= 4*i;
+		if (!count)
+			return;
+		buf += 4*i;
+		mask += 4*i;
+	}
+
+	for (i=0; i<count; i++)
+		buf[i] ^= mask[i];
+}
+
+void xorbuf(byte *output, const byte *input, const byte *mask, size_t count)
+{
+	size_t i;
+
+	if (IsAligned<word32>(output) && IsAligned<word32>(input) && IsAligned<word32>(mask))
+	{
+		if (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(output) && IsAligned<word64>(input) && IsAligned<word64>(mask))
+		{
+			for (i=0; i<count/8; i++)
+				((word64*)output)[i] = ((word64*)input)[i] ^ ((word64*)mask)[i];
+			count -= 8*i;
+			if (!count)
+				return;
+			output += 8*i;
+			input += 8*i;
+			mask += 8*i;
+		}
+
+		for (i=0; i<count/4; i++)
+			((word32*)output)[i] = ((word32*)input)[i] ^ ((word32*)mask)[i];
+		count -= 4*i;
+		if (!count)
+			return;
+		output += 4*i;
+		input += 4*i;
+		mask += 4*i;
+	}
+
+	for (i=0; i<count; i++)
+		output[i] = input[i] ^ mask[i];
+}
+
+bool VerifyBufsEqual(const byte *buf, const byte *mask, size_t count)
+{
+	size_t i;
+	byte acc8 = 0;
+
+	if (IsAligned<word32>(buf) && IsAligned<word32>(mask))
+	{
+		word32 acc32 = 0;
+		if (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))
+		{
+			word64 acc64 = 0;
+			for (i=0; i<count/8; i++)
+				acc64 |= ((word64*)buf)[i] ^ ((word64*)mask)[i];
+			count -= 8*i;
+			if (!count)
+				return acc64 == 0;
+			buf += 8*i;
+			mask += 8*i;
+			acc32 = word32(acc64) | word32(acc64>>32);
+		}
+
+		for (i=0; i<count/4; i++)
+			acc32 |= ((word32*)buf)[i] ^ ((word32*)mask)[i];
+		count -= 4*i;
+		if (!count)
+			return acc32 == 0;
+		buf += 4*i;
+		mask += 4*i;
+		acc8 = byte(acc32) | byte(acc32>>8) | byte(acc32>>16) | byte(acc32>>24);
+	}
+
+	for (i=0; i<count; i++)
+		acc8 |= buf[i] ^ mask[i];
+	return acc8 == 0;
+}
+
+#if !(defined(_MSC_VER) && (_MSC_VER < 1300))
+using std::new_handler;
+using std::set_new_handler;
+#endif
+
+void CallNewHandler()
+{
+	new_handler newHandler = set_new_handler(NULL);
+	if (newHandler)
+		set_new_handler(newHandler);
+
+	if (newHandler)
+		newHandler();
+	else
+		throw std::bad_alloc();
+}
+
+#if CRYPTOPP_BOOL_ALIGN16_ENABLED
+
+void * AlignedAllocate(size_t size)
+{
+	byte *p;
+#ifdef CRYPTOPP_MM_MALLOC_AVAILABLE
+	while (!(p = (byte *)_mm_malloc(size, 16)))
+#elif defined(CRYPTOPP_MEMALIGN_AVAILABLE)
+	while (!(p = (byte *)memalign(16, size)))
+#elif defined(CRYPTOPP_MALLOC_ALIGNMENT_IS_16)
+	while (!(p = (byte *)malloc(size)))
+#else
+	while (!(p = (byte *)malloc(size + 16)))
+#endif
+		CallNewHandler();
+
+#ifdef CRYPTOPP_NO_ALIGNED_ALLOC
+	size_t adjustment = 16-((size_t)p%16);
+	p += adjustment;
+	p[-1] = (byte)adjustment;
+#endif
+
+	assert(IsAlignedOn(p, 16));
+	return p;
+}
+
+void AlignedDeallocate(void *p)
+{
+#ifdef CRYPTOPP_MM_MALLOC_AVAILABLE
+	_mm_free(p);
+#elif defined(CRYPTOPP_NO_ALIGNED_ALLOC)
+	p = (byte *)p - ((byte *)p)[-1];
+	free(p);
+#else
+	free(p);
+#endif
+}
+
+#endif
+
+void * UnalignedAllocate(size_t size)
+{
+	void *p;
+	while (!(p = malloc(size)))
+		CallNewHandler();
+	return p;
+}
+
+void UnalignedDeallocate(void *p)
+{
+	free(p);
+}
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/modes.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/modes.cpp
index 7b3b0d8b..46332284 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/src/modes.cpp
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/modes.cpp
@@ -1,266 +1,245 @@
-// modes.cpp - written and placed in the public domain by Wei Dai
-
-//#include "pch.h"
-#include "modes.h"
-
-#include "des.h"
-
-#include "strciphr.cpp"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-void Modes_TestInstantiations()
-{
-	CFB_Mode<DES>::Encryption m0;
-	CFB_Mode<DES>::Decryption m1;
-	OFB_Mode<DES>::Encryption m2;
-	CTR_Mode<DES>::Encryption m3;
-	ECB_Mode<DES>::Encryption m4;
-	CBC_Mode<DES>::Encryption m5;
-}
-
-// explicit instantiations for Darwin gcc-932.1
-template class CFB_CipherTemplate<AbstractPolicyHolder<CFB_CipherAbstractPolicy, SymmetricCipher> >;
-template class CFB_EncryptionTemplate<>;
-template class CFB_DecryptionTemplate<>;
-template class AdditiveCipherTemplate<>;
-template class CFB_CipherTemplate<AbstractPolicyHolder<CFB_CipherAbstractPolicy, CFB_ModePolicy> >;
-template class CFB_EncryptionTemplate<AbstractPolicyHolder<CFB_CipherAbstractPolicy, CFB_ModePolicy> >;
-template class CFB_DecryptionTemplate<AbstractPolicyHolder<CFB_CipherAbstractPolicy, CFB_ModePolicy> >;
-template class AdditiveCipherTemplate<AbstractPolicyHolder<AdditiveCipherAbstractPolicy, OFB_ModePolicy> >;
-template class AdditiveCipherTemplate<AbstractPolicyHolder<AdditiveCipherAbstractPolicy, CTR_ModePolicy> >;
-
-void CipherModeBase::SetKey(const byte *key, unsigned int length, const NameValuePairs &params)
-{
-	UncheckedSetKey(params, key, length);	// the underlying cipher will check the key length
-}
-
-void CipherModeBase::GetNextIV(byte *IV)
-{
-	if (!IsForwardTransformation())
-		throw NotImplemented("CipherModeBase: GetNextIV() must be called on an encryption object");
-
-	m_cipher->ProcessBlock(m_register);
-	memcpy(IV, m_register, BlockSize());
-}
-
-void CipherModeBase::SetIV(const byte *iv)
-{
-	if (iv)
-		Resynchronize(iv);
-	else if (IsResynchronizable())
-	{
-		if (!CanUseStructuredIVs())
-			throw InvalidArgument("CipherModeBase: this cipher mode cannot use a null IV");
-
-		// use all zeros as default IV
-		SecByteBlock iv(BlockSize());
-		memset(iv, 0, iv.size());
-		Resynchronize(iv);
-	}
-}
-
-void CTR_ModePolicy::SeekToIteration(dword iterationCount)
-{
-	int carry=0;
-	for (int i=BlockSize()-1; i>=0; i--)
-	{
-		unsigned int sum = m_register[i] + byte(iterationCount) + carry;
-		m_counterArray[i] = (byte) sum;
-		carry = sum >> 8;
-		iterationCount >>= 8;
-	}
-}
-
-static inline void IncrementCounterByOne(byte *inout, unsigned int s)
-{
-	for (int i=s-1, carry=1; i>=0 && carry; i--)
-		carry = !++inout[i];
-}
-
-static inline void IncrementCounterByOne(byte *output, const byte *input, unsigned int s)
-{
-	for (int i=s-1, carry=1; i>=0; i--)
-		carry = !(output[i] = input[i]+carry) && carry;
-}
-
-inline void CTR_ModePolicy::ProcessMultipleBlocks(byte *output, const byte *input, unsigned int n)
-{
-	unsigned int s = BlockSize(), j = 0;
-	for (unsigned int i=1; i<n; i++, j+=s)
-		IncrementCounterByOne(m_counterArray + j + s, m_counterArray + j, s);
-	m_cipher->ProcessAndXorMultipleBlocks(m_counterArray, input, output, n);
-	IncrementCounterByOne(m_counterArray, m_counterArray + s*(n-1), s);
-}
-
-void CTR_ModePolicy::OperateKeystream(KeystreamOperation operation, byte *output, const byte *input, unsigned int iterationCount)
-{
-	unsigned int maxBlocks = m_cipher->OptimalNumberOfParallelBlocks();
-	if (maxBlocks == 1)
-	{
-		unsigned int sizeIncrement = BlockSize();
-		while (iterationCount)
-		{
-			m_cipher->ProcessAndXorBlock(m_counterArray, input, output);
-			IncrementCounterByOne(m_counterArray, sizeIncrement);
-			output += sizeIncrement;
-			input += sizeIncrement;
-			iterationCount -= 1;
-		}
-	}
-	else
-	{
-		unsigned int sizeIncrement = maxBlocks * BlockSize();
-		while (iterationCount >= maxBlocks)
-		{
-			ProcessMultipleBlocks(output, input, maxBlocks);
-			output += sizeIncrement;
-			input += sizeIncrement;
-			iterationCount -= maxBlocks;
-		}
-		if (iterationCount > 0)
-			ProcessMultipleBlocks(output, input, iterationCount);
-	}
-}
-
-void CTR_ModePolicy::CipherResynchronize(byte *keystreamBuffer, const byte *iv)
-{
-	unsigned int s = BlockSize();
-	memcpy(m_register, iv, s);
-	m_counterArray.New(s * m_cipher->OptimalNumberOfParallelBlocks());
-	memcpy(m_counterArray, iv, s);
-}
-
-void BlockOrientedCipherModeBase::UncheckedSetKey(const NameValuePairs &params, const byte *key, unsigned int length)
-{
-	m_cipher->SetKey(key, length, params);
-	ResizeBuffers();
-	const byte *iv = params.GetValueWithDefault(Name::IV(), (const byte *)NULL);
-	SetIV(iv);
-}
-
-void BlockOrientedCipherModeBase::ProcessData(byte *outString, const byte *inString, unsigned int length)
-{
-	unsigned int s = BlockSize();
-	assert(length % s == 0);
-	unsigned int alignment = m_cipher->BlockAlignment();
-	bool inputAlignmentOk = !RequireAlignedInput() || IsAlignedOn(inString, alignment);
-
-	if (IsAlignedOn(outString, alignment))
-	{
-		if (inputAlignmentOk)
-			ProcessBlocks(outString, inString, length / s);
-		else
-		{
-			memcpy(outString, inString, length);
-			ProcessBlocks(outString, outString, length / s);
-		}
-	}
-	else
-	{
-		while (length)
-		{
-			if (inputAlignmentOk)
-				ProcessBlocks(m_buffer, inString, 1);
-			else
-			{
-				memcpy(m_buffer, inString, s);
-				ProcessBlocks(m_buffer, m_buffer, 1);
-			}
-			memcpy(outString, m_buffer, s);
-			inString += s;
-			outString += s;
-			length -= s;
-		}
-	}
-}
-
-void CBC_Encryption::ProcessBlocks(byte *outString, const byte *inString, unsigned int numberOfBlocks)
-{
-	unsigned int blockSize = BlockSize();
-	while (numberOfBlocks--)
-	{
-		xorbuf(m_register, inString, blockSize);
-		m_cipher->ProcessBlock(m_register);
-		memcpy(outString, m_register, blockSize);
-		inString += blockSize;
-		outString += blockSize;
-	}
-}
-
-void CBC_CTS_Encryption::ProcessLastBlock(byte *outString, const byte *inString, unsigned int length)
-{
-	if (length <= BlockSize())
-	{
-		if (!m_stolenIV)
-			throw InvalidArgument("CBC_Encryption: message is too short for ciphertext stealing");
-
-		// steal from IV
-		memcpy(outString, m_register, length);
-		outString = m_stolenIV;
-	}
-	else
-	{
-		// steal from next to last block
-		xorbuf(m_register, inString, BlockSize());
-		m_cipher->ProcessBlock(m_register);
-		inString += BlockSize();
-		length -= BlockSize();
-		memcpy(outString+BlockSize(), m_register, length);
-	}
-
-	// output last full ciphertext block
-	xorbuf(m_register, inString, length);
-	m_cipher->ProcessBlock(m_register);
-	memcpy(outString, m_register, BlockSize());
-}
-
-void CBC_Decryption::ProcessBlocks(byte *outString, const byte *inString, unsigned int numberOfBlocks)
-{
-	unsigned int blockSize = BlockSize();
-	while (numberOfBlocks--)
-	{
-		memcpy(m_temp, inString, blockSize);
-		m_cipher->ProcessBlock(m_temp, outString);
-		xorbuf(outString, m_register, blockSize);
-		m_register.swap(m_temp);
-		inString += blockSize;
-		outString += blockSize;
-	}
-}
-
-void CBC_CTS_Decryption::ProcessLastBlock(byte *outString, const byte *inString, unsigned int length)
-{
-	const byte *pn, *pn1;
-	bool stealIV = length <= BlockSize();
-
-	if (stealIV)
-	{
-		pn = inString;
-		pn1 = m_register;
-	}
-	else
-	{
-		pn = inString + BlockSize();
-		pn1 = inString;
-		length -= BlockSize();
-	}
-
-	// decrypt last partial plaintext block
-	memcpy(m_temp, pn1, BlockSize());
-	m_cipher->ProcessBlock(m_temp);
-	xorbuf(m_temp, pn, length);
-
-	if (stealIV)
-		memcpy(outString, m_temp, length);
-	else
-	{
-		memcpy(outString+BlockSize(), m_temp, length);
-		// decrypt next to last plaintext block
-		memcpy(m_temp, pn, length);
-		m_cipher->ProcessBlock(m_temp);
-		xorbuf(outString, m_temp, m_register, BlockSize());
-	}
-}
-
-NAMESPACE_END
+// modes.cpp - written and placed in the public domain by Wei Dai
+
+#include "pch.h"
+
+#ifndef CRYPTOPP_IMPORTS
+
+#include "modes.h"
+
+#ifndef NDEBUG
+#include "des.h"
+#endif
+
+NAMESPACE_BEGIN(CryptoPP)
+
+#ifndef NDEBUG
+void Modes_TestInstantiations()
+{
+	CFB_Mode<DES>::Encryption m0;
+	CFB_Mode<DES>::Decryption m1;
+	OFB_Mode<DES>::Encryption m2;
+	CTR_Mode<DES>::Encryption m3;
+	ECB_Mode<DES>::Encryption m4;
+	CBC_Mode<DES>::Encryption m5;
+}
+#endif
+
+void CFB_ModePolicy::Iterate(byte *output, const byte *input, CipherDir dir, size_t iterationCount)
+{
+	assert(m_cipher->IsForwardTransformation());	// CFB mode needs the "encrypt" direction of the underlying block cipher, even to decrypt
+	assert(m_feedbackSize == BlockSize());
+
+	unsigned int s = BlockSize();
+	if (dir == ENCRYPTION)
+	{
+		m_cipher->ProcessAndXorBlock(m_register, input, output);
+		m_cipher->AdvancedProcessBlocks(output, input+s, output+s, (iterationCount-1)*s, 0);
+		memcpy(m_register, output+(iterationCount-1)*s, s);
+	}
+	else
+	{
+		memcpy(m_temp, input+(iterationCount-1)*s, s);	// make copy first in case of in-place decryption
+		m_cipher->AdvancedProcessBlocks(input, input+s, output+s, (iterationCount-1)*s, BlockTransformation::BT_ReverseDirection);
+		m_cipher->ProcessAndXorBlock(m_register, input, output);
+		memcpy(m_register, m_temp, s);
+	}
+}
+
+void CFB_ModePolicy::TransformRegister()
+{
+	assert(m_cipher->IsForwardTransformation());	// CFB mode needs the "encrypt" direction of the underlying block cipher, even to decrypt
+	m_cipher->ProcessBlock(m_register, m_temp);
+	unsigned int updateSize = BlockSize()-m_feedbackSize;
+	memmove_s(m_register, m_register.size(), m_register+m_feedbackSize, updateSize);
+	memcpy_s(m_register+updateSize, m_register.size()-updateSize, m_temp, m_feedbackSize);
+}
+
+void CFB_ModePolicy::CipherResynchronize(const byte *iv, size_t length)
+{
+	assert(length == BlockSize());
+	CopyOrZero(m_register, iv, length);
+	TransformRegister();
+}
+
+void CFB_ModePolicy::SetFeedbackSize(unsigned int feedbackSize)
+{
+	if (feedbackSize > BlockSize())
+		throw InvalidArgument("CFB_Mode: invalid feedback size");
+	m_feedbackSize = feedbackSize ? feedbackSize : BlockSize();
+}
+
+void CFB_ModePolicy::ResizeBuffers()
+{
+	CipherModeBase::ResizeBuffers();
+	m_temp.New(BlockSize());
+}
+
+void OFB_ModePolicy::WriteKeystream(byte *keystreamBuffer, size_t iterationCount)
+{
+	assert(m_cipher->IsForwardTransformation());	// OFB mode needs the "encrypt" direction of the underlying block cipher, even to decrypt
+	unsigned int s = BlockSize();
+	m_cipher->ProcessBlock(m_register, keystreamBuffer);
+	if (iterationCount > 1)
+		m_cipher->AdvancedProcessBlocks(keystreamBuffer, NULL, keystreamBuffer+s, s*(iterationCount-1), 0);
+	memcpy(m_register, keystreamBuffer+s*(iterationCount-1), s);
+}
+
+void OFB_ModePolicy::CipherResynchronize(byte *keystreamBuffer, const byte *iv, size_t length)
+{
+	assert(length == BlockSize());
+	CopyOrZero(m_register, iv, length);
+}
+
+void CTR_ModePolicy::SeekToIteration(lword iterationCount)
+{
+	int carry=0;
+	for (int i=BlockSize()-1; i>=0; i--)
+	{
+		unsigned int sum = m_register[i] + byte(iterationCount) + carry;
+		m_counterArray[i] = (byte) sum;
+		carry = sum >> 8;
+		iterationCount >>= 8;
+	}
+}
+
+void CTR_ModePolicy::IncrementCounterBy256()
+{
+	IncrementCounterByOne(m_counterArray, BlockSize()-1);
+}
+
+void CTR_ModePolicy::OperateKeystream(KeystreamOperation operation, byte *output, const byte *input, size_t iterationCount)
+{
+	assert(m_cipher->IsForwardTransformation());	// CTR mode needs the "encrypt" direction of the underlying block cipher, even to decrypt
+	unsigned int s = BlockSize();
+	unsigned int inputIncrement = input ? s : 0;
+
+	while (iterationCount)
+	{
+		byte lsb = m_counterArray[s-1];
+		size_t blocks = UnsignedMin(iterationCount, 256U-lsb);
+		m_cipher->AdvancedProcessBlocks(m_counterArray, input, output, blocks*s, BlockTransformation::BT_InBlockIsCounter|BlockTransformation::BT_AllowParallel);
+		if ((m_counterArray[s-1] = lsb + (byte)blocks) == 0)
+			IncrementCounterBy256();
+
+		output += blocks*s;
+		input += blocks*inputIncrement;
+		iterationCount -= blocks;
+	}
+}
+
+void CTR_ModePolicy::CipherResynchronize(byte *keystreamBuffer, const byte *iv, size_t length)
+{
+	assert(length == BlockSize());
+	CopyOrZero(m_register, iv, length);
+	m_counterArray = m_register;
+}
+
+void BlockOrientedCipherModeBase::UncheckedSetKey(const byte *key, unsigned int length, const NameValuePairs &params)
+{
+	m_cipher->SetKey(key, length, params);
+	ResizeBuffers();
+	if (IsResynchronizable())
+	{
+		size_t ivLength;
+		const byte *iv = GetIVAndThrowIfInvalid(params, ivLength);
+		Resynchronize(iv, (int)ivLength);
+	}
+}
+
+void ECB_OneWay::ProcessData(byte *outString, const byte *inString, size_t length)
+{
+	assert(length%BlockSize()==0);
+	m_cipher->AdvancedProcessBlocks(inString, NULL, outString, length, BlockTransformation::BT_AllowParallel);
+}
+
+void CBC_Encryption::ProcessData(byte *outString, const byte *inString, size_t length)
+{
+	if (!length)
+		return;
+	assert(length%BlockSize()==0);
+
+	unsigned int blockSize = BlockSize();
+	m_cipher->AdvancedProcessBlocks(inString, m_register, outString, blockSize, BlockTransformation::BT_XorInput);
+	if (length > blockSize)
+		m_cipher->AdvancedProcessBlocks(inString+blockSize, outString, outString+blockSize, length-blockSize, BlockTransformation::BT_XorInput);
+	memcpy(m_register, outString + length - blockSize, blockSize);
+}
+
+void CBC_CTS_Encryption::ProcessLastBlock(byte *outString, const byte *inString, size_t length)
+{
+	if (length <= BlockSize())
+	{
+		if (!m_stolenIV)
+			throw InvalidArgument("CBC_Encryption: message is too short for ciphertext stealing");
+
+		// steal from IV
+		memcpy(outString, m_register, length);
+		outString = m_stolenIV;
+	}
+	else
+	{
+		// steal from next to last block
+		xorbuf(m_register, inString, BlockSize());
+		m_cipher->ProcessBlock(m_register);
+		inString += BlockSize();
+		length -= BlockSize();
+		memcpy(outString+BlockSize(), m_register, length);
+	}
+
+	// output last full ciphertext block
+	xorbuf(m_register, inString, length);
+	m_cipher->ProcessBlock(m_register);
+	memcpy(outString, m_register, BlockSize());
+}
+
+void CBC_Decryption::ProcessData(byte *outString, const byte *inString, size_t length)
+{
+	if (!length)
+		return;
+	assert(length%BlockSize()==0);
+
+	unsigned int blockSize = BlockSize();
+	memcpy(m_temp, inString+length-blockSize, blockSize);	// save copy now in case of in-place decryption
+	if (length > blockSize)
+		m_cipher->AdvancedProcessBlocks(inString+blockSize, inString, outString+blockSize, length-blockSize, BlockTransformation::BT_ReverseDirection|BlockTransformation::BT_AllowParallel);
+	m_cipher->ProcessAndXorBlock(inString, m_register, outString);
+	m_register.swap(m_temp);
+}
+
+void CBC_CTS_Decryption::ProcessLastBlock(byte *outString, const byte *inString, size_t length)
+{
+	const byte *pn, *pn1;
+	bool stealIV = length <= BlockSize();
+
+	if (stealIV)
+	{
+		pn = inString;
+		pn1 = m_register;
+	}
+	else
+	{
+		pn = inString + BlockSize();
+		pn1 = inString;
+		length -= BlockSize();
+	}
+
+	// decrypt last partial plaintext block
+	memcpy(m_temp, pn1, BlockSize());
+	m_cipher->ProcessBlock(m_temp);
+	xorbuf(m_temp, pn, length);
+
+	if (stealIV)
+		memcpy(outString, m_temp, length);
+	else
+	{
+		memcpy(outString+BlockSize(), m_temp, length);
+		// decrypt next to last plaintext block
+		memcpy(m_temp, pn, length);
+		m_cipher->ProcessBlock(m_temp);
+		xorbuf(outString, m_temp, m_register, BlockSize());
+	}
+}
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/mqueue.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/mqueue.cpp
index 8701cac8..1d645d83 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/src/mqueue.cpp
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/mqueue.cpp
@@ -1,182 +1,174 @@
-// mqueue.cpp - written and placed in the public domain by Wei Dai
-
-//#include "pch.h"
-#include "mqueue.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-MessageQueue::MessageQueue(unsigned int nodeSize)
-	: m_queue(nodeSize), m_lengths(1, 0U), m_messageCounts(1, 0U)
-{
-}
-
-unsigned int MessageQueue::CopyRangeTo2(BufferedTransformation &target, unsigned long &begin, unsigned long end, const std::string &channel, bool blocking) const
-{
-	if (begin >= MaxRetrievable())
-		return 0;
-
-	return m_queue.CopyRangeTo2(target, begin, STDMIN(MaxRetrievable(), end), channel, blocking);
-}
-
-unsigned int MessageQueue::TransferTo2(BufferedTransformation &target, unsigned long &transferBytes, const std::string &channel, bool blocking)
-{
-	transferBytes = STDMIN(MaxRetrievable(), transferBytes);
-	unsigned int blockedBytes = m_queue.TransferTo2(target, transferBytes, channel, blocking);
-	m_lengths.front() -= transferBytes;
-	return blockedBytes;
-}
-
-bool MessageQueue::GetNextMessage()
-{
-	if (NumberOfMessages() > 0 && !AnyRetrievable())
-	{
-		m_lengths.pop_front();
-		if (m_messageCounts[0] == 0 && m_messageCounts.size() > 1)
-			m_messageCounts.pop_front();
-		return true;
-	}
-	else
-		return false;
-}
-
-unsigned int MessageQueue::CopyMessagesTo(BufferedTransformation &target, unsigned int count, const std::string &channel) const
-{
-	ByteQueue::Walker walker(m_queue);
-	std::deque<unsigned long>::const_iterator it = m_lengths.begin();
-	unsigned int i;
-	for (i=0; i<count && it != --m_lengths.end(); ++i, ++it)
-	{
-		walker.TransferTo(target, *it, channel);
-		if (GetAutoSignalPropagation())
-			target.ChannelMessageEnd(channel, GetAutoSignalPropagation()-1);
-	}
-	return i;
-}
-
-void MessageQueue::swap(MessageQueue &rhs)
-{
-	m_queue.swap(rhs.m_queue);
-	m_lengths.swap(rhs.m_lengths);
-}
-
-const byte * MessageQueue::Spy(unsigned int &contiguousSize) const
-{
-	const byte *result = m_queue.Spy(contiguousSize);
-	contiguousSize = (unsigned int)STDMIN((unsigned long)contiguousSize, MaxRetrievable());
-	return result;
-}
-
-// *************************************************************
-
-unsigned int EqualityComparisonFilter::MapChannel(const std::string &channel) const
-{
-	if (channel == m_firstChannel)
-		return 0;
-	else if (channel == m_secondChannel)
-		return 1;
-	else
-		return 2;
-}
-
-unsigned int EqualityComparisonFilter::ChannelPut2(const std::string &channel, const byte *inString, unsigned int length, int messageEnd, bool blocking)
-{
-	if (!blocking)
-		throw BlockingInputOnly("EqualityComparisonFilter");
-
-	unsigned int i = MapChannel(channel);
-
-	if (i == 2)
-		return Output(3, inString, length, messageEnd, blocking, channel);
-	else if (m_mismatchDetected)
-		return 0;
-	else
-	{
-		MessageQueue &q1 = m_q[i], &q2 = m_q[1-i];
-
-		if (q2.AnyMessages() && q2.MaxRetrievable() < length)
-			goto mismatch;
-
-		while (length > 0 && q2.AnyRetrievable())
-		{
-			unsigned int len = length;
-			const byte *data = q2.Spy(len);
-			len = STDMIN(len, length);
-			if (memcmp(inString, data, len) != 0)
-				goto mismatch;
-			inString += len;
-			length -= len;
-			q2.Skip(len);
-		}
-
-		q1.Put(inString, length);
-
-		if (messageEnd)
-		{
-			if (q2.AnyRetrievable())
-				goto mismatch;
-			else if (q2.AnyMessages())
-				q2.GetNextMessage();
-			else if (q2.NumberOfMessageSeries() > 0)
-				goto mismatch;
-			else
-				q1.MessageEnd();
-		}
-
-		return 0;
-
-mismatch:
-		return HandleMismatchDetected(blocking);
-	}
-}
-
-void EqualityComparisonFilter::ChannelInitialize(const std::string &channel, const NameValuePairs &parameters, int propagation)
-{
-	unsigned int i = MapChannel(channel);
-
-	if (i == 2)
-		PropagateInitialize(parameters, propagation, channel);
-	else
-	{
-		m_q[i].Initialize();
-		m_mismatchDetected = false;
-	}
-}
-
-bool EqualityComparisonFilter::ChannelMessageSeriesEnd(const std::string &channel, int propagation, bool blocking)
-{
-	unsigned int i = MapChannel(channel);
-
-	if (i == 2)
-	{
-		OutputMessageSeriesEnd(4, propagation, blocking, channel);
-		return false;
-	}
-	else if (m_mismatchDetected)
-		return false;
-	else
-	{
-		MessageQueue &q1 = m_q[i], &q2 = m_q[1-i];
-
-		if (q2.AnyRetrievable() || q2.AnyMessages())
-			goto mismatch;
-		else if (q2.NumberOfMessageSeries() > 0)
-			return Output(2, (const byte *)"\1", 1, 0, blocking) != 0;
-		else
-			q1.MessageSeriesEnd();
-
-		return false;
-
-mismatch:
-		return HandleMismatchDetected(blocking);
-	}
-}
-
-bool EqualityComparisonFilter::HandleMismatchDetected(bool blocking)
-{
-	m_mismatchDetected = true;
-	if (m_throwIfNotEqual)
-		throw MismatchDetected();
-	return Output(1, (const byte *)"\0", 1, 0, blocking) != 0;
-}
-
-NAMESPACE_END
+// mqueue.cpp - written and placed in the public domain by Wei Dai
+
+#include "pch.h"
+
+#ifndef CRYPTOPP_IMPORTS
+
+#include "mqueue.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+MessageQueue::MessageQueue(unsigned int nodeSize)
+	: m_queue(nodeSize), m_lengths(1, 0U), m_messageCounts(1, 0U)
+{
+}
+
+size_t MessageQueue::CopyRangeTo2(BufferedTransformation &target, lword &begin, lword end, const std::string &channel, bool blocking) const
+{
+	if (begin >= MaxRetrievable())
+		return 0;
+
+	return m_queue.CopyRangeTo2(target, begin, STDMIN(MaxRetrievable(), end), channel, blocking);
+}
+
+size_t MessageQueue::TransferTo2(BufferedTransformation &target, lword &transferBytes, const std::string &channel, bool blocking)
+{
+	transferBytes = STDMIN(MaxRetrievable(), transferBytes);
+	size_t blockedBytes = m_queue.TransferTo2(target, transferBytes, channel, blocking);
+	m_lengths.front() -= transferBytes;
+	return blockedBytes;
+}
+
+bool MessageQueue::GetNextMessage()
+{
+	if (NumberOfMessages() > 0 && !AnyRetrievable())
+	{
+		m_lengths.pop_front();
+		if (m_messageCounts[0] == 0 && m_messageCounts.size() > 1)
+			m_messageCounts.pop_front();
+		return true;
+	}
+	else
+		return false;
+}
+
+unsigned int MessageQueue::CopyMessagesTo(BufferedTransformation &target, unsigned int count, const std::string &channel) const
+{
+	ByteQueue::Walker walker(m_queue);
+	std::deque<lword>::const_iterator it = m_lengths.begin();
+	unsigned int i;
+	for (i=0; i<count && it != --m_lengths.end(); ++i, ++it)
+	{
+		walker.TransferTo(target, *it, channel);
+		if (GetAutoSignalPropagation())
+			target.ChannelMessageEnd(channel, GetAutoSignalPropagation()-1);
+	}
+	return i;
+}
+
+void MessageQueue::swap(MessageQueue &rhs)
+{
+	m_queue.swap(rhs.m_queue);
+	m_lengths.swap(rhs.m_lengths);
+}
+
+const byte * MessageQueue::Spy(size_t &contiguousSize) const
+{
+	const byte *result = m_queue.Spy(contiguousSize);
+	contiguousSize = UnsignedMin(contiguousSize, MaxRetrievable());
+	return result;
+}
+
+// *************************************************************
+
+unsigned int EqualityComparisonFilter::MapChannel(const std::string &channel) const
+{
+	if (channel == m_firstChannel)
+		return 0;
+	else if (channel == m_secondChannel)
+		return 1;
+	else
+		return 2;
+}
+
+size_t EqualityComparisonFilter::ChannelPut2(const std::string &channel, const byte *inString, size_t length, int messageEnd, bool blocking)
+{
+	if (!blocking)
+		throw BlockingInputOnly("EqualityComparisonFilter");
+
+	unsigned int i = MapChannel(channel);
+
+	if (i == 2)
+		return Output(3, inString, length, messageEnd, blocking, channel);
+	else if (m_mismatchDetected)
+		return 0;
+	else
+	{
+		MessageQueue &q1 = m_q[i], &q2 = m_q[1-i];
+
+		if (q2.AnyMessages() && q2.MaxRetrievable() < length)
+			goto mismatch;
+
+		while (length > 0 && q2.AnyRetrievable())
+		{
+			size_t len = length;
+			const byte *data = q2.Spy(len);
+			len = STDMIN(len, length);
+			if (memcmp(inString, data, len) != 0)
+				goto mismatch;
+			inString += len;
+			length -= len;
+			q2.Skip(len);
+		}
+
+		q1.Put(inString, length);
+
+		if (messageEnd)
+		{
+			if (q2.AnyRetrievable())
+				goto mismatch;
+			else if (q2.AnyMessages())
+				q2.GetNextMessage();
+			else if (q2.NumberOfMessageSeries() > 0)
+				goto mismatch;
+			else
+				q1.MessageEnd();
+		}
+
+		return 0;
+
+mismatch:
+		return HandleMismatchDetected(blocking);
+	}
+}
+
+bool EqualityComparisonFilter::ChannelMessageSeriesEnd(const std::string &channel, int propagation, bool blocking)
+{
+	unsigned int i = MapChannel(channel);
+
+	if (i == 2)
+	{
+		OutputMessageSeriesEnd(4, propagation, blocking, channel);
+		return false;
+	}
+	else if (m_mismatchDetected)
+		return false;
+	else
+	{
+		MessageQueue &q1 = m_q[i], &q2 = m_q[1-i];
+
+		if (q2.AnyRetrievable() || q2.AnyMessages())
+			goto mismatch;
+		else if (q2.NumberOfMessageSeries() > 0)
+			return Output(2, (const byte *)"\1", 1, 0, blocking) != 0;
+		else
+			q1.MessageSeriesEnd();
+
+		return false;
+
+mismatch:
+		return HandleMismatchDetected(blocking);
+	}
+}
+
+bool EqualityComparisonFilter::HandleMismatchDetected(bool blocking)
+{
+	m_mismatchDetected = true;
+	if (m_throwIfNotEqual)
+		throw MismatchDetected();
+	return Output(1, (const byte *)"\0", 1, 0, blocking) != 0;
+}
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/osrng.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/osrng.cpp
new file mode 100644
index 00000000..fa6dd36d
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/osrng.cpp
@@ -0,0 +1,171 @@
+// osrng.cpp - written and placed in the public domain by Wei Dai
+
+// Thanks to Leonard Janke for the suggestion for AutoSeededRandomPool.
+
+#include "pch.h"
+
+#ifndef CRYPTOPP_IMPORTS
+
+#include "osrng.h"
+
+#ifdef OS_RNG_AVAILABLE
+
+#include "rng.h"
+
+#ifdef CRYPTOPP_WIN32_AVAILABLE
+#ifndef _WIN32_WINNT
+#define _WIN32_WINNT 0x0400
+#endif
+#include <windows.h>
+#include <wincrypt.h>
+#endif
+
+#ifdef CRYPTOPP_UNIX_AVAILABLE
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#endif
+
+NAMESPACE_BEGIN(CryptoPP)
+
+#if defined(NONBLOCKING_RNG_AVAILABLE) || defined(BLOCKING_RNG_AVAILABLE)
+OS_RNG_Err::OS_RNG_Err(const std::string &operation)
+	: Exception(OTHER_ERROR, "OS_Rng: " + operation + " operation failed with error " + 
+#ifdef CRYPTOPP_WIN32_AVAILABLE
+		"0x" + IntToString(GetLastError(), 16)
+#else
+		IntToString(errno)
+#endif
+		)
+{
+}
+#endif
+
+#ifdef NONBLOCKING_RNG_AVAILABLE
+
+#ifdef CRYPTOPP_WIN32_AVAILABLE
+
+MicrosoftCryptoProvider::MicrosoftCryptoProvider()
+{
+	if(!CryptAcquireContext(&m_hProvider, 0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
+		throw OS_RNG_Err("CryptAcquireContext");
+}
+
+MicrosoftCryptoProvider::~MicrosoftCryptoProvider()
+{
+	CryptReleaseContext(m_hProvider, 0);
+}
+
+#endif
+
+NonblockingRng::NonblockingRng()
+{
+#ifndef CRYPTOPP_WIN32_AVAILABLE
+	m_fd = open("/dev/urandom",O_RDONLY);
+	if (m_fd == -1)
+		throw OS_RNG_Err("open /dev/urandom");
+#endif
+}
+
+NonblockingRng::~NonblockingRng()
+{
+#ifndef CRYPTOPP_WIN32_AVAILABLE
+	close(m_fd);
+#endif
+}
+
+void NonblockingRng::GenerateBlock(byte *output, size_t size)
+{
+#ifdef CRYPTOPP_WIN32_AVAILABLE
+#	ifdef WORKAROUND_MS_BUG_Q258000
+		const MicrosoftCryptoProvider &m_Provider = Singleton<MicrosoftCryptoProvider>().Ref();
+#	endif
+	if (!CryptGenRandom(m_Provider.GetProviderHandle(), (DWORD)size, output))
+		throw OS_RNG_Err("CryptGenRandom");
+#else
+	if (read(m_fd, output, size) != size)
+		throw OS_RNG_Err("read /dev/urandom");
+#endif
+}
+
+#endif
+
+// *************************************************************
+
+#ifdef BLOCKING_RNG_AVAILABLE
+
+#ifndef CRYPTOPP_BLOCKING_RNG_FILENAME
+#ifdef __OpenBSD__
+#define CRYPTOPP_BLOCKING_RNG_FILENAME "/dev/srandom"
+#else
+#define CRYPTOPP_BLOCKING_RNG_FILENAME "/dev/random"
+#endif
+#endif
+
+BlockingRng::BlockingRng()
+{
+	m_fd = open(CRYPTOPP_BLOCKING_RNG_FILENAME,O_RDONLY);
+	if (m_fd == -1)
+		throw OS_RNG_Err("open " CRYPTOPP_BLOCKING_RNG_FILENAME);
+}
+
+BlockingRng::~BlockingRng()
+{
+	close(m_fd);
+}
+
+void BlockingRng::GenerateBlock(byte *output, size_t size)
+{
+	while (size)
+	{
+		// on some systems /dev/random will block until all bytes
+		// are available, on others it will returns immediately
+		ssize_t len = read(m_fd, output, size);
+		if (len < 0)
+			throw OS_RNG_Err("read " CRYPTOPP_BLOCKING_RNG_FILENAME);
+		size -= len;
+		output += len;
+		if (size)
+			sleep(1);
+	}
+}
+
+#endif
+
+// *************************************************************
+
+void OS_GenerateRandomBlock(bool blocking, byte *output, size_t size)
+{
+#ifdef NONBLOCKING_RNG_AVAILABLE
+	if (blocking)
+#endif
+	{
+#ifdef BLOCKING_RNG_AVAILABLE
+		BlockingRng rng;
+		rng.GenerateBlock(output, size);
+#endif
+	}
+
+#ifdef BLOCKING_RNG_AVAILABLE
+	if (!blocking)
+#endif
+	{
+#ifdef NONBLOCKING_RNG_AVAILABLE
+		NonblockingRng rng;
+		rng.GenerateBlock(output, size);
+#endif
+	}
+}
+
+void AutoSeededRandomPool::Reseed(bool blocking, unsigned int seedSize)
+{
+	SecByteBlock seed(seedSize);
+	OS_GenerateRandomBlock(blocking, seed, seedSize);
+	IncorporateEntropy(seed, seedSize);
+}
+
+NAMESPACE_END
+
+#endif
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/pch.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/pch.cpp
new file mode 100644
index 00000000..1d9f38c5
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/pch.cpp
@@ -0,0 +1 @@
+#include "pch.h"
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/queue.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/queue.cpp
index 4c35ed60..ff2f0d31 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/src/queue.cpp
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/queue.cpp
@@ -1,518 +1,565 @@
-// queue.cpp - written and placed in the public domain by Wei Dai
-
-//#include "pch.h"
-#include "queue.h"
-#include "filters.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-// this class for use by ByteQueue only
-class ByteQueueNode
-{
-public:
-	ByteQueueNode(unsigned int maxSize)
-		: buf(maxSize)
-	{
-		m_head = m_tail = 0;
-		next = 0;
-	}
-
-	inline unsigned int MaxSize() const {return buf.size();}
-
-	inline unsigned int CurrentSize() const
-	{
-		return m_tail-m_head;
-	}
-
-	inline bool UsedUp() const
-	{
-		return (m_head==MaxSize());
-	}
-
-	inline void Clear()
-	{
-		m_head = m_tail = 0;
-	}
-
-/*	inline unsigned int Put(byte inByte)
-	{
-		if (MaxSize()==m_tail)
-			return 0;
-
-		buf[m_tail++]=inByte;
-		return 1;
-	}
-*/
-	inline unsigned int Put(const byte *begin, unsigned int length)
-	{
-		unsigned int l = STDMIN(length, MaxSize()-m_tail);
-		memcpy(buf+m_tail, begin, l);
-		m_tail += l;
-		return l;
-	}
-
-	inline unsigned int Peek(byte &outByte) const
-	{
-		if (m_tail==m_head)
-			return 0;
-
-		outByte=buf[m_head];
-		return 1;
-	}
-
-	inline unsigned int Peek(byte *target, unsigned int copyMax) const
-	{
-		unsigned int len = STDMIN(copyMax, m_tail-m_head);
-		memcpy(target, buf+m_head, len);
-		return len;
-	}
-
-	inline unsigned int CopyTo(BufferedTransformation &target, const std::string &channel=BufferedTransformation::NULL_CHANNEL) const
-	{
-		unsigned int len = m_tail-m_head;
-		target.ChannelPut(channel, buf+m_head, len);
-		return len;
-	}
-
-	inline unsigned int CopyTo(BufferedTransformation &target, unsigned int copyMax, const std::string &channel=BufferedTransformation::NULL_CHANNEL) const
-	{
-		unsigned int len = STDMIN(copyMax, m_tail-m_head);
-		target.ChannelPut(channel, buf+m_head, len);
-		return len;
-	}
-
-	inline unsigned int Get(byte &outByte)
-	{
-		unsigned int len = Peek(outByte);
-		m_head += len;
-		return len;
-	}
-
-	inline unsigned int Get(byte *outString, unsigned int getMax)
-	{
-		unsigned int len = Peek(outString, getMax);
-		m_head += len;
-		return len;
-	}
-
-	inline unsigned int TransferTo(BufferedTransformation &target, const std::string &channel=BufferedTransformation::NULL_CHANNEL)
-	{
-		unsigned int len = m_tail-m_head;
-		target.ChannelPutModifiable(channel, buf+m_head, len);
-		m_head = m_tail;
-		return len;
-	}
-
-	inline unsigned int TransferTo(BufferedTransformation &target, unsigned int transferMax, const std::string &channel=BufferedTransformation::NULL_CHANNEL)
-	{
-		unsigned int len = STDMIN(transferMax, m_tail-m_head);
-		target.ChannelPutModifiable(channel, buf+m_head, len);
-		m_head += len;
-		return len;
-	}
-
-	inline unsigned int Skip(unsigned int skipMax)
-	{
-		unsigned int len = STDMIN(skipMax, m_tail-m_head);
-		m_head += len;
-		return len;
-	}
-
-	inline byte operator[](unsigned int i) const
-	{
-		return buf[m_head+i];
-	}
-
-	ByteQueueNode *next;
-
-	SecByteBlock buf;
-	unsigned int m_head, m_tail;
-};
-
-// ********************************************************
-
-ByteQueue::ByteQueue(unsigned int m_nodeSize)
-	: m_nodeSize(m_nodeSize), m_lazyLength(0)
-{
-	m_head = m_tail = new ByteQueueNode(m_nodeSize);
-}
-
-ByteQueue::ByteQueue(const ByteQueue &copy)
-{
-	CopyFrom(copy);
-}
-
-void ByteQueue::CopyFrom(const ByteQueue &copy)
-{
-	m_lazyLength = 0;
-	m_nodeSize = copy.m_nodeSize;
-	m_head = m_tail = new ByteQueueNode(*copy.m_head);
-
-	for (ByteQueueNode *current=copy.m_head->next; current; current=current->next)
-	{
-		m_tail->next = new ByteQueueNode(*current);
-		m_tail = m_tail->next;
-	}
-
-	m_tail->next = NULL;
-
-	Put(copy.m_lazyString, copy.m_lazyLength);
-}
-
-ByteQueue::~ByteQueue()
-{
-	Destroy();
-}
-
-void ByteQueue::Destroy()
-{
-	ByteQueueNode *next;
-
-	for (ByteQueueNode *current=m_head; current; current=next)
-	{
-		next=current->next;
-		delete current;
-	}
-}
-
-void ByteQueue::IsolatedInitialize(const NameValuePairs &parameters)
-{
-	m_nodeSize = parameters.GetIntValueWithDefault("NodeSize", 256);
-	Clear();
-}
-
-unsigned long ByteQueue::CurrentSize() const
-{
-	unsigned long size=0;
-
-	for (ByteQueueNode *current=m_head; current; current=current->next)
-		size += current->CurrentSize();
-
-	return size + m_lazyLength;
-}
-
-bool ByteQueue::IsEmpty() const
-{
-	return m_head==m_tail && m_head->CurrentSize()==0 && m_lazyLength==0;
-}
-
-void ByteQueue::Clear()
-{
-	Destroy();
-	m_head = m_tail = new ByteQueueNode(m_nodeSize);
-	m_lazyLength = 0;
-}
-
-unsigned int ByteQueue::Put2(const byte *inString, unsigned int length, int messageEnd, bool blocking)
-{
-	if (m_lazyLength > 0)
-		FinalizeLazyPut();
-
-	unsigned int len;
-	while ((len=m_tail->Put(inString, length)) < length)
-	{
-		m_tail->next = new ByteQueueNode(m_nodeSize);
-		m_tail = m_tail->next;
-		inString += len;
-		length -= len;
-	}
-
-	return 0;
-}
-
-void ByteQueue::CleanupUsedNodes()
-{
-	while (m_head != m_tail && m_head->UsedUp())
-	{
-		ByteQueueNode *temp=m_head;
-		m_head=m_head->next;
-		delete temp;
-	}
-
-	if (m_head->CurrentSize() == 0)
-		m_head->Clear();
-}
-
-void ByteQueue::LazyPut(const byte *inString, unsigned int size)
-{
-	if (m_lazyLength > 0)
-		FinalizeLazyPut();
-	m_lazyString = inString;
-	m_lazyLength = size;
-}
-
-void ByteQueue::UndoLazyPut(unsigned int size)
-{
-	if (m_lazyLength < size)
-		throw InvalidArgument("ByteQueue: size specified for UndoLazyPut is too large");
-
-	m_lazyLength -= size;
-}
-
-void ByteQueue::FinalizeLazyPut()
-{
-	unsigned int len = m_lazyLength;
-	m_lazyLength = 0;
-	if (len)
-		Put(m_lazyString, len);
-}
-
-unsigned int ByteQueue::Get(byte &outByte)
-{
-	if (m_head->Get(outByte))
-	{
-		if (m_head->UsedUp())
-			CleanupUsedNodes();
-		return 1;
-	}
-	else if (m_lazyLength > 0)
-	{
-		outByte = *m_lazyString++;
-		m_lazyLength--;
-		return 1;
-	}
-	else
-		return 0;
-}
-
-unsigned int ByteQueue::Get(byte *outString, unsigned int getMax)
-{
-	ArraySink sink(outString, getMax);
-	return TransferTo(sink, getMax);
-}
-
-unsigned int ByteQueue::Peek(byte &outByte) const
-{
-	if (m_head->Peek(outByte))
-		return 1;
-	else if (m_lazyLength > 0)
-	{
-		outByte = *m_lazyString;
-		return 1;
-	}
-	else
-		return 0;
-}
-
-unsigned int ByteQueue::Peek(byte *outString, unsigned int peekMax) const
-{
-	ArraySink sink(outString, peekMax);
-	return CopyTo(sink, peekMax);
-}
-
-unsigned int ByteQueue::TransferTo2(BufferedTransformation &target, unsigned long &transferBytes, const std::string &channel, bool blocking)
-{
-	if (blocking)
-	{
-		unsigned long bytesLeft = transferBytes;
-		for (ByteQueueNode *current=m_head; bytesLeft && current; current=current->next)
-			bytesLeft -= current->TransferTo(target, bytesLeft, channel);
-		CleanupUsedNodes();
-
-		unsigned int len = (unsigned int)STDMIN(bytesLeft, (unsigned long)m_lazyLength);
-		if (len)
-		{
-			target.ChannelPut(channel, m_lazyString, len);
-			m_lazyString += len;
-			m_lazyLength -= len;
-			bytesLeft -= len;
-		}
-		transferBytes -= bytesLeft;
-		return 0;
-	}
-	else
-	{
-		Walker walker(*this);
-		unsigned int blockedBytes = walker.TransferTo2(target, transferBytes, channel, blocking);
-		Skip(transferBytes);
-		return blockedBytes;
-	}
-}
-
-unsigned int ByteQueue::CopyRangeTo2(BufferedTransformation &target, unsigned long &begin, unsigned long end, const std::string &channel, bool blocking) const
-{
-	Walker walker(*this);
-	walker.Skip(begin);
-	unsigned long transferBytes = end-begin;
-	unsigned int blockedBytes = walker.TransferTo2(target, transferBytes, channel, blocking);
-	begin += transferBytes;
-	return blockedBytes;
-}
-
-void ByteQueue::Unget(byte inByte)
-{
-	Unget(&inByte, 1);
-}
-
-void ByteQueue::Unget(const byte *inString, unsigned int length)
-{
-	// TODO: make this more efficient
-	ByteQueueNode *newHead = new ByteQueueNode(length);
-	newHead->next = m_head;
-	m_head = newHead;
-	m_head->Put(inString, length);
-}
-
-const byte * ByteQueue::Spy(unsigned int &contiguousSize) const
-{
-	contiguousSize = m_head->m_tail - m_head->m_head;
-	if (contiguousSize == 0 && m_lazyLength > 0)
-	{
-		contiguousSize = m_lazyLength;
-		return m_lazyString;
-	}
-	else
-		return m_head->buf + m_head->m_head;
-}
-
-byte * ByteQueue::CreatePutSpace(unsigned int &size)
-{
-	if (m_lazyLength > 0)
-		FinalizeLazyPut();
-
-	if (m_tail->m_tail == m_tail->MaxSize())
-	{
-		m_tail->next = new ByteQueueNode(size < m_nodeSize ? m_nodeSize : STDMAX(m_nodeSize, 1024U));
-		m_tail = m_tail->next;
-	}
-
-	size = m_tail->MaxSize() - m_tail->m_tail;
-	return m_tail->buf + m_tail->m_tail;
-}
-
-ByteQueue & ByteQueue::operator=(const ByteQueue &rhs)
-{
-	Destroy();
-	CopyFrom(rhs);
-	return *this;
-}
-
-bool ByteQueue::operator==(const ByteQueue &rhs) const
-{
-	const unsigned long currentSize = CurrentSize();
-
-	if (currentSize != rhs.CurrentSize())
-		return false;
-
-	Walker walker1(*this), walker2(rhs);
-	byte b1, b2;
-
-	while (walker1.Get(b1) && walker2.Get(b2))
-		if (b1 != b2)
-			return false;
-
-	return true;
-}
-
-byte ByteQueue::operator[](unsigned long i) const
-{
-	for (ByteQueueNode *current=m_head; current; current=current->next)
-	{
-		if (i < current->CurrentSize())
-			return (*current)[i];
-		
-		i -= current->CurrentSize();
-	}
-
-	assert(i < m_lazyLength);
-	return m_lazyString[i];
-}
-
-void ByteQueue::swap(ByteQueue &rhs)
-{
-	std::swap(m_nodeSize, rhs.m_nodeSize);
-	std::swap(m_head, rhs.m_head);
-	std::swap(m_tail, rhs.m_tail);
-	std::swap(m_lazyString, rhs.m_lazyString);
-	std::swap(m_lazyLength, rhs.m_lazyLength);
-}
-
-// ********************************************************
-
-void ByteQueue::Walker::IsolatedInitialize(const NameValuePairs &parameters)
-{
-	m_node = m_queue.m_head;
-	m_position = 0;
-	m_offset = 0;
-	m_lazyString = m_queue.m_lazyString;
-	m_lazyLength = m_queue.m_lazyLength;
-}
-
-unsigned int ByteQueue::Walker::Get(byte &outByte)
-{
-	ArraySink sink(&outByte, 1);
-	return TransferTo(sink, 1);
-}
-
-unsigned int ByteQueue::Walker::Get(byte *outString, unsigned int getMax)
-{
-	ArraySink sink(outString, getMax);
-	return TransferTo(sink, getMax);
-}
-
-unsigned int ByteQueue::Walker::Peek(byte &outByte) const
-{
-	ArraySink sink(&outByte, 1);
-	return CopyTo(sink, 1);
-}
-
-unsigned int ByteQueue::Walker::Peek(byte *outString, unsigned int peekMax) const
-{
-	ArraySink sink(outString, peekMax);
-	return CopyTo(sink, peekMax);
-}
-
-unsigned int ByteQueue::Walker::TransferTo2(BufferedTransformation &target, unsigned long &transferBytes, const std::string &channel, bool blocking)
-{
-	unsigned long bytesLeft = transferBytes;
-	unsigned int blockedBytes = 0;
-
-	while (m_node)
-	{
-		unsigned int len = STDMIN(bytesLeft, (unsigned long)m_node->CurrentSize()-m_offset);
-		blockedBytes = target.ChannelPut2(channel, m_node->buf+m_node->m_head+m_offset, len, 0, blocking);
-
-		if (blockedBytes)
-			goto done;
-
-		m_position += len;
-		bytesLeft -= len;
-
-		if (!bytesLeft)
-		{
-			m_offset += len;
-			goto done;
-		}
-
-		m_node = m_node->next;
-		m_offset = 0;
-	}
-
-	if (bytesLeft && m_lazyLength)
-	{
-		unsigned int len = (unsigned int)STDMIN(bytesLeft, (unsigned long)m_lazyLength);
-		unsigned int blockedBytes = target.ChannelPut2(channel, m_lazyString, len, 0, blocking);
-		if (blockedBytes)
-			goto done;
-
-		m_lazyString += len;
-		m_lazyLength -= len;
-		bytesLeft -= len;
-	}
-
-done:
-	transferBytes -= bytesLeft;
-	return blockedBytes;
-}
-
-unsigned int ByteQueue::Walker::CopyRangeTo2(BufferedTransformation &target, unsigned long &begin, unsigned long end, const std::string &channel, bool blocking) const
-{
-	Walker walker(*this);
-	walker.Skip(begin);
-	unsigned long transferBytes = end-begin;
-	unsigned int blockedBytes = walker.TransferTo2(target, transferBytes, channel, blocking);
-	begin += transferBytes;
-	return blockedBytes;
-}
-
-NAMESPACE_END
+// queue.cpp - written and placed in the public domain by Wei Dai
+
+#include "pch.h"
+
+#ifndef CRYPTOPP_IMPORTS
+
+#include "queue.h"
+#include "filters.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+static const unsigned int s_maxAutoNodeSize = 16*1024;
+
+// this class for use by ByteQueue only
+class ByteQueueNode
+{
+public:
+	ByteQueueNode(size_t maxSize)
+		: buf(maxSize)
+	{
+		m_head = m_tail = 0;
+		next = 0;
+	}
+
+	inline size_t MaxSize() const {return buf.size();}
+
+	inline size_t CurrentSize() const
+	{
+		return m_tail-m_head;
+	}
+
+	inline bool UsedUp() const
+	{
+		return (m_head==MaxSize());
+	}
+
+	inline void Clear()
+	{
+		m_head = m_tail = 0;
+	}
+
+	inline size_t Put(const byte *begin, size_t length)
+	{
+		size_t l = STDMIN(length, MaxSize()-m_tail);
+		if (buf+m_tail != begin)
+			memcpy(buf+m_tail, begin, l);
+		m_tail += l;
+		return l;
+	}
+
+	inline size_t Peek(byte &outByte) const
+	{
+		if (m_tail==m_head)
+			return 0;
+
+		outByte=buf[m_head];
+		return 1;
+	}
+
+	inline size_t Peek(byte *target, size_t copyMax) const
+	{
+		size_t len = STDMIN(copyMax, m_tail-m_head);
+		memcpy(target, buf+m_head, len);
+		return len;
+	}
+
+	inline size_t CopyTo(BufferedTransformation &target, const std::string &channel=DEFAULT_CHANNEL) const
+	{
+		size_t len = m_tail-m_head;
+		target.ChannelPut(channel, buf+m_head, len);
+		return len;
+	}
+
+	inline size_t CopyTo(BufferedTransformation &target, size_t copyMax, const std::string &channel=DEFAULT_CHANNEL) const
+	{
+		size_t len = STDMIN(copyMax, m_tail-m_head);
+		target.ChannelPut(channel, buf+m_head, len);
+		return len;
+	}
+
+	inline size_t Get(byte &outByte)
+	{
+		size_t len = Peek(outByte);
+		m_head += len;
+		return len;
+	}
+
+	inline size_t Get(byte *outString, size_t getMax)
+	{
+		size_t len = Peek(outString, getMax);
+		m_head += len;
+		return len;
+	}
+
+	inline size_t TransferTo(BufferedTransformation &target, const std::string &channel=DEFAULT_CHANNEL)
+	{
+		size_t len = m_tail-m_head;
+		target.ChannelPutModifiable(channel, buf+m_head, len);
+		m_head = m_tail;
+		return len;
+	}
+
+	inline size_t TransferTo(BufferedTransformation &target, lword transferMax, const std::string &channel=DEFAULT_CHANNEL)
+	{
+		size_t len = UnsignedMin(m_tail-m_head, transferMax);
+		target.ChannelPutModifiable(channel, buf+m_head, len);
+		m_head += len;
+		return len;
+	}
+
+	inline size_t Skip(size_t skipMax)
+	{
+		size_t len = STDMIN(skipMax, m_tail-m_head);
+		m_head += len;
+		return len;
+	}
+
+	inline byte operator[](size_t i) const
+	{
+		return buf[m_head+i];
+	}
+
+	ByteQueueNode *next;
+
+	SecByteBlock buf;
+	size_t m_head, m_tail;
+};
+
+// ********************************************************
+
+ByteQueue::ByteQueue(size_t nodeSize)
+	: m_lazyString(NULL), m_lazyLength(0)
+{
+	SetNodeSize(nodeSize);
+	m_head = m_tail = new ByteQueueNode(m_nodeSize);
+}
+
+void ByteQueue::SetNodeSize(size_t nodeSize)
+{
+	m_autoNodeSize = !nodeSize;
+	m_nodeSize = m_autoNodeSize ? 256 : nodeSize;
+}
+
+ByteQueue::ByteQueue(const ByteQueue &copy)
+	: m_lazyString(NULL)
+{
+	CopyFrom(copy);
+}
+
+void ByteQueue::CopyFrom(const ByteQueue &copy)
+{
+	m_lazyLength = 0;
+	m_autoNodeSize = copy.m_autoNodeSize;
+	m_nodeSize = copy.m_nodeSize;
+	m_head = m_tail = new ByteQueueNode(*copy.m_head);
+
+	for (ByteQueueNode *current=copy.m_head->next; current; current=current->next)
+	{
+		m_tail->next = new ByteQueueNode(*current);
+		m_tail = m_tail->next;
+	}
+
+	m_tail->next = NULL;
+
+	Put(copy.m_lazyString, copy.m_lazyLength);
+}
+
+ByteQueue::~ByteQueue()
+{
+	Destroy();
+}
+
+void ByteQueue::Destroy()
+{
+	for (ByteQueueNode *next, *current=m_head; current; current=next)
+	{
+		next=current->next;
+		delete current;
+	}
+}
+
+void ByteQueue::IsolatedInitialize(const NameValuePairs &parameters)
+{
+	m_nodeSize = parameters.GetIntValueWithDefault("NodeSize", 256);
+	Clear();
+}
+
+lword ByteQueue::CurrentSize() const
+{
+	lword size=0;
+
+	for (ByteQueueNode *current=m_head; current; current=current->next)
+		size += current->CurrentSize();
+
+	return size + m_lazyLength;
+}
+
+bool ByteQueue::IsEmpty() const
+{
+	return m_head==m_tail && m_head->CurrentSize()==0 && m_lazyLength==0;
+}
+
+void ByteQueue::Clear()
+{
+	for (ByteQueueNode *next, *current=m_head->next; current; current=next)
+	{
+		next=current->next;
+		delete current;
+	}
+
+	m_tail = m_head;
+	m_head->Clear();
+	m_head->next = NULL;
+	m_lazyLength = 0;
+}
+
+size_t ByteQueue::Put2(const byte *inString, size_t length, int messageEnd, bool blocking)
+{
+	if (m_lazyLength > 0)
+		FinalizeLazyPut();
+
+	size_t len;
+	while ((len=m_tail->Put(inString, length)) < length)
+	{
+		inString += len;
+		length -= len;
+		if (m_autoNodeSize && m_nodeSize < s_maxAutoNodeSize)
+			do
+			{
+				m_nodeSize *= 2;
+			}
+			while (m_nodeSize < length && m_nodeSize < s_maxAutoNodeSize);
+		m_tail->next = new ByteQueueNode(STDMAX(m_nodeSize, length));
+		m_tail = m_tail->next;
+	}
+
+	return 0;
+}
+
+void ByteQueue::CleanupUsedNodes()
+{
+	while (m_head != m_tail && m_head->UsedUp())
+	{
+		ByteQueueNode *temp=m_head;
+		m_head=m_head->next;
+		delete temp;
+	}
+
+	if (m_head->CurrentSize() == 0)
+		m_head->Clear();
+}
+
+void ByteQueue::LazyPut(const byte *inString, size_t size)
+{
+	if (m_lazyLength > 0)
+		FinalizeLazyPut();
+
+	if (inString == m_tail->buf+m_tail->m_tail)
+		Put(inString, size);
+	else
+	{
+		m_lazyString = const_cast<byte *>(inString);
+		m_lazyLength = size;
+		m_lazyStringModifiable = false;
+	}
+}
+
+void ByteQueue::LazyPutModifiable(byte *inString, size_t size)
+{
+	if (m_lazyLength > 0)
+		FinalizeLazyPut();
+	m_lazyString = inString;
+	m_lazyLength = size;
+	m_lazyStringModifiable = true;
+}
+
+void ByteQueue::UndoLazyPut(size_t size)
+{
+	if (m_lazyLength < size)
+		throw InvalidArgument("ByteQueue: size specified for UndoLazyPut is too large");
+
+	m_lazyLength -= size;
+}
+
+void ByteQueue::FinalizeLazyPut()
+{
+	size_t len = m_lazyLength;
+	m_lazyLength = 0;
+	if (len)
+		Put(m_lazyString, len);
+}
+
+size_t ByteQueue::Get(byte &outByte)
+{
+	if (m_head->Get(outByte))
+	{
+		if (m_head->UsedUp())
+			CleanupUsedNodes();
+		return 1;
+	}
+	else if (m_lazyLength > 0)
+	{
+		outByte = *m_lazyString++;
+		m_lazyLength--;
+		return 1;
+	}
+	else
+		return 0;
+}
+
+size_t ByteQueue::Get(byte *outString, size_t getMax)
+{
+	ArraySink sink(outString, getMax);
+	return (size_t)TransferTo(sink, getMax);
+}
+
+size_t ByteQueue::Peek(byte &outByte) const
+{
+	if (m_head->Peek(outByte))
+		return 1;
+	else if (m_lazyLength > 0)
+	{
+		outByte = *m_lazyString;
+		return 1;
+	}
+	else
+		return 0;
+}
+
+size_t ByteQueue::Peek(byte *outString, size_t peekMax) const
+{
+	ArraySink sink(outString, peekMax);
+	return (size_t)CopyTo(sink, peekMax);
+}
+
+size_t ByteQueue::TransferTo2(BufferedTransformation &target, lword &transferBytes, const std::string &channel, bool blocking)
+{
+	if (blocking)
+	{
+		lword bytesLeft = transferBytes;
+		for (ByteQueueNode *current=m_head; bytesLeft && current; current=current->next)
+			bytesLeft -= current->TransferTo(target, bytesLeft, channel);
+		CleanupUsedNodes();
+
+		size_t len = (size_t)STDMIN(bytesLeft, (lword)m_lazyLength);
+		if (len)
+		{
+			if (m_lazyStringModifiable)
+				target.ChannelPutModifiable(channel, m_lazyString, len);
+			else
+				target.ChannelPut(channel, m_lazyString, len);
+			m_lazyString += len;
+			m_lazyLength -= len;
+			bytesLeft -= len;
+		}
+		transferBytes -= bytesLeft;
+		return 0;
+	}
+	else
+	{
+		Walker walker(*this);
+		size_t blockedBytes = walker.TransferTo2(target, transferBytes, channel, blocking);
+		Skip(transferBytes);
+		return blockedBytes;
+	}
+}
+
+size_t ByteQueue::CopyRangeTo2(BufferedTransformation &target, lword &begin, lword end, const std::string &channel, bool blocking) const
+{
+	Walker walker(*this);
+	walker.Skip(begin);
+	lword transferBytes = end-begin;
+	size_t blockedBytes = walker.TransferTo2(target, transferBytes, channel, blocking);
+	begin += transferBytes;
+	return blockedBytes;
+}
+
+void ByteQueue::Unget(byte inByte)
+{
+	Unget(&inByte, 1);
+}
+
+void ByteQueue::Unget(const byte *inString, size_t length)
+{
+	size_t len = STDMIN(length, m_head->m_head);
+	length -= len;
+	m_head->m_head -= len;
+	memcpy(m_head->buf + m_head->m_head, inString + length, len);
+
+	if (length > 0)
+	{
+		ByteQueueNode *newHead = new ByteQueueNode(length);
+		newHead->next = m_head;
+		m_head = newHead;
+		m_head->Put(inString, length);
+	}
+}
+
+const byte * ByteQueue::Spy(size_t &contiguousSize) const
+{
+	contiguousSize = m_head->m_tail - m_head->m_head;
+	if (contiguousSize == 0 && m_lazyLength > 0)
+	{
+		contiguousSize = m_lazyLength;
+		return m_lazyString;
+	}
+	else
+		return m_head->buf + m_head->m_head;
+}
+
+byte * ByteQueue::CreatePutSpace(size_t &size)
+{
+	if (m_lazyLength > 0)
+		FinalizeLazyPut();
+
+	if (m_tail->m_tail == m_tail->MaxSize())
+	{
+		m_tail->next = new ByteQueueNode(STDMAX(m_nodeSize, size));
+		m_tail = m_tail->next;
+	}
+
+	size = m_tail->MaxSize() - m_tail->m_tail;
+	return m_tail->buf + m_tail->m_tail;
+}
+
+ByteQueue & ByteQueue::operator=(const ByteQueue &rhs)
+{
+	Destroy();
+	CopyFrom(rhs);
+	return *this;
+}
+
+bool ByteQueue::operator==(const ByteQueue &rhs) const
+{
+	const lword currentSize = CurrentSize();
+
+	if (currentSize != rhs.CurrentSize())
+		return false;
+
+	Walker walker1(*this), walker2(rhs);
+	byte b1, b2;
+
+	while (walker1.Get(b1) && walker2.Get(b2))
+		if (b1 != b2)
+			return false;
+
+	return true;
+}
+
+byte ByteQueue::operator[](lword i) const
+{
+	for (ByteQueueNode *current=m_head; current; current=current->next)
+	{
+		if (i < current->CurrentSize())
+			return (*current)[(size_t)i];
+		
+		i -= current->CurrentSize();
+	}
+
+	assert(i < m_lazyLength);
+	return m_lazyString[i];
+}
+
+void ByteQueue::swap(ByteQueue &rhs)
+{
+	std::swap(m_autoNodeSize, rhs.m_autoNodeSize);
+	std::swap(m_nodeSize, rhs.m_nodeSize);
+	std::swap(m_head, rhs.m_head);
+	std::swap(m_tail, rhs.m_tail);
+	std::swap(m_lazyString, rhs.m_lazyString);
+	std::swap(m_lazyLength, rhs.m_lazyLength);
+	std::swap(m_lazyStringModifiable, rhs.m_lazyStringModifiable);
+}
+
+// ********************************************************
+
+void ByteQueue::Walker::IsolatedInitialize(const NameValuePairs &parameters)
+{
+	m_node = m_queue.m_head;
+	m_position = 0;
+	m_offset = 0;
+	m_lazyString = m_queue.m_lazyString;
+	m_lazyLength = m_queue.m_lazyLength;
+}
+
+size_t ByteQueue::Walker::Get(byte &outByte)
+{
+	ArraySink sink(&outByte, 1);
+	return (size_t)TransferTo(sink, 1);
+}
+
+size_t ByteQueue::Walker::Get(byte *outString, size_t getMax)
+{
+	ArraySink sink(outString, getMax);
+	return (size_t)TransferTo(sink, getMax);
+}
+
+size_t ByteQueue::Walker::Peek(byte &outByte) const
+{
+	ArraySink sink(&outByte, 1);
+	return (size_t)CopyTo(sink, 1);
+}
+
+size_t ByteQueue::Walker::Peek(byte *outString, size_t peekMax) const
+{
+	ArraySink sink(outString, peekMax);
+	return (size_t)CopyTo(sink, peekMax);
+}
+
+size_t ByteQueue::Walker::TransferTo2(BufferedTransformation &target, lword &transferBytes, const std::string &channel, bool blocking)
+{
+	lword bytesLeft = transferBytes;
+	size_t blockedBytes = 0;
+
+	while (m_node)
+	{
+		size_t len = (size_t)STDMIN(bytesLeft, (lword)m_node->CurrentSize()-m_offset);
+		blockedBytes = target.ChannelPut2(channel, m_node->buf+m_node->m_head+m_offset, len, 0, blocking);
+
+		if (blockedBytes)
+			goto done;
+
+		m_position += len;
+		bytesLeft -= len;
+
+		if (!bytesLeft)
+		{
+			m_offset += len;
+			goto done;
+		}
+
+		m_node = m_node->next;
+		m_offset = 0;
+	}
+
+	if (bytesLeft && m_lazyLength)
+	{
+		size_t len = (size_t)STDMIN(bytesLeft, (lword)m_lazyLength);
+		blockedBytes = target.ChannelPut2(channel, m_lazyString, len, 0, blocking);
+		if (blockedBytes)
+			goto done;
+
+		m_lazyString += len;
+		m_lazyLength -= len;
+		bytesLeft -= len;
+	}
+
+done:
+	transferBytes -= bytesLeft;
+	return blockedBytes;
+}
+
+size_t ByteQueue::Walker::CopyRangeTo2(BufferedTransformation &target, lword &begin, lword end, const std::string &channel, bool blocking) const
+{
+	Walker walker(*this);
+	walker.Skip(begin);
+	lword transferBytes = end-begin;
+	size_t blockedBytes = walker.TransferTo2(target, transferBytes, channel, blocking);
+	begin += transferBytes;
+	return blockedBytes;
+}
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/randpool.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/randpool.cpp
new file mode 100644
index 00000000..a063c899
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/randpool.cpp
@@ -0,0 +1,63 @@
+// randpool.cpp - written and placed in the public domain by Wei Dai
+// RandomPool used to follow the design of randpool in PGP 2.6.x,
+// but as of version 5.5 it has been redesigned to reduce the risk
+// of reusing random numbers after state rollback (which may occur
+// when running in a virtual machine like VMware).
+
+#include "pch.h"
+
+#ifndef CRYPTOPP_IMPORTS
+
+#include "randpool.h"
+#include "aes.h"
+#include "sha.h"
+#include "hrtimer.h"
+#include <time.h>
+
+NAMESPACE_BEGIN(CryptoPP)
+
+RandomPool::RandomPool()
+	: m_pCipher(new AES::Encryption), m_keySet(false)
+{
+	memset(m_key, 0, m_key.SizeInBytes());
+	memset(m_seed, 0, m_seed.SizeInBytes());
+}
+
+void RandomPool::IncorporateEntropy(const byte *input, size_t length)
+{
+	SHA256 hash;
+	hash.Update(m_key, 32);
+	hash.Update(input, length);
+	hash.Final(m_key);
+	m_keySet = false;
+}
+
+void RandomPool::GenerateIntoBufferedTransformation(BufferedTransformation &target, const std::string &channel, lword size)
+{
+	if (size > 0)
+	{
+		if (!m_keySet)
+			m_pCipher->SetKey(m_key, 32);
+
+		Timer timer;
+		TimerWord tw = timer.GetCurrentTimerValue();
+		CRYPTOPP_COMPILE_ASSERT(sizeof(tw) <= 16);
+		*(TimerWord *)m_seed.data() += tw;
+
+		time_t t = time(NULL);
+		CRYPTOPP_COMPILE_ASSERT(sizeof(t) <= 8);
+		*(time_t *)(m_seed.data()+8) += t;
+
+		do
+		{
+			m_pCipher->ProcessBlock(m_seed);
+			size_t len = UnsignedMin(16, size);
+			target.ChannelPut(channel, m_seed, len);
+			size -= len;
+		} while (size > 0);
+	}
+}
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/rijndael.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/rijndael.cpp
new file mode 100644
index 00000000..608b9d30
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/rijndael.cpp
@@ -0,0 +1,1257 @@
+// rijndael.cpp - modified by Chris Morgan <cmorgan@wpi.edu>
+// and Wei Dai from Paulo Baretto's Rijndael implementation
+// The original code and all modifications are in the public domain.
+
+// use "cl /EP /P /DCRYPTOPP_GENERATE_X64_MASM rijndael.cpp" to generate MASM code
+
+/*
+July 2010: Added support for AES-NI instructions via compiler intrinsics.
+*/
+
+/*
+Feb 2009: The x86/x64 assembly code was rewritten in by Wei Dai to do counter mode 
+caching, which was invented by Hongjun Wu and popularized by Daniel J. Bernstein 
+and Peter Schwabe in their paper "New AES software speed records". The round 
+function was also modified to include a trick similar to one in Brian Gladman's 
+x86 assembly code, doing an 8-bit register move to minimize the number of 
+register spills. Also switched to compressed tables and copying round keys to 
+the stack.
+
+The C++ implementation now uses compressed tables if 
+CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS is defined.
+*/
+
+/*
+July 2006: Defense against timing attacks was added in by Wei Dai.
+
+The code now uses smaller tables in the first and last rounds,
+and preloads them into L1 cache before usage (by loading at least 
+one element in each cache line). 
+
+We try to delay subsequent accesses to each table (used in the first 
+and last rounds) until all of the table has been preloaded. Hopefully
+the compiler isn't smart enough to optimize that code away.
+
+After preloading the table, we also try not to access any memory location
+other than the table and the stack, in order to prevent table entries from 
+being unloaded from L1 cache, until that round is finished.
+(Some popular CPUs have 2-way associative caches.)
+*/
+
+// This is the original introductory comment:
+
+/**
+ * version 3.0 (December 2000)
+ *
+ * Optimised ANSI C code for the Rijndael cipher (now AES)
+ *
+ * author Vincent Rijmen <vincent.rijmen@esat.kuleuven.ac.be>
+ * author Antoon Bosselaers <antoon.bosselaers@esat.kuleuven.ac.be>
+ * author Paulo Barreto <paulo.barreto@terra.com.br>
+ *
+ * This code is hereby placed in the public domain.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "pch.h"
+
+#ifndef CRYPTOPP_IMPORTS
+#ifndef CRYPTOPP_GENERATE_X64_MASM
+
+#include "rijndael.h"
+#include "misc.h"
+#include "cpu.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+#ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS
+#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)
+namespace rdtable {CRYPTOPP_ALIGN_DATA(16) word64 Te[256+2];}
+using namespace rdtable;
+#else
+static word64 Te[256];
+#endif
+static word64 Td[256];
+#else
+static word32 Te[256*4], Td[256*4];
+#endif
+static volatile bool s_TeFilled = false, s_TdFilled = false;
+
+// ************************* Portable Code ************************************
+
+#define QUARTER_ROUND(L, T, t, a, b, c, d)	\
+	a ^= L(T, 3, byte(t)); t >>= 8;\
+	b ^= L(T, 2, byte(t)); t >>= 8;\
+	c ^= L(T, 1, byte(t)); t >>= 8;\
+	d ^= L(T, 0, t);
+
+#define QUARTER_ROUND_LE(t, a, b, c, d)	\
+	tempBlock[a] = ((byte *)(Te+byte(t)))[1]; t >>= 8;\
+	tempBlock[b] = ((byte *)(Te+byte(t)))[1]; t >>= 8;\
+	tempBlock[c] = ((byte *)(Te+byte(t)))[1]; t >>= 8;\
+	tempBlock[d] = ((byte *)(Te+t))[1];
+
+#ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS
+	#define QUARTER_ROUND_LD(t, a, b, c, d)	\
+		tempBlock[a] = ((byte *)(Td+byte(t)))[GetNativeByteOrder()*7]; t >>= 8;\
+		tempBlock[b] = ((byte *)(Td+byte(t)))[GetNativeByteOrder()*7]; t >>= 8;\
+		tempBlock[c] = ((byte *)(Td+byte(t)))[GetNativeByteOrder()*7]; t >>= 8;\
+		tempBlock[d] = ((byte *)(Td+t))[GetNativeByteOrder()*7];
+#else
+	#define QUARTER_ROUND_LD(t, a, b, c, d)	\
+		tempBlock[a] = Sd[byte(t)]; t >>= 8;\
+		tempBlock[b] = Sd[byte(t)]; t >>= 8;\
+		tempBlock[c] = Sd[byte(t)]; t >>= 8;\
+		tempBlock[d] = Sd[t];
+#endif
+
+#define QUARTER_ROUND_E(t, a, b, c, d)		QUARTER_ROUND(TL_M, Te, t, a, b, c, d)
+#define QUARTER_ROUND_D(t, a, b, c, d)		QUARTER_ROUND(TL_M, Td, t, a, b, c, d)
+
+#ifdef IS_LITTLE_ENDIAN
+	#define QUARTER_ROUND_FE(t, a, b, c, d)		QUARTER_ROUND(TL_F, Te, t, d, c, b, a)
+	#define QUARTER_ROUND_FD(t, a, b, c, d)		QUARTER_ROUND(TL_F, Td, t, d, c, b, a)
+	#ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS
+		#define TL_F(T, i, x)	(*(word32 *)((byte *)T + x*8 + (6-i)%4+1))
+		#define TL_M(T, i, x)	(*(word32 *)((byte *)T + x*8 + (i+3)%4+1))
+	#else
+		#define TL_F(T, i, x)	rotrFixed(T[x], (3-i)*8)
+		#define TL_M(T, i, x)	T[i*256 + x]
+	#endif
+#else
+	#define QUARTER_ROUND_FE(t, a, b, c, d)		QUARTER_ROUND(TL_F, Te, t, a, b, c, d)
+	#define QUARTER_ROUND_FD(t, a, b, c, d)		QUARTER_ROUND(TL_F, Td, t, a, b, c, d)
+	#ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS
+		#define TL_F(T, i, x)	(*(word32 *)((byte *)T + x*8 + (4-i)%4))
+		#define TL_M			TL_F
+	#else
+		#define TL_F(T, i, x)	rotrFixed(T[x], i*8)
+		#define TL_M(T, i, x)	T[i*256 + x]
+	#endif
+#endif
+
+
+#define f2(x)   ((x<<1)^(((x>>7)&1)*0x11b))
+#define f4(x)   ((x<<2)^(((x>>6)&1)*0x11b)^(((x>>6)&2)*0x11b))
+#define f8(x)   ((x<<3)^(((x>>5)&1)*0x11b)^(((x>>5)&2)*0x11b)^(((x>>5)&4)*0x11b))
+
+#define f3(x)   (f2(x) ^ x)
+#define f9(x)   (f8(x) ^ x)
+#define fb(x)   (f8(x) ^ f2(x) ^ x)
+#define fd(x)   (f8(x) ^ f4(x) ^ x)
+#define fe(x)   (f8(x) ^ f4(x) ^ f2(x))
+
+void Rijndael::Base::FillEncTable()
+{
+	for (int i=0; i<256; i++)
+	{
+		byte x = Se[i];
+#ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS
+		word32 y = word32(x)<<8 | word32(x)<<16 | word32(f2(x))<<24;
+		Te[i] = word64(y | f3(x))<<32 | y;
+#else
+		word32 y = f3(x) | word32(x)<<8 | word32(x)<<16 | word32(f2(x))<<24;
+		for (int j=0; j<4; j++)
+		{
+			Te[i+j*256] = y;
+			y = rotrFixed(y, 8);
+		}
+#endif
+	}
+#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)
+	Te[256] = Te[257] = 0;
+#endif
+	s_TeFilled = true;
+}
+
+void Rijndael::Base::FillDecTable()
+{
+	for (int i=0; i<256; i++)
+	{
+		byte x = Sd[i];
+#ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS
+		word32 y = word32(fd(x))<<8 | word32(f9(x))<<16 | word32(fe(x))<<24;
+		Td[i] = word64(y | fb(x))<<32 | y | x;
+#else
+		word32 y = fb(x) | word32(fd(x))<<8 | word32(f9(x))<<16 | word32(fe(x))<<24;;
+		for (int j=0; j<4; j++)
+		{
+			Td[i+j*256] = y;
+			y = rotrFixed(y, 8);
+		}
+#endif
+	}
+	s_TdFilled = true;
+}
+
+void Rijndael::Base::UncheckedSetKey(const byte *userKey, unsigned int keylen, const NameValuePairs &)
+{
+	AssertValidKeyLength(keylen);
+
+	m_rounds = keylen/4 + 6;
+	m_key.New(4*(m_rounds+1));
+
+	word32 *rk = m_key;
+
+#if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE && (!defined(_MSC_VER) || _MSC_VER >= 1600 || CRYPTOPP_BOOL_X86)
+	// MSVC 2008 SP1 generates bad code for _mm_extract_epi32() when compiling for X64
+	if (HasAESNI())
+	{
+		static const word32 rcLE[] = {
+			0x01, 0x02, 0x04, 0x08,
+			0x10, 0x20, 0x40, 0x80,
+			0x1B, 0x36, /* for 128-bit blocks, Rijndael never uses more than 10 rcon values */
+		};
+		const word32 *rc = rcLE;
+
+		__m128i temp = _mm_loadu_si128((__m128i *)(userKey+keylen-16));
+		memcpy(rk, userKey, keylen);
+
+		while (true)
+		{
+			rk[keylen/4] = rk[0] ^ _mm_extract_epi32(_mm_aeskeygenassist_si128(temp, 0), 3) ^ *(rc++);
+			rk[keylen/4+1] = rk[1] ^ rk[keylen/4];
+			rk[keylen/4+2] = rk[2] ^ rk[keylen/4+1];
+			rk[keylen/4+3] = rk[3] ^ rk[keylen/4+2];
+
+			if (rk + keylen/4 + 4 == m_key.end())
+				break;
+
+			if (keylen == 24)
+			{
+				rk[10] = rk[ 4] ^ rk[ 9];
+				rk[11] = rk[ 5] ^ rk[10];
+				temp = _mm_insert_epi32(temp, rk[11], 3);
+			}
+			else if (keylen == 32)
+			{
+				temp = _mm_insert_epi32(temp, rk[11], 3);
+    			rk[12] = rk[ 4] ^ _mm_extract_epi32(_mm_aeskeygenassist_si128(temp, 0), 2);
+    			rk[13] = rk[ 5] ^ rk[12];
+    			rk[14] = rk[ 6] ^ rk[13];
+    			rk[15] = rk[ 7] ^ rk[14];
+				temp = _mm_insert_epi32(temp, rk[15], 3);
+			}
+			else
+				temp = _mm_insert_epi32(temp, rk[7], 3);
+
+			rk += keylen/4;
+		}
+
+		if (!IsForwardTransformation())
+		{
+			rk = m_key;
+			unsigned int i, j;
+
+			std::swap(*(__m128i *)(rk), *(__m128i *)(rk+4*m_rounds));
+
+			for (i = 4, j = 4*m_rounds-4; i < j; i += 4, j -= 4)
+			{
+				temp = _mm_aesimc_si128(*(__m128i *)(rk+i));
+				*(__m128i *)(rk+i) = _mm_aesimc_si128(*(__m128i *)(rk+j));
+				*(__m128i *)(rk+j) = temp;
+			}
+
+			*(__m128i *)(rk+i) = _mm_aesimc_si128(*(__m128i *)(rk+i));
+		}
+
+		return;
+	}
+#endif
+
+	GetUserKey(BIG_ENDIAN_ORDER, rk, keylen/4, userKey, keylen);
+	const word32 *rc = rcon;
+	word32 temp;
+
+	while (true)
+	{
+		temp  = rk[keylen/4-1];
+		word32 x = (word32(Se[GETBYTE(temp, 2)]) << 24) ^ (word32(Se[GETBYTE(temp, 1)]) << 16) ^ (word32(Se[GETBYTE(temp, 0)]) << 8) ^ Se[GETBYTE(temp, 3)];
+		rk[keylen/4] = rk[0] ^ x ^ *(rc++);
+		rk[keylen/4+1] = rk[1] ^ rk[keylen/4];
+		rk[keylen/4+2] = rk[2] ^ rk[keylen/4+1];
+		rk[keylen/4+3] = rk[3] ^ rk[keylen/4+2];
+
+		if (rk + keylen/4 + 4 == m_key.end())
+			break;
+
+		if (keylen == 24)
+		{
+			rk[10] = rk[ 4] ^ rk[ 9];
+			rk[11] = rk[ 5] ^ rk[10];
+		}
+		else if (keylen == 32)
+		{
+    		temp = rk[11];
+    		rk[12] = rk[ 4] ^ (word32(Se[GETBYTE(temp, 3)]) << 24) ^ (word32(Se[GETBYTE(temp, 2)]) << 16) ^ (word32(Se[GETBYTE(temp, 1)]) << 8) ^ Se[GETBYTE(temp, 0)];
+    		rk[13] = rk[ 5] ^ rk[12];
+    		rk[14] = rk[ 6] ^ rk[13];
+    		rk[15] = rk[ 7] ^ rk[14];
+		}
+		rk += keylen/4;
+	}
+
+	rk = m_key;
+
+	if (IsForwardTransformation())
+	{
+		if (!s_TeFilled)
+			FillEncTable();
+
+		ConditionalByteReverse(BIG_ENDIAN_ORDER, rk, rk, 16);
+		ConditionalByteReverse(BIG_ENDIAN_ORDER, rk + m_rounds*4, rk + m_rounds*4, 16);
+	}
+	else
+	{
+		if (!s_TdFilled)
+			FillDecTable();
+
+		unsigned int i, j;
+
+#define InverseMixColumn(x)		TL_M(Td, 0, Se[GETBYTE(x, 3)]) ^ TL_M(Td, 1, Se[GETBYTE(x, 2)]) ^ TL_M(Td, 2, Se[GETBYTE(x, 1)]) ^ TL_M(Td, 3, Se[GETBYTE(x, 0)])
+
+		for (i = 4, j = 4*m_rounds-4; i < j; i += 4, j -= 4)
+		{
+			temp = InverseMixColumn(rk[i    ]); rk[i    ] = InverseMixColumn(rk[j    ]); rk[j    ] = temp;
+			temp = InverseMixColumn(rk[i + 1]); rk[i + 1] = InverseMixColumn(rk[j + 1]); rk[j + 1] = temp;
+			temp = InverseMixColumn(rk[i + 2]); rk[i + 2] = InverseMixColumn(rk[j + 2]); rk[j + 2] = temp;
+			temp = InverseMixColumn(rk[i + 3]); rk[i + 3] = InverseMixColumn(rk[j + 3]); rk[j + 3] = temp;
+		}
+
+		rk[i+0] = InverseMixColumn(rk[i+0]);
+		rk[i+1] = InverseMixColumn(rk[i+1]);
+		rk[i+2] = InverseMixColumn(rk[i+2]);
+		rk[i+3] = InverseMixColumn(rk[i+3]);
+
+		temp = ConditionalByteReverse(BIG_ENDIAN_ORDER, rk[0]); rk[0] = ConditionalByteReverse(BIG_ENDIAN_ORDER, rk[4*m_rounds+0]); rk[4*m_rounds+0] = temp;
+		temp = ConditionalByteReverse(BIG_ENDIAN_ORDER, rk[1]); rk[1] = ConditionalByteReverse(BIG_ENDIAN_ORDER, rk[4*m_rounds+1]); rk[4*m_rounds+1] = temp;
+		temp = ConditionalByteReverse(BIG_ENDIAN_ORDER, rk[2]); rk[2] = ConditionalByteReverse(BIG_ENDIAN_ORDER, rk[4*m_rounds+2]); rk[4*m_rounds+2] = temp;
+		temp = ConditionalByteReverse(BIG_ENDIAN_ORDER, rk[3]); rk[3] = ConditionalByteReverse(BIG_ENDIAN_ORDER, rk[4*m_rounds+3]); rk[4*m_rounds+3] = temp;
+	}
+
+#if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE
+	if (HasAESNI())
+		ConditionalByteReverse(BIG_ENDIAN_ORDER, rk+4, rk+4, (m_rounds-1)*16);
+#endif
+}
+
+void Rijndael::Enc::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const
+{
+#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE) || CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE
+	if (HasSSE2())
+	{
+		Rijndael::Enc::AdvancedProcessBlocks(inBlock, xorBlock, outBlock, 16, 0);
+		return;
+	}
+#endif
+
+	typedef BlockGetAndPut<word32, NativeByteOrder> Block;
+
+	word32 s0, s1, s2, s3, t0, t1, t2, t3;
+	Block::Get(inBlock)(s0)(s1)(s2)(s3);
+
+	const word32 *rk = m_key;
+	s0 ^= rk[0];
+	s1 ^= rk[1];
+	s2 ^= rk[2];
+	s3 ^= rk[3];
+	t0 = rk[4];
+	t1 = rk[5];
+	t2 = rk[6];
+	t3 = rk[7];
+	rk += 8;
+
+	// timing attack countermeasure. see comments at top for more details
+	const int cacheLineSize = GetCacheLineSize();
+	unsigned int i;
+	word32 u = 0;
+#ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS
+	for (i=0; i<2048; i+=cacheLineSize)
+#else
+	for (i=0; i<1024; i+=cacheLineSize)
+#endif
+		u &= *(const word32 *)(((const byte *)Te)+i);
+	u &= Te[255];
+	s0 |= u; s1 |= u; s2 |= u; s3 |= u;
+
+	QUARTER_ROUND_FE(s3, t0, t1, t2, t3)
+	QUARTER_ROUND_FE(s2, t3, t0, t1, t2)
+	QUARTER_ROUND_FE(s1, t2, t3, t0, t1)
+	QUARTER_ROUND_FE(s0, t1, t2, t3, t0)
+
+	// Nr - 2 full rounds:
+    unsigned int r = m_rounds/2 - 1;
+    do
+	{
+		s0 = rk[0]; s1 = rk[1]; s2 = rk[2]; s3 = rk[3];
+
+		QUARTER_ROUND_E(t3, s0, s1, s2, s3)
+		QUARTER_ROUND_E(t2, s3, s0, s1, s2)
+		QUARTER_ROUND_E(t1, s2, s3, s0, s1)
+		QUARTER_ROUND_E(t0, s1, s2, s3, s0)
+
+		t0 = rk[4]; t1 = rk[5]; t2 = rk[6]; t3 = rk[7];
+
+		QUARTER_ROUND_E(s3, t0, t1, t2, t3)
+		QUARTER_ROUND_E(s2, t3, t0, t1, t2)
+		QUARTER_ROUND_E(s1, t2, t3, t0, t1)
+		QUARTER_ROUND_E(s0, t1, t2, t3, t0)
+
+        rk += 8;
+    } while (--r);
+
+	word32 tbw[4];
+	byte *const tempBlock = (byte *)tbw;
+
+	QUARTER_ROUND_LE(t2, 15, 2, 5, 8)
+	QUARTER_ROUND_LE(t1, 11, 14, 1, 4)
+	QUARTER_ROUND_LE(t0, 7, 10, 13, 0)
+	QUARTER_ROUND_LE(t3, 3, 6, 9, 12)
+
+	Block::Put(xorBlock, outBlock)(tbw[0]^rk[0])(tbw[1]^rk[1])(tbw[2]^rk[2])(tbw[3]^rk[3]);
+}
+
+void Rijndael::Dec::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const
+{
+#if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE
+	if (HasAESNI())
+	{
+		Rijndael::Dec::AdvancedProcessBlocks(inBlock, xorBlock, outBlock, 16, 0);
+		return;
+	}
+#endif
+
+	typedef BlockGetAndPut<word32, NativeByteOrder> Block;
+
+	word32 s0, s1, s2, s3, t0, t1, t2, t3;
+	Block::Get(inBlock)(s0)(s1)(s2)(s3);
+
+	const word32 *rk = m_key;
+	s0 ^= rk[0];
+	s1 ^= rk[1];
+	s2 ^= rk[2];
+	s3 ^= rk[3];
+	t0 = rk[4];
+	t1 = rk[5];
+	t2 = rk[6];
+	t3 = rk[7];
+	rk += 8;
+
+	// timing attack countermeasure. see comments at top for more details
+	const int cacheLineSize = GetCacheLineSize();
+	unsigned int i;
+	word32 u = 0;
+#ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS
+	for (i=0; i<2048; i+=cacheLineSize)
+#else
+	for (i=0; i<1024; i+=cacheLineSize)
+#endif
+		u &= *(const word32 *)(((const byte *)Td)+i);
+	u &= Td[255];
+	s0 |= u; s1 |= u; s2 |= u; s3 |= u;
+
+	QUARTER_ROUND_FD(s3, t2, t1, t0, t3)
+	QUARTER_ROUND_FD(s2, t1, t0, t3, t2)
+	QUARTER_ROUND_FD(s1, t0, t3, t2, t1)
+	QUARTER_ROUND_FD(s0, t3, t2, t1, t0)
+
+	// Nr - 2 full rounds:
+    unsigned int r = m_rounds/2 - 1;
+    do
+	{
+		s0 = rk[0]; s1 = rk[1]; s2 = rk[2]; s3 = rk[3];
+
+		QUARTER_ROUND_D(t3, s2, s1, s0, s3)
+		QUARTER_ROUND_D(t2, s1, s0, s3, s2)
+		QUARTER_ROUND_D(t1, s0, s3, s2, s1)
+		QUARTER_ROUND_D(t0, s3, s2, s1, s0)
+
+		t0 = rk[4]; t1 = rk[5]; t2 = rk[6]; t3 = rk[7];
+
+		QUARTER_ROUND_D(s3, t2, t1, t0, t3)
+		QUARTER_ROUND_D(s2, t1, t0, t3, t2)
+		QUARTER_ROUND_D(s1, t0, t3, t2, t1)
+		QUARTER_ROUND_D(s0, t3, t2, t1, t0)
+
+        rk += 8;
+    } while (--r);
+
+#ifndef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS
+	// timing attack countermeasure. see comments at top for more details
+	// If CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS is defined, 
+	// QUARTER_ROUND_LD will use Td, which is already preloaded.
+	u = 0;
+	for (i=0; i<256; i+=cacheLineSize)
+		u &= *(const word32 *)(Sd+i);
+	u &= *(const word32 *)(Sd+252);
+	t0 |= u; t1 |= u; t2 |= u; t3 |= u;
+#endif
+
+	word32 tbw[4];
+	byte *const tempBlock = (byte *)tbw;
+
+	QUARTER_ROUND_LD(t2, 7, 2, 13, 8)
+	QUARTER_ROUND_LD(t1, 3, 14, 9, 4)
+	QUARTER_ROUND_LD(t0, 15, 10, 5, 0)
+	QUARTER_ROUND_LD(t3, 11, 6, 1, 12)
+
+	Block::Put(xorBlock, outBlock)(tbw[0]^rk[0])(tbw[1]^rk[1])(tbw[2]^rk[2])(tbw[3]^rk[3]);
+}
+
+// ************************* Assembly Code ************************************
+
+#pragma warning(disable: 4731)	// frame pointer register 'ebp' modified by inline assembly code
+
+#endif	// #ifndef CRYPTOPP_GENERATE_X64_MASM
+
+#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE
+
+CRYPTOPP_NAKED void CRYPTOPP_FASTCALL Rijndael_Enc_AdvancedProcessBlocks(void *locals, const word32 *k)
+{
+#if CRYPTOPP_BOOL_X86
+
+#define L_REG			esp
+#define L_INDEX(i)		(L_REG+512+i)
+#define L_INXORBLOCKS	L_INBLOCKS+4
+#define L_OUTXORBLOCKS	L_INBLOCKS+8
+#define L_OUTBLOCKS		L_INBLOCKS+12
+#define L_INCREMENTS	L_INDEX(16*15)
+#define L_SP			L_INDEX(16*16)
+#define L_LENGTH		L_INDEX(16*16+4)
+#define L_KEYS_BEGIN	L_INDEX(16*16+8)
+
+#define MOVD			movd
+#define MM(i)			mm##i
+
+#define MXOR(a,b,c)	\
+	AS2(	movzx	esi, b)\
+	AS2(	movd	mm7, DWORD PTR [AS_REG_7+8*WORD_REG(si)+MAP0TO4(c)])\
+	AS2(	pxor	MM(a), mm7)\
+
+#define MMOV(a,b,c)	\
+	AS2(	movzx	esi, b)\
+	AS2(	movd	MM(a), DWORD PTR [AS_REG_7+8*WORD_REG(si)+MAP0TO4(c)])\
+
+#else
+
+#define L_REG			r8
+#define L_INDEX(i)		(L_REG+i)
+#define L_INXORBLOCKS	L_INBLOCKS+8
+#define L_OUTXORBLOCKS	L_INBLOCKS+16
+#define L_OUTBLOCKS		L_INBLOCKS+24
+#define L_INCREMENTS	L_INDEX(16*16)
+#define L_LENGTH		L_INDEX(16*18+8)
+#define L_KEYS_BEGIN	L_INDEX(16*19)
+
+#define MOVD			mov
+#define MM_0			r9d
+#define MM_1			r12d
+#ifdef __GNUC__
+#define MM_2			r11d
+#else
+#define MM_2			r10d
+#endif
+#define MM(i)			MM_##i
+
+#define MXOR(a,b,c)	\
+	AS2(	movzx	esi, b)\
+	AS2(	xor		MM(a), DWORD PTR [AS_REG_7+8*WORD_REG(si)+MAP0TO4(c)])\
+
+#define MMOV(a,b,c)	\
+	AS2(	movzx	esi, b)\
+	AS2(	mov		MM(a), DWORD PTR [AS_REG_7+8*WORD_REG(si)+MAP0TO4(c)])\
+
+#endif
+
+#define L_SUBKEYS		L_INDEX(0)
+#define L_SAVED_X		L_SUBKEYS
+#define L_KEY12			L_INDEX(16*12)
+#define L_LASTROUND		L_INDEX(16*13)
+#define L_INBLOCKS		L_INDEX(16*14)
+#define MAP0TO4(i)		(ASM_MOD(i+3,4)+1)
+
+#define XOR(a,b,c)	\
+	AS2(	movzx	esi, b)\
+	AS2(	xor		a, DWORD PTR [AS_REG_7+8*WORD_REG(si)+MAP0TO4(c)])\
+
+#define MOV(a,b,c)	\
+	AS2(	movzx	esi, b)\
+	AS2(	mov		a, DWORD PTR [AS_REG_7+8*WORD_REG(si)+MAP0TO4(c)])\
+
+#ifdef CRYPTOPP_GENERATE_X64_MASM
+		ALIGN   8
+	Rijndael_Enc_AdvancedProcessBlocks	PROC FRAME
+		rex_push_reg rsi
+		push_reg rdi
+		push_reg rbx
+		push_reg r12
+		.endprolog
+		mov L_REG, rcx
+		mov AS_REG_7, ?Te@rdtable@CryptoPP@@3PA_KA
+		mov edi, DWORD PTR [?g_cacheLineSize@CryptoPP@@3IA]
+#elif defined(__GNUC__)
+	__asm__ __volatile__
+	(
+	".intel_syntax noprefix;"
+	#if CRYPTOPP_BOOL_X64
+	AS2(	mov		L_REG, rcx)
+	#endif
+	AS_PUSH_IF86(bx)
+	AS_PUSH_IF86(bp)
+	AS2(	mov		AS_REG_7, WORD_REG(si))
+#else
+	AS_PUSH_IF86(si)
+	AS_PUSH_IF86(di)
+	AS_PUSH_IF86(bx)
+	AS_PUSH_IF86(bp)
+	AS2(	lea		AS_REG_7, [Te])
+	AS2(	mov		edi, [g_cacheLineSize])
+#endif
+
+#if CRYPTOPP_BOOL_X86
+	AS2(	mov		[ecx+16*12+16*4], esp)	// save esp to L_SP
+	AS2(	lea		esp, [ecx-512])
+#endif
+
+	// copy subkeys to stack
+	AS2(	mov		WORD_REG(si), [L_KEYS_BEGIN])
+	AS2(	mov		WORD_REG(ax), 16)
+	AS2(	and		WORD_REG(ax), WORD_REG(si))
+	AS2(	movdqa	xmm3, XMMWORD_PTR [WORD_REG(dx)+16+WORD_REG(ax)])	// subkey 1 (non-counter) or 2 (counter)
+	AS2(	movdqa	[L_KEY12], xmm3)
+	AS2(	lea		WORD_REG(ax), [WORD_REG(dx)+WORD_REG(ax)+2*16])
+	AS2(	sub		WORD_REG(ax), WORD_REG(si))
+	ASL(0)
+	AS2(	movdqa	xmm0, [WORD_REG(ax)+WORD_REG(si)])
+	AS2(	movdqa	XMMWORD_PTR [L_SUBKEYS+WORD_REG(si)], xmm0)
+	AS2(	add		WORD_REG(si), 16)
+	AS2(	cmp		WORD_REG(si), 16*12)
+	ASJ(	jl,		0, b)
+
+	// read subkeys 0, 1 and last
+	AS2(	movdqa	xmm4, [WORD_REG(ax)+WORD_REG(si)])	// last subkey
+	AS2(	movdqa	xmm1, [WORD_REG(dx)])			// subkey 0
+	AS2(	MOVD	MM(1), [WORD_REG(dx)+4*4])		// 0,1,2,3
+	AS2(	mov		ebx, [WORD_REG(dx)+5*4])		// 4,5,6,7
+	AS2(	mov		ecx, [WORD_REG(dx)+6*4])		// 8,9,10,11
+	AS2(	mov		edx, [WORD_REG(dx)+7*4])		// 12,13,14,15
+
+	// load table into cache
+	AS2(	xor		WORD_REG(ax), WORD_REG(ax))
+	ASL(9)
+	AS2(	mov		esi, [AS_REG_7+WORD_REG(ax)])
+	AS2(	add		WORD_REG(ax), WORD_REG(di))
+	AS2(	mov		esi, [AS_REG_7+WORD_REG(ax)])
+	AS2(	add		WORD_REG(ax), WORD_REG(di))
+	AS2(	mov		esi, [AS_REG_7+WORD_REG(ax)])
+	AS2(	add		WORD_REG(ax), WORD_REG(di))
+	AS2(	mov		esi, [AS_REG_7+WORD_REG(ax)])
+	AS2(	add		WORD_REG(ax), WORD_REG(di))
+	AS2(	cmp		WORD_REG(ax), 2048)
+	ASJ(	jl,		9, b)
+	AS1(	lfence)
+
+	AS2(	test	DWORD PTR [L_LENGTH], 1)
+	ASJ(	jz,		8, f)
+
+	// counter mode one-time setup
+	AS2(	mov		WORD_REG(si), [L_INBLOCKS])
+	AS2(	movdqu	xmm2, [WORD_REG(si)])	// counter
+	AS2(	pxor	xmm2, xmm1)
+	AS2(	psrldq	xmm1, 14)
+	AS2(	movd	eax, xmm1)
+	AS2(	mov		al, BYTE PTR [WORD_REG(si)+15])
+	AS2(	MOVD	MM(2), eax)
+#if CRYPTOPP_BOOL_X86
+	AS2(	mov		eax, 1)
+	AS2(	movd	mm3, eax)
+#endif
+
+	// partial first round, in: xmm2(15,14,13,12;11,10,9,8;7,6,5,4;3,2,1,0), out: mm1, ebx, ecx, edx
+	AS2(	movd	eax, xmm2)
+	AS2(	psrldq	xmm2, 4)
+	AS2(	movd	edi, xmm2)
+	AS2(	psrldq	xmm2, 4)
+		MXOR(		1, al, 0)		// 0
+		XOR(		edx, ah, 1)		// 1
+	AS2(	shr		eax, 16)
+		XOR(		ecx, al, 2)		// 2
+		XOR(		ebx, ah, 3)		// 3
+	AS2(	mov		eax, edi)
+	AS2(	movd	edi, xmm2)
+	AS2(	psrldq	xmm2, 4)
+		XOR(		ebx, al, 0)		// 4
+		MXOR(		1, ah, 1)		// 5
+	AS2(	shr		eax, 16)
+		XOR(		edx, al, 2)		// 6
+		XOR(		ecx, ah, 3)		// 7
+	AS2(	mov		eax, edi)
+	AS2(	movd	edi, xmm2)
+		XOR(		ecx, al, 0)		// 8
+		XOR(		ebx, ah, 1)		// 9
+	AS2(	shr		eax, 16)
+		MXOR(		1, al, 2)		// 10
+		XOR(		edx, ah, 3)		// 11
+	AS2(	mov		eax, edi)
+		XOR(		edx, al, 0)		// 12
+		XOR(		ecx, ah, 1)		// 13
+	AS2(	shr		eax, 16)
+		XOR(		ebx, al, 2)		// 14
+	AS2(	psrldq	xmm2, 3)
+
+	// partial second round, in: ebx(4,5,6,7), ecx(8,9,10,11), edx(12,13,14,15), out: eax, ebx, edi, mm0
+	AS2(	mov		eax, [L_KEY12+0*4])
+	AS2(	mov		edi, [L_KEY12+2*4])
+	AS2(	MOVD	MM(0), [L_KEY12+3*4])
+		MXOR(	0, cl, 3)	/* 11 */
+		XOR(	edi, bl, 3)	/* 7 */
+		MXOR(	0, bh, 2)	/* 6 */
+	AS2(	shr ebx, 16)	/* 4,5 */
+		XOR(	eax, bl, 1)	/* 5 */
+		MOV(	ebx, bh, 0)	/* 4 */
+	AS2(	xor		ebx, [L_KEY12+1*4])
+		XOR(	eax, ch, 2)	/* 10 */
+	AS2(	shr ecx, 16)	/* 8,9 */
+		XOR(	eax, dl, 3)	/* 15 */
+		XOR(	ebx, dh, 2)	/* 14 */
+	AS2(	shr edx, 16)	/* 12,13 */
+		XOR(	edi, ch, 0)	/* 8 */
+		XOR(	ebx, cl, 1)	/* 9 */
+		XOR(	edi, dl, 1)	/* 13 */
+		MXOR(	0, dh, 0)	/* 12 */
+
+	AS2(	movd	ecx, xmm2)
+	AS2(	MOVD	edx, MM(1))
+	AS2(	MOVD	[L_SAVED_X+3*4], MM(0))
+	AS2(	mov		[L_SAVED_X+0*4], eax)
+	AS2(	mov		[L_SAVED_X+1*4], ebx)
+	AS2(	mov		[L_SAVED_X+2*4], edi)
+	ASJ(	jmp,	5, f)
+
+	ASL(3)
+	// non-counter mode per-block setup
+	AS2(	MOVD	MM(1), [L_KEY12+0*4])	// 0,1,2,3
+	AS2(	mov		ebx, [L_KEY12+1*4])		// 4,5,6,7
+	AS2(	mov		ecx, [L_KEY12+2*4])		// 8,9,10,11
+	AS2(	mov		edx, [L_KEY12+3*4])		// 12,13,14,15
+	ASL(8)
+	AS2(	mov		WORD_REG(ax), [L_INBLOCKS])
+	AS2(	movdqu	xmm2, [WORD_REG(ax)])
+	AS2(	mov		WORD_REG(si), [L_INXORBLOCKS])
+	AS2(	movdqu	xmm5, [WORD_REG(si)])
+	AS2(	pxor	xmm2, xmm1)
+	AS2(	pxor	xmm2, xmm5)
+
+	// first round, in: xmm2(15,14,13,12;11,10,9,8;7,6,5,4;3,2,1,0), out: eax, ebx, ecx, edx
+	AS2(	movd	eax, xmm2)
+	AS2(	psrldq	xmm2, 4)
+	AS2(	movd	edi, xmm2)
+	AS2(	psrldq	xmm2, 4)
+		MXOR(		1, al, 0)		// 0
+		XOR(		edx, ah, 1)		// 1
+	AS2(	shr		eax, 16)
+		XOR(		ecx, al, 2)		// 2
+		XOR(		ebx, ah, 3)		// 3
+	AS2(	mov		eax, edi)
+	AS2(	movd	edi, xmm2)
+	AS2(	psrldq	xmm2, 4)
+		XOR(		ebx, al, 0)		// 4
+		MXOR(		1, ah, 1)		// 5
+	AS2(	shr		eax, 16)
+		XOR(		edx, al, 2)		// 6
+		XOR(		ecx, ah, 3)		// 7
+	AS2(	mov		eax, edi)
+	AS2(	movd	edi, xmm2)
+		XOR(		ecx, al, 0)		// 8
+		XOR(		ebx, ah, 1)		// 9
+	AS2(	shr		eax, 16)
+		MXOR(		1, al, 2)		// 10
+		XOR(		edx, ah, 3)		// 11
+	AS2(	mov		eax, edi)
+		XOR(		edx, al, 0)		// 12
+		XOR(		ecx, ah, 1)		// 13
+	AS2(	shr		eax, 16)
+		XOR(		ebx, al, 2)		// 14
+		MXOR(		1, ah, 3)		// 15
+	AS2(	MOVD	eax, MM(1))
+
+	AS2(	add		L_REG, [L_KEYS_BEGIN])
+	AS2(	add		L_REG, 4*16)
+	ASJ(	jmp,	2, f)
+
+	ASL(1)
+	// counter-mode per-block setup
+	AS2(	MOVD	ecx, MM(2))
+	AS2(	MOVD	edx, MM(1))
+	AS2(	mov		eax, [L_SAVED_X+0*4])
+	AS2(	mov		ebx, [L_SAVED_X+1*4])
+	AS2(	xor		cl, ch)
+	AS2(	and		WORD_REG(cx), 255)
+	ASL(5)
+#if CRYPTOPP_BOOL_X86
+	AS2(	paddb	MM(2), mm3)
+#else
+	AS2(	add		MM(2), 1)
+#endif
+	// remaining part of second round, in: edx(previous round),esi(keyed counter byte) eax,ebx,[L_SAVED_X+2*4],[L_SAVED_X+3*4], out: eax,ebx,ecx,edx
+	AS2(	xor		edx, DWORD PTR [AS_REG_7+WORD_REG(cx)*8+3])
+		XOR(		ebx, dl, 3)
+		MOV(		ecx, dh, 2)
+	AS2(	shr		edx, 16)
+	AS2(	xor		ecx, [L_SAVED_X+2*4])
+		XOR(		eax, dh, 0)
+		MOV(		edx, dl, 1)
+	AS2(	xor		edx, [L_SAVED_X+3*4])
+
+	AS2(	add		L_REG, [L_KEYS_BEGIN])
+	AS2(	add		L_REG, 3*16)
+	ASJ(	jmp,	4, f)
+
+// in: eax(0,1,2,3), ebx(4,5,6,7), ecx(8,9,10,11), edx(12,13,14,15)
+// out: eax, ebx, edi, mm0
+#define ROUND()		\
+		MXOR(	0, cl, 3)	/* 11 */\
+	AS2(	mov	cl, al)		/* 8,9,10,3 */\
+		XOR(	edi, ah, 2)	/* 2 */\
+	AS2(	shr eax, 16)	/* 0,1 */\
+		XOR(	edi, bl, 3)	/* 7 */\
+		MXOR(	0, bh, 2)	/* 6 */\
+	AS2(	shr ebx, 16)	/* 4,5 */\
+		MXOR(	0, al, 1)	/* 1 */\
+		MOV(	eax, ah, 0)	/* 0 */\
+		XOR(	eax, bl, 1)	/* 5 */\
+		MOV(	ebx, bh, 0)	/* 4 */\
+		XOR(	eax, ch, 2)	/* 10 */\
+		XOR(	ebx, cl, 3)	/* 3 */\
+	AS2(	shr ecx, 16)	/* 8,9 */\
+		XOR(	eax, dl, 3)	/* 15 */\
+		XOR(	ebx, dh, 2)	/* 14 */\
+	AS2(	shr edx, 16)	/* 12,13 */\
+		XOR(	edi, ch, 0)	/* 8 */\
+		XOR(	ebx, cl, 1)	/* 9 */\
+		XOR(	edi, dl, 1)	/* 13 */\
+		MXOR(	0, dh, 0)	/* 12 */\
+
+	ASL(2)	// 2-round loop
+	AS2(	MOVD	MM(0), [L_SUBKEYS-4*16+3*4])
+	AS2(	mov		edi, [L_SUBKEYS-4*16+2*4])
+	ROUND()
+	AS2(	mov		ecx, edi)
+	AS2(	xor		eax, [L_SUBKEYS-4*16+0*4])
+	AS2(	xor		ebx, [L_SUBKEYS-4*16+1*4])
+	AS2(	MOVD	edx, MM(0))
+
+	ASL(4)
+	AS2(	MOVD	MM(0), [L_SUBKEYS-4*16+7*4])
+	AS2(	mov		edi, [L_SUBKEYS-4*16+6*4])
+	ROUND()
+	AS2(	mov		ecx, edi)
+	AS2(	xor		eax, [L_SUBKEYS-4*16+4*4])
+	AS2(	xor		ebx, [L_SUBKEYS-4*16+5*4])
+	AS2(	MOVD	edx, MM(0))
+
+	AS2(	add		L_REG, 32)
+	AS2(	test	L_REG, 255)
+	ASJ(	jnz,	2, b)
+	AS2(	sub		L_REG, 16*16)
+
+#define LAST(a, b, c)												\
+	AS2(	movzx	esi, a											)\
+	AS2(	movzx	edi, BYTE PTR [AS_REG_7+WORD_REG(si)*8+1]	)\
+	AS2(	movzx	esi, b											)\
+	AS2(	xor		edi, DWORD PTR [AS_REG_7+WORD_REG(si)*8+0]	)\
+	AS2(	mov		WORD PTR [L_LASTROUND+c], di					)\
+
+	// last round
+	LAST(ch, dl, 2)
+	LAST(dh, al, 6)
+	AS2(	shr		edx, 16)
+	LAST(ah, bl, 10)
+	AS2(	shr		eax, 16)
+	LAST(bh, cl, 14)
+	AS2(	shr		ebx, 16)
+	LAST(dh, al, 12)
+	AS2(	shr		ecx, 16)
+	LAST(ah, bl, 0)
+	LAST(bh, cl, 4)
+	LAST(ch, dl, 8)
+
+	AS2(	mov		WORD_REG(ax), [L_OUTXORBLOCKS])
+	AS2(	mov		WORD_REG(bx), [L_OUTBLOCKS])
+
+	AS2(	mov		WORD_REG(cx), [L_LENGTH])
+	AS2(	sub		WORD_REG(cx), 16)
+
+	AS2(	movdqu	xmm2, [WORD_REG(ax)])
+	AS2(	pxor	xmm2, xmm4)
+
+#if CRYPTOPP_BOOL_X86
+	AS2(	movdqa	xmm0, [L_INCREMENTS])
+	AS2(	paddd	xmm0, [L_INBLOCKS])
+	AS2(	movdqa	[L_INBLOCKS], xmm0)
+#else
+	AS2(	movdqa	xmm0, [L_INCREMENTS+16])
+	AS2(	paddq	xmm0, [L_INBLOCKS+16])
+	AS2(	movdqa	[L_INBLOCKS+16], xmm0)
+#endif
+
+	AS2(	pxor	xmm2, [L_LASTROUND])
+	AS2(	movdqu	[WORD_REG(bx)], xmm2)
+
+	ASJ(	jle,	7, f)
+	AS2(	mov		[L_LENGTH], WORD_REG(cx))
+	AS2(	test	WORD_REG(cx), 1)
+	ASJ(	jnz,	1, b)
+#if CRYPTOPP_BOOL_X64
+	AS2(	movdqa	xmm0, [L_INCREMENTS])
+	AS2(	paddq	xmm0, [L_INBLOCKS])
+	AS2(	movdqa	[L_INBLOCKS], xmm0)
+#endif
+	ASJ(	jmp,	3, b)
+
+	ASL(7)
+	// erase keys on stack
+	AS2(	xorps	xmm0, xmm0)
+	AS2(	lea		WORD_REG(ax), [L_SUBKEYS+7*16])
+	AS2(	movaps	[WORD_REG(ax)-7*16], xmm0)
+	AS2(	movaps	[WORD_REG(ax)-6*16], xmm0)
+	AS2(	movaps	[WORD_REG(ax)-5*16], xmm0)
+	AS2(	movaps	[WORD_REG(ax)-4*16], xmm0)
+	AS2(	movaps	[WORD_REG(ax)-3*16], xmm0)
+	AS2(	movaps	[WORD_REG(ax)-2*16], xmm0)
+	AS2(	movaps	[WORD_REG(ax)-1*16], xmm0)
+	AS2(	movaps	[WORD_REG(ax)+0*16], xmm0)
+	AS2(	movaps	[WORD_REG(ax)+1*16], xmm0)
+	AS2(	movaps	[WORD_REG(ax)+2*16], xmm0)
+	AS2(	movaps	[WORD_REG(ax)+3*16], xmm0)
+	AS2(	movaps	[WORD_REG(ax)+4*16], xmm0)
+	AS2(	movaps	[WORD_REG(ax)+5*16], xmm0)
+	AS2(	movaps	[WORD_REG(ax)+6*16], xmm0)
+#if CRYPTOPP_BOOL_X86
+	AS2(	mov		esp, [L_SP])
+	AS1(	emms)
+#endif
+	AS_POP_IF86(bp)
+	AS_POP_IF86(bx)
+#if defined(_MSC_VER) && CRYPTOPP_BOOL_X86
+	AS_POP_IF86(di)
+	AS_POP_IF86(si)
+	AS1(ret)
+#endif
+#ifdef CRYPTOPP_GENERATE_X64_MASM
+	pop r12
+	pop rbx
+	pop rdi
+	pop rsi
+	ret
+	Rijndael_Enc_AdvancedProcessBlocks ENDP
+#endif
+#ifdef __GNUC__
+	".att_syntax prefix;"
+	: 
+	: "c" (locals), "d" (k), "S" (Te), "D" (g_cacheLineSize)
+	: "memory", "cc", "%eax"
+	#if CRYPTOPP_BOOL_X64
+		, "%rbx", "%r8", "%r9", "%r10", "%r11", "%r12"
+	#endif
+	);
+#endif
+}
+
+#endif
+
+#ifndef CRYPTOPP_GENERATE_X64_MASM
+
+#ifdef CRYPTOPP_X64_MASM_AVAILABLE
+extern "C" {
+void Rijndael_Enc_AdvancedProcessBlocks(void *locals, const word32 *k);
+}
+#endif
+
+#if CRYPTOPP_BOOL_X64 || CRYPTOPP_BOOL_X86
+
+static inline bool AliasedWithTable(const byte *begin, const byte *end)
+{
+	size_t s0 = size_t(begin)%4096, s1 = size_t(end)%4096;
+	size_t t0 = size_t(Te)%4096, t1 = (size_t(Te)+sizeof(Te))%4096;
+	if (t1 > t0)
+		return (s0 >= t0 && s0 < t1) || (s1 > t0 && s1 <= t1);
+	else
+		return (s0 < t1 || s1 <= t1) || (s0 >= t0 || s1 > t0);
+}
+
+#if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE
+
+inline void AESNI_Enc_Block(__m128i &block, const __m128i *subkeys, unsigned int rounds)
+{
+	block = _mm_xor_si128(block, subkeys[0]);
+	for (unsigned int i=1; i<rounds-1; i+=2)
+	{
+		block = _mm_aesenc_si128(block, subkeys[i]);
+		block = _mm_aesenc_si128(block, subkeys[i+1]);
+	}
+	block = _mm_aesenc_si128(block, subkeys[rounds-1]);
+	block = _mm_aesenclast_si128(block, subkeys[rounds]);
+}
+
+inline void AESNI_Enc_4_Blocks(__m128i &block0, __m128i &block1, __m128i &block2, __m128i &block3, const __m128i *subkeys, unsigned int rounds)
+{
+	__m128i rk = subkeys[0];
+	block0 = _mm_xor_si128(block0, rk);
+	block1 = _mm_xor_si128(block1, rk);
+	block2 = _mm_xor_si128(block2, rk);
+	block3 = _mm_xor_si128(block3, rk);
+	for (unsigned int i=1; i<rounds; i++)
+	{
+		rk = subkeys[i];
+		block0 = _mm_aesenc_si128(block0, rk);
+		block1 = _mm_aesenc_si128(block1, rk);
+		block2 = _mm_aesenc_si128(block2, rk);
+		block3 = _mm_aesenc_si128(block3, rk);
+	}
+	rk = subkeys[rounds];
+	block0 = _mm_aesenclast_si128(block0, rk);
+	block1 = _mm_aesenclast_si128(block1, rk);
+	block2 = _mm_aesenclast_si128(block2, rk);
+	block3 = _mm_aesenclast_si128(block3, rk);
+}
+
+inline void AESNI_Dec_Block(__m128i &block, const __m128i *subkeys, unsigned int rounds)
+{
+	block = _mm_xor_si128(block, subkeys[0]);
+	for (unsigned int i=1; i<rounds-1; i+=2)
+	{
+		block = _mm_aesdec_si128(block, subkeys[i]);
+		block = _mm_aesdec_si128(block, subkeys[i+1]);
+	}
+	block = _mm_aesdec_si128(block, subkeys[rounds-1]);
+	block = _mm_aesdeclast_si128(block, subkeys[rounds]);
+}
+
+inline void AESNI_Dec_4_Blocks(__m128i &block0, __m128i &block1, __m128i &block2, __m128i &block3, const __m128i *subkeys, unsigned int rounds)
+{
+	__m128i rk = subkeys[0];
+	block0 = _mm_xor_si128(block0, rk);
+	block1 = _mm_xor_si128(block1, rk);
+	block2 = _mm_xor_si128(block2, rk);
+	block3 = _mm_xor_si128(block3, rk);
+	for (unsigned int i=1; i<rounds; i++)
+	{
+		rk = subkeys[i];
+		block0 = _mm_aesdec_si128(block0, rk);
+		block1 = _mm_aesdec_si128(block1, rk);
+		block2 = _mm_aesdec_si128(block2, rk);
+		block3 = _mm_aesdec_si128(block3, rk);
+	}
+	rk = subkeys[rounds];
+	block0 = _mm_aesdeclast_si128(block0, rk);
+	block1 = _mm_aesdeclast_si128(block1, rk);
+	block2 = _mm_aesdeclast_si128(block2, rk);
+	block3 = _mm_aesdeclast_si128(block3, rk);
+}
+
+static CRYPTOPP_ALIGN_DATA(16) const word32 s_one[] = {0, 0, 0, 1<<24};
+
+template <typename F1, typename F4>
+inline size_t AESNI_AdvancedProcessBlocks(F1 func1, F4 func4, const __m128i *subkeys, unsigned int rounds, const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags)
+{
+	size_t blockSize = 16;
+	size_t inIncrement = (flags & (BlockTransformation::BT_InBlockIsCounter|BlockTransformation::BT_DontIncrementInOutPointers)) ? 0 : blockSize;
+	size_t xorIncrement = xorBlocks ? blockSize : 0;
+	size_t outIncrement = (flags & BlockTransformation::BT_DontIncrementInOutPointers) ? 0 : blockSize;
+
+	if (flags & BlockTransformation::BT_ReverseDirection)
+	{
+		assert(length % blockSize == 0);
+		inBlocks += length - blockSize;
+		xorBlocks += length - blockSize;
+		outBlocks += length - blockSize;
+		inIncrement = 0-inIncrement;
+		xorIncrement = 0-xorIncrement;
+		outIncrement = 0-outIncrement;
+	}
+
+	if (flags & BlockTransformation::BT_AllowParallel)
+	{
+		while (length >= 4*blockSize)
+		{
+			__m128i block0 = _mm_loadu_si128((const __m128i *)inBlocks), block1, block2, block3;
+			if (flags & BlockTransformation::BT_InBlockIsCounter)
+			{
+				const __m128i be1 = *(const __m128i *)s_one;
+				block1 = _mm_add_epi32(block0, be1);
+				block2 = _mm_add_epi32(block1, be1);
+				block3 = _mm_add_epi32(block2, be1);
+				_mm_storeu_si128((__m128i *)inBlocks, _mm_add_epi32(block3, be1));
+			}
+			else
+			{
+				inBlocks += inIncrement;
+				block1 = _mm_loadu_si128((const __m128i *)inBlocks);
+				inBlocks += inIncrement;
+				block2 = _mm_loadu_si128((const __m128i *)inBlocks);
+				inBlocks += inIncrement;
+				block3 = _mm_loadu_si128((const __m128i *)inBlocks);
+				inBlocks += inIncrement;
+			}
+
+			if (flags & BlockTransformation::BT_XorInput)
+			{
+				block0 = _mm_xor_si128(block0, _mm_loadu_si128((const __m128i *)xorBlocks));
+				xorBlocks += xorIncrement;
+				block1 = _mm_xor_si128(block1, _mm_loadu_si128((const __m128i *)xorBlocks));
+				xorBlocks += xorIncrement;
+				block2 = _mm_xor_si128(block2, _mm_loadu_si128((const __m128i *)xorBlocks));
+				xorBlocks += xorIncrement;
+				block3 = _mm_xor_si128(block3, _mm_loadu_si128((const __m128i *)xorBlocks));
+				xorBlocks += xorIncrement;
+			}
+
+			func4(block0, block1, block2, block3, subkeys, rounds);
+
+			if (xorBlocks && !(flags & BlockTransformation::BT_XorInput))
+			{
+				block0 = _mm_xor_si128(block0, _mm_loadu_si128((const __m128i *)xorBlocks));
+				xorBlocks += xorIncrement;
+				block1 = _mm_xor_si128(block1, _mm_loadu_si128((const __m128i *)xorBlocks));
+				xorBlocks += xorIncrement;
+				block2 = _mm_xor_si128(block2, _mm_loadu_si128((const __m128i *)xorBlocks));
+				xorBlocks += xorIncrement;
+				block3 = _mm_xor_si128(block3, _mm_loadu_si128((const __m128i *)xorBlocks));
+				xorBlocks += xorIncrement;
+			}
+
+			_mm_storeu_si128((__m128i *)outBlocks, block0);
+			outBlocks += outIncrement;
+			_mm_storeu_si128((__m128i *)outBlocks, block1);
+			outBlocks += outIncrement;
+			_mm_storeu_si128((__m128i *)outBlocks, block2);
+			outBlocks += outIncrement;
+			_mm_storeu_si128((__m128i *)outBlocks, block3);
+			outBlocks += outIncrement;
+
+			length -= 4*blockSize;
+		}
+	}
+
+	while (length >= blockSize)
+	{
+		__m128i block = _mm_loadu_si128((const __m128i *)inBlocks);
+
+		if (flags & BlockTransformation::BT_XorInput)
+			block = _mm_xor_si128(block, _mm_loadu_si128((const __m128i *)xorBlocks));
+
+		if (flags & BlockTransformation::BT_InBlockIsCounter)
+			const_cast<byte *>(inBlocks)[15]++;
+
+		func1(block, subkeys, rounds);
+
+		if (xorBlocks && !(flags & BlockTransformation::BT_XorInput))
+			block = _mm_xor_si128(block, _mm_loadu_si128((const __m128i *)xorBlocks));
+			
+		_mm_storeu_si128((__m128i *)outBlocks, block);
+
+		inBlocks += inIncrement;
+		outBlocks += outIncrement;
+		xorBlocks += xorIncrement;
+		length -= blockSize;
+	}
+
+	return length;
+}
+#endif
+
+size_t Rijndael::Enc::AdvancedProcessBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags) const
+{
+#if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE
+	if (HasAESNI())
+		return AESNI_AdvancedProcessBlocks(AESNI_Enc_Block, AESNI_Enc_4_Blocks, (const __m128i *)m_key.begin(), m_rounds, inBlocks, xorBlocks, outBlocks, length, flags);
+#endif
+	
+#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)
+	if (HasSSE2())
+	{
+		if (length < BLOCKSIZE)
+			return length;
+
+		struct Locals
+		{
+			word32 subkeys[4*12], workspace[8];
+			const byte *inBlocks, *inXorBlocks, *outXorBlocks;
+			byte *outBlocks;
+			size_t inIncrement, inXorIncrement, outXorIncrement, outIncrement;
+			size_t regSpill, lengthAndCounterFlag, keysBegin;
+		};
+
+		size_t increment = BLOCKSIZE;
+		const byte* zeros = (byte *)(Te+256);
+		byte *space;
+
+		do {
+			space = (byte *)alloca(255+sizeof(Locals));
+			space += (256-(size_t)space%256)%256;
+		}
+		while (AliasedWithTable(space, space+sizeof(Locals)));
+
+		if (flags & BT_ReverseDirection)
+		{
+			assert(length % BLOCKSIZE == 0);
+			inBlocks += length - BLOCKSIZE;
+			xorBlocks += length - BLOCKSIZE;
+			outBlocks += length - BLOCKSIZE;
+			increment = 0-increment;
+		}
+
+		Locals &locals = *(Locals *)space;
+
+		locals.inBlocks = inBlocks;
+		locals.inXorBlocks = (flags & BT_XorInput) && xorBlocks ? xorBlocks : zeros;
+		locals.outXorBlocks = (flags & BT_XorInput) || !xorBlocks ? zeros : xorBlocks;
+		locals.outBlocks = outBlocks;
+
+		locals.inIncrement = (flags & BT_DontIncrementInOutPointers) ? 0 : increment;
+		locals.inXorIncrement = (flags & BT_XorInput) && xorBlocks ? increment : 0;
+		locals.outXorIncrement = (flags & BT_XorInput) || !xorBlocks ? 0 : increment;
+		locals.outIncrement = (flags & BT_DontIncrementInOutPointers) ? 0 : increment;
+
+		locals.lengthAndCounterFlag = length - (length%16) - bool(flags & BT_InBlockIsCounter);
+		int keysToCopy = m_rounds - (flags & BT_InBlockIsCounter ? 3 : 2);
+		locals.keysBegin = (12-keysToCopy)*16;
+
+		Rijndael_Enc_AdvancedProcessBlocks(&locals, m_key);
+		return length % BLOCKSIZE;
+	}
+#endif
+
+	return BlockTransformation::AdvancedProcessBlocks(inBlocks, xorBlocks, outBlocks, length, flags);
+}
+
+#endif
+
+#if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE
+
+size_t Rijndael::Dec::AdvancedProcessBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags) const
+{
+	if (HasAESNI())
+		return AESNI_AdvancedProcessBlocks(AESNI_Dec_Block, AESNI_Dec_4_Blocks, (const __m128i *)m_key.begin(), m_rounds, inBlocks, xorBlocks, outBlocks, length, flags);
+	
+	return BlockTransformation::AdvancedProcessBlocks(inBlocks, xorBlocks, outBlocks, length, flags);
+}
+
+#endif	// #if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE
+
+NAMESPACE_END
+
+#endif
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/rng.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/rng.cpp
new file mode 100644
index 00000000..9866cd83
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/rng.cpp
@@ -0,0 +1,155 @@
+// rng.cpp - written and placed in the public domain by Wei Dai
+
+#include "pch.h"
+
+#include "rng.h"
+#include "fips140.h"
+
+#include <time.h>
+#include <math.h>
+
+NAMESPACE_BEGIN(CryptoPP)
+
+// linear congruential generator
+// originally by William S. England
+
+// do not use for cryptographic purposes
+
+/*
+** Original_numbers are the original published m and q in the
+** ACM article above.  John Burton has furnished numbers for
+** a reportedly better generator.  The new numbers are now
+** used in this program by default.
+*/
+
+#ifndef LCRNG_ORIGINAL_NUMBERS
+const word32 LC_RNG::m=2147483647L;
+const word32 LC_RNG::q=44488L;
+
+const word16 LC_RNG::a=(unsigned int)48271L;
+const word16 LC_RNG::r=3399;
+#else
+const word32 LC_RNG::m=2147483647L;
+const word32 LC_RNG::q=127773L;
+
+const word16 LC_RNG::a=16807;
+const word16 LC_RNG::r=2836;
+#endif
+
+void LC_RNG::GenerateBlock(byte *output, size_t size)
+{
+	while (size--)
+	{
+		word32 hi = seed/q;
+		word32 lo = seed%q;
+
+		long test = a*lo - r*hi;
+
+		if (test > 0)
+			seed = test;
+		else
+			seed = test+ m;
+
+		*output++ = (GETBYTE(seed, 0) ^ GETBYTE(seed, 1) ^ GETBYTE(seed, 2) ^ GETBYTE(seed, 3));
+	}
+}
+
+// ********************************************************
+
+#ifndef CRYPTOPP_IMPORTS
+
+X917RNG::X917RNG(BlockTransformation *c, const byte *seed, const byte *deterministicTimeVector)
+	: cipher(c),
+	  S(cipher->BlockSize()),
+	  dtbuf(S),
+	  randseed(seed, S),
+	  m_lastBlock(S),
+	  m_deterministicTimeVector(deterministicTimeVector, deterministicTimeVector ? S : 0)
+{
+	if (!deterministicTimeVector)
+	{
+		time_t tstamp1 = time(0);
+		xorbuf(dtbuf, (byte *)&tstamp1, UnsignedMin(sizeof(tstamp1), S));
+		cipher->ProcessBlock(dtbuf);
+		clock_t tstamp2 = clock();
+		xorbuf(dtbuf, (byte *)&tstamp2, UnsignedMin(sizeof(tstamp2), S));
+		cipher->ProcessBlock(dtbuf);
+	}
+
+	// for FIPS 140-2
+	GenerateBlock(m_lastBlock, S);
+}
+
+void X917RNG::GenerateIntoBufferedTransformation(BufferedTransformation &target, const std::string &channel, lword size)
+{
+	while (size > 0)
+	{
+		// calculate new enciphered timestamp
+		if (m_deterministicTimeVector.size())
+		{
+			cipher->ProcessBlock(m_deterministicTimeVector, dtbuf);
+			IncrementCounterByOne(m_deterministicTimeVector, S);
+		}
+		else
+		{
+			clock_t c = clock();
+			xorbuf(dtbuf, (byte *)&c, UnsignedMin(sizeof(c), S));
+			time_t t = time(NULL);
+			xorbuf(dtbuf+S-UnsignedMin(sizeof(t), S), (byte *)&t, UnsignedMin(sizeof(t), S));
+			cipher->ProcessBlock(dtbuf);
+		}
+
+		// combine enciphered timestamp with seed
+		xorbuf(randseed, dtbuf, S);
+
+		// generate a new block of random bytes
+		cipher->ProcessBlock(randseed);
+		if (memcmp(m_lastBlock, randseed, S) == 0)
+			throw SelfTestFailure("X917RNG: Continuous random number generator test failed.");
+
+		// output random bytes
+		size_t len = UnsignedMin(S, size);
+		target.ChannelPut(channel, randseed, len);
+		size -= len;
+
+		// compute new seed vector
+		memcpy(m_lastBlock, randseed, S);
+		xorbuf(randseed, dtbuf, S);
+		cipher->ProcessBlock(randseed);
+	}
+}
+
+#endif
+
+MaurerRandomnessTest::MaurerRandomnessTest()
+	: sum(0.0), n(0)
+{
+	for (unsigned i=0; i<V; i++)
+		tab[i] = 0;
+}
+
+size_t MaurerRandomnessTest::Put2(const byte *inString, size_t length, int messageEnd, bool blocking)
+{
+	while (length--)
+	{
+		byte inByte = *inString++;
+		if (n >= Q)
+			sum += log(double(n - tab[inByte]));
+		tab[inByte] = n;
+		n++;
+	}
+	return 0;
+}
+
+double MaurerRandomnessTest::GetTestValue() const
+{
+	if (BytesNeeded() > 0)
+		throw Exception(Exception::OTHER_ERROR, "MaurerRandomnessTest: " + IntToString(BytesNeeded()) + " more bytes of input needed");
+
+	double fTu = (sum/(n-Q))/log(2.0);	// this is the test value defined by Maurer
+
+	double value = fTu * 0.1392;		// arbitrarily normalize it to
+	return value > 1.0 ? 1.0 : value;	// a number between 0 and 1
+}
+
+NAMESPACE_END
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/sha.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/sha.cpp
index a3c40187..df947ad1 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/src/sha.cpp
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/sha.cpp
@@ -1,277 +1,900 @@
-// sha.cpp - modified by Wei Dai from Steve Reid's public domain sha1.c
-
-// Steve Reid implemented SHA-1. Wei Dai implemented SHA-2.
-// Both are in the public domain.
-
-//#include "pch.h"
-#include "sha.h"
-#include "misc.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-void SHA::Init()
-{
-	m_digest[0] = 0x67452301L;
-	m_digest[1] = 0xEFCDAB89L;
-	m_digest[2] = 0x98BADCFEL;
-	m_digest[3] = 0x10325476L;
-	m_digest[4] = 0xC3D2E1F0L;
-}
-
-// start of Steve Reid's code
-
-#define blk0(i) (W[i] = data[i])
-#define blk1(i) (W[i&15] = rotlFixed(W[(i+13)&15]^W[(i+8)&15]^W[(i+2)&15]^W[i&15],1))
-
-#define f1(x,y,z) (z^(x&(y^z)))
-#define f2(x,y,z) (x^y^z)
-#define f3(x,y,z) ((x&y)|(z&(x|y)))
-#define f4(x,y,z) (x^y^z)
-
-/* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */
-#define R0(v,w,x,y,z,i) z+=f1(w,x,y)+blk0(i)+0x5A827999+rotlFixed(v,5);w=rotlFixed(w,30);
-#define R1(v,w,x,y,z,i) z+=f1(w,x,y)+blk1(i)+0x5A827999+rotlFixed(v,5);w=rotlFixed(w,30);
-#define R2(v,w,x,y,z,i) z+=f2(w,x,y)+blk1(i)+0x6ED9EBA1+rotlFixed(v,5);w=rotlFixed(w,30);
-#define R3(v,w,x,y,z,i) z+=f3(w,x,y)+blk1(i)+0x8F1BBCDC+rotlFixed(v,5);w=rotlFixed(w,30);
-#define R4(v,w,x,y,z,i) z+=f4(w,x,y)+blk1(i)+0xCA62C1D6+rotlFixed(v,5);w=rotlFixed(w,30);
-
-void SHA::Transform(word32 *state, const word32 *data)
-{
-	word32 W[16];
-    /* Copy context->state[] to working vars */
-    word32 a = state[0];
-    word32 b = state[1];
-    word32 c = state[2];
-    word32 d = state[3];
-    word32 e = state[4];
-    /* 4 rounds of 20 operations each. Loop unrolled. */
-    R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
-    R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
-    R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);
-    R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);
-    R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
-    R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);
-    R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);
-    R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
-    R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
-    R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);
-    R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);
-    R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
-    R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
-    R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
-    R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
-    R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
-    R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);
-    R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
-    R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
-    R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);
-    /* Add the working vars back into context.state[] */
-    state[0] += a;
-    state[1] += b;
-    state[2] += c;
-    state[3] += d;
-    state[4] += e;
-    /* Wipe variables */
-    a = b = c = d = e = 0;
-	memset(W, 0, sizeof(W));
-}
-
-// end of Steve Reid's code
-
-// *************************************************************
-
-void SHA256::Init()
-{
-	m_digest[0] = 0x6a09e667;
-	m_digest[1] = 0xbb67ae85;
-	m_digest[2] = 0x3c6ef372;
-	m_digest[3] = 0xa54ff53a;
-	m_digest[4] = 0x510e527f;
-	m_digest[5] = 0x9b05688c;
-	m_digest[6] = 0x1f83d9ab;
-	m_digest[7] = 0x5be0cd19;
-}
-
-#define blk2(i) (W[i&15]+=s1(W[(i-2)&15])+W[(i-7)&15]+s0(W[(i-15)&15]))
-
-#define Ch(x,y,z) (z^(x&(y^z)))
-#define Maj(x,y,z) ((x&y)|(z&(x|y)))
-
-#define a(i) T[(0-i)&7]
-#define b(i) T[(1-i)&7]
-#define c(i) T[(2-i)&7]
-#define d(i) T[(3-i)&7]
-#define e(i) T[(4-i)&7]
-#define f(i) T[(5-i)&7]
-#define g(i) T[(6-i)&7]
-#define h(i) T[(7-i)&7]
-
-#define R(i) h(i)+=S1(e(i))+Ch(e(i),f(i),g(i))+K[i+j]+(j?blk2(i):blk0(i));\
-	d(i)+=h(i);h(i)+=S0(a(i))+Maj(a(i),b(i),c(i))
-
-// for SHA256
-#define S0(x) (rotrFixed(x,2)^rotrFixed(x,13)^rotrFixed(x,22))
-#define S1(x) (rotrFixed(x,6)^rotrFixed(x,11)^rotrFixed(x,25))
-#define s0(x) (rotrFixed(x,7)^rotrFixed(x,18)^(x>>3))
-#define s1(x) (rotrFixed(x,17)^rotrFixed(x,19)^(x>>10))
-
-void SHA256::Transform(word32 *state, const word32 *data)
-{
-	word32 W[16];
-	word32 T[8];
-    /* Copy context->state[] to working vars */
-	memcpy(T, state, sizeof(T));
-    /* 64 operations, partially loop unrolled */
-	for (unsigned int j=0; j<64; j+=16)
-	{
-		R( 0); R( 1); R( 2); R( 3);
-		R( 4); R( 5); R( 6); R( 7);
-		R( 8); R( 9); R(10); R(11);
-		R(12); R(13); R(14); R(15);
-	}
-    /* Add the working vars back into context.state[] */
-    state[0] += a(0);
-    state[1] += b(0);
-    state[2] += c(0);
-    state[3] += d(0);
-    state[4] += e(0);
-    state[5] += f(0);
-    state[6] += g(0);
-    state[7] += h(0);
-    /* Wipe variables */
-	memset(W, 0, sizeof(W));
-	memset(T, 0, sizeof(T));
-}
-
-const word32 SHA256::K[64] = {
-	0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
-	0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
-	0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
-	0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
-	0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
-	0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
-	0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
-	0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
-	0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
-	0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
-	0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
-	0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
-	0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
-	0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
-	0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
-	0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
-};
-
-#undef S0
-#undef S1
-#undef s0
-#undef s1
-
-// *************************************************************
-
-#ifdef WORD64_AVAILABLE
-
-void SHA512::Init()
-{
-	m_digest[0] = W64LIT(0x6a09e667f3bcc908);
-	m_digest[1] = W64LIT(0xbb67ae8584caa73b);
-	m_digest[2] = W64LIT(0x3c6ef372fe94f82b);
-	m_digest[3] = W64LIT(0xa54ff53a5f1d36f1);
-	m_digest[4] = W64LIT(0x510e527fade682d1);
-	m_digest[5] = W64LIT(0x9b05688c2b3e6c1f);
-	m_digest[6] = W64LIT(0x1f83d9abfb41bd6b);
-	m_digest[7] = W64LIT(0x5be0cd19137e2179);
-}
-
-// for SHA512
-#define S0(x) (rotrFixed(x,28)^rotrFixed(x,34)^rotrFixed(x,39))
-#define S1(x) (rotrFixed(x,14)^rotrFixed(x,18)^rotrFixed(x,41))
-#define s0(x) (rotrFixed(x,1)^rotrFixed(x,8)^(x>>7))
-#define s1(x) (rotrFixed(x,19)^rotrFixed(x,61)^(x>>6))
-
-void SHA512::Transform(word64 *state, const word64 *data)
-{
-	word64 W[16];
-	word64 T[8];
-    /* Copy context->state[] to working vars */
-	memcpy(T, state, sizeof(T));
-    /* 80 operations, partially loop unrolled */
-	for (unsigned int j=0; j<80; j+=16)
-	{
-		R( 0); R( 1); R( 2); R( 3);
-		R( 4); R( 5); R( 6); R( 7);
-		R( 8); R( 9); R(10); R(11);
-		R(12); R(13); R(14); R(15);
-	}
-    /* Add the working vars back into context.state[] */
-    state[0] += a(0);
-    state[1] += b(0);
-    state[2] += c(0);
-    state[3] += d(0);
-    state[4] += e(0);
-    state[5] += f(0);
-    state[6] += g(0);
-    state[7] += h(0);
-    /* Wipe variables */
-	memset(W, 0, sizeof(W));
-	memset(T, 0, sizeof(T));
-}
-
-const word64 SHA512::K[80] = {
-	W64LIT(0x428a2f98d728ae22), W64LIT(0x7137449123ef65cd),
-	W64LIT(0xb5c0fbcfec4d3b2f), W64LIT(0xe9b5dba58189dbbc),
-	W64LIT(0x3956c25bf348b538), W64LIT(0x59f111f1b605d019),
-	W64LIT(0x923f82a4af194f9b), W64LIT(0xab1c5ed5da6d8118),
-	W64LIT(0xd807aa98a3030242), W64LIT(0x12835b0145706fbe),
-	W64LIT(0x243185be4ee4b28c), W64LIT(0x550c7dc3d5ffb4e2),
-	W64LIT(0x72be5d74f27b896f), W64LIT(0x80deb1fe3b1696b1),
-	W64LIT(0x9bdc06a725c71235), W64LIT(0xc19bf174cf692694),
-	W64LIT(0xe49b69c19ef14ad2), W64LIT(0xefbe4786384f25e3),
-	W64LIT(0x0fc19dc68b8cd5b5), W64LIT(0x240ca1cc77ac9c65),
-	W64LIT(0x2de92c6f592b0275), W64LIT(0x4a7484aa6ea6e483),
-	W64LIT(0x5cb0a9dcbd41fbd4), W64LIT(0x76f988da831153b5),
-	W64LIT(0x983e5152ee66dfab), W64LIT(0xa831c66d2db43210),
-	W64LIT(0xb00327c898fb213f), W64LIT(0xbf597fc7beef0ee4),
-	W64LIT(0xc6e00bf33da88fc2), W64LIT(0xd5a79147930aa725),
-	W64LIT(0x06ca6351e003826f), W64LIT(0x142929670a0e6e70),
-	W64LIT(0x27b70a8546d22ffc), W64LIT(0x2e1b21385c26c926),
-	W64LIT(0x4d2c6dfc5ac42aed), W64LIT(0x53380d139d95b3df),
-	W64LIT(0x650a73548baf63de), W64LIT(0x766a0abb3c77b2a8),
-	W64LIT(0x81c2c92e47edaee6), W64LIT(0x92722c851482353b),
-	W64LIT(0xa2bfe8a14cf10364), W64LIT(0xa81a664bbc423001),
-	W64LIT(0xc24b8b70d0f89791), W64LIT(0xc76c51a30654be30),
-	W64LIT(0xd192e819d6ef5218), W64LIT(0xd69906245565a910),
-	W64LIT(0xf40e35855771202a), W64LIT(0x106aa07032bbd1b8),
-	W64LIT(0x19a4c116b8d2d0c8), W64LIT(0x1e376c085141ab53),
-	W64LIT(0x2748774cdf8eeb99), W64LIT(0x34b0bcb5e19b48a8),
-	W64LIT(0x391c0cb3c5c95a63), W64LIT(0x4ed8aa4ae3418acb),
-	W64LIT(0x5b9cca4f7763e373), W64LIT(0x682e6ff3d6b2b8a3),
-	W64LIT(0x748f82ee5defb2fc), W64LIT(0x78a5636f43172f60),
-	W64LIT(0x84c87814a1f0ab72), W64LIT(0x8cc702081a6439ec),
-	W64LIT(0x90befffa23631e28), W64LIT(0xa4506cebde82bde9),
-	W64LIT(0xbef9a3f7b2c67915), W64LIT(0xc67178f2e372532b),
-	W64LIT(0xca273eceea26619c), W64LIT(0xd186b8c721c0c207),
-	W64LIT(0xeada7dd6cde0eb1e), W64LIT(0xf57d4f7fee6ed178),
-	W64LIT(0x06f067aa72176fba), W64LIT(0x0a637dc5a2c898a6),
-	W64LIT(0x113f9804bef90dae), W64LIT(0x1b710b35131c471b),
-	W64LIT(0x28db77f523047d84), W64LIT(0x32caab7b40c72493),
-	W64LIT(0x3c9ebe0a15c9bebc), W64LIT(0x431d67c49c100d4c),
-	W64LIT(0x4cc5d4becb3e42b6), W64LIT(0x597f299cfc657e2a),
-	W64LIT(0x5fcb6fab3ad6faec), W64LIT(0x6c44198c4a475817)
-};
-
-void SHA384::Init()
-{
-	m_digest[0] = W64LIT(0xcbbb9d5dc1059ed8);
-	m_digest[1] = W64LIT(0x629a292a367cd507);
-	m_digest[2] = W64LIT(0x9159015a3070dd17);
-	m_digest[3] = W64LIT(0x152fecd8f70e5939);
-	m_digest[4] = W64LIT(0x67332667ffc00b31);
-	m_digest[5] = W64LIT(0x8eb44a8768581511);
-	m_digest[6] = W64LIT(0xdb0c2e0d64f98fa7);
-	m_digest[7] = W64LIT(0x47b5481dbefa4fa4);
-}
-
-#endif
-
-NAMESPACE_END
+// sha.cpp - modified by Wei Dai from Steve Reid's public domain sha1.c
+
+// Steve Reid implemented SHA-1. Wei Dai implemented SHA-2.
+// Both are in the public domain.
+
+// use "cl /EP /P /DCRYPTOPP_GENERATE_X64_MASM sha.cpp" to generate MASM code
+
+#include "pch.h"
+
+#ifndef CRYPTOPP_IMPORTS
+#ifndef CRYPTOPP_GENERATE_X64_MASM
+
+#include "sha.h"
+#include "misc.h"
+#include "cpu.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+// start of Steve Reid's code
+
+#define blk0(i) (W[i] = data[i])
+#define blk1(i) (W[i&15] = rotlFixed(W[(i+13)&15]^W[(i+8)&15]^W[(i+2)&15]^W[i&15],1))
+
+void SHA1::InitState(HashWordType *state)
+{
+	state[0] = 0x67452301L;
+	state[1] = 0xEFCDAB89L;
+	state[2] = 0x98BADCFEL;
+	state[3] = 0x10325476L;
+	state[4] = 0xC3D2E1F0L;
+}
+
+#define f1(x,y,z) (z^(x&(y^z)))
+#define f2(x,y,z) (x^y^z)
+#define f3(x,y,z) ((x&y)|(z&(x|y)))
+#define f4(x,y,z) (x^y^z)
+
+/* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */
+#define R0(v,w,x,y,z,i) z+=f1(w,x,y)+blk0(i)+0x5A827999+rotlFixed(v,5);w=rotlFixed(w,30);
+#define R1(v,w,x,y,z,i) z+=f1(w,x,y)+blk1(i)+0x5A827999+rotlFixed(v,5);w=rotlFixed(w,30);
+#define R2(v,w,x,y,z,i) z+=f2(w,x,y)+blk1(i)+0x6ED9EBA1+rotlFixed(v,5);w=rotlFixed(w,30);
+#define R3(v,w,x,y,z,i) z+=f3(w,x,y)+blk1(i)+0x8F1BBCDC+rotlFixed(v,5);w=rotlFixed(w,30);
+#define R4(v,w,x,y,z,i) z+=f4(w,x,y)+blk1(i)+0xCA62C1D6+rotlFixed(v,5);w=rotlFixed(w,30);
+
+void SHA1::Transform(word32 *state, const word32 *data)
+{
+	word32 W[16];
+    /* Copy context->state[] to working vars */
+    word32 a = state[0];
+    word32 b = state[1];
+    word32 c = state[2];
+    word32 d = state[3];
+    word32 e = state[4];
+    /* 4 rounds of 20 operations each. Loop unrolled. */
+    R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
+    R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
+    R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);
+    R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);
+    R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
+    R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);
+    R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);
+    R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
+    R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
+    R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);
+    R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);
+    R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
+    R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
+    R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
+    R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
+    R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
+    R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);
+    R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
+    R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
+    R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);
+    /* Add the working vars back into context.state[] */
+    state[0] += a;
+    state[1] += b;
+    state[2] += c;
+    state[3] += d;
+    state[4] += e;
+}
+
+// end of Steve Reid's code
+
+// *************************************************************
+
+void SHA224::InitState(HashWordType *state)
+{
+	static const word32 s[8] = {0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4};
+	memcpy(state, s, sizeof(s));
+}
+
+void SHA256::InitState(HashWordType *state)
+{
+	static const word32 s[8] = {0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};
+	memcpy(state, s, sizeof(s));
+}
+
+#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE
+CRYPTOPP_ALIGN_DATA(16) extern const word32 SHA256_K[64] CRYPTOPP_SECTION_ALIGN16 = {
+#else
+extern const word32 SHA256_K[64] = {
+#endif
+	0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
+	0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
+	0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
+	0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
+	0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
+	0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
+	0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
+	0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
+	0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
+	0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
+	0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
+	0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
+	0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
+	0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
+	0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
+	0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
+};
+
+#endif // #ifndef CRYPTOPP_GENERATE_X64_MASM
+
+#if defined(CRYPTOPP_X86_ASM_AVAILABLE) || defined(CRYPTOPP_GENERATE_X64_MASM)
+
+#pragma warning(disable: 4731)	// frame pointer register 'ebp' modified by inline assembly code
+
+static void CRYPTOPP_FASTCALL X86_SHA256_HashBlocks(word32 *state, const word32 *data, size_t len
+#if defined(_MSC_VER) && (_MSC_VER == 1200)
+	, ...	// VC60 workaround: prevent VC 6 from inlining this function
+#endif
+	)
+{
+#if defined(_MSC_VER) && (_MSC_VER == 1200)
+	AS2(mov ecx, [state])
+	AS2(mov edx, [data])
+#endif
+
+	#define LOCALS_SIZE	8*4 + 16*4 + 4*WORD_SZ
+	#define H(i)		[BASE+ASM_MOD(1024+7-(i),8)*4]
+	#define G(i)		H(i+1)
+	#define F(i)		H(i+2)
+	#define E(i)		H(i+3)
+	#define D(i)		H(i+4)
+	#define C(i)		H(i+5)
+	#define B(i)		H(i+6)
+	#define A(i)		H(i+7)
+	#define Wt(i)		BASE+8*4+ASM_MOD(1024+15-(i),16)*4
+	#define Wt_2(i)		Wt((i)-2)
+	#define Wt_15(i)	Wt((i)-15)
+	#define Wt_7(i)		Wt((i)-7)
+	#define K_END		[BASE+8*4+16*4+0*WORD_SZ]
+	#define STATE_SAVE	[BASE+8*4+16*4+1*WORD_SZ]
+	#define DATA_SAVE	[BASE+8*4+16*4+2*WORD_SZ]
+	#define DATA_END	[BASE+8*4+16*4+3*WORD_SZ]
+	#define Kt(i)		WORD_REG(si)+(i)*4
+#if CRYPTOPP_BOOL_X86
+	#define BASE		esp+4
+#elif defined(__GNUC__)
+	#define BASE		r8
+#else
+	#define BASE		rsp
+#endif
+
+#define RA0(i, edx, edi)		\
+	AS2(	add edx, [Kt(i)]	)\
+	AS2(	add edx, [Wt(i)]	)\
+	AS2(	add edx, H(i)		)\
+
+#define RA1(i, edx, edi)
+
+#define RB0(i, edx, edi)
+
+#define RB1(i, edx, edi)	\
+	AS2(	mov AS_REG_7d, [Wt_2(i)]	)\
+	AS2(	mov edi, [Wt_15(i)])\
+	AS2(	mov ebx, AS_REG_7d	)\
+	AS2(	shr AS_REG_7d, 10		)\
+	AS2(	ror ebx, 17		)\
+	AS2(	xor AS_REG_7d, ebx	)\
+	AS2(	ror ebx, 2		)\
+	AS2(	xor ebx, AS_REG_7d	)/* s1(W_t-2) */\
+	AS2(	add ebx, [Wt_7(i)])\
+	AS2(	mov AS_REG_7d, edi	)\
+	AS2(	shr AS_REG_7d, 3		)\
+	AS2(	ror edi, 7		)\
+	AS2(	add ebx, [Wt(i)])/* s1(W_t-2) + W_t-7 + W_t-16 */\
+	AS2(	xor AS_REG_7d, edi	)\
+	AS2(	add edx, [Kt(i)])\
+	AS2(	ror edi, 11		)\
+	AS2(	add edx, H(i)	)\
+	AS2(	xor AS_REG_7d, edi	)/* s0(W_t-15) */\
+	AS2(	add AS_REG_7d, ebx	)/* W_t = s1(W_t-2) + W_t-7 + s0(W_t-15) W_t-16*/\
+	AS2(	mov [Wt(i)], AS_REG_7d)\
+	AS2(	add edx, AS_REG_7d	)\
+
+#define ROUND(i, r, eax, ecx, edi, edx)\
+	/* in: edi = E	*/\
+	/* unused: eax, ecx, temp: ebx, AS_REG_7d, out: edx = T1 */\
+	AS2(	mov edx, F(i)	)\
+	AS2(	xor edx, G(i)	)\
+	AS2(	and edx, edi	)\
+	AS2(	xor edx, G(i)	)/* Ch(E,F,G) = (G^(E&(F^G))) */\
+	AS2(	mov AS_REG_7d, edi	)\
+	AS2(	ror edi, 6		)\
+	AS2(	ror AS_REG_7d, 25		)\
+	RA##r(i, edx, edi		)/* H + Wt + Kt + Ch(E,F,G) */\
+	AS2(	xor AS_REG_7d, edi	)\
+	AS2(	ror edi, 5		)\
+	AS2(	xor AS_REG_7d, edi	)/* S1(E) */\
+	AS2(	add edx, AS_REG_7d	)/* T1 = S1(E) + Ch(E,F,G) + H + Wt + Kt */\
+	RB##r(i, edx, edi		)/* H + Wt + Kt + Ch(E,F,G) */\
+	/* in: ecx = A, eax = B^C, edx = T1 */\
+	/* unused: edx, temp: ebx, AS_REG_7d, out: eax = A, ecx = B^C, edx = E */\
+	AS2(	mov ebx, ecx	)\
+	AS2(	xor ecx, B(i)	)/* A^B */\
+	AS2(	and eax, ecx	)\
+	AS2(	xor eax, B(i)	)/* Maj(A,B,C) = B^((A^B)&(B^C) */\
+	AS2(	mov AS_REG_7d, ebx	)\
+	AS2(	ror ebx, 2		)\
+	AS2(	add eax, edx	)/* T1 + Maj(A,B,C) */\
+	AS2(	add edx, D(i)	)\
+	AS2(	mov D(i), edx	)\
+	AS2(	ror AS_REG_7d, 22		)\
+	AS2(	xor AS_REG_7d, ebx	)\
+	AS2(	ror ebx, 11		)\
+	AS2(	xor AS_REG_7d, ebx	)\
+	AS2(	add eax, AS_REG_7d	)/* T1 + S0(A) + Maj(A,B,C) */\
+	AS2(	mov H(i), eax	)\
+
+#define SWAP_COPY(i)		\
+	AS2(	mov		WORD_REG(bx), [WORD_REG(dx)+i*WORD_SZ])\
+	AS1(	bswap	WORD_REG(bx))\
+	AS2(	mov		[Wt(i*(1+CRYPTOPP_BOOL_X64)+CRYPTOPP_BOOL_X64)], WORD_REG(bx))
+
+#if defined(__GNUC__)
+	#if CRYPTOPP_BOOL_X64
+		FixedSizeAlignedSecBlock<byte, LOCALS_SIZE> workspace;
+	#endif
+	__asm__ __volatile__
+	(
+	#if CRYPTOPP_BOOL_X64
+		"lea %4, %%r8;"
+	#endif
+	".intel_syntax noprefix;"
+#elif defined(CRYPTOPP_GENERATE_X64_MASM)
+		ALIGN   8
+	X86_SHA256_HashBlocks	PROC FRAME
+		rex_push_reg rsi
+		push_reg rdi
+		push_reg rbx
+		push_reg rbp
+		alloc_stack(LOCALS_SIZE+8)
+		.endprolog
+		mov rdi, r8
+		lea rsi, [?SHA256_K@CryptoPP@@3QBIB + 48*4]
+#endif
+
+#if CRYPTOPP_BOOL_X86
+	#ifndef __GNUC__
+		AS2(	mov		edi, [len])
+		AS2(	lea		WORD_REG(si), [SHA256_K+48*4])
+	#endif
+	#if !defined(_MSC_VER) || (_MSC_VER < 1400)
+		AS_PUSH_IF86(bx)
+	#endif
+
+	AS_PUSH_IF86(bp)
+	AS2(	mov		ebx, esp)
+	AS2(	and		esp, -16)
+	AS2(	sub		WORD_REG(sp), LOCALS_SIZE)
+	AS_PUSH_IF86(bx)
+#endif
+	AS2(	mov		STATE_SAVE, WORD_REG(cx))
+	AS2(	mov		DATA_SAVE, WORD_REG(dx))
+	AS2(	lea		WORD_REG(ax), [WORD_REG(di) + WORD_REG(dx)])
+	AS2(	mov		DATA_END, WORD_REG(ax))
+	AS2(	mov		K_END, WORD_REG(si))
+
+#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE
+#if CRYPTOPP_BOOL_X86
+	AS2(	test	edi, 1)
+	ASJ(	jnz,	2, f)
+	AS1(	dec		DWORD PTR K_END)
+#endif
+	AS2(	movdqa	xmm0, XMMWORD_PTR [WORD_REG(cx)+0*16])
+	AS2(	movdqa	xmm1, XMMWORD_PTR [WORD_REG(cx)+1*16])
+#endif
+
+#if CRYPTOPP_BOOL_X86
+#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE
+	ASJ(	jmp,	0, f)
+#endif
+	ASL(2)	// non-SSE2
+	AS2(	mov		esi, ecx)
+	AS2(	lea		edi, A(0))
+	AS2(	mov		ecx, 8)
+	AS1(	rep movsd)
+	AS2(	mov		esi, K_END)
+	ASJ(	jmp,	3, f)
+#endif
+
+#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE
+	ASL(0)
+	AS2(	movdqa	E(0), xmm1)
+	AS2(	movdqa	A(0), xmm0)
+#endif
+#if CRYPTOPP_BOOL_X86
+	ASL(3)
+#endif
+	AS2(	sub		WORD_REG(si), 48*4)
+	SWAP_COPY(0)	SWAP_COPY(1)	SWAP_COPY(2)	SWAP_COPY(3)
+	SWAP_COPY(4)	SWAP_COPY(5)	SWAP_COPY(6)	SWAP_COPY(7)
+#if CRYPTOPP_BOOL_X86
+	SWAP_COPY(8)	SWAP_COPY(9)	SWAP_COPY(10)	SWAP_COPY(11)
+	SWAP_COPY(12)	SWAP_COPY(13)	SWAP_COPY(14)	SWAP_COPY(15)
+#endif
+	AS2(	mov		edi, E(0))	// E
+	AS2(	mov		eax, B(0))	// B
+	AS2(	xor		eax, C(0))	// B^C
+	AS2(	mov		ecx, A(0))	// A
+
+	ROUND(0, 0, eax, ecx, edi, edx)
+	ROUND(1, 0, ecx, eax, edx, edi)
+	ROUND(2, 0, eax, ecx, edi, edx)
+	ROUND(3, 0, ecx, eax, edx, edi)
+	ROUND(4, 0, eax, ecx, edi, edx)
+	ROUND(5, 0, ecx, eax, edx, edi)
+	ROUND(6, 0, eax, ecx, edi, edx)
+	ROUND(7, 0, ecx, eax, edx, edi)
+	ROUND(8, 0, eax, ecx, edi, edx)
+	ROUND(9, 0, ecx, eax, edx, edi)
+	ROUND(10, 0, eax, ecx, edi, edx)
+	ROUND(11, 0, ecx, eax, edx, edi)
+	ROUND(12, 0, eax, ecx, edi, edx)
+	ROUND(13, 0, ecx, eax, edx, edi)
+	ROUND(14, 0, eax, ecx, edi, edx)
+	ROUND(15, 0, ecx, eax, edx, edi)
+
+	ASL(1)
+	AS2(add WORD_REG(si), 4*16)
+	ROUND(0, 1, eax, ecx, edi, edx)
+	ROUND(1, 1, ecx, eax, edx, edi)
+	ROUND(2, 1, eax, ecx, edi, edx)
+	ROUND(3, 1, ecx, eax, edx, edi)
+	ROUND(4, 1, eax, ecx, edi, edx)
+	ROUND(5, 1, ecx, eax, edx, edi)
+	ROUND(6, 1, eax, ecx, edi, edx)
+	ROUND(7, 1, ecx, eax, edx, edi)
+	ROUND(8, 1, eax, ecx, edi, edx)
+	ROUND(9, 1, ecx, eax, edx, edi)
+	ROUND(10, 1, eax, ecx, edi, edx)
+	ROUND(11, 1, ecx, eax, edx, edi)
+	ROUND(12, 1, eax, ecx, edi, edx)
+	ROUND(13, 1, ecx, eax, edx, edi)
+	ROUND(14, 1, eax, ecx, edi, edx)
+	ROUND(15, 1, ecx, eax, edx, edi)
+	AS2(	cmp		WORD_REG(si), K_END)
+	ASJ(	jb,		1, b)
+
+	AS2(	mov		WORD_REG(dx), DATA_SAVE)
+	AS2(	add		WORD_REG(dx), 64)
+	AS2(	mov		AS_REG_7, STATE_SAVE)
+	AS2(	mov		DATA_SAVE, WORD_REG(dx))
+
+#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE
+#if CRYPTOPP_BOOL_X86
+	AS2(	test	DWORD PTR K_END, 1)
+	ASJ(	jz,		4, f)
+#endif
+	AS2(	movdqa	xmm1, XMMWORD_PTR [AS_REG_7+1*16])
+	AS2(	movdqa	xmm0, XMMWORD_PTR [AS_REG_7+0*16])
+	AS2(	paddd	xmm1, E(0))
+	AS2(	paddd	xmm0, A(0))
+	AS2(	movdqa	[AS_REG_7+1*16], xmm1)
+	AS2(	movdqa	[AS_REG_7+0*16], xmm0)
+	AS2(	cmp		WORD_REG(dx), DATA_END)
+	ASJ(	jb,		0, b)
+#endif
+
+#if CRYPTOPP_BOOL_X86
+#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE
+	ASJ(	jmp,	5, f)
+	ASL(4)	// non-SSE2
+#endif
+	AS2(	add		[AS_REG_7+0*4], ecx)	// A
+	AS2(	add		[AS_REG_7+4*4], edi)	// E
+	AS2(	mov		eax, B(0))
+	AS2(	mov		ebx, C(0))
+	AS2(	mov		ecx, D(0))
+	AS2(	add		[AS_REG_7+1*4], eax)
+	AS2(	add		[AS_REG_7+2*4], ebx)
+	AS2(	add		[AS_REG_7+3*4], ecx)
+	AS2(	mov		eax, F(0))
+	AS2(	mov		ebx, G(0))
+	AS2(	mov		ecx, H(0))
+	AS2(	add		[AS_REG_7+5*4], eax)
+	AS2(	add		[AS_REG_7+6*4], ebx)
+	AS2(	add		[AS_REG_7+7*4], ecx)
+	AS2(	mov		ecx, AS_REG_7d)
+	AS2(	cmp		WORD_REG(dx), DATA_END)
+	ASJ(	jb,		2, b)
+#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE
+	ASL(5)
+#endif
+#endif
+
+	AS_POP_IF86(sp)
+	AS_POP_IF86(bp)
+	#if !defined(_MSC_VER) || (_MSC_VER < 1400)
+		AS_POP_IF86(bx)
+	#endif
+
+#ifdef CRYPTOPP_GENERATE_X64_MASM
+	add		rsp, LOCALS_SIZE+8
+	pop		rbp
+	pop		rbx
+	pop		rdi
+	pop		rsi
+	ret
+	X86_SHA256_HashBlocks ENDP
+#endif
+
+#ifdef __GNUC__
+	".att_syntax prefix;"
+	: 
+	: "c" (state), "d" (data), "S" (SHA256_K+48), "D" (len)
+	#if CRYPTOPP_BOOL_X64
+		, "m" (workspace[0])
+	#endif
+	: "memory", "cc", "%eax"
+	#if CRYPTOPP_BOOL_X64
+		, "%rbx", "%r8", "%r10"
+	#endif
+	);
+#endif
+}
+
+#endif	// #if defined(CRYPTOPP_X86_ASM_AVAILABLE) || defined(CRYPTOPP_GENERATE_X64_MASM)
+
+#ifndef CRYPTOPP_GENERATE_X64_MASM
+
+#ifdef CRYPTOPP_X64_MASM_AVAILABLE
+extern "C" {
+void CRYPTOPP_FASTCALL X86_SHA256_HashBlocks(word32 *state, const word32 *data, size_t len);
+}
+#endif
+
+#if defined(CRYPTOPP_X86_ASM_AVAILABLE) || defined(CRYPTOPP_X64_MASM_AVAILABLE)
+
+size_t SHA256::HashMultipleBlocks(const word32 *input, size_t length)
+{
+	X86_SHA256_HashBlocks(m_state, input, (length&(size_t(0)-BLOCKSIZE)) - !HasSSE2());
+	return length % BLOCKSIZE;
+}
+
+size_t SHA224::HashMultipleBlocks(const word32 *input, size_t length)
+{
+	X86_SHA256_HashBlocks(m_state, input, (length&(size_t(0)-BLOCKSIZE)) - !HasSSE2());
+	return length % BLOCKSIZE;
+}
+
+#endif
+
+#define blk2(i) (W[i&15]+=s1(W[(i-2)&15])+W[(i-7)&15]+s0(W[(i-15)&15]))
+
+#define Ch(x,y,z) (z^(x&(y^z)))
+#define Maj(x,y,z) (y^((x^y)&(y^z)))
+
+#define a(i) T[(0-i)&7]
+#define b(i) T[(1-i)&7]
+#define c(i) T[(2-i)&7]
+#define d(i) T[(3-i)&7]
+#define e(i) T[(4-i)&7]
+#define f(i) T[(5-i)&7]
+#define g(i) T[(6-i)&7]
+#define h(i) T[(7-i)&7]
+
+#define R(i) h(i)+=S1(e(i))+Ch(e(i),f(i),g(i))+SHA256_K[i+j]+(j?blk2(i):blk0(i));\
+	d(i)+=h(i);h(i)+=S0(a(i))+Maj(a(i),b(i),c(i))
+
+// for SHA256
+#define S0(x) (rotrFixed(x,2)^rotrFixed(x,13)^rotrFixed(x,22))
+#define S1(x) (rotrFixed(x,6)^rotrFixed(x,11)^rotrFixed(x,25))
+#define s0(x) (rotrFixed(x,7)^rotrFixed(x,18)^(x>>3))
+#define s1(x) (rotrFixed(x,17)^rotrFixed(x,19)^(x>>10))
+
+void SHA256::Transform(word32 *state, const word32 *data)
+{
+	word32 W[16];
+#if defined(CRYPTOPP_X86_ASM_AVAILABLE) || defined(CRYPTOPP_X64_MASM_AVAILABLE)
+	// this byte reverse is a waste of time, but this function is only called by MDC
+	ByteReverse(W, data, BLOCKSIZE);
+	X86_SHA256_HashBlocks(state, W, BLOCKSIZE - !HasSSE2());
+#else
+	word32 T[8];
+    /* Copy context->state[] to working vars */
+	memcpy(T, state, sizeof(T));
+    /* 64 operations, partially loop unrolled */
+	for (unsigned int j=0; j<64; j+=16)
+	{
+		R( 0); R( 1); R( 2); R( 3);
+		R( 4); R( 5); R( 6); R( 7);
+		R( 8); R( 9); R(10); R(11);
+		R(12); R(13); R(14); R(15);
+	}
+    /* Add the working vars back into context.state[] */
+    state[0] += a(0);
+    state[1] += b(0);
+    state[2] += c(0);
+    state[3] += d(0);
+    state[4] += e(0);
+    state[5] += f(0);
+    state[6] += g(0);
+    state[7] += h(0);
+#endif
+}
+
+/* 
+// smaller but slower
+void SHA256::Transform(word32 *state, const word32 *data)
+{
+	word32 T[20];
+	word32 W[32];
+	unsigned int i = 0, j = 0;
+	word32 *t = T+8;
+
+	memcpy(t, state, 8*4);
+	word32 e = t[4], a = t[0];
+
+	do 
+	{
+		word32 w = data[j];
+		W[j] = w;
+		w += SHA256_K[j];
+		w += t[7];
+		w += S1(e);
+		w += Ch(e, t[5], t[6]);
+		e = t[3] + w;
+		t[3] = t[3+8] = e;
+		w += S0(t[0]);
+		a = w + Maj(a, t[1], t[2]);
+		t[-1] = t[7] = a;
+		--t;
+		++j;
+		if (j%8 == 0)
+			t += 8;
+	} while (j<16);
+
+	do
+	{
+		i = j&0xf;
+		word32 w = s1(W[i+16-2]) + s0(W[i+16-15]) + W[i] + W[i+16-7];
+		W[i+16] = W[i] = w;
+		w += SHA256_K[j];
+		w += t[7];
+		w += S1(e);
+		w += Ch(e, t[5], t[6]);
+		e = t[3] + w;
+		t[3] = t[3+8] = e;
+		w += S0(t[0]);
+		a = w + Maj(a, t[1], t[2]);
+		t[-1] = t[7] = a;
+
+		w = s1(W[(i+1)+16-2]) + s0(W[(i+1)+16-15]) + W[(i+1)] + W[(i+1)+16-7];
+		W[(i+1)+16] = W[(i+1)] = w;
+		w += SHA256_K[j+1];
+		w += (t-1)[7];
+		w += S1(e);
+		w += Ch(e, (t-1)[5], (t-1)[6]);
+		e = (t-1)[3] + w;
+		(t-1)[3] = (t-1)[3+8] = e;
+		w += S0((t-1)[0]);
+		a = w + Maj(a, (t-1)[1], (t-1)[2]);
+		(t-1)[-1] = (t-1)[7] = a;
+
+		t-=2;
+		j+=2;
+		if (j%8 == 0)
+			t += 8;
+	} while (j<64);
+
+    state[0] += a;
+    state[1] += t[1];
+    state[2] += t[2];
+    state[3] += t[3];
+    state[4] += e;
+    state[5] += t[5];
+    state[6] += t[6];
+    state[7] += t[7];
+}
+*/
+
+#undef S0
+#undef S1
+#undef s0
+#undef s1
+#undef R
+
+// *************************************************************
+
+void SHA384::InitState(HashWordType *state)
+{
+	static const word64 s[8] = {
+		W64LIT(0xcbbb9d5dc1059ed8), W64LIT(0x629a292a367cd507),
+		W64LIT(0x9159015a3070dd17), W64LIT(0x152fecd8f70e5939),
+		W64LIT(0x67332667ffc00b31), W64LIT(0x8eb44a8768581511),
+		W64LIT(0xdb0c2e0d64f98fa7), W64LIT(0x47b5481dbefa4fa4)};
+	memcpy(state, s, sizeof(s));
+}
+
+void SHA512::InitState(HashWordType *state)
+{
+	static const word64 s[8] = {
+		W64LIT(0x6a09e667f3bcc908), W64LIT(0xbb67ae8584caa73b),
+		W64LIT(0x3c6ef372fe94f82b), W64LIT(0xa54ff53a5f1d36f1),
+		W64LIT(0x510e527fade682d1), W64LIT(0x9b05688c2b3e6c1f),
+		W64LIT(0x1f83d9abfb41bd6b), W64LIT(0x5be0cd19137e2179)};
+	memcpy(state, s, sizeof(s));
+}
+
+#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE && CRYPTOPP_BOOL_X86
+CRYPTOPP_ALIGN_DATA(16) static const word64 SHA512_K[80] CRYPTOPP_SECTION_ALIGN16 = {
+#else
+static const word64 SHA512_K[80] = {
+#endif
+	W64LIT(0x428a2f98d728ae22), W64LIT(0x7137449123ef65cd),
+	W64LIT(0xb5c0fbcfec4d3b2f), W64LIT(0xe9b5dba58189dbbc),
+	W64LIT(0x3956c25bf348b538), W64LIT(0x59f111f1b605d019),
+	W64LIT(0x923f82a4af194f9b), W64LIT(0xab1c5ed5da6d8118),
+	W64LIT(0xd807aa98a3030242), W64LIT(0x12835b0145706fbe),
+	W64LIT(0x243185be4ee4b28c), W64LIT(0x550c7dc3d5ffb4e2),
+	W64LIT(0x72be5d74f27b896f), W64LIT(0x80deb1fe3b1696b1),
+	W64LIT(0x9bdc06a725c71235), W64LIT(0xc19bf174cf692694),
+	W64LIT(0xe49b69c19ef14ad2), W64LIT(0xefbe4786384f25e3),
+	W64LIT(0x0fc19dc68b8cd5b5), W64LIT(0x240ca1cc77ac9c65),
+	W64LIT(0x2de92c6f592b0275), W64LIT(0x4a7484aa6ea6e483),
+	W64LIT(0x5cb0a9dcbd41fbd4), W64LIT(0x76f988da831153b5),
+	W64LIT(0x983e5152ee66dfab), W64LIT(0xa831c66d2db43210),
+	W64LIT(0xb00327c898fb213f), W64LIT(0xbf597fc7beef0ee4),
+	W64LIT(0xc6e00bf33da88fc2), W64LIT(0xd5a79147930aa725),
+	W64LIT(0x06ca6351e003826f), W64LIT(0x142929670a0e6e70),
+	W64LIT(0x27b70a8546d22ffc), W64LIT(0x2e1b21385c26c926),
+	W64LIT(0x4d2c6dfc5ac42aed), W64LIT(0x53380d139d95b3df),
+	W64LIT(0x650a73548baf63de), W64LIT(0x766a0abb3c77b2a8),
+	W64LIT(0x81c2c92e47edaee6), W64LIT(0x92722c851482353b),
+	W64LIT(0xa2bfe8a14cf10364), W64LIT(0xa81a664bbc423001),
+	W64LIT(0xc24b8b70d0f89791), W64LIT(0xc76c51a30654be30),
+	W64LIT(0xd192e819d6ef5218), W64LIT(0xd69906245565a910),
+	W64LIT(0xf40e35855771202a), W64LIT(0x106aa07032bbd1b8),
+	W64LIT(0x19a4c116b8d2d0c8), W64LIT(0x1e376c085141ab53),
+	W64LIT(0x2748774cdf8eeb99), W64LIT(0x34b0bcb5e19b48a8),
+	W64LIT(0x391c0cb3c5c95a63), W64LIT(0x4ed8aa4ae3418acb),
+	W64LIT(0x5b9cca4f7763e373), W64LIT(0x682e6ff3d6b2b8a3),
+	W64LIT(0x748f82ee5defb2fc), W64LIT(0x78a5636f43172f60),
+	W64LIT(0x84c87814a1f0ab72), W64LIT(0x8cc702081a6439ec),
+	W64LIT(0x90befffa23631e28), W64LIT(0xa4506cebde82bde9),
+	W64LIT(0xbef9a3f7b2c67915), W64LIT(0xc67178f2e372532b),
+	W64LIT(0xca273eceea26619c), W64LIT(0xd186b8c721c0c207),
+	W64LIT(0xeada7dd6cde0eb1e), W64LIT(0xf57d4f7fee6ed178),
+	W64LIT(0x06f067aa72176fba), W64LIT(0x0a637dc5a2c898a6),
+	W64LIT(0x113f9804bef90dae), W64LIT(0x1b710b35131c471b),
+	W64LIT(0x28db77f523047d84), W64LIT(0x32caab7b40c72493),
+	W64LIT(0x3c9ebe0a15c9bebc), W64LIT(0x431d67c49c100d4c),
+	W64LIT(0x4cc5d4becb3e42b6), W64LIT(0x597f299cfc657e2a),
+	W64LIT(0x5fcb6fab3ad6faec), W64LIT(0x6c44198c4a475817)
+};
+
+#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE && CRYPTOPP_BOOL_X86
+// put assembly version in separate function, otherwise MSVC 2005 SP1 doesn't generate correct code for the non-assembly version
+CRYPTOPP_NAKED static void CRYPTOPP_FASTCALL SHA512_SSE2_Transform(word64 *state, const word64 *data)
+{
+#ifdef __GNUC__
+	__asm__ __volatile__
+	(
+		".intel_syntax noprefix;"
+	AS1(	push	ebx)
+	AS2(	mov		ebx, eax)
+#else
+	AS1(	push	ebx)
+	AS1(	push	esi)
+	AS1(	push	edi)
+	AS2(	lea		ebx, SHA512_K)
+#endif
+
+	AS2(	mov		eax, esp)
+	AS2(	and		esp, 0xfffffff0)
+	AS2(	sub		esp, 27*16)				// 17*16 for expanded data, 20*8 for state
+	AS1(	push	eax)
+	AS2(	xor		eax, eax)
+	AS2(	lea		edi, [esp+4+8*8])		// start at middle of state buffer. will decrement pointer each round to avoid copying
+	AS2(	lea		esi, [esp+4+20*8+8])	// 16-byte alignment, then add 8
+
+	AS2(	movdqa	xmm0, [ecx+0*16])
+	AS2(	movdq2q	mm4, xmm0)
+	AS2(	movdqa	[edi+0*16], xmm0)
+	AS2(	movdqa	xmm0, [ecx+1*16])
+	AS2(	movdqa	[edi+1*16], xmm0)
+	AS2(	movdqa	xmm0, [ecx+2*16])
+	AS2(	movdq2q	mm5, xmm0)
+	AS2(	movdqa	[edi+2*16], xmm0)
+	AS2(	movdqa	xmm0, [ecx+3*16])
+	AS2(	movdqa	[edi+3*16], xmm0)
+	ASJ(	jmp,	0, f)
+
+#define SSE2_S0_S1(r, a, b, c)	\
+	AS2(	movq	mm6, r)\
+	AS2(	psrlq	r, a)\
+	AS2(	movq	mm7, r)\
+	AS2(	psllq	mm6, 64-c)\
+	AS2(	pxor	mm7, mm6)\
+	AS2(	psrlq	r, b-a)\
+	AS2(	pxor	mm7, r)\
+	AS2(	psllq	mm6, c-b)\
+	AS2(	pxor	mm7, mm6)\
+	AS2(	psrlq	r, c-b)\
+	AS2(	pxor	r, mm7)\
+	AS2(	psllq	mm6, b-a)\
+	AS2(	pxor	r, mm6)
+
+#define SSE2_s0(r, a, b, c)	\
+	AS2(	movdqa	xmm6, r)\
+	AS2(	psrlq	r, a)\
+	AS2(	movdqa	xmm7, r)\
+	AS2(	psllq	xmm6, 64-c)\
+	AS2(	pxor	xmm7, xmm6)\
+	AS2(	psrlq	r, b-a)\
+	AS2(	pxor	xmm7, r)\
+	AS2(	psrlq	r, c-b)\
+	AS2(	pxor	r, xmm7)\
+	AS2(	psllq	xmm6, c-a)\
+	AS2(	pxor	r, xmm6)
+
+#define SSE2_s1(r, a, b, c)	\
+	AS2(	movdqa	xmm6, r)\
+	AS2(	psrlq	r, a)\
+	AS2(	movdqa	xmm7, r)\
+	AS2(	psllq	xmm6, 64-c)\
+	AS2(	pxor	xmm7, xmm6)\
+	AS2(	psrlq	r, b-a)\
+	AS2(	pxor	xmm7, r)\
+	AS2(	psllq	xmm6, c-b)\
+	AS2(	pxor	xmm7, xmm6)\
+	AS2(	psrlq	r, c-b)\
+	AS2(	pxor	r, xmm7)
+
+	ASL(SHA512_Round)
+	// k + w is in mm0, a is in mm4, e is in mm5
+	AS2(	paddq	mm0, [edi+7*8])		// h
+	AS2(	movq	mm2, [edi+5*8])		// f
+	AS2(	movq	mm3, [edi+6*8])		// g
+	AS2(	pxor	mm2, mm3)
+	AS2(	pand	mm2, mm5)
+	SSE2_S0_S1(mm5,14,18,41)
+	AS2(	pxor	mm2, mm3)
+	AS2(	paddq	mm0, mm2)			// h += Ch(e,f,g)
+	AS2(	paddq	mm5, mm0)			// h += S1(e)
+	AS2(	movq	mm2, [edi+1*8])		// b
+	AS2(	movq	mm1, mm2)
+	AS2(	por		mm2, mm4)
+	AS2(	pand	mm2, [edi+2*8])		// c
+	AS2(	pand	mm1, mm4)
+	AS2(	por		mm1, mm2)
+	AS2(	paddq	mm1, mm5)			// temp = h + Maj(a,b,c)
+	AS2(	paddq	mm5, [edi+3*8])		// e = d + h
+	AS2(	movq	[edi+3*8], mm5)
+	AS2(	movq	[edi+11*8], mm5)
+	SSE2_S0_S1(mm4,28,34,39)			// S0(a)
+	AS2(	paddq	mm4, mm1)			// a = temp + S0(a)
+	AS2(	movq	[edi-8], mm4)
+	AS2(	movq	[edi+7*8], mm4)
+	AS1(	ret)
+
+	// first 16 rounds
+	ASL(0)
+	AS2(	movq	mm0, [edx+eax*8])
+	AS2(	movq	[esi+eax*8], mm0)
+	AS2(	movq	[esi+eax*8+16*8], mm0)
+	AS2(	paddq	mm0, [ebx+eax*8])
+	ASC(	call,	SHA512_Round)
+	AS1(	inc		eax)
+	AS2(	sub		edi, 8)
+	AS2(	test	eax, 7)
+	ASJ(	jnz,	0, b)
+	AS2(	add		edi, 8*8)
+	AS2(	cmp		eax, 16)
+	ASJ(	jne,	0, b)
+
+	// rest of the rounds
+	AS2(	movdqu	xmm0, [esi+(16-2)*8])
+	ASL(1)
+	// data expansion, W[i-2] already in xmm0
+	AS2(	movdqu	xmm3, [esi])
+	AS2(	paddq	xmm3, [esi+(16-7)*8])
+	AS2(	movdqa	xmm2, [esi+(16-15)*8])
+	SSE2_s1(xmm0, 6, 19, 61)
+	AS2(	paddq	xmm0, xmm3)
+	SSE2_s0(xmm2, 1, 7, 8)
+	AS2(	paddq	xmm0, xmm2)
+	AS2(	movdq2q	mm0, xmm0)
+	AS2(	movhlps	xmm1, xmm0)
+	AS2(	paddq	mm0, [ebx+eax*8])
+	AS2(	movlps	[esi], xmm0)
+	AS2(	movlps	[esi+8], xmm1)
+	AS2(	movlps	[esi+8*16], xmm0)
+	AS2(	movlps	[esi+8*17], xmm1)
+	// 2 rounds
+	ASC(	call,	SHA512_Round)
+	AS2(	sub		edi, 8)
+	AS2(	movdq2q	mm0, xmm1)
+	AS2(	paddq	mm0, [ebx+eax*8+8])
+	ASC(	call,	SHA512_Round)
+	// update indices and loop
+	AS2(	add		esi, 16)
+	AS2(	add		eax, 2)
+	AS2(	sub		edi, 8)
+	AS2(	test	eax, 7)
+	ASJ(	jnz,	1, b)
+	// do housekeeping every 8 rounds
+	AS2(	mov		esi, 0xf)
+	AS2(	and		esi, eax)
+	AS2(	lea		esi, [esp+4+20*8+8+esi*8])
+	AS2(	add		edi, 8*8)
+	AS2(	cmp		eax, 80)
+	ASJ(	jne,	1, b)
+
+#define SSE2_CombineState(i)	\
+	AS2(	movdqa	xmm0, [edi+i*16])\
+	AS2(	paddq	xmm0, [ecx+i*16])\
+	AS2(	movdqa	[ecx+i*16], xmm0)
+
+	SSE2_CombineState(0)
+	SSE2_CombineState(1)
+	SSE2_CombineState(2)
+	SSE2_CombineState(3)
+
+	AS1(	pop		esp)
+	AS1(	emms)
+
+#if defined(__GNUC__)
+	AS1(	pop		ebx)
+	".att_syntax prefix;"
+		:
+		: "a" (SHA512_K), "c" (state), "d" (data)
+		: "%esi", "%edi", "memory", "cc"
+	);
+#else
+	AS1(	pop		edi)
+	AS1(	pop		esi)
+	AS1(	pop		ebx)
+	AS1(	ret)
+#endif
+}
+#endif	// #if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE
+
+void SHA512::Transform(word64 *state, const word64 *data)
+{
+#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE && CRYPTOPP_BOOL_X86
+	if (HasSSE2())
+	{
+		SHA512_SSE2_Transform(state, data);
+		return;
+	}
+#endif
+
+#define S0(x) (rotrFixed(x,28)^rotrFixed(x,34)^rotrFixed(x,39))
+#define S1(x) (rotrFixed(x,14)^rotrFixed(x,18)^rotrFixed(x,41))
+#define s0(x) (rotrFixed(x,1)^rotrFixed(x,8)^(x>>7))
+#define s1(x) (rotrFixed(x,19)^rotrFixed(x,61)^(x>>6))
+
+#define R(i) h(i)+=S1(e(i))+Ch(e(i),f(i),g(i))+SHA512_K[i+j]+(j?blk2(i):blk0(i));\
+	d(i)+=h(i);h(i)+=S0(a(i))+Maj(a(i),b(i),c(i))
+
+	word64 W[16];
+	word64 T[8];
+    /* Copy context->state[] to working vars */
+	memcpy(T, state, sizeof(T));
+    /* 80 operations, partially loop unrolled */
+	for (unsigned int j=0; j<80; j+=16)
+	{
+		R( 0); R( 1); R( 2); R( 3);
+		R( 4); R( 5); R( 6); R( 7);
+		R( 8); R( 9); R(10); R(11);
+		R(12); R(13); R(14); R(15);
+	}
+    /* Add the working vars back into context.state[] */
+    state[0] += a(0);
+    state[1] += b(0);
+    state[2] += c(0);
+    state[3] += d(0);
+    state[4] += e(0);
+    state[5] += f(0);
+    state[6] += g(0);
+    state[7] += h(0);
+}
+
+NAMESPACE_END
+
+#endif	// #ifndef CRYPTOPP_GENERATE_X64_MASM
+#endif	// #ifndef CRYPTOPP_IMPORTS
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/strciphr.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/strciphr.cpp
index 6b8b914a..53e00737 100644
--- a/SelfServiceCommon/Massai/cpp/Mcrypt/src/strciphr.cpp
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/strciphr.cpp
@@ -1,188 +1,252 @@
-// strciphr.cpp - written and placed in the public domain by Wei Dai
-
-//#include "pch.h"
-#include "strciphr.h"
-
-NAMESPACE_BEGIN(CryptoPP)
-
-template <class S>
-byte AdditiveCipherTemplate<S>::GenerateByte()
-{
-	PolicyInterface &policy = AccessPolicy();
-
-	if (m_leftOver == 0)
-	{
-		policy.WriteKeystream(m_buffer, policy.GetIterationsToBuffer());
-		m_leftOver = policy.GetBytesPerIteration();
-	}
-
-	return *(KeystreamBufferEnd()-m_leftOver--);
-}
-
-template <class S>
-inline void AdditiveCipherTemplate<S>::ProcessData(byte *outString, const byte *inString, unsigned int length)
-{
-	if (m_leftOver > 0)
-	{
-		unsigned int len = STDMIN(m_leftOver, length);
-		xorbuf(outString, inString, KeystreamBufferEnd()-m_leftOver, len);
-		length -= len;
-		m_leftOver -= len;
-		inString += len;
-		outString += len;
-	}
-
-	if (!length)
-		return;
-
-	assert(m_leftOver == 0);
-
-	PolicyInterface &policy = AccessPolicy();
-	unsigned int bytesPerIteration = policy.GetBytesPerIteration();
-	unsigned int alignment = policy.GetAlignment();
-
-	if (policy.CanOperateKeystream() && length >= bytesPerIteration && IsAlignedOn(outString, alignment))
-	{
-		if (IsAlignedOn(inString, alignment))
-			policy.OperateKeystream(XOR_KEYSTREAM, outString, inString, length / bytesPerIteration);
-		else
-		{
-			memcpy(outString, inString, length);
-			policy.OperateKeystream(XOR_KEYSTREAM_INPLACE, outString, outString, length / bytesPerIteration);
-		}
-		inString += length - length % bytesPerIteration;
-		outString += length - length % bytesPerIteration;
-		length %= bytesPerIteration;
-
-		if (!length)
-			return;
-	}
-
-	unsigned int bufferByteSize = GetBufferByteSize(policy);
-	unsigned int bufferIterations = policy.GetIterationsToBuffer();
-
-	while (length >= bufferByteSize)
-	{
-		policy.WriteKeystream(m_buffer, bufferIterations);
-		xorbuf(outString, inString, KeystreamBufferBegin(), bufferByteSize);
-		length -= bufferByteSize;
-		inString += bufferByteSize;
-		outString += bufferByteSize;
-	}
-
-	if (length > 0)
-	{
-		policy.WriteKeystream(m_buffer, bufferIterations);
-		xorbuf(outString, inString, KeystreamBufferBegin(), length);
-		m_leftOver = bytesPerIteration - length;
-	}
-}
-
-template <class S>
-void AdditiveCipherTemplate<S>::Resynchronize(const byte *iv)
-{
-	PolicyInterface &policy = AccessPolicy();
-	m_leftOver = 0;
-	m_buffer.New(GetBufferByteSize(policy));
-	policy.CipherResynchronize(m_buffer, iv);
-}
-
-template <class BASE>
-void AdditiveCipherTemplate<BASE>::Seek(dword position)
-{
-	PolicyInterface &policy = AccessPolicy();
-	unsigned int bytesPerIteration = policy.GetBytesPerIteration();
-
-	policy.SeekToIteration(position / bytesPerIteration);
-	position %= bytesPerIteration;
-
-	if (position > 0)
-	{
-		policy.WriteKeystream(m_buffer, 1);
-		m_leftOver = bytesPerIteration - (unsigned int)position;
-	}
-	else
-		m_leftOver = 0;
-}
-
-template <class BASE>
-void CFB_CipherTemplate<BASE>::Resynchronize(const byte *iv)
-{
-	PolicyInterface &policy = AccessPolicy();
-	policy.CipherResynchronize(iv);
-	m_leftOver = policy.GetBytesPerIteration();
-}
-
-template <class BASE>
-void CFB_CipherTemplate<BASE>::ProcessData(byte *outString, const byte *inString, unsigned int length)
-{
-	PolicyInterface &policy = AccessPolicy();
-	unsigned int bytesPerIteration = policy.GetBytesPerIteration();
-	unsigned int alignment = policy.GetAlignment();
-	byte *reg = policy.GetRegisterBegin();
-
-	if (m_leftOver)
-	{
-		unsigned int len = STDMIN(m_leftOver, length);
-		CombineMessageAndShiftRegister(outString, reg + bytesPerIteration - m_leftOver, inString, len);
-		m_leftOver -= len;
-		length -= len;
-		inString += len;
-		outString += len;
-	}
-
-	if (!length)
-		return;
-
-	assert(m_leftOver == 0);
-
-	if (policy.CanIterate() && length >= bytesPerIteration && IsAlignedOn(outString, alignment))
-	{
-		if (IsAlignedOn(inString, alignment))
-			policy.Iterate(outString, inString, GetCipherDir(*this), length / bytesPerIteration);
-		else
-		{
-			memcpy(outString, inString, length);
-			policy.Iterate(outString, outString, GetCipherDir(*this), length / bytesPerIteration);
-		}
-		inString += length - length % bytesPerIteration;
-		outString += length - length % bytesPerIteration;
-		length %= bytesPerIteration;
-	}
-
-	while (length >= bytesPerIteration)
-	{
-		policy.TransformRegister();
-		CombineMessageAndShiftRegister(outString, reg, inString, bytesPerIteration);
-		length -= bytesPerIteration;
-		inString += bytesPerIteration;
-		outString += bytesPerIteration;
-	}
-
-	if (length > 0)
-	{
-		policy.TransformRegister();
-		CombineMessageAndShiftRegister(outString, reg, inString, length);
-		m_leftOver = bytesPerIteration - length;
-	}
-}
-
-template <class BASE>
-void CFB_EncryptionTemplate<BASE>::CombineMessageAndShiftRegister(byte *output, byte *reg, const byte *message, unsigned int length)
-{
-	xorbuf(reg, message, length);
-	memcpy(output, reg, length);
-}
-
-template <class BASE>
-void CFB_DecryptionTemplate<BASE>::CombineMessageAndShiftRegister(byte *output, byte *reg, const byte *message, unsigned int length)
-{
-	for (unsigned int i=0; i<length; i++)
-	{
-		byte b = message[i];
-		output[i] = reg[i] ^ b;
-		reg[i] = b;
-	}
-}
-
-NAMESPACE_END
+// strciphr.cpp - written and placed in the public domain by Wei Dai
+
+#include "pch.h"
+
+#ifndef CRYPTOPP_IMPORTS
+
+#include "strciphr.h"
+
+NAMESPACE_BEGIN(CryptoPP)
+
+template <class S>
+void AdditiveCipherTemplate<S>::UncheckedSetKey(const byte *key, unsigned int length, const NameValuePairs &params)
+{
+	PolicyInterface &policy = this->AccessPolicy();
+	policy.CipherSetKey(params, key, length);
+	m_leftOver = 0;
+	unsigned int bufferByteSize = policy.CanOperateKeystream() ? GetBufferByteSize(policy) : RoundUpToMultipleOf(1024U, GetBufferByteSize(policy));
+	m_buffer.New(bufferByteSize);
+
+	if (this->IsResynchronizable())
+	{
+		size_t ivLength;
+		const byte *iv = this->GetIVAndThrowIfInvalid(params, ivLength);
+		policy.CipherResynchronize(m_buffer, iv, ivLength);
+	}
+}
+
+template <class S>
+void AdditiveCipherTemplate<S>::GenerateBlock(byte *outString, size_t length)
+{
+	if (m_leftOver > 0)
+	{
+		size_t len = STDMIN(m_leftOver, length);
+		memcpy(outString, KeystreamBufferEnd()-m_leftOver, len);
+		length -= len;
+		m_leftOver -= len;
+		outString += len;
+
+		if (!length)
+			return;
+	}
+	assert(m_leftOver == 0);
+
+	PolicyInterface &policy = this->AccessPolicy();
+	unsigned int bytesPerIteration = policy.GetBytesPerIteration();
+
+	if (length >= bytesPerIteration)
+	{
+		size_t iterations = length / bytesPerIteration;
+		policy.WriteKeystream(outString, iterations);
+		outString += iterations * bytesPerIteration;
+		length -= iterations * bytesPerIteration;
+	}
+
+	if (length > 0)
+	{
+		size_t bufferByteSize = RoundUpToMultipleOf(length, bytesPerIteration);
+		size_t bufferIterations = bufferByteSize / bytesPerIteration;
+
+		policy.WriteKeystream(KeystreamBufferEnd()-bufferByteSize, bufferIterations);
+		memcpy(outString, KeystreamBufferEnd()-bufferByteSize, length);
+		m_leftOver = bufferByteSize - length;
+	}
+}
+
+template <class S>
+void AdditiveCipherTemplate<S>::ProcessData(byte *outString, const byte *inString, size_t length)
+{
+	if (m_leftOver > 0)
+	{
+		size_t len = STDMIN(m_leftOver, length);
+		xorbuf(outString, inString, KeystreamBufferEnd()-m_leftOver, len);
+		length -= len;
+		m_leftOver -= len;
+		inString += len;
+		outString += len;
+
+		if (!length)
+			return;
+	}
+	assert(m_leftOver == 0);
+
+	PolicyInterface &policy = this->AccessPolicy();
+	unsigned int bytesPerIteration = policy.GetBytesPerIteration();
+
+	if (policy.CanOperateKeystream() && length >= bytesPerIteration)
+	{
+		size_t iterations = length / bytesPerIteration;
+		unsigned int alignment = policy.GetAlignment();
+		KeystreamOperation operation = KeystreamOperation((IsAlignedOn(inString, alignment) * 2) | (int)IsAlignedOn(outString, alignment));
+
+		policy.OperateKeystream(operation, outString, inString, iterations);
+
+		inString += iterations * bytesPerIteration;
+		outString += iterations * bytesPerIteration;
+		length -= iterations * bytesPerIteration;
+
+		if (!length)
+			return;
+	}
+
+	size_t bufferByteSize = m_buffer.size();
+	size_t bufferIterations = bufferByteSize / bytesPerIteration;
+
+	while (length >= bufferByteSize)
+	{
+		policy.WriteKeystream(m_buffer, bufferIterations);
+		xorbuf(outString, inString, KeystreamBufferBegin(), bufferByteSize);
+		length -= bufferByteSize;
+		inString += bufferByteSize;
+		outString += bufferByteSize;
+	}
+
+	if (length > 0)
+	{
+		bufferByteSize = RoundUpToMultipleOf(length, bytesPerIteration);
+		bufferIterations = bufferByteSize / bytesPerIteration;
+
+		policy.WriteKeystream(KeystreamBufferEnd()-bufferByteSize, bufferIterations);
+		xorbuf(outString, inString, KeystreamBufferEnd()-bufferByteSize, length);
+		m_leftOver = bufferByteSize - length;
+	}
+}
+
+template <class S>
+void AdditiveCipherTemplate<S>::Resynchronize(const byte *iv, int length)
+{
+	PolicyInterface &policy = this->AccessPolicy();
+	m_leftOver = 0;
+	m_buffer.New(GetBufferByteSize(policy));
+	policy.CipherResynchronize(m_buffer, iv, this->ThrowIfInvalidIVLength(length));
+}
+
+template <class BASE>
+void AdditiveCipherTemplate<BASE>::Seek(lword position)
+{
+	PolicyInterface &policy = this->AccessPolicy();
+	unsigned int bytesPerIteration = policy.GetBytesPerIteration();
+
+	policy.SeekToIteration(position / bytesPerIteration);
+	position %= bytesPerIteration;
+
+	if (position > 0)
+	{
+		policy.WriteKeystream(KeystreamBufferEnd()-bytesPerIteration, 1);
+		m_leftOver = bytesPerIteration - (unsigned int)position;
+	}
+	else
+		m_leftOver = 0;
+}
+
+template <class BASE>
+void CFB_CipherTemplate<BASE>::UncheckedSetKey(const byte *key, unsigned int length, const NameValuePairs &params)
+{
+	PolicyInterface &policy = this->AccessPolicy();
+	policy.CipherSetKey(params, key, length);
+
+	if (this->IsResynchronizable())
+	{
+		size_t ivLength;
+		const byte *iv = this->GetIVAndThrowIfInvalid(params, ivLength);
+		policy.CipherResynchronize(iv, ivLength);
+	}
+
+	m_leftOver = policy.GetBytesPerIteration();
+}
+
+template <class BASE>
+void CFB_CipherTemplate<BASE>::Resynchronize(const byte *iv, int length)
+{
+	PolicyInterface &policy = this->AccessPolicy();
+	policy.CipherResynchronize(iv, this->ThrowIfInvalidIVLength(length));
+	m_leftOver = policy.GetBytesPerIteration();
+}
+
+template <class BASE>
+void CFB_CipherTemplate<BASE>::ProcessData(byte *outString, const byte *inString, size_t length)
+{
+	assert(length % this->MandatoryBlockSize() == 0);
+
+	PolicyInterface &policy = this->AccessPolicy();
+	unsigned int bytesPerIteration = policy.GetBytesPerIteration();
+	unsigned int alignment = policy.GetAlignment();
+	byte *reg = policy.GetRegisterBegin();
+
+	if (m_leftOver)
+	{
+		size_t len = STDMIN(m_leftOver, length);
+		CombineMessageAndShiftRegister(outString, reg + bytesPerIteration - m_leftOver, inString, len);
+		m_leftOver -= len;
+		length -= len;
+		inString += len;
+		outString += len;
+	}
+
+	if (!length)
+		return;
+
+	assert(m_leftOver == 0);
+
+	if (policy.CanIterate() && length >= bytesPerIteration && IsAlignedOn(outString, alignment))
+	{
+		if (IsAlignedOn(inString, alignment))
+			policy.Iterate(outString, inString, GetCipherDir(*this), length / bytesPerIteration);
+		else
+		{
+			memcpy(outString, inString, length);
+			policy.Iterate(outString, outString, GetCipherDir(*this), length / bytesPerIteration);
+		}
+		inString += length - length % bytesPerIteration;
+		outString += length - length % bytesPerIteration;
+		length %= bytesPerIteration;
+	}
+
+	while (length >= bytesPerIteration)
+	{
+		policy.TransformRegister();
+		CombineMessageAndShiftRegister(outString, reg, inString, bytesPerIteration);
+		length -= bytesPerIteration;
+		inString += bytesPerIteration;
+		outString += bytesPerIteration;
+	}
+
+	if (length > 0)
+	{
+		policy.TransformRegister();
+		CombineMessageAndShiftRegister(outString, reg, inString, length);
+		m_leftOver = bytesPerIteration - length;
+	}
+}
+
+template <class BASE>
+void CFB_EncryptionTemplate<BASE>::CombineMessageAndShiftRegister(byte *output, byte *reg, const byte *message, size_t length)
+{
+	xorbuf(reg, message, length);
+	memcpy(output, reg, length);
+}
+
+template <class BASE>
+void CFB_DecryptionTemplate<BASE>::CombineMessageAndShiftRegister(byte *output, byte *reg, const byte *message, size_t length)
+{
+	for (unsigned int i=0; i<length; i++)
+	{
+		byte b = message[i];
+		output[i] = reg[i] ^ b;
+		reg[i] = b;
+	}
+}
+
+NAMESPACE_END
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/Mcrypt/src/trdlocal.cpp b/SelfServiceCommon/Massai/cpp/Mcrypt/src/trdlocal.cpp
new file mode 100644
index 00000000..6d6b822c
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Mcrypt/src/trdlocal.cpp
@@ -0,0 +1,73 @@
+// trdlocal.cpp - written and placed in the public domain by Wei Dai
+
+#include "pch.h"
+
+#ifndef CRYPTOPP_IMPORTS
+#ifdef THREADS_AVAILABLE
+
+#include "trdlocal.h"
+
+#ifdef HAS_WINTHREADS
+#include <windows.h>
+#endif
+
+NAMESPACE_BEGIN(CryptoPP)
+
+ThreadLocalStorage::Err::Err(const std::string& operation, int error)
+	: OS_Error(OTHER_ERROR, "ThreadLocalStorage: " + operation + " operation failed with error 0x" + IntToString(error, 16), operation, error)
+{
+}
+
+ThreadLocalStorage::ThreadLocalStorage()
+{
+#ifdef HAS_WINTHREADS
+	m_index = TlsAlloc();
+	if (m_index == TLS_OUT_OF_INDEXES)
+		throw Err("TlsAlloc", GetLastError());
+#else
+	int error = pthread_key_create(&m_index, NULL);
+	if (error)
+		throw Err("pthread_key_create", error);
+#endif
+}
+
+ThreadLocalStorage::~ThreadLocalStorage()
+{
+#ifdef HAS_WINTHREADS
+	if (!TlsFree(m_index))
+		throw Err("TlsFree", GetLastError());
+#else
+	int error = pthread_key_delete(m_index);
+	if (error)
+		throw Err("pthread_key_delete", error);
+#endif
+}
+
+void ThreadLocalStorage::SetValue(void *value)
+{
+#ifdef HAS_WINTHREADS
+	if (!TlsSetValue(m_index, value))
+		throw Err("TlsSetValue", GetLastError());
+#else
+	int error = pthread_setspecific(m_index, value);
+	if (error)
+		throw Err("pthread_key_getspecific", error);
+#endif
+}
+
+void *ThreadLocalStorage::GetValue() const
+{
+#ifdef HAS_WINTHREADS
+	void *result = TlsGetValue(m_index);
+	if (!result && GetLastError() != NO_ERROR)
+		throw Err("TlsGetValue", GetLastError());
+#else
+	void *result = pthread_getspecific(m_index);
+#endif
+	return result;
+}
+
+NAMESPACE_END
+
+#endif	// #ifdef THREADS_AVAILABLE
+#endif
-- 
2.41.0.windows.1

