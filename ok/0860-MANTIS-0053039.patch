From 145ba78bd17aa8d66a15d31f0b1775b3291d5414 Mon Sep 17 00:00:00 2001
From: tstegema <tstegema@90b65887-3827-0410-9a23-83215b262276>
Date: Tue, 15 Jan 2019 15:23:56 +0000
Subject: [PATCH 0860/1000] MANTIS 0053039 Support AZTEC barcode printing for
 LH

massai_graphic.lib
V1.0.0.5
- use zint library for barcode generation: PDF417, Aztec, DataMatrix, QR


git-svn-id: svn://localhost/SelfServiceCommon/trunk@1414 90b65887-3827-0410-9a23-83215b262276
---
 .../Interfaces/inc/graphic/barcode.h          |  24 +-
 .../Interfaces/inc/graphic/barcodeAztec.h     |  33 +
 .../inc/graphic/barcodeDataMatrix.h           |  32 +
 .../Interfaces/inc/graphic/barcodeEAN13.h     |  33 +
 .../Interfaces/inc/graphic/barcodePDF417.h    |   9 +-
 .../Interfaces/inc/graphic/barcodeQR.h        |  33 +
 .../Interfaces/inc/graphic/zintPixelRow.h     |  34 +
 .../Massai/cpp/Graphic/makefile.mak           |  10 +-
 .../cpp/Graphic/src/TestBarcodePDF417.cpp     |   2 -
 .../Massai/cpp/Graphic/src/barcode.cpp        |   6 +
 .../Massai/cpp/Graphic/src/barcodeAztec.cpp   |  76 ++
 .../cpp/Graphic/src/barcodeDataMatrix.cpp     |  75 ++
 .../Massai/cpp/Graphic/src/barcodeEAN13.cpp   |  76 ++
 .../Massai/cpp/Graphic/src/barcodePDF417.cpp  | 131 +--
 .../Massai/cpp/Graphic/src/barcodeQR.cpp      |  76 ++
 .../Massai/cpp/Graphic/src/local_def.cpp      |  17 +-
 .../Massai/cpp/Graphic/src/pdf417lib.cpp      | 815 ------------------
 .../Massai/cpp/Graphic/src/zintPixelRow.cpp   |  56 ++
 18 files changed, 591 insertions(+), 947 deletions(-)
 create mode 100644 SelfServiceCommon/Interfaces/inc/graphic/barcodeAztec.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/graphic/barcodeDataMatrix.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/graphic/barcodeEAN13.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/graphic/barcodeQR.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/graphic/zintPixelRow.h
 create mode 100644 SelfServiceCommon/Massai/cpp/Graphic/src/barcodeAztec.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Graphic/src/barcodeDataMatrix.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Graphic/src/barcodeEAN13.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Graphic/src/barcodeQR.cpp
 delete mode 100644 SelfServiceCommon/Massai/cpp/Graphic/src/pdf417lib.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Graphic/src/zintPixelRow.cpp

diff --git a/SelfServiceCommon/Interfaces/inc/graphic/barcode.h b/SelfServiceCommon/Interfaces/inc/graphic/barcode.h
index 5bdc9716..fdb95f21 100644
--- a/SelfServiceCommon/Interfaces/inc/graphic/barcode.h
+++ b/SelfServiceCommon/Interfaces/inc/graphic/barcode.h
@@ -1,14 +1,7 @@
-/**
- **************************************************************************
- *
- * @file barcode.h
- *
- * create barcode bitmap
- *
- **************************************************************************
-**/
-#ifndef INCLUDE_BARCODE_H
-#define INCLUDE_BARCODE_H
+// * create barcode bitmap
+
+#pragma once
+
 #ifdef SHOW_INCLUDE_FILES
 #pragma message("including: " __FILE__)
 #endif
@@ -26,11 +19,19 @@ namespace MASSAI
       public:
         BufferOverflowException(const std::string& what_arg);
     };
+
+    class InitializationFailedException: public std::runtime_error
+    {
+      public:
+        InitializationFailedException(const std::string& what_arg);
+    };
+
     class InvalidParameterException: public std::invalid_argument
     {
       public:
         InvalidParameterException(const std::string& what_arg);
     };
+
     class Barcode
     {
       public:
@@ -42,4 +43,3 @@ namespace MASSAI
   }
 }
 
-#endif
diff --git a/SelfServiceCommon/Interfaces/inc/graphic/barcodeAztec.h b/SelfServiceCommon/Interfaces/inc/graphic/barcodeAztec.h
new file mode 100644
index 00000000..bc352a42
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/graphic/barcodeAztec.h
@@ -0,0 +1,33 @@
+// create barcodeAztec bitmap
+#pragma once
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "graphic/barcode.h"
+#include <stddef.h>
+
+namespace MASSAI
+{
+  namespace Barcode
+  {
+    struct BarcodeAztecSettings
+    {
+      size_t blockWidth;
+      size_t blockHeight;
+      size_t errorLevel;  // 1: 10%, 2: 23%, 3: 36%, 4: 50%
+    };
+
+    class BarcodeAztec: public Barcode
+    {
+      public:
+        BarcodeAztec(const BarcodeAztecSettings& settings);
+        virtual ~BarcodeAztec();
+
+        virtual Bitmap::Bitmap createBarcode(const std::string& barcodeData) const;
+        virtual std::string createBarcodeData(const std::string& data) const;
+      private:
+        BarcodeAztecSettings m_settings;
+    };
+  }
+}
diff --git a/SelfServiceCommon/Interfaces/inc/graphic/barcodeDataMatrix.h b/SelfServiceCommon/Interfaces/inc/graphic/barcodeDataMatrix.h
new file mode 100644
index 00000000..48d2879e
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/graphic/barcodeDataMatrix.h
@@ -0,0 +1,32 @@
+// create barcodeDataMatrix bitmap
+#pragma once
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "graphic/barcode.h"
+#include <stddef.h>
+
+namespace MASSAI
+{
+  namespace Barcode
+  {
+    struct BarcodeDataMatrixSettings
+    {
+      size_t blockWidth;
+      size_t blockHeight;
+    };
+
+    class BarcodeDataMatrix: public Barcode
+    {
+      public:
+        BarcodeDataMatrix(const BarcodeDataMatrixSettings& settings);
+        virtual ~BarcodeDataMatrix();
+
+        virtual Bitmap::Bitmap createBarcode(const std::string& barcodeData) const;
+        virtual std::string createBarcodeData(const std::string& data) const;
+      private:
+        BarcodeDataMatrixSettings m_settings;
+    };
+  }
+}
diff --git a/SelfServiceCommon/Interfaces/inc/graphic/barcodeEAN13.h b/SelfServiceCommon/Interfaces/inc/graphic/barcodeEAN13.h
new file mode 100644
index 00000000..1519de02
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/graphic/barcodeEAN13.h
@@ -0,0 +1,33 @@
+// create barcodeEAN13 bitmap
+#pragma once
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "graphic/barcode.h"
+#include <stddef.h>
+
+namespace MASSAI
+{
+  namespace Barcode
+  {
+    struct BarcodeEAN13Settings
+    {
+      size_t blockWidth;
+      size_t blockHeight;
+      bool   useCheckSum;
+    };
+
+    class BarcodeEAN13: public Barcode
+    {
+      public:
+        BarcodeEAN13(const BarcodeEAN13Settings& settings);
+        virtual ~BarcodeEAN13();
+
+        virtual Bitmap::Bitmap createBarcode(const std::string& barcodeData) const;
+        virtual std::string createBarcodeData(const std::string& data) const;
+      private:
+        BarcodeEAN13Settings m_settings;
+    };
+  }
+}
diff --git a/SelfServiceCommon/Interfaces/inc/graphic/barcodePDF417.h b/SelfServiceCommon/Interfaces/inc/graphic/barcodePDF417.h
index 974f789a..a5303965 100644
--- a/SelfServiceCommon/Interfaces/inc/graphic/barcodePDF417.h
+++ b/SelfServiceCommon/Interfaces/inc/graphic/barcodePDF417.h
@@ -1,6 +1,5 @@
 // create barcodePDF417 bitmap
-#ifndef BARCODEPDF417_INCLUDED
-#define BARCODEPDF417_INCLUDED
+#pragma once
 #ifdef SHOW_INCLUDE_FILES
 #pragma message("including: " __FILE__)
 #endif
@@ -17,9 +16,7 @@ namespace MASSAI
       size_t blockWidth;
       size_t blockHeight;
       size_t rows;
-      size_t errorLevel;
-      bool   useQuietZone;
-      size_t columns;
+      size_t errorLevel;  // 0-8: 2^(errorLevel+1)
     };
 
     class BarcodePDF417: public Barcode
@@ -35,5 +32,3 @@ namespace MASSAI
     };
   }
 }
-
-#endif
diff --git a/SelfServiceCommon/Interfaces/inc/graphic/barcodeQR.h b/SelfServiceCommon/Interfaces/inc/graphic/barcodeQR.h
new file mode 100644
index 00000000..9fd12440
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/graphic/barcodeQR.h
@@ -0,0 +1,33 @@
+// create barcodeQR bitmap
+#pragma once
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "graphic/barcode.h"
+#include <stddef.h>
+
+namespace MASSAI
+{
+  namespace Barcode
+  {
+    struct BarcodeQRSettings
+    {
+      size_t blockWidth;
+      size_t blockHeight;
+      size_t errorLevel;  // 1: L 20%/7%, 2: M 37%/15%, 3: Q 55%/25%, 4: H 65%/30%
+    };
+
+    class BarcodeQR: public Barcode
+    {
+      public:
+        BarcodeQR(const BarcodeQRSettings& settings);
+        virtual ~BarcodeQR();
+
+        virtual Bitmap::Bitmap createBarcode(const std::string& barcodeData) const;
+        virtual std::string createBarcodeData(const std::string& data) const;
+      private:
+        BarcodeQRSettings m_settings;
+    };
+  }
+}
diff --git a/SelfServiceCommon/Interfaces/inc/graphic/zintPixelRow.h b/SelfServiceCommon/Interfaces/inc/graphic/zintPixelRow.h
new file mode 100644
index 00000000..1ce5f501
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/graphic/zintPixelRow.h
@@ -0,0 +1,34 @@
+// create PixelRows from zint bitmap
+
+#pragma once
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "graphic/pixelRow.h"
+#include <stddef.h>
+#include <vector>
+
+namespace MASSAI
+{
+  namespace Barcode
+  {
+    class ZintPixelRows: public MASSAI::Bitmap::PixelRows
+    {
+      public:
+        ZintPixelRows(size_t blockWidth, size_t blockHeight, size_t width, size_t height, char* bitmap);
+        ~ZintPixelRows();
+
+        size_t getHeight() const;
+        size_t getWidth() const;
+        const MASSAI::text::StringBuffer& getRow(size_t y) const;
+
+      private:
+        size_t m_width;
+        size_t m_rows;
+        size_t m_blockHeight;
+        typedef std::vector<MASSAI::text::StringBuffer> BitmapRows;
+        BitmapRows m_bitmapRows;
+    };
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/Graphic/makefile.mak b/SelfServiceCommon/Massai/cpp/Graphic/makefile.mak
index f8f770f7..3d036034 100644
--- a/SelfServiceCommon/Massai/cpp/Graphic/makefile.mak
+++ b/SelfServiceCommon/Massai/cpp/Graphic/makefile.mak
@@ -9,7 +9,7 @@
 ######################################################################
 
 
-MY_CFLAGS =             $(MY_CFLAGS_2) $(INC_INTERFACES)
+MY_CFLAGS =             $(MY_CFLAGS_2) $(INC_INTERFACES) $(INC_ZINT)
 
 MY_LIB1 =               $(LIB_DST_GRAPHIC)
 
@@ -21,8 +21,12 @@ MY_LIB1_OBJS =          $(_OBJ)\local_def.obj \
                         $(_OBJ)\barcodeIndustrial2of5.obj \
                         $(_OBJ)\barcodeInterleaved2of5.obj \
                         $(_OBJ)\barcode128.obj \
-                        $(_OBJ)\pdf417lib.obj \
-                        $(_OBJ)\barcodePDF417.obj
+                        $(_OBJ)\barcodePDF417.obj \
+                        $(_OBJ)\barcodeEAN13.obj \
+                        $(_OBJ)\barcodeAztec.obj \
+                        $(_OBJ)\barcodeDataMatrix.obj \
+                        $(_OBJ)\barcodeQR.obj \
+                        $(_OBJ)\zintPixelRow.obj
 
 ######################################################################
 
diff --git a/SelfServiceCommon/Massai/cpp/Graphic/src/TestBarcodePDF417.cpp b/SelfServiceCommon/Massai/cpp/Graphic/src/TestBarcodePDF417.cpp
index 084795b9..5adfb13d 100644
--- a/SelfServiceCommon/Massai/cpp/Graphic/src/TestBarcodePDF417.cpp
+++ b/SelfServiceCommon/Massai/cpp/Graphic/src/TestBarcodePDF417.cpp
@@ -32,7 +32,6 @@ void printUsage(int argc, char** argv, char* error= 0)
   std::cout << " [-height:<BlockHeight>]";
   std::cout << " [-rows:<NumberOfRows]";
   std::cout << " [-error:<ErrorLevel]";
-  std::cout << " [-quietzone]";
   std::cout << std::endl;
   if(error)
   {
@@ -87,7 +86,6 @@ int main(int argc, char** argv)
       settings.blockHeight= args.optionInteger("HEIGHT", 1);
       settings.rows= args.optionInteger("ROWS", 0);
       settings.errorLevel= args.optionInteger("ERROR", 3);
-      settings.useQuietZone= args.option("QUIETZONE") != 0;
       createBarcode(filename, input, settings);
     }
   }
diff --git a/SelfServiceCommon/Massai/cpp/Graphic/src/barcode.cpp b/SelfServiceCommon/Massai/cpp/Graphic/src/barcode.cpp
index 154656c5..dc97fa2e 100644
--- a/SelfServiceCommon/Massai/cpp/Graphic/src/barcode.cpp
+++ b/SelfServiceCommon/Massai/cpp/Graphic/src/barcode.cpp
@@ -15,9 +15,15 @@ namespace MASSAI
   {
     Barcode::~Barcode()
     {}
+
     BufferOverflowException::BufferOverflowException(const std::string& what_arg):
       std::runtime_error(what_arg)
     {}
+
+    InitializationFailedException::InitializationFailedException(const std::string& what_arg):
+      std::runtime_error(what_arg)
+    {}
+
     InvalidParameterException::InvalidParameterException(const std::string& what_arg):
       std::invalid_argument(what_arg)
     {}
diff --git a/SelfServiceCommon/Massai/cpp/Graphic/src/barcodeAztec.cpp b/SelfServiceCommon/Massai/cpp/Graphic/src/barcodeAztec.cpp
new file mode 100644
index 00000000..7d5e9e0b
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Graphic/src/barcodeAztec.cpp
@@ -0,0 +1,76 @@
+//  create aztec barcode in windows bmp fileformat (black/white)
+
+#include "graphic/barcodeAztec.h"
+#include "zint.h"
+#include "graphic/blackAndWhiteBitmap.h"
+#include "graphic/zintPixelRow.h"
+#include <vector>
+
+using namespace MASSAI::Barcode;
+using MASSAI::text::StringBuffer;
+using MASSAI::Bitmap::BlackAndWhiteBitmap;
+
+namespace
+{
+  ZintPixelRows createBarcodePixel(const std::string& data, const BarcodeAztecSettings& settings)
+  {
+    struct zint_symbol* barcode = ZBarcode_Create();
+    if(!barcode)
+    {
+      throw InitializationFailedException("ZBarcode_Create: failed");
+    }
+    else
+    {
+      StringBuffer buf(data);
+      barcode->symbology = BARCODE_AZTEC;
+      barcode->input_mode = DATA_MODE;
+      barcode->show_hrt = 0;
+      barcode->option_1 = settings.errorLevel;
+      int errorCode = ZBarcode_Encode_and_Buffer(barcode, buf.udata(), buf.size(), 0);
+      if(errorCode == ZINT_ERROR_MEMORY || errorCode == ZINT_ERROR_TOO_LONG)
+      {
+        std::string error = barcode->errtxt;
+        ZBarcode_Delete(barcode);
+        throw BufferOverflowException(error);
+      }
+      else if(errorCode)
+      {
+        std::string error = barcode->errtxt;
+        ZBarcode_Delete(barcode);
+        throw InvalidParameterException(error);
+      }
+      else
+      {
+        ZintPixelRows result(settings.blockWidth, settings.blockHeight, barcode->bitmap_width, barcode->bitmap_height, barcode->bitmap);
+        ZBarcode_Delete(barcode);
+        return result;
+      }
+    }
+  }
+}
+
+namespace MASSAI
+{
+  namespace Barcode
+  {
+    BarcodeAztec::BarcodeAztec(const BarcodeAztecSettings& settings):
+      m_settings(settings)
+    {}
+
+    BarcodeAztec::~BarcodeAztec()
+    {}
+
+    MASSAI::Bitmap::Bitmap BarcodeAztec::createBarcode(const std::string& barcodeData) const
+    {
+      MASSAI::Bitmap::Bitmap result;
+      ZintPixelRows pixel= createBarcodePixel(barcodeData, m_settings);
+      BlackAndWhiteBitmap bitmap;
+      return bitmap.createBitmap(pixel);
+    }
+
+    std::string BarcodeAztec::createBarcodeData(const std::string& data) const
+    {
+      return data;
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/Graphic/src/barcodeDataMatrix.cpp b/SelfServiceCommon/Massai/cpp/Graphic/src/barcodeDataMatrix.cpp
new file mode 100644
index 00000000..fdde7103
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Graphic/src/barcodeDataMatrix.cpp
@@ -0,0 +1,75 @@
+//  create datamatrix barcode in windows bmp fileformat (black/white)
+
+#include "graphic/barcodeDataMatrix.h"
+#include "zint.h"
+#include "graphic/blackAndWhiteBitmap.h"
+#include "graphic/zintPixelRow.h"
+#include <vector>
+
+using namespace MASSAI::Barcode;
+using MASSAI::text::StringBuffer;
+using MASSAI::Bitmap::BlackAndWhiteBitmap;
+
+namespace
+{
+  ZintPixelRows createBarcodePixel(const std::string& data, const BarcodeDataMatrixSettings& settings)
+  {
+    struct zint_symbol* barcode = ZBarcode_Create();
+    if(!barcode)
+    {
+      throw InitializationFailedException("ZBarcode_Create: failed");
+    }
+    else
+    {
+      StringBuffer buf(data);
+      barcode->symbology = BARCODE_DATAMATRIX;
+      barcode->input_mode = DATA_MODE;
+      barcode->show_hrt = 0;
+      int errorCode = ZBarcode_Encode_and_Buffer(barcode, buf.udata(), buf.size(), 0);
+      if(errorCode == ZINT_ERROR_MEMORY || errorCode == ZINT_ERROR_TOO_LONG)
+      {
+        std::string error = barcode->errtxt;
+        ZBarcode_Delete(barcode);
+        throw BufferOverflowException(error);
+      }
+      else if(errorCode)
+      {
+        std::string error = barcode->errtxt;
+        ZBarcode_Delete(barcode);
+        throw InvalidParameterException(error);
+      }
+      else
+      {
+        ZintPixelRows result(settings.blockWidth, settings.blockHeight, barcode->bitmap_width, barcode->bitmap_height, barcode->bitmap);
+        ZBarcode_Delete(barcode);
+        return result;
+      }
+    }
+  }
+}
+
+namespace MASSAI
+{
+  namespace Barcode
+  {
+    BarcodeDataMatrix::BarcodeDataMatrix(const BarcodeDataMatrixSettings& settings):
+      m_settings(settings)
+    {}
+
+    BarcodeDataMatrix::~BarcodeDataMatrix()
+    {}
+
+    MASSAI::Bitmap::Bitmap BarcodeDataMatrix::createBarcode(const std::string& barcodeData) const
+    {
+      MASSAI::Bitmap::Bitmap result;
+      ZintPixelRows pixel= createBarcodePixel(barcodeData, m_settings);
+      BlackAndWhiteBitmap bitmap;
+      return bitmap.createBitmap(pixel);
+    }
+
+    std::string BarcodeDataMatrix::createBarcodeData(const std::string& data) const
+    {
+      return data;
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/Graphic/src/barcodeEAN13.cpp b/SelfServiceCommon/Massai/cpp/Graphic/src/barcodeEAN13.cpp
new file mode 100644
index 00000000..288e399a
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Graphic/src/barcodeEAN13.cpp
@@ -0,0 +1,76 @@
+//  create EAN13 barcode in windows bmp fileformat (black/white)
+
+#include "graphic/barcodeEAN13.h"
+#include "zint.h"
+#include "graphic/blackAndWhiteBitmap.h"
+#include "graphic/zintPixelRow.h"
+#include <vector>
+
+using namespace MASSAI::Barcode;
+using MASSAI::text::StringBuffer;
+using MASSAI::Bitmap::BlackAndWhiteBitmap;
+
+namespace
+{
+  ZintPixelRows createBarcodePixel(const std::string& data, const BarcodeEAN13Settings& settings)
+  {
+    struct zint_symbol* barcode = ZBarcode_Create();
+    if(!barcode)
+    {
+      throw InitializationFailedException("ZBarcode_Create: failed");
+    }
+    else
+    {
+      StringBuffer buf(data);
+      barcode->symbology = settings.useCheckSum ? BARCODE_EAN14 : BARCODE_ISBNX;
+      barcode->input_mode = DATA_MODE;
+      barcode->show_hrt = 0;
+      barcode->height = 1;
+      int errorCode = ZBarcode_Encode_and_Buffer(barcode, buf.udata(), buf.size(), 0);
+      if(errorCode == ZINT_ERROR_MEMORY || errorCode == ZINT_ERROR_TOO_LONG)
+      {
+        std::string error = barcode->errtxt;
+        ZBarcode_Delete(barcode);
+        throw BufferOverflowException(error);
+      }
+      else if(errorCode)
+      {
+        std::string error = barcode->errtxt;
+        ZBarcode_Delete(barcode);
+        throw InvalidParameterException(error);
+      }
+      else
+      {
+        ZintPixelRows result(settings.blockWidth, settings.blockHeight, barcode->bitmap_width, barcode->bitmap_height, barcode->bitmap);
+        ZBarcode_Delete(barcode);
+        return result;
+      }
+    }
+  }
+}
+
+namespace MASSAI
+{
+  namespace Barcode
+  {
+    BarcodeEAN13::BarcodeEAN13(const BarcodeEAN13Settings& settings):
+      m_settings(settings)
+    {}
+
+    BarcodeEAN13::~BarcodeEAN13()
+    {}
+
+    MASSAI::Bitmap::Bitmap BarcodeEAN13::createBarcode(const std::string& barcodeData) const
+    {
+      MASSAI::Bitmap::Bitmap result;
+      ZintPixelRows pixel= createBarcodePixel(barcodeData, m_settings);
+      BlackAndWhiteBitmap bitmap;
+      return bitmap.createBitmap(pixel);
+    }
+
+    std::string BarcodeEAN13::createBarcodeData(const std::string& data) const
+    {
+      return data;
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/Graphic/src/barcodePDF417.cpp b/SelfServiceCommon/Massai/cpp/Graphic/src/barcodePDF417.cpp
index 863ab220..d7c7bd1d 100644
--- a/SelfServiceCommon/Massai/cpp/Graphic/src/barcodePDF417.cpp
+++ b/SelfServiceCommon/Massai/cpp/Graphic/src/barcodePDF417.cpp
@@ -1,125 +1,52 @@
-//  create pdf in windows bmp fileformat (black/white)
+//  create pdf417 barcode in windows bmp fileformat (black/white)
 
 #include "graphic/barcodePDF417.h"
-#include "pdf417lib.h"
+#include "zint.h"
 #include "graphic/blackAndWhiteBitmap.h"
-#include "Tools/bitarray.h"
+#include "graphic/zintPixelRow.h"
 #include <vector>
 
 using namespace MASSAI::Barcode;
 using MASSAI::text::StringBuffer;
 using MASSAI::Bitmap::BlackAndWhiteBitmap;
-using MASSAI::BitArray;
 
 namespace
 {
-  class PDF417PixelRows: public MASSAI::Bitmap::PixelRows
+  ZintPixelRows createBarcodePixel(const std::string& data, const BarcodePDF417Settings& settings)
   {
-    public:
-      PDF417PixelRows(const BarcodePDF417Settings& settings, size_t width, size_t height, char* bits, size_t length):
-        m_width(width * settings.blockWidth),
-        m_rows(height),
-        m_blockHeight(settings.blockHeight)
-      {
-        m_bitmapRows.reserve(m_rows);
-        if(settings.blockWidth > 1)
-        {
-          size_t length= (width + 7)/8;
-          for(size_t i= 0; i < m_rows; i++)
-          {
-            BitArray source(reinterpret_cast<unsigned char*>(bits) + i * length, width);
-            BitArray dest(m_width);
-            for(size_t j= 0; j < width; j++)
-            {
-              dest.set(i * settings.blockWidth, source.get(i), settings.blockWidth);
-            }
-            m_bitmapRows.push_back(dest.buffer());
-          }
-        }
-        else
-        {
-          size_t length= (width + 7)/8;
-          for(size_t i= 0; i < m_rows; i++)
-          {
-            m_bitmapRows.push_back(StringBuffer(bits + i * length, length));
-          }
-        }
-      }
-
-      ~PDF417PixelRows()
-      {}
-
-      size_t getHeight() const
-      {
-        return m_rows * m_blockHeight;
-      }
-
-      size_t getWidth() const
-      {
-        return m_width;
-      }
-
-      const MASSAI::text::StringBuffer& getRow(size_t y) const
-      {
-        if(y < getHeight())
-        {
-          return m_bitmapRows[y / m_blockHeight];
-        }
-        else
-        {
-          return m_bitmapRows[0];
-        }
-      }
-
-    private:
-      size_t m_width;
-      size_t m_rows;
-      size_t m_blockHeight;
-      typedef std::vector<StringBuffer> BitmapRows;
-      BitmapRows m_bitmapRows;
-  };
-
-
-  PDF417PixelRows createBarcodePixel(const std::string& data, const BarcodePDF417Settings& settings)
-  {
-    StringBuffer buf(data);
-    pdf417param params;
-    pdf417init(&params);
-    params.text          = buf.data();
-    params.lenText       = buf.size();
-    params.options       = PDF417_INVERT_BITMAP | PDF417_USE_ERROR_LEVEL;
-    params.errorLevel    = settings.errorLevel;
-    if(settings.rows > 0)
+    struct zint_symbol* barcode = ZBarcode_Create();
+    if(!barcode)
     {
-      params.options     |= PDF417_FIXED_ROWS;
-      params.codeRows    = settings.rows;
-    }
-    else if(settings.columns > 0)
-    {
-      params.options     |= PDF417_FIXED_COLUMNS;
-      params.codeColumns = settings.columns;
+      throw InitializationFailedException("ZBarcode_Create: failed");
     }
     else
     {
-      params.options     |= PDF417_USE_ASPECT_RATIO;
-      params.aspectRatio = (float) 3.0 / (float) 4.0;
-    }
-    paintCode(&params);
-    if(params.error != 0)
-    {
-      pdf417free(&params);
-      if(params.error == PDF417_ERROR_TEXT_TOO_BIG)
+      StringBuffer buf(data);
+      barcode->symbology = BARCODE_PDF417;
+      barcode->input_mode = DATA_MODE;
+      barcode->show_hrt = 0;
+      barcode->option_2 = settings.rows;
+      barcode->option_1 = settings.errorLevel;
+      int errorCode = ZBarcode_Encode_and_Buffer(barcode, buf.udata(), buf.size(), 0);
+      if(errorCode == ZINT_ERROR_MEMORY || errorCode == ZINT_ERROR_TOO_LONG)
+      {
+        std::string error = barcode->errtxt;
+        ZBarcode_Delete(barcode);
+        throw BufferOverflowException(error);
+      }
+      else if(errorCode)
       {
-        throw BufferOverflowException("PDF417: text too big");
+        std::string error = barcode->errtxt;
+        ZBarcode_Delete(barcode);
+        throw InvalidParameterException(error);
       }
-      else if(params.error != 0)
+      else
       {
-        throw InvalidParameterException("PDF417: invalid argument");
+        ZintPixelRows result(settings.blockWidth, settings.blockHeight, barcode->bitmap_width, barcode->bitmap_height, barcode->bitmap);
+        ZBarcode_Delete(barcode);
+        return result;
       }
     }
-    PDF417PixelRows result(settings, params.bitColumns, params.codeRows, params.outBits, params.lenBits);
-    pdf417free(&params);
-    return result;
   }
 }
 
@@ -137,7 +64,7 @@ namespace MASSAI
     MASSAI::Bitmap::Bitmap BarcodePDF417::createBarcode(const std::string& barcodeData) const
     {
       MASSAI::Bitmap::Bitmap result;
-      PDF417PixelRows pixel= createBarcodePixel(barcodeData, m_settings);
+      ZintPixelRows pixel= createBarcodePixel(barcodeData, m_settings);
       BlackAndWhiteBitmap bitmap;
       return bitmap.createBitmap(pixel);
     }
diff --git a/SelfServiceCommon/Massai/cpp/Graphic/src/barcodeQR.cpp b/SelfServiceCommon/Massai/cpp/Graphic/src/barcodeQR.cpp
new file mode 100644
index 00000000..f308f297
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Graphic/src/barcodeQR.cpp
@@ -0,0 +1,76 @@
+//  create qr barcode in windows bmp fileformat (black/white)
+
+#include "graphic/barcodeQR.h"
+#include "zint.h"
+#include "graphic/blackAndWhiteBitmap.h"
+#include "graphic/zintPixelRow.h"
+#include <vector>
+
+using namespace MASSAI::Barcode;
+using MASSAI::text::StringBuffer;
+using MASSAI::Bitmap::BlackAndWhiteBitmap;
+
+namespace
+{
+  ZintPixelRows createBarcodePixel(const std::string& data, const BarcodeQRSettings& settings)
+  {
+    struct zint_symbol* barcode = ZBarcode_Create();
+    if(!barcode)
+    {
+      throw InitializationFailedException("ZBarcode_Create: failed");
+    }
+    else
+    {
+      StringBuffer buf(data);
+      barcode->symbology = BARCODE_QRCODE;
+      barcode->input_mode = DATA_MODE;
+      barcode->show_hrt = 0;
+      barcode->option_1 = settings.errorLevel;
+      int errorCode = ZBarcode_Encode_and_Buffer(barcode, buf.udata(), buf.size(), 0);
+      if(errorCode == ZINT_ERROR_MEMORY || errorCode == ZINT_ERROR_TOO_LONG)
+      {
+        std::string error = barcode->errtxt;
+        ZBarcode_Delete(barcode);
+        throw BufferOverflowException(error);
+      }
+      else if(errorCode)
+      {
+        std::string error = barcode->errtxt;
+        ZBarcode_Delete(barcode);
+        throw InvalidParameterException(error);
+      }
+      else
+      {
+        ZintPixelRows result(settings.blockWidth, settings.blockHeight, barcode->bitmap_width, barcode->bitmap_height, barcode->bitmap);
+        ZBarcode_Delete(barcode);
+        return result;
+      }
+    }
+  }
+}
+
+namespace MASSAI
+{
+  namespace Barcode
+  {
+    BarcodeQR::BarcodeQR(const BarcodeQRSettings& settings):
+      m_settings(settings)
+    {}
+
+    BarcodeQR::~BarcodeQR()
+    {}
+
+    MASSAI::Bitmap::Bitmap BarcodeQR::createBarcode(const std::string& barcodeData) const
+    {
+      MASSAI::Bitmap::Bitmap result;
+      ZintPixelRows pixel= createBarcodePixel(barcodeData, m_settings);
+      BlackAndWhiteBitmap bitmap;
+      return bitmap.createBitmap(pixel);
+    }
+
+    std::string BarcodeQR::createBarcodeData(const std::string& data) const
+    {
+      return data;
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/Graphic/src/local_def.cpp b/SelfServiceCommon/Massai/cpp/Graphic/src/local_def.cpp
index 79202fc3..1bf56bdf 100644
--- a/SelfServiceCommon/Massai/cpp/Graphic/src/local_def.cpp
+++ b/SelfServiceCommon/Massai/cpp/Graphic/src/local_def.cpp
@@ -1,6 +1,6 @@
 #include "tools/versionlib.h"
 
-VERSION_ID_DT(graphic, 1, 0, 0, 4);
+VERSION_ID_DT(graphic, 1, 0, 0, 5);
 
 /*!
 \file
@@ -8,19 +8,24 @@ VERSION_ID_DT(graphic, 1, 0, 0, 4);
 
 \page massai_graphic.lib Release Notes - massai_graphic.lib
 
-@version 1.0.0.4
+@version 1.0.0.5
 
 \section changehistory Change history
 
 massai_graphic.lib
 
+\version 1.0.0.5
+\li 15.01.2019
+\li Mantis 0053039: Support AZTEC barcode printing for LH
+- use zint library for barcode generation: PDF417, Aztec, DataMatrix, QR
+
 \version 1.0.0.4
 \li 13.08.2013
 \li Mantis 0028572: GPPDev: Receipt support Barcode according to AEA2011
-\li added field size_t columns to BarcodePDF417Settings\n
-if rows != 0 use rows\n
-if columns != 0 use columns\n
-else use ratio of height/width = 3/4\n
+\li added field size_t columns to BarcodePDF417Settings
+if rows != 0 use rows
+if columns != 0 use columns
+else use ratio of height/width = 3/4
 
 \version 1.0.0.3
 \li 09.07.2013
diff --git a/SelfServiceCommon/Massai/cpp/Graphic/src/pdf417lib.cpp b/SelfServiceCommon/Massai/cpp/Graphic/src/pdf417lib.cpp
deleted file mode 100644
index e3aa8a12..00000000
--- a/SelfServiceCommon/Massai/cpp/Graphic/src/pdf417lib.cpp
+++ /dev/null
@@ -1,815 +0,0 @@
-/*
- * Copyright 2003 by Paulo Soares.
- *
- * The contents of this file are subject to the Mozilla Public License Version 1.1
- * (the "License"); you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the License.
- *
- * The Original Code is 'pdf417lib, a library to generate the bidimensional barcode PDF417'.
- *
- * The Initial Developer of the Original Code is Paulo Soares. Portions created by
- * the Initial Developer are Copyright (C) 2003 by Paulo Soares.
- * All Rights Reserved.
- *
- * Contributor(s): all the names of the contributors are added in the source code
- * where applicable.
- *
- * Alternatively, the contents of this file may be used under the terms of the
- * LGPL license (the "GNU LIBRARY GENERAL PUBLIC LICENSE"), in which case the
- * provisions of LGPL are applicable instead of those above.  If you wish to
- * allow use of your version of this file only under the terms of the LGPL
- * License and not to allow others to use your version of this file under
- * the MPL, indicate your decision by deleting the provisions above and
- * replace them with the notice and other provisions required by the LGPL.
- * If you do not delete the provisions above, a recipient may use your version
- * of this file under either the MPL or the GNU LIBRARY GENERAL PUBLIC LICENSE.
- *
- * This library is free software; you can redistribute it and/or modify it
- * under the terms of the MPL as stated above or under the terms of the GNU
- * Library General Public License as published by the Free Software Foundation;
- * either version 2 of the License, or any later version.
- *
- * This library is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE. See the GNU Library general Public License for more
- * details.
- *
- * If you didn't download this code from the following link, you should check if
- * you aren't using an obsolete version:
- * http://sourceforge.net/projects/pdf417lib
- */
-#include <malloc.h>
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#define __INCLUDE_PDF417LIBIMP_H__
-#include "pdf417libimp.h"
-#undef __INCLUDE_PDF417LIBIMP_H__
-#include "pdf417lib.h"
-
-#ifndef NULL
-#ifdef  __cplusplus
-#define NULL    0
-#else
-#define NULL    ((void *)0)
-#endif
-#endif
-
-char* MIXED_SET = "0123456789&\r\t,:#-.$/+%*=^";
-char* PUNCTUATION_SET = ";<>@[\\]_`~!\r\t,:\n-.$/\"|*()?{}'";
-
-typedef struct _listElement {
-    char type;
-    int start;
-    int end;
-} listElement, *pListElement;
-
-typedef struct _arrayList {
-    pListElement array;
-    int size;
-    int capacity;
-} arrayList, *pArrayList;
-
-typedef struct _pdf417class {
-    int bitPtr;
-    int cwPtr;
-    pdf417param *param;
-} pdf417class, *pPdf417class;
-
-
-void listInit(pArrayList list) {
-    list->capacity = 20;
-    list->size = 0;
-    list->array = (pListElement)malloc(list->capacity * sizeof(listElement));
-}
-
-void listFree(pArrayList list) {
-    free(list->array);
-    list->array = NULL;
-}
-
-void listAdd(pArrayList list, char type, int start, int end) {
-    if (list->size == list->capacity) {
-        pListElement temp;
-        list->capacity *= 2;
-        temp = (pListElement)malloc(list->capacity * sizeof(listElement));
-        memcpy(temp, list->array, list->size * sizeof(listElement));
-        free(list->array);
-        list->array = temp;
-    }
-    list->array[list->size].type = type;
-    list->array[list->size].start = start;
-    list->array[list->size].end = end;
-    ++list->size;
-}
-
-pListElement listGet(pArrayList list, int idx) {
-    if (idx >= list->size || idx < 0)
-        return NULL;
-    return list->array + idx;
-}
-
-void listRemove(pArrayList list, int idx) {
-    if (idx >= list->size || idx < 0)
-        return;
-    --list->size;
-    memmove(list->array + idx, list->array + (idx + 1), (list->size - idx) * sizeof(listElement));
-}
-
-int checkElementType(pListElement p, char type) {
-    if (!p)
-        return 0;
-    return (p->type == type);
-}
-
-int getElementLength(pListElement p) {
-    if (!p)
-        return 0;
-    return p->end - p->start;
-}
-
-void pdf417init(pPdf417param param) {
-    param->options = 0;
-    param->outBits = NULL;
-    param->lenBits = 0;
-    param->error = 0;
-    param->lenText = -1;
-    param->text = "";
-    param->yHeight = 3;
-    param->aspectRatio = 0.5;
-}
-
-void pdf417free(pPdf417param param) {
-    if (param->outBits != NULL) {
-        free(param->outBits);
-        param->outBits = NULL;
-    }
-}
-
-void outCodeword17(pPdf417class p, int codeword) {
-    int bytePtr = p->bitPtr / 8;
-    int bit = p->bitPtr - bytePtr * 8;
-    p->param->outBits[bytePtr++] |= codeword >> (9 + bit);
-    p->param->outBits[bytePtr++] |= codeword >> (1 + bit);
-    codeword <<= 8;
-    p->param->outBits[bytePtr] |= codeword >> (1 + bit);
-    p->bitPtr += 17;
-}
-
-void outCodeword18(pPdf417class p, int codeword) {
-    int bytePtr = p->bitPtr / 8;
-    int bit = p->bitPtr - bytePtr * 8;
-    p->param->outBits[bytePtr++] |= codeword >> (10 + bit);
-    p->param->outBits[bytePtr++] |= codeword >> (2 + bit);
-    codeword <<= 8;
-    p->param->outBits[bytePtr] |= codeword >> (2 + bit);
-    if (bit == 7)
-        p->param->outBits[++bytePtr] |= 0x80;
-    p->bitPtr += 18;
-}
-
-void outCodeword(pPdf417class p, int codeword) {
-    outCodeword17(p, codeword);
-}
-
-void outStopPattern(pPdf417class p) {
-    outCodeword18(p, STOP_PATTERN);
-}
-
-void outStartPattern(pPdf417class p) {
-    outCodeword17(p, START_PATTERN);
-}
-
-void outPaintCode(pPdf417class p) {
-    int codePtr = 0;
-    int row;
-    int rowMod;
-    int *cluster;
-    int edge;
-    int column;
-    p->param->bitColumns = START_CODE_SIZE * (p->param->codeColumns + 3) + STOP_SIZE;
-    p->param->lenBits = ((p->param->bitColumns - 1) / 8 + 1) * p->param->codeRows;
-    p->param->outBits = (char*)malloc(p->param->lenBits);
-    memset(p->param->outBits, 0, p->param->lenBits);
-    for (row = 0; row < p->param->codeRows; ++row) {
-        p->bitPtr = ((p->param->bitColumns - 1) / 8 + 1) * 8 * row;
-        rowMod = row % 3;
-        cluster = CLUSTERS[rowMod];
-        outStartPattern(p);
-        edge = 0;
-        switch (rowMod) {
-        case 0:
-            edge = 30 * (row / 3) + ((p->param->codeRows - 1) / 3);
-            break;
-        case 1:
-            edge = 30 * (row / 3) + p->param->errorLevel * 3 + ((p->param->codeRows - 1) % 3);
-            break;
-        default:
-            edge = 30 * (row / 3) + p->param->codeColumns - 1;
-            break;
-        }
-        outCodeword(p, cluster[edge]);
-
-        for (column = 0; column < p->param->codeColumns; ++column) {
-            outCodeword(p, cluster[p->param->codewords[codePtr++]]);
-        }
-
-        switch (rowMod) {
-        case 0:
-            edge = 30 * (row / 3) + p->param->codeColumns - 1;
-            break;
-        case 1:
-            edge = 30 * (row / 3) + ((p->param->codeRows - 1) / 3);
-            break;
-        default:
-            edge = 30 * (row / 3) + p->param->errorLevel * 3 + ((p->param->codeRows - 1) % 3);
-            break;
-        }
-        outCodeword(p, cluster[edge]);
-        outStopPattern(p);
-    }
-    if (p->param->options & PDF417_INVERT_BITMAP) {
-        char* pm = p->param->outBits;
-        char* end = pm + p->param->lenBits;
-        while (pm < end)
-            *(pm++) ^= 0xff;
-    }
-}
-
-void calculateErrorCorrection(pPdf417class p, int dest) {
-    int t1 = 0;
-    int t2 = 0;
-    int t3 = 0;
-    int *A;
-    int Alength;
-    int *E;
-    int lastE;
-    int k, e, j;
-    if (p->param->errorLevel < 0 || p->param->errorLevel > 8)
-        p->param->errorLevel = 0;
-    A = ERROR_LEVEL[p->param->errorLevel];
-    Alength = 2 << p->param->errorLevel;
-    E = p->param->codewords + dest;
-    memset(E, 0, Alength * sizeof(int));
-    lastE = Alength - 1;
-    for (k = 0; k < p->param->lenCodewords; ++k) {
-        t1 = p->param->codewords[k] + E[0];
-        for (e = 0; e <= lastE; ++e) {
-            t2 = (t1 * A[lastE - e]) % MOD;
-            t3 = MOD - t2;
-            E[e] = ((e == lastE ? 0 : E[e + 1]) + t3) % MOD;
-        }
-    }
-    for (j = 0; j < Alength; ++j)
-        E[j] = (MOD - E[j]) % MOD;
-}
-
-static int getTextTypeAndValue(char* text, int size, int idx) {
-    int c;
-    char *ms, *ps;
-    if (idx >= size)
-        return 0;
-    c = text[idx];
-    if (c >= 'A' && c <= 'Z')
-        return (ALPHA + c - 'A');
-    if (c >= 'a' && c <= 'z')
-        return (LOWER + c - 'a');
-    if (c == ' ')
-        return (ALPHA + LOWER + MIXED + SPACE);
-    ms = strchr(MIXED_SET, c);
-    ps = strchr(PUNCTUATION_SET, c);
-    if (!ms && !ps)
-        return (ISBYTE + (c & 0xff));
-    if (ms - MIXED_SET == ps - PUNCTUATION_SET)
-        return (MIXED + PUNCTUATION + (ms - MIXED_SET));
-    if (ms != NULL)
-        return (MIXED + (ms - MIXED_SET));
-    return (PUNCTUATION + (ps - PUNCTUATION_SET));
-}
-
-void textCompaction(pPdf417class p, int start, int length) {
-    int dest[ABSOLUTE_MAX_TEXT_SIZE * 2];
-    char* text = p->param->text;
-    int mode = ALPHA;
-    int ptr = 0;
-    int fullBytes = 0;
-    int v = 0;
-    int k;
-    int size;
-    memset(dest, 0, sizeof(dest));
-    length += start;
-    for (k = start; k < length; ++k) {
-        v = getTextTypeAndValue(text, length, k);
-        if ((v & mode) != 0) {
-            dest[ptr++] = v & 0xff;
-            continue;
-        }
-        if ((v & ISBYTE) != 0) {
-            if ((ptr & 1) != 0) {
-                dest[ptr++] = (mode & PUNCTUATION) != 0 ? PAL : PS;
-                mode = (mode & PUNCTUATION) != 0 ? ALPHA : mode;
-            }
-            dest[ptr++] = BYTESHIFT;
-            dest[ptr++] = v & 0xff;
-            fullBytes += 2;
-            continue;
-        }
-        switch (mode) {
-        case ALPHA:
-            if ((v & LOWER) != 0) {
-                dest[ptr++] = LL;
-                dest[ptr++] = v & 0xff;
-                mode = LOWER;
-            }
-            else if ((v & MIXED) != 0) {
-                dest[ptr++] = ML;
-                dest[ptr++] = v & 0xff;
-                mode = MIXED;
-            }
-            else if ((getTextTypeAndValue(text, length, k + 1) & getTextTypeAndValue(text, length, k + 2) & PUNCTUATION) != 0) {
-                dest[ptr++] = ML;
-                dest[ptr++] = PL;
-                dest[ptr++] = v & 0xff;
-                mode = PUNCTUATION;
-            }
-            else {
-                dest[ptr++] = PS;
-                dest[ptr++] = v & 0xff;
-            }
-            break;
-        case LOWER:
-            if ((v & ALPHA) != 0) {
-                if ((getTextTypeAndValue(text, length, k + 1) & getTextTypeAndValue(text, length, k + 2) & ALPHA) != 0) {
-                    dest[ptr++] = ML;
-                    dest[ptr++] = AL;
-                    mode = ALPHA;
-                }
-                else {
-                    dest[ptr++] = AS;
-                }
-                dest[ptr++] = v & 0xff;
-            }
-            else if ((v & MIXED) != 0) {
-                dest[ptr++] = ML;
-                dest[ptr++] = v & 0xff;
-                mode = MIXED;
-            }
-            else if ((getTextTypeAndValue(text, length, k + 1) & getTextTypeAndValue(text, length, k + 2) & PUNCTUATION) != 0) {
-                dest[ptr++] = ML;
-                dest[ptr++] = PL;
-                dest[ptr++] = v & 0xff;
-                mode = PUNCTUATION;
-            }
-            else {
-                dest[ptr++] = PS;
-                dest[ptr++] = v & 0xff;
-            }
-            break;
-        case MIXED:
-            if ((v & LOWER) != 0) {
-                dest[ptr++] = LL;
-                dest[ptr++] = v & 0xff;
-                mode = LOWER;
-            }
-            else if ((v & ALPHA) != 0) {
-                dest[ptr++] = AL;
-                dest[ptr++] = v & 0xff;
-                mode = ALPHA;
-            }
-            else if ((getTextTypeAndValue(text, length, k + 1) & getTextTypeAndValue(text, length, k + 2) & PUNCTUATION) != 0) {
-                dest[ptr++] = PL;
-                dest[ptr++] = v & 0xff;
-                mode = PUNCTUATION;
-            }
-            else {
-                dest[ptr++] = PS;
-                dest[ptr++] = v & 0xff;
-            }
-            break;
-        case PUNCTUATION:
-            dest[ptr++] = PAL;
-            mode = ALPHA;
-            --k;
-            break;
-        }
-    }
-    if ((ptr & 1) != 0)
-        dest[ptr++] = PS;
-    size = (ptr + fullBytes) / 2;
-    if (size + p->cwPtr > MAX_DATA_CODEWORDS) {
-        p->param->error = PDF417_ERROR_TEXT_TOO_BIG;
-        return;
-    }
-    length = ptr;
-    ptr = 0;
-    while (ptr < length) {
-        v = dest[ptr++];
-        if (v >= 30) {
-            p->param->codewords[p->cwPtr++] = v;
-            p->param->codewords[p->cwPtr++] = dest[ptr++];
-        }
-        else
-            p->param->codewords[p->cwPtr++] = v * 30 + dest[ptr++];
-    }
-}
-
-static void basicNumberCompaction(pPdf417class p, int start, int length) {
-    char* text = p->param->text;
-    int* ret = p->param->codewords + p->cwPtr;
-    int retLast = length / 3;
-    int ni, k;
-    p->cwPtr += retLast + 1;
-    memset(ret, 0, (retLast + 1) * sizeof(int));
-    ret[retLast] = 1;
-    length += start;
-    for (ni = start; ni < length; ++ni) {
-        // multiply by 10
-        for (k = retLast; k >= 0; --k)
-            ret[k] *= 10;
-        // add the digit
-        ret[retLast] += text[ni] - '0';
-        // propagate carry
-        for (k = retLast; k > 0; --k) {
-            ret[k - 1] += ret[k] / 900;
-            ret[k] %= 900;
-        }
-    }
-}
-
-void numberCompaction(pPdf417class p, int start, int length) {
-    int full = (length / 44) * 15;
-    int size = length % 44;
-    int k;
-    if (size == 0)
-        size = full;
-    else
-        size = full + size / 3 + 1;
-    if (size + p->cwPtr > MAX_DATA_CODEWORDS) {
-        p->param->error = PDF417_ERROR_TEXT_TOO_BIG;
-        return;
-    }
-    length += start;
-    for (k = start; k < length; k += 44) {
-        size = length - k < 44 ? length - k : 44;
-        basicNumberCompaction(p, k, size);
-    }
-}
-
-static void byteCompaction6(pPdf417class p, int start) {
-    int length = 6;
-    char* text = p->param->text;
-    int* ret = p->param->codewords + p->cwPtr;
-    int retLast = 4;
-    int ni, k;
-    p->cwPtr += retLast + 1;
-    memset(ret, 0, (retLast + 1) * sizeof(int));
-    length += start;
-    for (ni = start; ni < length; ++ni) {
-        // multiply by 256
-        for (k = retLast; k >= 0; --k)
-            ret[k] *= 256;
-        // add the digit
-        ret[retLast] += (int)text[ni] & 0xff;
-        // propagate carry
-        for (k = retLast; k > 0; --k) {
-            ret[k - 1] += ret[k] / 900;
-            ret[k] %= 900;
-        }
-    }
-}
-
-void byteCompaction(pPdf417class p, int start, int length) {
-    int k, j;
-    int size = (length / 6) * 5 + (length % 6);
-    if (size + p->cwPtr > MAX_DATA_CODEWORDS) {
-        p->param->error = PDF417_ERROR_TEXT_TOO_BIG;
-        return;
-    }
-    length += start;
-    for (k = start; k < length; k += 6) {
-        size = length - k < 44 ? length - k : 6;
-        if (size < 6) {
-            for (j = 0; j < size; ++j)
-                p->param->codewords[p->cwPtr++] = (int)p->param->text[k + j] & 0xff;
-        }
-        else {
-            byteCompaction6(p, k);
-        }
-    }
-}
-
-void breakString(pPdf417class p, pArrayList list) {
-    char* text = p->param->text;
-    int textLength = p->param->lenText;
-    int lastP = 0;
-    int startN = 0;
-    int nd = 0;
-    char c = 0;
-    int k, ptrS, lastTxt, j, txt;
-    pListElement v;
-    pListElement vp;
-    pListElement vn;
-    list->size = 0;
-    for (k = 0; k < textLength; ++k) {
-        c = text[k];
-        if (c >= '0' && c <= '9') {
-            if (nd == 0)
-                startN = k;
-            ++nd;
-            continue;
-        }
-        if (nd >= 13) {
-            if (lastP != startN) {
-                c = text[lastP];
-                ptrS = lastP;
-                lastTxt = (c >= ' ' && c < 127) || c == '\r' || c == '\n' || c == '\t';
-                for (j = lastP; j < startN; ++j) {
-                    c = text[j];
-                    txt = (c >= ' ' && c < 127) || c == '\r' || c == '\n' || c == '\t';
-                    if (txt != lastTxt) {
-                        listAdd(list, (char)(lastTxt ? 'T' : 'B'), lastP, j);
-                        lastP = j;
-                        lastTxt = txt;
-                    }
-                }
-                listAdd(list, (char)(lastTxt ? 'T' : 'B'), lastP, startN);
-            }
-            listAdd(list, 'N', startN, k);
-            lastP = k;
-        }
-        nd = 0;
-    }
-    if (nd < 13)
-        startN = textLength;
-    if (lastP != startN) {
-        c = text[lastP];
-        ptrS = lastP;
-        lastTxt = (c >= ' ' && c < 127) || c == '\r' || c == '\n' || c == '\t';
-        for (j = lastP; j < startN; ++j) {
-            c = text[j];
-            txt = (c >= ' ' && c < 127) || c == '\r' || c == '\n' || c == '\t';
-            if (txt != lastTxt) {
-                listAdd(list, (char)(lastTxt ? 'T' : 'B'), lastP, j);
-                lastP = j;
-                lastTxt = txt;
-            }
-        }
-        listAdd(list, (char)(lastTxt ? 'T' : 'B'), lastP, startN);
-    }
-    if (nd >= 13)
-        listAdd(list, 'N', startN, textLength);
-    //optimize
-    //merge short binary
-    for (k = 0; k < list->size; ++k) {
-        v = listGet(list, k);
-        vp = listGet(list, k - 1);
-        vn = listGet(list, k + 1);;
-        if (checkElementType(v, 'B') && getElementLength(v) == 1) {
-            if (checkElementType(vp, 'T') && checkElementType(vn, 'T')
-                && getElementLength(vp) + getElementLength(vn) >= 3) {
-                vp->end = vn->end;
-                listRemove(list, k);
-                listRemove(list, k);
-                k = -1;
-                continue;
-            }
-        }
-    }
-    //merge text sections
-    for (k = 0; k < list->size; ++k) {
-        v = listGet(list, k);
-        vp = listGet(list, k - 1);
-        vn = listGet(list, k + 1);;
-        if (checkElementType(v, 'T') && getElementLength(v) >= 5) {
-            int redo = 0;
-            if ((checkElementType(vp, 'B') && getElementLength(vp) == 1) || checkElementType(vp, 'T')) {
-                redo = 1;
-                v->start = vp->start;
-                listRemove(list, k - 1);
-                --k;
-            }
-            if ((checkElementType(vn, 'B') && getElementLength(vn) == 1) || checkElementType(vn, 'T')) {
-                redo = 1;
-                v->end = vn->end;
-                listRemove(list, k + 1);
-            }
-            if (redo) {
-                k = -1;
-                continue;
-            }
-        }
-    }
-    //merge binary sections
-    for (k = 0; k < list->size; ++k) {
-        v = listGet(list, k);
-        vp = listGet(list, k - 1);
-        vn = listGet(list, k + 1);;
-        if (checkElementType(v, 'B')) {
-            int redo = 0;
-            if ((checkElementType(vp, 'T') && getElementLength(vp) < 5) || checkElementType(vp, 'B')) {
-                redo = 1;
-                v->start = vp->start;
-                listRemove(list, k - 1);
-                --k;
-            }
-            if ((checkElementType(vn, 'T') && getElementLength(vn) < 5) || checkElementType(vn, 'B')) {
-                redo = 1;
-                v->end = vn->end;
-                listRemove(list, k + 1);
-            }
-            if (redo) {
-                k = -1;
-                continue;
-            }
-        }
-    }
-    // check if all numbers
-    if (list->size == 1 && (v = listGet(list, 0))->type == 'T' && getElementLength(v) >= 8) {
-        for (k = v->start; k < v->end; ++k) {
-            c = text[k];
-            if (c < '0' || c > '9')
-                break;
-        }
-        if (k == v->end)
-            v->type = 'N';
-    }
-}
-
-void assemble(pPdf417class p, pArrayList list) {
-    int k;
-    if (list->size == 0)
-        return;
-    p->cwPtr = 1;
-    for (k = 0; k < list->size; ++k) {
-        pListElement v = listGet(list, k);
-        switch (v->type) {
-        case 'T':
-            if (k != 0)
-                p->param->codewords[p->cwPtr++] = TEXT_MODE;
-            textCompaction(p, v->start, v->end - v->start);
-            break;
-        case 'N':
-            p->param->codewords[p->cwPtr++] = NUMERIC_MODE;
-            numberCompaction(p, v->start, v->end - v->start);
-            break;
-        case 'B':
-            p->param->codewords[p->cwPtr++] = (v->end - v->start) % 6 ? BYTE_MODE : BYTE_MODE_6;
-            byteCompaction(p, v->start, v->end - v->start);
-            break;
-        }
-        if (p->param->error)
-            return;
-    }
-}
-
-static int maxPossibleErrorLevel(int remain) {
-    int level = 8;
-    int size = 512;
-    while (level > 0) {
-        if (remain >= size)
-            return level;
-        --level;
-        size >>= 1;
-    }
-    return 0;
-}
-
-void dumpList(pPdf417class p, pArrayList list) {
-    int k;
-    if (list->size == 0)
-        return;
-    for (k = 0; k < list->size; ++k) {
-        pListElement v = listGet(list, k);
-        printf("%c%.*s\n", v->type, v->end - v->start, p->param->text + v->start);
-    }
-}
-
-static int getMaxSquare(pPdf417param p) {
-    if (p->codeColumns > 21) {
-        p->codeColumns = 29;
-        p->codeRows = 32;
-    }
-    else {
-        p->codeColumns = 16;
-        p->codeRows = 58;
-    }
-    return MAX_DATA_CODEWORDS + 2;
-}
-
-void paintCode(pPdf417param p) {
-    pdf417class pp;
-    arrayList list;
-    int maxErr, fixedColumn, lenErr, tot, skipRowColAdjust, pad;
-    pp.param = p;
-    p->error = 0;
-    if (p->options & PDF417_USE_RAW_CODEWORDS) {
-        if (p->lenCodewords > MAX_DATA_CODEWORDS || p->lenCodewords < 1 || p->lenCodewords != p->codewords[0]) {
-            p->error = PDF417_ERROR_INVALID_PARAMS;
-            return;
-        }
-    }
-    else {
-        if (p->lenText < 0)
-            p->lenText = strlen(p->text);
-        if (p->lenText > ABSOLUTE_MAX_TEXT_SIZE) {
-            p->error = PDF417_ERROR_TEXT_TOO_BIG;
-            return;
-        }
-        listInit(&list);
-        breakString(&pp, &list);
-        //dumpList(&pp, &list);
-        assemble(&pp, &list);
-        listFree(&list);
-        if (p->error)
-            return;
-        p->codewords[0] = p->lenCodewords = pp.cwPtr;
-    }
-    maxErr = maxPossibleErrorLevel(MAX_DATA_CODEWORDS + 2 - p->lenCodewords);
-    if (!(p->options & PDF417_USE_ERROR_LEVEL)) {
-        if (p->lenCodewords < 41)
-            p->errorLevel = 2;
-        else if (p->lenCodewords < 161)
-            p->errorLevel = 3;
-        else if (p->lenCodewords < 321)
-            p->errorLevel = 4;
-        else
-            p->errorLevel = 5;
-    }
-    if (p->errorLevel < 0)
-        p->errorLevel = 0;
-    else if (p->errorLevel > maxErr)
-        p->errorLevel = maxErr;
-    if (p->codeColumns < 1)
-        p->codeColumns = 1;
-    else if (p->codeColumns > 30)
-        p->codeColumns = 30;
-    if (p->codeRows < 3)
-        p->codeRows = 3;
-    else if (p->codeRows > 90)
-        p->codeRows = 90;
-    lenErr = 2 << p->errorLevel;
-    fixedColumn = !(p->options & PDF417_FIXED_ROWS);
-    skipRowColAdjust = 0;
-    tot = p->lenCodewords + lenErr;
-    if (p->options & PDF417_FIXED_RECTANGLE) {
-        tot = p->codeColumns * p->codeRows;
-        if (tot > MAX_DATA_CODEWORDS + 2) {
-            tot = getMaxSquare(p);
-        }
-        if (tot < p->lenCodewords + lenErr)
-            tot = p->lenCodewords + lenErr;
-        else
-            skipRowColAdjust = 1;
-    }
-    else if (!(p->options & (PDF417_FIXED_COLUMNS | PDF417_FIXED_ROWS))) {
-        double c, b;
-        fixedColumn = 1;
-        if (p->aspectRatio < 0.001)
-            p->aspectRatio = 0.001f;
-        else if (p->aspectRatio > 1000)
-            p->aspectRatio = 1000;
-        b = 73 * p->aspectRatio - 4;
-        c = (-b + sqrt(b * b + 4 * 17 * p->aspectRatio * (p->lenCodewords + lenErr) * p->yHeight)) / (2 * 17 * p->aspectRatio);
-        p->codeColumns = (int)(c + 0.5);
-        if (p->codeColumns < 1)
-            p->codeColumns = 1;
-        else if (p->codeColumns > 30)
-            p->codeColumns = 30;
-    }
-    if (!skipRowColAdjust) {
-        if (fixedColumn) {
-            p->codeRows = (tot - 1) / p->codeColumns + 1;
-            if (p->codeRows < 3)
-                p->codeRows = 3;
-            else if (p->codeRows > 90) {
-                p->codeRows = 90;
-                p->codeColumns = (tot - 1) / 90 + 1;
-            }
-        }
-        else {
-            p->codeColumns = (tot - 1) / p->codeRows + 1;
-            if (p->codeColumns > 30) {
-                p->codeColumns = 30;
-                p->codeRows = (tot - 1) / 30 + 1;
-            }
-        }
-        tot = p->codeRows * p->codeColumns;
-    }
-    if (tot > MAX_DATA_CODEWORDS + 2) {
-        tot = getMaxSquare(p);
-    }
-    p->errorLevel = maxPossibleErrorLevel(tot - p->lenCodewords);
-    lenErr = 2 << p->errorLevel;
-    pad = tot - lenErr - p->lenCodewords;
-    pp.cwPtr = p->lenCodewords;
-    while (pad--)
-        p->codewords[pp.cwPtr++] = TEXT_MODE;
-    p->codewords[0] = p->lenCodewords = pp.cwPtr;
-    calculateErrorCorrection(&pp, pp.param->lenCodewords);
-    pp.param->lenCodewords = tot;
-    outPaintCode(&pp);
-}
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/Graphic/src/zintPixelRow.cpp b/SelfServiceCommon/Massai/cpp/Graphic/src/zintPixelRow.cpp
new file mode 100644
index 00000000..504a0299
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Graphic/src/zintPixelRow.cpp
@@ -0,0 +1,56 @@
+// create PixelRows from zint bitmap
+
+#include "graphic/zintPixelRow.h"
+
+using MASSAI::text::StringBuffer;
+using MASSAI::BitArray;
+
+namespace MASSAI
+{
+  namespace Barcode
+  {
+    ZintPixelRows::ZintPixelRows(size_t blockWidth, size_t blockHeight, size_t width, size_t height, char* bitmap):
+      m_width(width * blockWidth),
+      m_rows(height),
+      m_blockHeight(blockHeight)
+    {
+      m_bitmapRows.reserve(m_rows);
+      for(size_t y = 0; y < height; y++)
+      {
+        size_t columnIndex = y * width * 3;
+        BitArray dest(m_width);
+        for(size_t x = 0; x < width; x++)
+        {
+          size_t index = columnIndex + x * 3;
+          dest.set(x * blockWidth, bitmap[index] != 0, blockWidth);
+        }
+        m_bitmapRows.push_back(dest.buffer());
+      }
+    }
+
+    ZintPixelRows::~ZintPixelRows()
+    {}
+
+    size_t ZintPixelRows::getHeight() const
+    {
+      return m_rows * m_blockHeight;
+    }
+
+    size_t ZintPixelRows::getWidth() const
+    {
+      return m_width;
+    }
+
+    const StringBuffer& ZintPixelRows::getRow(size_t y) const
+    {
+      if(y < getHeight())
+      {
+        return m_bitmapRows[y / m_blockHeight];
+      }
+      else
+      {
+        return m_bitmapRows[0];
+      }
+    }
+  }
+}
-- 
2.41.0.windows.1

