From 6ff7cbd46763703e6d34fa106f64765f223363a4 Mon Sep 17 00:00:00 2001
From: tgeisler <tgeisler@90b65887-3827-0410-9a23-83215b262276>
Date: Wed, 31 Jul 2013 09:05:23 +0000
Subject: [PATCH 0449/1076] MANTIS0028310: Plattform build: Integrate external
 CUSS repository

git-svn-id: svn://localhost/SelfServiceCommon/trunk@547 90b65887-3827-0410-9a23-83215b262276
---
 .../Interfaces/inc/CussIF/atb2Scanner.h       |   81 +
 .../Interfaces/inc/CussIF/atbreader.h         |  285 ++
 .../Interfaces/inc/CussIF/baggagedev.h        |  272 ++
 .../Interfaces/inc/CussIF/bcsdev.h            |  198 ++
 .../Interfaces/inc/CussIF/bppdev.h            |  405 +++
 .../Interfaces/inc/CussIF/btpScanner.h        |   73 +
 .../Interfaces/inc/CussIF/btpdev.h            |  240 ++
 .../Interfaces/inc/CussIF/callbackthread.h    |  109 +
 .../Interfaces/inc/CussIF/clock.h             |  159 +
 .../Interfaces/inc/CussIF/cuss_component.h    |  563 ++++
 .../Interfaces/inc/CussIF/cussif.h            |  638 ++++
 .../Interfaces/inc/CussIF/cussif_component.h  |  276 ++
 .../Interfaces/inc/CussIF/dispclnt.h          |   79 +
 .../Interfaces/inc/CussIF/dispdev.h           |  386 +++
 .../Interfaces/inc/CussIF/escrowdev.h         |  203 ++
 .../Interfaces/inc/CussIF/fprdev.h            |  160 +
 .../Interfaces/inc/CussIF/gppdevice.h         |  226 ++
 .../Interfaces/inc/CussIF/language.h          |   81 +
 .../Interfaces/inc/CussIF/manufacturer.h      |   58 +
 .../Interfaces/inc/CussIF/mcdev.h             |  362 +++
 .../Interfaces/inc/CussIF/pdf417.h            |   33 +
 .../Interfaces/inc/CussIF/polling.h           |   87 +
 .../Interfaces/inc/CussIF/pprdev.h            |  206 ++
 .../Interfaces/inc/CussIF/vcomp.h             |  375 +++
 .../Interfaces/inc/atb2Scanner.h              |    9 +
 SelfServiceCommon/Interfaces/inc/atbreader.h  |    9 +
 SelfServiceCommon/Interfaces/inc/baggagedev.h |    9 +
 SelfServiceCommon/Interfaces/inc/bcsdev.h     |    9 +
 SelfServiceCommon/Interfaces/inc/bppdev.h     |    9 +
 SelfServiceCommon/Interfaces/inc/btpScanner.h |    9 +
 SelfServiceCommon/Interfaces/inc/btpdev.h     |    9 +
 .../Interfaces/inc/callbackthread.h           |    9 +
 SelfServiceCommon/Interfaces/inc/clock.h      |    9 +
 SelfServiceCommon/Interfaces/inc/cussif.h     |    9 +
 SelfServiceCommon/Interfaces/inc/dispclnt.h   |    9 +
 SelfServiceCommon/Interfaces/inc/dispdev.h    |    9 +
 SelfServiceCommon/Interfaces/inc/escrowdev.h  |    9 +
 SelfServiceCommon/Interfaces/inc/fprdev.h     |    9 +
 SelfServiceCommon/Interfaces/inc/gppdevice.h  |    9 +
 .../Interfaces/inc/initIDL/initgmrdev.h       |   24 +
 SelfServiceCommon/Interfaces/inc/initgmrdev.h |    9 +
 SelfServiceCommon/Interfaces/inc/language.h   |    9 +
 .../Interfaces/inc/manufacturer.h             |    9 +
 SelfServiceCommon/Interfaces/inc/mcdev.h      |    9 +
 SelfServiceCommon/Interfaces/inc/pdf417.h     |    9 +
 SelfServiceCommon/Interfaces/inc/polling.h    |    9 +
 SelfServiceCommon/Interfaces/inc/pprdev.h     |    9 +
 .../Interfaces/inc/textIDL/textAppControl.h   |   27 +
 .../inc/textIDL/textcharacteristics.h         |   67 +
 .../Interfaces/inc/textIDL/textcodes.h        |   46 +
 .../Interfaces/inc/textIDL/textgppdev.h       |   45 +
 .../Interfaces/inc/textIDL/textmdci.h         |   37 +
 .../Interfaces/inc/textIDL/texttypes.h        |  130 +
 SelfServiceCommon/Interfaces/inc/vcomp.h      |    9 +
 SelfServiceCommon/Massai/cpp/CussIF/doxyfile  |  234 ++
 .../Massai/cpp/CussIF/doxyfooter.html         |   15 +
 .../Massai/cpp/CussIF/doxyheader.html         |   33 +
 .../Massai/cpp/CussIF/inc/XMLScreen.h         |   25 +
 .../Massai/cpp/CussIF/inc/check.h             |   24 +
 .../Massai/cpp/CussIF/inc/client.h            |   96 +
 .../Massai/cpp/CussIF/inc/client_def.h        |   16 +
 .../Massai/cpp/CussIF/inc/dispMap.h           |   60 +
 .../Massai/cpp/CussIF/inc/pdf417lib.h         |   83 +
 .../Massai/cpp/CussIF/inc/pdf417libimp.h      |  514 ++++
 .../Massai/cpp/CussIF/inc/tracedef.h          |   44 +
 .../Massai/cpp/CussIF/mainpage.dox            |   37 +
 .../Massai/cpp/CussIF/makefile.mak            |  204 ++
 .../Massai/cpp/CussIF/massai.css              |  216 ++
 .../Massai/cpp/CussIF/materna.GIF             |  Bin 0 -> 3794 bytes
 .../Massai/cpp/CussIF/res/client.rc           |  107 +
 SelfServiceCommon/Massai/cpp/CussIF/sed.inp   |    2 +
 .../Massai/cpp/CussIF/src/Atb2Scanner.l       |  534 ++++
 .../Massai/cpp/CussIF/src/TestCallback.cpp    |   75 +
 .../Massai/cpp/CussIF/src/XMLScreen.cpp       |  269 ++
 .../Massai/cpp/CussIF/src/appmgr.cpp          | 2399 +++++++++++++++
 .../Massai/cpp/CussIF/src/atb2.cpp            | 2642 +++++++++++++++++
 .../Massai/cpp/CussIF/src/atbreader.cpp       | 1218 ++++++++
 .../Massai/cpp/CussIF/src/baggage.cpp         |  887 ++++++
 .../Massai/cpp/CussIF/src/bcs.cpp             |  682 +++++
 .../Massai/cpp/CussIF/src/btp.cpp             | 1048 +++++++
 .../Massai/cpp/CussIF/src/btpScanner.l        |  263 ++
 .../Massai/cpp/CussIF/src/callbackthread.cpp  |  162 +
 .../Massai/cpp/CussIF/src/check.cpp           |   38 +
 .../Massai/cpp/CussIF/src/client.cpp          |  628 ++++
 .../Massai/cpp/CussIF/src/clock.cpp           |  392 +++
 .../Massai/cpp/CussIF/src/cuss_component.cpp  | 1390 +++++++++
 .../Massai/cpp/CussIF/src/cussapp.cpp         | 1509 ++++++++++
 .../Massai/cpp/CussIF/src/cussif.cpp          |   89 +
 .../cpp/CussIF/src/cussif_component.cpp       |  676 +++++
 .../Massai/cpp/CussIF/src/dispMap.cpp         | 1414 +++++++++
 .../Massai/cpp/CussIF/src/dispXTRA.cpp        |  397 +++
 .../Massai/cpp/CussIF/src/dispclnt.cpp        |  507 ++++
 .../Massai/cpp/CussIF/src/displayTest.cpp     |  114 +
 .../Massai/cpp/CussIF/src/escrow.cpp          |  870 ++++++
 .../Massai/cpp/CussIF/src/fpr.cpp             |  421 +++
 .../Massai/cpp/CussIF/src/gpp.cpp             |  508 ++++
 .../Massai/cpp/CussIF/src/language.cpp        |  224 ++
 .../Massai/cpp/CussIF/src/local_def.cpp       |  211 ++
 .../Massai/cpp/CussIF/src/magcard.cpp         | 1239 ++++++++
 .../Massai/cpp/CussIF/src/manufacturer.cpp    |   67 +
 .../Massai/cpp/CussIF/src/pdf417.cpp          |  230 ++
 .../Massai/cpp/CussIF/src/pdf417lib.cpp       |  815 +++++
 .../Massai/cpp/CussIF/src/ppr.cpp             |  654 ++++
 .../Massai/cpp/CussIF/src/svg.cpp             |  212 ++
 .../Massai/cpp/CussIF/src/testLevel.cpp       |  118 +
 .../cpp/CussIF/src/testScreenConversion.cpp   |   84 +
 .../Massai/cpp/CussIF/src/testapp.cpp         |  649 ++++
 .../Massai/cpp/CussIF/src/testscanner.cpp     |  100 +
 .../Massai/cpp/CussIF/src/trace.cpp           |  449 +++
 .../Massai/cpp/CussIF/src/vcomp.cpp           |  278 ++
 .../Massai/cpp/CussIF/static/makefile.mak     |   77 +
 .../Massai/cpp/CussIF/static/sed.inp          |    2 +
 .../Massai/cpp/initIDL/makefile.mak           |   26 +
 .../Massai/cpp/initIDL/src/initgmrdev.cpp     |   53 +
 .../Massai/cpp/initIDL/src/local_def.cpp      |   17 +
 .../Massai/cpp/textIDL/inc/textIDL.h          |   18 +
 .../Massai/cpp/textIDL/makefile.mak           |   32 +
 .../Massai/cpp/textIDL/src/local_def.cpp      |   43 +
 .../Massai/cpp/textIDL/src/textappcontrol.cpp |   84 +
 .../cpp/textIDL/src/textcharacteristics.cpp   |  381 +++
 .../Massai/cpp/textIDL/src/textcodes.cpp      |  335 +++
 .../Massai/cpp/textIDL/src/textgppdev.cpp     |  294 ++
 .../Massai/cpp/textIDL/src/textidl.cpp        |   39 +
 .../Massai/cpp/textIDL/src/textmdci.cpp       |   96 +
 .../Massai/cpp/textIDL/src/texttypes.cpp      |  871 ++++++
 .../Massai/cpp/textIDL/static/makefile.mak    |   33 +
 SelfServiceCommon/Massai/idl/.classpath       |    7 +
 SelfServiceCommon/Massai/idl/.project         |   17 +
 .../Massai/idl/Cuss/characteristics.idl       |  560 ++++
 SelfServiceCommon/Massai/idl/Cuss/codes.idl   |  299 ++
 SelfServiceCommon/Massai/idl/Cuss/comps.idl   |  741 +++++
 SelfServiceCommon/Massai/idl/Cuss/comps.sed   |    2 +
 .../Massai/idl/Cuss/comps.tao140.idl          |  731 +++++
 SelfServiceCommon/Massai/idl/Cuss/doxyfile    |  226 ++
 .../Massai/idl/Cuss/doxyfooter.html           |   15 +
 .../Massai/idl/Cuss/doxyheader.html           |   33 +
 .../Massai/idl/Cuss/mainpage.dox              |  161 +
 .../Massai/idl/Cuss/makefile.mak              |   31 +
 SelfServiceCommon/Massai/idl/Cuss/massai.css  |  216 ++
 SelfServiceCommon/Massai/idl/Cuss/materna.GIF |  Bin 0 -> 3794 bytes
 SelfServiceCommon/Massai/idl/Cuss/types.idl   |  506 ++++
 .../Massai/idl/Massai/BarCodeScannerDev.idl   |  138 +
 .../Massai/idl/Massai/ConveyorDev.idl         |  283 ++
 .../Massai/idl/Massai/DeviceTest.idl          |  233 ++
 .../Massai/idl/Massai/PassportReaderDev.idl   |  154 +
 .../Massai/idl/Massai/ScaleDev.idl            |  116 +
 .../Massai/idl/Massai/atb2dev.idl             |  169 ++
 .../Massai/idl/Massai/display.idl             |  102 +
 .../Massai/idl/Massai/doordev.idl             |  240 ++
 SelfServiceCommon/Massai/idl/Massai/gmdev.idl |   62 +
 .../Massai/idl/Massai/gmrdev.idl              |  316 ++
 .../Massai/idl/Massai/gppdev.idl              |  161 +
 SelfServiceCommon/Massai/idl/Massai/icntc.idl |   87 +
 .../Massai/idl/Massai/magcarddev.idl          |  158 +
 .../Massai/idl/Massai/makefile.mak            |   18 +-
 .../Massai/idl/Massai/platform.idl            |  288 ++
 .../Massai/idl/Massai/platformgui.idl         |   34 +
 .../Massai/idl/Massai/screendev.idl           |   66 +
 .../Massai/idl/Massai/seldev.idl              |  216 ++
 159 files changed, 41096 insertions(+), 1 deletion(-)
 create mode 100644 SelfServiceCommon/Interfaces/inc/CussIF/atb2Scanner.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/CussIF/atbreader.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/CussIF/baggagedev.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/CussIF/bcsdev.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/CussIF/bppdev.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/CussIF/btpScanner.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/CussIF/btpdev.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/CussIF/callbackthread.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/CussIF/clock.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/CussIF/cuss_component.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/CussIF/cussif.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/CussIF/cussif_component.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/CussIF/dispclnt.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/CussIF/dispdev.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/CussIF/escrowdev.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/CussIF/fprdev.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/CussIF/gppdevice.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/CussIF/language.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/CussIF/manufacturer.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/CussIF/mcdev.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/CussIF/pdf417.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/CussIF/polling.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/CussIF/pprdev.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/CussIF/vcomp.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/atb2Scanner.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/atbreader.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/baggagedev.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/bcsdev.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/bppdev.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/btpScanner.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/btpdev.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/callbackthread.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/clock.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/cussif.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/dispclnt.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/dispdev.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/escrowdev.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/fprdev.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/gppdevice.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/initIDL/initgmrdev.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/initgmrdev.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/language.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/manufacturer.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/mcdev.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/pdf417.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/polling.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/pprdev.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/textIDL/textAppControl.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/textIDL/textcharacteristics.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/textIDL/textcodes.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/textIDL/textgppdev.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/textIDL/textmdci.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/textIDL/texttypes.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/vcomp.h
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/doxyfile
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/doxyfooter.html
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/doxyheader.html
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/inc/XMLScreen.h
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/inc/check.h
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/inc/client.h
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/inc/client_def.h
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/inc/dispMap.h
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/inc/pdf417lib.h
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/inc/pdf417libimp.h
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/inc/tracedef.h
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/mainpage.dox
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/makefile.mak
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/massai.css
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/materna.GIF
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/res/client.rc
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/sed.inp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/Atb2Scanner.l
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/TestCallback.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/XMLScreen.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/appmgr.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/atb2.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/atbreader.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/baggage.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/bcs.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/btp.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/btpScanner.l
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/callbackthread.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/check.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/client.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/clock.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/cuss_component.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/cussapp.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/cussif.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/cussif_component.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/dispMap.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/dispXTRA.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/dispclnt.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/displayTest.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/escrow.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/fpr.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/gpp.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/language.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/local_def.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/magcard.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/manufacturer.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/pdf417.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/pdf417lib.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/ppr.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/svg.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/testLevel.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/testScreenConversion.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/testapp.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/testscanner.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/trace.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/src/vcomp.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/static/makefile.mak
 create mode 100644 SelfServiceCommon/Massai/cpp/CussIF/static/sed.inp
 create mode 100644 SelfServiceCommon/Massai/cpp/initIDL/makefile.mak
 create mode 100644 SelfServiceCommon/Massai/cpp/initIDL/src/initgmrdev.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/initIDL/src/local_def.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/textIDL/inc/textIDL.h
 create mode 100644 SelfServiceCommon/Massai/cpp/textIDL/makefile.mak
 create mode 100644 SelfServiceCommon/Massai/cpp/textIDL/src/local_def.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/textIDL/src/textappcontrol.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/textIDL/src/textcharacteristics.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/textIDL/src/textcodes.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/textIDL/src/textgppdev.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/textIDL/src/textidl.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/textIDL/src/textmdci.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/textIDL/src/texttypes.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/textIDL/static/makefile.mak
 create mode 100644 SelfServiceCommon/Massai/idl/.classpath
 create mode 100644 SelfServiceCommon/Massai/idl/.project
 create mode 100644 SelfServiceCommon/Massai/idl/Cuss/characteristics.idl
 create mode 100644 SelfServiceCommon/Massai/idl/Cuss/codes.idl
 create mode 100644 SelfServiceCommon/Massai/idl/Cuss/comps.idl
 create mode 100644 SelfServiceCommon/Massai/idl/Cuss/comps.sed
 create mode 100644 SelfServiceCommon/Massai/idl/Cuss/comps.tao140.idl
 create mode 100644 SelfServiceCommon/Massai/idl/Cuss/doxyfile
 create mode 100644 SelfServiceCommon/Massai/idl/Cuss/doxyfooter.html
 create mode 100644 SelfServiceCommon/Massai/idl/Cuss/doxyheader.html
 create mode 100644 SelfServiceCommon/Massai/idl/Cuss/mainpage.dox
 create mode 100644 SelfServiceCommon/Massai/idl/Cuss/makefile.mak
 create mode 100644 SelfServiceCommon/Massai/idl/Cuss/massai.css
 create mode 100644 SelfServiceCommon/Massai/idl/Cuss/materna.GIF
 create mode 100644 SelfServiceCommon/Massai/idl/Cuss/types.idl
 create mode 100644 SelfServiceCommon/Massai/idl/Massai/BarCodeScannerDev.idl
 create mode 100644 SelfServiceCommon/Massai/idl/Massai/ConveyorDev.idl
 create mode 100644 SelfServiceCommon/Massai/idl/Massai/DeviceTest.idl
 create mode 100644 SelfServiceCommon/Massai/idl/Massai/PassportReaderDev.idl
 create mode 100644 SelfServiceCommon/Massai/idl/Massai/ScaleDev.idl
 create mode 100644 SelfServiceCommon/Massai/idl/Massai/atb2dev.idl
 create mode 100644 SelfServiceCommon/Massai/idl/Massai/display.idl
 create mode 100644 SelfServiceCommon/Massai/idl/Massai/doordev.idl
 create mode 100644 SelfServiceCommon/Massai/idl/Massai/gmdev.idl
 create mode 100644 SelfServiceCommon/Massai/idl/Massai/gmrdev.idl
 create mode 100644 SelfServiceCommon/Massai/idl/Massai/gppdev.idl
 create mode 100644 SelfServiceCommon/Massai/idl/Massai/icntc.idl
 create mode 100644 SelfServiceCommon/Massai/idl/Massai/magcarddev.idl
 create mode 100644 SelfServiceCommon/Massai/idl/Massai/platform.idl
 create mode 100644 SelfServiceCommon/Massai/idl/Massai/platformgui.idl
 create mode 100644 SelfServiceCommon/Massai/idl/Massai/screendev.idl
 create mode 100644 SelfServiceCommon/Massai/idl/Massai/seldev.idl

diff --git a/SelfServiceCommon/Interfaces/inc/CussIF/atb2Scanner.h b/SelfServiceCommon/Interfaces/inc/CussIF/atb2Scanner.h
new file mode 100644
index 00000000..22b57549
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/CussIF/atb2Scanner.h
@@ -0,0 +1,81 @@
+//---------------------------------------------------------------------------
+//
+//  file:       atb2Scanner.h
+//
+//  purpose:    Scanner to find CUSS papertype from AEA commands
+//
+//  date:       30.04.2002, 14:16
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+/** Header file for AEA data scanner
+
+ @file      atb2Scanner.h
+ @date      02.05.2002
+ @version   1.0
+ @author    AGe - (C) Materna Information & Communications
+
+*/
+
+#ifndef ATB2SCANNER_H
+#define ATB2SCANNER_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+// forward reference to real scanner class
+
+class atb2ScannerHandle;
+
+namespace MASSAI
+{
+
+/** Interface implementation for an ATB2 datastream scanner.
+*/
+
+class atb2Scanner
+{
+private:
+
+    atb2ScannerHandle *scanner;
+
+public:
+
+    /** Paper type mapping */
+
+    enum PaperTypes { Unknown,              /**< 0 Unkown papertype */
+                      Setup,                /**< 1 Virtual papertype used for PECTABS, LOGOS etc.*/
+                      Ticket,               /**< 2 Ticket datastream like TK#xyz */
+                      BoardingPass,         /**< 3 Boarding pass datastream like CP#xyz */
+                      InsertedDoc,          /**< 4 Boarding pass datastream like CI#xyz or TR#xyz */
+                      GeneralPuposeDoc,     /**< 5 Ticket datastream like TK#xyz when no according stock available */
+                      BoardingPassFirst,    /**< 6 Boarding pass datastream like CP#xyz for first class ticket*/
+                      BoardingPassBusiness, /**< 7 Boarding pass datastream like CP#xyz for business class ticket*/
+                      BoardingPassEconomy,  /**< 8 Boarding pass datastream like CP#xyz for economy class ticket*/
+                      Error,                /**< 9 Error encountered in datastream */
+                      PreferTicket,         /**<   No Papertype specified, print command is TK */
+                      PreferBoardingPass,   /**<   No Papertype specified, print command is CP */
+                    };
+
+    /** Tries to find the papertype from the AEA datastream.
+        @param pszAEA - Data to be sent to the printer
+        @return values as specified in PaperTypes enumeration
+    */
+
+    PaperTypes checkPaperType(const char *pszAEA);
+
+    /** class constructor */
+
+    atb2Scanner();
+
+    /** class destructor */
+
+   ~atb2Scanner();
+};
+
+}; // namespace MASSAI
+
+#endif // ATB2SCANNER_H
diff --git a/SelfServiceCommon/Interfaces/inc/CussIF/atbreader.h b/SelfServiceCommon/Interfaces/inc/CussIF/atbreader.h
new file mode 100644
index 00000000..295548c2
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/CussIF/atbreader.h
@@ -0,0 +1,285 @@
+//---------------------------------------------------------------------------
+//
+//  file:       atbreader.h
+//
+//  purpose:    Boarding Pass Printer device definition
+//
+//  date:       25.04.2002, 15:41
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+/** Header file for boarding pass printer implementation
+
+ @file      atbreader.h
+ @date      25.04.2002
+ @version   1.0
+ @author    AGe - (C) Materna Information & Communications
+
+*/
+
+#ifndef ATBREADER_H
+#define ATBREADER_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#ifndef CUSSIF_H
+
+#include <signal.h>
+
+#include "orbincdefs.h"
+
+#include "comps.h"
+#include "types.h"
+#include "codes.h"
+
+#include "orbs.h"
+#include "vcomp.h"
+
+#endif // CUSSIF_H
+
+#include "atb2Scanner.h"
+#include "manufacturer.h"
+#include "callbackthread.h"
+#include "cussif/cussif_component.h"
+
+
+using namespace CORBA;
+using namespace types;
+using namespace Components;
+//using namespace Characteristics;
+
+namespace MASSAI
+{
+class amInterface;
+
+/** Interface implementation for the Boarding Pass Printer device.
+    This class hides all the handling for the virtual components that make up
+    a Boarding Pass Printer device.
+*/
+
+class atbReader : public vManufacturer,
+                  public vCompReader,
+                  public vCompDispenser,
+                  private CallbackThread
+{
+private:
+
+    massai::cussif::MediaInput   vcReader;       // coupon insertion
+
+    massai::cussif::Dispenser    vcDispenser;    // eject coupon
+
+    bool hasEscrowDispenser;
+
+    char abData[8192];
+
+    void        clearData            ();
+    void        saveData             (const types::datastream ds);
+    void        readerCallback       (const Event& ev, int id);
+    void        dispenserCallback    (const Event& ev, int id);
+
+    void        callback(CallbackComponent component, const types::Event& ev, int id);
+    void        process_readerCallback       (const Event& ev, int id);
+    void        process_dispenserCallback    (const Event& ev, int id);
+
+    char *checkATBResponse(char *pszData,long *plStatusCode);
+
+public:
+
+    long error();
+
+    enum atbReaderType
+    {
+      USE_ANY_READER,
+      USE_READ_ONLY_READER
+    };
+
+    /** Definition of important reader types. */
+
+    enum readertype
+    {
+      RT_MOTORIZED, /**< Motorized reader */
+      RT_SWIPE,     /**< Swipe reader */
+      RT_ERROR      /**< Unusable reader type, or not available */
+    };
+
+    /** Returns the type of the reader */
+
+    readertype readerType();
+
+    /** Query the component status..
+	        @param ct - the virtual component type to be queried
+	        @return values as specified in the CUSS statuscodes namespace
+	    */
+
+    long status (comptype ct = vCompReader::reader, Event_out ev= Event_var());
+    long status (long lTimeout, comptype ct = vCompReader::reader, Event_out ev= Event_var());
+
+    /** Opens the BPP reader for ticket insertion.
+        @param lTimeOut - timeout to be used in milliseconds
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long open  (long lTimeOut = 30000, Event_out ev= Event_var());
+
+    /** Closes the BPP reader for ticket insertion.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long close (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Cancel all pending commands.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long cancel (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Read the data from the inserted ticket.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long read  (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Eject the inserted ticket to the connected Escrow module.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long eject (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Write ticket- or boarding-pass data (depends on the datastream).
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call).
+        @param pszData - pointer to the data to be printed. If the pointer is not valid (NULL)
+                        the data in the buffer is printed.
+        @param lLen - Length of data buffer if binary
+        @return values as specified in the CUSS returncodes namespace.
+    */
+
+    long write (long lTimeOut = BLOCK_,char *pszData = NULL, long lLen = 0, Event_out ev= Event_var());
+
+
+    /** Returns the data from the inserted coupon or the last printer response
+        @return data if available or NULL
+    */
+
+    char *getData ();
+
+    /** Returns the current input/output mode
+        @return Current mode, Check-in or Revalidation
+    */
+
+    Characteristics::IOMode::InputOutputMode ioMode();
+
+    /** Sets the current input/output mode
+        @param mode - Current mode, Check-in or Revalidation
+        @return Zero if Ok, non-zero if any error occured
+    */
+
+    long setIOMode(Characteristics::IOMode::InputOutputMode mode);
+
+
+    /** Checks if the device is connected to an Escrow device.
+        @return TRUE if functionality is available, FALSE otherwise.
+    */
+
+    bool hasEscrow();
+
+    /** This handler is called when a ticket is inserted into the reader.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void couponInserted ();
+
+    /** This handler is called when data from the inserted coupon is available.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void dataPresent ();
+
+    /** This handler is called when a ticket is ejected to the Escrow module.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void couponEjected ();
+
+	/** This handler is called when a ticket is removed.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void couponRemoved ();
+
+    /** This handler is called when the reader component has been disabled.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void printerClosed (long lStatusCode = 0);
+
+
+    /** This handler is called when setup was erroneous.
+        Overwrite this function to implement your own handler in your derived class.
+        @param lStatusCode - CUSS status code
+        @param pszError - ATB error message
+    */
+
+    virtual void setupError (const long lStatusCode,const char *pszError);
+
+    /** This handler is called when sending setup data is done (PECTABS, LOGOS, ...).
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void setupResponse ();
+
+    /** This handler is called when the last issued command has timed out.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void commandTimeout ();
+
+    /** This handler is called when the last issued command has been cancelled.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void commandCancelled ();
+
+    /** This handler is called whenever a status code is returned for which no separate handler is available.
+        Use this handler to examine all unusual status codes (errors).
+        Overwrite this function to implement your own handler in your derived class.
+        @param eventCode - eventcode as specified in the CUSS eventcodes namespace
+        @param statusCode - statuscode as specified in the CUSSS statuscodes namespace
+        @param pszFunction - function that caused the event (null for unsolicited events)
+    */
+
+    virtual void handleException(long eventCode, long statusCode, const char *pszFunction);
+
+    /** This handler is called for every event that is recieved from the CUSS platfrom.
+        The eventReceived-handler is called before any other, so make sure that you
+        return FALSE for all events you want to handle in one of the handlers
+        descibed above.
+        @param eventCode - eventcode as specified in the CUSS eventcodes namespace
+        @param statusCode - statuscode as specified in the CUSSS statuscodes namespace
+        @param pszFunction - function that caused the event (null for unsolicited events)
+    */
+
+    virtual bool eventReceived (const Event& ev);
+    virtual bool eventReceived (long eventCode, long statusCode, const char *pszFunction);
+
+    /** Class constructor. All required virtual devices are aquired implicitly.
+        @param pAmi - Pointer to the application manger interface
+    */
+
+    atbReader(amInterface *pAmi, atbReaderType readerCreation= USE_ANY_READER);
+
+    /** Class destructor. All virtual devices are released implicitly. */
+
+    ~atbReader();
+};
+
+}; // namespace MASSAI
+
+#endif // ATBREADER_H
diff --git a/SelfServiceCommon/Interfaces/inc/CussIF/baggagedev.h b/SelfServiceCommon/Interfaces/inc/CussIF/baggagedev.h
new file mode 100644
index 00000000..5fa356d0
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/CussIF/baggagedev.h
@@ -0,0 +1,272 @@
+//---------------------------------------------------------------------------
+//
+//  file:       baggagedev.h
+//
+//  purpose:    Baggagehandling device definition
+//
+//  date:       04.11.2002
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+/** Header file for Baggagehandling device implementation
+
+ @file      baggagedev.h
+ @date      07.11.2002
+ @version   1.0
+ @author    AGe - (C) Materna Information & Communications
+
+*/
+
+#ifndef BAGGAGEDEV_H
+#define BAGGAGEDEV_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#ifndef CUSSIF_H
+
+#include <signal.h>
+
+#include "orbincdefs.h"
+
+#include "comps.h"
+#include "types.h"
+#include "codes.h"
+
+#include "orbs.h"
+
+#endif // CUSSIF_H
+
+#include "vcomp.h"
+#include "manufacturer.h"
+#include "cussif/cussif_component.h"
+
+using namespace CORBA;
+//using namespace std;
+using namespace types;
+using namespace Components;
+
+namespace MASSAI
+{
+class amInterface;
+
+#define MAX_TAGS 5
+
+/** Implementation of an Baggage Handling Device.
+    This class hides all the handling for the virtual components that make up
+    a Baggage Handling Device.
+*/
+
+class baggageDevice : public vManufacturer,
+                      public vCompConveyor
+{
+private:
+
+    massai::cussif::Conveyor        vcConveyor;
+
+    char  abData[MAX_TAGS][256];
+    long  lNoOfTags;
+    float fWeight;
+
+    void saveData  (const types::datastream ds);
+    void clearData ();
+
+    void        conveyorCallback         (const Event& ev, int id);
+    void        baggageSystemCallback    (const Event& ev, int id);
+
+public:
+
+    /** Query the component status..
+        @param ct - the virtual component type to be queried
+        @return values as specified in the CUSS statuscodes namespace
+    */
+
+    long status (comptype ct = vCompReader::reader, Event_out ev= Event_var());
+    long status (long lTimeout, comptype ct = vCompReader::reader, Event_out ev= Event_var());
+
+
+    /** Returns the number of tags scanned (could be more than one at a time)
+    */
+
+    long noOfTags();
+
+    /** Get the data from the scanner bridge in the read/write buffer.
+        @return Pointer to the stored data or NULL if no data available.
+    */
+
+    char *getTagData (long index = 0);
+
+    /** Get the baggage weight from the scale.
+        @param  weight - Returned weight
+        @return Weight in KG or 0.000 if nothing read.
+    */
+
+    long getWeight (float& weight);
+
+    /** Opens the conveyor shutter to allow baggage placing
+        @param  lTimeOut - Timeout value in milliseconds
+        @return statuscode as specified in the CUSSS statuscodes namespace
+     */
+
+    long open (long lTimeOut = 30000, Event_out ev= Event_var());
+
+    /** Closes the conveyor shutter to deny baggage placing
+        @param  lTimeOut - Timeout value in milliseconds
+        @return statuscode as specified in the CUSSS statuscodes namespace
+     */
+
+    long close (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Cancel all pending commands.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long cancel (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Accepts the current baggage piece and transports it to the parking position, if there's any.
+        If no parking position is available the baggage is transported directly to the airport baggage system.
+        @param  lTimeOut - Timeout value in milliseconds
+        @return statuscode as specified in the CUSSS statuscodes namespace
+     */
+
+    long accept (long lTimeOut = 30000, Event_out ev= Event_var());
+
+    /** Returns the current baggage piece back to the user (excluding parked baggages).
+        @param  lTimeOut - Timeout value in milliseconds
+        @return statuscode as specified in the CUSSS statuscodes namespace
+     */
+
+    long reject (long lTimeOut = 30000, Event_out ev= Event_var());
+
+    /** Accepts the current baggage piece and transports all bagagge pieces to the
+        airport baggage system (including parked baggages).
+        @param  lTimeOut - Timeout value in milliseconds
+        @return statuscode as specified in the CUSSS statuscodes namespace
+     */
+
+    long acceptAll (long lTimeOut = 30000, Event_out ev= Event_var());
+
+    /** Returns all baggage piecees back to the user (including parked baggages).
+        @param  lTimeOut - Timeout value in milliseconds
+        @return statuscode as specified in the CUSSS statuscodes namespace
+     */
+
+    long rejectAll (long lTimeOut = 30000, Event_out ev= Event_var());
+
+    /** Wait for baggage to be removed from scale.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long waitRemoved(long lTimeOut = 30000, Event_out ev= Event_var());
+
+    /** Read baggage weigth and baggage tag data.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long getData (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** This handler is called on baggage presence.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void baggagePresent ();
+
+    /** This handler is called on baggage removal.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void baggageRemoved ();
+
+    /** This handler is called when baggage in park position.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void baggageParked ();
+
+    /** This handler is called on baggage delivery to airport baggage system.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void baggageDelivered ();
+
+    /** This handler is called on baggage oversize detection.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void baggageOversized ();
+
+    /** This handler is called on baggage weight change.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void baggageWeightChanged ();
+
+    /** This handler is called when data from the conveyor is available.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void dataPresent ();
+
+    /** This handler is called when the last issued command has timed out.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void commandTimeout ();
+
+    /** This handler is called when the last issued command has been cancelled.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void commandCancelled ();
+
+    /** This handler is called whenever a OK is returned for an asynchronous call.
+        Overwrite this function to implement your own handler in your derived class.
+        @param eventCode - eventcode as specified in the CUSS eventcodes namespace
+        @param statusCode - statuscode as specified in the CUSSS statuscodes namespace
+        @param pszFunction - function that caused the event (null for unsolicited events)
+    */
+
+    virtual void commandPerformed(long eventCode, long statusCode, const char *pszFunction);
+
+    /** This handler is called whenever a status code is returned for which no separate handler is available.
+        Use this handler to examine all unusual status codes (errors).
+        Overwrite this function to implement your own handler in your derived class.
+        @param eventCode - eventcode as specified in the CUSS eventcodes namespace
+        @param statusCode - statuscode as specified in the CUSSS statuscodes namespace
+        @param pszFunction - function that caused the event (null for unsolicited events)
+    */
+
+    virtual void handleException(long eventCode, long statusCode, const char *pszFunction);
+
+    /** This handler is called for every event that is recieved from the CUSS platfrom.
+        The eventReceived-handler is called before any other, so make sure that you
+        return FALSE for all events you want to handle in one of the handlers
+        descibed above.
+        @param eventCode - eventcode as specified in the CUSS eventcodes namespace
+        @param statusCode - statuscode as specified in the CUSSS statuscodes namespace
+        @param pszFunction - function that caused the event (null for unsolicited events)
+    */
+
+    virtual bool eventReceived (const Event& ev);
+    virtual bool eventReceived (long eventCode, long statusCode, const char *pszFunction);
+
+    /** Class constructor. All devices are aquired implicitly.
+        @param pAmi - Pointer to the application manger interface
+    */
+
+    baggageDevice(amInterface *pAmi);
+
+    /** Class destructor. All virtual devices are released implicitly. */
+
+    ~baggageDevice();
+};
+
+}; // namespace MASSAI
+
+#endif // BAGGAGEDEV_H
diff --git a/SelfServiceCommon/Interfaces/inc/CussIF/bcsdev.h b/SelfServiceCommon/Interfaces/inc/CussIF/bcsdev.h
new file mode 100644
index 00000000..7a19d766
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/CussIF/bcsdev.h
@@ -0,0 +1,198 @@
+/**
+ *  @file      bcsdev.h
+ *
+ *  @brief     Barcode reader device definition
+ *
+ *  @date      26.03.2004
+ *
+ *  @author    Materna Information & Communications (PtM)
+ *
+ ************************************************************************/
+
+#ifndef BCSDEV_H
+#define BCSDEV_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#ifndef CUSSIF_H
+
+#include <signal.h>
+
+#include "orbincdefs.h"
+
+#include "comps.h"
+#include "types.h"
+#include "codes.h"
+
+#include "orbs.h"
+
+#endif // CUSSIF_H
+
+#include "vcomp.h"
+#include "manufacturer.h"
+#include "cussif/cussif_component.h"
+
+using namespace CORBA;
+using namespace types;
+using namespace Components;
+
+namespace MASSAI
+{
+
+class amInterface;
+
+/** Interface implementation to a CUSS document reader device.
+    This class hides all the handling for the virtual components that make up
+    a document reader device.
+*/
+
+class bcsDevice : public vManufacturer, public vCompReader
+{
+private:
+
+    massai::cussif::MediaInput  vcReader;
+
+    char abData[8192];  // should be enough for PDF417, too
+
+    void  readerCallback (const Event& ev, int id);
+    void  clearData      ();
+    void  saveData       (const types::datastream ds);
+
+public:
+
+    /** Definition of important reader types. */
+
+    enum readertype
+    {
+      RT_MOTORIZED,     /**< Motorized reader */
+      RT_SWIPE,         /**< Swipe reader */
+      RT_CONTACTLESS,   /**< Contactless reader */
+      RT_DIP,           /**< DIP-In reader */
+      RT_FLATBED,       /**< Flatbed scanner */
+      RT_PENSCAN,       /**< Pencil scanne */
+      RT_ERROR          /**< Unusable reader type, or not available */
+    };
+
+    enum barcodetype
+    {
+      BT_ERROR,   // unknown/no barcode type
+      BT_CODE39,
+      BT_CODE128,
+      BT_CODE2OF5
+    };
+
+
+    /** Returns the type of the reader */
+
+    readertype readerType();
+
+    /** Returns the type of the reader */
+
+    barcodetype barcodeType();
+
+    /** Query the component status..
+        @param ct - the virtual component type to be queried
+        @return values as specified in the CUSS statuscodes namespace
+    */
+
+    long status (comptype ct = vCompReader::reader, Event_out ev= Event_var());
+    long status (long lTimeout, comptype ct = vCompReader::reader, Event_out ev= Event_var());
+
+    /** Opens the document reader for document insertion.
+        @param lTimeOut - timeout to be used in milliseconds
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long open (long lTimeOut = 30000, Event_out ev= Event_var());
+
+    /** Closes the document reader insertion.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long close (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Read all tracks on the inserted document.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long read (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Cancel pending command.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long cancel (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Get barcode data.
+        Use read(...) to read all tracks from the document.
+        @return pointer to data or NULL if track is empty
+    */
+
+    char *getData ();
+
+    virtual void dataPresent ();
+
+    virtual void documentInserted ();
+
+    virtual void documentRemoved ();
+
+    /** This handler is called when the last issued command has timed out.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void commandTimeout ();
+
+    /** This handler is called when the last issued command has been cancelled.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void commandCancelled ();
+
+    /** This handler is called whenever a status code is returned for which no separate handler is available.
+        Use this handler to examine all unusual status codes (errors).
+        Overwrite this function to implement your own handler in your derived class.
+        @param eventCode - eventcode as specified in the CUSS eventcodes namespace
+        @param statusCode - statuscode as specified in the CUSSS statuscodes namespace
+        @param pszFunction - function that caused the event (null for unsolicited events)
+    */
+
+    virtual void handleException(long eventCode, long statusCode, const char *pszFunction);
+
+    /** This handler is called for every event that is recieved from the CUSS platfrom.
+        The eventReceived-handler is called before any other, so make sure that you
+        return FALSE for all events you want to handle in one of the handlers
+        descibed above.
+        @param eventCode - eventcode as specified in the CUSS eventcodes namespace
+        @param statusCode - statuscode as specified in the CUSSS statuscodes namespace
+        @param pszFunction - function that caused the event (null for unsolicited events)
+    */
+
+    virtual bool eventReceived (const Event& ev);
+    virtual bool eventReceived (long eventCode, long statusCode, const char *pszFunction);
+
+    /** Class constructor. All devices are aquired implicitly.
+        @param pAmi - Pointer to the application manger interface
+    */
+
+    bcsDevice(amInterface *pAmi);
+
+    /** Class constructor. All devices are aquired implicitly.
+        @param pAmi - Pointer to the application manger interface
+        @param select - needed barcode type support for mediainput
+    */
+
+    bcsDevice(amInterface *pAmi, barcodetype select);
+
+    /** Class destructor. All aquired devices are released implicitly. */
+
+    ~bcsDevice();
+};
+
+}; // namespace MASSAI
+
+#endif // BCSDEV_H
diff --git a/SelfServiceCommon/Interfaces/inc/CussIF/bppdev.h b/SelfServiceCommon/Interfaces/inc/CussIF/bppdev.h
new file mode 100644
index 00000000..8b531ee7
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/CussIF/bppdev.h
@@ -0,0 +1,405 @@
+//---------------------------------------------------------------------------
+//
+//  file:       bppdev.h
+//
+//  purpose:    Boarding Pass Printer device definition
+//
+//  date:       25.04.2002, 15:41
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+/** Header file for boarding pass printer implementation
+
+ @file      bppdev.h
+ @date      25.04.2002
+ @version   1.0
+ @author    AGe - (C) Materna Information & Communications
+
+*/
+
+#ifndef BPPDEV_H
+#define BPPDEV_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "cussif.h"
+#include "atb2Scanner.h"
+#include "manufacturer.h"
+#include "callbackthread.h"
+#include "cussif/cussif_component.h"
+#include <string>
+
+using namespace CORBA;
+using namespace types;
+using namespace Components;
+//using namespace Characteristics;
+
+namespace MASSAI
+{
+class amInterface;
+
+/** Interface implementation for the Boarding Pass Printer device.
+    This class hides all the handling for the virtual components that make up
+    a Boarding Pass Printer device.
+*/
+
+class bppDevice : public vManufacturer,
+                  public vCompReader,
+                  public vCompWriter,
+                  public vCompDispenser,
+                  public vCompFeeder,
+                  private CallbackThread
+{
+  public:
+
+    long error();
+
+    enum bppType
+    {
+      READER_INCLUSIVE,
+      READER_IGNORED
+    };
+
+    /** Definition of important reader types. */
+
+    enum readertype
+    {
+      RT_MOTORIZED, /**< Motorized reader */
+      RT_SWIPE,     /**< Swipe reader */
+      RT_ERROR      /**< Unusable reader type, or not available */
+    };
+
+    enum papertype
+    {
+      PT_TICKET,
+      PT_BOARDINGPASS,
+      PT_INSERTEDDOC,
+      PT_GENERALPURPOSEDOC,
+      PT_BOARDINGPASSFIRST,
+      PT_BOARDINGPASSBUSINESS,
+      PT_BOARDINGPASSECONOMY,
+    };
+    enum papertypehandling
+    {
+      PH_PAPERTYPE_FROM_DATASTREAM,
+      PH_PAPERTYPE_FROM_CONSTRUCTOR,
+    };
+
+    struct ComponentId
+    {
+      papertype paper;
+      int       feeder_count;
+      comptype  component;
+    };
+
+    /** Returns the type of the reader */
+
+    readertype readerType();
+
+    /** Returns bin size of the dispenser */
+
+    long dispenserBinSize();
+
+    /** Query the component status..
+        @param ct - the virtual component type to be queried
+        @return values as specified in the CUSS statuscodes namespace
+    */
+
+    long status (comptype ct = vCompReader::reader, Event_out ev= Event_var());
+    long status (long lTimeout, comptype ct = vCompReader::reader, Event_out ev= Event_var());
+
+    long feederStatus (papertype pt, Event_out ev= Event_var());
+
+    /** Opens the BPP reader for ticket insertion.
+        @param lTimeOut - timeout to be used in milliseconds
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long open  (long lTimeOut = 30000, Event_out ev= Event_var());
+
+    /** Closes the BPP reader for ticket insertion.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long close (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Cancel all pending commands.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long cancel (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Read the data from the inserted ticket.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long read  (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Eject the inserted ticket to the connected Escrow module.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long eject (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Write ticket- or boarding-pass data (depends on the datastream).
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call).
+        @param pszData - pointer to the data to be printed. If the pointer is not valid (NULL)
+                        the data in the buffer is printed.
+        @param lLen - Length of data buffer if binary
+        @return values as specified in the CUSS returncodes namespace.
+    */
+
+    long write (long lTimeOut = BLOCK_,char *pszData = NULL, long lLen = 0, Event_out ev= Event_var());
+
+    /** Returns the data from the inserted coupon or the last printer response
+        @return data if available or NULL
+    */
+
+    char *getData ();
+
+    /** Returns the current input/output mode
+        @return Current mode, Check-in or Revalidation
+    */
+
+    Characteristics::IOMode::InputOutputMode ioMode();
+
+    /** Sets the current input/output mode
+        @param mode - Current mode, Check-in or Revalidation
+        @return Zero if Ok, non-zero if any error occured
+    */
+
+    long setIOMode(Characteristics::IOMode::InputOutputMode mode);
+
+    /** Get the number ticket documents available in this printer
+        @return number of coupons or -1 on error
+    */
+
+    long tktDocsAvailable();
+
+    /** Get the number boarding pass documents available in this printer
+        @param boardingclass boardingpasstype
+                             \li 0 = general boardingpass
+                             \li 1 = first class boardingpass
+                             \li 2 = business class boardingpass
+                             \li 3 = economy class boardingpass
+        @return number of coupons or -1 on error
+    */
+
+    long bpDocsAvailable(int boardingclass = 0);
+
+    /** Get the number general purpose documents available in this printer
+        @return number of coupons or -1 on error
+    */
+
+    long gpDocsAvailable();
+
+    /** Get the current document number of the first feeder
+	        @return current document number or "???" on error (char because of length)
+	    */
+
+    const char *documentNumber();
+
+    /** Checks if the device supports AEA data stream. This might not be the case if
+        the device is mapped to a GPP printer.
+        @return TRUE if functionality is available, FALSE otherwise.
+    */
+
+    bool hasAEASupport();
+
+    /** Checks if the device supports a specified papertype.
+        @return TRUE if functionality is available, FALSE otherwise.
+    */
+
+    bool hasPaperTypeSupport(papertype paper);
+
+    /** Checks if the device is connected to an Escrow device.
+        @return TRUE if functionality is available, FALSE otherwise.
+    */
+
+    bool hasEscrow();
+
+    /** Checks if the device is connected to an Escrow device for the reader
+        @return TRUE if functionality is available, FALSE otherwise.
+    */
+
+    bool hasReaderEscrow();
+
+    /** Checks if the device is connected to an MediaInput device.
+        @return TRUE if functionality is available, FALSE otherwise.
+    */
+
+    bool hasReader();
+
+    /** This handler is called when a ticket is inserted into the reader.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void couponInserted ();
+
+    /** This handler is called when data from the inserted coupon is available.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void dataPresent ();
+
+    /** This handler is called when a ticket is ejected to the Escrow module.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void couponEjected ();
+
+    /** This handler is called when the reader component has been disabled.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void printerClosed (long lStatusCode = 0);
+
+    /** This handler is called when printing a ticket or boarding-pass was erroneous.
+        Overwrite this function to implement your own handler in your derived class.
+        @param lStatusCode - CUSS status code
+        @param pszError - ATB error message
+    */
+
+    virtual void printError (const long lStatusCode,const char *pszError);
+
+    /** This handler is called when printing a ticket or boarding-pass has been completed.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void couponPrinted ();
+    virtual void couponPrinted (const ComponentId& id);
+
+    /** This handler is called when sending setup data is done (PECTABS, LOGOS, ...).
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void setupResponse ();
+    virtual void setupResponse (const ComponentId& id);
+
+    /** This handler is called when the last issued command has timed out.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void commandTimeout ();
+    virtual void commandTimeout (const ComponentId& id);
+
+    /** This handler is called when the last issued command has been cancelled.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void commandCancelled ();
+    virtual void commandCancelled (const ComponentId& id);
+
+    /** This handler is called whenever a status code is returned for which no separate handler is available.
+        Use this handler to examine all unusual status codes (errors).
+        Overwrite this function to implement your own handler in your derived class.
+        @param eventCode - eventcode as specified in the CUSS eventcodes namespace
+        @param statusCode - statuscode as specified in the CUSSS statuscodes namespace
+        @param pszFunction - function that caused the event (null for unsolicited events)
+    */
+
+    virtual void handleException(long eventCode, long statusCode, const char *pszFunction);
+    virtual void handleException(long eventCode, long statusCode, const char *pszFunction, const ComponentId& id);
+
+    /** This handler is called for every event that is recieved from the CUSS platfrom.
+        The eventReceived-handler is called before any other, so make sure that you
+        return FALSE for all events you want to handle in one of the handlers
+        descibed above.
+        @param eventCode - eventcode as specified in the CUSS eventcodes namespace
+        @param statusCode - statuscode as specified in the CUSSS statuscodes namespace
+        @param pszFunction - function that caused the event (null for unsolicited events)
+    */
+
+    virtual bool eventReceived (const Event& ev);
+    virtual bool eventReceived (const Event& ev, const ComponentId& id);
+    virtual bool eventReceived (long eventCode, long statusCode, const char *pszFunction);
+    virtual bool eventReceived (long eventCode, long statusCode, const char *pszFunction, const ComponentId& id);
+
+    /** Class constructor. All required virtual devices are aquired implicitly.
+        @param pAmi - Pointer to the application manger interface
+    */
+
+    bppDevice(amInterface *pAmi, bppType readerCreation= READER_IGNORED);
+
+    /** Class constructor. All required virtual devices are aquired implicitly.
+        use method hasPaperTypeSupport to check if a device has been acquired
+        @param pAmi - Pointer to the application manger interface
+        @param paper - needed papertype support
+    */
+
+    bppDevice(amInterface *pAmi, papertype paper, bppType readerCreation= READER_IGNORED, papertypehandling handlepapertype= PH_PAPERTYPE_FROM_DATASTREAM);
+
+    /** Class destructor. All virtual devices are released implicitly. */
+
+    ~bppDevice();
+
+  private:
+
+    massai::cussif::MediaInput   vcReader;       // coupon insertion
+
+    massai::cussif::MediaOutput  vcWriter;       // write on inserted coupon
+
+    massai::cussif::Dispenser    vcDispenser;    // eject coupon
+
+    bool hasEscrowDispenser;
+
+    bool hasReaderEscrowDispenser;
+
+    ComponentId   compId[15];
+
+    bool          useDSPaperType;                   // use paper type from datastream
+    papertype     papertypeDefault;                 // use this paper type instead
+
+    /** Internal BIN definition */
+
+    struct _vcWriterBin
+    {
+      massai::cussif::MediaOutput  vcWriter;     // write on coupon from BINs
+      massai::cussif::Feeder       vcBin[3];     // characteristics of BINs
+    };
+    _vcWriterBin vcWriterBin[3];
+
+    char abData[8192];
+    std::string m_documentNumber;
+
+    void        clearData            ();
+    void        saveData             (const types::datastream ds);
+    void        readerCallback       (const Event& ev, int id);
+    void        writerCallback       (const Event& ev, int id);
+    void        dispenserCallback    (const Event& ev, int id);
+    void        feederCallback       (const Event &ev, int id);
+
+    void        callback(CallbackComponent component, const types::Event& ev, int id);
+    void        process_readerCallback       (const Event& ev, int id);
+    void        process_writerCallback       (const Event& ev, int id);
+    void        process_dispenserCallback    (const Event& ev, int id);
+    void        process_feederCallback       (const Event &ev, int id);
+    void        disable                      (int id);
+
+
+    char *checkATBResponse(char *pszData,long *plStatusCode);
+
+    massai::cussif::MediaOutput* getVirtualWriter(Characteristics::MediaOutput::MediaType type,
+                                                     errorCodes& lErr,
+                                                     errorCodes noStock,
+                                                     errorCodes emptyStock);
+    massai::cussif::MediaOutput* findVirtualWriter(char *pszData,
+                                      MASSAI::atb2Scanner::PaperTypes *pt = NULL,
+                                      long *plError = NULL);
+    massai::cussif::MediaOutput* getDefaultVirtualWriter(long *plError);
+    void init(amInterface *pAmi, const char* pszRealComponent, bppType readerCreation);
+
+
+};
+
+}; // namespace MASSAI
+
+#endif // BPPDEV_H
diff --git a/SelfServiceCommon/Interfaces/inc/CussIF/btpScanner.h b/SelfServiceCommon/Interfaces/inc/CussIF/btpScanner.h
new file mode 100644
index 00000000..874b35de
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/CussIF/btpScanner.h
@@ -0,0 +1,73 @@
+//---------------------------------------------------------------------------
+//
+//  file:       btpScanner.h
+//
+//  purpose:    Scanner to find CUSS papertype from AEA commands
+//
+//  date:       30.04.2002, 14:16
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+/** Header file for AEA data scanner
+
+ @file      btpScanner.h
+ @date      02.05.2002
+ @version   1.0
+ @author    AGe - (C) Materna Information & Communications
+
+*/
+
+#ifndef BTPSCANNER_H
+#define BTPSCANNER_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+// forward reference to real scanner class
+
+class btpScannerHandle;
+
+namespace MASSAI
+{
+
+/** Interface implementation for an BTP datastream scanner.
+*/
+
+class btpScanner
+{
+private:
+
+    btpScannerHandle *scanner;
+
+public:
+
+    /** Paper type mapping */
+
+    enum PaperTypes { Unknown,              /**< 0 Unkown papertype */
+                      Setup,                /**< 1 Virtual papertype used for PECTABS, LOGOS etc.*/
+                      BaggageTag,           /**< 2 Papertype used for BAGTAGS etc.*/
+                      Error                 /**< 3 Error encountered in datastream */
+                    };
+
+    /** Tries to find the papertype from the AEA datastream.
+        @param pszAEA - Data to be sent to the printer
+        @return values as specified in PaperTypes enumeration
+    */
+
+    PaperTypes checkPaperType(const char *pszAEA);
+
+    /** class constructor */
+
+    btpScanner();
+
+    /** class destructor */
+
+   ~btpScanner();
+};
+
+}; // namespace MASSAI
+
+#endif // BTPSCANNER_H
diff --git a/SelfServiceCommon/Interfaces/inc/CussIF/btpdev.h b/SelfServiceCommon/Interfaces/inc/CussIF/btpdev.h
new file mode 100644
index 00000000..5f6888bd
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/CussIF/btpdev.h
@@ -0,0 +1,240 @@
+//---------------------------------------------------------------------------
+//
+//  file:       btpdev.h
+//
+//  purpose:    Baggage Tag Printer device definition
+//
+//  date:       25.04.2002
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+/** Header file for baggage tag printer implementation
+
+ @file      btpdev.h
+ @date      25.04.2002
+ @version   1.0
+ @author    AGe - (C) Materna Information & Communications
+
+*/
+
+#ifndef BTPDEV_H
+#define BTPDEV_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#ifndef CUSSIF_H
+
+#include <signal.h>
+
+#include "orbincdefs.h"
+
+#include "comps.h"
+#include "types.h"
+#include "codes.h"
+
+#include "orbs.h"
+
+#endif // CUSSIF_H
+
+#include "vcomp.h"
+#include "btpScanner.h"
+#include "manufacturer.h"
+#include "callbackthread.h"
+#include "cussif/cussif_component.h"
+
+
+using namespace CORBA;
+using namespace types;
+using namespace Components;
+
+namespace MASSAI
+{
+class amInterface;
+
+/** Interface implementation for the Baggage Tag  Printer device.
+    This class hides all the handling for the virtual components that make up
+    an Baggage Tag Printer device.
+*/
+
+class btpDevice : public vManufacturer,
+                  public vCompWriter,
+                  public vCompDispenser,
+                  public vCompFeeder,
+                  private CallbackThread
+{
+private:
+
+    massai::cussif::MediaOutput vcWriter;
+
+    massai::cussif::Feeder      vcBin1;
+    massai::cussif::Dispenser   vcDispenser;
+
+    bool fHasAEASupport;
+    bool hasEscrowDispenser;
+
+    char abData[8192];
+
+    void clearData        ();
+    void saveData         (const types::datastream ds);
+
+    void        writerCallback       (const Event& ev, int id);
+    void        dispenserCallback    (const Event& ev, int id);
+    void        feederCallback       (const Event &ev, int id);
+
+
+    void        callback(CallbackComponent component, const types::Event& ev, int id);
+    void        process_writerCallback       (const Event& ev, int id);
+    void        process_dispenserCallback    (const Event& ev, int id);
+    void        process_feederCallback       (const Event& ev, int id);
+
+
+    char *checkBTPResponse(char *pszData,long *plStatusCode);
+
+    massai::cussif::MediaOutput* findVirtualWriter(char *pszData,
+                                      MASSAI::btpScanner::PaperTypes *pt = NULL);
+
+public:
+
+    /** Checks if the device is connected to an Escrow device.
+        @return TRUE if functionality is available, FALSE otherwise.
+    */
+
+    bool hasEscrow();
+
+    /** Get the number ticket documents available in this printer
+        @return number of coupons or -1 on error
+    */
+    long docsAvailable();
+
+
+    /** Eject the inserted ticket to the connected Escrow module.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+    long eject(long lTimeOut, Event_out ev);
+
+    /** Returns bin size of the dispenser */
+
+    long dispenserBinSize();
+
+    long error();
+
+
+    /** Query the component status..
+        @param ct - the virtual component type to be queried
+        @return values as specified in the CUSS statuscodes namespace
+    */
+
+    long status (comptype ct = vCompWriter::writer, Event_out ev= Event_var());
+    long status (long lTimeout, comptype ct = vCompWriter::writer, Event_out ev= Event_var());
+
+    /** Write baggage tag data.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call).
+        @param pszData - pointer to the data to be printed. If the pointer is not valid (NULL)
+                         the data in the buffer is printed.
+        @param lLen - specifies the length of the data. Data can be binary, so that string functions
+                      are not very useful.
+        @return values as specified in the CUSS returncodes namespace.
+    */
+
+    long write (long lTimeOut = BLOCK_,char *pszData = NULL, long lLen = 0, Event_out ev= Event_var());
+
+    /** Cancel all pending commands.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long cancel (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Get the data in the read/write buffer.
+        @return pointer to the buffer.
+    */
+
+    char *getData ();
+
+
+    /** Checks if the device spports AEA data stream. This might not be the case if
+        the device is mapped to a GPP printer.
+        @return TRUE if functionality is available, FALSE otherwise.
+    */
+
+    bool hasAEASupport() { return(fHasAEASupport); }
+
+    /** This handler is called when a ticket is ejected to the Escrow module.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void bagtagEjected ();
+
+    /** This handler is called when printing a ticket or boarding-pass was erroneous.
+        Overwrite this function to implement your own handler in your derived class.
+        @param lStatusCode - CUSS status code
+        @param pszError - ATB error message
+    */
+
+    virtual void printError (const long lStatusCode,const char *pszError);
+
+    /** This handler is called when printing a baggage tag has been completed.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void bagtagPrinted ();
+
+    /** This handler is called when sending setup data is done (PECTABS, LOGOS, ...).
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void setupResponse ();
+
+    /** This handler is called when the last issued command has timed out.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void commandTimeout ();
+
+    /** This handler is called when the last issued command has been cancelled.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void commandCancelled ();
+
+    /** This handler is called whenever a status code is returned for which no separate handler is available.
+        Use this handler to examine all unusual status codes (errors).
+        Overwrite this function to implement your own handler in your derived class.
+        @param eventCode - eventcode as specified in the CUSS eventcodes namespace
+        @param statusCode - statuscode as specified in the CUSSS statuscodes namespace
+        @param pszFunction - function that caused the event (null for unsolicited events)
+    */
+
+    virtual void handleException(long eventCode, long statusCode, const char *pszFunction);
+
+    /** This handler is called for every event that is recieved from the CUSS platfrom.
+        The eventReceived-handler is called before any other, so make sure that you
+        return FALSE for all events you want to handle in one of the handlers
+        descibed above.
+        @param eventCode - eventcode as specified in the CUSS eventcodes namespace
+        @param statusCode - statuscode as specified in the CUSSS statuscodes namespace
+        @param pszFunction - function that caused the event (null for unsolicited events)
+    */
+
+    virtual bool eventReceived (const Event& ev);
+    virtual bool eventReceived (long eventCode, long statusCode, const char *pszFunction);
+
+    /** Class constructor. All required virtual devices are aquired implicitly.
+        @param pAmi - Pointer to the application manger interface
+    */
+
+    btpDevice(amInterface *pAmi);
+
+    /** Class destructor. All virtual devices are released implicitly. */
+
+    ~btpDevice();
+};
+
+}; // namespace MASSAI
+
+#endif // BTPDEV_H
diff --git a/SelfServiceCommon/Interfaces/inc/CussIF/callbackthread.h b/SelfServiceCommon/Interfaces/inc/CussIF/callbackthread.h
new file mode 100644
index 00000000..5f4fc943
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/CussIF/callbackthread.h
@@ -0,0 +1,109 @@
+//---------------------------------------------------------------------------
+//
+//  file:       callbackthread.h
+//
+//  purpose:    Thread processing queued component callbacks
+//
+//  date:       20.04.2007
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+#ifndef CALLBACKTHREAD_H
+#define CALLBACKTHREAD_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "mThreadEx.h"
+#include "mEventSem.hpp"
+#include "types.h"
+#include <list>
+
+
+namespace MASSAI
+{
+  enum CallbackComponent
+  {
+    CC_READER,
+    CC_WRITER,
+    CC_DISPENSER,
+    CC_CAPTURE,
+    CC_FEEDER,
+    CC_DISPLAY,
+    CC_CONVEYOR,
+    CC_BAGGAGE,
+    CC_APPLICATIONMANAGER,
+  };
+  /*
+    queue component callbacks and process the callbacks serial
+  */
+
+  class CallbackHandler
+  {
+    public:
+      CallbackHandler();
+      virtual ~CallbackHandler();
+      virtual void process();
+  };
+  class CallbackProcessor: private mThreadEx
+  {
+    public:
+      CallbackProcessor();
+      void startProcessing(CallbackHandler* cb);
+
+    private:
+      virtual long function();
+      CallbackHandler* m_pHandler;
+  };
+
+  class CallbackThread: private CallbackHandler
+  {
+    public:
+      CallbackThread();
+      /*
+        write the data for a callback in the queue
+      */
+      void enqueue(CallbackComponent component, const types::Event& ev, int id);
+      /*
+        callback are processed in an extra thread, start the thread
+      */
+      void startProcessing();
+      /*
+        stop the callback processing thread (after processing all enqueued callbacks)
+      */
+      void stopProcessing();
+
+    protected:
+      /*
+        callbacks are called serial from the processing thread,
+        cussif devices should overwrite this and do their processing for the callback
+      */
+      virtual void callback(CallbackComponent component, const types::Event& ev, int id)= 0;
+
+    private:
+      struct CallbackData
+      {
+        CallbackComponent component;
+        types::Event_var ev;
+        int id;
+        CallbackData(CallbackComponent component_, const types::Event& ev_, int id_);
+        CallbackData(const CallbackData& assign);
+        CallbackData();
+        ~CallbackData();
+      };
+      typedef std::list<CallbackData> CallbackDataQueue;
+
+      void process();
+
+      mThreadMutex m_queueMutex;
+      Materna::MSSD::eventSemaphore m_queueEvent;
+      bool m_stopped;
+      CallbackDataQueue m_queue;
+      CallbackProcessor m_processor;
+  };
+}; // namespace MASSAI
+
+#endif // CALLBACKTHREAD_H
diff --git a/SelfServiceCommon/Interfaces/inc/CussIF/clock.h b/SelfServiceCommon/Interfaces/inc/CussIF/clock.h
new file mode 100644
index 00000000..6b38fb94
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/CussIF/clock.h
@@ -0,0 +1,159 @@
+//---------------------------------------------------------------------------
+//
+//  file:       clock.h
+//
+//  purpose:    clock device definition
+//
+//  date:       11.11.2005
+//
+//  author:     Materna Information & Communications (TS)
+//
+//---------------------------------------------------------------------------
+
+/** Header file for cuss clock device implementation
+
+ @file      clock.h
+ @date      11.11.2005
+ @version   1.0
+ @author    (C) Materna Information & Communications
+
+*/
+
+#ifndef CLOCK_H
+#define CLOCK_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#ifndef CUSSIF_H
+
+#include <signal.h>
+
+#include "orbincdefs.h"
+
+#include "comps.h"
+#include "types.h"
+#include "codes.h"
+
+#include "orbs.h"
+#include "vcomp.h"
+
+#endif // CUSSIF_H
+
+#include "manufacturer.h"
+#include "cussif/cussif_component.h"
+
+using namespace CORBA;
+using namespace types;
+using namespace Components;
+//using namespace Characteristics;
+
+namespace MASSAI
+{
+class amInterface;
+
+/** Interface implementation for the clock device.
+    This class hides all the handling for the virtual components that make up
+    a clock device.
+*/
+
+class clock : public vManufacturer,
+              public vCompReader
+{
+private:
+
+    massai::cussif::DataInput     vcReader;
+
+    char time[15];
+
+    bool        saveData             (const types::datastream ds);
+    void        readerCallback       (const Event& ev, int id);
+
+
+public:
+
+    /** Query the timezone..
+         @return time difference in minutes relative to GMT
+     */
+
+    long timezone ();
+
+
+    /** Query the component status..
+	        @return values as specified in the CUSS statuscodes namespace
+	    */
+
+    long status (Event_out ev= Event_var());
+    long status (long lTimeout, Event_out ev= Event_var());
+
+
+    /** Read the data from the inserted ticket.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long read  (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Cancel all pending commands.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long cancel (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Returns the data from the inserted coupon or the last printer response
+        @return data if available or NULL
+    */
+
+    char *getData ();
+
+
+    /** This handler is called when the last issued command has timed out.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void commandTimeout ();
+
+    /** This handler is called when the last issued command has been cancelled.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void commandCancelled ();
+
+    /** This handler is called whenever a status code is returned for which no separate handler is available.
+        Use this handler to examine all unusual status codes (errors).
+        Overwrite this function to implement your own handler in your derived class.
+        @param eventCode - eventcode as specified in the CUSS eventcodes namespace
+        @param statusCode - statuscode as specified in the CUSSS statuscodes namespace
+        @param pszFunction - function that caused the event (null for unsolicited events)
+    */
+
+    virtual void handleException(long eventCode, long statusCode, const char *pszFunction);
+
+    /** This handler is called for every event that is recieved from the CUSS platfrom.
+        The eventReceived-handler is called before any other, so make sure that you
+        return FALSE for all events you want to handle in one of the handlers
+        descibed above.
+        @param eventCode - eventcode as specified in the CUSS eventcodes namespace
+        @param statusCode - statuscode as specified in the CUSSS statuscodes namespace
+        @param pszFunction - function that caused the event (null for unsolicited events)
+    */
+
+    virtual bool eventReceived (const Event& ev);
+    virtual bool eventReceived (long eventCode, long statusCode, const char *pszFunction);
+
+    /** Class constructor. All required virtual devices are aquired implicitly.
+        @param pAmi - Pointer to the application manger interface
+    */
+
+    clock(amInterface *pAmi);
+
+    /** Class destructor. All virtual devices are released implicitly. */
+
+    ~clock();
+};
+
+}; // namespace MASSAI
+
+#endif // CLOCK_H
diff --git a/SelfServiceCommon/Interfaces/inc/CussIF/cuss_component.h b/SelfServiceCommon/Interfaces/inc/CussIF/cuss_component.h
new file mode 100644
index 00000000..0c867d14
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/CussIF/cuss_component.h
@@ -0,0 +1,563 @@
+//---------------------------------------------------------------------------
+//
+//  file:       cuss_component.h
+//
+//  purpose:    interface for cuss corba calls
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef CUSS_COMPONENT_H_INCLUDED
+#define CUSS_COMPONENT_H_INCLUDED
+
+#include "comps.h"
+#include "types.h"
+#include "codes.h"
+#include "characteristics.h"
+#include <string>
+
+namespace MASSAI
+{
+  class vComponent;
+}
+
+namespace massai
+{
+  class ComponentBase
+  {
+    public:
+      ComponentBase();
+      virtual ~ComponentBase();
+      bool isConnected();
+      bool canConnect();
+//      void reconnect();
+      bool connect();
+      bool exception(bool retry= true);
+      const char* getAppRef();
+      long setTimeout(long timeout);
+      void resetTimeout(long oldTimeout);
+      long setListener();
+      long clearListener();
+      void storeIOR(const char* pszIOR);
+      int getId();
+
+      void setId(int id);
+      void setComponent(MASSAI::vComponent* pComponent);
+    private:
+      long acquire();
+      long acquire(types::Event_out e);
+      virtual returncodes::rc acquire(types::evtListener_ptr el, types::Event_out e)= 0;
+      virtual returncodes::rc release(types::Event_out e)= 0;
+
+      virtual void narrow(MASSAI::vComponent*& pComponent, const char* pszIOR)= 0;
+
+      enum ComponentState
+      {
+        CS_NOT_CONNECTED,
+        CS_CONNECTED,
+        CS_NOT_CONNECTED_RETRY,
+        CS_FAILED
+      };
+      std::string          m_ior;
+      MASSAI::vComponent*  m_pComponent;
+      ComponentState       m_state;
+      int                  m_id;
+  };
+  template<class T> class Cache
+  {
+    public:
+      Cache(const T& defaultValue, bool doCache= true);
+      void doCache(bool doCache);
+      bool isCached();
+      void set(const T& value);
+      bool get(T& value);
+      T get();
+    private:
+      T m_value;
+      bool m_isCached;
+      bool m_doCache;
+  };
+
+  namespace cuss_characteristics
+  {
+    class Manufacturer: public virtual ComponentBase
+    {
+      public:
+        Manufacturer();
+        std::string getRealComponentIdentification();
+        bool getRealComponentIdentification(std::string& realComponentIdentification);
+        bool getDownloadableFirmware();
+        bool getDownloadableFirmware(bool& downloadableFirmware);
+        std::string getFirmwareVersion();
+        bool getFirmwareVersion(std::string& firmwareVersion);
+        std::string getManufacturerName();
+        bool getManufacturerName(std::string& manufacturerName);
+        std::string getModelNumber();
+        bool getModelNumber(std::string& modelNumber);
+        std::string getSerialNumber();
+        bool getSerialNumber(std::string& serialNumber);
+        Characteristics::Manufacturer_ptr getServant();
+        virtual Characteristics::Manufacturer_ptr getCharacteristicsManufacturer()= 0;
+
+        const char *firmwareVersion();
+        const char *manufacturerName();
+        const char *modelNumber();
+        const char *realComponentIdentification();
+        const char *serialNumber();
+
+      private:
+        Cache<std::string> m_realComponentIdentification;
+        Cache<bool> m_downloadableFirmware;
+        Cache<std::string> m_firmwareVersion;
+        Cache<std::string> m_manufacturerName;
+        Cache<std::string> m_modelNumber;
+        Cache<std::string> m_serialNumber;
+    };
+    class MediaType: public virtual ComponentBase
+    {
+      public:
+        MediaType();
+        Characteristics::MediaType::MediaTypeDef getType();
+        bool getType(Characteristics::MediaType::MediaTypeDef& type);
+        Characteristics::MediaType_ptr getServant();
+      private:
+        virtual Characteristics::MediaType_ptr getCharacteristicsMediaType()= 0;
+        Cache<Characteristics::MediaType::MediaTypeDef> m_type;
+    };
+    class MediaTypeList: public virtual ComponentBase
+    {
+      public:
+        MediaTypeList();
+        Characteristics::MediaTypeListDef_var getMtList();
+        bool getMtList(Characteristics::MediaTypeListDef_var& mtList);
+        Characteristics::MediaTypeList_ptr getServant();
+      private:
+        virtual Characteristics::MediaTypeList_ptr getCharacteristicsMediaTypeList()= 0;
+        Cache<Characteristics::MediaTypeListDef_var> m_mtList;
+    };
+    class Location: public virtual ComponentBase
+    {
+      public:
+        Location();
+        std::string getMap();
+        bool getMap(std::string& Map);
+        Characteristics::Location::ImageType getMapType();
+        bool getMapType(Characteristics::Location::ImageType& mapType);
+        std::string getHowTo();
+        bool getHowTo(std::string& howTo);
+        Characteristics::Location::ImageType getHowToType();
+        bool getHowToType(Characteristics::Location::ImageType& howToType);
+        Characteristics::Location::LocationType getComponentLocation();
+        bool getComponentLocation(Characteristics::Location::LocationType& componentLocation);
+        Characteristics::Location_ptr getServant();
+     private:
+        virtual Characteristics::Location_ptr getCharacteristicsLocation()= 0;
+        Cache<std::string> m_Map;
+        Cache<Characteristics::Location::ImageType> m_mapType;
+        Cache<std::string> m_howTo;
+        Cache<Characteristics::Location::ImageType> m_howToType;
+        Cache<Characteristics::Location::LocationType> m_componentLocation;
+    };
+    class ComponentFonts: public virtual ComponentBase
+    {
+      public:
+        ComponentFonts();
+        Characteristics::ComponentFonts::BarcodeStandard getUsedStandard();
+        bool getUsedStandard(Characteristics::ComponentFonts::BarcodeStandard& usedStandard);
+        Characteristics::ComponentFonts::FontList_var getFonts();
+        bool getFonts(Characteristics::ComponentFonts::FontList_var& Fonts);
+        Characteristics::ComponentFonts_ptr getServant();
+      private:
+        virtual Characteristics::ComponentFonts_ptr getCharacteristicsComponentFonts()= 0;
+        Cache<Characteristics::ComponentFonts::BarcodeStandard> m_usedStandard;
+        Cache<Characteristics::ComponentFonts::FontList_var> m_Fonts;
+    };
+    class Bin: public virtual ComponentBase
+    {
+      public:
+        Bin();
+        long getBinSize();
+        bool getBinSize(long& binSize);
+        long getAllmostFullLevel();
+        bool getAllmostFullLevel(long& allmostFullLevel);
+        long getAllmostEmptyLevel();
+        bool getAllmostEmptyLevel(long& allmostEmptyLevel);
+        long getCurrentNoOfDocuments();
+        bool getCurrentNoOfDocuments(long& currentNoOfDocuments);
+        Characteristics::Bin_ptr getServant();
+      private:
+        virtual Characteristics::Bin_ptr getCharacteristicsBin()= 0;
+        Cache<long> m_binSize;
+        Cache<long> m_allmostFullLevel;
+        Cache<long> m_allmostEmptyLevel;
+        Cache<long> m_currentNoOfDocuments;
+    };
+    class IOMode: public virtual ComponentBase
+    {
+      public:
+        IOMode();
+        Characteristics::IOMode::InputOutputMode getMode();
+        bool getMode(Characteristics::IOMode::InputOutputMode& mode);
+        returncodes::rc setIOMode(const Characteristics::IOMode::InputOutputMode& mode);
+        Characteristics::IOMode_ptr getServant();
+      private:
+        virtual Characteristics::IOMode_ptr getCharacteristicsIOMode()= 0;
+        Cache<Characteristics::IOMode::InputOutputMode> m_mode;
+    };
+    class Capture: public Bin, public Manufacturer, public virtual ComponentBase
+    {};
+    class DataInput: public Manufacturer, public virtual ComponentBase
+    {
+      public:
+        DataInput();
+        long getTimeZone();
+        bool getTimeZone(long& timeZone);
+        Characteristics::DataInput_ptr getServant();
+      private:
+        virtual Characteristics::DataInput_ptr getCharacteristicsDataInput()= 0;
+        Cache<long> m_timeZone;
+    };
+    class DataOutput: public Manufacturer, public virtual ComponentBase
+    {};
+    class Dispenser: public Bin, public Location, public Manufacturer, public virtual ComponentBase
+    {
+      public:
+        Dispenser();
+        Characteristics::Dispenser::DispenserType getKind();
+        bool getKind(Characteristics::Dispenser::DispenserType& kind);
+        Characteristics::Dispenser_ptr getServant();
+      private:
+        virtual Characteristics::Dispenser_ptr getCharacteristicsDispenser()= 0;
+        Cache<Characteristics::Dispenser::DispenserType> m_kind;
+    };
+    class Feeder: public Bin, public Manufacturer, public virtual ComponentBase
+    {};
+    class MediaInput: public IOMode, public MediaTypeList, public ComponentFonts, public Location, public Manufacturer, public virtual ComponentBase
+    {
+      public:
+        MediaInput();
+        Characteristics::MediaInput::ReaderType getTypeOfReader();
+        bool getTypeOfReader(Characteristics::MediaInput::ReaderType& typeOfReader);
+        Characteristics::DataTypeList_var getSupportedDataTypes();
+        bool getSupportedDataTypes(Characteristics::DataTypeList_var& supportedDataTypes);
+        Characteristics::DataType getSetupDataType();
+        bool getSetupDataType(Characteristics::DataType& setupDataType);
+        long getNumberOfTracks();
+        bool getNumberOfTracks(long& numberOfTracks);
+        Characteristics::MediaInput_ptr getServant();
+      private:
+        virtual Characteristics::MediaInput_ptr getCharacteristicsMediaInput()= 0;
+        Cache<Characteristics::MediaInput::ReaderType> m_typeOfReader;
+        Cache<Characteristics::DataTypeList_var> m_supportedDataTypes;
+        Cache<Characteristics::DataType> m_setupDataType;
+        Cache<long> m_numberOfTracks;
+    };
+    class MediaOutput: public IOMode, public MediaTypeList, public ComponentFonts, public Location, public Manufacturer, public virtual ComponentBase
+    {
+      public:
+        MediaOutput();
+        Characteristics::MediaOutput::MediaType getType();
+        bool getType(Characteristics::MediaOutput::MediaType& type);
+        Characteristics::DataTypeList_var getSupportedDataTypes();
+        bool getSupportedDataTypes(Characteristics::DataTypeList_var& supportedDataTypes);
+        long getBufferSize();
+        bool getBufferSize(long& bufferSize);
+        long getNumberOfTracks();
+        bool getNumberOfTracks(long& numberOfTracks);
+        long getMinDocumentLength();
+        bool getMinDocumentLength(long& minDocumentLength);
+        long getMaxDocumentLength();
+        bool getMaxDocumentLength(long& maxDocumentLength);
+        long getMaxPrintSizeX();
+        bool getMaxPrintSizeX(long& maxPrintSizeX);
+        long getMaxPrintSizeY();
+        bool getMaxPrintSizeY(long& maxPrintSizeY);
+        Characteristics::MediaOutput::PrintOrientationDef getPrintOrientation();
+        bool getPrintOrientation(Characteristics::MediaOutput::PrintOrientationDef& printOrientation);
+        returncodes::rc setPrintOrientation(const Characteristics::MediaOutput::PrintOrientationDef& orientation);
+        Characteristics::MediaOutput_ptr getServant();
+      private:
+        virtual Characteristics::MediaOutput_ptr getCharacteristicsMediaOutput()= 0;
+        Cache<Characteristics::MediaOutput::MediaType> m_type;
+        Cache<Characteristics::DataTypeList_var> m_supportedDataTypes;
+        Cache<long> m_bufferSize;
+        Cache<long> m_numberOfTracks;
+        Cache<long> m_minDocumentLength;
+        Cache<long> m_maxDocumentLength;
+        Cache<long> m_maxPrintSizeX;
+        Cache<long> m_maxPrintSizeY;
+        Cache<Characteristics::MediaOutput::PrintOrientationDef> m_printOrientation;
+    };
+    class Storage: public Manufacturer, public virtual ComponentBase
+    {
+      public:
+        Storage();
+        long getSize();
+        bool getSize(long& size);
+        std::string getPath();
+        bool getPath(std::string& path);
+        Characteristics::Storage_ptr getServant();
+      private:
+        virtual Characteristics::Storage_ptr getCharacteristicsStorage()= 0;
+        Cache<long> m_size;
+        Cache<std::string> m_path;
+    };
+    class Display: public Location, public Manufacturer, public virtual ComponentBase
+    {
+      public:
+        Display();
+        Characteristics::Display::ResolutionList_var getDisplayResolution();
+        bool getDisplayResolution(Characteristics::Display::ResolutionList_var& displayResolution);
+        long getCurrentResolution();
+        bool getCurrentResolution(long& currentResolution);
+        returncodes::rc setScreenResolution(long resolution);
+        long getScreenDiagonal();
+        bool getScreenDiagonal(long& screenDiagonal);
+        Characteristics::Display_ptr getServant();
+      private:
+        virtual Characteristics::Display_ptr getCharacteristicsDisplay()= 0;
+        Cache<Characteristics::Display::ResolutionList_var> m_displayResolution;
+        Cache<long> m_currentResolution;
+        Cache<long> m_screenDiagonal;
+    };
+    class UserInput: public Location, public Manufacturer, public virtual ComponentBase
+    {};
+    class UserOutput: public Location, public Manufacturer, public virtual ComponentBase
+    {};
+    class Network: public Manufacturer, public virtual ComponentBase
+    {};
+    class Application: public Manufacturer, public virtual ComponentBase
+    {
+      public:
+        Application();
+        types::akID_var getIdentification();
+        bool getIdentification(types::akID_var& identification);
+        Characteristics::Application::ContactList_var getAllContacts();
+        bool getAllContacts(Characteristics::Application::ContactList_var& allContacts);
+        long getFirstIPPort();
+        bool getFirstIPPort(long& firstIPPort);
+        long getLastIPPort();
+        bool getLastIPPort(long& lastIPPort);
+        Characteristics::Application_ptr getServant();
+      private:
+        virtual Characteristics::Application_ptr getCharacteristicsApplication()= 0;
+        Cache<types::akID_var> m_identification;
+        Cache<Characteristics::Application::ContactList_var> m_allContacts;
+        Cache<long> m_firstIPPort;
+        Cache<long> m_lastIPPort;
+    };
+    class Conveyor: public Location, public Manufacturer, public virtual ComponentBase
+    {
+      public:
+        Conveyor();
+        long getMaxWeight();
+        bool getMaxWeight(long& maxWeight);
+        Characteristics::Conveyor::ConveyorType getTypeOfConveyor();
+        bool getTypeOfConveyor(Characteristics::Conveyor::ConveyorType& typeOfConveyor);
+        long getMaxWidth();
+        bool getMaxWidth(long& maxWidth);
+        long getMaxHeigth();
+        bool getMaxHeigth(long& maxHeigth);
+        long getMaxLength();
+        bool getMaxLength(long& maxLength);
+        long getGuarenteedNoOfBags();
+        bool getGuarenteedNoOfBags(long& guarenteedNoOfBags);
+        long getCurrentNoOfBagsParked();
+        bool getCurrentNoOfBagsParked(long& currentNoOfBagsParked);
+        Characteristics::Conveyor_ptr getServant();
+      private:
+        virtual Characteristics::Conveyor_ptr getCharacteristicsConveyor()= 0;
+        Cache<long> m_maxWeight;
+        Cache<Characteristics::Conveyor::ConveyorType> m_typeOfConveyor;
+        Cache<long> m_maxWidth;
+        Cache<long> m_maxHeigth;
+        Cache<long> m_maxLength;
+        Cache<long> m_guarenteedNoOfBags;
+        Cache<long> m_currentNoOfBagsParked;
+    };
+  }
+  namespace cuss_components
+  {
+    class Component
+    {};
+    class CUSSCntl: public Component, public virtual ComponentBase
+    {
+      public:
+        returncodes::rc query(long to, types::Event_out e);
+        Components::CUSSCntl_ptr getServant();
+      private:
+        virtual Components::CUSSCntl_ptr getComponentsCUSSCntl()= 0;
+    };
+    class Peripheral: public CUSSCntl, public virtual ComponentBase
+    {
+      public:
+        returncodes::rc acquire(types::evtListener_ptr el, types::Event_out e);
+        returncodes::rc release(types::Event_out e);
+        returncodes::rc setup(long to, const types::datastream& ds, types::Event_out e);
+        returncodes::rc cancel(types::Event_out e);
+        returncodes::rc test(long to, types::Event_out e);
+        Components::Peripheral_ptr getServant();
+        virtual Components::Peripheral_ptr getComponentsPeripheral()= 0;
+    };
+    class Input: public virtual ComponentBase
+    {
+      public:
+        returncodes::rc receive(long to, types::Event_out e);
+        Components::Input_ptr getServant();
+      private:
+        virtual Components::Input_ptr getComponentsInput()= 0;
+    };
+    class Output: public virtual ComponentBase
+    {
+      public:
+        returncodes::rc send(long to, const types::datastream&  ds, types::Event_out e);
+        Components::Output_ptr  getServant();
+      private:
+        virtual Components::Output_ptr getComponentsOutput()= 0;
+    };
+    class User: public virtual ComponentBase
+    {
+      public:
+        returncodes::rc enable(long to, types::Event_out e);
+        returncodes::rc disable(long to, types::Event_out e);
+        Components::User_ptr getServant();
+      private:
+        virtual Components::User_ptr getComponentsUser()= 0;
+    };
+    class Userless: public virtual ComponentBase
+    {};
+    class Media: public virtual ComponentBase
+    {};
+    class Medialess: public virtual ComponentBase
+    {};
+    class Data: public virtual ComponentBase
+    {};
+    class Dataless: public virtual ComponentBase
+    {};
+    /*
+    class ManagementInterface: public Component, public virtual ComponentBase
+    {
+      public:
+        returncodes::rc level(const types::akID& appid, types::EnvironmentLevel_out el);
+        returncodes::rc components(types::EnvironmentComponents_out ec);
+        returncodes::rc waitEvent(long to, const types::evtFilter& ef, types::Event_out e);
+        returncodes::rc generateEvent(const types::Event& ie, types::Event_out oe);
+        returncodes::rc queryEvent(const types::evtFilter& ef, types::evtDescription_out ed);
+        returncodes::rc registerEvent(const types::action& act, const types::evtFilter& ef, const types::evtListener& el, const types::correlation& elud, types::Event_out e);
+        Components::ManagementInterface_ptr getServant();
+      private:
+        virtual Components::ManagementInterface_ptr getComponentsManagementInterface()= 0;
+    };
+    */
+    class Capture: public Peripheral, public Userless, public Media, public Dataless, public cuss_characteristics::Capture, public virtual ComponentBase
+    {
+      public:
+        Capture& operator=(const Capture& assign);
+        returncodes::rc retain(long to, types::Event_out e);
+        Components::Capture_ptr getServant();
+      private:
+        virtual Components::Capture_ptr getComponentsCapture()= 0;
+    };
+    class Dispenser: public Peripheral, public User, public Media, public Dataless, public cuss_characteristics::Dispenser, public virtual ComponentBase
+    {
+      public:
+        Dispenser& operator=(const Dispenser& assign);
+        returncodes::rc offer(long to, types::Event_out e);
+        Components::Dispenser_ptr getServant();
+      private:
+        virtual Components::Dispenser_ptr getComponentsDispenser()= 0;
+    };
+    class Feeder: public Peripheral, public Userless, public Media, public Dataless, public cuss_characteristics::Feeder, public virtual ComponentBase
+    {
+      public:
+        Feeder& operator=(const Feeder& assign);
+        returncodes::rc offer(long to, types::Event_out e);
+        Components::Feeder_ptr getServant();
+      private:
+        virtual Components::Feeder_ptr getComponentsFeeder()= 0;
+    };
+    class DataInput: public Peripheral, public Userless, public Medialess, public Data, public Input, public cuss_characteristics::DataInput, public virtual ComponentBase
+    {
+      public:
+        DataInput& operator=(const DataInput& assign);
+    };
+    class DataOutput: public Peripheral, public Userless, public Medialess, public Data, public Output, public cuss_characteristics::DataOutput, public virtual ComponentBase
+    {
+      public:
+        DataOutput& operator=(const DataOutput& assign);
+    };
+    class UserInput: public Peripheral, public User, public Medialess, public Data, public Input, public cuss_characteristics::UserInput, public virtual ComponentBase
+    {
+      public:
+        UserInput& operator=(const UserInput& assign);
+    };
+    class UserOutput: public Peripheral, public User, public Medialess, public Data, public Output, public cuss_characteristics::UserOutput, public virtual ComponentBase
+    {
+      public:
+        UserOutput& operator=(const UserOutput& assign);
+    };
+    class MediaInput: public Peripheral, public User, public Media, public Data, public Input, public cuss_characteristics::MediaInput, public virtual ComponentBase
+    {
+      public:
+        MediaInput& operator=(const MediaInput& assign);
+    };
+    class MediaOutput: public Peripheral, public User, public Media, public Data, public Output, public cuss_characteristics::MediaOutput, public virtual ComponentBase
+    {
+      public:
+        MediaOutput& operator=(const MediaOutput& assign);
+    };
+    class Storage: public Peripheral, public Userless, public Media, public cuss_characteristics::Storage, public virtual ComponentBase
+    {
+      public:
+        Storage& operator=(const Storage& assign);
+    };
+    class Display: public Peripheral, public User, public Medialess, public cuss_characteristics::Display, public virtual ComponentBase
+    {
+      public:
+        Display& operator=(const Display& assign);
+    };
+    class Network: public Peripheral, public Userless, public Medialess, public cuss_characteristics::Network, public virtual ComponentBase
+    {
+      public:
+        Network& operator=(const Network& assign);
+    };
+/*
+    class Application: public CUSSCntl, public cuss_characteristics::Application, public virtual ComponentBase
+    {
+      public:
+        Application& operator=(const Application& assign);
+    }
+*/
+    /*
+    class ApplicationManager: public ManagementInterface, public virtual ComponentBase
+    {
+      public:
+        returncodes::rc initrequest(types::Event_out e);
+        returncodes::rc notify(const types::akID& id, const types::evtCode& ec, types::Event_out e);
+        Components::ApplicationManager_ptr getServant();
+      private:
+        virtual Components::ApplicationManager_ptr getComponentsApplicationManager()= 0;
+    };
+    */
+    class Conveyor: public Peripheral, public User, public Medialess, public Data, public Input, public cuss_characteristics::Conveyor, public virtual ComponentBase
+    {
+      public:
+        Conveyor& operator=(const Conveyor& assign);
+        returncodes::rc accept(long to, types::Event_out e);
+        returncodes::rc reject(long to, types::Event_out e);
+        returncodes::rc forwardParked(long to, types::Event_out e);
+        returncodes::rc returnParked(long to, types::Event_out e);
+        returncodes::rc waitForRemovedBaggage(long to, types::Event_out e);
+        Components::Conveyor_ptr getServant();
+      private:
+        virtual Components::Conveyor_ptr getComponentsConveyor()= 0;
+    };
+  }
+}
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/CussIF/cussif.h b/SelfServiceCommon/Interfaces/inc/CussIF/cussif.h
new file mode 100644
index 00000000..3c0f8191
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/CussIF/cussif.h
@@ -0,0 +1,638 @@
+//---------------------------------------------------------------------------
+//
+//  file:       cussif.h
+//
+//  purpose:    CUSS Applications interface to the platform
+//
+//  date:       25.04.2002, 15:37
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+/** Main header file for CUSS Application implementation
+
+ @file      cussif.h
+ @date      25.04.2002
+ @version   1.0
+ @author    AGe - (C) Materna Information & Communications
+
+*/
+
+#ifndef CUSSIF_H
+#define CUSSIF_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#pragma warning(disable: 4786)
+#include <iostream>
+#include <signal.h>
+#include <map>
+#include <set>
+#include <list>
+#include <string>
+
+#include "corbaclnt.h"
+
+#include "comps.h"
+#include "types.h"
+#include "codes.h"
+#include "characteristics.h"
+#include "types_skel.h"
+
+#include "ping.h"
+#include "ping_skel.h"
+
+#include "orbs.h"
+#include "vcomp.h"
+#include "polling.h"
+
+#include "mThreadEx.h"
+#include "mEventSem.hpp"
+#include "callbackthread.h"
+
+
+// global definitions
+
+using namespace CORBA;
+
+using namespace std;
+using namespace types;
+using namespace Components;
+
+namespace MASSAI
+{
+
+
+
+class amInterface;
+
+/** Massai specific error codes */
+
+enum errorCodes
+{
+    noError          = 0,           /**< No error */
+    missingComponent = 1000,        /**< Virtual component not available or not found */
+
+    atb2ScannerError,               /**< AEA scanner for ATB2 returned error */
+    btpScannerError,                /**< AEA scanner for BTP returned error */
+
+    noGeneralPurposeStock,          /**< No general purpose documents available */
+    noBoardingPassStock,            /**< No boarding pass documents available */
+    noTicketStock,                  /**< No ticket documents available  */
+
+    noBoardingPassEconomyStock,     /**< No economy class boarding pass documents available */
+    noBoardingPassBusinessStock,    /**< No business class boarding pass documents available */
+    noBoardingPassFirstStock,       /**< No first class boarding pass documents available */
+
+    emptyGeneralPurposeStock,       /**< General purpose documents empty */
+    emptyBoardingPassStock,         /**< Boarding pass documents empty */
+    emptyTicketStock,               /**< Ticket documents empty  */
+
+    emptyBoardingPassEconomyStock,  /**< Economy class boarding pass documents empty */
+    emptyBoardingPassBusinessStock, /**< Business class boarding pass documents empty */
+    emptyBoardingPassFirstStock,    /**< First class boarding pass documents empty */
+
+    parameterError                  /**< Error in parameters passed to function */
+};
+
+/** Implementation of CUSS Application manager interface */
+
+class amInterface : public POA_types::evtListener, public TerminationBase, private CallbackThread
+{
+public:
+
+    typedef std::set<Characteristics::MediaType::MediaTypeDef> MediaTypeSet;
+    typedef std::set<Characteristics::DataType> DataTypeSet;
+
+    typedef std::set<long> FailedComponents;
+
+private:
+
+    bool                      fConnected;
+    long                      lError;
+    char                      szAppRef          [512];
+    char                      szCompanyCode     [256];
+    char                      szApplicationName [256];
+    char                      szVendorCode      [256];
+
+    corbaCallbackClientTerminator  <ApplicationManager> *cclnt;
+    ApplicationManager_var                     ami;
+    EnvironmentComponents_var                  ec;
+    EnvironmentLevel_var                       el;
+    akID                                       akid;
+
+    struct MediaInputData
+    {
+      MediaInputData();
+      Characteristics::ComponentFonts::BarcodeStandard barcodetype;
+      Characteristics::MediaInput::ReaderType readertype;
+      MediaTypeSet mediatype;
+      DataTypeSet datatype;
+    };
+
+    struct MediaOutputData
+    {
+      MediaOutputData();
+      Characteristics::MediaOutput::MediaType writertype;
+      MediaTypeSet mediatype;
+      DataTypeSet datatype;
+    };
+
+    struct ConveyorData
+    {
+      ConveyorData();
+      Characteristics::Conveyor::ConveyorType conveyortype;
+    };
+
+    struct DispenserData
+    {
+      DispenserData();
+      Characteristics::Dispenser::DispenserType dispensertype;
+    };
+
+    typedef std::map<long, MediaInputData> MediaInputMapping;
+    typedef std::map<long, MediaOutputData> MediaOutputMapping;
+    typedef std::map<long, ConveyorData> ConveyorMapping;
+    typedef std::map<long, DispenserData> DispenserMapping;
+
+    MediaInputMapping  mediainput;
+    MediaOutputMapping mediaoutput;
+    ConveyorMapping    conveyor;
+    DispenserMapping   dispenser;
+    FailedComponents   failed;
+
+    enum ComponentState
+    {
+      CS_NOT_CONNECTED,
+      CS_CONNECTED,
+      CS_NOT_CONNECTED_RETRY,
+      CS_FAILED
+    };
+
+    ComponentState state;
+    bool           registered;
+    std::string    iorRef;
+
+    bool connect();
+    long setListener(bool retry= true);
+    bool catch_cuss_exception(bool retry= true);
+
+
+    void callback(const Event& ev);
+    virtual void callback(CallbackComponent component, const types::Event& ev, int id);
+
+    /** Returns the listener */
+
+    types::evtListener *listener() { return(_this()); }
+
+protected:
+
+    /** Set default values and timestamp for the specified event */
+
+    void prepareEvent (Event &ev);
+
+    /** Returns the CORBA object that executes the directives */
+
+    ApplicationManager_var object() { return(ami); }
+
+    /** Allow derived classes to re-implement CUSS event listeners */
+
+    virtual void amInterfaceCallback(const Event& ev);
+
+    void startProcessing();
+
+public:
+
+    /** Returns the current error */
+
+    long error ();
+
+    /** Set application reference (token) explicitly.
+        Can be used if the application gets a valid reference from a
+        starter frontend. In such a case the application does not
+        need to initialize itself at the application manager
+
+        @param  pszAppRef - Pointer to a string containing the reference
+    */
+
+    void setAppReference (const char *pszAppRef);
+
+    /** Returns the actual application token/reference */
+
+    char *getAppReference() { return(szAppRef); }
+
+    /** Get the environment in which the application runs */
+
+    long queryEnvironment();
+
+    /** Retrieve the list of components from the platform
+        @param pszAppRef - A valid reference (token). Needed
+        only if the reference was not set in advance
+        @return Error code or 0 on success
+    */
+
+    long queryComponents (const char *pszAppRef = NULL);
+    const FailedComponents& queryFailedComponents() const;
+    long retryComponentRetrieval();
+    long retryComponentRetrieval(long comp);
+
+    /** Returns the CUSS environment components list */
+
+    EnvironmentComponents_var getComponents();
+
+    /** Returns the CUSS environment the application is running in */
+
+    EnvironmentLevel_var getEnvironment();
+
+    /** Returns the number components retrieved
+        @return Number of components or -1 if queryComponents() has not been called
+     */
+
+    long noOfComponents ();
+
+    /** Requests application manager for initialization allowance */
+
+    long waitToInitialize ();
+
+    /** Send an event to the application manager
+        @param eventCode - event specification
+    */
+
+    long notify (long eventCode);
+
+    /** Register/Deregister an event listener to/from the application manager
+        @param fRegister - register/unregister switch
+    */
+
+    long registerForEvents(bool fRegister = true);
+
+
+    /** Check if the specified real component is available in the platform
+        @return TRUE if component is available, FALSE otherwise
+     */
+
+    bool queryRealComponent(const char *pszRealCompName);
+
+    /** Query the real component for a reader type from the components table.
+        @param lIndex - Starting index (typically 0), returned index or -1 if no component was found
+        @param readertype - ReaderType as defined in CUSS
+        @param barcodetype - BarcodeStandard as defined in CUSS
+        @param mediatype - set of MediaType as defined in CUSS
+        @param datatype - set of DataType as defined in CUSS
+        @return real componenet name or NULL if not found
+    */
+
+    const char* queryMediaInputNegateBarcode(long& lIndex, Characteristics::MediaInput::ReaderType readertype, Characteristics::ComponentFonts::BarcodeStandard barcodetype, MediaTypeSet& mediatype, DataTypeSet& datatype);
+    const char* queryMediaInputNegateBarcode(long& lIndex, Characteristics::ComponentFonts::BarcodeStandard barcodetype, MediaTypeSet& mediatype, DataTypeSet& datatype);
+    const char* queryMediaInput(long& lIndex, Characteristics::MediaInput::ReaderType readertype, Characteristics::ComponentFonts::BarcodeStandard barcodetype, MediaTypeSet& mediatype, DataTypeSet& datatype);
+    const char* queryMediaInput(long& lIndex, Characteristics::MediaInput::ReaderType readertype, MediaTypeSet& mediatype, DataTypeSet& datatype);
+    const char* queryMediaInput(long& lIndex, Characteristics::ComponentFonts::BarcodeStandard barcodetype, MediaTypeSet& mediatype, DataTypeSet& datatype);
+    const char* queryMediaInput(long& lIndex, MediaTypeSet& mediatype, DataTypeSet& datatype);
+
+    /** Query the real component for a media type from the components table.
+        @param lIndex - Starting index (typically 0), returned index or -1 if no component was found
+        @param writertype - MediaType as defined in CUSS
+        @param mediatype - set of MediaType as defined in CUSS
+        @param datatype - set of DataType as defined in CUSS
+        @return real componenet name or NULL if not found
+    */
+
+    const char* queryMediaOutput(long& lIndex, Characteristics::MediaOutput::MediaType writertype, MediaTypeSet& mediatype, DataTypeSet& datatype);
+    const char* queryMediaOutput(long& lIndex, MediaTypeSet& mediatype, DataTypeSet& datatype);
+
+    /** Query the real component for a conveyor type from the components table.
+        @param lIndex - Starting index (typically 0), returned index or -1 if no component was found
+        @param conveyortype - ConveyorType as defined in CUSS
+        @return real componenet name or NULL if not found
+    */
+
+    const char* queryConveyor(long& lIndex, Characteristics::Conveyor::ConveyorType conveyortype);
+    const char* queryConveyor(long& lIndex);
+
+    /** Query the CORBA object reference from the components table.
+        @param lIndex - Starting index (typically 0), returned index or -1 if no component was found
+        @param pszRealCompName - Real Component name as defined in CUSS (eg. BPPDevice)
+        @param pszVirtualCompName - Virtual Component type name as defined in CUSS (eg. MediaInput)
+        @return CORBA object reference or NULL if not found
+    */
+
+    const char *ior(long& lIndex, const char *pszRealCompName, const char *pszVirtualCompName);
+
+    /** Query the CORBA object reference from the components table.
+        @param lIndex - Starting index (typically 0), returned index or -1 if no component was found
+        @param pszRealCompName - Real Component name as defined in CUSS (eg. BPPDevice)
+        @param pszVirtualCompName - Virtual Component type name as defined in CUSS (eg. MediaInput)
+        @param pszExL1 - If this virtual component name is found in the linked list, continue searching (first option)
+        @param pszExL2 - If this virtual component name is found in the linked list, continue searching (second option)
+        @return CORBA object reference or NULL if not found
+    */
+
+    const char *iorExclude(long& lIndex, const char *pszRealCompName, const char *pszVirtualCompName, const char *pszExL1, const char *pszExL2 = NULL);
+
+    /** Query the CORBA object reference from the components table.
+        @param lIndex - Starting index (typically 0), returned index or -1 if no component was found
+        @param pszRealCompName - Real Component name as defined in CUSS (eg. BPPDevice)
+        @param pszVirtualCompName - Virtual Component type name as defined in CUSS (eg. MediaInput)
+        @param pszInL1 - If this virtual component name is NOT found in the linked list, continue searching (first option)
+        @param pszInL2 - If this virtual component name is NOT found in the linked list, continue searching (second option)
+        @return CORBA object reference or NULL if not found
+    */
+
+    const char *iorInclude(long& lIndex, const char *pszRealCompName, const char *pszVirtualCompName, const char *pszInL1, const char *pszInL2 = NULL);
+    const char *iorInclude(long& lIndex, const char *pszRealCompName, const char *pszInL1, Characteristics::Dispenser::DispenserType dispensertype);
+
+    /** Query the linked CORBA object reference from the components table.
+        @param lIndex - Index of component with linked components
+        @param lStartIndex - Starting index in linked components (typically 0), returned index or -1 if no linked component was found
+        @param pszVirtualCompName - Virtual Component type name as defined in CUSS (eg. MediaInput)
+        @return CORBA object reference or NULL if not found
+    */
+
+    const char *iorLinked(const long lIndex,long& lStartIndex,const char *pszVirtualCompName);
+    const char *iorLinked(const long lIndex, long& lStartIndex, Characteristics::Dispenser::DispenserType dispensertype);
+
+    /** Query all linked components from the components table.
+        @param lIndex - Index of component with linked components
+        @param linked - receives the linked components
+        @param pszVirtualCompName - Virtual Component type name as defined in CUSS (eg. MediaInput)
+    */
+    void queryLinkedComponents(long lIndex,  std::list<long>& linked, const char *pszVirtualCompName);
+
+    /** Tries to connect the kiosks application manager interface. Use a corbaloc-identifier,
+        a CORBA-IOR identifier or an IP-Address to get the connection. If neither a corbaloc-
+        nor an IOR identifier is given the constructor builds a corbaloc-identifier from
+        the given object reference, so at least it has to be a valid IP address.
+
+        @param pszIOR - The object reference
+    */
+
+    long connect(char *pszIOR);
+
+    /** Check if application manager is connected
+        @return TRUE if applivcation manager is connected, FALSE otherwise
+    */
+
+    bool connected() { return(fConnected); }
+
+    /** Class constructor.
+        Tries to connect the kiosks application manager interface. Use a corbaloc-identifier,
+        a CORBA-IOR identifier or an IP-Address to get the connection. If neither a corbaloc-
+        nor an IOR identifier is given the constructor builds a corbaloc-identifier from
+        the given object reference, so at least it has to be a valid IP address.
+
+        @param pszIOR - The object reference
+        @param pszCompanyCode - The company code (eg SR,BA,LG)
+        @param pszApplicationName - The name of the application
+        @param pszVendorCode - The company code of the application vendor
+    */
+
+    amInterface(char *pszIOR = NULL,
+                char *pszCompanyCode = NULL,
+                char *pszApplicationName = NULL,
+                char *pszVendorCode = NULL);
+
+    /** Class destructor */
+
+    ~amInterface();
+};
+
+/** Standard implementation of a CUSS application */
+
+class cussApplication : public amInterface,
+                        public vCompApp,
+                        private mThreadEx
+{
+public:
+
+    enum appState { STOPPED      = 1,
+                    DISABLED     = 2,
+                    ACTIVE       = 3,
+                    SUSPENDED    = 4,
+                    IDLE         = 5,
+                    UNAVAILABLE  = 6,
+                    INITIALIZING = 7
+                  };
+
+    enum appType { INIT = 0, BUSINESS = 1 };
+
+    enum appMode { SINGLE_APPLICATION = 1, MULTI_APPLICATION  = 2 };
+
+private:
+
+    CUSSCntl_var vcApplication;       // applications virtual component
+
+    corbaClientTerminator  <massaiPinger::Pinger> *pingClnt;
+
+    appType      applicationType;
+
+    appMode      applicationMode;
+
+    char         szPingerIOR[256];
+    char         szIOR      [1024];
+
+    long         checkAppMgrMinutes;
+
+    bool         fSelfSuspended;
+    bool         fTerminate;
+    bool         fOrbDestroyed;
+    bool         fEventsRegistered;
+
+    std::string  branding;
+    std::string  language;
+
+    Materna::MSSD::eventSemaphore     pingThreadStopped;  // notify if ping thread terminates
+    long                              pingResult;
+    mThreadMutex                      transitionMutex;
+
+
+
+    void         initialize           ();
+
+    long         handleResume         (long evc);
+    long         handleSuspend        (long evc);
+    long         handleInit           (long evc);
+    long         handleStart          (long evc);
+    long         handleIdle           (long evc);
+    long         handleStop           (long evc);
+    long         handleActivate       (long evc);
+    long         handleOnScreen       (long evc);
+    long         handleOffScreen      (long evc);
+    long         handleDisable        (long evc);
+    long         handleReactivate     (long evc);
+
+    bool         appManagerEvent      (const Event& ev);
+    bool         applicationEvent     (long evc);
+
+    void         amInterfaceCallback  (const Event& ev);
+
+    bool         isTerminating() const;
+
+    // overwrite function of mThreadEx
+    // send pings to pingClnt
+    long         function();
+
+
+protected:
+
+    /** This handler is called when the application lost it's connection to application manager or kiosk proxy */
+
+    virtual void appmgrLost();
+
+    /** This handler is called upon event reception from the application manager.
+        The handler is called only if the event is not an application state change event.
+        @param eventCode - The event code according to the CUSS specification
+        @param statusCode - The status code according to the CUSS specification
+    */
+
+    virtual void platformEvent (long eventCode, long statusCode);
+
+    /** This handler is called when the application is disabled by the application manager */
+
+    virtual long disable();
+
+    /** This handler is called when the application is activated by the application manager
+        @param el The CUSS environment the application is running in.
+    */
+
+    virtual long activate(EnvironmentLevel_var el);
+
+    /** This handler is called when the application is requested to go into the stopped state */
+
+    virtual long stop();
+
+    /** This handler is called when the application is requested to go into the suspended state */
+
+    virtual long suspend();
+
+    /** This handler is called when the application is resumed either by itself or the application manager*/
+
+    virtual long resume();
+
+    /** This handler is called when the application is requested to go into idle state */
+
+    virtual long idle();
+
+    /** This handler is called when the application is requested to (re-)initialize
+        @param el The CUSS environment the application is running in.
+    */
+
+    virtual long initialize(EnvironmentLevel_var el);
+
+    /** Starts receiving events from the remote application manager.
+        Sets a listener for event reception.
+    */
+
+    void startHandlingEvents();
+
+    /** Stops receiving events from the remote application manager */
+
+    void stopHandlingEvents();
+
+public:
+    /** print function - prints to the file used by the core application */
+    virtual long massaiTrace(long lLevel,char *pszFile,long sLine,char *pText);
+    virtual long massaiCryptTrace(long lLevel,char *pszFile,long sLine,char *pData,long lLen);
+
+    appState state();
+
+    appMode mode();
+
+    //std::string getLanguage();
+    std::string getBranding();
+
+    /** Sets the value for checking application manager availability.
+        @param minutes - Specifies the check interval in minutes
+    */
+
+    void checkAppManager(long minutes = 0);
+
+    /** Starts the application.
+        @param fBlock - Specifies whether this call blocks or returns immediately
+    */
+
+    long run(bool fBlock = true);
+
+    /** Call this function to set the application into the UNAVAILABLE mode.
+        The application manager is notified about the state change.
+    */
+
+    long disableMe();
+
+    /** Call this function to remove the application from the UNAVAILABLE mode.
+        The application manager is notified about the state change.
+    */
+
+    long enableMe();
+
+    /** Call this function to indicate a new customer in SAM.
+        The application manager is notified about the state change.
+    */
+
+    long reactivateMe();
+
+    /** Call this function to set the application into the AVAILABLE mode.
+        The application manager is notified about the state change.
+        @param fTerminate - Terminates the blocking mode if set to TRUE
+    */
+
+    long idleMe(bool fTerminate = false);
+
+    /** Call this function to set the application into the STOPPED mode.
+        The application icon is removed from the CommonLaunchScreen.
+        The application manager is notified about the state change.
+        @param fTerminate - Terminates the blocking mode if set to TRUE
+    */
+
+    long stopMe(bool fTerminate = false);
+
+    /** Stopps the application (releases a blocking run() call */
+
+    long terminate();
+
+    /** sets the trace level for debugging the CUSS interface */
+
+    long setTraceLevel(long level);
+
+    /** This handler is called upon segmentation faults, 0-divisions and illegal instructions.
+        Very last chance to clean up and terminate the application.
+    */
+
+    virtual long criticalError(int iSignal);
+
+    /** This handler is called if a termination signal is received like CTRL-C.
+        Very last chance to clean up and terminate the application.
+    */
+
+    virtual long userBreak(int iSignal);
+
+    /** Class constructor.
+        @param pszObjRef - The object reference
+        @param pszCompanyCode - The company code (eg LH,BA,LG,...)
+        @param pszApplicationName - The name of the application
+        @param pszVendorCode - The company code of the application vendor
+    */
+
+    cussApplication(char *pszObjRef,
+                    char *pszCompanyCode,
+                    char *pszApplicationName,
+                    char *pszVendorCode);
+
+    /** Class destructor */
+
+    virtual ~cussApplication();
+};
+
+/** \class cussApplication
+ *  \example client.cpp
+ */
+
+/** \class cussApplication
+ *  \example client.h
+ */
+
+}; // namespace MASSAI
+
+#endif //CUSSIF_H
diff --git a/SelfServiceCommon/Interfaces/inc/CussIF/cussif_component.h b/SelfServiceCommon/Interfaces/inc/CussIF/cussif_component.h
new file mode 100644
index 00000000..2d0d20d9
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/CussIF/cussif_component.h
@@ -0,0 +1,276 @@
+//---------------------------------------------------------------------------
+//
+//  file:       cussif_component.h
+//
+//  purpose:    interface fore cuss corba calls
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef CUSSIF_COMPONENT_H_INCLUDED
+#define CUSSIF_COMPONENT_H_INCLUDED
+
+
+#include "cussif/cuss_component.h"
+
+
+
+namespace massai
+{
+  namespace cussif
+  {
+/*
+    class Application: public massai::cuss_components::Application
+    {
+      public:
+        Application();
+        Application(class MASSAI::vComponent* pComp, int ident= 0);
+        Application& operator=(const Application& assign);
+      private:
+        Components::Application_var m_component;
+        void narrow(class MASSAI::vComponent*& pComponent, const char* pszIOR);
+
+        Characteristics::Manufacturer_ptr getCharacteristicsManufacturer();
+        Components::CUSSCntl_ptr getComponentsCUSSCntl();
+        Characteristics::Application_ptr getCharacteristicsApplication();
+    };
+*/
+    class Capture: public massai::cuss_components::Capture
+    {
+      public:
+        Capture();
+        Capture(class MASSAI::vComponent* pComp, int ident= 0);
+        Capture& operator=(const Capture& assign);
+      private:
+        Components::Capture_var m_component;
+        void narrow(class MASSAI::vComponent*& pComponent, const char* pszIOR);
+
+        Characteristics::Bin_ptr getCharacteristicsBin();
+        Characteristics::Manufacturer_ptr getCharacteristicsManufacturer();
+        Components::CUSSCntl_ptr getComponentsCUSSCntl();
+        Components::Peripheral_ptr getComponentsPeripheral();
+        Components::Userless_ptr getComponentsUserless();
+        Components::Capture_ptr getComponentsCapture();
+    };
+    class Conveyor: public massai::cuss_components::Conveyor
+    {
+      public:
+        Conveyor();
+        Conveyor(class MASSAI::vComponent* pComp, int ident= 0);
+        Conveyor& operator=(const Conveyor& assign);
+      private:
+        Components::Conveyor_var m_component;
+        void narrow(class MASSAI::vComponent*& pComponent, const char* pszIOR);
+
+        Characteristics::Location_ptr getCharacteristicsLocation();
+        Characteristics::Manufacturer_ptr getCharacteristicsManufacturer();
+        Components::CUSSCntl_ptr getComponentsCUSSCntl();
+        Components::Peripheral_ptr getComponentsPeripheral();
+        Components::User_ptr getComponentsUser();
+        Components::Input_ptr getComponentsInput();
+        Characteristics::Conveyor_ptr getCharacteristicsConveyor();
+        Components::Conveyor_ptr getComponentsConveyor();
+    };
+    class DataInput: public massai::cuss_components::DataInput
+    {
+      public:
+        DataInput();
+        DataInput(class MASSAI::vComponent* pComp, int ident= 0);
+        DataInput& operator=(const DataInput& assign);
+      private:
+        Components::DataInput_var m_component;
+        void narrow(class MASSAI::vComponent*& pComponent, const char* pszIOR);
+
+        Characteristics::Manufacturer_ptr getCharacteristicsManufacturer();
+        Components::CUSSCntl_ptr getComponentsCUSSCntl();
+        Components::Peripheral_ptr getComponentsPeripheral();
+        Components::Userless_ptr getComponentsUserless();
+        Components::Input_ptr getComponentsInput();
+        Characteristics::DataInput_ptr getCharacteristicsDataInput();
+    };
+    class DataOutput: public massai::cuss_components::DataOutput
+    {
+      public:
+        DataOutput();
+        DataOutput(class MASSAI::vComponent* pComp, int ident= 0);
+        DataOutput& operator=(const DataOutput& assign);
+      private:
+        Components::DataOutput_var m_component;
+        void narrow(class MASSAI::vComponent*& pComponent, const char* pszIOR);
+
+        Characteristics::Manufacturer_ptr getCharacteristicsManufacturer();
+        Components::CUSSCntl_ptr getComponentsCUSSCntl();
+        Components::Peripheral_ptr getComponentsPeripheral();
+        Components::Userless_ptr getComponentsUserless();
+        Components::Output_ptr getComponentsOutput();
+    };
+    class Dispenser: public massai::cuss_components::Dispenser
+    {
+      public:
+        Dispenser();
+        Dispenser(class MASSAI::vComponent* pComp, int ident= 0);
+        Dispenser& operator=(const Dispenser& assign);
+      private:
+        Components::Dispenser_var m_component;
+        void narrow(class MASSAI::vComponent*& pComponent, const char* pszIOR);
+
+        Characteristics::Bin_ptr getCharacteristicsBin();
+        Characteristics::Location_ptr getCharacteristicsLocation();
+        Characteristics::Manufacturer_ptr getCharacteristicsManufacturer();
+        Components::CUSSCntl_ptr getComponentsCUSSCntl();
+        Components::Peripheral_ptr getComponentsPeripheral();
+        Components::User_ptr getComponentsUser();
+        Characteristics::Dispenser_ptr getCharacteristicsDispenser();
+        Components::Dispenser_ptr getComponentsDispenser();
+    };
+    class Display: public massai::cuss_components::Display
+    {
+      public:
+        Display();
+        Display(class MASSAI::vComponent* pComp, int ident= 0);
+        Display& operator=(const Display& assign);
+      private:
+        Components::Display_var m_component;
+        void narrow(class MASSAI::vComponent*& pComponent, const char* pszIOR);
+
+        Characteristics::Location_ptr getCharacteristicsLocation();
+        Characteristics::Manufacturer_ptr getCharacteristicsManufacturer();
+        Components::CUSSCntl_ptr getComponentsCUSSCntl();
+        Components::Peripheral_ptr getComponentsPeripheral();
+        Components::User_ptr getComponentsUser();
+        Characteristics::Display_ptr getCharacteristicsDisplay();
+    };
+    class Feeder: public massai::cuss_components::Feeder
+    {
+      public:
+        Feeder();
+        Feeder(class MASSAI::vComponent* pComp, int ident= 0);
+        Feeder& operator=(const Feeder& assign);
+      private:
+        Components::Feeder_var m_component;
+        void narrow(class MASSAI::vComponent*& pComponent, const char* pszIOR);
+
+        Characteristics::Bin_ptr getCharacteristicsBin();
+        Characteristics::Manufacturer_ptr getCharacteristicsManufacturer();
+        Components::CUSSCntl_ptr getComponentsCUSSCntl();
+        Components::Peripheral_ptr getComponentsPeripheral();
+        Components::Userless_ptr getComponentsUserless();
+        Components::Feeder_ptr getComponentsFeeder();
+    };
+    class MediaInput: public massai::cuss_components::MediaInput
+    {
+      public:
+        MediaInput();
+        MediaInput(class MASSAI::vComponent* pComp, int ident= 0);
+        MediaInput& operator=(const MediaInput& assign);
+      private:
+        Components::MediaInput_var m_component;
+        void narrow(class MASSAI::vComponent*& pComponent, const char* pszIOR);
+
+        Characteristics::IOMode_ptr getCharacteristicsIOMode();
+        Characteristics::MediaTypeList_ptr getCharacteristicsMediaTypeList();
+        Characteristics::ComponentFonts_ptr getCharacteristicsComponentFonts();
+        Characteristics::Location_ptr getCharacteristicsLocation();
+        Characteristics::Manufacturer_ptr getCharacteristicsManufacturer();
+        Components::CUSSCntl_ptr getComponentsCUSSCntl();
+        Components::Peripheral_ptr getComponentsPeripheral();
+        Components::User_ptr getComponentsUser();
+        Components::Input_ptr getComponentsInput();
+        Characteristics::MediaInput_ptr getCharacteristicsMediaInput();
+    };
+    class MediaOutput: public massai::cuss_components::MediaOutput
+    {
+      public:
+        MediaOutput();
+        MediaOutput(class MASSAI::vComponent* pComp, int ident= 0);
+        MediaOutput& operator=(const MediaOutput& assign);
+      private:
+        Components::MediaOutput_var m_component;
+        void narrow(class MASSAI::vComponent*& pComponent, const char* pszIOR);
+
+        Characteristics::IOMode_ptr getCharacteristicsIOMode();
+        Characteristics::MediaTypeList_ptr getCharacteristicsMediaTypeList();
+        Characteristics::ComponentFonts_ptr getCharacteristicsComponentFonts();
+        Characteristics::Location_ptr getCharacteristicsLocation();
+        Characteristics::Manufacturer_ptr getCharacteristicsManufacturer();
+        Components::CUSSCntl_ptr getComponentsCUSSCntl();
+        Components::Peripheral_ptr getComponentsPeripheral();
+        Components::User_ptr getComponentsUser();
+        Components::Output_ptr getComponentsOutput();
+        Characteristics::MediaOutput_ptr getCharacteristicsMediaOutput();
+    };
+    class Network: public massai::cuss_components::Network
+    {
+      public:
+        Network();
+        Network(class MASSAI::vComponent* pComp, int ident= 0);
+        Network& operator=(const Network& assign);
+      private:
+        Components::Network_var m_component;
+        void narrow(class MASSAI::vComponent*& pComponent, const char* pszIOR);
+
+        Characteristics::Manufacturer_ptr getCharacteristicsManufacturer();
+        Components::CUSSCntl_ptr getComponentsCUSSCntl();
+        Components::Peripheral_ptr getComponentsPeripheral();
+        Components::Userless_ptr getComponentsUserless();
+    };
+    class Storage: public massai::cuss_components::Storage
+    {
+      public:
+        Storage();
+        Storage(class MASSAI::vComponent* pComp, int ident= 0);
+        Storage& operator=(const Storage& assign);
+      private:
+        Components::Storage_var m_component;
+        void narrow(class MASSAI::vComponent*& pComponent, const char* pszIOR);
+
+        Characteristics::Manufacturer_ptr getCharacteristicsManufacturer();
+        Components::CUSSCntl_ptr getComponentsCUSSCntl();
+        Components::Peripheral_ptr getComponentsPeripheral();
+        Components::Userless_ptr getComponentsUserless();
+        Characteristics::Storage_ptr getCharacteristicsStorage();
+    };
+    class UserInput: public massai::cuss_components::UserInput
+    {
+      public:
+        UserInput();
+        UserInput(class MASSAI::vComponent* pComp, int ident= 0);
+        UserInput& operator=(const UserInput& assign);
+      private:
+        Components::UserInput_var m_component;
+        void narrow(class MASSAI::vComponent*& pComponent, const char* pszIOR);
+
+        Characteristics::Location_ptr getCharacteristicsLocation();
+        Characteristics::Manufacturer_ptr getCharacteristicsManufacturer();
+        Components::CUSSCntl_ptr getComponentsCUSSCntl();
+        Components::Peripheral_ptr getComponentsPeripheral();
+        Components::User_ptr getComponentsUser();
+        Components::Input_ptr getComponentsInput();
+    };
+    class UserOutput: public massai::cuss_components::UserOutput
+    {
+      public:
+        UserOutput();
+        UserOutput(class MASSAI::vComponent* pComp, int ident= 0);
+        UserOutput& operator=(const UserOutput& assign);
+      private:
+        Components::UserOutput_var m_component;
+        void narrow(class MASSAI::vComponent*& pComponent, const char* pszIOR);
+
+        Characteristics::Location_ptr getCharacteristicsLocation();
+        Characteristics::Manufacturer_ptr getCharacteristicsManufacturer();
+        Components::CUSSCntl_ptr getComponentsCUSSCntl();
+        Components::Peripheral_ptr getComponentsPeripheral();
+        Components::User_ptr getComponentsUser();
+        Components::Output_ptr getComponentsOutput();
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/CussIF/dispclnt.h b/SelfServiceCommon/Interfaces/inc/CussIF/dispclnt.h
new file mode 100644
index 00000000..23dc9469
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/CussIF/dispclnt.h
@@ -0,0 +1,79 @@
+//---------------------------------------------------------------------------
+//
+//  file:       dispclnt.h
+//
+//  purpose:    Header file for CORBA display class.
+//
+//  date:       26.10.99, 08:40
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//  history:
+//  30.07.2001 ts void reqDisplay(aMap& screen) added
+//  20.09.2004 ts void reqDisplay(aMap& screen, bool xml= false) parameter xml added
+//                     uses xml for sending the data structure
+//  22.01.2007 SteT 27095: im CussIF den Parameter Timeout fr die Funktion showDisplay hinzufgen
+//
+//---------------------------------------------------------------------------
+
+#ifndef DISPCLNT_H
+#define DISPCLNT_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "asso.h"
+#include "corbaclnt.h"
+
+#include "display.h"
+#include "display_skel.h"
+#include "polling.h"
+
+using namespace mDisplay;
+
+class indicationServer;
+
+namespace MASSAI
+{
+  class amInterface;
+};
+
+class displayClient
+{
+private:
+
+    char              szIOR[1024];
+
+    Screen           *pScreen;
+    indicationServer *pIndicationServer;
+
+    MASSAI::corbaCallbackClientTerminator<Screen> *cclnt;
+
+    bool fReconnected;
+    bool fAbort;
+    long connect(bool fReconnect = false, long lTimeout= 30000);
+
+    MASSAI::amInterface* pAmi;
+
+protected:
+
+    void         reqDisplay(displayTyp *pdt, long lTimeout= 30000);
+//  30.07.2001 ts void reqDisplay(aMap& screen) added
+//  20.09.2004 ts void reqDisplay(aMap& screen, bool xml= false) parameter xml added
+    void         reqDisplay(const aMap& screen, bool xml= false, long lTimeout= 30000);
+    void         reqDone();
+
+public:
+
+    void         abort();
+    virtual void indication(const dspReturnTyp& dr) = 0;
+
+    int          status();
+    virtual void statusCallback(const dspReturnTyp& dr);
+
+    displayClient(MASSAI::amInterface* pAmi, char *pszIOR);
+   ~displayClient();
+};
+
+#endif //DISPCLNT_H
diff --git a/SelfServiceCommon/Interfaces/inc/CussIF/dispdev.h b/SelfServiceCommon/Interfaces/inc/CussIF/dispdev.h
new file mode 100644
index 00000000..acc24ded
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/CussIF/dispdev.h
@@ -0,0 +1,386 @@
+//---------------------------------------------------------------------------
+//
+//  file:       dispdev.h
+//
+//  purpose:    Display XTRA device definition
+//
+//  date:       25.04.2002
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//  history:
+//  30.07.2001 ts long showDisplay(aMap& screen) added
+//                displayXTRA inherits from language
+//  20.09.2004 ts long showDisplay(aMap& screen, bool xml= false) parameter xml added
+//  22.01.2007 SteT 27095: im CussIF den Parameter Timeout fr die Funktion showDisplay hinzufgen
+//
+//---------------------------------------------------------------------------
+
+/** Header file for display devices implementation (Shockwave Connector)
+
+ @file      dispdev.h
+ @date      25.04.2002
+ @version   1.0
+ @author    AGe - (C) Materna Information & Communications
+
+*/
+
+#ifndef DISPDEV_H
+#define DISPDEV_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#ifndef CUSSIF_H
+
+#include "orbincdefs.h"
+
+#include "comps.h"
+#include "types.h"
+#include "codes.h"
+
+#include "orbs.h"
+
+#endif // CUSSIF_H
+
+#include "dispclnt.h"
+#include "vcomp.h"
+#include "asso.h"
+#include "language.h"  // 30.07.2001 ts displayXTRA inherits from language
+
+#include "manufacturer.h"
+#include "cussif/cussif_component.h"
+
+//using namespace std;
+using namespace types;
+using namespace Components;
+
+namespace MASSAI
+{
+class amInterface;
+
+/** Interface implementation for the Macromedia Shockwave display XTRA interface.
+    This is a massai specific implementation and does not map to any CUSS components.
+    To use this interface the massai display XTRA has to be installed with the
+    Macromedia Shockwave installation on the remote machine (kiosk).
+*/
+
+// 30.07.2001 ts displayXTRA inherits from language
+
+class displayXTRA : public vManufacturer,
+                    public vCompDisplay,
+                    public displayClient,
+                    public language
+{
+private:
+
+    std::ostream*                                pOutput;
+
+    massai::cussif::Display                   vcDisplay;
+    Characteristics::Display::ResolutionList_var rl;
+
+    void        indication           (const dspReturnTyp& dr);
+    void        displayCallback      (const Event& ev, int id);
+
+protected:
+
+    /** Returns the stream for debug output */
+
+    std::ostream* output() { return(pOutput); }
+
+    /** This handler is called upon data reception from the screen.
+        @param pszScreenId - The name of the screen
+        @param languageId - The current language for that screen
+        @param lError - Error value, if <> 0
+        @param lValue - Numerical value
+        @param pszButton - The name of the button that nhas been touched
+        @param pszValue - Alpha-numerical value
+    */
+
+    virtual void displayInput(char *pszScreenId,
+                              long  languageId,
+                              long  lError,
+                              long  lValue,
+                              char *pszButton,
+                              char *pszValue);
+
+public:
+
+    /** Definition of screen resolutions. */
+
+    enum resolution
+    {
+      RES_800x600,
+      RES_1024x768,
+      RES_1280x1024,
+      RES_1600x1200,
+      RES_ERROR
+    };
+
+    /** Returns the current screen resolution */
+
+    resolution currentResolution();
+
+    /** Checks if a specific display resolution is supported on kiosk
+        @param res - The resolution to check
+     */
+
+    bool supportsResolution(resolution res);
+
+    /** Checks if platform supports more than one dsiplay resolutions */
+
+    bool supportsMultipleResolutions();
+
+    /** Switches kiosk hardware to a specific display resolution
+        @param newRes - The new resolution to switch to
+     */
+
+    long switchResolution(resolution newRes);
+
+    /** Standard button IDs */
+
+    enum touchInput
+    {
+      Ok,               /**< 0:  Ok button */
+      Cancel,           /**< 1:  Cancel button */
+      Continue,         /**< 2:  Continue button */
+      Back,             /**< 3:  Back button */
+      Up,               /**< 4:  Up button */
+      Down,             /**< 5:  Down button */
+      Left,             /**< 6:  Left button */
+      Right,            /**< 7:  Right button */
+      Language,         /**< 8:  Language button */
+      Help,             /**< 9:  Help button */
+      Exit,             /**< 10: Exit button */
+      Select,           /**< 11: Selection in a listbox */
+      SmokerWindow,     /**< 12: Window seat in the smoking area */
+      SmokerAisle,      /**< 13: Aisle seat in the smoking area */
+      NonSmokerWindow,  /**< 14: Window seat in the non-smoking area*/
+      NonSmokerAisle,   /**< 15: Aisle seat in the non-smoking area */
+      Yes,              /**< 16: Yes button */
+      No_,              /**< 17: No button */
+      Reserved1,        /**< 18: Reserved1 button - for special usage */
+      Reserved2,        /**< 19: Reserved2 button - for special usage */
+      Reserved3,        /**< 20: Reserved3 button - for special usage */
+      Reserved4,        /**< 21: Reserved4 button - for special usage */
+      Reserved5         /**< 22: Reserved5 button - for special usage */
+    };
+
+    /** This method requests the XTRA to display a specific screen.
+        @param pszScreenId - The name of the screen
+        @param lLanguageId - The current language for that screen
+        @param pszInstructionId - Identification of the instruction to be displayed
+        @param pszButtons - A list of button identifiers to be displayed
+        (items have to be separated with a ~)
+        @param pszStringValue - A list of alpha-numerical values to be displayed
+        (items have to be separated with a ~)
+        @param lTimeout - timeout to be used in milliseconds (usually 1 minute).
+    */
+
+    long showDisplay(char *pszScreenId,
+                     long  lLanguageId,
+                     char *pszInstructionId,
+                     char *pszButtons,
+                     char *pszStringValue,
+                     long lTimeout= 30000);
+
+    /** This method requests the XTRA to display a specific screen.
+        @param pszScreenId - The name of the screen
+        @param lLanguageId - The current language for that screen
+        @param pszStringValue - A list of alpha-numerical values to be displayed
+        (items have to be separated with a ~)
+    */
+
+    long showDisplay(char *pszScreenId, long lLanguageId, char *pszStringValue, long lTimeout= 30000);
+
+    /** This method requests the XTRA to display a specific screen.
+        @param pszScreenId - The name of the screen
+        @param pszStringValue - A list of alpha-numerical values to be displayed
+        (items have to be separated with a ~)
+    */
+
+    long showDisplay(char *pszScreenId, char *pszStringValue, long lTimeout= 30000);
+
+    /** This method requests the XTRA to display a specific screen.
+        @param pszScreenId - The name of the screen
+    */
+
+    long showDisplay(char *pszScreenId, long lTimeout= 30000);
+
+    /** This method requests the XTRA to display a specific screen.
+        @param screen - A map decribing all screen parameters
+    */
+
+//  20.09.2004 ts long showDisplay(aMap& screen, bool xml= false) parameter xml added
+
+    long showDisplay(const aMap& screen, bool xml= false, long lTimeout= 30000);
+
+    /** Class constructor.
+        Tries to connect the masai display XTRA on the remote machine. Use a corbaloc-identifier,
+        a CORBA-IOR identifier or an IP-Address to get the connection. If neither a corbaloc-
+        nor an IOR identifier is given the constructor builds a corbaloc-identifier from
+        the given object reference, so at least it has to be a valid IP address.
+
+        @param pszIOR - The object reference to XTRA
+        @param pAmi - Pointer to the application manger interface
+    */
+
+    displayXTRA(char *pszIOR, amInterface *pAmi = NULL);
+
+};
+
+/** Wrapper class for easier screen construction */
+
+class screen : public aMap
+{
+private:
+
+    long lError;
+    aObject CurrentListId;
+
+public:
+
+    enum Encoding
+    {
+      ENCODING_NO,
+      ENCODING_GB2312
+    };
+
+    /** Returns the current error, 0 if none */
+
+    long error();
+
+    /** Returns the current screen identifier, NULL if not set */
+
+    const char *id();
+
+    /** Sets or resets the current screen identifier
+        @param pszId - The screen identifier
+    */
+
+    screen& screenId(char *pszId);
+
+    /** Returns the current screen encoding */
+
+    Encoding encoding();
+
+    /** Sets or resets the current screen identifier
+        @param enc - Encoding use for screen
+    */
+
+    screen& screenEncoding(Encoding enc);
+
+    /** Creates a new member for this screen.
+        @param pszName - The name of the member
+    */
+
+    screen& member(char *pszName);
+
+    /** Creates a new member for this screen.
+        @param pszName - The name of the member
+        @param pszFile - The name of the RTF file to use for this member
+    */
+
+    screen& member(char *pszName, char *pszFile);
+
+    /** Creates a new member for this screen.
+        This call uses the standard template file build from "pszName.rtf"
+        @param pszName - The name of the member
+        @param data - A map specifying the data to be used for the template file
+    */
+
+    screen& member(char *pszName, aMap& data);
+
+    /** Creates a new member for this screen.
+        @param pszName - The name of the member
+        @param pszFile - The name of the RTF template file to use for this member
+        @param data - A map specifying the data to be used for the template file
+    */
+
+    screen& member(char *pszName, char *pszFile, aMap& data);
+
+    /** Creates a new list for this screen.
+        @param pszName - The name of the list
+    */
+
+    screen& list(char *pszName);
+
+    /** Creates a new list for this screen.
+        @param pszName - The name of the list
+        @param pszFile - The name of the RTF file to use for this member
+    */
+
+    screen& list(char *pszName, char* pszFile);
+
+    /** Creates a new list item for previously created list.
+        @param lIndex - The index of the list member (index counting starts with 1)
+        @param pszFile - The name of the RTF file to use for this member
+    */
+
+    screen& list(long lIndex, char *pszFile);
+
+    /** Creates a new list item for previously created list.
+        @param lIndex - The index of the list member (index counting starts with 1)
+        @param data - A map specifying the data to be used for the template file
+    */
+
+    screen& list(long lIndex, aMap& data);
+
+    /** Creates a new list item for previously created list.
+        @param lIndex - The index of the list member (index counting starts with 1)
+        @param pszFile - The name of the RTF template file to use for this list item
+        @param data - A map specifying the data to be used for the template file
+    */
+
+    screen& list(long lIndex, char *pszFile, aMap& data);
+
+    /** Set an entry in the list of data
+        @param lIndex - The index of the data member (index counting starts with 1)
+        @param pszData - The data value
+    */
+
+    screen& data(long lIndex, char *pszData);
+
+    /** Add an entry to the list of data
+        @param pszData - The data value
+    */
+
+    screen& data(char *pszData);
+
+    /** Set an entry in the list of data
+        @param lIndex - The index of the data member (index counting starts with 1)
+        @param lData - The data value
+    */
+
+    screen& data(long lIndex, long lData);
+
+    /** Add an entry to the list of data
+        @param lData - The data value
+    */
+
+    screen& data(long lData);
+
+    /** Overwrite the list of data
+        @param data - The list of data values
+    */
+
+    screen& data(aMap data);
+
+    /** Class constructor.
+        @param pszId - The screen identifier
+        @param enc - Encoding use for screen
+    */
+
+    screen(char *pszId = "null", Encoding enc= ENCODING_NO);
+
+    /** Class constructor.
+        @param enc - Encoding use for screen
+    */
+
+    screen(Encoding enc);
+};
+
+}; // namespace MASSAI
+
+#endif // DISPDEV_H
diff --git a/SelfServiceCommon/Interfaces/inc/CussIF/escrowdev.h b/SelfServiceCommon/Interfaces/inc/CussIF/escrowdev.h
new file mode 100644
index 00000000..7158e398
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/CussIF/escrowdev.h
@@ -0,0 +1,203 @@
+//---------------------------------------------------------------------------
+//
+//  file:       escrowdev.h
+//
+//  purpose:    Escrow device definition
+//
+//  date:       25.04.2002
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+/** Header file for ESCROW device implementation
+
+ @file      escrowdev.h
+ @date      25.04.2002
+ @version   1.0
+ @author    AGe - (C) Materna Information & Communications
+
+*/
+
+#ifndef ESCROWDEV_H
+#define ESCROWDEV_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#ifndef CUSSIF_H
+
+#include <iostream>
+#include <signal.h>
+
+#include "orbincdefs.h"
+
+#include "comps.h"
+#include "types.h"
+#include "codes.h"
+
+#include "orbs.h"
+
+#endif // CUSSIF_H
+
+#include "vcomp.h"
+#include "manufacturer.h"
+#include "callbackthread.h"
+#include "cussif/cussif_component.h"
+
+using namespace CORBA;
+//using namespace std;
+using namespace types;
+using namespace Components;
+
+namespace MASSAI
+{
+class amInterface;
+
+/** Implementation of an Escrow device.
+    This class hides all the handling for the virtual components that make up
+    an Escrow device.
+*/
+
+class escrowDevice : public vManufacturer,
+                     public vCompDispenser,
+                     public vCompCapture,
+                     private CallbackThread
+{
+private:
+
+    massai::cussif::Dispenser vcDispenser;
+    massai::cussif::Capture   vcCapture;
+
+    bool          fIsEmpty;
+
+    void        captureCallback      (const Event& ev, int id);
+    void        dispenserCallback    (const Event& ev, int id);
+
+    void        callback(CallbackComponent component, const types::Event& ev, int id);
+    void        process_captureCallback      (const Event& ev, int id);
+    void        process_dispenserCallback    (const Event& ev, int id);
+
+    void        init();
+
+public:
+
+    long error();
+
+    /** Returns bin size of the dispenser */
+
+    long dispenserBinSize();
+
+    /** Query the component status..
+        @param ct - the virtual component type to be queried
+        @return values as specified in the CUSS statuscodes namespace
+    */
+
+    long status (comptype ct = vCompDispenser::dispenser, Event_out ev= Event_var());
+    long status (long lTimeout, comptype ct = vCompDispenser::dispenser, Event_out ev= Event_var());
+
+    /** Opens the Escrow device and presents the coupon(s) to the user
+        @param  lTimeOut - Timeout value in milliseconds
+        @return statuscode as specified in the CUSSS statuscodes namespace
+     */
+
+    long open (long lTimeOut = 30000, Event_out ev= Event_var());
+
+    /** Closes the shutter and retains the coupon(s)
+        @param  lTimeOut - Timeout value in milliseconds
+        @return statuscode as specified in the CUSSS statuscodes namespace
+     */
+
+    long close (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Cancel all pending commands.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long cancel (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Retracts the coupon(s) in the device
+        @param  lTimeOut - Timeout value in milliseconds
+        @return statuscode as specified in the CUSSS statuscodes namespace
+     */
+
+    long retract (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Check if the Escrow device is empty
+        @return TRUE if there's no coupon in the device, FALSE otherwise
+    */
+
+    bool isEmpty ();
+
+    /** Event handler which is called when coupons(s) have been removed from the device.
+        Overwrite this handler to be notified with this event.
+    */
+
+    virtual void couponsRemoved ();
+
+    /** Event handler which is called when coupons(s) have been retracted.
+        Overwrite this handler to be notified with this event.
+    */
+
+    virtual void couponsRetracted();
+
+    /** This handler is called when the last issued command has timed out.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void commandTimeout ();
+
+    /** This handler is called when the last issued command has been cancelled.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void commandCancelled ();
+
+    /** This handler is called whenever a status code is returned for which no separate handler is available.
+        Use this handler to examine all unusual status codes (errors).
+        Overwrite this function to implement your own handler in your derived class.
+        @param eventCode - eventcode as specified in the CUSS eventcodes namespace
+        @param statusCode - statuscode as specified in the CUSSS statuscodes namespace
+        @param pszFunction - function that caused the event (null for unsolicited events)
+    */
+
+    virtual void handleException(long eventCode, long statusCode, const char *pszFunction);
+
+    /** This handler is called for every event that is recieved from the CUSS platfrom.
+        The eventReceived-handler is called before any other, so make sure that you
+        return FALSE for all events you want to handle in one of the handlers
+        descibed above.
+        @param eventCode - eventcode as specified in the CUSS eventcodes namespace
+        @param statusCode - statuscode as specified in the CUSSS statuscodes namespace
+        @param pszFunction - function that caused the event (null for unsolicited events)
+    */
+
+    virtual bool eventReceived (const Event& ev);
+    virtual bool eventReceived (long eventCode, long statusCode, const char *pszFunction);
+
+    /** Class constructor. All devices are aquired implicitly.
+        @param pAmi - Pointer to the application manger interface
+        @param pStream - Stream for debug output
+    */
+
+    escrowDevice(amInterface *pAmi);
+
+    /** Class constructor. All devices are aquired implicitly.
+        @param pAmi - Pointer to the application manger interface
+        @param pStream - Stream for debug output
+        @param component - find escrow for this component
+    */
+
+    escrowDevice(amInterface *pAmi, vManufacturer& component);
+    escrowDevice(amInterface *pAmi, vManufacturer& component, MASSAI::vComponent::comptype comp);
+
+    /** Class destructor. All virtual devices are released implicitly. */
+
+    ~escrowDevice();
+};
+
+}; // namespace MASSAI
+
+#endif // ESCROWDEV_H
diff --git a/SelfServiceCommon/Interfaces/inc/CussIF/fprdev.h b/SelfServiceCommon/Interfaces/inc/CussIF/fprdev.h
new file mode 100644
index 00000000..98b2cca5
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/CussIF/fprdev.h
@@ -0,0 +1,160 @@
+/**
+ *  @file      fprdev.h
+ *
+ *  @brief     Fingerprint reader device definition
+ *
+ *  @author    Materna Information & Communications
+ *
+ ************************************************************************/
+
+#ifndef FPRDEV_H
+#define FPRDEV_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#ifndef CUSSIF_H
+
+#include <signal.h>
+
+#include "orbincdefs.h"
+
+#include "comps.h"
+#include "types.h"
+#include "codes.h"
+
+#include "orbs.h"
+
+#endif // CUSSIF_H
+
+#include "vcomp.h"
+#include "manufacturer.h"
+#include <string>
+#include "cussif/cussif_component.h"
+
+using namespace CORBA;
+using namespace types;
+using namespace Components;
+
+namespace MASSAI
+{
+
+class amInterface;
+
+/** Interface implementation to a CUSS fingerprint reader device.
+    This class hides all the handling for the virtual components that make up
+    a fingerprint reader device.
+*/
+
+class fprDevice : public vManufacturer, public vCompReader
+{
+  private:
+    massai::cussif::UserInput  vcReader;
+
+    std::string image;
+
+    void  readerCallback (const Event& ev, int id);
+    void  clearData      ();
+    void  saveData       (const types::datastream ds);
+
+  public:
+    /** Query the component status..
+        @param ct - the virtual component type to be queried
+        @return values as specified in the CUSS statuscodes namespace
+    */
+
+    long status (comptype ct = vCompReader::reader, Event_out ev= Event_var());
+    long status (long lTimeout, comptype ct = vCompReader::reader, Event_out ev= Event_var());
+
+    /** enables the fingerprint reader
+        @param lTimeOut - timeout to be used in milliseconds
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long open (long lTimeOut = 30000, Event_out ev= Event_var());
+
+    /** disables the fingerprint reader for card insertion.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long close (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** read the images of the scanned fingerprint
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long read (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Cancel pending command.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long cancel (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Get image data
+        Use read(...) to read the image.
+        @return image data
+    */
+
+    std::string getImage();
+
+
+    /** This handler is called when data from the scanned fingerprint is available.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void dataPresent ();
+
+
+    /** This handler is called when the last issued command has timed out.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void commandTimeout ();
+
+    /** This handler is called when the last issued command has been cancelled.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void commandCancelled ();
+
+    /** This handler is called whenever a status code is returned for which no separate handler is available.
+        Use this handler to examine all unusual status codes (errors).
+        Overwrite this function to implement your own handler in your derived class.
+        @param eventCode - eventcode as specified in the CUSS eventcodes namespace
+        @param statusCode - statuscode as specified in the CUSSS statuscodes namespace
+        @param pszFunction - function that caused the event (null for unsolicited events)
+    */
+
+    virtual void handleException(long eventCode, long statusCode, const char *pszFunction);
+
+    /** This handler is called for every event that is recieved from the CUSS platfrom.
+        The eventReceived-handler is called before any other, so make sure that you
+        return FALSE for all events you want to handle in one of the handlers
+        descibed above.
+        @param eventCode - eventcode as specified in the CUSS eventcodes namespace
+        @param statusCode - statuscode as specified in the CUSSS statuscodes namespace
+        @param pszFunction - function that caused the event (null for unsolicited events)
+    */
+
+    virtual bool eventReceived (const Event& ev);
+    virtual bool eventReceived (long eventCode, long statusCode, const char *pszFunction);
+
+    /** Class constructor. All devices are aquired implicitly.
+        @param pAmi - Pointer to the application manger interface
+    */
+
+    fprDevice(amInterface *pAmi);
+
+    /** Class destructor. All aquired devices are released implicitly. */
+
+    ~fprDevice();
+};
+
+}; // namespace MASSAI
+
+#endif // FPRDEV_H
diff --git a/SelfServiceCommon/Interfaces/inc/CussIF/gppdevice.h b/SelfServiceCommon/Interfaces/inc/CussIF/gppdevice.h
new file mode 100644
index 00000000..a788035a
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/CussIF/gppdevice.h
@@ -0,0 +1,226 @@
+//---------------------------------------------------------------------------
+//
+//  file:       gppdevice.h
+//
+//  purpose:    Genereal purpuse printer device definition
+//
+//  date:       15.09.03
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+/** Header file for gp printer implementation
+
+ @file      gppdevice.h
+ @date      04.09.2003
+ @version   1.0
+ @author    PtM - (C) Materna Information & Communications
+
+*/
+
+#ifndef __GPPDEVICE_H
+#define __GPPDEVICE_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#ifndef CUSSIF_H
+#include <iostream>
+#include <signal.h>
+#include "orbincdefs.h"
+#include "comps.h"
+#include "types.h"
+#include "codes.h"
+#include "orbs.h"
+#endif // CUSSIF_H
+
+#include "vcomp.h"
+#include "manufacturer.h"
+#include "callbackthread.h"
+#include "asso.h"
+#include <string>
+#include "cussif/cussif_component.h"
+
+using namespace CORBA;
+using namespace types;
+using namespace Components;
+
+namespace MASSAI
+{
+class amInterface;
+
+/** Interface implementation for the gp printer device.
+    This class hides all the handling for the virtual components that make up
+    an gp printer device.
+*/
+
+class gppDevice : public vManufacturer,
+                  public vCompWriter,
+                  private CallbackThread
+{
+private:
+
+    massai::cussif::MediaOutput vcWriter;
+    // not used!
+    /* massai::cussif::Feeder      vcBin1; */
+
+
+    char abData[8192];
+
+    void clearData        ();
+    void saveData         (const types::datastream ds);
+
+    void        readerCallback       (const Event& ev, int id);
+    void        writerCallback       (const Event& ev, int id);
+    void        dispenserCallback    (const Event& ev, int id);
+
+    void        callback(CallbackComponent component, const types::Event& ev, int id);
+    void        process_readerCallback       (const Event& ev, int id);
+    void        process_writerCallback       (const Event& ev, int id);
+    void        process_dispenserCallback    (const Event& ev, int id);
+
+    char *checkGPPResponse(char *pszData,long *plStatusCode);
+
+public:
+    long error();
+
+    /** Query the component status..
+        @param ct - the virtual component type to be queried
+        @return values as specified in the CUSS statuscodes namespace
+    */
+
+    long status (comptype ct = vCompWriter::writer, Event_out ev= Event_var());
+    long status (long lTimeout, comptype ct = vCompWriter::writer, Event_out ev= Event_var());
+
+    /** Write SVG data.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call).
+        @param pszData - pointer to the data to be printed. If the pointer is not valid (NULL)
+                         the data in the buffer is printed.
+        @param lLen - specifies the length of the data. Data can be binary, so that string functions
+                      are not very useful.
+        @return values as specified in the CUSS returncodes namespace.
+    */
+
+    long write (long lTimeOut = BLOCK_,char *pszData = NULL, long lLen = 0, Event_out ev= Event_var());
+
+    /** Cancel all pending commands.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long cancel (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+
+    /** Get the data in the read/write buffer.
+        @return pointer to the buffer.
+    */
+
+    char *getData ();
+
+
+    /** This handler is called when printing SVG data has been completed.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void dataPrinted ();
+
+
+    /** This handler is called when the last issued command has timed out.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void commandTimeout ();
+
+
+    /** This handler is called when the last issued command has been cancelled.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void commandCancelled ();
+
+
+    /** This handler is called whenever a status code is returned for which no separate handler is available.
+        Use this handler to examine all unusual status codes (errors).
+        Overwrite this function to implement your own handler in your derived class.
+        @param eventCode - eventcode as specified in the CUSS eventcodes namespace
+        @param statusCode - statuscode as specified in the CUSSS statuscodes namespace
+        @param pszFunction - function that caused the event (null for unsolicited events)
+    */
+
+    virtual void handleException(long eventCode, long statusCode, const char *pszFunction);
+
+
+    /** This handler is called for every event that is recieved from the CUSS platfrom.
+        The eventReceived-handler is called before any other, so make sure that you
+        return FALSE for all events you want to handle in one of the handlers
+        descibed above.
+        @param eventCode - eventcode as specified in the CUSS eventcodes namespace
+        @param statusCode - statuscode as specified in the CUSSS statuscodes namespace
+        @param pszFunction - function that caused the event (null for unsolicited events)
+    */
+
+    virtual bool eventReceived (const Event& ev);
+    virtual bool eventReceived (long eventCode, long statusCode, const char *pszFunction);
+
+
+    /** Class constructor. All required virtual devices are aquired implicitly.
+        @param pAmi - Pointer to the application manger interface
+    */
+
+    gppDevice(amInterface *pAmi);
+
+    /** Class destructor. All virtual devices are released implicitly. */
+
+    ~gppDevice();
+};
+
+/** Wrapper class for easier SVG construction */
+
+class svg
+{
+private:
+
+    long    lError;
+    long    lLangId;
+    aMap    memberMap;
+    std::string  fileName;
+    std::string  buffer;
+    std::string  langPath;
+
+
+public:
+
+    /** Returns the current error, 0 if none */
+
+    long error();
+
+    /** Returns the final SVG data stream, NULL on error */
+
+    const char *getData();
+
+    /** Substitutes a member in the SVG file.
+        @param pszName - The name of the variable
+        @param pszText - The text for the specified variable
+    */
+
+    svg& member(const char *pszName, const char *pszText);
+
+    /** Substitutes one or more members in the SVG file as specified in the map.
+        @param data - A map specifying the data to be used for the template file
+    */
+
+    svg& member(const aMap& data);
+
+    /** Class constructor.
+        @param pszFile - The name of the SVG template file to use for this member
+        @param languageId - The language identifier
+    */
+
+    svg(const char *pszFile, long languageId = 1, const char* pszLangPath = "");
+};
+
+}; // namespace MASSAI
+
+#endif // __GPPDEVICE_H
diff --git a/SelfServiceCommon/Interfaces/inc/CussIF/language.h b/SelfServiceCommon/Interfaces/inc/CussIF/language.h
new file mode 100644
index 00000000..f7210e8d
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/CussIF/language.h
@@ -0,0 +1,81 @@
+//---------------------------------------------------------------------------
+//
+//  file:       language.h
+//
+//  purpose:    Langauage class defintion
+//
+//  date:       02.04.2001, 11:54
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//  history:
+//  30.07.2001 ts char *resourceFile(char* pszPath); added
+//---------------------------------------------------------------------------
+
+#ifndef LANGUAGE_H
+#define LANGUAGE_H
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+
+#include "massai.hpp"
+
+
+/** Language support class for CUSS interface*/
+
+class language
+{
+private:
+
+    long lCurrent;
+    char szCurrent [512];
+    HMODULE hModule;
+
+public:
+
+    /** Loads a new language DLL. The name of the DLL to be loaded is "path/langXXXX.dll", where XXXX is the language id that is passed to this method.
+        @param lLanguage - The language id to be used
+        @param pszPath - Path to be used for language files
+        @return Zero on success, operating system error code otherwise
+    */
+
+    long loadLanguage(long lLanguage,char *pszPath = "");
+
+//  30.07.2001 ts char *resourceFile(char* pszPath, char *pszFullPath) added
+//  returns a new allocated buffer, use delete[] to free it
+//  10.09.2001 ts return the full path in pszFullPath (must be allocated buffer)
+
+    /** Loads a new resource file
+        @param pszPath - ???
+        @param pszFullPath - ???
+        @return ???
+    */
+
+    char *resourceFile(const char* pszPath, char *pszFullPath);
+
+    /** Returns a resource string
+        @param id - identifies the string to be loaded
+        @return The string identified by the parameter, otherwise a textual error message
+    */
+
+    char *resourceText(long id);
+
+    /** Returns the currently set language identifier
+        @return The currently set language identifier
+    */
+
+    long  languageId ();
+
+    /** class constructor
+        @param lLanguage - The default language to be used
+        @param pszPath - Path to be used for language files
+    */
+
+    language(long lLanguage = 0,char *pszPath = "");
+
+    /** class destructor */
+
+   ~language();
+};
+
+#endif // LANGUAGE_H
\ No newline at end of file
diff --git a/SelfServiceCommon/Interfaces/inc/CussIF/manufacturer.h b/SelfServiceCommon/Interfaces/inc/CussIF/manufacturer.h
new file mode 100644
index 00000000..46c2c9d1
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/CussIF/manufacturer.h
@@ -0,0 +1,58 @@
+//---------------------------------------------------------------------------
+//
+//  file:       manufacturer.h
+//
+//  purpose:    manufacturer component definition
+//
+//  date:       31.07.2002
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+/** Header file for Manufacturer Component Definitions
+
+ @file      manufacturer.h
+ @date      31.07.2002
+ @version   1.0
+ @author    AGe - (C) Materna Information & Communications
+
+*/
+
+#ifndef MANUFACTURER_H
+#define MANUFACTURER_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include <iostream>
+#include <signal.h>
+
+#include "characteristics.h"
+
+namespace MASSAI
+{
+
+/** Base class implementation for characteristics queries. */
+
+class vManufacturer
+{
+protected:
+
+    std::string realComponent;
+
+public:
+
+    /** Returns the real name for this component */
+
+    const char* realComponentName();
+
+    /** check if two devices use the same hardware */
+
+    bool isSameDevice(vManufacturer& cmp);
+};
+
+}; // namespace MASSAI
+
+#endif // MANUFACTURER_H
\ No newline at end of file
diff --git a/SelfServiceCommon/Interfaces/inc/CussIF/mcdev.h b/SelfServiceCommon/Interfaces/inc/CussIF/mcdev.h
new file mode 100644
index 00000000..69f7168a
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/CussIF/mcdev.h
@@ -0,0 +1,362 @@
+//---------------------------------------------------------------------------
+//
+//  file:       mcdev.h
+//
+//  purpose:    Magnetic Card reader device definition
+//
+//  date:       25.04.2002
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+/** Header file for Magnetic Card Reader implementation
+
+ @file      mcdev.h
+ @date      25.04.2002
+ @version   1.0
+ @author    AGe - (C) Materna Information & Communications
+
+*/
+
+#ifndef MCDEV_H
+#define MCDEV_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#ifndef CUSSIF_H
+
+#include <signal.h>
+
+#include "orbincdefs.h"
+
+#include "comps.h"
+#include "types.h"
+#include "codes.h"
+
+#include "orbs.h"
+
+#endif // CUSSIF_H
+
+#include "vcomp.h"
+#include "manufacturer.h"
+#include "cussif/cussif_component.h"
+#include "callbackThread.h"
+
+#include <set>
+
+using namespace CORBA;
+using namespace types;
+using namespace Components;
+
+namespace MASSAI
+{
+
+class amInterface;
+
+/** Interface implementation to a CUSS magnetic card reader device.
+    This class hides all the handling for the virtual components that make up
+    a card reader device.
+*/
+
+class magCardDevice : public vManufacturer,
+                      public vCompReader,
+                      public vCompWriter,
+                      public vCompDispenser,
+                      public vCompCapture,
+                      private CallbackThread
+{
+private:
+
+    massai::cussif::MediaInput  vcReader;
+    massai::cussif::MediaOutput vcWriter;
+    massai::cussif::Dispenser   vcDispenser;
+    massai::cussif::Capture     vcCapture;
+
+    bool fHasCapture;
+    bool fHasWriter;
+    bool fHasDispenser;
+
+    char abTrack1[256];
+    char abTrack2[256];
+    char abTrack3[256];
+
+    void        readerCallback       (const Event& ev, int id);
+    void        writerCallback       (const Event& ev, int id);
+    void        captureCallback      (const Event& ev, int id);
+    void        dispenserCallback    (const Event& ev, int id);
+
+    void        callback(CallbackComponent component, const types::Event& ev, int id);
+    void        process_readerCallback       (const Event& ev, int id);
+    void        process_writerCallback       (const Event& ev, int id);
+    void        process_dispenserCallback    (const Event& ev, int id);
+    void        process_captureCallback      (const Event &ev, int id);
+
+
+    void        init                 (amInterface *pAmi, const char* pszRealComponent);
+
+    void        clearData            ();
+    void        saveData             (const types::datastream ds);
+
+public:
+
+    long error();
+
+    /** Definition of important reader types. */
+
+    enum readertype
+    {
+      RT_MOTORIZED,     /**< Motorized reader */
+      RT_SWIPE,         /**< Swipe reader */
+      RT_CONTACTLESS,   /**< Contactless reader */
+      RT_DIP,           /**< DIP-In reader */
+      RT_ERROR          /**< Unusable reader type, or not available */
+    };
+
+
+    /** Definition of Card Types */
+    enum cardtype
+    {
+      CT_MAGNETICSTRIPE,
+      CT_CHIP,
+      CT_JIS
+    };
+
+    /** Collection of Card Types */
+    typedef std::set<cardtype> cardselection;
+
+    /** Returns the type of the reader */
+
+    readertype readerType();
+
+    /** Query the component status..
+        @param ct - the virtual component type to be queried
+        @return values as specified in the CUSS statuscodes namespace
+    */
+
+    long status (comptype ct = vCompReader::reader, Event_out ev= Event_var());
+    long status (long lTimeout, comptype ct = vCompReader::reader, Event_out ev= Event_var());
+
+    /** Opens the card reader for card insertion.
+        @param lTimeOut - timeout to be used in milliseconds
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long open (long lTimeOut = 30000, Event_out ev= Event_var());
+
+    /** Closes the card reader for card insertion.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long close (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Read all tracks on the inserted card.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long read (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Write all the tracks for which data has been preset.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long write (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Returns card to the user.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long eject (long lTimeOut = 30000, Event_out ev= Event_var());
+
+    /** Retracts card into a secured bin.
+        @param lTimeOut - timeout to be used in milliseconds
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long retract (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Cancel all pending commands.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long cancel (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Preset data for card track 1.
+        Use write(...) to write data to the card.
+        @param pszTrack - pointer to track data
+    */
+
+    void setTrack1 (char *pszTrack = NULL);
+
+    /** Preset data for card track 2.
+        Use write(...) to write data to the card.
+        @param pszTrack - pointer to track data
+    */
+
+    void setTrack2 (char *pszTrack = NULL);
+
+    /** Preset data for card track 3.
+        Use write(...) to write data to the card.
+        @param pszTrack - pointer to track data
+    */
+
+    void setTrack3 (char *pszTrack = NULL);
+
+    /** Set data for all tracks.
+        Use write(...) to write data to the card.
+        @param pszTrack1 - pointer to data for track 1
+        @param pszTrack2 - pointer to data for track 2
+        @param pszTrack3 - pointer to data for track 3
+    */
+
+    void setTracks (char *pszTrack1,char *pszTrack2,char *pszTrack3);
+
+    /** Clear data for all track buffers */
+
+    void clearTracks ();
+
+    /** Get data from track 1.
+        Use read(...) to read all tracks from the card.
+        @return pointer to data or NULL if track is empty
+    */
+
+    char *getTrack1 ();
+
+    /** Get data from track 2.
+        Use read(...) to read all tracks from the card.
+        @return pointer to data or NULL if track is empty
+    */
+
+    char *getTrack2 ();
+
+    /** Get data from track 3.
+        Use read(...) to read all tracks from the card.
+        @return pointer to data or NULL if track is empty
+    */
+
+    char *getTrack3 ();
+
+    /** Checks if the device has a capture bin.
+        @return TRUE if functionality is available, FALSE otherwise.
+    */
+
+    bool hasCapture() { return(fHasCapture); }
+
+    /** Checks if the device has a dispenser.
+        @return TRUE if functionality is available, FALSE otherwise.
+    */
+
+    bool hasDispenser() { return(fHasDispenser); }
+
+    /** Checks if the device is able to write data onto magnetic cards.
+        @return TRUE if functionality is available, FALSE otherwise.
+    */
+
+    bool hasWriter() { return(fHasWriter); }
+
+    /** Checks if the device supports a specified cardtype.
+        @return TRUE if functionality is available, FALSE otherwise.
+    */
+
+    bool hasMediaInputCardTypeSupport(cardtype card);
+
+    /** Checks if the device supports a specified cardtype.
+        @return TRUE if functionality is available, FALSE otherwise.
+    */
+
+    bool hasMediaOutputCardTypeSupport(cardtype card);
+
+
+    /** This handler is called when a card is inserted into the reader.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void cardInserted ();
+
+    /** This handler is called when data from the card is available.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void dataPresent ();
+
+    /** This handler is called when a card is presented to the user.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void cardEjected ();
+
+    /** This handler is called when a card has been taken by the user.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void cardRemoved ();
+
+    /** This handler is called when a card has been retracted into the secured bin.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void cardRetracted ();
+
+    /** This handler is called when the last issued command has timed out.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void commandTimeout ();
+
+    /** This handler is called when the last issued command has been cancelled.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void commandCancelled ();
+
+    /** This handler is called whenever a status code is returned for which no separate handler is available.
+        Use this handler to examine all unusual status codes (errors).
+        Overwrite this function to implement your own handler in your derived class.
+        @param eventCode - eventcode as specified in the CUSS eventcodes namespace
+        @param statusCode - statuscode as specified in the CUSSS statuscodes namespace
+        @param pszFunction - function that caused the event (null for unsolicited events)
+    */
+
+    virtual void handleException(long eventCode, long statusCode, const char *pszFunction);
+
+    /** This handler is called for every event that is recieved from the CUSS platfrom.
+        The eventReceived-handler is called before any other, so make sure that you
+        return FALSE for all events you want to handle in one of the handlers
+        descibed above.
+        @param eventCode - eventcode as specified in the CUSS eventcodes namespace
+        @param statusCode - statuscode as specified in the CUSSS statuscodes namespace
+        @param pszFunction - function that caused the event (null for unsolicited events)
+    */
+
+    virtual bool eventReceived (const Event& ev);
+    virtual bool eventReceived (long eventCode, long statusCode, const char *pszFunction);
+
+    /** Class constructor. All devices are aquired implicitly.
+        @param pAmi - Pointer to the application manger interface
+    */
+
+    magCardDevice(amInterface *pAmi);
+
+    /** Class constructor. All required virtual devices are aquired implicitly.
+        use method hasMediaInputCardTypeSupport to check if a device has been acquired
+        @param pAmi - Pointer to the application manger interface
+        @param cardselection - needed card type support for mediainput
+    */
+
+    magCardDevice(amInterface *pAmi, const cardselection& select);
+
+    /** Class destructor. All aquired devices are released implicitly. */
+
+    ~magCardDevice();
+};
+
+}; // namespace MASSAI
+
+#endif // MCDEV_H
diff --git a/SelfServiceCommon/Interfaces/inc/CussIF/pdf417.h b/SelfServiceCommon/Interfaces/inc/CussIF/pdf417.h
new file mode 100644
index 00000000..c906ebd9
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/CussIF/pdf417.h
@@ -0,0 +1,33 @@
+/**
+ *  @file      pdf417.h
+ *
+ *  @brief     Definitions for PDF417 barcode usage
+ *
+ *  @date      01.07.2004
+ *
+ *  @author    Materna Information & Communications (AGe)
+ *
+ ************************************************************************/
+
+#ifndef PDF417_H
+#define PFD417_H
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+
+class pdf417
+{
+private:
+
+    char szInBuf [2048];
+
+public:
+
+    char *svg();
+    long  convert(char *pszInput = "");
+
+    pdf417(char *pszInput = NULL);
+   ~pdf417();
+};
+
+#endif // PDF417_H
\ No newline at end of file
diff --git a/SelfServiceCommon/Interfaces/inc/CussIF/polling.h b/SelfServiceCommon/Interfaces/inc/CussIF/polling.h
new file mode 100644
index 00000000..5523bbcb
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/CussIF/polling.h
@@ -0,0 +1,87 @@
+/**
+ *  @file      polling.h
+ *
+ *  @brief
+ *
+ *  @date      15.01.2009
+ *
+ *  @author    Materna Information & Communications
+ *
+ ************************************************************************/
+
+#ifndef POLLING_H
+#define POLLING_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+
+#include "corbapoll.h"
+#include "corbaclnt.h"
+
+namespace MASSAI
+{
+  class TerminationBase
+  {
+    public:
+      TerminationBase(){};
+      ~TerminationBase(){};
+      bool isTerminating() const { return false; };
+  };
+
+  template<class T> class corbaCallbackClientTerminator: public corbaCallbackClient<T>
+  {
+    public:
+      corbaCallbackClientTerminator(const TerminationBase* pTermination, const char *pszIOR_or_ServantName, long lCORBA_Invocation_Timeout = -1):
+        pApp(pTermination),
+        corbaCallbackClient<T>(pszIOR_or_ServantName, lCORBA_Invocation_Timeout)
+      {}
+      corbaCallbackClientTerminator(const TerminationBase* pTermination, const char *pszHost, const long  port, const char *pszServant, long lCORBA_Invocation_Timeout = -1):
+        pApp(pTermination),
+        corbaCallbackClient<T>(pszHost, port, pszServant, lCORBA_Invocation_Timeout)
+      {}
+      bool poll()
+      {
+        if(!pApp || !pApp->isTerminating())
+          return corbaCallbackClient<T>::poll();
+        else
+          return true;
+      }
+    private:
+      const TerminationBase* pApp;
+  };
+
+  template<class T> class corbaClientTerminator: public corbaClient<T>
+  {
+    public:
+      corbaClientTerminator(const TerminationBase* pTermination, const char *pszIOR_or_ServantName, long lCORBA_Invocation_Timeout = -1, AutoPolling autopoll= AUTO_POLL_NON_LOCAL):
+        pApp(pTermination),
+        corbaClient<T>(pszIOR_or_ServantName, lCORBA_Invocation_Timeout, autopoll)
+      {}
+      corbaClientTerminator(const TerminationBase* pTermination, const char *pszInitialService, const char *pszIOR, long lCORBA_Invocation_Timeout = -1, AutoPolling autopoll= AUTO_POLL_NON_LOCAL):
+        pApp(pTermination),
+        corbaClient<T>(pszInitialService, pszIOR, lCORBA_Invocation_Timeout, autopoll)
+      {}
+      corbaClientTerminator(const TerminationBase* pTermination, const char *pszHost, long port, const char* pszServant, long lCORBA_Invocation_Timeout = -1, AutoPolling autopoll= AUTO_POLL_NON_LOCAL):
+        pApp(pTermination),
+        corbaClient<T>(pszHost, port, pszServant, lCORBA_Invocation_Timeout, autopoll)
+      {}
+      corbaClientTerminator(const TerminationBase* pTermination, T* servant, long lCORBA_Invocation_Timeout = -1, AutoPolling autopoll= AUTO_POLL_NON_LOCAL):
+        pApp(pTermination),
+        corbaClient<T>(servant, lCORBA_Invocation_Timeout, autopoll)
+      {}
+      bool poll()
+      {
+        if(!pApp || !pApp->isTerminating())
+          return corbaClient<T>::poll();
+        else
+          return true;
+      }
+    private:
+      const TerminationBase* pApp;
+  };
+
+
+}
+#endif // POLLING_H
diff --git a/SelfServiceCommon/Interfaces/inc/CussIF/pprdev.h b/SelfServiceCommon/Interfaces/inc/CussIF/pprdev.h
new file mode 100644
index 00000000..904bebe7
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/CussIF/pprdev.h
@@ -0,0 +1,206 @@
+/**
+ *  @file      pprdev.h
+ *
+ *  @brief     Passport reader device definition
+ *
+ *  @date      26.03.2004
+ *
+ *  @author    Materna Information & Communications (PtM)
+ *
+ ************************************************************************/
+
+#ifndef PPRDEV_H
+#define PPRDEV_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#ifndef CUSSIF_H
+
+#include <signal.h>
+
+#include "orbincdefs.h"
+
+#include "comps.h"
+#include "types.h"
+#include "codes.h"
+
+#include "orbs.h"
+
+#endif // CUSSIF_H
+
+#include "vcomp.h"
+#include "manufacturer.h"
+#include "cussif/cussif_component.h"
+
+using namespace CORBA;
+using namespace types;
+using namespace Components;
+
+namespace MASSAI
+{
+
+class amInterface;
+
+/** Interface implementation to a CUSS passport reader device.
+    This class hides all the handling for the virtual components that make up
+    a passport reader device.
+*/
+
+class pprDevice : public vManufacturer, public vCompReader
+{
+private:
+
+    massai::cussif::MediaInput  vcReader;
+
+    char abTrack1[256];
+    char abTrack2[256];
+    char abTrack3[256];
+
+    void  readerCallback (const Event& ev, int id);
+    void  clearData      ();
+    void  saveData       (const types::datastream ds);
+
+public:
+
+    /** Definition of important reader types. */
+
+    enum readertype
+    {
+      RT_MOTORIZED,     /**< Motorized reader */
+      RT_SWIPE,         /**< Swipe reader */
+      RT_CONTACTLESS,   /**< Contactless reader */
+      RT_DIP,           /**< DIP-In reader */
+      RT_FLATBED,       /**< Flatbed scanner */
+      RT_PENSCAN,       /**< Pencil scanne */
+      RT_ERROR          /**< Unusable reader type, or not available */
+    };
+
+    /** Returns the type of the reader */
+
+    readertype readerType();
+
+    /** Query the component status..
+        @param ct - the virtual component type to be queried
+        @return values as specified in the CUSS statuscodes namespace
+    */
+
+    long status (comptype ct = vCompReader::reader, Event_out ev= Event_var());
+    long status (long lTimeout, comptype ct = vCompReader::reader, Event_out ev= Event_var());
+
+    /** Opens the passport reader for passport insertion.
+        @param lTimeOut - timeout to be used in milliseconds
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long open (long lTimeOut = 30000, Event_out ev= Event_var());
+
+    /** Closes the passport reader for card insertion.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long close (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Read all tracks on the inserted passport.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long read (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Cancel pending command.
+        @param lTimeOut - timeout to be used in milliseconds (usually blocking call)
+        @return values as specified in the CUSS returncodes namespace
+    */
+
+    long cancel (long lTimeOut = BLOCK_, Event_out ev= Event_var());
+
+    /** Get data from track 1.
+        Use read(...) to read all tracks from the passport.
+        @return pointer to data or NULL if track is empty
+    */
+
+    char *getTrack1 ();
+
+    /** Get data from track 2.
+        Use read(...) to read all tracks from the passport.
+        @return pointer to data or NULL if track is empty
+    */
+
+    char *getTrack2 ();
+
+    /** Get data from track 3.
+        Use read(...) to read all tracks from the passport.
+        @return pointer to data or NULL if track is empty
+    */
+
+    char *getTrack3 ();
+
+    /** This handler is called when a passport is inserted into the reader.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void passportInserted ();
+
+    /** This handler is called when data from the passport is available.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void dataPresent ();
+
+    /** This handler is called when a passport has been taken by the user.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void passportRemoved ();
+
+    /** This handler is called when the last issued command has timed out.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void commandTimeout ();
+
+    /** This handler is called when the last issued command has been cancelled.
+        Overwrite this function to implement your own handler in your derived class.
+    */
+
+    virtual void commandCancelled ();
+
+    /** This handler is called whenever a status code is returned for which no separate handler is available.
+        Use this handler to examine all unusual status codes (errors).
+        Overwrite this function to implement your own handler in your derived class.
+        @param eventCode - eventcode as specified in the CUSS eventcodes namespace
+        @param statusCode - statuscode as specified in the CUSSS statuscodes namespace
+        @param pszFunction - function that caused the event (null for unsolicited events)
+    */
+
+    virtual void handleException(long eventCode, long statusCode, const char *pszFunction);
+
+    /** This handler is called for every event that is recieved from the CUSS platfrom.
+        The eventReceived-handler is called before any other, so make sure that you
+        return FALSE for all events you want to handle in one of the handlers
+        descibed above.
+        @param eventCode - eventcode as specified in the CUSS eventcodes namespace
+        @param statusCode - statuscode as specified in the CUSSS statuscodes namespace
+        @param pszFunction - function that caused the event (null for unsolicited events)
+    */
+
+    virtual bool eventReceived (const Event& ev);
+    virtual bool eventReceived (long eventCode, long statusCode, const char *pszFunction);
+
+    /** Class constructor. All devices are aquired implicitly.
+        @param pAmi - Pointer to the application manger interface
+    */
+
+    pprDevice(amInterface *pAmi);
+
+    /** Class destructor. All aquired devices are released implicitly. */
+
+    ~pprDevice();
+};
+
+}; // namespace MASSAI
+
+#endif // PPRDEV_H
diff --git a/SelfServiceCommon/Interfaces/inc/CussIF/vcomp.h b/SelfServiceCommon/Interfaces/inc/CussIF/vcomp.h
new file mode 100644
index 00000000..345026f7
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/CussIF/vcomp.h
@@ -0,0 +1,375 @@
+//---------------------------------------------------------------------------
+//
+//  file:       vcomp.h
+//
+//  purpose:    Virtual component definition
+//
+//  date:       25.04.2002
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+/** Header file for Virtual Component Definitions
+
+ @file      vcomp.h
+ @date      25.04.2002
+ @version   1.0
+ @author    AGe - (C) Materna Information & Communications
+
+*/
+
+#ifndef VCOMP_H
+#define VCOMP_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "polling.h"
+
+#ifndef CUSSIF_H
+
+#include <signal.h>
+
+#include "corbaclnt.h"
+
+#include "comps.h"
+#include "types.h"
+#include "codes.h"
+
+#include "types_skel.h"
+
+#endif // CUSSIF_H
+
+#include <string>
+#include <map>
+
+using namespace CORBA;
+
+using namespace types;
+using namespace Components;
+
+namespace MASSAI
+{
+
+/** Implementation of CUSS virtual component.
+    This is the base class for all devices
+*/
+
+class amInterface;
+
+class vComponent
+{
+private:
+
+    class mEventListener;
+    typedef std::map<int, mEventListener*> mEventListenerMap;
+
+    Object_var     obj;
+
+    mEventListenerMap m_listener;
+
+    corbaCallbackClientTerminator<Component> *cclnt;
+
+    amInterface *pAmi;
+
+protected:
+
+    long lError;        /**< Current error value */
+    char sz3LCode[10];  /**< 3L Code received from platform */
+    char szID[1024];    /**< Kiosk identifier received from platform */
+    char szAppRef[256]; /**< The current valid application reference (token) */
+
+    /** Returns the CORBA object that executes the directives */
+
+    Object_var object() { return(obj); }
+
+public:
+
+    /** Definition virtual component types for status queries on hardware components. */
+
+    enum comptype
+    {
+      reader,     /**< reader component */
+      writer,     /**< writer component  */
+      capture,    /**< capture component */
+      dispenser,  /**< dispenser component  */
+      feeder      /**< feeder component  */
+    };
+
+    /** Force all derived classes to implement CUSS event listeners */
+
+    virtual void callback(const Event& ev, int id) = 0;
+
+    /** returns the current error value hold in lError */
+
+    long error ();
+    void error (long store);
+
+    /** Connects from given IOR and returns the CORBA object */
+
+    Object_var connect(const char *pszVCompIOR);
+
+    /** Returns the listener object */
+
+    types::evtListener *listener(int id= 0);
+
+    /** Returns the application reference */
+
+    const char* appRef();
+
+    /** Class constructor
+     */
+
+    vComponent(amInterface *pAmi);
+
+    /** Class destructor */
+
+    ~vComponent();
+
+
+    long setTimeout(long timeout);
+    void resetTimeout(long oldTimeout);
+
+};
+
+/** Implementation of CUSS virtual application component.
+    This is the base class for all CUSS applications.
+*/
+
+class vCompApp : public vComponent
+{
+private:
+
+    void callback(const Event& ev, int id)
+    {
+    };
+
+public:
+
+    /** Class constructor, initialize base class only
+     */
+
+    vCompApp(amInterface *pAmi) : vComponent(pAmi) {};
+};
+
+/** Implementation of CUSS virtual reader component.
+    This is the base class for all CUSS MediaInput devices.
+*/
+
+class vCompReader : public vComponent
+{
+private:
+
+    void callback(const Event& ev, int id)
+    {
+        readerCallback(ev, id);
+    };
+
+protected:
+
+    /** Force all derived classes to implement CUSS event listeners */
+
+    virtual void readerCallback(const Event& ev, int id) = 0;
+
+public:
+
+    /** Class constructor, initialize base class only
+     */
+
+    vCompReader(amInterface *pAmi) : vComponent(pAmi) {};
+};
+
+/** Implementation of CUSS virtual writer component.
+    This is the base class for all CUSS MediaOutput devices.
+*/
+
+class vCompWriter : public vComponent
+{
+private:
+
+    void callback(const Event& ev, int id)
+    {
+        writerCallback(ev, id);
+    };
+
+protected:
+
+    /** Force all derived classes to implement CUSS event listeners */
+
+    virtual void writerCallback(const Event& ev, int id) = 0;
+
+public:
+
+    /** Class constructor, initialize base class only
+     */
+
+    vCompWriter(amInterface *pAmi) : vComponent(pAmi) {};
+};
+
+/** Implementation of CUSS virtual dispenser.
+    This is the base class for all CUSS Dispenser devices
+ */
+
+class vCompDispenser : public vComponent
+{
+private:
+
+    void callback(const Event& ev, int id)
+    {
+        dispenserCallback(ev, id);
+    };
+
+protected:
+
+    /** Force all derived classes to implement CUSS event listeners */
+
+    virtual void dispenserCallback(const Event& ev, int id) = 0;
+
+public:
+
+    /** Class constructor, initialize base class only
+     */
+
+    vCompDispenser(amInterface *pAmi) : vComponent(pAmi) {};
+};
+
+/** Implementation of CUSS virtual capture component.
+    This is the base class for all CUSS Capture devices
+ */
+
+class vCompCapture : public vComponent
+{
+private:
+
+    void callback(const Event& ev, int id)
+    {
+        captureCallback(ev, id);
+    };
+
+protected:
+
+    /** Force all derived classes to implement CUSS event listeners */
+
+    virtual void captureCallback(const Event& ev, int id) = 0;
+
+public:
+
+    /** Class constructor, initialize base class only
+     */
+
+    vCompCapture(amInterface *pAmi) : vComponent(pAmi) {};
+};
+
+/** Implementation of CUSS virtual feeder component.
+    This is the base class for all CUSS Feeder devices
+ */
+
+class vCompFeeder : public vComponent
+{
+private:
+
+    void callback(const Event& ev, int id)
+    {
+        feederCallback(ev, id);
+    };
+
+protected:
+
+    /** Force all derived classes to implement CUSS event listeners */
+
+    virtual void feederCallback(const Event& ev, int id) = 0;
+
+public:
+
+    /** Class constructor, initialize base class only
+     */
+
+    vCompFeeder(amInterface *pAmi) : vComponent(pAmi) {};
+};
+
+/** Implementation of CUSS virtual display component.
+    This is the base class for all CUSS display devices
+ */
+
+class vCompDisplay : public vComponent
+{
+private:
+
+    void callback(const Event& ev, int id)
+    {
+        displayCallback(ev, id);
+    };
+
+protected:
+
+    /** Force all derived classes to implement CUSS event listeners */
+
+    virtual void displayCallback(const Event& ev, int id) = 0;
+
+public:
+
+    /** Class constructor, initialize base class only
+     */
+
+    vCompDisplay(amInterface *pAmi) : vComponent(pAmi) {};
+};
+
+/** Implementation of CUSS virtual conveyor component.
+    This is the base class for all CUSS conveyor devices
+ */
+class vCompConveyor : public vComponent
+{
+private:
+
+    void callback(const Event& ev, int id)
+    {
+        conveyorCallback(ev, id);
+    };
+
+protected:
+
+    /** Force all derived classes to implement CUSS event listeners */
+
+    virtual void conveyorCallback(const Event& ev, int id) = 0;
+
+public:
+
+    /** Class constructor, initialize base class only
+     */
+
+    vCompConveyor(amInterface *pAmi) : vComponent(pAmi) {};
+};
+
+/** Implementation of CUSS virtual baggage system component.
+    This is the base class for all CUSS baggage system devices
+ */
+
+class vCompBaggageSystem : public vComponent
+{
+private:
+
+    void callback(const Event& ev, int id)
+    {
+        baggageSystemCallback(ev, id);
+    };
+
+protected:
+
+    /** Force all derived classes to implement CUSS event listeners */
+
+    virtual void baggageSystemCallback(const Event& ev, int id) = 0;
+
+public:
+
+    /** Class constructor, initialize base class only
+     */
+
+    vCompBaggageSystem(amInterface *pAmi) : vComponent(pAmi) {};
+};
+
+
+}; // namespace MASSAI
+
+#endif // VCOMP_H
diff --git a/SelfServiceCommon/Interfaces/inc/atb2Scanner.h b/SelfServiceCommon/Interfaces/inc/atb2Scanner.h
new file mode 100644
index 00000000..7de6ea9e
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/atb2Scanner.h
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES) 
+#pragma message("including: " __FILE__) 
+#endif 
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER) 
+#error "atb2Scanner.h" is deprecated, use "CussIF/atb2Scanner.h" instead. 
+#else 
+// #pragma message ("Warning: \"atb2Scanner.h\" is deprecated, use \"CussIF/atb2Scanner.h\" instead.") 
+#include "CussIF/atb2Scanner.h" 
+#endif 
diff --git a/SelfServiceCommon/Interfaces/inc/atbreader.h b/SelfServiceCommon/Interfaces/inc/atbreader.h
new file mode 100644
index 00000000..ae38f66b
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/atbreader.h
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES) 
+#pragma message("including: " __FILE__) 
+#endif 
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER) 
+#error "atbreader.h" is deprecated, use "CussIF/atbreader.h" instead. 
+#else 
+// #pragma message ("Warning: \"atbreader.h\" is deprecated, use \"CussIF/atbreader.h\" instead.") 
+#include "CussIF/atbreader.h" 
+#endif 
diff --git a/SelfServiceCommon/Interfaces/inc/baggagedev.h b/SelfServiceCommon/Interfaces/inc/baggagedev.h
new file mode 100644
index 00000000..7d0adf9d
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/baggagedev.h
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES) 
+#pragma message("including: " __FILE__) 
+#endif 
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER) 
+#error "baggagedev.h" is deprecated, use "CussIF/baggagedev.h" instead. 
+#else 
+// #pragma message ("Warning: \"baggagedev.h\" is deprecated, use \"CussIF/baggagedev.h\" instead.") 
+#include "CussIF/baggagedev.h" 
+#endif 
diff --git a/SelfServiceCommon/Interfaces/inc/bcsdev.h b/SelfServiceCommon/Interfaces/inc/bcsdev.h
new file mode 100644
index 00000000..af6ab8f5
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/bcsdev.h
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES) 
+#pragma message("including: " __FILE__) 
+#endif 
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER) 
+#error "bcsdev.h" is deprecated, use "CussIF/bcsdev.h" instead. 
+#else 
+// #pragma message ("Warning: \"bcsdev.h\" is deprecated, use \"CussIF/bcsdev.h\" instead.") 
+#include "CussIF/bcsdev.h" 
+#endif 
diff --git a/SelfServiceCommon/Interfaces/inc/bppdev.h b/SelfServiceCommon/Interfaces/inc/bppdev.h
new file mode 100644
index 00000000..25564401
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/bppdev.h
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES) 
+#pragma message("including: " __FILE__) 
+#endif 
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER) 
+#error "bppdev.h" is deprecated, use "CussIF/bppdev.h" instead. 
+#else 
+// #pragma message ("Warning: \"bppdev.h\" is deprecated, use \"CussIF/bppdev.h\" instead.") 
+#include "CussIF/bppdev.h" 
+#endif 
diff --git a/SelfServiceCommon/Interfaces/inc/btpScanner.h b/SelfServiceCommon/Interfaces/inc/btpScanner.h
new file mode 100644
index 00000000..a403113a
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/btpScanner.h
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES) 
+#pragma message("including: " __FILE__) 
+#endif 
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER) 
+#error "btpScanner.h" is deprecated, use "CussIF/btpScanner.h" instead. 
+#else 
+// #pragma message ("Warning: \"btpScanner.h\" is deprecated, use \"CussIF/btpScanner.h\" instead.") 
+#include "CussIF/btpScanner.h" 
+#endif 
diff --git a/SelfServiceCommon/Interfaces/inc/btpdev.h b/SelfServiceCommon/Interfaces/inc/btpdev.h
new file mode 100644
index 00000000..6228593e
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/btpdev.h
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES) 
+#pragma message("including: " __FILE__) 
+#endif 
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER) 
+#error "btpdev.h" is deprecated, use "CussIF/btpdev.h" instead. 
+#else 
+// #pragma message ("Warning: \"btpdev.h\" is deprecated, use \"CussIF/btpdev.h\" instead.") 
+#include "CussIF/btpdev.h" 
+#endif 
diff --git a/SelfServiceCommon/Interfaces/inc/callbackthread.h b/SelfServiceCommon/Interfaces/inc/callbackthread.h
new file mode 100644
index 00000000..97b4f52a
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/callbackthread.h
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES) 
+#pragma message("including: " __FILE__) 
+#endif 
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER) 
+#error "callbackthread.h" is deprecated, use "CussIF/callbackthread.h" instead. 
+#else 
+// #pragma message ("Warning: \"callbackthread.h\" is deprecated, use \"CussIF/callbackthread.h\" instead.") 
+#include "CussIF/callbackthread.h" 
+#endif 
diff --git a/SelfServiceCommon/Interfaces/inc/clock.h b/SelfServiceCommon/Interfaces/inc/clock.h
new file mode 100644
index 00000000..7d825dcf
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/clock.h
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES) 
+#pragma message("including: " __FILE__) 
+#endif 
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER) 
+#error "clock.h" is deprecated, use "CussIF/clock.h" instead. 
+#else 
+// #pragma message ("Warning: \"clock.h\" is deprecated, use \"CussIF/clock.h\" instead.") 
+#include "CussIF/clock.h" 
+#endif 
diff --git a/SelfServiceCommon/Interfaces/inc/cussif.h b/SelfServiceCommon/Interfaces/inc/cussif.h
new file mode 100644
index 00000000..00318d8c
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/cussif.h
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES) 
+#pragma message("including: " __FILE__) 
+#endif 
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER) 
+#error "cussif.h" is deprecated, use "CussIF/cussif.h" instead. 
+#else 
+// #pragma message ("Warning: \"cussif.h\" is deprecated, use \"CussIF/cussif.h\" instead.") 
+#include "CussIF/cussif.h" 
+#endif 
diff --git a/SelfServiceCommon/Interfaces/inc/dispclnt.h b/SelfServiceCommon/Interfaces/inc/dispclnt.h
new file mode 100644
index 00000000..f46efb9c
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/dispclnt.h
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES) 
+#pragma message("including: " __FILE__) 
+#endif 
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER) 
+#error "dispclnt.h" is deprecated, use "CussIF/dispclnt.h" instead. 
+#else 
+// #pragma message ("Warning: \"dispclnt.h\" is deprecated, use \"CussIF/dispclnt.h\" instead.") 
+#include "CussIF/dispclnt.h" 
+#endif 
diff --git a/SelfServiceCommon/Interfaces/inc/dispdev.h b/SelfServiceCommon/Interfaces/inc/dispdev.h
new file mode 100644
index 00000000..f8506226
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/dispdev.h
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES) 
+#pragma message("including: " __FILE__) 
+#endif 
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER) 
+#error "dispdev.h" is deprecated, use "CussIF/dispdev.h" instead. 
+#else 
+// #pragma message ("Warning: \"dispdev.h\" is deprecated, use \"CussIF/dispdev.h\" instead.") 
+#include "CussIF/dispdev.h" 
+#endif 
diff --git a/SelfServiceCommon/Interfaces/inc/escrowdev.h b/SelfServiceCommon/Interfaces/inc/escrowdev.h
new file mode 100644
index 00000000..cb6c21f4
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/escrowdev.h
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES) 
+#pragma message("including: " __FILE__) 
+#endif 
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER) 
+#error "escrowdev.h" is deprecated, use "CussIF/escrowdev.h" instead. 
+#else 
+// #pragma message ("Warning: \"escrowdev.h\" is deprecated, use \"CussIF/escrowdev.h\" instead.") 
+#include "CussIF/escrowdev.h" 
+#endif 
diff --git a/SelfServiceCommon/Interfaces/inc/fprdev.h b/SelfServiceCommon/Interfaces/inc/fprdev.h
new file mode 100644
index 00000000..444f9ce0
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/fprdev.h
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER)
+#error "fprdev.h" is deprecated, use "CussIF/fprdev.h" instead.
+#else
+// #pragma message ("Warning: \"fprdev.h\" is deprecated, use \"CussIF/fprdev.h\" instead.")
+#include "CussIF/fprdev.h"
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/gppdevice.h b/SelfServiceCommon/Interfaces/inc/gppdevice.h
new file mode 100644
index 00000000..e4d2d16c
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/gppdevice.h
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES) 
+#pragma message("including: " __FILE__) 
+#endif 
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER) 
+#error "gppdevice.h" is deprecated, use "CussIF/gppdevice.h" instead. 
+#else 
+// #pragma message ("Warning: \"gppdevice.h\" is deprecated, use \"CussIF/gppdevice.h\" instead.") 
+#include "CussIF/gppdevice.h" 
+#endif 
diff --git a/SelfServiceCommon/Interfaces/inc/initIDL/initgmrdev.h b/SelfServiceCommon/Interfaces/inc/initIDL/initgmrdev.h
new file mode 100644
index 00000000..23d5eed0
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/initIDL/initgmrdev.h
@@ -0,0 +1,24 @@
+#ifndef INCLUDE_INITGMRDEV_H
+#define INCLUDE_INITGMRDEV_H
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "gmrdev.h"
+
+namespace gmrdev
+{
+  void init_multiCompCmdData(multiCompCmdData& init, const multidevices::compType& comp);
+  multiCompCmdData init_multiCompCmdData(const multidevices::compType& comp);
+
+  void init_dataTrack(dataTrack& init);
+  dataTrack init_dataTrack();
+
+  void init_readerDataType(readerDataType& init, const multidevices::compType& comp);
+  readerDataType init_readerDataType(const multidevices::compType& comp);
+
+  void init_compStatus(compStatus& init, const multidevices::compType& comp);
+  compStatus init_compStatus(multidevices::compType comp);
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/initgmrdev.h b/SelfServiceCommon/Interfaces/inc/initgmrdev.h
new file mode 100644
index 00000000..13f01a1a
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/initgmrdev.h
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER)
+#error "initgmrdev.h" is deprecated, use "initIDL/initgmrdev.h" instead.
+#else
+// #pragma message ("Warning: \"initgmrdev.h\" is deprecated, use \"initIDL/initgmrdev.h\" instead.")
+#include "initIDL/initgmrdev.h"
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/language.h b/SelfServiceCommon/Interfaces/inc/language.h
new file mode 100644
index 00000000..e19ccee6
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/language.h
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES) 
+#pragma message("including: " __FILE__) 
+#endif 
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER) 
+#error "language.h" is deprecated, use "CussIF/language.h" instead. 
+#else 
+// #pragma message ("Warning: \"language.h\" is deprecated, use \"CussIF/language.h\" instead.") 
+#include "CussIF/language.h" 
+#endif 
diff --git a/SelfServiceCommon/Interfaces/inc/manufacturer.h b/SelfServiceCommon/Interfaces/inc/manufacturer.h
new file mode 100644
index 00000000..d7e790f2
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/manufacturer.h
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES) 
+#pragma message("including: " __FILE__) 
+#endif 
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER) 
+#error "manufacturer.h" is deprecated, use "CussIF/manufacturer.h" instead. 
+#else 
+// #pragma message ("Warning: \"manufacturer.h\" is deprecated, use \"CussIF/manufacturer.h\" instead.") 
+#include "CussIF/manufacturer.h" 
+#endif 
diff --git a/SelfServiceCommon/Interfaces/inc/mcdev.h b/SelfServiceCommon/Interfaces/inc/mcdev.h
new file mode 100644
index 00000000..7a82d02d
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/mcdev.h
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES) 
+#pragma message("including: " __FILE__) 
+#endif 
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER) 
+#error "mcdev.h" is deprecated, use "CussIF/mcdev.h" instead. 
+#else 
+// #pragma message ("Warning: \"mcdev.h\" is deprecated, use \"CussIF/mcdev.h\" instead.") 
+#include "CussIF/mcdev.h" 
+#endif 
diff --git a/SelfServiceCommon/Interfaces/inc/pdf417.h b/SelfServiceCommon/Interfaces/inc/pdf417.h
new file mode 100644
index 00000000..d17ce505
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/pdf417.h
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES) 
+#pragma message("including: " __FILE__) 
+#endif 
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER) 
+#error "pdf417.h" is deprecated, use "CussIF/pdf417.h" instead. 
+#else 
+// #pragma message ("Warning: \"pdf417.h\" is deprecated, use \"CussIF/pdf417.h\" instead.") 
+#include "CussIF/pdf417.h" 
+#endif 
diff --git a/SelfServiceCommon/Interfaces/inc/polling.h b/SelfServiceCommon/Interfaces/inc/polling.h
new file mode 100644
index 00000000..167483f1
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/polling.h
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES) 
+#pragma message("including: " __FILE__) 
+#endif 
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER) 
+#error "polling.h" is deprecated, use "CussIF/polling.h" instead. 
+#else 
+// #pragma message ("Warning: \"polling.h\" is deprecated, use \"CussIF/polling.h\" instead.") 
+#include "CussIF/polling.h" 
+#endif 
diff --git a/SelfServiceCommon/Interfaces/inc/pprdev.h b/SelfServiceCommon/Interfaces/inc/pprdev.h
new file mode 100644
index 00000000..e22a2bb5
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/pprdev.h
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES) 
+#pragma message("including: " __FILE__) 
+#endif 
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER) 
+#error "pprdev.h" is deprecated, use "CussIF/pprdev.h" instead. 
+#else 
+// #pragma message ("Warning: \"pprdev.h\" is deprecated, use \"CussIF/pprdev.h\" instead.") 
+#include "CussIF/pprdev.h" 
+#endif 
diff --git a/SelfServiceCommon/Interfaces/inc/textIDL/textAppControl.h b/SelfServiceCommon/Interfaces/inc/textIDL/textAppControl.h
new file mode 100644
index 00000000..c853fc29
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/textIDL/textAppControl.h
@@ -0,0 +1,27 @@
+#ifndef TEXTAPPCONTROL_H_INCLUDED
+#define TEXTAPPCONTROL_H_INCLUDED
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "appcontrol.h"
+#include <string>
+#include <ostream>
+
+namespace MASSAI
+{
+  namespace appcontrol_text
+  {
+    std::string resolutionsText(const appControl::resolutions& code);
+    std::string applicationText(const appControl::application& code);
+    std::string commandTypeText(const appControl::commandType& code);
+    std::string applicationStartText(const appControl::applicationStart& code);
+  }
+}
+
+std::ostream& operator<<(std::ostream& out, const appControl::resolutions& code);
+std::ostream& operator<<(std::ostream& out, const appControl::application& code);
+std::ostream& operator<<(std::ostream& out, const appControl::commandType& code);
+std::ostream& operator<<(std::ostream& out, const appControl::applicationStart& code);
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/textIDL/textcharacteristics.h b/SelfServiceCommon/Interfaces/inc/textIDL/textcharacteristics.h
new file mode 100644
index 00000000..07b66561
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/textIDL/textcharacteristics.h
@@ -0,0 +1,67 @@
+#ifndef TEXTCHARACTERISTICS_H_INCLUDED
+#define TEXTCHARACTERISTICS_H_INCLUDED
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include <string>
+#include <ostream>
+#include "characteristics.h"
+
+namespace MASSAI
+{
+  namespace characteristics_text
+  {
+    std::string mediaTypeDefText         (Characteristics::MediaType::MediaTypeDef          mediaTypeDef);
+    std::string imageTypeText            (Characteristics::Location::ImageType              imageType);
+    std::string locationTypeText         (Characteristics::Location::LocationType           locationType);
+    std::string barcodeStandardText      (Characteristics::ComponentFonts::BarcodeStandard  barcodeStandard);
+    std::string inputOutputModeText      (Characteristics::IOMode::InputOutputMode          inputOutputMode);
+    std::string dispenserTypeText        (Characteristics::Dispenser::DispenserType         dispenserType);
+    std::string dataTypeText             (Characteristics::DataType                         dataType);
+    std::string readerTypeText           (Characteristics::MediaInput::ReaderType           readerType);
+    std::string mediaTypeText            (Characteristics::MediaOutput::MediaType           mediaType);
+    std::string printOrientationDefText  (Characteristics::MediaOutput::PrintOrientationDef printOrientationDef);
+    std::string mediaTransferTypeText    (Characteristics::MediaOutput::MediaTransferType   mediaTransferType);
+    std::string contactAddressTypeText   (Characteristics::Application::ContactAddressType  contactAddressType);
+    std::string conveyorTypeText         (Characteristics::Conveyor::ConveyorType           conveyorType);
+    std::string resolutionText           (long                                              resolution);
+
+    std::string fontSpecText             (const Characteristics::ComponentFonts::FontSpec&  fontSpec);
+    std::string contactText              (const Characteristics::Application::Contact&      contact);
+    std::string fontSpecText             (const Characteristics::ComponentFonts::FontSpec&  fontSpec);
+    std::string mediaTypeListDefText     (const Characteristics::MediaTypeListDef&          mediaTypeListDef);
+    std::string fontListText             (const Characteristics::ComponentFonts::FontList&  fontList);
+    std::string dataTypeListText         (const Characteristics::DataTypeList&              dataTypeList);
+    std::string resolutionListText       (const Characteristics::Display::ResolutionList&   resolutionList);
+    std::string contactListText          (const Characteristics::Application::ContactList&  contactList);
+  }
+}
+
+
+std::ostream& operator<<(std::ostream& out, Characteristics::MediaType::MediaTypeDef           mediaTypeDef);
+std::ostream& operator<<(std::ostream& out, Characteristics::Location::ImageType               imageType);
+std::ostream& operator<<(std::ostream& out, Characteristics::Location::LocationType            locationType);
+std::ostream& operator<<(std::ostream& out, Characteristics::ComponentFonts::BarcodeStandard   barcodeStandard);
+std::ostream& operator<<(std::ostream& out, Characteristics::IOMode::InputOutputMode           inputOutputMode);
+std::ostream& operator<<(std::ostream& out, Characteristics::Dispenser::DispenserType          dispenserType);
+std::ostream& operator<<(std::ostream& out, Characteristics::DataType                          dataType);
+std::ostream& operator<<(std::ostream& out, Characteristics::MediaInput::ReaderType            readerType);
+std::ostream& operator<<(std::ostream& out, Characteristics::MediaOutput::MediaType            mediaType);
+std::ostream& operator<<(std::ostream& out, Characteristics::MediaOutput::PrintOrientationDef  printOrientationDef);
+std::ostream& operator<<(std::ostream& out, Characteristics::MediaOutput::MediaTransferType    mediaTransferType);
+std::ostream& operator<<(std::ostream& out, Characteristics::Application::ContactAddressType   contactAddressType);
+std::ostream& operator<<(std::ostream& out, Characteristics::Conveyor::ConveyorType            conveyorType);
+
+std::ostream& operator<<(std::ostream& out, const Characteristics::ComponentFonts::FontSpec&   fontSpec);
+std::ostream& operator<<(std::ostream& out, const Characteristics::Application::Contact&       contact);
+std::ostream& operator<<(std::ostream& out, const Characteristics::ComponentFonts::FontSpec&   fontSpec);
+std::ostream& operator<<(std::ostream& out, const Characteristics::MediaTypeListDef&           mediaTypeListDef);
+std::ostream& operator<<(std::ostream& out, const Characteristics::ComponentFonts::FontList&   fontList);
+std::ostream& operator<<(std::ostream& out, const Characteristics::DataTypeList&               dataTypeList);
+std::ostream& operator<<(std::ostream& out, const Characteristics::Display::ResolutionList&    resolutionList);
+std::ostream& operator<<(std::ostream& out, const Characteristics::Application::ContactList&   contactList);
+std::ostream& operator<<(std::ostream& out, const Characteristics::Application::ContactList&   contactList);
+
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/textIDL/textcodes.h b/SelfServiceCommon/Interfaces/inc/textIDL/textcodes.h
new file mode 100644
index 00000000..abe3e5e3
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/textIDL/textcodes.h
@@ -0,0 +1,46 @@
+#ifndef TEXTCODES_H_INCLUDED
+#define TEXTCODES_H_INCLUDED
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include <string>
+#include <ostream>
+
+namespace MASSAI
+{
+  namespace codes_text
+  {
+    std::string returnCodesText(long code);
+    std::string dataStatusText (long code);
+    std::string eventCodesText (long code);
+    std::string statusCodesText(long code);
+
+    // ReturnCode included in EventCode and StatusCode
+
+    class DataStatus
+    {
+      public:
+        DataStatus(long code);
+        long code;
+    };
+    class EventCode
+    {
+      public:
+        EventCode(long code);
+        long code;
+    };
+    class StatusCode
+    {
+      public:
+        StatusCode(long code);
+        long code;
+    };
+  }
+}
+
+std::ostream& operator<<(std::ostream& out, const MASSAI::codes_text::DataStatus& code);
+std::ostream& operator<<(std::ostream& out, const MASSAI::codes_text::EventCode& code);
+std::ostream& operator<<(std::ostream& out, const MASSAI::codes_text::StatusCode& code);
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/textIDL/textgppdev.h b/SelfServiceCommon/Interfaces/inc/textIDL/textgppdev.h
new file mode 100644
index 00000000..b889617f
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/textIDL/textgppdev.h
@@ -0,0 +1,45 @@
+#ifndef TEXTGPPDEV_H_INCLUDED
+#define TEXTGPPDEV_H_INCLUDED
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "gppdev.h"
+#include <string>
+#include <ostream>
+
+namespace MASSAI
+{
+  namespace gppdev_text
+  {
+    std::string mediaTypeText       (const gppdev::mediaType& code);
+    std::string completionTypeText  (const gppdev::completionType& code);
+    std::string errorTypeText       (const gppdev::errorType& code);
+    std::string mediaStatusTypeText (const gppdev::mediaStatusType& code);
+    std::string commandTypeText     (const gppdev::commandType& code);
+    std::string printOrientationText(const gppdev::printOrientation& code);
+    std::string indicationTypeText  (const gppdev::indicationType& code);
+
+    std::string stockTypeText                   (const gppdev::stockType& data);
+    std::string stockListText                   (const gppdev::stockList& data);
+    std::string statusOfMultipleStockPrinterText(const gppdev::statusOfMultipleStockPrinter& data);
+    std::string extendendPrintDataText          (const gppdev::extendendPrintData& data);
+    std::string gppCommandDataText              (const gppdev::gppCommandData& data);
+  }
+}
+
+std::ostream& operator<<(std::ostream& out, const gppdev::mediaType& code);
+std::ostream& operator<<(std::ostream& out, const gppdev::completionType& code);
+std::ostream& operator<<(std::ostream& out, const gppdev::errorType& code);
+std::ostream& operator<<(std::ostream& out, const gppdev::mediaStatusType& code);
+std::ostream& operator<<(std::ostream& out, const gppdev::commandType& code);
+std::ostream& operator<<(std::ostream& out, const gppdev::printOrientation& code);
+std::ostream& operator<<(std::ostream& out, const gppdev::indicationType& code);
+
+std::ostream& operator<<(std::ostream& out, const gppdev::stockType& data);
+std::ostream& operator<<(std::ostream& out, const gppdev::stockList& data);
+std::ostream& operator<<(std::ostream& out, const gppdev::statusOfMultipleStockPrinter& data);
+std::ostream& operator<<(std::ostream& out, const gppdev::extendendPrintData& data);
+std::ostream& operator<<(std::ostream& out, const gppdev::gppCommandData& data);
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/textIDL/textmdci.h b/SelfServiceCommon/Interfaces/inc/textIDL/textmdci.h
new file mode 100644
index 00000000..bc37abec
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/textIDL/textmdci.h
@@ -0,0 +1,37 @@
+#ifndef TEXTMDCI_H_INCLUDED
+#define TEXTMDCI_H_INCLUDED
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "mdci.h"
+#include <string>
+#include <ostream>
+
+namespace MASSAI
+{
+  namespace mdci_text
+  {
+    std::string rcText(const DeviceComponents::RC& code);
+
+    std::string svgDataText   (const DeviceComponents::svgData& data);
+    std::string aeaDataText   (const DeviceComponents::aeaData& data);
+    std::string strngDataText (const DeviceComponents::strngData& data);
+    std::string nullDataText  (const DeviceComponents::nullData& data);
+    std::string commandText   (const DeviceComponents::command& data);
+    std::string indicationText(const DeviceComponents::indication& data);
+  }
+}
+
+std::ostream& operator<<(std::ostream& out, const DeviceComponents::RC& code);
+
+std::ostream& operator<<(std::ostream& out, const DeviceComponents::svgData& data);
+std::ostream& operator<<(std::ostream& out, const DeviceComponents::aeaData& data);
+std::ostream& operator<<(std::ostream& out, const DeviceComponents::nullData& data);
+std::ostream& operator<<(std::ostream& out, const DeviceComponents::command& data);
+std::ostream& operator<<(std::ostream& out, const DeviceComponents::indication& data);
+
+
+#endif
+
+
diff --git a/SelfServiceCommon/Interfaces/inc/textIDL/texttypes.h b/SelfServiceCommon/Interfaces/inc/textIDL/texttypes.h
new file mode 100644
index 00000000..2f0d45cc
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/textIDL/texttypes.h
@@ -0,0 +1,130 @@
+#ifndef TEXTTYPES_H_INCLUDED
+#define TEXTTYPES_H_INCLUDED
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include <string>
+#include <ostream>
+#include "types.h"
+
+namespace MASSAI
+{
+  namespace types_text
+  {
+    std::string orientationText                     (types::orientation                                     orientation);
+    std::string actionText                          (types::action                                          action);
+    std::string evtCategoryText                     (types::evtCategory                                     evtCategory);
+    std::string evtTypeText                         (types::evtType                                         evtType);
+    std::string evtModeText                         (types::evtMode                                         evtMode);
+    std::string evtFilterTypeText                   (types::evtFilterType                                   evtFilterType);
+    std::string dataStatusText                      (types::dataStatus                                      dataStatus);
+    std::string evtCodeText                         (types::evtCode                                         evtCode);
+    std::string evtStatusCodeText                   (types::evtStatusCode                                   evtStatusCode);
+
+    std::string akIDText                            (const types::akID&                                     akID);
+    std::string locationText                        (const types::location&                                 location);
+    std::string coordinateText                      (const types::coordinate&                               coordinate);
+    std::string gpsText                             (const types::gps&                                      gps);
+    std::string environmentLevelText                (const types::EnvironmentLevel&                         environmentLevel);
+    std::string environmentComponentText            (const types::EnvironmentComponent&                     environmentComponent);
+    std::string dataRecordText                      (const types::dataRecord&                               dataRecord);
+    std::string msgDataTypeText                     (const types::msgDataType&                              msgDataType);
+    std::string evtCodeFilterElemText               (const types::evtCodeFilterElem&                        evtCodeFilterElem);
+    std::string evtTypeFilterElemText               (const types::evtTypeFilterElem&                        evtTypeFilterElem);
+    std::string evtComponentFilterElemText          (const types::evtComponentFilterElem&                   evtComponentFilterElem);
+    std::string evtDescrText                        (const types::evtDescr&                                 evtDescr);
+    std::string evtDescrANY_CODE_TYPEText           (const types::evtDescrANY_CODE_TYPE&                    evtDescrANY_CODE_TYPE);
+    std::string evtDescrCOMPONENTText               (const types::evtDescrCOMPONENT&                        evtDescrCOMPONENT);
+    std::string eventText                           (const types::Event&                                    event);
+    std::string evtCodeFilterUnionText              (const types::evtCodeFilterUnion&                       evtCodeFilterUnion);
+    std::string evtTypeFilterUnionText              (const types::evtTypeFilterUnion&                       evtTypeFilterUnion);
+    std::string evtComponentFilterUnionText         (const types::evtComponentFilterUnion&                  evtComponentFilterUnion);
+    std::string evtFilterText                       (const types::evtFilter&                                evtFilter);
+    std::string evtAcquireFilterText                (const types::evtAcquireFilter&                         evtAcquireFilter);
+    std::string evtDescriptionText                  (const types::evtDescription&                           evtDescription);
+    std::string namelistText                        (const types::namelist&                                 namelist);
+    std::string indexListText                       (const types::indexList&                                indexList);
+    std::string iorlistText                         (const types::iorlist&                                  iorlist);
+    std::string bytestreamText                      (const types::bytestream&                               bytestream);
+    std::string environmentComponentsText           (const types::EnvironmentComponents&                    environmentComponents);
+    std::string evtCodeFilterText                   (const types::evtCodeFilter&                            evtCodeFilter);
+    std::string evtTypeFilterText                   (const types::evtTypeFilter&                            evtTypeFilter);
+    std::string evtComponentFilterText              (const types::evtComponentFilter&                       evtComponentFilter);
+
+    std::string msgDataTypeRecordsSeqText           (const types::msgDataType::_records_seq&                records);
+    std::string evtDescrEventTypesSeq               (const types::evtDescr::_eventTypes_seq&                eventTypes);
+    std::string evtDescrCOMPONENTEventDescrSeq      (const types::evtDescrCOMPONENT::_eventDescr_seq&       eventDescr);
+    std::string evtComponentFilterUnionFilterCODESeq(const types::evtComponentFilterUnion::_filterCODE_seq& filterCODE);
+    std::string evtComponentFilterUnionFilterTYPESeq(const types::evtComponentFilterUnion::_filterTYPE_seq& filterTYPE);
+    std::string evtAcquireFilterFilterCODESeq       (const types::evtAcquireFilter::_filterCODE_seq&        filterCODE);
+    std::string evtAcquireFilterFilterTYPESeq       (const types::evtAcquireFilter::_filterTYPE_seq&        filterTYPE);
+
+    std::string timestampText                       (types::TimeT                                           timestamp);
+    std::string eventDataText                       (const CORBA::Any&                                      eventData);
+    std::string eludText                            (const CORBA::Any&                                      elud);
+    std::string bytestreamText                      (const types::bytestream&                               bytestream);
+  }
+}
+
+std::ostream& operator<<(std::ostream& out, types::orientation                                     orientation);
+std::ostream& operator<<(std::ostream& out, types::action                                          action);
+std::ostream& operator<<(std::ostream& out, types::evtCategory                                     evtCategory);
+std::ostream& operator<<(std::ostream& out, types::evtType                                         evtType);
+std::ostream& operator<<(std::ostream& out, types::evtMode                                         evtMode);
+std::ostream& operator<<(std::ostream& out, types::evtFilterType                                   evtFilterType);
+
+std::ostream& operator<<(std::ostream& out, const types::akID&                                     akID);
+std::ostream& operator<<(std::ostream& out, const types::location&                                 location);
+std::ostream& operator<<(std::ostream& out, const types::coordinate&                               coordinate);
+std::ostream& operator<<(std::ostream& out, const types::gps&                                      gps);
+std::ostream& operator<<(std::ostream& out, const types::EnvironmentLevel&                         environmentLevel);
+std::ostream& operator<<(std::ostream& out, const types::EnvironmentComponent&                     environmentComponent);
+std::ostream& operator<<(std::ostream& out, const types::dataRecord&                               dataRecord);
+std::ostream& operator<<(std::ostream& out, const types::msgDataType&                              msgDataType);
+std::ostream& operator<<(std::ostream& out, const types::evtCodeFilterElem&                        evtCodeFilterElem);
+std::ostream& operator<<(std::ostream& out, const types::evtTypeFilterElem&                        evtTypeFilterElem);
+std::ostream& operator<<(std::ostream& out, const types::evtComponentFilterElem&                   evtComponentFilterElem);
+std::ostream& operator<<(std::ostream& out, const types::evtDescr&                                 evtDescr);
+std::ostream& operator<<(std::ostream& out, const types::evtDescrANY_CODE_TYPE&                    evtDescrANY_CODE_TYPE);
+std::ostream& operator<<(std::ostream& out, const types::evtDescrCOMPONENT&                        evtDescrCOMPONENT);
+std::ostream& operator<<(std::ostream& out, const types::Event&                                    event);
+std::ostream& operator<<(std::ostream& out, const types::evtCodeFilterUnion&                       evtCodeFilterUnion);
+std::ostream& operator<<(std::ostream& out, const types::evtTypeFilterUnion&                       evtTypeFilterUnion);
+std::ostream& operator<<(std::ostream& out, const types::evtComponentFilterUnion&                  evtComponentFilterUnion);
+std::ostream& operator<<(std::ostream& out, const types::evtFilter&                                evtFilter);
+std::ostream& operator<<(std::ostream& out, const types::evtAcquireFilter&                         evtAcquireFilter);
+std::ostream& operator<<(std::ostream& out, const types::evtDescription&                           evtDescription);
+std::ostream& operator<<(std::ostream& out, const types::namelist&                                 namelist);
+std::ostream& operator<<(std::ostream& out, const types::indexList&                                indexList);
+std::ostream& operator<<(std::ostream& out, const types::iorlist&                                  iorlist);
+std::ostream& operator<<(std::ostream& out, const types::bytestream&                               bytestream);
+std::ostream& operator<<(std::ostream& out, const types::EnvironmentComponents&                    environmentComponents);
+std::ostream& operator<<(std::ostream& out, const types::evtCodeFilter&                            evtCodeFilter);
+std::ostream& operator<<(std::ostream& out, const types::evtTypeFilter&                            evtTypeFilter);
+std::ostream& operator<<(std::ostream& out, const types::evtComponentFilter&                       evtComponentFilter);
+
+std::ostream& operator<<(std::ostream& out, const types::msgDataType::_records_seq&                records);
+std::ostream& operator<<(std::ostream& out, const types::evtDescr::_eventTypes_seq&                eventTypes);
+std::ostream& operator<<(std::ostream& out, const types::evtDescrCOMPONENT::_eventDescr_seq&       eventDescr);
+
+std::ostream& operator<<(std::ostream& out, const types::evtComponentFilterUnion::_filterCODE_seq& filterCODE);
+std::ostream& operator<<(std::ostream& out, const types::evtComponentFilterUnion::_filterTYPE_seq& filterTYPE);
+std::ostream& operator<<(std::ostream& out, const types::evtAcquireFilter::_filterCODE_seq&        filterCODE);
+std::ostream& operator<<(std::ostream& out, const types::evtAcquireFilter::_filterTYPE_seq&        filterTYPE);
+
+
+
+
+/*
+typedef string name;
+typedef string reference;
+typedef string ior;
+typedef bytestream aeaDataType;
+typedef bytestream svgDataType;
+typedef octet nilDataType;
+typedef any correlation;
+typedef any  datastream;
+*/
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/vcomp.h b/SelfServiceCommon/Interfaces/inc/vcomp.h
new file mode 100644
index 00000000..7855033a
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/vcomp.h
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES) 
+#pragma message("including: " __FILE__) 
+#endif 
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER) 
+#error "vcomp.h" is deprecated, use "CussIF/vcomp.h" instead. 
+#else 
+// #pragma message ("Warning: \"vcomp.h\" is deprecated, use \"CussIF/vcomp.h\" instead.") 
+#include "CussIF/vcomp.h" 
+#endif 
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/doxyfile b/SelfServiceCommon/Massai/cpp/CussIF/doxyfile
new file mode 100644
index 00000000..fdf33b53
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/doxyfile
@@ -0,0 +1,234 @@
+# Doxyfile 1.4.6
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+PROJECT_NAME           = "Massai.CussIF (C++)"
+PROJECT_NUMBER         = 
+OUTPUT_DIRECTORY       = 
+CREATE_SUBDIRS         = NO
+OUTPUT_LANGUAGE        = English
+USE_WINDOWS_ENCODING   = YES
+BRIEF_MEMBER_DESC      = YES
+REPEAT_BRIEF           = YES
+ABBREVIATE_BRIEF       = "The $name class" \
+                         "The $name widget" \
+                         "The $name file" \
+                         is \
+                         provides \
+                         specifies \
+                         contains \
+                         represents \
+                         a \
+                         an \
+                         the
+ALWAYS_DETAILED_SEC    = NO
+INLINE_INHERITED_MEMB  = NO
+FULL_PATH_NAMES        = NO
+STRIP_FROM_PATH        = 
+STRIP_FROM_INC_PATH    = 
+SHORT_NAMES            = NO
+JAVADOC_AUTOBRIEF      = YES
+MULTILINE_CPP_IS_BRIEF = NO
+DETAILS_AT_TOP         = NO
+INHERIT_DOCS           = YES
+SEPARATE_MEMBER_PAGES  = NO
+TAB_SIZE               = 8
+ALIASES                = 
+OPTIMIZE_OUTPUT_FOR_C  = NO
+OPTIMIZE_OUTPUT_JAVA   = NO
+BUILTIN_STL_SUPPORT    = NO
+DISTRIBUTE_GROUP_DOC   = NO
+SUBGROUPING            = YES
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+EXTRACT_ALL            = NO
+EXTRACT_PRIVATE        = NO
+EXTRACT_STATIC         = NO
+EXTRACT_LOCAL_CLASSES  = YES
+EXTRACT_LOCAL_METHODS  = NO
+HIDE_UNDOC_MEMBERS     = YES
+HIDE_UNDOC_CLASSES     = YES
+HIDE_FRIEND_COMPOUNDS  = NO
+HIDE_IN_BODY_DOCS      = NO
+INTERNAL_DOCS          = NO
+CASE_SENSE_NAMES       = YES
+HIDE_SCOPE_NAMES       = NO
+SHOW_INCLUDE_FILES     = YES
+INLINE_INFO            = YES
+SORT_MEMBER_DOCS       = YES
+SORT_BRIEF_DOCS        = NO
+SORT_BY_SCOPE_NAME     = NO
+GENERATE_TODOLIST      = YES
+GENERATE_TESTLIST      = YES
+GENERATE_BUGLIST       = YES
+GENERATE_DEPRECATEDLIST= YES
+ENABLED_SECTIONS       = 
+MAX_INITIALIZER_LINES  = 30
+SHOW_USED_FILES        = YES
+SHOW_DIRECTORIES       = NO
+FILE_VERSION_FILTER    = 
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+QUIET                  = NO
+WARNINGS               = YES
+WARN_IF_UNDOCUMENTED   = YES
+WARN_IF_DOC_ERROR      = YES
+WARN_NO_PARAMDOC       = NO
+WARN_FORMAT            = "$file($line) : $text"
+WARN_LOGFILE           = 
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+INPUT                  = M:/chmetzle_SelfService_R1040_MainDev_Local/SelfServiceCUSS/Massai/cpp/cussif/mainpage.dox \
+                         M:/chmetzle_SelfService_R1040_MainDev_Local/SelfServiceCUSS/Interfaces/inc/CussIF
+FILE_PATTERNS          = 
+RECURSIVE              = NO
+EXCLUDE                = 
+EXCLUDE_SYMLINKS       = NO
+EXCLUDE_PATTERNS       = 
+EXAMPLE_PATH           = examples
+EXAMPLE_PATTERNS       = 
+EXAMPLE_RECURSIVE      = NO
+IMAGE_PATH             = 
+INPUT_FILTER           = 
+FILTER_PATTERNS        = 
+FILTER_SOURCE_FILES    = NO
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+SOURCE_BROWSER         = NO
+INLINE_SOURCES         = NO
+STRIP_CODE_COMMENTS    = YES
+REFERENCED_BY_RELATION = NO
+REFERENCES_RELATION    = NO
+USE_HTAGS              = NO
+VERBATIM_HEADERS       = NO
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+ALPHABETICAL_INDEX     = YES
+COLS_IN_ALPHA_INDEX    = 3
+IGNORE_PREFIX          = 
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+GENERATE_HTML          = YES
+HTML_OUTPUT            = html
+HTML_FILE_EXTENSION    = .html
+HTML_HEADER            = doxyheader.html
+HTML_FOOTER            = doxyfooter.html
+HTML_STYLESHEET        = massai.css
+HTML_ALIGN_MEMBERS     = YES
+GENERATE_HTMLHELP      = YES
+CHM_FILE               = 
+HHC_LOCATION           = 
+GENERATE_CHI           = YES
+BINARY_TOC             = YES
+TOC_EXPAND             = YES
+DISABLE_INDEX          = NO
+ENUM_VALUES_PER_LINE   = 4
+GENERATE_TREEVIEW      = NO
+TREEVIEW_WIDTH         = 250
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+GENERATE_LATEX         = NO
+LATEX_OUTPUT           = latex
+LATEX_CMD_NAME         = latex
+MAKEINDEX_CMD_NAME     = makeindex
+COMPACT_LATEX          = NO
+PAPER_TYPE             = a4
+EXTRA_PACKAGES         = 
+LATEX_HEADER           = 
+PDF_HYPERLINKS         = YES
+USE_PDFLATEX           = YES
+LATEX_BATCHMODE        = NO
+LATEX_HIDE_INDICES     = NO
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+GENERATE_RTF           = YES
+RTF_OUTPUT             = rtf
+COMPACT_RTF            = NO
+RTF_HYPERLINKS         = YES
+RTF_STYLESHEET_FILE    = 
+RTF_EXTENSIONS_FILE    = 
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+GENERATE_MAN           = NO
+MAN_OUTPUT             = man
+MAN_EXTENSION          = .3
+MAN_LINKS              = NO
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+GENERATE_XML           = NO
+XML_OUTPUT             = xml
+XML_SCHEMA             = 
+XML_DTD                = 
+XML_PROGRAMLISTING     = YES
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+GENERATE_AUTOGEN_DEF   = NO
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+GENERATE_PERLMOD       = NO
+PERLMOD_LATEX          = NO
+PERLMOD_PRETTY         = YES
+PERLMOD_MAKEVAR_PREFIX = 
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor   
+#---------------------------------------------------------------------------
+ENABLE_PREPROCESSING   = YES
+MACRO_EXPANSION        = NO
+EXPAND_ONLY_PREDEF     = NO
+SEARCH_INCLUDES        = YES
+INCLUDE_PATH           = 
+INCLUDE_FILE_PATTERNS  = 
+PREDEFINED             = 
+EXPAND_AS_DEFINED      = 
+SKIP_FUNCTION_MACROS   = YES
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references   
+#---------------------------------------------------------------------------
+TAGFILES               = 
+GENERATE_TAGFILE       = 
+ALLEXTERNALS           = NO
+EXTERNAL_GROUPS        = YES
+PERL_PATH              = /usr/bin/perl
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool   
+#---------------------------------------------------------------------------
+CLASS_DIAGRAMS         = YES
+HIDE_UNDOC_RELATIONS   = YES
+HAVE_DOT               = NO
+CLASS_GRAPH            = YES
+COLLABORATION_GRAPH    = YES
+GROUP_GRAPHS           = YES
+UML_LOOK               = NO
+TEMPLATE_RELATIONS     = YES
+INCLUDE_GRAPH          = YES
+INCLUDED_BY_GRAPH      = YES
+CALL_GRAPH             = NO
+GRAPHICAL_HIERARCHY    = YES
+DIRECTORY_GRAPH        = YES
+DOT_IMAGE_FORMAT       = png
+DOT_PATH               = 
+DOTFILE_DIRS           = 
+MAX_DOT_GRAPH_WIDTH    = 1024
+MAX_DOT_GRAPH_HEIGHT   = 1024
+MAX_DOT_GRAPH_DEPTH    = 1000
+DOT_TRANSPARENT        = NO
+DOT_MULTI_TARGETS      = NO
+GENERATE_LEGEND        = YES
+DOT_CLEANUP            = YES
+#---------------------------------------------------------------------------
+# Configuration::additions related to the search engine   
+#---------------------------------------------------------------------------
+SEARCHENGINE           = NO
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/doxyfooter.html b/SelfServiceCommon/Massai/cpp/CussIF/doxyfooter.html
new file mode 100644
index 00000000..b7e720c5
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/doxyfooter.html
@@ -0,0 +1,15 @@
+<body text="#000000" bgcolor="#ffffff" link="#000080" vlink="#000077" alink="#800000">
+
+<hr>
+
+<table border="0" width="100%">
+<tr>
+<td width=40>
+   <img src="../materna.gif" alt="Materna Information & Communications" border=0>
+</td>
+<td align=right valign = top> Comments to: &nbsp
+<a href="mailto:andreas.gehling@materna.de">Andreas Gehling</A>
+</td>
+</tr>
+</table>
+</body>
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/doxyheader.html b/SelfServiceCommon/Massai/cpp/CussIF/doxyheader.html
new file mode 100644
index 00000000..47bd94cb
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/doxyheader.html
@@ -0,0 +1,33 @@
+<head>
+   <title>Massai Documentation</title>
+</head>
+
+<body text="#000080" background="#eeeeff" link="#000080" vlink="#000077" alink="#800000">
+
+<link href="massai.css" rel="stylesheet" type="text/css">
+
+<table border="0" width="100%">
+<tr>
+  <td align=right bgcolor="#17479e" width=100% height=80> <a href="http://www.cuss-solutions.com"> <p valign= middle> <font size="+2" color="#ffffff">
+  <b>Massai</a>.FRAME Documentation&nbsp</b></p>
+  </font>
+  </td>
+</tr>
+
+<tr>
+  <table border="0" width="100%">
+
+    <td bgcolor="#f58220" width=50%  height=20> </td>
+    <td bgcolor="#eaeaea" width=1% > </td>
+    <td bgcolor="#f9b883" width=15%> </td>
+    <td bgcolor="#eaeaea" width=1%> </td>
+    <td bgcolor="#fce0c8" width=15%> </td>
+    <td bgcolor="#eaeaea" width=1%> </td>
+    <td bgcolor="#ffffff" width=16%> </td>
+
+  </table>
+
+</tr>
+</table>
+<hr>
+</body>
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/inc/XMLScreen.h b/SelfServiceCommon/Massai/cpp/CussIF/inc/XMLScreen.h
new file mode 100644
index 00000000..eef521cc
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/inc/XMLScreen.h
@@ -0,0 +1,25 @@
+/****************************************************************************
+ *
+ * @file XMLScreen.h
+ *
+ * converts the screen data to an xml format
+ *
+ * @author TS
+ *
+ * Copyright (c) 2004, MATERNA Information & Communications
+ *
+ ****************************************************************************/
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+
+
+#include <string>
+#include "asso.h"
+
+void convertScreenToXML(const aMap& screen, std::string& xmlstream);
+
+
+/****************************************************************************
+ End of file XMLScreen.h
+****************************************************************************/
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/inc/check.h b/SelfServiceCommon/Massai/cpp/CussIF/inc/check.h
new file mode 100644
index 00000000..c3d71ffd
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/inc/check.h
@@ -0,0 +1,24 @@
+//---------------------------------------------------------------------------
+//
+//  file:       check.h
+//
+//  purpose:    check functions for return codes etc.
+//
+//  date:       23.02.01, 12:16
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+#ifndef CHECK_H
+#define CHECK_H
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+
+#include "types.h"
+#include "codes.h"
+
+long checkStatusCode(types::Event_out ev);
+
+#endif // CHECK_H
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/inc/client.h b/SelfServiceCommon/Massai/cpp/CussIF/inc/client.h
new file mode 100644
index 00000000..152b66d6
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/inc/client.h
@@ -0,0 +1,96 @@
+//---------------------------------------------------------------------------
+//
+//  file:       client.h
+//
+//  purpose:    Header file
+//
+//  date:       19.04.2002, 12:20
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+#if !defined(CLIENT_H)
+#define CLIENT_H
+
+#ifdef  SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include "cussif.h"
+#include "tracedef.h"
+
+#include "bppdev.h"
+#include "btpdev.h"
+#include "gppdevice.h"
+#include "mcdev.h"
+#include "escrowdev.h"
+
+using namespace MASSAI;
+
+class testApplication : public cussApplication
+{
+private:
+
+    /** CUSS application handlers */
+
+    void platformEvent  (long eventCode, long statusCode);
+
+    long disable        ();
+    long stop           ();
+    long suspend        ();
+    long resume         ();
+    long idle           ();
+
+    long initialize     (EnvironmentLevel_var el);
+    long activate       (EnvironmentLevel_var el);
+
+    long userBreak      (int signal);
+    long criticalError  (int signal);
+//    long massaiTrace    (long lLevel,char *pszFile,long sLine,char *pText);
+
+public:
+
+    magCardDevice *pCardDev;
+    escrowDevice  *pEscrow;
+    bppDevice     *pBPPrinter;
+    btpDevice     *pBTPrinter;
+    gppDevice     *pgppDevice;
+
+    long terminate();
+
+    long connectHardwareDevices();
+    long releaseHardwareDevices();
+
+    /** Class constructor
+        @param pszAddress - Kiosk IP address or the IOR of the application manager on the kiosk.
+        This value is passed to the application by the starter applet on the kiosk.
+    */
+
+    testApplication(char *pszAppMgrIOR,
+                    char *pszCompanyCode,
+                    char *pszAppName) : cussApplication(pszAppMgrIOR,
+                                                        pszCompanyCode,
+                                                        pszAppName,
+                                                        "MAT")
+    {
+       trace(_HERE,"INTERNAL APPLICATION START\n");
+
+       pCardDev   = NULL;
+       pEscrow    = NULL;
+       pBPPrinter = NULL;
+       pBTPrinter = NULL;
+       pgppDevice = NULL;
+
+       startHandlingEvents();
+    }
+
+    /** Class destructor */
+
+    ~testApplication()
+    {
+       trace(_HERE,"INTERNAL APPLICATION STOP\n");
+    }
+};
+
+#endif // CLIENT_H
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/inc/client_def.h b/SelfServiceCommon/Massai/cpp/CussIF/inc/client_def.h
new file mode 100644
index 00000000..03eeec2c
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/inc/client_def.h
@@ -0,0 +1,16 @@
+/*! \page c++-cussif testclient
+ *
+ *  \date 21.09.2006 \li V1.0.0.0
+ *
+ */
+
+
+#define FILE_VER_BIN     1,0,0,0
+#define FILE_VER_STR     "FileVersion", "1.0.0.0\0"
+
+#define FILEDESCRIPTION  "FileDescription"  ,"CussIF Client\0"
+#define INTERNALNAME     "InternalName"     ,"cussif Client\0"
+#define LEGALTRADEMARKS  "LegalTrademarks"  ,"\0"
+#define ORIGINALFILENAME "OriginalFilename" ,"client.exe\0"
+
+
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/inc/dispMap.h b/SelfServiceCommon/Massai/cpp/CussIF/inc/dispMap.h
new file mode 100644
index 00000000..d3b2b17b
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/inc/dispMap.h
@@ -0,0 +1,60 @@
+/**
+ **************************************************************************
+ *
+ * @file dispMap.h
+ *
+ * dispXTRA device implementation: showDisplay(aMap& screen)
+ *
+ * @author TS
+ *
+ * Copyright (c) 2001, MATERNA Information & Communications
+ *
+ **************************************************************************
+**/
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+
+
+#include <string>
+#include "language.h"
+#include "asso.h"
+#include "dispdev.h"
+
+enum Error
+{
+  INVALID_DATA= 1,
+  INVALID_PARAM,
+  ID_ALREADY_SET,
+  ID_NOT_SET,
+};
+
+using std::string;
+/*
+  replace all variables in the template file by the values of DataIn
+*/
+int fillTemplate(string Template, const aMap& DataIn, string& result, aMap& DataUsed, aMap& NotFound);
+/*
+  read the template file to Template (if not found use pAlternative)
+*/
+int loadTemplate(const char* pFile, const char* pAlternative, string& Template, language& resource, bool isRtf);
+/*
+  read the template file to Template (if not found use pAlternative)
+*/
+int loadTemplate(const char* pScreenId, const char* pTemplate, const char* pAlternative, string& Template, language& resource);
+/*
+  translate the values of the data entries (if a filename is found use the content of the file)
+*/
+int transData(const aObject& ScreenId, const aObject DataIn, aObject& DataOut, aObject& DataError, language& resource, MASSAI::screen::Encoding enc= MASSAI::screen::ENCODING_NO);
+
+
+
+/**
+ **************************************************************************
+ *
+ * End of file
+ *
+ **************************************************************************
+**/
+
+
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/inc/pdf417lib.h b/SelfServiceCommon/Massai/cpp/CussIF/inc/pdf417lib.h
new file mode 100644
index 00000000..16709c6f
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/inc/pdf417lib.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2003 by Paulo Soares.
+ *
+ * The contents of this file are subject to the Mozilla Public License Version 1.1
+ * (the "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the License.
+ *
+ * The Original Code is 'pdf417lib, a library to generate the bidimensional barcode PDF417'.
+ *
+ * The Initial Developer of the Original Code is Paulo Soares. Portions created by
+ * the Initial Developer are Copyright (C) 2003 by Paulo Soares.
+ * All Rights Reserved.
+ *
+ * Contributor(s): all the names of the contributors are added in the source code
+ * where applicable.
+ *
+ * Alternatively, the contents of this file may be used under the terms of the
+ * LGPL license (the "GNU LIBRARY GENERAL PUBLIC LICENSE"), in which case the
+ * provisions of LGPL are applicable instead of those above.  If you wish to
+ * allow use of your version of this file only under the terms of the LGPL
+ * License and not to allow others to use your version of this file under
+ * the MPL, indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by the LGPL.
+ * If you do not delete the provisions above, a recipient may use your version
+ * of this file under either the MPL or the GNU LIBRARY GENERAL PUBLIC LICENSE.
+ *
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the MPL as stated above or under the terms of the GNU
+ * Library General Public License as published by the Free Software Foundation;
+ * either version 2 of the License, or any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU Library general Public License for more
+ * details.
+ *
+ * If you didn't download this code from the following link, you should check if
+ * you aren't using an obsolete version:
+ * http://sourceforge.net/projects/pdf417lib
+ */
+#ifndef __PDF417LIB_H__
+#define __PDF417LIB_H__
+
+#define PDF417_USE_ASPECT_RATIO     0
+#define PDF417_FIXED_RECTANGLE      1
+#define PDF417_FIXED_COLUMNS        2
+#define PDF417_FIXED_ROWS           4
+#define PDF417_AUTO_ERROR_LEVEL     0
+#define PDF417_USE_ERROR_LEVEL      16
+#define PDF417_USE_RAW_CODEWORDS    64
+#define PDF417_INVERT_BITMAP        128
+
+#define PDF417_ERROR_SUCCESS        0
+#define PDF417_ERROR_TEXT_TOO_BIG   1
+#define PDF417_ERROR_INVALID_PARAMS 2
+
+
+typedef struct _pdf417param {
+    char *outBits;
+    int lenBits;
+    int bitColumns;
+    int codeRows;
+    int codeColumns;
+    int codewords[928];
+    int lenCodewords;
+    int errorLevel;
+    char *text;
+    int lenText;
+    int options;
+    float aspectRatio;
+    float yHeight;
+    int error;
+} pdf417param, *pPdf417param;
+
+void paintCode(pPdf417param p);
+void pdf417init(pPdf417param param);
+void pdf417free(pPdf417param param);
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/inc/pdf417libimp.h b/SelfServiceCommon/Massai/cpp/CussIF/inc/pdf417libimp.h
new file mode 100644
index 00000000..91867ba7
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/inc/pdf417libimp.h
@@ -0,0 +1,514 @@
+/*
+ * Copyright 2003 by Paulo Soares.
+ *
+ * The contents of this file are subject to the Mozilla Public License Version 1.1
+ * (the "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the License.
+ *
+ * The Original Code is 'pdf417lib, a library to generate the bidimensional barcode PDF417'.
+ *
+ * The Initial Developer of the Original Code is Paulo Soares. Portions created by
+ * the Initial Developer are Copyright (C) 2003 by Paulo Soares.
+ * All Rights Reserved.
+ *
+ * Contributor(s): all the names of the contributors are added in the source code
+ * where applicable.
+ *
+ * Alternatively, the contents of this file may be used under the terms of the
+ * LGPL license (the "GNU LIBRARY GENERAL PUBLIC LICENSE"), in which case the
+ * provisions of LGPL are applicable instead of those above.  If you wish to
+ * allow use of your version of this file only under the terms of the LGPL
+ * License and not to allow others to use your version of this file under
+ * the MPL, indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by the LGPL.
+ * If you do not delete the provisions above, a recipient may use your version
+ * of this file under either the MPL or the GNU LIBRARY GENERAL PUBLIC LICENSE.
+ *
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the MPL as stated above or under the terms of the GNU
+ * Library General Public License as published by the Free Software Foundation;
+ * either version 2 of the License, or any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU Library general Public License for more
+ * details.
+ *
+ * If you didn't download this code from the following link, you should check if
+ * you aren't using an obsolete version:
+ * http://sourceforge.net/projects/pdf417lib
+ */
+#ifdef __INCLUDE_PDF417LIBIMP_H__
+
+#define START_PATTERN 0x1fea8
+#define STOP_PATTERN 0x3fa29
+#define START_CODE_SIZE 17
+#define STOP_SIZE 18
+#define MOD 929
+#define ALPHA 0x10000
+#define LOWER 0x20000
+#define MIXED 0x40000
+#define PUNCTUATION 0x80000
+#define ISBYTE 0x100000
+#define BYTESHIFT 913
+#define PL 25
+#define LL 27
+#define AS 27
+#define ML 28
+#define AL 28
+#define PS 29
+#define PAL 29
+#define SPACE 26
+#define TEXT_MODE 900
+#define BYTE_MODE_6 924
+#define BYTE_MODE 901
+#define NUMERIC_MODE 902
+#define ABSOLUTE_MAX_TEXT_SIZE  5420
+#define MAX_DATA_CODEWORDS  926
+
+int CLUSTERS[3][929] =
+{{
+    0x1d5c0, 0x1eaf0, 0x1f57c, 0x1d4e0, 0x1ea78, 0x1f53e, 0x1a8c0, 0x1d470,
+    0x1a860, 0x15040, 0x1a830, 0x15020, 0x1adc0, 0x1d6f0, 0x1eb7c, 0x1ace0,
+    0x1d678, 0x1eb3e, 0x158c0, 0x1ac70, 0x15860, 0x15dc0, 0x1aef0, 0x1d77c,
+    0x15ce0, 0x1ae78, 0x1d73e, 0x15c70, 0x1ae3c, 0x15ef0, 0x1af7c, 0x15e78,
+    0x1af3e, 0x15f7c, 0x1f5fa, 0x1d2e0, 0x1e978, 0x1f4be, 0x1a4c0, 0x1d270,
+    0x1e93c, 0x1a460, 0x1d238, 0x14840, 0x1a430, 0x1d21c, 0x14820, 0x1a418,
+    0x14810, 0x1a6e0, 0x1d378, 0x1e9be, 0x14cc0, 0x1a670, 0x1d33c, 0x14c60,
+    0x1a638, 0x1d31e, 0x14c30, 0x1a61c, 0x14ee0, 0x1a778, 0x1d3be, 0x14e70,
+    0x1a73c, 0x14e38, 0x1a71e, 0x14f78, 0x1a7be, 0x14f3c, 0x14f1e, 0x1a2c0,
+    0x1d170, 0x1e8bc, 0x1a260, 0x1d138, 0x1e89e, 0x14440, 0x1a230, 0x1d11c,
+    0x14420, 0x1a218, 0x14410, 0x14408, 0x146c0, 0x1a370, 0x1d1bc, 0x14660,
+    0x1a338, 0x1d19e, 0x14630, 0x1a31c, 0x14618, 0x1460c, 0x14770, 0x1a3bc,
+    0x14738, 0x1a39e, 0x1471c, 0x147bc, 0x1a160, 0x1d0b8, 0x1e85e, 0x14240,
+    0x1a130, 0x1d09c, 0x14220, 0x1a118, 0x1d08e, 0x14210, 0x1a10c, 0x14208,
+    0x1a106, 0x14360, 0x1a1b8, 0x1d0de, 0x14330, 0x1a19c, 0x14318, 0x1a18e,
+    0x1430c, 0x14306, 0x1a1de, 0x1438e, 0x14140, 0x1a0b0, 0x1d05c, 0x14120,
+    0x1a098, 0x1d04e, 0x14110, 0x1a08c, 0x14108, 0x1a086, 0x14104, 0x141b0,
+    0x14198, 0x1418c, 0x140a0, 0x1d02e, 0x1a04c, 0x1a046, 0x14082, 0x1cae0,
+    0x1e578, 0x1f2be, 0x194c0, 0x1ca70, 0x1e53c, 0x19460, 0x1ca38, 0x1e51e,
+    0x12840, 0x19430, 0x12820, 0x196e0, 0x1cb78, 0x1e5be, 0x12cc0, 0x19670,
+    0x1cb3c, 0x12c60, 0x19638, 0x12c30, 0x12c18, 0x12ee0, 0x19778, 0x1cbbe,
+    0x12e70, 0x1973c, 0x12e38, 0x12e1c, 0x12f78, 0x197be, 0x12f3c, 0x12fbe,
+    0x1dac0, 0x1ed70, 0x1f6bc, 0x1da60, 0x1ed38, 0x1f69e, 0x1b440, 0x1da30,
+    0x1ed1c, 0x1b420, 0x1da18, 0x1ed0e, 0x1b410, 0x1da0c, 0x192c0, 0x1c970,
+    0x1e4bc, 0x1b6c0, 0x19260, 0x1c938, 0x1e49e, 0x1b660, 0x1db38, 0x1ed9e,
+    0x16c40, 0x12420, 0x19218, 0x1c90e, 0x16c20, 0x1b618, 0x16c10, 0x126c0,
+    0x19370, 0x1c9bc, 0x16ec0, 0x12660, 0x19338, 0x1c99e, 0x16e60, 0x1b738,
+    0x1db9e, 0x16e30, 0x12618, 0x16e18, 0x12770, 0x193bc, 0x16f70, 0x12738,
+    0x1939e, 0x16f38, 0x1b79e, 0x16f1c, 0x127bc, 0x16fbc, 0x1279e, 0x16f9e,
+    0x1d960, 0x1ecb8, 0x1f65e, 0x1b240, 0x1d930, 0x1ec9c, 0x1b220, 0x1d918,
+    0x1ec8e, 0x1b210, 0x1d90c, 0x1b208, 0x1b204, 0x19160, 0x1c8b8, 0x1e45e,
+    0x1b360, 0x19130, 0x1c89c, 0x16640, 0x12220, 0x1d99c, 0x1c88e, 0x16620,
+    0x12210, 0x1910c, 0x16610, 0x1b30c, 0x19106, 0x12204, 0x12360, 0x191b8,
+    0x1c8de, 0x16760, 0x12330, 0x1919c, 0x16730, 0x1b39c, 0x1918e, 0x16718,
+    0x1230c, 0x12306, 0x123b8, 0x191de, 0x167b8, 0x1239c, 0x1679c, 0x1238e,
+    0x1678e, 0x167de, 0x1b140, 0x1d8b0, 0x1ec5c, 0x1b120, 0x1d898, 0x1ec4e,
+    0x1b110, 0x1d88c, 0x1b108, 0x1d886, 0x1b104, 0x1b102, 0x12140, 0x190b0,
+    0x1c85c, 0x16340, 0x12120, 0x19098, 0x1c84e, 0x16320, 0x1b198, 0x1d8ce,
+    0x16310, 0x12108, 0x19086, 0x16308, 0x1b186, 0x16304, 0x121b0, 0x190dc,
+    0x163b0, 0x12198, 0x190ce, 0x16398, 0x1b1ce, 0x1638c, 0x12186, 0x16386,
+    0x163dc, 0x163ce, 0x1b0a0, 0x1d858, 0x1ec2e, 0x1b090, 0x1d84c, 0x1b088,
+    0x1d846, 0x1b084, 0x1b082, 0x120a0, 0x19058, 0x1c82e, 0x161a0, 0x12090,
+    0x1904c, 0x16190, 0x1b0cc, 0x19046, 0x16188, 0x12084, 0x16184, 0x12082,
+    0x120d8, 0x161d8, 0x161cc, 0x161c6, 0x1d82c, 0x1d826, 0x1b042, 0x1902c,
+    0x12048, 0x160c8, 0x160c4, 0x160c2, 0x18ac0, 0x1c570, 0x1e2bc, 0x18a60,
+    0x1c538, 0x11440, 0x18a30, 0x1c51c, 0x11420, 0x18a18, 0x11410, 0x11408,
+    0x116c0, 0x18b70, 0x1c5bc, 0x11660, 0x18b38, 0x1c59e, 0x11630, 0x18b1c,
+    0x11618, 0x1160c, 0x11770, 0x18bbc, 0x11738, 0x18b9e, 0x1171c, 0x117bc,
+    0x1179e, 0x1cd60, 0x1e6b8, 0x1f35e, 0x19a40, 0x1cd30, 0x1e69c, 0x19a20,
+    0x1cd18, 0x1e68e, 0x19a10, 0x1cd0c, 0x19a08, 0x1cd06, 0x18960, 0x1c4b8,
+    0x1e25e, 0x19b60, 0x18930, 0x1c49c, 0x13640, 0x11220, 0x1cd9c, 0x1c48e,
+    0x13620, 0x19b18, 0x1890c, 0x13610, 0x11208, 0x13608, 0x11360, 0x189b8,
+    0x1c4de, 0x13760, 0x11330, 0x1cdde, 0x13730, 0x19b9c, 0x1898e, 0x13718,
+    0x1130c, 0x1370c, 0x113b8, 0x189de, 0x137b8, 0x1139c, 0x1379c, 0x1138e,
+    0x113de, 0x137de, 0x1dd40, 0x1eeb0, 0x1f75c, 0x1dd20, 0x1ee98, 0x1f74e,
+    0x1dd10, 0x1ee8c, 0x1dd08, 0x1ee86, 0x1dd04, 0x19940, 0x1ccb0, 0x1e65c,
+    0x1bb40, 0x19920, 0x1eedc, 0x1e64e, 0x1bb20, 0x1dd98, 0x1eece, 0x1bb10,
+    0x19908, 0x1cc86, 0x1bb08, 0x1dd86, 0x19902, 0x11140, 0x188b0, 0x1c45c,
+    0x13340, 0x11120, 0x18898, 0x1c44e, 0x17740, 0x13320, 0x19998, 0x1ccce,
+    0x17720, 0x1bb98, 0x1ddce, 0x18886, 0x17710, 0x13308, 0x19986, 0x17708,
+    0x11102, 0x111b0, 0x188dc, 0x133b0, 0x11198, 0x188ce, 0x177b0, 0x13398,
+    0x199ce, 0x17798, 0x1bbce, 0x11186, 0x13386, 0x111dc, 0x133dc, 0x111ce,
+    0x177dc, 0x133ce, 0x1dca0, 0x1ee58, 0x1f72e, 0x1dc90, 0x1ee4c, 0x1dc88,
+    0x1ee46, 0x1dc84, 0x1dc82, 0x198a0, 0x1cc58, 0x1e62e, 0x1b9a0, 0x19890,
+    0x1ee6e, 0x1b990, 0x1dccc, 0x1cc46, 0x1b988, 0x19884, 0x1b984, 0x19882,
+    0x1b982, 0x110a0, 0x18858, 0x1c42e, 0x131a0, 0x11090, 0x1884c, 0x173a0,
+    0x13190, 0x198cc, 0x18846, 0x17390, 0x1b9cc, 0x11084, 0x17388, 0x13184,
+    0x11082, 0x13182, 0x110d8, 0x1886e, 0x131d8, 0x110cc, 0x173d8, 0x131cc,
+    0x110c6, 0x173cc, 0x131c6, 0x110ee, 0x173ee, 0x1dc50, 0x1ee2c, 0x1dc48,
+    0x1ee26, 0x1dc44, 0x1dc42, 0x19850, 0x1cc2c, 0x1b8d0, 0x19848, 0x1cc26,
+    0x1b8c8, 0x1dc66, 0x1b8c4, 0x19842, 0x1b8c2, 0x11050, 0x1882c, 0x130d0,
+    0x11048, 0x18826, 0x171d0, 0x130c8, 0x19866, 0x171c8, 0x1b8e6, 0x11042,
+    0x171c4, 0x130c2, 0x171c2, 0x130ec, 0x171ec, 0x171e6, 0x1ee16, 0x1dc22,
+    0x1cc16, 0x19824, 0x19822, 0x11028, 0x13068, 0x170e8, 0x11022, 0x13062,
+    0x18560, 0x10a40, 0x18530, 0x10a20, 0x18518, 0x1c28e, 0x10a10, 0x1850c,
+    0x10a08, 0x18506, 0x10b60, 0x185b8, 0x1c2de, 0x10b30, 0x1859c, 0x10b18,
+    0x1858e, 0x10b0c, 0x10b06, 0x10bb8, 0x185de, 0x10b9c, 0x10b8e, 0x10bde,
+    0x18d40, 0x1c6b0, 0x1e35c, 0x18d20, 0x1c698, 0x18d10, 0x1c68c, 0x18d08,
+    0x1c686, 0x18d04, 0x10940, 0x184b0, 0x1c25c, 0x11b40, 0x10920, 0x1c6dc,
+    0x1c24e, 0x11b20, 0x18d98, 0x1c6ce, 0x11b10, 0x10908, 0x18486, 0x11b08,
+    0x18d86, 0x10902, 0x109b0, 0x184dc, 0x11bb0, 0x10998, 0x184ce, 0x11b98,
+    0x18dce, 0x11b8c, 0x10986, 0x109dc, 0x11bdc, 0x109ce, 0x11bce, 0x1cea0,
+    0x1e758, 0x1f3ae, 0x1ce90, 0x1e74c, 0x1ce88, 0x1e746, 0x1ce84, 0x1ce82,
+    0x18ca0, 0x1c658, 0x19da0, 0x18c90, 0x1c64c, 0x19d90, 0x1cecc, 0x1c646,
+    0x19d88, 0x18c84, 0x19d84, 0x18c82, 0x19d82, 0x108a0, 0x18458, 0x119a0,
+    0x10890, 0x1c66e, 0x13ba0, 0x11990, 0x18ccc, 0x18446, 0x13b90, 0x19dcc,
+    0x10884, 0x13b88, 0x11984, 0x10882, 0x11982, 0x108d8, 0x1846e, 0x119d8,
+    0x108cc, 0x13bd8, 0x119cc, 0x108c6, 0x13bcc, 0x119c6, 0x108ee, 0x119ee,
+    0x13bee, 0x1ef50, 0x1f7ac, 0x1ef48, 0x1f7a6, 0x1ef44, 0x1ef42, 0x1ce50,
+    0x1e72c, 0x1ded0, 0x1ef6c, 0x1e726, 0x1dec8, 0x1ef66, 0x1dec4, 0x1ce42,
+    0x1dec2, 0x18c50, 0x1c62c, 0x19cd0, 0x18c48, 0x1c626, 0x1bdd0, 0x19cc8,
+    0x1ce66, 0x1bdc8, 0x1dee6, 0x18c42, 0x1bdc4, 0x19cc2, 0x1bdc2, 0x10850,
+    0x1842c, 0x118d0, 0x10848, 0x18426, 0x139d0, 0x118c8, 0x18c66, 0x17bd0,
+    0x139c8, 0x19ce6, 0x10842, 0x17bc8, 0x1bde6, 0x118c2, 0x17bc4, 0x1086c,
+    0x118ec, 0x10866, 0x139ec, 0x118e6, 0x17bec, 0x139e6, 0x17be6, 0x1ef28,
+    0x1f796, 0x1ef24, 0x1ef22, 0x1ce28, 0x1e716, 0x1de68, 0x1ef36, 0x1de64,
+    0x1ce22, 0x1de62, 0x18c28, 0x1c616, 0x19c68, 0x18c24, 0x1bce8, 0x19c64,
+    0x18c22, 0x1bce4, 0x19c62, 0x1bce2, 0x10828, 0x18416, 0x11868, 0x18c36,
+    0x138e8, 0x11864, 0x10822, 0x179e8, 0x138e4, 0x11862, 0x179e4, 0x138e2,
+    0x179e2, 0x11876, 0x179f6, 0x1ef12, 0x1de34, 0x1de32, 0x19c34, 0x1bc74,
+    0x1bc72, 0x11834, 0x13874, 0x178f4, 0x178f2, 0x10540, 0x10520, 0x18298,
+    0x10510, 0x10508, 0x10504, 0x105b0, 0x10598, 0x1058c, 0x10586, 0x105dc,
+    0x105ce, 0x186a0, 0x18690, 0x1c34c, 0x18688, 0x1c346, 0x18684, 0x18682,
+    0x104a0, 0x18258, 0x10da0, 0x186d8, 0x1824c, 0x10d90, 0x186cc, 0x10d88,
+    0x186c6, 0x10d84, 0x10482, 0x10d82, 0x104d8, 0x1826e, 0x10dd8, 0x186ee,
+    0x10dcc, 0x104c6, 0x10dc6, 0x104ee, 0x10dee, 0x1c750, 0x1c748, 0x1c744,
+    0x1c742, 0x18650, 0x18ed0, 0x1c76c, 0x1c326, 0x18ec8, 0x1c766, 0x18ec4,
+    0x18642, 0x18ec2, 0x10450, 0x10cd0, 0x10448, 0x18226, 0x11dd0, 0x10cc8,
+    0x10444, 0x11dc8, 0x10cc4, 0x10442, 0x11dc4, 0x10cc2, 0x1046c, 0x10cec,
+    0x10466, 0x11dec, 0x10ce6, 0x11de6, 0x1e7a8, 0x1e7a4, 0x1e7a2, 0x1c728,
+    0x1cf68, 0x1e7b6, 0x1cf64, 0x1c722, 0x1cf62, 0x18628, 0x1c316, 0x18e68,
+    0x1c736, 0x19ee8, 0x18e64, 0x18622, 0x19ee4, 0x18e62, 0x19ee2, 0x10428,
+    0x18216, 0x10c68, 0x18636, 0x11ce8, 0x10c64, 0x10422, 0x13de8, 0x11ce4,
+    0x10c62, 0x13de4, 0x11ce2, 0x10436, 0x10c76, 0x11cf6, 0x13df6, 0x1f7d4,
+    0x1f7d2, 0x1e794, 0x1efb4, 0x1e792, 0x1efb2, 0x1c714, 0x1cf34, 0x1c712,
+    0x1df74, 0x1cf32, 0x1df72, 0x18614, 0x18e34, 0x18612, 0x19e74, 0x18e32,
+    0x1bef4
+}, {
+    0x1f560, 0x1fab8, 0x1ea40, 0x1f530, 0x1fa9c, 0x1ea20, 0x1f518, 0x1fa8e,
+    0x1ea10, 0x1f50c, 0x1ea08, 0x1f506, 0x1ea04, 0x1eb60, 0x1f5b8, 0x1fade,
+    0x1d640, 0x1eb30, 0x1f59c, 0x1d620, 0x1eb18, 0x1f58e, 0x1d610, 0x1eb0c,
+    0x1d608, 0x1eb06, 0x1d604, 0x1d760, 0x1ebb8, 0x1f5de, 0x1ae40, 0x1d730,
+    0x1eb9c, 0x1ae20, 0x1d718, 0x1eb8e, 0x1ae10, 0x1d70c, 0x1ae08, 0x1d706,
+    0x1ae04, 0x1af60, 0x1d7b8, 0x1ebde, 0x15e40, 0x1af30, 0x1d79c, 0x15e20,
+    0x1af18, 0x1d78e, 0x15e10, 0x1af0c, 0x15e08, 0x1af06, 0x15f60, 0x1afb8,
+    0x1d7de, 0x15f30, 0x1af9c, 0x15f18, 0x1af8e, 0x15f0c, 0x15fb8, 0x1afde,
+    0x15f9c, 0x15f8e, 0x1e940, 0x1f4b0, 0x1fa5c, 0x1e920, 0x1f498, 0x1fa4e,
+    0x1e910, 0x1f48c, 0x1e908, 0x1f486, 0x1e904, 0x1e902, 0x1d340, 0x1e9b0,
+    0x1f4dc, 0x1d320, 0x1e998, 0x1f4ce, 0x1d310, 0x1e98c, 0x1d308, 0x1e986,
+    0x1d304, 0x1d302, 0x1a740, 0x1d3b0, 0x1e9dc, 0x1a720, 0x1d398, 0x1e9ce,
+    0x1a710, 0x1d38c, 0x1a708, 0x1d386, 0x1a704, 0x1a702, 0x14f40, 0x1a7b0,
+    0x1d3dc, 0x14f20, 0x1a798, 0x1d3ce, 0x14f10, 0x1a78c, 0x14f08, 0x1a786,
+    0x14f04, 0x14fb0, 0x1a7dc, 0x14f98, 0x1a7ce, 0x14f8c, 0x14f86, 0x14fdc,
+    0x14fce, 0x1e8a0, 0x1f458, 0x1fa2e, 0x1e890, 0x1f44c, 0x1e888, 0x1f446,
+    0x1e884, 0x1e882, 0x1d1a0, 0x1e8d8, 0x1f46e, 0x1d190, 0x1e8cc, 0x1d188,
+    0x1e8c6, 0x1d184, 0x1d182, 0x1a3a0, 0x1d1d8, 0x1e8ee, 0x1a390, 0x1d1cc,
+    0x1a388, 0x1d1c6, 0x1a384, 0x1a382, 0x147a0, 0x1a3d8, 0x1d1ee, 0x14790,
+    0x1a3cc, 0x14788, 0x1a3c6, 0x14784, 0x14782, 0x147d8, 0x1a3ee, 0x147cc,
+    0x147c6, 0x147ee, 0x1e850, 0x1f42c, 0x1e848, 0x1f426, 0x1e844, 0x1e842,
+    0x1d0d0, 0x1e86c, 0x1d0c8, 0x1e866, 0x1d0c4, 0x1d0c2, 0x1a1d0, 0x1d0ec,
+    0x1a1c8, 0x1d0e6, 0x1a1c4, 0x1a1c2, 0x143d0, 0x1a1ec, 0x143c8, 0x1a1e6,
+    0x143c4, 0x143c2, 0x143ec, 0x143e6, 0x1e828, 0x1f416, 0x1e824, 0x1e822,
+    0x1d068, 0x1e836, 0x1d064, 0x1d062, 0x1a0e8, 0x1d076, 0x1a0e4, 0x1a0e2,
+    0x141e8, 0x1a0f6, 0x141e4, 0x141e2, 0x1e814, 0x1e812, 0x1d034, 0x1d032,
+    0x1a074, 0x1a072, 0x1e540, 0x1f2b0, 0x1f95c, 0x1e520, 0x1f298, 0x1f94e,
+    0x1e510, 0x1f28c, 0x1e508, 0x1f286, 0x1e504, 0x1e502, 0x1cb40, 0x1e5b0,
+    0x1f2dc, 0x1cb20, 0x1e598, 0x1f2ce, 0x1cb10, 0x1e58c, 0x1cb08, 0x1e586,
+    0x1cb04, 0x1cb02, 0x19740, 0x1cbb0, 0x1e5dc, 0x19720, 0x1cb98, 0x1e5ce,
+    0x19710, 0x1cb8c, 0x19708, 0x1cb86, 0x19704, 0x19702, 0x12f40, 0x197b0,
+    0x1cbdc, 0x12f20, 0x19798, 0x1cbce, 0x12f10, 0x1978c, 0x12f08, 0x19786,
+    0x12f04, 0x12fb0, 0x197dc, 0x12f98, 0x197ce, 0x12f8c, 0x12f86, 0x12fdc,
+    0x12fce, 0x1f6a0, 0x1fb58, 0x16bf0, 0x1f690, 0x1fb4c, 0x169f8, 0x1f688,
+    0x1fb46, 0x168fc, 0x1f684, 0x1f682, 0x1e4a0, 0x1f258, 0x1f92e, 0x1eda0,
+    0x1e490, 0x1fb6e, 0x1ed90, 0x1f6cc, 0x1f246, 0x1ed88, 0x1e484, 0x1ed84,
+    0x1e482, 0x1ed82, 0x1c9a0, 0x1e4d8, 0x1f26e, 0x1dba0, 0x1c990, 0x1e4cc,
+    0x1db90, 0x1edcc, 0x1e4c6, 0x1db88, 0x1c984, 0x1db84, 0x1c982, 0x1db82,
+    0x193a0, 0x1c9d8, 0x1e4ee, 0x1b7a0, 0x19390, 0x1c9cc, 0x1b790, 0x1dbcc,
+    0x1c9c6, 0x1b788, 0x19384, 0x1b784, 0x19382, 0x1b782, 0x127a0, 0x193d8,
+    0x1c9ee, 0x16fa0, 0x12790, 0x193cc, 0x16f90, 0x1b7cc, 0x193c6, 0x16f88,
+    0x12784, 0x16f84, 0x12782, 0x127d8, 0x193ee, 0x16fd8, 0x127cc, 0x16fcc,
+    0x127c6, 0x16fc6, 0x127ee, 0x1f650, 0x1fb2c, 0x165f8, 0x1f648, 0x1fb26,
+    0x164fc, 0x1f644, 0x1647e, 0x1f642, 0x1e450, 0x1f22c, 0x1ecd0, 0x1e448,
+    0x1f226, 0x1ecc8, 0x1f666, 0x1ecc4, 0x1e442, 0x1ecc2, 0x1c8d0, 0x1e46c,
+    0x1d9d0, 0x1c8c8, 0x1e466, 0x1d9c8, 0x1ece6, 0x1d9c4, 0x1c8c2, 0x1d9c2,
+    0x191d0, 0x1c8ec, 0x1b3d0, 0x191c8, 0x1c8e6, 0x1b3c8, 0x1d9e6, 0x1b3c4,
+    0x191c2, 0x1b3c2, 0x123d0, 0x191ec, 0x167d0, 0x123c8, 0x191e6, 0x167c8,
+    0x1b3e6, 0x167c4, 0x123c2, 0x167c2, 0x123ec, 0x167ec, 0x123e6, 0x167e6,
+    0x1f628, 0x1fb16, 0x162fc, 0x1f624, 0x1627e, 0x1f622, 0x1e428, 0x1f216,
+    0x1ec68, 0x1f636, 0x1ec64, 0x1e422, 0x1ec62, 0x1c868, 0x1e436, 0x1d8e8,
+    0x1c864, 0x1d8e4, 0x1c862, 0x1d8e2, 0x190e8, 0x1c876, 0x1b1e8, 0x1d8f6,
+    0x1b1e4, 0x190e2, 0x1b1e2, 0x121e8, 0x190f6, 0x163e8, 0x121e4, 0x163e4,
+    0x121e2, 0x163e2, 0x121f6, 0x163f6, 0x1f614, 0x1617e, 0x1f612, 0x1e414,
+    0x1ec34, 0x1e412, 0x1ec32, 0x1c834, 0x1d874, 0x1c832, 0x1d872, 0x19074,
+    0x1b0f4, 0x19072, 0x1b0f2, 0x120f4, 0x161f4, 0x120f2, 0x161f2, 0x1f60a,
+    0x1e40a, 0x1ec1a, 0x1c81a, 0x1d83a, 0x1903a, 0x1b07a, 0x1e2a0, 0x1f158,
+    0x1f8ae, 0x1e290, 0x1f14c, 0x1e288, 0x1f146, 0x1e284, 0x1e282, 0x1c5a0,
+    0x1e2d8, 0x1f16e, 0x1c590, 0x1e2cc, 0x1c588, 0x1e2c6, 0x1c584, 0x1c582,
+    0x18ba0, 0x1c5d8, 0x1e2ee, 0x18b90, 0x1c5cc, 0x18b88, 0x1c5c6, 0x18b84,
+    0x18b82, 0x117a0, 0x18bd8, 0x1c5ee, 0x11790, 0x18bcc, 0x11788, 0x18bc6,
+    0x11784, 0x11782, 0x117d8, 0x18bee, 0x117cc, 0x117c6, 0x117ee, 0x1f350,
+    0x1f9ac, 0x135f8, 0x1f348, 0x1f9a6, 0x134fc, 0x1f344, 0x1347e, 0x1f342,
+    0x1e250, 0x1f12c, 0x1e6d0, 0x1e248, 0x1f126, 0x1e6c8, 0x1f366, 0x1e6c4,
+    0x1e242, 0x1e6c2, 0x1c4d0, 0x1e26c, 0x1cdd0, 0x1c4c8, 0x1e266, 0x1cdc8,
+    0x1e6e6, 0x1cdc4, 0x1c4c2, 0x1cdc2, 0x189d0, 0x1c4ec, 0x19bd0, 0x189c8,
+    0x1c4e6, 0x19bc8, 0x1cde6, 0x19bc4, 0x189c2, 0x19bc2, 0x113d0, 0x189ec,
+    0x137d0, 0x113c8, 0x189e6, 0x137c8, 0x19be6, 0x137c4, 0x113c2, 0x137c2,
+    0x113ec, 0x137ec, 0x113e6, 0x137e6, 0x1fba8, 0x175f0, 0x1bafc, 0x1fba4,
+    0x174f8, 0x1ba7e, 0x1fba2, 0x1747c, 0x1743e, 0x1f328, 0x1f996, 0x132fc,
+    0x1f768, 0x1fbb6, 0x176fc, 0x1327e, 0x1f764, 0x1f322, 0x1767e, 0x1f762,
+    0x1e228, 0x1f116, 0x1e668, 0x1e224, 0x1eee8, 0x1f776, 0x1e222, 0x1eee4,
+    0x1e662, 0x1eee2, 0x1c468, 0x1e236, 0x1cce8, 0x1c464, 0x1dde8, 0x1cce4,
+    0x1c462, 0x1dde4, 0x1cce2, 0x1dde2, 0x188e8, 0x1c476, 0x199e8, 0x188e4,
+    0x1bbe8, 0x199e4, 0x188e2, 0x1bbe4, 0x199e2, 0x1bbe2, 0x111e8, 0x188f6,
+    0x133e8, 0x111e4, 0x177e8, 0x133e4, 0x111e2, 0x177e4, 0x133e2, 0x177e2,
+    0x111f6, 0x133f6, 0x1fb94, 0x172f8, 0x1b97e, 0x1fb92, 0x1727c, 0x1723e,
+    0x1f314, 0x1317e, 0x1f734, 0x1f312, 0x1737e, 0x1f732, 0x1e214, 0x1e634,
+    0x1e212, 0x1ee74, 0x1e632, 0x1ee72, 0x1c434, 0x1cc74, 0x1c432, 0x1dcf4,
+    0x1cc72, 0x1dcf2, 0x18874, 0x198f4, 0x18872, 0x1b9f4, 0x198f2, 0x1b9f2,
+    0x110f4, 0x131f4, 0x110f2, 0x173f4, 0x131f2, 0x173f2, 0x1fb8a, 0x1717c,
+    0x1713e, 0x1f30a, 0x1f71a, 0x1e20a, 0x1e61a, 0x1ee3a, 0x1c41a, 0x1cc3a,
+    0x1dc7a, 0x1883a, 0x1987a, 0x1b8fa, 0x1107a, 0x130fa, 0x171fa, 0x170be,
+    0x1e150, 0x1f0ac, 0x1e148, 0x1f0a6, 0x1e144, 0x1e142, 0x1c2d0, 0x1e16c,
+    0x1c2c8, 0x1e166, 0x1c2c4, 0x1c2c2, 0x185d0, 0x1c2ec, 0x185c8, 0x1c2e6,
+    0x185c4, 0x185c2, 0x10bd0, 0x185ec, 0x10bc8, 0x185e6, 0x10bc4, 0x10bc2,
+    0x10bec, 0x10be6, 0x1f1a8, 0x1f8d6, 0x11afc, 0x1f1a4, 0x11a7e, 0x1f1a2,
+    0x1e128, 0x1f096, 0x1e368, 0x1e124, 0x1e364, 0x1e122, 0x1e362, 0x1c268,
+    0x1e136, 0x1c6e8, 0x1c264, 0x1c6e4, 0x1c262, 0x1c6e2, 0x184e8, 0x1c276,
+    0x18de8, 0x184e4, 0x18de4, 0x184e2, 0x18de2, 0x109e8, 0x184f6, 0x11be8,
+    0x109e4, 0x11be4, 0x109e2, 0x11be2, 0x109f6, 0x11bf6, 0x1f9d4, 0x13af8,
+    0x19d7e, 0x1f9d2, 0x13a7c, 0x13a3e, 0x1f194, 0x1197e, 0x1f3b4, 0x1f192,
+    0x13b7e, 0x1f3b2, 0x1e114, 0x1e334, 0x1e112, 0x1e774, 0x1e332, 0x1e772,
+    0x1c234, 0x1c674, 0x1c232, 0x1cef4, 0x1c672, 0x1cef2, 0x18474, 0x18cf4,
+    0x18472, 0x19df4, 0x18cf2, 0x19df2, 0x108f4, 0x119f4, 0x108f2, 0x13bf4,
+    0x119f2, 0x13bf2, 0x17af0, 0x1bd7c, 0x17a78, 0x1bd3e, 0x17a3c, 0x17a1e,
+    0x1f9ca, 0x1397c, 0x1fbda, 0x17b7c, 0x1393e, 0x17b3e, 0x1f18a, 0x1f39a,
+    0x1f7ba, 0x1e10a, 0x1e31a, 0x1e73a, 0x1ef7a, 0x1c21a, 0x1c63a, 0x1ce7a,
+    0x1defa, 0x1843a, 0x18c7a, 0x19cfa, 0x1bdfa, 0x1087a, 0x118fa, 0x139fa,
+    0x17978, 0x1bcbe, 0x1793c, 0x1791e, 0x138be, 0x179be, 0x178bc, 0x1789e,
+    0x1785e, 0x1e0a8, 0x1e0a4, 0x1e0a2, 0x1c168, 0x1e0b6, 0x1c164, 0x1c162,
+    0x182e8, 0x1c176, 0x182e4, 0x182e2, 0x105e8, 0x182f6, 0x105e4, 0x105e2,
+    0x105f6, 0x1f0d4, 0x10d7e, 0x1f0d2, 0x1e094, 0x1e1b4, 0x1e092, 0x1e1b2,
+    0x1c134, 0x1c374, 0x1c132, 0x1c372, 0x18274, 0x186f4, 0x18272, 0x186f2,
+    0x104f4, 0x10df4, 0x104f2, 0x10df2, 0x1f8ea, 0x11d7c, 0x11d3e, 0x1f0ca,
+    0x1f1da, 0x1e08a, 0x1e19a, 0x1e3ba, 0x1c11a, 0x1c33a, 0x1c77a, 0x1823a,
+    0x1867a, 0x18efa, 0x1047a, 0x10cfa, 0x11dfa, 0x13d78, 0x19ebe, 0x13d3c,
+    0x13d1e, 0x11cbe, 0x13dbe, 0x17d70, 0x1bebc, 0x17d38, 0x1be9e, 0x17d1c,
+    0x17d0e, 0x13cbc, 0x17dbc, 0x13c9e, 0x17d9e, 0x17cb8, 0x1be5e, 0x17c9c,
+    0x17c8e, 0x13c5e, 0x17cde, 0x17c5c, 0x17c4e, 0x17c2e, 0x1c0b4, 0x1c0b2,
+    0x18174, 0x18172, 0x102f4, 0x102f2, 0x1e0da, 0x1c09a, 0x1c1ba, 0x1813a,
+    0x1837a, 0x1027a, 0x106fa, 0x10ebe, 0x11ebc, 0x11e9e, 0x13eb8, 0x19f5e,
+    0x13e9c, 0x13e8e, 0x11e5e, 0x13ede, 0x17eb0, 0x1bf5c, 0x17e98, 0x1bf4e,
+    0x17e8c, 0x17e86, 0x13e5c, 0x17edc, 0x13e4e, 0x17ece, 0x17e58, 0x1bf2e,
+    0x17e4c, 0x17e46, 0x13e2e, 0x17e6e, 0x17e2c, 0x17e26, 0x10f5e, 0x11f5c,
+    0x11f4e, 0x13f58, 0x19fae, 0x13f4c, 0x13f46, 0x11f2e, 0x13f6e, 0x13f2c,
+    0x13f26
+}, {
+    0x1abe0, 0x1d5f8, 0x153c0, 0x1a9f0, 0x1d4fc, 0x151e0, 0x1a8f8, 0x1d47e,
+    0x150f0, 0x1a87c, 0x15078, 0x1fad0, 0x15be0, 0x1adf8, 0x1fac8, 0x159f0,
+    0x1acfc, 0x1fac4, 0x158f8, 0x1ac7e, 0x1fac2, 0x1587c, 0x1f5d0, 0x1faec,
+    0x15df8, 0x1f5c8, 0x1fae6, 0x15cfc, 0x1f5c4, 0x15c7e, 0x1f5c2, 0x1ebd0,
+    0x1f5ec, 0x1ebc8, 0x1f5e6, 0x1ebc4, 0x1ebc2, 0x1d7d0, 0x1ebec, 0x1d7c8,
+    0x1ebe6, 0x1d7c4, 0x1d7c2, 0x1afd0, 0x1d7ec, 0x1afc8, 0x1d7e6, 0x1afc4,
+    0x14bc0, 0x1a5f0, 0x1d2fc, 0x149e0, 0x1a4f8, 0x1d27e, 0x148f0, 0x1a47c,
+    0x14878, 0x1a43e, 0x1483c, 0x1fa68, 0x14df0, 0x1a6fc, 0x1fa64, 0x14cf8,
+    0x1a67e, 0x1fa62, 0x14c7c, 0x14c3e, 0x1f4e8, 0x1fa76, 0x14efc, 0x1f4e4,
+    0x14e7e, 0x1f4e2, 0x1e9e8, 0x1f4f6, 0x1e9e4, 0x1e9e2, 0x1d3e8, 0x1e9f6,
+    0x1d3e4, 0x1d3e2, 0x1a7e8, 0x1d3f6, 0x1a7e4, 0x1a7e2, 0x145e0, 0x1a2f8,
+    0x1d17e, 0x144f0, 0x1a27c, 0x14478, 0x1a23e, 0x1443c, 0x1441e, 0x1fa34,
+    0x146f8, 0x1a37e, 0x1fa32, 0x1467c, 0x1463e, 0x1f474, 0x1477e, 0x1f472,
+    0x1e8f4, 0x1e8f2, 0x1d1f4, 0x1d1f2, 0x1a3f4, 0x1a3f2, 0x142f0, 0x1a17c,
+    0x14278, 0x1a13e, 0x1423c, 0x1421e, 0x1fa1a, 0x1437c, 0x1433e, 0x1f43a,
+    0x1e87a, 0x1d0fa, 0x14178, 0x1a0be, 0x1413c, 0x1411e, 0x141be, 0x140bc,
+    0x1409e, 0x12bc0, 0x195f0, 0x1cafc, 0x129e0, 0x194f8, 0x1ca7e, 0x128f0,
+    0x1947c, 0x12878, 0x1943e, 0x1283c, 0x1f968, 0x12df0, 0x196fc, 0x1f964,
+    0x12cf8, 0x1967e, 0x1f962, 0x12c7c, 0x12c3e, 0x1f2e8, 0x1f976, 0x12efc,
+    0x1f2e4, 0x12e7e, 0x1f2e2, 0x1e5e8, 0x1f2f6, 0x1e5e4, 0x1e5e2, 0x1cbe8,
+    0x1e5f6, 0x1cbe4, 0x1cbe2, 0x197e8, 0x1cbf6, 0x197e4, 0x197e2, 0x1b5e0,
+    0x1daf8, 0x1ed7e, 0x169c0, 0x1b4f0, 0x1da7c, 0x168e0, 0x1b478, 0x1da3e,
+    0x16870, 0x1b43c, 0x16838, 0x1b41e, 0x1681c, 0x125e0, 0x192f8, 0x1c97e,
+    0x16de0, 0x124f0, 0x1927c, 0x16cf0, 0x1b67c, 0x1923e, 0x16c78, 0x1243c,
+    0x16c3c, 0x1241e, 0x16c1e, 0x1f934, 0x126f8, 0x1937e, 0x1fb74, 0x1f932,
+    0x16ef8, 0x1267c, 0x1fb72, 0x16e7c, 0x1263e, 0x16e3e, 0x1f274, 0x1277e,
+    0x1f6f4, 0x1f272, 0x16f7e, 0x1f6f2, 0x1e4f4, 0x1edf4, 0x1e4f2, 0x1edf2,
+    0x1c9f4, 0x1dbf4, 0x1c9f2, 0x1dbf2, 0x193f4, 0x193f2, 0x165c0, 0x1b2f0,
+    0x1d97c, 0x164e0, 0x1b278, 0x1d93e, 0x16470, 0x1b23c, 0x16438, 0x1b21e,
+    0x1641c, 0x1640e, 0x122f0, 0x1917c, 0x166f0, 0x12278, 0x1913e, 0x16678,
+    0x1b33e, 0x1663c, 0x1221e, 0x1661e, 0x1f91a, 0x1237c, 0x1fb3a, 0x1677c,
+    0x1233e, 0x1673e, 0x1f23a, 0x1f67a, 0x1e47a, 0x1ecfa, 0x1c8fa, 0x1d9fa,
+    0x191fa, 0x162e0, 0x1b178, 0x1d8be, 0x16270, 0x1b13c, 0x16238, 0x1b11e,
+    0x1621c, 0x1620e, 0x12178, 0x190be, 0x16378, 0x1213c, 0x1633c, 0x1211e,
+    0x1631e, 0x121be, 0x163be, 0x16170, 0x1b0bc, 0x16138, 0x1b09e, 0x1611c,
+    0x1610e, 0x120bc, 0x161bc, 0x1209e, 0x1619e, 0x160b8, 0x1b05e, 0x1609c,
+    0x1608e, 0x1205e, 0x160de, 0x1605c, 0x1604e, 0x115e0, 0x18af8, 0x1c57e,
+    0x114f0, 0x18a7c, 0x11478, 0x18a3e, 0x1143c, 0x1141e, 0x1f8b4, 0x116f8,
+    0x18b7e, 0x1f8b2, 0x1167c, 0x1163e, 0x1f174, 0x1177e, 0x1f172, 0x1e2f4,
+    0x1e2f2, 0x1c5f4, 0x1c5f2, 0x18bf4, 0x18bf2, 0x135c0, 0x19af0, 0x1cd7c,
+    0x134e0, 0x19a78, 0x1cd3e, 0x13470, 0x19a3c, 0x13438, 0x19a1e, 0x1341c,
+    0x1340e, 0x112f0, 0x1897c, 0x136f0, 0x11278, 0x1893e, 0x13678, 0x19b3e,
+    0x1363c, 0x1121e, 0x1361e, 0x1f89a, 0x1137c, 0x1f9ba, 0x1377c, 0x1133e,
+    0x1373e, 0x1f13a, 0x1f37a, 0x1e27a, 0x1e6fa, 0x1c4fa, 0x1cdfa, 0x189fa,
+    0x1bae0, 0x1dd78, 0x1eebe, 0x174c0, 0x1ba70, 0x1dd3c, 0x17460, 0x1ba38,
+    0x1dd1e, 0x17430, 0x1ba1c, 0x17418, 0x1ba0e, 0x1740c, 0x132e0, 0x19978,
+    0x1ccbe, 0x176e0, 0x13270, 0x1993c, 0x17670, 0x1bb3c, 0x1991e, 0x17638,
+    0x1321c, 0x1761c, 0x1320e, 0x1760e, 0x11178, 0x188be, 0x13378, 0x1113c,
+    0x17778, 0x1333c, 0x1111e, 0x1773c, 0x1331e, 0x1771e, 0x111be, 0x133be,
+    0x177be, 0x172c0, 0x1b970, 0x1dcbc, 0x17260, 0x1b938, 0x1dc9e, 0x17230,
+    0x1b91c, 0x17218, 0x1b90e, 0x1720c, 0x17206, 0x13170, 0x198bc, 0x17370,
+    0x13138, 0x1989e, 0x17338, 0x1b99e, 0x1731c, 0x1310e, 0x1730e, 0x110bc,
+    0x131bc, 0x1109e, 0x173bc, 0x1319e, 0x1739e, 0x17160, 0x1b8b8, 0x1dc5e,
+    0x17130, 0x1b89c, 0x17118, 0x1b88e, 0x1710c, 0x17106, 0x130b8, 0x1985e,
+    0x171b8, 0x1309c, 0x1719c, 0x1308e, 0x1718e, 0x1105e, 0x130de, 0x171de,
+    0x170b0, 0x1b85c, 0x17098, 0x1b84e, 0x1708c, 0x17086, 0x1305c, 0x170dc,
+    0x1304e, 0x170ce, 0x17058, 0x1b82e, 0x1704c, 0x17046, 0x1302e, 0x1706e,
+    0x1702c, 0x17026, 0x10af0, 0x1857c, 0x10a78, 0x1853e, 0x10a3c, 0x10a1e,
+    0x10b7c, 0x10b3e, 0x1f0ba, 0x1e17a, 0x1c2fa, 0x185fa, 0x11ae0, 0x18d78,
+    0x1c6be, 0x11a70, 0x18d3c, 0x11a38, 0x18d1e, 0x11a1c, 0x11a0e, 0x10978,
+    0x184be, 0x11b78, 0x1093c, 0x11b3c, 0x1091e, 0x11b1e, 0x109be, 0x11bbe,
+    0x13ac0, 0x19d70, 0x1cebc, 0x13a60, 0x19d38, 0x1ce9e, 0x13a30, 0x19d1c,
+    0x13a18, 0x19d0e, 0x13a0c, 0x13a06, 0x11970, 0x18cbc, 0x13b70, 0x11938,
+    0x18c9e, 0x13b38, 0x1191c, 0x13b1c, 0x1190e, 0x13b0e, 0x108bc, 0x119bc,
+    0x1089e, 0x13bbc, 0x1199e, 0x13b9e, 0x1bd60, 0x1deb8, 0x1ef5e, 0x17a40,
+    0x1bd30, 0x1de9c, 0x17a20, 0x1bd18, 0x1de8e, 0x17a10, 0x1bd0c, 0x17a08,
+    0x1bd06, 0x17a04, 0x13960, 0x19cb8, 0x1ce5e, 0x17b60, 0x13930, 0x19c9c,
+    0x17b30, 0x1bd9c, 0x19c8e, 0x17b18, 0x1390c, 0x17b0c, 0x13906, 0x17b06,
+    0x118b8, 0x18c5e, 0x139b8, 0x1189c, 0x17bb8, 0x1399c, 0x1188e, 0x17b9c,
+    0x1398e, 0x17b8e, 0x1085e, 0x118de, 0x139de, 0x17bde, 0x17940, 0x1bcb0,
+    0x1de5c, 0x17920, 0x1bc98, 0x1de4e, 0x17910, 0x1bc8c, 0x17908, 0x1bc86,
+    0x17904, 0x17902, 0x138b0, 0x19c5c, 0x179b0, 0x13898, 0x19c4e, 0x17998,
+    0x1bcce, 0x1798c, 0x13886, 0x17986, 0x1185c, 0x138dc, 0x1184e, 0x179dc,
+    0x138ce, 0x179ce, 0x178a0, 0x1bc58, 0x1de2e, 0x17890, 0x1bc4c, 0x17888,
+    0x1bc46, 0x17884, 0x17882, 0x13858, 0x19c2e, 0x178d8, 0x1384c, 0x178cc,
+    0x13846, 0x178c6, 0x1182e, 0x1386e, 0x178ee, 0x17850, 0x1bc2c, 0x17848,
+    0x1bc26, 0x17844, 0x17842, 0x1382c, 0x1786c, 0x13826, 0x17866, 0x17828,
+    0x1bc16, 0x17824, 0x17822, 0x13816, 0x17836, 0x10578, 0x182be, 0x1053c,
+    0x1051e, 0x105be, 0x10d70, 0x186bc, 0x10d38, 0x1869e, 0x10d1c, 0x10d0e,
+    0x104bc, 0x10dbc, 0x1049e, 0x10d9e, 0x11d60, 0x18eb8, 0x1c75e, 0x11d30,
+    0x18e9c, 0x11d18, 0x18e8e, 0x11d0c, 0x11d06, 0x10cb8, 0x1865e, 0x11db8,
+    0x10c9c, 0x11d9c, 0x10c8e, 0x11d8e, 0x1045e, 0x10cde, 0x11dde, 0x13d40,
+    0x19eb0, 0x1cf5c, 0x13d20, 0x19e98, 0x1cf4e, 0x13d10, 0x19e8c, 0x13d08,
+    0x19e86, 0x13d04, 0x13d02, 0x11cb0, 0x18e5c, 0x13db0, 0x11c98, 0x18e4e,
+    0x13d98, 0x19ece, 0x13d8c, 0x11c86, 0x13d86, 0x10c5c, 0x11cdc, 0x10c4e,
+    0x13ddc, 0x11cce, 0x13dce, 0x1bea0, 0x1df58, 0x1efae, 0x1be90, 0x1df4c,
+    0x1be88, 0x1df46, 0x1be84, 0x1be82, 0x13ca0, 0x19e58, 0x1cf2e, 0x17da0,
+    0x13c90, 0x19e4c, 0x17d90, 0x1becc, 0x19e46, 0x17d88, 0x13c84, 0x17d84,
+    0x13c82, 0x17d82, 0x11c58, 0x18e2e, 0x13cd8, 0x11c4c, 0x17dd8, 0x13ccc,
+    0x11c46, 0x17dcc, 0x13cc6, 0x17dc6, 0x10c2e, 0x11c6e, 0x13cee, 0x17dee,
+    0x1be50, 0x1df2c, 0x1be48, 0x1df26, 0x1be44, 0x1be42, 0x13c50, 0x19e2c,
+    0x17cd0, 0x13c48, 0x19e26, 0x17cc8, 0x1be66, 0x17cc4, 0x13c42, 0x17cc2,
+    0x11c2c, 0x13c6c, 0x11c26, 0x17cec, 0x13c66, 0x17ce6, 0x1be28, 0x1df16,
+    0x1be24, 0x1be22, 0x13c28, 0x19e16, 0x17c68, 0x13c24, 0x17c64, 0x13c22,
+    0x17c62, 0x11c16, 0x13c36, 0x17c76, 0x1be14, 0x1be12, 0x13c14, 0x17c34,
+    0x13c12, 0x17c32, 0x102bc, 0x1029e, 0x106b8, 0x1835e, 0x1069c, 0x1068e,
+    0x1025e, 0x106de, 0x10eb0, 0x1875c, 0x10e98, 0x1874e, 0x10e8c, 0x10e86,
+    0x1065c, 0x10edc, 0x1064e, 0x10ece, 0x11ea0, 0x18f58, 0x1c7ae, 0x11e90,
+    0x18f4c, 0x11e88, 0x18f46, 0x11e84, 0x11e82, 0x10e58, 0x1872e, 0x11ed8,
+    0x18f6e, 0x11ecc, 0x10e46, 0x11ec6, 0x1062e, 0x10e6e, 0x11eee, 0x19f50,
+    0x1cfac, 0x19f48, 0x1cfa6, 0x19f44, 0x19f42, 0x11e50, 0x18f2c, 0x13ed0,
+    0x19f6c, 0x18f26, 0x13ec8, 0x11e44, 0x13ec4, 0x11e42, 0x13ec2, 0x10e2c,
+    0x11e6c, 0x10e26, 0x13eec, 0x11e66, 0x13ee6, 0x1dfa8, 0x1efd6, 0x1dfa4,
+    0x1dfa2, 0x19f28, 0x1cf96, 0x1bf68, 0x19f24, 0x1bf64, 0x19f22, 0x1bf62,
+    0x11e28, 0x18f16, 0x13e68, 0x11e24, 0x17ee8, 0x13e64, 0x11e22, 0x17ee4,
+    0x13e62, 0x17ee2, 0x10e16, 0x11e36, 0x13e76, 0x17ef6, 0x1df94, 0x1df92,
+    0x19f14, 0x1bf34, 0x19f12, 0x1bf32, 0x11e14, 0x13e34, 0x11e12, 0x17e74,
+    0x13e32, 0x17e72, 0x1df8a, 0x19f0a, 0x1bf1a, 0x11e0a, 0x13e1a, 0x17e3a,
+    0x1035c, 0x1034e, 0x10758, 0x183ae, 0x1074c, 0x10746, 0x1032e, 0x1076e,
+    0x10f50, 0x187ac, 0x10f48, 0x187a6, 0x10f44, 0x10f42, 0x1072c, 0x10f6c,
+    0x10726, 0x10f66, 0x18fa8, 0x1c7d6, 0x18fa4, 0x18fa2, 0x10f28, 0x18796,
+    0x11f68, 0x18fb6, 0x11f64, 0x10f22, 0x11f62, 0x10716, 0x10f36, 0x11f76,
+    0x1cfd4, 0x1cfd2, 0x18f94, 0x19fb4, 0x18f92, 0x19fb2, 0x10f14, 0x11f34,
+    0x10f12, 0x13f74, 0x11f32, 0x13f72, 0x1cfca, 0x18f8a, 0x19f9a, 0x10f0a,
+    0x11f1a, 0x13f3a, 0x103ac, 0x103a6, 0x107a8, 0x183d6, 0x107a4, 0x107a2,
+    0x10396, 0x107b6, 0x187d4, 0x187d2, 0x10794, 0x10fb4, 0x10792, 0x10fb2,
+    0x1c7ea
+}};
+
+static int ERROR_LEVEL0[] = {27, 917};
+static int ERROR_LEVEL1[] = {522, 568, 723, 809};
+static int ERROR_LEVEL2[] = {237, 308, 436, 284, 646, 653, 428, 379};
+static int ERROR_LEVEL3[] = {274, 562, 232, 755, 599, 524, 801, 132, 295, 116, 442, 428, 295, 42, 176, 65};
+static int ERROR_LEVEL4[] = {
+    361, 575, 922, 525, 176, 586, 640, 321, 536, 742, 677, 742, 687, 284, 193, 517,
+    273, 494, 263, 147, 593, 800, 571, 320, 803, 133, 231, 390, 685, 330, 63, 410};
+static int ERROR_LEVEL5[] = {
+    539, 422, 6, 93, 862, 771, 453, 106, 610, 287, 107, 505, 733, 877, 381, 612,
+    723, 476, 462, 172, 430, 609, 858, 822, 543, 376, 511, 400, 672, 762, 283, 184,
+    440, 35, 519, 31, 460, 594, 225, 535, 517, 352, 605, 158, 651, 201, 488, 502,
+    648, 733, 717, 83, 404, 97, 280, 771, 840, 629, 4, 381, 843, 623, 264, 543};
+static int ERROR_LEVEL6[] = {
+    521, 310, 864, 547, 858, 580, 296, 379, 53, 779, 897, 444, 400, 925, 749, 415,
+    822, 93, 217, 208, 928, 244, 583, 620, 246, 148, 447, 631, 292, 908, 490, 704,
+    516, 258, 457, 907, 594, 723, 674, 292, 272, 96, 684, 432, 686, 606, 860, 569,
+    193, 219, 129, 186, 236, 287, 192, 775, 278, 173, 40, 379, 712, 463, 646, 776,
+    171, 491, 297, 763, 156, 732, 95, 270, 447, 90, 507, 48, 228, 821, 808, 898,
+    784, 663, 627, 378, 382, 262, 380, 602, 754, 336, 89, 614, 87, 432, 670, 616,
+    157, 374, 242, 726, 600, 269, 375, 898, 845, 454, 354, 130, 814, 587, 804, 34,
+    211, 330, 539, 297, 827, 865, 37, 517, 834, 315, 550, 86, 801, 4, 108, 539};
+static int ERROR_LEVEL7[] = {
+    524, 894, 75, 766, 882, 857, 74, 204, 82, 586, 708, 250, 905, 786, 138, 720,
+    858, 194, 311, 913, 275, 190, 375, 850, 438, 733, 194, 280, 201, 280, 828, 757,
+    710, 814, 919, 89, 68, 569, 11, 204, 796, 605, 540, 913, 801, 700, 799, 137,
+    439, 418, 592, 668, 353, 859, 370, 694, 325, 240, 216, 257, 284, 549, 209, 884,
+    315, 70, 329, 793, 490, 274, 877, 162, 749, 812, 684, 461, 334, 376, 849, 521,
+    307, 291, 803, 712, 19, 358, 399, 908, 103, 511, 51, 8, 517, 225, 289, 470,
+    637, 731, 66, 255, 917, 269, 463, 830, 730, 433, 848, 585, 136, 538, 906, 90,
+    2, 290, 743, 199, 655, 903, 329, 49, 802, 580, 355, 588, 188, 462, 10, 134,
+    628, 320, 479, 130, 739, 71, 263, 318, 374, 601, 192, 605, 142, 673, 687, 234,
+    722, 384, 177, 752, 607, 640, 455, 193, 689, 707, 805, 641, 48, 60, 732, 621,
+    895, 544, 261, 852, 655, 309, 697, 755, 756, 60, 231, 773, 434, 421, 726, 528,
+    503, 118, 49, 795, 32, 144, 500, 238, 836, 394, 280, 566, 319, 9, 647, 550,
+    73, 914, 342, 126, 32, 681, 331, 792, 620, 60, 609, 441, 180, 791, 893, 754,
+    605, 383, 228, 749, 760, 213, 54, 297, 134, 54, 834, 299, 922, 191, 910, 532,
+    609, 829, 189, 20, 167, 29, 872, 449, 83, 402, 41, 656, 505, 579, 481, 173,
+    404, 251, 688, 95, 497, 555, 642, 543, 307, 159, 924, 558, 648, 55, 497, 10};
+static int ERROR_LEVEL8[] = {
+    352, 77, 373, 504, 35, 599, 428, 207, 409, 574, 118, 498, 285, 380, 350, 492,
+    197, 265, 920, 155, 914, 299, 229, 643, 294, 871, 306, 88, 87, 193, 352, 781,
+    846, 75, 327, 520, 435, 543, 203, 666, 249, 346, 781, 621, 640, 268, 794, 534,
+    539, 781, 408, 390, 644, 102, 476, 499, 290, 632, 545, 37, 858, 916, 552, 41,
+    542, 289, 122, 272, 383, 800, 485, 98, 752, 472, 761, 107, 784, 860, 658, 741,
+    290, 204, 681, 407, 855, 85, 99, 62, 482, 180, 20, 297, 451, 593, 913, 142,
+    808, 684, 287, 536, 561, 76, 653, 899, 729, 567, 744, 390, 513, 192, 516, 258,
+    240, 518, 794, 395, 768, 848, 51, 610, 384, 168, 190, 826, 328, 596, 786, 303,
+    570, 381, 415, 641, 156, 237, 151, 429, 531, 207, 676, 710, 89, 168, 304, 402,
+    40, 708, 575, 162, 864, 229, 65, 861, 841, 512, 164, 477, 221, 92, 358, 785,
+    288, 357, 850, 836, 827, 736, 707, 94, 8, 494, 114, 521, 2, 499, 851, 543,
+    152, 729, 771, 95, 248, 361, 578, 323, 856, 797, 289, 51, 684, 466, 533, 820,
+    669, 45, 902, 452, 167, 342, 244, 173, 35, 463, 651, 51, 699, 591, 452, 578,
+    37, 124, 298, 332, 552, 43, 427, 119, 662, 777, 475, 850, 764, 364, 578, 911,
+    283, 711, 472, 420, 245, 288, 594, 394, 511, 327, 589, 777, 699, 688, 43, 408,
+    842, 383, 721, 521, 560, 644, 714, 559, 62, 145, 873, 663, 713, 159, 672, 729,
+    624, 59, 193, 417, 158, 209, 563, 564, 343, 693, 109, 608, 563, 365, 181, 772,
+    677, 310, 248, 353, 708, 410, 579, 870, 617, 841, 632, 860, 289, 536, 35, 777,
+    618, 586, 424, 833, 77, 597, 346, 269, 757, 632, 695, 751, 331, 247, 184, 45,
+    787, 680, 18, 66, 407, 369, 54, 492, 228, 613, 830, 922, 437, 519, 644, 905,
+    789, 420, 305, 441, 207, 300, 892, 827, 141, 537, 381, 662, 513, 56, 252, 341,
+    242, 797, 838, 837, 720, 224, 307, 631, 61, 87, 560, 310, 756, 665, 397, 808,
+    851, 309, 473, 795, 378, 31, 647, 915, 459, 806, 590, 731, 425, 216, 548, 249,
+    321, 881, 699, 535, 673, 782, 210, 815, 905, 303, 843, 922, 281, 73, 469, 791,
+    660, 162, 498, 308, 155, 422, 907, 817, 187, 62, 16, 425, 535, 336, 286, 437,
+    375, 273, 610, 296, 183, 923, 116, 667, 751, 353, 62, 366, 691, 379, 687, 842,
+    37, 357, 720, 742, 330, 5, 39, 923, 311, 424, 242, 749, 321, 54, 669, 316,
+    342, 299, 534, 105, 667, 488, 640, 672, 576, 540, 316, 486, 721, 610, 46, 656,
+    447, 171, 616, 464, 190, 531, 297, 321, 762, 752, 533, 175, 134, 14, 381, 433,
+    717, 45, 111, 20, 596, 284, 736, 138, 646, 411, 877, 669, 141, 919, 45, 780,
+    407, 164, 332, 899, 165, 726, 600, 325, 498, 655, 357, 752, 768, 223, 849, 647,
+    63, 310, 863, 251, 366, 304, 282, 738, 675, 410, 389, 244, 31, 121, 303, 263};
+
+
+static int *ERROR_LEVEL[] = {
+    ERROR_LEVEL0,
+    ERROR_LEVEL1,
+    ERROR_LEVEL2,
+    ERROR_LEVEL3,
+    ERROR_LEVEL4,
+    ERROR_LEVEL5,
+    ERROR_LEVEL6,
+    ERROR_LEVEL7,
+    ERROR_LEVEL8};
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/inc/tracedef.h b/SelfServiceCommon/Massai/cpp/CussIF/inc/tracedef.h
new file mode 100644
index 00000000..c0289150
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/inc/tracedef.h
@@ -0,0 +1,44 @@
+//---------------------------------------------------------------------------
+//
+//  file:       tracedef.h
+//
+//  purpose:    trace makro definitions
+//
+//  date:       15.09.00, 12:11
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+
+#include <string>
+
+#define COMPLETE message("to be completed: "  __FILE__)
+
+
+// for easier traces --------------------------------------------------------
+
+//#define _HERE  255,__FILE__,__LINE__     // unconditional trace
+#define _HERE    1,__FILE__,__LINE__     // do not use unconditional trace
+
+#define _HERE_1  1,__FILE__,__LINE__     // level 1 trace (high)
+#define _HERE_2  2,__FILE__,__LINE__
+#define _HERE_3  3,__FILE__,__LINE__
+#define _HERE_4  4,__FILE__,__LINE__
+#define _HERE_5  5,__FILE__,__LINE__
+#define _HERE_6  6,__FILE__,__LINE__
+#define _HERE_7  7,__FILE__,__LINE__
+#define _HERE_8  8,__FILE__,__LINE__
+#define _HERE_9  9,__FILE__,__LINE__     // level 9 trace (low)
+
+void cryptTrace(long lLevel,char *pszFile,long lLine,char *pData,long lLen);
+void trace     (long lLevel,char *pszFile,long lLine,char *pszFormat, ...);
+void dump      (long lLevel,char *pszFile,long lLine,char *pData,long lLen);
+long setLevel  (long level);
+
+std::string scString(long code);
+std::string ecString(long code);
+std::string dsString(long code);
+std::string rcString(long code);
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/mainpage.dox b/SelfServiceCommon/Massai/cpp/CussIF/mainpage.dox
new file mode 100644
index 00000000..bf340443
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/mainpage.dox
@@ -0,0 +1,37 @@
+//---------------------------------------------------------------------------
+//
+//  file:       mainpage.doc
+//
+//  purpose:    Doxygen MainPage
+//
+//  date:       24.07.2001, 09:55
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+/*! \mainpage CUSS Application Development Kit (C++)
+ *  Definition of the Application Interface to the CUSS v1.0 Virtual Components.
+ *  This C++ CLass Library is used to hide the CUSS Virtual Component Concept from
+ *  the application implementation, so that hardware devices can be addressed in
+ *  a direct way.
+ *  To achieve direct access to the hardware devices the CUSS Application Manager on
+ *  the kiosk has to be connected in a first step.
+ *  After querying the environment and the list of virtual components, instances of
+ *  the hardware connection classes can be allocated. All hardware connection classes
+ *  (BPP, ESCROW, MAGCARD, ...) use a reference to the application manager to get
+ *  references to their according virtual components on the kiosk.
+ *
+ *  @attention This definiton includes massai specific implementations which cannot be
+ *             found in the CUSS standard.
+ *
+ *  @see CUSS Technical Specification, Revision 1.0, May 2003
+ *  @version 1.1
+ *
+ *  \section change1 Change history
+ *  \date 25.04.2002 \li No changes - first complete documentation
+ *  \date 25.04.2002 \li Amendments to CUSS v1.0
+ *  \date 07.11.2002 \li Implementation of automated baggage handling interface
+ *  \date 01.10.2004 \li Minor error corrections
+ *
+ */
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/makefile.mak b/SelfServiceCommon/Massai/cpp/CussIF/makefile.mak
new file mode 100644
index 00000000..e13ded20
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/makefile.mak
@@ -0,0 +1,204 @@
+######################################################################
+#
+# /vob/SelfServicePlatform/Massai/cpp/CussIF/makefile.mak
+#
+######################################################################
+
+!include $(BUILDROOT)\Build\cpp\makefile.common.mak
+
+MY_CFLAGS = \
+    $(MY_CFLAGS_3) \
+    $(INC_INTERFACES) \
+    $(INC_ACETAO) \
+    $(INC_REGEX) \
+    $(INC_ZLIB)
+
+STDCFLAGS = $(INC_FLEX) $(INC_PLATFORM_INTER) $(STDCFLAGS)
+
+######################################################################
+
+MY_LIB1 = $(LIB_DST_CUSSIF)
+
+MY_LIB1_OBJS = \
+    $(_OBJ)\codes.obj \
+    $(_OBJ)\codes_skel.obj \
+    $(_OBJ)\types.obj \
+    $(_OBJ)\types_skel.obj \
+    $(_OBJ)\characteristics.obj \
+    $(_OBJ)\characteristics_skel.obj \
+    $(_OBJ)\comps.obj \
+    $(_OBJ)\comps_skel.obj \
+    $(_OBJ)\ping.obj \
+    $(_OBJ)\ping_skel.obj \
+    $(_OBJ)\display.obj \
+    $(_OBJ)\display_skel.obj\
+    $(_OBJ)\dispclnt.obj \
+    $(_OBJ)\appmgr.obj \
+    $(_OBJ)\assotrace.obj \
+    $(_OBJ)\atb2.obj \
+    $(_OBJ)\atb2Scanner.obj \
+    $(_OBJ)\atbreader.obj \
+    $(_OBJ)\clock.obj \
+    $(_OBJ)\baggage.obj \
+    $(_OBJ)\bcs.obj \
+    $(_OBJ)\btp.obj \
+    $(_OBJ)\btpScanner.obj \
+    $(_OBJ)\check.obj \
+    $(_OBJ)\cussapp.obj \
+    $(_OBJ)\dispMap.obj \
+    $(_OBJ)\dispXTRA.obj \
+    $(_OBJ)\escrow.obj \
+    $(_OBJ)\gpp.obj \
+    $(_OBJ)\language.obj \
+    $(_OBJ)\magcard.obj \
+    $(_OBJ)\manufacturer.obj \
+    $(_OBJ)\pdf417.obj \
+    $(_OBJ)\pdf417lib.obj \
+    $(_OBJ)\ppr.obj \
+    $(_OBJ)\fpr.obj \
+    $(_OBJ)\svg.obj \
+    $(_OBJ)\trace.obj \
+    $(_OBJ)\vcomp.obj \
+    $(_OBJ)\XMLScreen.obj \
+    $(_OBJ)\callbackthread.obj \
+    $(_OBJ)\cuss_component.obj \
+    $(_OBJ)\cussif_component.obj \
+    $(_OBJ)\local_def.obj
+
+MY_LIB1_GEN_DIRS = \
+    $(GEN_MASSAI_COMMON) \
+    $(GEN_CUSS)
+
+######################################################################
+
+MY_BIN1 = \
+    $(_BIN)\client.exe
+
+MY_BIN1_RES = \
+    $(_OBJ)\client.res
+    
+MY_BIN1_OBJS = \
+    $(_OBJ)\client.obj
+    
+
+MY_BIN1_USER_LIBS = \
+    $(LIB_CUSSIF) \
+    $(LIB_MASSAI) \
+    $(LIB_MCFGCLNT) \
+    $(LIB_MCORBA) \
+    $(LIB_REGEX) \
+    $(LIB_ZLIB)
+
+MY_BIN1_LINKLIBS = \
+    $(SYS_ADVAPI32) \
+    $(SYS_USER32) \
+    $(SYS_WSOCK32) \
+    $(SYS_ACETAO)
+
+######################################################################
+
+MY_BIN2 = \
+    $(_BIN)\TestCallback.exe
+
+MY_BIN2_RES = \
+    $(_OBJ)\client.res
+    
+MY_BIN2_OBJS = \
+    $(_OBJ)\TestCallback.obj
+    
+
+MY_BIN2_USER_LIBS = \
+    $(LIB_CUSSIF) \
+    $(LIB_MASSAI) \
+    $(LIB_MCFGCLNT) \
+    $(LIB_MCORBA) \
+    $(LIB_REGEX) \
+    $(LIB_ZLIB)
+
+MY_BIN2_LINKLIBS = \
+    $(SYS_ADVAPI32) \
+    $(SYS_USER32) \
+    $(SYS_WSOCK32) \
+    $(SYS_ACETAO)
+
+######################################################################
+
+MY_BIN3 = \
+    $(_BIN)\TestApp.exe
+
+MY_BIN3_RES = \
+    $(_OBJ)\client.res
+    
+MY_BIN3_OBJS = \
+    $(_OBJ)\TestApp.obj
+    
+MY_BIN3_USER_LIBS = \
+    $(LIB_CUSSIF) \
+    $(LIB_MASSAI) \
+    $(LIB_MCFGCLNT) \
+    $(LIB_MCORBA) \
+    $(LIB_REGEX) \
+    $(LIB_ZLIB)
+
+MY_BIN3_LINKLIBS = \
+    $(SYS_ADVAPI32) \
+    $(SYS_USER32) \
+    $(SYS_WSOCK32) \
+    $(SYS_ACETAO)
+
+######################################################################
+
+MY_BIN4 = \
+    $(_BIN)\displayTest.exe
+
+MY_BIN4_RES = \
+    $(_OBJ)\client.res
+    
+MY_BIN4_OBJS = \
+    $(_OBJ)\displayTest.obj
+
+MY_BIN4_LDFLAGS = \
+	/NODEFAULTLIB:LIBC.lib
+    
+MY_BIN4_USER_LIBS = \
+    $(LIB_CUSSIF) \
+    $(LIB_MASSAI) \
+    $(LIB_MCFGCLNT) \
+    $(LIB_MCORBA) \
+    $(LIB_REGEX) \
+    $(LIB_ZLIB)
+
+MY_BIN4_LINKLIBS = \
+    $(SYS_ADVAPI32) \
+    $(SYS_USER32) \
+    $(SYS_WSOCK32) \
+    $(SYS_ACETAO)
+
+######################################################################
+#
+#MY_BIN5 = \
+#    $(_BIN)\TestLevel.exe
+#
+#MY_BIN5_RES = \
+#    $(_OBJ)\client.res
+#    
+#MY_BIN5_OBJS = \
+#    $(_OBJ)\TestLevel.obj \
+#    $(_OBJ)\types.obj \
+#    $(_OBJ)\types_skel.obj \
+#    $(_OBJ)\characteristics.obj \
+#    $(_OBJ)\characteristics_skel.obj \
+#    $(_OBJ)\comps.obj \
+#    $(_OBJ)\comps_skel.obj
+#    
+#MY_BIN5_USER_LIBS = \
+#    $(LIB_MCORBA) \
+#    $(LIB_TEXTIDL)
+#
+#MY_BIN5_LINKLIBS = \
+#    $(SYS_ACETAO)
+#
+######################################################################
+
+
+!include $(BUILDROOT)\Build\cpp\makefile.rules.mak
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/massai.css b/SelfServiceCommon/Massai/cpp/CussIF/massai.css
new file mode 100644
index 00000000..a5a5bc98
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/massai.css
@@ -0,0 +1,216 @@
+H1 {
+  text-align: center;
+  font-family: Geneva, Arial, Helvetica, sans-serif;
+}
+H2 {
+  font-family: Geneva, Arial, Helvetica, sans-serif;
+}
+CAPTION { font-weight: bold }
+DIV.qindex {
+  width: 100%;
+  background-color: #eeeeff;
+  border: 1px solid #B0B0B0;
+  text-align: center;
+  margin: 2px;
+  padding: 2px;
+  line-height: 120%;
+}
+A.qindex {
+       text-decoration: none;
+       font-weight: bold;
+       color: #1A419D;
+       padding: 2px;
+}
+A.qindex:visited {
+       text-decoration: none;
+       font-weight: bold;
+       color: #1A419D
+       padding: 2px;
+}
+A.qindex:hover {
+  text-decoration: none;
+  background-color: #ddddff;
+  padding: 2px;
+}
+A.qindexHL {
+  text-decoration: none;
+  font-weight: bold;
+  background-color: #6666cc;
+  color: #ffffff;
+  padding: 2px 6px;
+  border: 1px double #9295C2;
+}
+A.qindexHL:hover {
+  text-decoration: none;
+  background-color: #6666cc;
+  color: #ffffff;
+  padding: 2px 6px;
+}
+A.qindexHL:visited { text-decoration: none; background-color: #6666cc; color: #ffffff }
+A.el { text-decoration: none; font-weight: bold }
+A.elRef { font-weight: bold }
+A.code { text-decoration: none; font-weight: normal; color: #1A419D}
+A.codeRef { font-weight: normal; color: #1A419D}
+A:hover { text-decoration: none; background-color: #f2f2ff }
+DL.el { margin-left: -1cm }
+PRE.fragment {
+  border: 1px solid #CCCCCC;
+  background-color: #f5f5f5;
+  margin-top: 4px;
+  margin-bottom: 4px;
+  margin-left: 2px;
+  margin-right: 8px;
+  padding-left: 6px;
+  padding-right: 6px;
+  padding-top: 4px;
+  padding-bottom: 4px;
+}
+DIV.fragment {
+  border: 1px solid #CCCCCC;
+  background-color: #f5f5f5;
+  padding: 6px;
+}
+DIV.ah { background-color: black; font-weight: bold; color: #ffffff; margin-bottom: 3px; margin-top: 3px }
+TD.md { background-color: #F4F4FB; font-weight: bold; }
+TD.mdname1 { background-color: #F4F4FB; font-weight: bold; color: #602020; }
+TD.mdname { background-color: #F4F4FB; font-weight: bold; color: #602020; width: 600px; }
+DIV.groupHeader {
+       margin-left: 16px;
+       margin-top: 12px;
+       margin-bottom: 6px;
+       font-weight: bold;
+  font-family: Geneva, Arial, Helvetica, sans-serif;
+}
+DIV.groupText { margin-left: 16px; font-style: italic; font-size: 14px }
+BODY {
+  background-color: #eeeeff;
+  color: #000064;
+  margin-right: 20px;
+  margin-left: 20px;
+}
+TD.indexkey {
+  background-color: #eeeeff;
+  font-weight: bold;
+  padding-right  : 10px;
+  padding-top    : 2px;
+  padding-left   : 10px;
+  padding-bottom : 2px;
+  margin-left    : 0px;
+  margin-right   : 0px;
+  margin-top     : 2px;
+  margin-bottom  : 2px;
+  border: 1px solid #CCCCCC;
+}
+TD.indexvalue {
+  background-color: #eeeeff;
+  font-style: italic;
+  padding-right  : 10px;
+  padding-top    : 2px;
+  padding-left   : 10px;
+  padding-bottom : 2px;
+  margin-left    : 0px;
+  margin-right   : 0px;
+  margin-top     : 2px;
+  margin-bottom  : 2px;
+  border: 1px solid #CCCCCC;
+}
+TR.memlist {
+   background-color: #f0f0f0;
+}
+P.formulaDsp { text-align: center; }
+IMG.formulaDsp { }
+IMG.formulaInl { vertical-align: middle; }
+SPAN.keyword       { color: #008000 }
+SPAN.keywordtype   { color: #604020 }
+SPAN.keywordflow   { color: #e08000 }
+SPAN.comment       { color: #800000 }
+SPAN.preprocessor  { color: #806020 }
+SPAN.stringliteral { color: #002080 }
+SPAN.charliteral   { color: #008080 }
+.mdTable {
+  border: 1px solid #868686;
+  background-color: #F4F4FB;
+}
+.mdRow {
+  padding: 8px 10px;
+}
+.mdescLeft {
+       padding: 0px 8px 4px 8px;
+  font-size: 14px;
+  font-style: italic;
+  background-color: #FAFAFA;
+  border-top: 1px none #E0E0E0;
+  border-right: 1px none #E0E0E0;
+  border-bottom: 1px none #E0E0E0;
+  border-left: 1px none #E0E0E0;
+  margin: 0px;
+}
+.mdescRight {
+       padding: 0px 8px 4px 8px;
+  font-size: 14px;
+  font-style: italic;
+  background-color: #FAFAFA;
+  border-top: 1px none #E0E0E0;
+  border-right: 1px none #E0E0E0;
+  border-bottom: 1px none #E0E0E0;
+  border-left: 1px none #E0E0E0;
+  margin: 0px;
+}
+.memItemLeft {
+  padding: 1px 0px 0px 8px;
+  margin: 4px;
+  border-top-width: 1px;
+  border-right-width: 1px;
+  border-bottom-width: 1px;
+  border-left-width: 1px;
+  border-top-style: solid;
+  border-top-color: #E0E0E0;
+  border-right-color: #E0E0E0;
+  border-bottom-color: #E0E0E0;
+  border-left-color: #E0E0E0;
+  border-right-style: none;
+  border-bottom-style: none;
+  border-left-style: none;
+  background-color: #FAFAFA;
+  font-family: Geneva, Arial, Helvetica, sans-serif;
+  font-size: 12px;
+}
+.memItemRight {
+  padding: 1px 8px 0px 8px;
+  margin: 4px;
+  border-top-width: 1px;
+  border-right-width: 1px;
+  border-bottom-width: 1px;
+  border-left-width: 1px;
+  border-top-style: solid;
+  border-top-color: #E0E0E0;
+  border-right-color: #E0E0E0;
+  border-bottom-color: #E0E0E0;
+  border-left-color: #E0E0E0;
+  border-right-style: none;
+  border-bottom-style: none;
+  border-left-style: none;
+  background-color: #FAFAFA;
+  font-family: Geneva, Arial, Helvetica, sans-serif;
+  font-size: 13px;
+}
+.search     { color: #003399;
+              font-weight: bold;
+}
+FORM.search {
+              margin-bottom: 0px;
+              margin-top: 0px;
+}
+INPUT.search { font-size: 75%;
+               color: #000080;
+               font-weight: normal;
+               background-color: #eeeeff;
+}
+TD.tiny      { font-size: 75%;
+}
+a {
+  color: #252E78;
+}
+a:visited {
+  color: #3D2185;
+}
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/materna.GIF b/SelfServiceCommon/Massai/cpp/CussIF/materna.GIF
new file mode 100644
index 0000000000000000000000000000000000000000..130f19a6839e28f38db8465a4dc3999728c3f083
GIT binary patch
literal 3794
zcmchY>swQIzQuq0lCVPpY!X7k&DjaJfPe`If*`XK?$Js>3ITPDfIx*hQK$vMo)8iU
z5HQ7vXwwp?C|2P_EhD4S1_Y|3MZlJNr4h%1*47j{rR``r_MbT47oS((^{f}`S<gyI
zOOB4&c?N`o?^b}-YF%DgnV6lQoqsVjF*`6mGyh`wHB18&#=h}t)6mT9e7SL`R6kIl
z>64cCNJ>q-O#Q(4tg&xG-!rZ;4aF3gM0v)bOg%5t$d&4GiKaj^kXPN8S>7WpHDNIt
zAgb;gn&}yss5TCj>jz3TeL<N<o>b43Xf&qr%<?{IX^*796q9G<O7wV)1`}0-pz`sF
z*`9$JQ{RNKXIyW3EgUM<3=~xN<(2ou<e5a7#vrL46KOzD^~~&xiJAGl^1jT{9%+Fo
zNNVIs^v0eEy=h!y9IDn2#AF&pub+de0k3>$e0F?deqd+@aLfA!W~6zh`S}+wUMw#!
zuguRc&&<rv&b|QukH`BBh5ob)`4fL;LOQIdfVxhjt#8mZHZ|*8S`QiCZ&OP|B7(<B
z<cWe1E#k%Ft>*GN)^ye*!c#|yqdcLwNq*A8W9za#`*{?D8+ne?Nb4uU*Q=Q(%dLOa
zA2}B&Z;*7{A_muFH{b3^hH{2@8|pY8hk=}+{?pp{&)hUI;e&xXxuBnPyu8Ms1^kcA
z;<|K2CCl%5+tp$hpL%l&)^q_6rS2W%%zeQCHi-!%7aTv|NaFZ2qE6mzNT#|f-B%~M
zi>VKW)edF~zU_P5!`9H8+I8^NA3o<7C4AJury}vg;5VNc{1^>8FDZU7Xgb?T%r%S5
zAAfVbf2*6(`J1~v-7Cs>IubATKfGMI^xc3u|G7SZS&{|e*1E6|=S0+E&q$=Zvf++N
zQJog1ZHS*DAcf8e(6{N?84R+;A4rw`Qw8HKyfeGago0@NL>$`AK0m#4*qxJO8MN?5
zw3wHNlQ4~ZqSiPjI~D$8--s98K}_g@`N=37@KY7nAqvoXLfcXyp?YkY8G}Z0YqeSw
z_#CJ<ud|LE@jO5g*i@*y;7fr>8SaREntIr*rUe_ZjkEv(Ql_y?GBxb|*U}oob$}$j
z-z(|%r-xZ5S^nJ%b7Z*5K1EPKmyNu?ealWvAdqMn_`htVFR$v0s{%nypl&7Y<I2g2
zAf7!DqbZ<ac<Th{+Q<(a18DI^isr`tZ;xD`IHr{;)72b<Mn~ztHVJY+t5J>7PJvp8
zmvkvDmG<V3Koxq*FTs^B%)I~tcya*fQAPIcn_oPLQfD(;x=$wv8Y{Do{_%Xe*`KU@
zraM0PX`>EN{M1_*v4<_G%jQ*Bpvd<EfP09`?q@fnXtTvSAaHAz(6`rK6jR5F%yVrV
z?g#1kc#&bGt8u{qJI0$;;ySfm@tl5#nXjUcePn$b9XsEwzWn27!lQ59@3zDA>z<NP
z`UCfB08stv5`MxJ+n(f%GOt>fHDFNZ;CZEaghFTU)2={Gn6SO}olxZ#KJ_M%sPvwH
za%y|TzbzlJX^cywDeE4PX-<?9UMe0+=To5PElIUHNr#Md+u9~u1vcv6NrIW)L)QIN
zBj_ixqs>>bY@_N!9=}62jBybeaH90Ksn&J!`nsKl54uN&(iBHDI$wQuZKM>7t!1Wg
z6eAF26Hu|Edj%+M))q269*f*O#&&Zf%6O3ceeIKu)m7Knh~mAfJB^ilC<}GUu-~8b
zcDDXAlG^*x@87q(sK<ci>K^hlO;+pgV35<c{%QR}Ym9x(t^%60+;imFPv@-4t-MHu
zXFJ20K0U%hJ=QXoc-~o)ZhT^_bY*$=FNp>gjOAbbrQNt=vj1<FY()_M_L7GA&8KRb
zV<0OZdBYikow&6v+?ND8{z${Hr|2BZ4uNE)cF7qEG)@vwC<Ni&Jy_g!2~`n}?wBk5
zBzY~$+OY7D=uLDg()gpUB~8?C`B*4uP6^)RaN5xvU?go`9np$SyOk~;-n-#tFmkY!
z7@mg|RL(IQ>n)~Q;3rvS`E@#M^LeKoReRk?gDhM2v)bEe)0b3`E@6wBU$GIsAf~xq
z_^8oyRtOKSwkAc{MH}Y$RIkh95fU3xDhu+s?>d}bI2j%=ENN0tiq9A#1tw)iY6J0=
zL&Bg}Sg>e?+i?%LY*RoSyV(d;B`xnmL3F;lK25$w_YdV4HC5#5Y^LUe$_xQv1Q~aU
z!kqoUo%ukzaby0R@0-JpwK$61^3#!-ATC5PwbA4^id~RPlGpl)=SlP|gIo7M1Jj(f
zZljEmMVz~TSB7@6jnPeegK!E@o91@9U{mmMFpTzWDPly~Y5r$}#I<pwJs&}ueN{q_
zyWXSN-Q3T0WeL=raF@Q3Dh!HCq{hV-pT*B5%f0bKKmksY_K?KHTPH}xuIok8+sE(y
zd@}mW)0^pC8kgt!VXrRS07Z$hmn<X}ORNGFLgDRAeTBKoe7^IfxqWsF0xJ|1E&8$Q
z2Zk+#BR_<zN8pCsE{AOHYEWjs5do9%A_8cFx!Oe|xh_<YPVWUOmyU8guH+alBWq_r
zRBSxrt#XMMK`yF5UpMYFKC=b+A`FULWjp2+eH%UyVs^-plgU2B;4k<H0=hx{erp6G
z2L+*bCW@VuTGlq_9ctZ(>xoZve!awrSf_qv!^Q`5o)>Y+ARCLaJlNEW(>VZQv|nyn
z&zGP_6?;}wEAw(omM>3J)-XE$O9y6!`OzCMD!;z`p!ik#6?+SC#Z|Ea*+sU;5Vd^g
zIrqd#0=-8Wc2SARx54U@j<2pqsgh(}3x&fxbJ0q@+ZCJR*1-`{p1vmR=1#@1Eq7$W
zqD2O4$*9L{+P%X>K`q3F&Bxfz!>(&{;u^SRZgJ70@8{zQ4Q1whZO6w^SByJ;>8(do
zlNakmnYDhtxw~^x{R8SJ3j?=$T;G}S^&bKQ@T<5>Wyv6Vd_~5Oc_-dGZwQV$&#g`T
z`F1y{48gnp4O3qFp@$2`(>)K+0aAtcN(~O<47zXF-0{3P4P-n$yeEu5YGVZNsmVAV
zQSQik5~2aryWb^b*;aKdkbk`(-=GNYb%2$xm-D5-Yo~&q=&{f#UL0|g^DqImkbm~>
z4c%N}Rtwc%Dy`Eo3vsM??=BOv;sgJfnQw^4g53&!f`PY{b3v8}iOvO9za(y}qrqvu
z@73D%BH;gq?4Gm7TL%>)52<KWR?`JB&fajK-&p6k%`R%$gJ7dkC~ZBn*(2BUu5GG`
zktNi<@df{0$}o9mpAp%1lJ(EW_YdRIkftj1>*T+#ay3de>!@dGSiH|@!og#@BmeaT
zOZC@W&`nFnZpBG2PVIB=x?Wxa%huf_Ppv;SKmPX8HQcAS&2(4n=ERTcl-(=dF(7Fs
zK7}!FMMDR8dF6lOPJHj^?9Rtu?L*4$FhecJoo6O~8F-gClUu7hSyt#<$oTmw6SHll
znpt{vK*t9DsDxEmx+1x`yCy<?pozkRTW?*z(=I!{`DI9kVuhdtTCKDi6~wTTM}A#9
zdYKja_vD7uJA&sA*=5!<9?p`xPe)k++k|zu3g9`ltvYUp<+m?O|5y_2{;BEjYp{^B
z8RMg#I@8DcZYq5avLo%Pj2guu*4#tFt%-5?QAv_UUbn%pwz}j$kJc4Eox=gWiS{(G
zGwww9^orR_G%?qY=G8y>`uA&`{JO~DxgWe0FvL|k*`Vh}X1&5ukg?xNMbZ7i<|600
zQz_>NcQGfW!5UoRUI}cZ%M|2f12KeJ{xt|us#@!vGQMHw8r(aq$eu;Nj!A{RA|t(_
z;?ud6nmTg7WU9jRtMb<kNXOj_0kt}t^pr(pX~2TP?sItM?e?U%>adGhEbE26imcQ+
z0}>MM_*DcJlkqNd8X>1Q#GJ&wT<e&wtRHKD-&sa?9evHDiaQ&My8`}pXGi^{`Z(NB
zF{kx5D#|&P@v?Wrm3y_S(u3D_A0i8m`OyL&>mnnaTk*yo-`FNwpp^gKfQ)IX+-BxB
zbw@XykT;#IY^oAN@rsBB5{Wb*Z90xWvBe;SSvGJX085j>d?Cy+R7NC0>#kvt1v#tZ
zd`JOe63QlEz>EyFh?oSN!lGanzzC!;g@CP~I2h3FJoGlU!VoJV2JlQ3Vydg#GlURT
zhCD0=95ed#Y9uooqvG7}vJhB^Xp@k_a7avoPUz5c8PZ9>vjm)JZRr#On%R#|K)z-_
z6i|HaYbYw14^wLVG1O|%pE3l?4#|X3->^5IfL0|e3JNlyrF{@TANg$zW)wqw3y5c<
z#gCvUgtBzLnV3Sj39woMw?^h@NsyqV1Q^zSo`}f}uzCx&iipUz$Oj@3vCM}i3`A5A
z9j9=V6t<b(O#xCvMkpXc%>1>4V1Az$Md_adpl>sva0J8>e3rru$k6*@H2g927oK-a
zIhJDaky|e#!TX>Ze~8<b117=pPD&Uah1uk6m1nFHk(&{JCB@$cS&jg?lCsGf;Rj@x
z)kAD?J{N=hHUcNRq8n^mTIEPQjzX`OP$??e1=ibXK6Z}~*{U!ZfJpTIqnsQo@?;8P
z3z5*t@HC-cng!{!!S_YTE)O(#x;@*1l($hhilj^%ymd0CW~})nPr$N6hy{Q}$a)Ry
zoCH_i+}5dU?2T?b$2FsQX6gZRGme4S$2piC>BQk~S7bqiI0!+S&FAocC}Pzro(hU4
zkeDSjbrB`)v<RC|H1R>Qoqy>mg#-|cucLY?lJkT}0g?MY+i<!|;4XwIHsBEfQ?6qa
e0^s=edr7StL(319#A9Jk_JJPx@t(FnJ^v2`(vp?{

literal 0
HcmV?d00001

diff --git a/SelfServiceCommon/Massai/cpp/CussIF/res/client.rc b/SelfServiceCommon/Massai/cpp/CussIF/res/client.rc
new file mode 100644
index 00000000..f49d390b
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/res/client.rc
@@ -0,0 +1,107 @@
+//Microsoft Developer Studio generated resource script.
+//
+#include "Global_def.h"
+#include "client_def.h"
+
+#define APSTUDIO_READONLY_SYMBOLS
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 2 resource.
+//
+#include "windows.h"
+
+/////////////////////////////////////////////////////////////////////////////
+#undef APSTUDIO_READONLY_SYMBOLS
+
+/////////////////////////////////////////////////////////////////////////////
+// German (Germany) resources
+
+#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_DEU)
+#ifdef _WIN32
+LANGUAGE LANG_GERMAN, SUBLANG_GERMAN
+#pragma code_page(1252)
+#endif //_WIN32
+
+#ifndef _MAC
+/////////////////////////////////////////////////////////////////////////////
+//
+// Version
+//
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION FILE_VER_BIN
+ PRODUCTVERSION PRODUCT_VER_BIN
+ FILEFLAGSMASK 0x3fL
+#ifdef _DEBUG
+ FILEFLAGS 0x1L
+#else
+ FILEFLAGS 0x0L
+#endif
+ FILEOS 0x40004L
+ FILETYPE 0x2L
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040704b0"
+        BEGIN
+            VALUE COMPANY
+			VALUE FILEDESCRIPTION
+			VALUE FILE_VER_STR
+			VALUE INTERNALNAME
+			VALUE COPYRIGHT
+			VALUE LEGALTRADEMARKS
+			VALUE ORIGINALFILENAME
+			VALUE PRODUCT
+            VALUE PRODUCT_VER_STR
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x407, 1200
+    END
+END
+
+#endif    // !_MAC
+
+
+#ifdef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// TEXTINCLUDE
+//
+
+1 TEXTINCLUDE DISCARDABLE
+BEGIN
+    "resource.h\0"
+END
+
+2 TEXTINCLUDE DISCARDABLE
+BEGIN
+    "#include ""windows.h""\r\n"
+    "\0"
+END
+
+3 TEXTINCLUDE DISCARDABLE
+BEGIN
+    "\r\n"
+    "\0"
+END
+
+#endif    // APSTUDIO_INVOKED
+
+#endif    // German (Germany) resources
+/////////////////////////////////////////////////////////////////////////////
+
+
+
+#ifndef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 3 resource.
+//
+
+
+/////////////////////////////////////////////////////////////////////////////
+#endif    // not APSTUDIO_INVOKED
+
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/sed.inp b/SelfServiceCommon/Massai/cpp/CussIF/sed.inp
new file mode 100644
index 00000000..d92e9cbe
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/sed.inp
@@ -0,0 +1,2 @@
+s/TAO140//g
+s/.tao140//g
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/Atb2Scanner.l b/SelfServiceCommon/Massai/cpp/CussIF/src/Atb2Scanner.l
new file mode 100644
index 00000000..4caf7da1
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/Atb2Scanner.l
@@ -0,0 +1,534 @@
+%{
+
+//---------------------------------------------------------------------------
+//
+//  file:       atb2Scanner.l
+//
+//  purpose:    Scanner to find CUSS papertype from AEA commands
+//
+//  date:       30.04.2002, 13:58
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "atb2Scanner.h"
+#include "tracedef.h"
+
+using namespace MASSAI;
+
+static atb2Scanner::PaperTypes prevPaperType;
+static long  count = 0;
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        static char *paperTypeString(atb2Scanner::PaperTypes pt)
+ *
+ *  @brief     Convert papertype into readable format
+ *
+ *  @date      13.02.2004
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+static char *paperTypeString(atb2Scanner::PaperTypes pt)
+{
+static char szPT[256];
+
+    switch(pt)
+    {
+    case atb2Scanner::Unknown:              strcpy(szPT,"Unkown papertype"); break;
+    case atb2Scanner::Setup:                strcpy(szPT,"Virtual (setup-) papertype"); break;
+    case atb2Scanner::Ticket:               strcpy(szPT,"Ticket"); break;
+    case atb2Scanner::BoardingPass:         strcpy(szPT,"Boarding pass"); break;
+    case atb2Scanner::InsertedDoc:          strcpy(szPT,"Boarding pass (inserted doc)"); break;
+    case atb2Scanner::GeneralPuposeDoc:     strcpy(szPT,"Ticket (no according stock available)"); break;
+    case atb2Scanner::BoardingPassFirst:    strcpy(szPT,"Boarding pass (first class)"); break;
+    case atb2Scanner::BoardingPassBusiness: strcpy(szPT,"Boarding pass (business class)"); break;
+    case atb2Scanner::BoardingPassEconomy:  strcpy(szPT,"Boarding pass (economy class)"); break;
+    case atb2Scanner::PreferTicket:         strcpy(szPT,"No papertype, ticket preferred"); break;
+    case atb2Scanner::PreferBoardingPass:   strcpy(szPT,"No papertype, boarding pass preferred"); break;
+    case atb2Scanner::Error:
+    default:                                strcpy(szPT,"Error encountered in datastream"); break;
+    }
+
+    return(szPT);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   static atb2Scanner::PaperTypes checkPaperType(const char *pszText)
+//
+//  purpose:    check ticketing paper types
+//
+//  date:       03.05.2002, 11:37
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+static atb2Scanner::PaperTypes checkPaperType(const char *pszText)
+{
+atb2Scanner::PaperTypes pt;
+
+    if(pszText && strlen(pszText) > 4)
+    {
+      // check the AEA defined papertypes
+
+      switch(*(pszText +3))
+      {
+      case '1': pt = atb2Scanner::Ticket;                break;
+      case '2': pt = atb2Scanner::GeneralPuposeDoc;      break;
+      case '3': pt = atb2Scanner::BoardingPass;          break;
+      case '4': pt = atb2Scanner::GeneralPuposeDoc;      break;
+      case '5': pt = atb2Scanner::Ticket;                break;
+      case '6': pt = atb2Scanner::BoardingPassFirst;     break;
+      case '7': pt = atb2Scanner::BoardingPassBusiness;  break;
+      case '8': pt = atb2Scanner::BoardingPassEconomy;   break;
+
+      // papertype 9-0 are not yet supported -> error
+      // if other character than 1-5, use CUSS mapped paper type instead
+
+      default: pt = atb2Scanner::Error;                  break;
+      }
+
+      trace(_HERE,"checkPaperType() detected paper type: [%s]:[%d]",paperTypeString(pt),pt);
+
+      return(pt);
+    }
+    else
+      return(atb2Scanner::Error);
+}
+
+%}
+
+/* specify options for the scanner */
+
+%option c++
+%option yylineno
+%option noyywrap
+%option never-interactive
+
+%option prefix="atb2"
+
+/* regular expression definitions */
+
+sep               [^0-9A-Z]
+seps              {sep}+
+
+sapp              (\$[A-Za-z]{1,4}\$)?
+
+logo              {sapp}"LT"[0-9A-Z]{2}|{sapp}"LC"[0-9A-Z]{2}|{sapp}"LS"
+tmplate           {sapp}"TT"[0-9]{2}|{sapp}"TC"[0-9]{2}|{sapp}"TA"
+font              {sapp}"FT"[0-9A-Z]{2}|{sapp}"FC"[0-9A-Z]{2}|{sapp}"FS"
+program           {sapp}"PD"([0-9A-Z]|[:punct:]){10}|{sapp}"PV"
+killprog          {sapp}"KP"
+changemode        {sapp}"XC"|{sapp}"XT"
+pectab            {sapp}"PT"{sep}|{sapp}"PS"|{sapp}"PC"[A-Z]*[0-9]*
+hardcode          {sapp}"CT"[0-9A-Z]{1,5}|{sapp}"CT"
+prnreset          {sapp}"IN"
+
+tktAllCoupon      {sapp}"TK"{sep}[0-9]?"A"[0-9]?{sep}
+tktFlightCoupon   {sapp}"TK"{sep}[0-9]?"C"[0-9]{2}{sep}
+tktCCChargeForm   {sapp}"TK"{sep}[0-9]?"F"[0-9]?{sep}
+tktAgentCoupon    {sapp}"TK"{sep}[0-9]?"I"[0-9]?{sep}
+tktReceipt        {sapp}"TK"{sep}[0-9]?"R"[0-9]?{sep}
+tktAuditCoupon    {sapp}"TK"{sep}[0-9]?"U"[0-9]?{sep}
+tktSpecialForm    {sapp}"TK"{sep}[0-9]?"S"[0-9]?{sep}
+tktFreeForm       {sapp}"TK"{sep}[0-9]?"X"[0-9]?{sep}
+
+/* CI!01B!4C724!4D0103340890!583!A7BOARDING PASS!B0$T!B31530!B4BUSINESS!B5GVA!B6C!B9B36!C534A!CD34A!CFNO!D00007! */
+
+checkinAll        {sapp}"CI"{sep}"A"{sep}
+couponPrintAll    {sapp}"CP"{sep}"A"{sep}
+
+checkin           {sapp}"CI"{sep}([0-9]?"C"[0-9]{2}{sep})*
+revalidation      {sapp}"TR"{sep}([0-9]?"C"[0-9]{2}{sep})*
+couponPrint       {sapp}"CP"{sep}([0-9]?"C"[0-9]{2}{sep})*
+
+%%
+
+^{prnreset}       { trace(_HERE,"scanner: hardcode, yytext = [%s]",YYText());
+                    yy_flush_buffer(YY_CURRENT_BUFFER);
+                    return(atb2Scanner::Setup);
+                  }
+
+^{hardcode}       { trace(_HERE,"scanner: hardcode, yytext = [%s]",YYText());
+                    yy_flush_buffer(YY_CURRENT_BUFFER);
+                    return(atb2Scanner::Setup);
+                  }
+
+
+^{logo}           { trace(_HERE,"scanner: logo, yytext = [%s]",YYText());
+                    yy_flush_buffer(YY_CURRENT_BUFFER);
+                    return(atb2Scanner::Setup);
+                  }
+
+^{tmplate}        { trace(_HERE,"scanner: template, yytext = [%s]",YYText());
+                    yy_flush_buffer(YY_CURRENT_BUFFER);
+                    return(atb2Scanner::Setup);
+                  }
+
+^{font}           { trace(_HERE,"scanner: font, yytext = [%s]",YYText());
+                    yy_flush_buffer(YY_CURRENT_BUFFER);
+                    return(atb2Scanner::Setup);
+                  }
+
+^{program}        { trace(_HERE,"scanner: program, yytext = [%s]",YYText());
+                    yy_flush_buffer(YY_CURRENT_BUFFER);
+                    return(atb2Scanner::Setup);
+                  }
+
+^{pectab}         { trace(_HERE,"scanner: pectab, yytext = [%s]",YYText());
+                    yy_flush_buffer(YY_CURRENT_BUFFER);
+                    return(atb2Scanner::Setup);
+                  }
+
+^{changemode}     { trace(_HERE,"scanner: change printer mode, yytext = [%s]",YYText());
+                    yy_flush_buffer(YY_CURRENT_BUFFER);
+                    return(atb2Scanner::Setup);
+                  }
+
+^{killprog}       { trace(_HERE,"scanner: kill program, yytext = [%s]",YYText());
+                    yy_flush_buffer(YY_CURRENT_BUFFER);
+                    return(atb2Scanner::Error);
+                  }
+
+^{tktAllCoupon}   { trace(_HERE,"scanner: ticket all coupon(s), yytext = [%s]",YYText());
+
+                    atb2Scanner::PaperTypes pt;
+
+                    //if((pt = checkPaperType(YYText())) == atb2Scanner::Error)
+                      pt = atb2Scanner::Ticket;
+
+                    yy_flush_buffer(YY_CURRENT_BUFFER);
+
+                    return(pt);
+                  }
+
+{tktFlightCoupon} { trace(_HERE,"scanner: ticket normal flight coupon, yytext = [%s]",YYText());
+
+                    atb2Scanner::PaperTypes pt;
+
+                    if((pt = checkPaperType(YYText())) == atb2Scanner::Error)
+                      pt = atb2Scanner::PreferTicket;
+
+                    yy_flush_buffer(YY_CURRENT_BUFFER);
+
+                    return(pt);
+                  }
+
+^{tktCCChargeForm} { trace(_HERE,"scanner: ticket credit card charge form, yytext = [%s]",YYText());
+
+                    atb2Scanner::PaperTypes pt;
+
+                    if((pt = checkPaperType(YYText())) == atb2Scanner::Error)
+                      pt = atb2Scanner::GeneralPuposeDoc;
+
+                    yy_flush_buffer(YY_CURRENT_BUFFER);
+
+                    return(pt);
+                  }
+
+^{tktAgentCoupon} { trace(_HERE,"scanner: ticket agent coupon, yytext = [%s]",YYText());
+
+                    atb2Scanner::PaperTypes pt;
+
+                    if((pt = checkPaperType(YYText())) == atb2Scanner::Error)
+                      pt = atb2Scanner::PreferTicket;
+
+                    yy_flush_buffer(YY_CURRENT_BUFFER);
+
+                    return(pt);
+                  }
+
+^{tktReceipt}     { trace(_HERE,"scanner: ticket receipt, yytext = [%s]",YYText());
+
+                    atb2Scanner::PaperTypes pt;
+
+                    if((pt = checkPaperType(YYText())) == atb2Scanner::Error)
+                      pt = atb2Scanner::PreferTicket;
+
+                    yy_flush_buffer(YY_CURRENT_BUFFER);
+
+                    return(pt);
+                  }
+
+^{tktAuditCoupon} { trace(_HERE,"scanner: ticket audit coupon, yytext = [%s]",YYText());
+
+                    atb2Scanner::PaperTypes pt;
+
+                    if((pt = checkPaperType(YYText())) == atb2Scanner::Error)
+                      pt = atb2Scanner::PreferTicket;
+
+                    yy_flush_buffer(YY_CURRENT_BUFFER);
+
+                    return(pt);
+                  }
+
+^{tktSpecialForm} { trace(_HERE,"scanner: ticket special form, yytext = [%s]",YYText());
+
+                    atb2Scanner::PaperTypes pt;
+
+                    if((pt = checkPaperType(YYText())) == atb2Scanner::Error)
+                      pt = atb2Scanner::GeneralPuposeDoc;
+
+                    yy_flush_buffer(YY_CURRENT_BUFFER);
+
+                    return(pt);
+                  }
+
+^{tktFreeForm}    { trace(_HERE,"scanner: ticket free form, yytext = [%s]",YYText());
+
+                    atb2Scanner::PaperTypes pt;
+
+                    if((pt = checkPaperType(YYText())) == atb2Scanner::Error)
+                      pt = atb2Scanner::GeneralPuposeDoc;
+
+                    yy_flush_buffer(YY_CURRENT_BUFFER);
+
+                    return(pt);
+                  }
+
+^{checkinAll}     { trace(_HERE,"scanner: CI multi coupons ??, yytext = [%s]",YYText());
+
+                    // use invalid paper type for first attempt
+
+                    // prevPaperType = atb2Scanner::PaperTypes(-1);
+                  }
+
+^{couponPrintAll} { trace(_HERE,"scanner: CP multi coupons ??, yytext = [%s]",YYText());
+
+                    // use invalid paper type for first attempt
+
+                    //prevPaperType = atb2Scanner::PaperTypes(-1);
+                  }
+
+^{checkin}        { trace(_HERE,"scanner: Check-in, yytext = [%s]",YYText());
+
+                    atb2Scanner::PaperTypes pt;
+
+                    count++;
+
+                    //if((pt = checkPaperType(YYText())) == atb2Scanner::Error)
+                    pt = atb2Scanner::InsertedDoc;
+
+                    if(count > 1 && pt != prevPaperType)
+                    {
+                      // can't handle different papertypes in one CI message !!
+
+                      trace(_HERE,"scanner: DIFFERENT PAPER TYPES IN AEA DATA STREAM !!");
+
+                      yy_flush_buffer(YY_CURRENT_BUFFER);
+
+                      return(atb2Scanner::Error);
+                    }
+                    else
+                      prevPaperType = pt;
+                  }
+
+^{revalidation}   { trace(_HERE,"scanner: Revalidation, yytext = [%s]",YYText());
+
+                    atb2Scanner::PaperTypes pt;
+
+                    count++;
+
+                    //if((pt = checkPaperType(YYText())) == atb2Scanner::Error)
+                    pt = atb2Scanner::InsertedDoc;
+
+                    if(count > 1 && pt != prevPaperType)
+                    {
+                      // can't handle different papertypes in one TR message !!
+
+                      trace(_HERE,"scanner: DIFFERENT PAPER TYPES IN AEA DATA STREAM !!");
+
+                      yy_flush_buffer(YY_CURRENT_BUFFER);
+
+                      return(atb2Scanner::Error);
+                    }
+                    else
+                      prevPaperType = pt;
+                  }
+
+{couponPrint}     { trace(_HERE,"scanner: Coupon from stock, yytext = [%s]",YYText());
+
+                    atb2Scanner::PaperTypes pt;
+
+                    count++;
+
+                    if((pt = checkPaperType(YYText())) == atb2Scanner::Error)
+                      //return pt;
+                      pt = atb2Scanner::PreferBoardingPass;
+
+                    if(count > 1 && pt != prevPaperType)
+                    {
+                      // can't handle different papertypes in one CP message !!
+
+                      //trace(_HERE,"scanner: DIFFERENT PAPER TYPES IN AEA DATA STREAM !!");
+
+                      yy_flush_buffer(YY_CURRENT_BUFFER);
+
+                      trace(_HERE,"scanner: DIFFERENT PAPER TYPES IN AEA DATA STREAM -> returning first detected papertype.");
+
+                      return(prevPaperType);
+
+                      //return(atb2Scanner::Error);
+                    }
+                    else
+                      prevPaperType = pt;
+                  }
+
+%%
+
+//int yywrap() { return(1); } // have defined [%option noyywrap] ???
+
+//---------------------------------------------------------------------------
+//
+//  function:   class atb2ScannerHandle : public yyFlexLexer
+//
+//  purpose:    the bsic scanner class
+//
+//  date:       30.04.2002, 16:43
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+class atb2ScannerHandle : public yyFlexLexer
+{
+private:
+
+    // scan buffer definition
+
+    char szScanBuffer[8096];
+
+    void LexerOutput(const char *p, int size)
+    {
+      //printf("LexerOutput(%s, size = %d)\n",p,size);
+    }
+
+    // redefine standard LexerInput()
+
+    int LexerInput(char *p,int n)
+    {
+      int rc;
+
+      if(*szScanBuffer)
+      {
+        // copy scan buffer to FLEX scan buffer
+
+        strcpy(p,szScanBuffer);
+
+        rc = strlen(szScanBuffer);
+
+        // do this only one time !!
+
+        *szScanBuffer = '\0';
+
+        // return length of buffer
+
+        return(rc);
+      }
+      else
+      {
+        // stops scanner
+
+        return(0);
+      }
+    }
+
+public:
+
+    void setBuffer(const char *pszBuffer)
+    {
+      count = 0;
+
+      if(pszBuffer)
+      {
+        //trace(_HERE,"AEA input: %-40s ...",pszBuffer);
+
+        strncpy(szScanBuffer,pszBuffer, sizeof(szScanBuffer));
+        szScanBuffer[sizeof(szScanBuffer)-1]= 0;
+      }
+      else
+        *szScanBuffer = '\0';
+    }
+};
+
+//---------------------------------------------------------------------------
+//
+//  function:   atb2Scanner::PaperTypes atb2Scanner::checkPaperType(const char *pszAEA)
+//
+//  purpose:    try to scan the given buffer for any CUSS-known paper types
+//
+//  date:       30.04.2002, 16:42
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+atb2Scanner::PaperTypes atb2Scanner::checkPaperType(const char *pszAEA)
+{
+PaperTypes rc = Unknown;
+
+    if(scanner && pszAEA)
+    {
+      scanner->setBuffer(pszAEA);
+
+      rc = (PaperTypes) scanner->yylex();
+
+      if(rc != Error && count >= 1)
+      {
+        // handled more than 1 CI/CP/TR in one AEA data stream
+        //
+        // if scanner returns something != Error, we can use the
+        // previous paper type for return !!
+
+        rc = prevPaperType;
+      }
+
+      trace(_HERE,"scanner returned papertype [%s]:[%d]",paperTypeString(rc),rc);
+
+      return(rc);
+    }
+    else
+      return(Error);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   atb2Scanner::atb2Scanner() : scanner( new atb2ScannerHandle )
+//
+//  purpose:    class constructor
+//
+//  date:       30.04.2002, 16:42
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+atb2Scanner::atb2Scanner() : scanner( new atb2ScannerHandle )
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   atb2Scanner::~atb2Scanner()
+//
+//  purpose:    class destructor
+//
+//  date:       30.04.2002, 16:43
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+atb2Scanner::~atb2Scanner()
+{
+    delete scanner;
+}
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/TestCallback.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/TestCallback.cpp
new file mode 100644
index 00000000..60bc716d
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/TestCallback.cpp
@@ -0,0 +1,75 @@
+//---------------------------------------------------------------------------
+//
+//  file:       TestCallback.cpp
+//
+//  author:     Materna Information & Communications
+//
+//---------------------------------------------------------------------------
+
+#include "callbackthread.h"
+#include "tracedef.h"
+#include <iostream>
+#include <windows.h>
+#include "cussif/cussif_component.h"
+
+massai::cussif::Capture capture(0);
+massai::cussif::Conveyor conveyor(0);
+massai::cussif::DataInput dataInput(0);
+massai::cussif::DataOutput dataOutput(0);
+massai::cussif::Dispenser dispenser(0);
+massai::cussif::Display display(0);
+massai::cussif::Feeder feeder(0);
+massai::cussif::MediaInput mediaInput(0);
+massai::cussif::MediaOutput mediaOutput(0);
+massai::cussif::Network network(0);
+massai::cussif::Storage storage(0);
+massai::cussif::UserInput userInput(0);
+massai::cussif::UserOutput userOutput(0);
+
+
+
+
+
+
+
+namespace
+{
+
+  mThreadMutex outaccess;
+
+  class TestCallback: public MASSAI::CallbackThread
+  {
+    protected:
+      void callback(MASSAI::CallbackComponent component, const types::Event& ev, int id)
+      {
+        mThreadAutoMutex request(&outaccess);
+        std::cout << "< " << id << std::endl;
+      }
+  };
+}
+
+int main(int argc, char **argv)
+{
+  std::cout << capture.getRealComponentIdentification() << std::endl;
+  setLevel(9);
+  TestCallback test;
+  test.startProcessing();
+  MASSAI::CallbackComponent component = MASSAI::CC_READER;
+  types::Event ev;
+  for(int id= 0; id < 1000; id++)
+  {
+    {
+      mThreadAutoMutex request(&outaccess);
+      std::cout << "> " << id << std::endl;
+    }
+    test.enqueue(component, ev, id);
+    if(id % 10 == 0)
+    {
+      Sleep(100);
+    }
+  }
+  Materna::MSSD::eventSemaphore wait;
+  wait.reset();
+  wait.wait();
+  return 0;
+}
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/XMLScreen.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/XMLScreen.cpp
new file mode 100644
index 00000000..14c381c0
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/XMLScreen.cpp
@@ -0,0 +1,269 @@
+/****************************************************************************
+ *
+ * @file XMLScreen.h
+ *
+ * converts the screen data to an xml format
+ *
+ * @author TS
+ *
+ * Copyright (c) 2004, MATERNA Information & Communications
+ *
+ ****************************************************************************/
+
+
+#include "XMLScreen.h"
+#include <sstream>
+
+using std::ostream;
+using std::string;
+
+/*---------------------------------------------------------------------------
+
+ FUNCTION:  void writeContentCharData(ostream& out, string::const_iterator first, string const_iterator last)
+
+ COMMENTS:  write XML AttValue to stream (using apos)
+
+ DATE:      16.07.2001
+
+ AUTHOR:    Materna Information & Communications (TS)
+
+---------------------------------------------------------------------------*/
+
+void writeContentCharData(ostream& out, string::const_iterator first, string::const_iterator last)
+{
+  char buffer[10];
+  string::const_iterator it;
+  unsigned int i;
+  for(it= first; it != last; it++)
+  {
+    switch(*it)
+    {
+      case '&':
+        out << "&amp;";
+        break;
+      case '<':
+        out << "&lt;";
+        break;
+      case '>':
+        out << "&gt;";  // avoid "]]>"
+        break;
+      default:
+        if (*it < ' ' || *it > 127)
+        {
+          i= (unsigned char)*it;
+          sprintf(buffer, "&#x%X;", i);
+          out << buffer;
+        }
+        else
+          out << *it;
+    }
+  }
+}
+
+
+
+/*---------------------------------------------------------------------------
+
+ FUNCTION:  void writeAttValueApos(ostream& out, string::const_iterator first, string const_iterator last)
+
+ COMMENTS:  write XML AttValue to stream (using apos)
+
+ DATE:      16.07.2001
+
+ AUTHOR:    Materna Information & Communications (TS)
+
+---------------------------------------------------------------------------*/
+
+void writeAttValueApos(ostream& out, string::const_iterator first, string::const_iterator last)
+{
+  char buffer[10];
+  string::const_iterator it;
+  unsigned int i;
+  out << "\'";
+  for(it= first; it != last; it++)
+  {
+    switch(*it)
+    {
+      case '&':
+        out << "&amp;";
+        break;
+      case '<':
+        out << "&lt;";
+        break;
+      case '\'':
+        out << "&apos;";
+        break;
+      default:
+        if (*it < ' ' || *it > 127)
+        {
+          i= (unsigned char)*it;
+          sprintf(buffer, "&#x%X;", i);
+          out << buffer;
+        }
+        else
+          out << *it;
+    }
+  }
+  out << "\'";
+}
+
+
+
+/*---------------------------------------------------------------------------
+
+ FUNCTION:  void writeAttValueQuot(ostream& out, string::const_iterator first, string const_iterator last)
+
+ COMMENTS:  write XML AttValue to stream (using quot)
+
+ DATE:      16.07.2001
+
+ AUTHOR:    Materna Information & Communications (TS)
+
+---------------------------------------------------------------------------*/
+
+void writeAttValueQuot(ostream& out, string::const_iterator first, string::const_iterator last)
+{
+  char buffer[10];
+  string::const_iterator it;
+  unsigned int i;
+  out << "\"";
+  for(it= first; it != last; it++)
+  {
+    switch(*it)
+    {
+      case '&':
+        out << "&amp;";
+        break;
+      case '<':
+        out << "&lt;";
+        break;
+      case '\"':
+        out << "&quot;";
+        break;
+      default:
+        if (*it < ' ' || *it > 127)
+        {
+          i= (unsigned char)*it;
+          sprintf(buffer, "&#x%X;", i);
+          out << buffer;
+        }
+        else
+          out << *it;
+    }
+  }
+  out << "\"";
+}
+
+
+/*  XML format:
+
+<scr id= "screenid">
+ <rtf>
+  <mbr id= "memberid">
+    Text
+  </mbr>
+  <lbx id= "memberid" cnt = '2'>
+   <val id= "1">Text</val>
+   <val id= "2">Text</val>
+  </lbx>
+ </rtf>
+ <dta>
+   <val id= "1">Text</val>
+   <val id= "2">Text</val>
+ </dta>
+</scr>
+*/
+void convertMemberToXML(ostream& out, const aMap& member)
+{
+  const aObject* pMemberId= 0;
+  while((pMemberId= member.getNextKey(pMemberId)) != 0)
+  {
+    if(pMemberId->getTag() == OBJ_STR)
+    {
+      std::string memberid= pMemberId->strObject();
+      aObject memberItem= member.get(*pMemberId);
+      if(memberItem.getTag() == OBJ_MAP) // list box
+      {
+        aMap listitems = memberItem.mapObject();
+        const aObject* pItem= 0;
+
+        out << "<lbx id=";
+        writeAttValueQuot(out, memberid.begin(), memberid.end());
+        out << " cnt=\"" << listitems.count() << "\">";
+
+        const aObject *pListitemid = 0;
+        while((pItem = listitems.getNextKey(pItem)) != 0)
+        {
+          if(pItem->getTag() == OBJ_NUM)
+          {
+            aObject item= listitems.get(*pItem);
+            if(item.getTag() == OBJ_STR)
+            {
+              std::string itemtext= item.strObject();
+              out << "<val id=\"" << pItem->numObject() << "\">";
+              writeContentCharData(out, itemtext.begin(), itemtext.end());
+              out << "</val>";
+            }
+          }
+        }
+      }
+      else if(member.get(*pMemberId).getTag() == OBJ_STR)
+      {
+        std::string itemtext= memberItem.strObject();
+        out << "<mbr id=";
+        writeAttValueQuot(out, memberid.begin(), memberid.end());
+        out << ">";
+        writeContentCharData(out, itemtext.begin(), itemtext.end());
+        out << "</mbr>";
+      }
+    }
+  }
+}
+void convertDataToXML(ostream& out, const aMap& member)
+{
+  const aObject* pMemberId= 0;
+  while((pMemberId= member.getNextKey(pMemberId)) != 0)
+  {
+    if(pMemberId->getTag() == OBJ_NUM)
+    {
+      aObject memberItem= member.get(*pMemberId);
+      if(member.get(*pMemberId).getTag() == OBJ_STR)
+      {
+        std::string itemtext= memberItem.strObject();
+        out << "<val id=\"" << pMemberId->numObject() << "\">";
+        writeContentCharData(out, itemtext.begin(), itemtext.end());
+        out << "</val>";
+      }
+    }
+  }
+}
+
+void convertScreenToXML(const aMap& screen, std::string& xmlstream)
+{
+  std::ostringstream out;
+  const char* szScreenId= screen.get("ScreenId").strObject();
+  std::string screenid= szScreenId?szScreenId:"";
+  const char* szLangId= screen.get("LangId").strObject();
+  std::string langid= szLangId?szLangId:"";
+
+  out << "<scr id=";
+  writeAttValueQuot(out, screenid.begin(), screenid.end());
+  if(langid.size() > 0)
+  {
+    out << " lang=";
+    writeAttValueQuot(out, langid.begin(), langid.end());
+  }
+  out << ">";
+  out << "<rtf>";
+  convertMemberToXML(out, screen.get("RTF").mapObject());
+  out << "</rtf>";
+  out << "<dta>";
+  convertDataToXML(out, screen.get("Data").mapObject());
+  out << "</dta>";
+  out << "</scr>";
+  xmlstream= out.str();
+}
+
+/****************************************************************************
+ End of file XMLScreen.h
+****************************************************************************/
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/appmgr.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/appmgr.cpp
new file mode 100644
index 00000000..2e3cc73a
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/appmgr.cpp
@@ -0,0 +1,2399 @@
+//---------------------------------------------------------------------------
+//
+//  file:       ami.cpp
+//
+//  purpose:    application manager client
+//
+//  date:       12.09.00, 13:18
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include <sys/timeb.h>
+#include <time.h>
+
+#include "iorparser.h"
+#include "cussif.h"
+#include "tracedef.h"
+#include "orbs.h"
+#include "textIDL/textcodes.h"
+#include "textIDL/texttypes.h"
+#include "textIDL/textcharacteristics.h"
+#include <vector>
+
+
+using namespace MASSAI;
+using namespace MASSAI::codes_text;
+using namespace MASSAI::characteristics_text;
+using namespace MASSAI::types_text;
+
+enum ComponentTraversal
+{
+  NOT_FOUND,
+  FOUND,
+  VISITED
+};
+
+
+
+amInterface::MediaInputData::MediaInputData():
+  barcodetype(Characteristics::ComponentFonts::nonApplicableBarcodeStandard),
+  readertype(Characteristics::MediaInput::nonApplicableReaderType)
+{}
+
+amInterface::MediaOutputData::MediaOutputData():
+  writertype(Characteristics::MediaOutput::nonApplicableMediaType)
+{}
+
+amInterface::ConveyorData::ConveyorData():
+  conveyortype(Characteristics::Conveyor::nonApplicableConveyorType)
+{}
+
+amInterface::DispenserData::DispenserData():
+  dispensertype(Characteristics::Dispenser::nonApplicableDispenserType)
+{}
+
+
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        EnvironmentComponents_var amInterface::getComponents()
+ *
+ *  @brief     Returns list of CUSS components
+ *
+ *  @date      23.02.2004
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+EnvironmentComponents_var amInterface::getComponents()
+{
+    return(ec);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   EnvironmentLevel_var amInterface::getEnvironment()
+//
+//  purpose:    Access to the environment level structure
+//
+//  date:       02.04.2001, 09:01
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+EnvironmentLevel_var amInterface::getEnvironment()
+{
+    return(el);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void amInterface::prepareEvent(Event &ev)
+//
+//  purpose:    Set default values for an event to be sent to application manager
+//
+//  date:       01.12.00, 17:04
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void amInterface::prepareEvent(Event &ev)
+{
+Any           elud;  // correlation data
+Any           data;  // event data
+gps           loc;   // gps location
+struct _timeb tb;    // timestamp
+
+      _ftime(&tb);
+
+      elud <<= (Long) 0;
+      data <<= (Long) 0;
+
+      loc.longitude.direction = north_;
+      loc.longitude.degrees   = 0;
+      loc.longitude.minutes   = 0;
+      loc.longitude.seconds   = 0;
+      loc.longitude.hundreths = 0;
+
+      loc.latitude.direction  = south_;
+      loc.latitude.degrees    = 0;
+      loc.latitude.minutes    = 0;
+      loc.latitude.seconds    = 0;
+      loc.latitude.hundreths  = 0;
+
+      ev.gpsLocation          = loc;
+
+      ev.timeStamp            = 141427L;  // Days between 15.10.1582 and 1.1.1970
+      ev.timeStamp            *= 24;      // hours
+      ev.timeStamp            *= 60;      // minutes
+      ev.timeStamp            *= 60;      // seconds
+      ev.timeStamp            += tb.time; // seconds between 1.1.1970 and now
+      ev.timeStamp            *= 1000;    // milliseconds
+      ev.timeStamp            += tb.millitm;
+      ev.timeStamp            *= 10000;   // 100 nanoseconds
+
+      ev.componentRef         = string_dup("");
+
+      ev.functionName         = string_dup("notify()");
+
+      ev.eventCode            = 0;
+
+      ev.eventMode            = unsolicited_;
+      ev.eventCategory        = normal_;
+      ev.eventType            = private_;
+      ev.statusCode           = statuscodes::OK;
+
+      ev.eventData            = data;
+      ev.elud                 = elud;
+
+      return;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void amInterface::callback(const Event &ev)
+//
+//  purpose:    Overload callback function
+//
+//  date:       01.12.00, 10:45
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void amInterface::callback(const Event &ev)
+{
+  enqueue(CC_APPLICATIONMANAGER, ev, 0);
+}
+
+void amInterface::callback(CallbackComponent component, const types::Event& ev, int id)
+{
+  amInterfaceCallback(ev);
+}
+
+void amInterface::startProcessing()
+{
+  CallbackThread::startProcessing();
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void amInterface::amInterfaceCallback(const Event &ev)
+//
+//  purpose:    application manager notifies application here!
+//
+//  date:       29.11.00, 15:06
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void amInterface::amInterfaceCallback(const Event &ev)
+{
+    trace(_HERE_7, "event: %s", eventText(ev).c_str());
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool amInterface::connect()
+//
+//  purpose:    reconnect
+//
+//  date:       02.05.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+bool amInterface::connect()
+{
+  if(state == CS_CONNECTED)
+  {}
+  else if(state == CS_FAILED)
+  {
+    trace(_HERE_1, "not connected state is: failed");
+  }
+  else if(iorRef.size() == 0)
+  {
+    trace(_HERE_1, "not connected no ior");
+    state= CS_NOT_CONNECTED;
+  }
+  else
+  {
+    try
+    {
+      if(cclnt)
+        delete cclnt;
+      cclnt= 0;
+      cclnt= new corbaCallbackClientTerminator<ApplicationManager>(this, iorRef.c_str());
+      ApplicationManager_ptr proxy= cclnt->proxy();
+      if(proxy != 0)
+      {
+        ami = proxy->_duplicate(proxy);
+      }
+      else
+      {
+        ami = proxy;
+      }
+      if(!is_nil(ami))
+      {
+        state= CS_CONNECTED;
+      }
+      else
+      {
+        trace(_HERE_1, "proxy is nil (%s)", iorRef.c_str());
+        state= CS_NOT_CONNECTED_RETRY;
+      }
+    }
+    catch(const CORBA::TRANSIENT& ex)
+    {
+      trace(_HERE_1, "CORBA::TRANSIENT (%s):\n%s", iorRef.c_str(), ex._message());
+      state= CS_NOT_CONNECTED_RETRY;
+    }
+    catch(const CORBA::COMM_FAILURE& ex)
+    {
+      trace(_HERE_1, "CORBA::COMM_FAILURE (%s):\n%s", iorRef.c_str(), ex._message());
+      state= CS_NOT_CONNECTED_RETRY;
+    }
+    catch(const CORBA::SystemException& ex)
+    {
+      trace(_HERE_1, "CORBA::SystemException (%s):\n%s", iorRef.c_str(), ex._message());
+    }
+    catch(std::exception& ex)
+    {
+      trace(_HERE_1, "std::exception (%s):\n%s", iorRef.c_str(), ex.what());
+    }
+    catch(...)
+    {
+      trace(_HERE_1, "unknown exception (%s)", iorRef.c_str());
+    }
+  }
+  return state == CS_CONNECTED;
+}
+//---------------------------------------------------------------------------
+//
+//  function:   long amInterface::setListener(bool retry)
+//
+//  purpose:    set listener
+//
+//  date:       02.05.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+long amInterface::setListener(bool retry)
+{
+  long rc= returncodes::RC_ERROR;
+  if(registered || !retry)
+  {
+    if(connect())
+    {
+      Event_var  ev;
+      evtFilter  ef;
+      action     actn;
+      Any        elud;
+      Any        any;
+
+      elud <<= (Long)0;
+      any  <<= all_;
+
+      if(registered)
+        actn = subscribe_;
+      else
+        actn = discard_;
+
+      ef.filterALLorANY(any);
+      try
+      {
+        rc= ami->registerEvent(szAppRef, actn, ef, listener(), elud, ev);
+      }
+      catch(...)
+      {
+        if(catch_cuss_exception())
+        {
+          try
+          {
+            rc= ami->registerEvent(szAppRef, actn, ef, listener(), elud, ev);
+          }
+          catch(...)
+          {
+            catch_cuss_exception(false);
+          }
+        }
+      }
+    }
+  }
+  return rc;
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool amInterface::catch_cuss_exception(bool retry= true)
+//
+//  purpose:    evaluate corba exceptions
+//
+//  date:       02.05.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+bool amInterface::catch_cuss_exception(bool retry)
+{
+  bool reconnect= false;
+  bool result= false;
+  try
+  {
+    throw;
+  }
+  catch(const CORBA::TRANSIENT& ex)
+  {
+    trace(_HERE_1, "CORBA::TRANSIENT(%s):\n%s", iorRef.c_str(), ex._message());
+    state= CS_NOT_CONNECTED_RETRY;
+    reconnect= retry;
+  }
+  catch(const CORBA::COMM_FAILURE& ex)
+  {
+    trace(_HERE_1, "CORBA::COMM_FAILURE(%s):\n%s", iorRef.c_str(), ex._message());
+    state= CS_NOT_CONNECTED_RETRY;
+    reconnect= retry;
+  }
+  catch(const CORBA::INITIALIZE& ex)
+  {
+    trace(_HERE_1, "CORBA::INITIALIZE (%s):\n%s", iorRef.c_str(), ex._message());
+    state= CS_FAILED;
+  }
+  catch(const CORBA::SystemException& ex)
+  {
+    trace(_HERE_1, "CORBA::SystemException (%s):\n%s", iorRef.c_str(), ex._message());
+  }
+  catch(std::exception& ex)
+  {
+    trace(_HERE_1, "std::exception (%s):\n%s", iorRef.c_str(), ex.what());
+  }
+  catch(...)
+  {
+    trace(_HERE_1, "Unknown exception (%s):\n", iorRef.c_str());
+  }
+  if(reconnect)
+  {
+    connect();
+    result= (state == CS_CONNECTED);
+  }
+  return result;
+}
+
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   long amInterface::waitToInitialize()
+//
+//  purpose:    Requests for initialization allowance
+//
+//  date:       01.12.00, 13:00
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long amInterface::waitToInitialize()
+{
+Event_var ev;
+
+    long storeOldTimeout= -1;
+    try
+    {
+      // initrequest may last some time
+      storeOldTimeout= GetInvocationTimeout(cclnt->orb(), true);    // store invocation timeout for this thread
+      SetInvocationTimeout(cclnt->orb(), 60*60*1000, true);         // change the invocation timeout for this thread, wait up to 1 hour for initrequest
+    }
+    catch(const CORBA::SystemException& ex)
+    {
+      trace(_HERE_1, "store timeout, CORBA::SystemException (%s):\n%s", iorRef.c_str(), ex._message());
+    }
+    catch(std::exception& ex)
+    {
+      trace(_HERE_1, "store timeout, std::exception (%s):\n%s", iorRef.c_str(), ex.what());
+    }
+    catch(...)
+    {
+      trace(_HERE_1, "store timeout, unknown exception (%s)", iorRef.c_str());
+    }
+
+
+    try
+    {
+      if(!connect())
+      {
+        lError = -1;
+        return(error());
+      }
+
+      trace(_HERE_7, "initrequest() ...");
+      lError= returncodes::RC_ERROR;
+
+      try
+      {
+        lError = ami->initrequest(szAppRef, ev);
+      }
+      catch(...)
+      {
+        if(catch_cuss_exception())
+        {
+          try
+          {
+            lError = ami->initrequest(szAppRef, ev);
+          }
+          catch(...)
+          {
+            catch_cuss_exception(false);
+          }
+        }
+      }
+      if(lError == returncodes::RC_LISTENER)
+      {
+        if(setListener() == returncodes::RC_OK)
+        {
+          try
+          {
+            lError = ami->initrequest(szAppRef, ev);
+          }
+          catch(...)
+          {
+            if(catch_cuss_exception())
+            {
+              try
+              {
+                lError = ami->initrequest(szAppRef, ev);
+              }
+              catch(...)
+              {
+                catch_cuss_exception(false);
+              }
+            }
+          }
+        }
+      }
+
+      if(lError != 0)
+      {
+        trace(_HERE_7, "initrequest() = (%s) (%d)", rcString(lError).c_str(), lError);
+
+        return(error());
+      }
+      else
+      {
+        if(ev->statusCode == statuscodes::OK)
+        {
+          trace(_HERE_7, "initrequest(), ok");
+
+          return(0);
+        }
+        else
+        {
+          trace(_HERE_7, "initrequest() = (%s) (%d)", scString(ev->statusCode).c_str(), ev->statusCode);
+
+          return(ev->statusCode);
+        }
+      }
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+
+      lError = -1;
+      return(error());
+    }
+    try
+    {
+      if(storeOldTimeout > 0)
+        SetInvocationTimeout(cclnt->orb(), storeOldTimeout, true); // reset the invocation timeout for this thread
+      else if(storeOldTimeout == 0)
+        ClearInvocationTimeout(cclnt->orb(), true);                // reset the invocation timeout for this thread
+    }
+    catch(const CORBA::SystemException& ex)
+    {
+      trace(_HERE_1, "restore timeout, CORBA::SystemException (%s):\n%s", iorRef.c_str(), ex._message());
+    }
+    catch(std::exception& ex)
+    {
+      trace(_HERE_1, "restore timeout, std::exception (%s):\n%s", iorRef.c_str(), ex.what());
+    }
+    catch(...)
+    {
+      trace(_HERE_1, "restore timeout, unknown exception (%s)", iorRef.c_str());
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long amInterface::notify (long eventCode)
+//
+//  purpose:    Send notification to remote application manager
+//
+//  date:       01.12.00, 17:28
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long amInterface::notify (long eventCode)
+{
+Event_var oev;
+
+    try
+    {
+      if(!connect())
+      {
+        lError = -1;
+        return(error());
+      }
+
+      trace(_HERE_7, "amInterface::notify() with:");
+      trace(_HERE_7, "akid: (\n%s)", akIDText(akid).c_str());
+      trace(_HERE_7, "event code: (%s) (%d)", eventCodesText(eventCode).c_str(), eventCode);
+
+      lError= returncodes::RC_ERROR;
+      try
+      {
+        lError= ami->notify(szAppRef, akid, eventCode, oev);
+      }
+      catch(...)
+      {
+        if(catch_cuss_exception())
+        {
+          try
+          {
+            lError= ami->notify(szAppRef, akid, eventCode, oev);
+          }
+          catch(...)
+          {
+            catch_cuss_exception(false);
+          }
+        }
+      }
+      if(lError == returncodes::RC_LISTENER)
+      {
+        if(setListener() == returncodes::RC_OK)
+        {
+          try
+          {
+            lError= ami->notify(szAppRef, akid, eventCode, oev);
+          }
+          catch(...)
+          {
+            if(catch_cuss_exception())
+            {
+              try
+              {
+                lError= ami->notify(szAppRef, akid, eventCode, oev);
+              }
+              catch(...)
+              {
+                catch_cuss_exception(false);
+              }
+            }
+          }
+        }
+      }
+
+
+      if(lError != 0)
+        return(error());
+      else
+      {
+        if(oev->statusCode != statuscodes::OK && oev->statusCode != statuscodes::AL_APPLICATION_REQUEST)
+        {
+          trace(_HERE_7, "appmanager::notify(), sc = (%s) (%d)", scString(oev->statusCode).c_str(), oev->statusCode);
+
+          return(oev->statusCode);
+        }
+        else
+          return(0);
+      }
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+
+      lError = -1;
+      return(error());
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long amInterface::registerForEvents(bool fRegister)
+//
+//  purpose:    Register/Unregister events from the application manager
+//
+//  date:       01.12.00, 17:29
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long amInterface::registerForEvents(bool fRegister)
+{
+  if(fRegister)
+    registered= true;
+  else
+    registered= false;
+  return setListener(false);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long amInterface::queryEnvironment()
+//
+//  purpose:    query environment to run in
+//
+//  date:       15.09.00, 12:12
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long amInterface::queryEnvironment()
+{
+    try
+    {
+      if(!connect())
+      {
+        lError = -1;
+        return(error());
+      }
+      trace(_HERE_7, "calling level()...");
+
+
+      lError= returncodes::RC_ERROR;
+      try
+      {
+        lError= ami->level(akid, el);
+      }
+      catch(...)
+      {
+        if(catch_cuss_exception())
+        {
+          try
+          {
+            lError= ami->level(akid, el);
+          }
+          catch(...)
+          {
+            catch_cuss_exception(false);
+          }
+        }
+      }
+      if(lError == returncodes::RC_LISTENER)
+      {
+        if(setListener() == returncodes::RC_OK)
+        {
+          try
+          {
+            lError= ami->level(akid, el);
+          }
+          catch(...)
+          {
+            if(catch_cuss_exception())
+            {
+              try
+              {
+                lError= ami->level(akid, el);
+              }
+              catch(...)
+              {
+                catch_cuss_exception(false);
+              }
+            }
+          }
+        }
+      }
+
+      if(lError != 0)
+      {
+        return(error());
+      }
+      else
+      {
+        trace(_HERE_7, "Kiosk Environment:(\n%s)", environmentLevelText(el).c_str());
+      }
+
+      // save the application token !!
+
+      strcpy(szAppRef, el->applicationToken);
+
+      return(0);
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+
+      lError = -1;
+      return(error());
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long amInterface::queryComponents(const char *pszAppRef)
+//
+//  purpose:    query the environment components
+//
+//  date:       12.09.00, 14:23
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long amInterface::queryComponents(const char *pszAppRef)
+{
+CORBA::ULong i, j, linked;
+
+    try
+    {
+      if(!pszAppRef)
+      {
+        // if not given, use reference got by environmentLevel()
+
+        pszAppRef = szAppRef;
+      }
+
+      if(!connect())
+      {
+        lError = -1;
+        return(error());
+      }
+
+      mediainput.clear();
+      mediaoutput.clear();
+      conveyor.clear();
+      dispenser.clear();
+
+      lError= returncodes::RC_ERROR;
+      try
+      {
+        lError= ami->components(string_dup(pszAppRef), ec);
+      }
+      catch(...)
+      {
+        if(catch_cuss_exception())
+        {
+          try
+          {
+            lError= ami->components(string_dup(pszAppRef), ec);
+          }
+          catch(...)
+          {
+            catch_cuss_exception(false);
+          }
+        }
+      }
+      if(lError == returncodes::RC_LISTENER)
+      {
+        if(setListener() == returncodes::RC_OK)
+        {
+          try
+          {
+            lError= ami->components(string_dup(pszAppRef), ec);
+          }
+          catch(...)
+          {
+            if(catch_cuss_exception())
+            {
+              try
+              {
+                lError= ami->components(string_dup(pszAppRef), ec);
+              }
+              catch(...)
+              {
+                catch_cuss_exception(false);
+              }
+            }
+          }
+        }
+      }
+
+
+      if(lError != 0)
+        return(error());
+
+      trace(_HERE_7, "Platform components:");
+
+      for(i = 0; i < ec->length(); i++)
+      {
+        // check first level
+
+        trace(_HERE_7, "[%d] = [%s][%s]", i,
+                                      ec[i].realComponentName.in(),
+                                      ec[i].virtualComponentName.in());
+
+        //trace(_HERE_7, "ior = [%s]", ec[i].virtualComponentRef);
+
+        for(j = 0; j < ec[i].linkedComponents.length(); j++)
+        {
+          // check second level
+
+          linked = ec[i].linkedComponents[j];
+
+          trace(_HERE_7, "--> [%d] = [%s][%s]", linked,
+                                            ec[linked].realComponentName.in(),
+                                            ec[linked].virtualComponentName.in());
+
+          //trace(_HERE_7, "--> ior   = [%s]", ec[linked].virtualComponentRef);
+        }
+        retryComponentRetrieval(i);
+      }
+      return(error());
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+
+      lError = -1;
+      return(error());
+    }
+}
+
+const amInterface::FailedComponents& amInterface::queryFailedComponents() const
+{
+  return failed;
+}
+long amInterface::retryComponentRetrieval()
+{
+  CORBA::ULong i;
+  try
+  {
+    for(i = 0; i < ec->length(); i++)
+    {
+      // check first level
+      if(failed.find(i) != failed.end())
+      {
+        trace(_HERE_7, "[%d] = [%s][%s]", i,
+                                      ec[i].realComponentName.in(),
+                                      ec[i].virtualComponentName.in());
+        if(retryComponentRetrieval(i) == 0)
+        {
+          failed.erase(i);
+        }
+      }
+    }
+    return(error());
+  }
+  catch(CORBA::SystemException& ex)
+  {
+    trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+
+    lError = -1;
+    return(error());
+  }
+}
+long amInterface::retryComponentRetrieval(long comp)
+{
+  long rc= 0;
+  CORBA::ULong i= comp;
+  if(!strcmp("MediaInput", ec[i].virtualComponentName))
+  {
+    try
+    {
+      corbaCallbackClientTerminator<MediaInput> cclnt(this, ec[i].virtualComponentRef);
+      MediaInput_ptr vcInput= cclnt.proxy();
+      MediaInputData& data= mediainput[i];
+      data.barcodetype= vcInput->usedStandard();
+      trace(_HERE_7, "> barcodetype (%s) (%d)", barcodeStandardText(data.barcodetype).c_str(), data.barcodetype);
+      data.readertype= vcInput->typeOfReader();
+      trace(_HERE_7, "> readertype (%s) (%d)", readerTypeText(data.readertype).c_str(), data.readertype);
+      Characteristics::DataTypeList_var datatype= vcInput->supportedDataTypes();
+      for(CORBA::ULong k= 0; k < datatype->length(); ++k)
+      {
+        data.datatype.insert(datatype[k]);
+        trace(_HERE_7, "> datatype (%s) (%d)", dataTypeText(datatype[k]).c_str(), datatype[k]);
+      }
+      Characteristics::MediaTypeListDef_var mediatype= vcInput->mtList();
+      for(CORBA::ULong j= 0; j < mediatype->length(); ++j)
+      {
+        Characteristics::MediaType::MediaTypeDef type= mediatype[j]->type();
+        data.mediatype.insert(type);
+        trace(_HERE_7, "> mediatype (%s) (%d)", mediaTypeDefText(type).c_str(), type);
+      }
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      rc= -1;
+      trace(_HERE_7, "CORBA::SystemException:\n%s", ex._message());
+    }
+    catch(...)
+    {
+      rc= -1;
+      trace(_HERE_7, "Exception:\n Cannot get typeOfReader [%s][%s]", ec[i].realComponentName.in(), ec[i].virtualComponentName.in());
+    }
+  }
+  else if(!strcmp("MediaOutput", ec[i].virtualComponentName))
+  {
+    try
+    {
+      corbaCallbackClientTerminator<MediaOutput> cclnt(this, ec[i].virtualComponentRef);
+      MediaOutput_ptr vcOutput= cclnt.proxy();
+      MediaOutputData& data= mediaoutput[i];
+      data.writertype= vcOutput->type();
+      trace(_HERE_7, "> writertype (%s) (%d)", mediaTypeText(data.writertype).c_str(), data.writertype);
+      Characteristics::DataTypeList_var datatype= vcOutput->supportedDataTypes();
+      for(CORBA::ULong k= 0; k < datatype->length(); ++k)
+      {
+        data.datatype.insert(datatype[k]);
+        trace(_HERE_7, "> datatype (%s) (%d)", dataTypeText(datatype[k]).c_str(), datatype[k]);
+      }
+      Characteristics::MediaTypeListDef_var mediatype= vcOutput->mtList();
+      for(CORBA::ULong j= 0; j < mediatype->length(); ++j)
+      {
+        Characteristics::MediaType::MediaTypeDef type = mediatype[j]->type();
+        data.mediatype.insert(type);
+        trace(_HERE_7, "> mediatype (%s) (%d)", mediaTypeDefText(type).c_str(), type);
+      }
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      rc= -1;
+      trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+    }
+    catch(...)
+    {
+      rc= -1;
+      trace(_HERE_1, "Exception:\n Cannot get type [%s][%s]", ec[i].realComponentName.in(), ec[i].virtualComponentName.in());
+    }
+  }
+  else if(!strcmp("Conveyor", ec[i].virtualComponentName))
+  {
+    try
+    {
+      corbaCallbackClientTerminator<Conveyor> cclnt(this, ec[i].virtualComponentRef);
+      Conveyor_ptr vcConveyor= cclnt.proxy();
+      ConveyorData& data= conveyor[i];
+      data.conveyortype= vcConveyor->typeOfConveyor();
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      rc= -1;
+      trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+    }
+    catch(...)
+    {
+      rc= -1;
+      trace(_HERE_1, "Exception:\n Cannot get typeOfConveyor [%s][%s]", ec[i].realComponentName.in(), ec[i].virtualComponentName.in());
+    }
+  }
+  else if(!strcmp("Dispenser", ec[i].virtualComponentName))
+  {
+    try
+    {
+      corbaCallbackClientTerminator<Dispenser> cclnt(this, ec[i].virtualComponentRef);
+      Dispenser_ptr vcDispenser= cclnt.proxy();
+      DispenserData& data= dispenser[i];
+      data.dispensertype= vcDispenser->kind();
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      rc= -1;
+      trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+    }
+    catch(...)
+    {
+      rc= -1;
+      trace(_HERE_1, "Exception:\n Cannot get kind [%s][%s]", ec[i].realComponentName.in(), ec[i].virtualComponentName.in());
+    }
+  }
+  if(rc != 0)
+  {
+    failed.insert(i);
+  }
+  return rc;
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   void amInterface::setAppReference(const char *pszAppRef)
+//
+//  purpose:    set application token explicitely
+//
+//  date:       12.09.00, 15:57
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void amInterface::setAppReference(const char *pszAppRef)
+{
+    if(pszAppRef)
+      strcpy(szAppRef, pszAppRef);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool amInterface::queryRealComponent(const char *pszRealCompName)
+//
+//  purpose:    Check if a real component is available in the platform
+//
+//  date:       28.11.00, 15:53
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+bool amInterface::queryRealComponent(const char *pszRealCompName)
+{
+bool fFound = false;
+CORBA::ULong i;
+
+    if(pszRealCompName && ec != NULL)
+    {
+      for(i = 0; i < ec->length() && !fFound; i++)
+      {
+        // check complete list of components
+
+        if(!strcmp(pszRealCompName, ec[i].realComponentName))
+          fFound = true;
+      }
+
+    }
+
+    return(fFound);
+}
+
+template<class Iterator, class Less>
+bool set_contains(Iterator i1, Iterator end1, Iterator i2, Iterator end2, Less less)
+{
+  bool result= true;
+  for(; i1 != end1 && i2 != end2; )
+  {
+    if(less(*i1, *i2))
+    {
+      ++i1;
+    }
+    else if(less(*i2, *i1))
+    {
+      result= false;
+      break;
+    }
+    else
+    {
+      ++i1;
+      ++i2;
+    }
+  }
+  if(i2 != end2)
+  {
+    result= false;
+  }
+  return result;
+}
+template<class Set>
+bool set_contains(const Set& s1, const Set& s2)
+{
+  return set_contains(s1.begin(), s1.end(), s2.begin(), s2.end(), s1.key_comp());
+}
+
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   const char* amInterface::queryMediaInput(long& lIndex, ...
+//
+//  purpose:    Return real componenet name the specified component
+//
+//  date:       28.03.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+const char* amInterface::queryMediaInput(long& lIndex, Characteristics::MediaInput::ReaderType readertype, Characteristics::ComponentFonts::BarcodeStandard barcodetype, MediaTypeSet& mediatype, DataTypeSet& datatype)
+{
+static char szComponentName[1024];
+bool        fFound;
+CORBA::ULong i;
+
+    i      = lIndex;
+    lIndex = -1;
+
+    if(ec != NULL)
+    {
+      for(fFound = false; i < ec->length() && !fFound; i++)
+      {
+        if(!strcmp("MediaInput", ec[i].virtualComponentName))
+        {
+          MediaInputMapping::const_iterator it= mediainput.find(i);
+          if(it != mediainput.end() && (*it).second.readertype == readertype && (*it).second.barcodetype == barcodetype)
+          {
+            if(set_contains((*it).second.mediatype, mediatype) && set_contains((*it).second.datatype, datatype))
+            {
+              fFound = true;
+
+              // save the IOR
+
+              strcpy(szComponentName, ec[i].realComponentName);
+
+              // return index, too
+
+              lIndex = i;
+            }
+          }
+        }
+      }
+
+      if(fFound)
+        return(szComponentName);
+      else
+        return(NULL);
+    }
+
+    return(NULL);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   const char* amInterface::queryMediaInput(long& lIndex, ...
+//
+//  purpose:    Return real componenet name the specified component
+//
+//  date:       09.10.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+const char* amInterface::queryMediaInputNegateBarcode(long& lIndex, Characteristics::MediaInput::ReaderType readertype, Characteristics::ComponentFonts::BarcodeStandard barcodetype, MediaTypeSet& mediatype, DataTypeSet& datatype)
+{
+static char szComponentName[1024];
+bool        fFound;
+CORBA::ULong i;
+
+    i      = lIndex;
+    lIndex = -1;
+
+    if(ec != NULL)
+    {
+      for(fFound = false; i < ec->length() && !fFound; i++)
+      {
+        if(!strcmp("MediaInput", ec[i].virtualComponentName))
+        {
+          MediaInputMapping::const_iterator it= mediainput.find(i);
+          if(it != mediainput.end() && (*it).second.readertype == readertype && (*it).second.barcodetype != barcodetype)
+          {
+            if(set_contains((*it).second.mediatype, mediatype) && set_contains((*it).second.datatype, datatype))
+            {
+              fFound = true;
+
+              // save the IOR
+
+              strcpy(szComponentName, ec[i].realComponentName);
+
+              // return index, too
+
+              lIndex = i;
+            }
+          }
+        }
+      }
+
+      if(fFound)
+        return(szComponentName);
+      else
+        return(NULL);
+    }
+
+    return(NULL);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   const char* amInterface::queryMediaInput(long& lIndex, ...
+//
+//  purpose:    Return real componenet name the specified component
+//
+//  date:       09.02.05
+//
+//  author:     Materna Information & Communications (TS)
+//
+//---------------------------------------------------------------------------
+
+const char* amInterface::queryMediaInputNegateBarcode(long& lIndex, Characteristics::ComponentFonts::BarcodeStandard barcodetype, MediaTypeSet& mediatype, DataTypeSet& datatype)
+{
+static char szComponentName[1024];
+bool        fFound;
+CORBA::ULong i;
+
+    i      = lIndex;
+    lIndex = -1;
+
+    if(ec != NULL)
+    {
+      for(fFound = false; i < ec->length() && !fFound; i++)
+      {
+        if(!strcmp("MediaInput", ec[i].virtualComponentName))
+        {
+          MediaInputMapping::const_iterator it= mediainput.find(i);
+          if(it != mediainput.end() && (*it).second.barcodetype != barcodetype)
+          {
+            if(set_contains((*it).second.mediatype, mediatype) && set_contains((*it).second.datatype, datatype))
+            {
+              fFound = true;
+
+              // save the IOR
+
+              strcpy(szComponentName, ec[i].realComponentName);
+
+              // return index, too
+
+              lIndex = i;
+            }
+          }
+        }
+      }
+
+      if(fFound)
+        return(szComponentName);
+      else
+        return(NULL);
+    }
+
+    return(NULL);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   const char* amInterface::queryMediaInput(long& lIndex, ...
+//
+//  purpose:    Return real componenet name the specified component
+//
+//  date:       09.02.05
+//
+//  author:     Materna Information & Communications (TS)
+//
+//---------------------------------------------------------------------------
+
+const char* amInterface::queryMediaInput(long& lIndex, Characteristics::ComponentFonts::BarcodeStandard barcodetype, MediaTypeSet& mediatype, DataTypeSet& datatype)
+{
+static char szComponentName[1024];
+bool        fFound;
+CORBA::ULong i;
+
+    i      = lIndex;
+    lIndex = -1;
+
+    if(ec != NULL)
+    {
+      for(fFound = false; i < ec->length() && !fFound; i++)
+      {
+        if(!strcmp("MediaInput", ec[i].virtualComponentName))
+        {
+          MediaInputMapping::const_iterator it= mediainput.find(i);
+          if(it != mediainput.end() && (*it).second.barcodetype == barcodetype)
+          {
+            if(set_contains((*it).second.mediatype, mediatype) && set_contains((*it).second.datatype, datatype))
+            {
+              fFound = true;
+
+              // save the IOR
+
+              strcpy(szComponentName, ec[i].realComponentName);
+
+              // return index, too
+
+              lIndex = i;
+            }
+          }
+        }
+      }
+
+      if(fFound)
+        return(szComponentName);
+      else
+        return(NULL);
+    }
+
+    return(NULL);
+}
+//---------------------------------------------------------------------------
+//
+//  function:   const char* amInterface::queryMediaInput(long& lIndex, ...
+//
+//  purpose:    Return real componenet name the specified component
+//
+//  date:       09.02.05
+//
+//  author:     Materna Information & Communications (TS)
+//
+//---------------------------------------------------------------------------
+
+const char* amInterface::queryMediaInput(long& lIndex, Characteristics::MediaInput::ReaderType readertype, MediaTypeSet& mediatype, DataTypeSet& datatype)
+{
+static char szComponentName[1024];
+bool        fFound;
+CORBA::ULong i;
+
+    i      = lIndex;
+    lIndex = -1;
+
+    if(ec != NULL)
+    {
+      for(fFound = false; i < ec->length() && !fFound; i++)
+      {
+        if(!strcmp("MediaInput", ec[i].virtualComponentName))
+        {
+          MediaInputMapping::const_iterator it= mediainput.find(i);
+          if(it != mediainput.end() && (*it).second.readertype == readertype)
+          {
+            if(set_contains((*it).second.mediatype, mediatype) && set_contains((*it).second.datatype, datatype))
+            {
+              fFound = true;
+
+              // save the IOR
+
+              strcpy(szComponentName, ec[i].realComponentName);
+
+              // return index, too
+
+              lIndex = i;
+            }
+          }
+        }
+      }
+
+      if(fFound)
+        return(szComponentName);
+      else
+        return(NULL);
+    }
+
+    return(NULL);
+}
+//---------------------------------------------------------------------------
+//
+//  function:   const char* amInterface::queryMediaInput(long& lIndex, ...
+//
+//  purpose:    Return real componenet name the specified component
+//
+//  date:       09.02.05
+//
+//  author:     Materna Information & Communications (TS)
+//
+//---------------------------------------------------------------------------
+const char* amInterface::queryMediaInput(long& lIndex, MediaTypeSet& mediatype, DataTypeSet& datatype)
+{
+static char szComponentName[1024];
+bool        fFound;
+CORBA::ULong i;
+
+    i      = lIndex;
+    lIndex = -1;
+
+    if(ec != NULL)
+    {
+      for(fFound = false; i < ec->length() && !fFound; i++)
+      {
+        if(!strcmp("MediaInput", ec[i].virtualComponentName))
+        {
+          MediaInputMapping::const_iterator it= mediainput.find(i);
+          if(it != mediainput.end() && set_contains((*it).second.mediatype, mediatype) && set_contains((*it).second.datatype, datatype))
+          {
+            fFound = true;
+
+            // save the IOR
+
+            strcpy(szComponentName, ec[i].realComponentName);
+
+            // return index, too
+
+            lIndex = i;
+          }
+        }
+      }
+
+      if(fFound)
+        return(szComponentName);
+      else
+        return(NULL);
+    }
+
+    return(NULL);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   const char* amInterface::queryMediaOutput(long& lIndex, ...
+//
+//  purpose:    Return real componenet name the specified component
+//
+//  date:       09.02.05
+//
+//  author:     Materna Information & Communications (TS)
+//
+//---------------------------------------------------------------------------
+
+const char* amInterface::queryMediaOutput(long& lIndex, Characteristics::MediaOutput::MediaType writertype, MediaTypeSet& mediatype, DataTypeSet& datatype)
+{
+static char szComponentName[1024];
+bool        fFound;
+CORBA::ULong i;
+
+    i      = lIndex;
+    lIndex = -1;
+
+    if(ec != NULL)
+    {
+      for(fFound = false; i < ec->length() && !fFound; i++)
+      {
+        if(!strcmp("MediaOutput", ec[i].virtualComponentName))
+        {
+          MediaOutputMapping::const_iterator it= mediaoutput.find(i);
+          if(it == mediaoutput.end())
+            trace(_HERE_7, "no mediaoutput %d", i);
+          else if((*it).second.writertype != writertype)
+            trace(_HERE_7, "writetype not supported; index: %d; found: (%s) (%d); needed: (%s) (%d)", i, mediaTypeText((*it).second.writertype).c_str(), (*it).second.writertype, mediaTypeText(writertype).c_str(), writertype);
+          else if(!set_contains((*it).second.mediatype, mediatype))
+            trace(_HERE_7, "mediatype not supported; index: %d", i);
+          else if(!set_contains((*it).second.datatype, datatype))
+            trace(_HERE_7, "datatype not supported; index: %d", i);
+          else
+          {
+            fFound = true;
+
+            // save the IOR
+
+            strcpy(szComponentName, ec[i].realComponentName);
+
+            // return index, too
+
+            lIndex = i;
+          }
+        }
+      }
+
+      if(fFound)
+        return(szComponentName);
+      else
+        return(NULL);
+    }
+
+    return(NULL);
+}
+//---------------------------------------------------------------------------
+//
+//  function:   const char* amInterface::queryMediaOutput(long& lIndex, ...
+//
+//  purpose:    Return real componenet name the specified component
+//
+//  date:       09.02.05
+//
+//  author:     Materna Information & Communications (TS)
+//
+//---------------------------------------------------------------------------
+
+const char* amInterface::queryMediaOutput(long& lIndex, MediaTypeSet& mediatype, DataTypeSet& datatype)
+{
+static char szComponentName[1024];
+bool        fFound;
+CORBA::ULong i;
+
+    i      = lIndex;
+    lIndex = -1;
+
+    if(ec != NULL)
+    {
+      for(fFound = false; i < ec->length() && !fFound; i++)
+      {
+        if(!strcmp("MediaOutput", ec[i].virtualComponentName))
+        {
+          MediaOutputMapping::const_iterator it= mediaoutput.find(i);
+          if(it == mediaoutput.end())
+            trace(_HERE_7, "no mediaoutput %d", i);
+          else if(!set_contains((*it).second.mediatype, mediatype))
+            trace(_HERE_7, "mediatype not supported %d", i);
+          else if(!set_contains((*it).second.datatype, datatype))
+            trace(_HERE_7, "datatype not supported %d", i);
+          else
+          {
+            fFound = true;
+
+            // save the IOR
+
+            strcpy(szComponentName, ec[i].realComponentName);
+
+            // return index, too
+
+            lIndex = i;
+          }
+        }
+      }
+
+      if(fFound)
+        return(szComponentName);
+      else
+        return(NULL);
+    }
+
+    return(NULL);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   const char* amInterface::queryConveyor(long& lIndex, ...
+//
+//  purpose:    Return real componenet name the specified component
+//
+//  date:       09.02.05
+//
+//  author:     Materna Information & Communications (TS)
+//
+//---------------------------------------------------------------------------
+
+const char* amInterface::queryConveyor(long& lIndex, Characteristics::Conveyor::ConveyorType conveyortype)
+{
+static char szComponentName[1024];
+bool        fFound;
+CORBA::ULong i;
+
+    i      = lIndex;
+    lIndex = -1;
+
+    if(ec != NULL)
+    {
+      for(fFound = false; i < ec->length() && !fFound; i++)
+      {
+        if(!strcmp("Conveyor", ec[i].virtualComponentName))
+        {
+          ConveyorMapping::const_iterator it= conveyor.find(i);
+          if(it != conveyor.end() && (*it).second.conveyortype == conveyortype)
+          {
+            fFound = true;
+
+            // save the IOR
+
+            strcpy(szComponentName, ec[i].realComponentName);
+
+            // return index, too
+
+            lIndex = i;
+          }
+        }
+      }
+
+      if(fFound)
+        return(szComponentName);
+      else
+        return(NULL);
+    }
+
+    return(NULL);
+}
+//---------------------------------------------------------------------------
+//
+//  function:   const char* amInterface::queryConveyor(long& lIndex, ...
+//
+//  purpose:    Return real componenet name the specified component
+//
+//  date:       09.02.05
+//
+//  author:     Materna Information & Communications (TS)
+//
+//---------------------------------------------------------------------------
+
+const char* amInterface::queryConveyor(long& lIndex)
+{
+static char szComponentName[1024];
+bool        fFound;
+CORBA::ULong i;
+
+    i      = lIndex;
+    lIndex = -1;
+
+    if(ec != NULL)
+    {
+      for(fFound = false; i < ec->length() && !fFound; i++)
+      {
+        if(!strcmp("Conveyor", ec[i].virtualComponentName))
+        {
+          fFound = true;
+
+          // save the IOR
+
+          strcpy(szComponentName, ec[i].realComponentName);
+
+          // return index, too
+
+          lIndex = i;
+        }
+      }
+
+      if(fFound)
+        return(szComponentName);
+      else
+        return(NULL);
+    }
+
+    return(NULL);
+}
+//---------------------------------------------------------------------------
+//
+//  function:   const char *amInterface::ior(long& lIndex, const char *pszRealCompName, ...
+//
+//  purpose:    Return CORB::IOR for the specified component
+//
+//  date:       28.11.00, 14:18
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+const char *amInterface::ior(long& lIndex, const char *pszRealCompName, const char *pszVirtualCompName)
+{
+static char szIOR[1024];
+bool        fFound;
+CORBA::ULong i;
+
+    i      = lIndex;
+    lIndex = -1;
+
+    if(pszRealCompName && pszVirtualCompName && ec != NULL)
+    {
+      for(fFound = false; i < ec->length() && !fFound; i++)
+      {
+        // check first level
+
+        if(!strcmp(pszRealCompName, ec[i].realComponentName))
+        {
+          if(!strcmp(pszVirtualCompName, ec[i].virtualComponentName))
+          {
+            fFound = true;
+
+            // save the IOR
+
+            strcpy(szIOR, ec[i].virtualComponentRef);
+
+            // return index, too
+
+            lIndex = i;
+          }
+        }
+      }
+
+      if(fFound)
+        return(szIOR);
+      else
+        return(NULL);
+    }
+
+    return(NULL);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   const char *amInterface::iorLinked(const long lIndex,
+//                                                 long& lStartIndex,
+//                                                 const char *pszVirtualCompName)
+//
+//  purpose:    Return CORB::IOR for the specified linked component
+//
+//  date:       25.04.2002, 12:02
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+const char *amInterface::iorLinked(const long lIndex, long& lStartIndex, const char *pszVirtualCompName)
+{
+static char szIOR[1024];
+bool        fFound;
+CORBA::ULong i, index, link;
+
+    if(ec != NULL && lIndex >= 0 && lStartIndex >= 0 && lIndex < static_cast<long>(ec->length()) && pszVirtualCompName)
+    {
+      //trace(_HERE_7, "iorLinked <- (rootComp = %d, startIndex = %d)", lIndex, lStartIndex);
+
+      index = lIndex;
+
+      i = lStartIndex;
+      lStartIndex = -1;
+
+      for(fFound = false; i < ec[index].linkedComponents.length() && !fFound; i++)
+      {
+        link = ec[index].linkedComponents[i];
+
+        //trace(_HERE_7, "checking  linked component [%d](%s)", link, ec[link].virtualComponentName);
+
+        if(!strcmp(pszVirtualCompName, ec[link].virtualComponentName))
+        {
+          // found !!
+
+          trace(_HERE_7, "returning linked component [%d](%s) for component [%d](%s)",
+                       link,
+                       ec[link].virtualComponentName.in(),
+                       lIndex,
+                       ec[index].virtualComponentName.in());
+
+          fFound = true;
+
+          // save the IOR
+
+          strcpy(szIOR, ec[link].virtualComponentRef);
+
+          // return start index, too
+
+          lStartIndex = i;
+        }
+      }
+
+      //trace(_HERE_7, "iorLinked -> (rootComp = %d, startIndex = %d)", lIndex, lStartIndex);
+
+      if(fFound)
+        return(szIOR);
+      else
+        return(NULL);
+    }
+
+    return(NULL);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   const char *amInterface::iorLinked(const long lIndex,
+//                                                 long& lStartIndex,
+//                                                 Characteristics::Dispenser::DispenserType dispensertype)
+//
+//  purpose:    Return CORB::IOR for the specified linked component
+//
+//  date:       25.04.2002, 12:02
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+const char *amInterface::iorLinked(const long lIndex, long& lStartIndex, Characteristics::Dispenser::DispenserType dispensertype)
+{
+static char szIOR[1024];
+bool        fFound;
+CORBA::ULong i, index, link;
+
+    if(ec != NULL && lIndex >= 0 && lStartIndex >= 0 && lIndex < static_cast<long>(ec->length()))
+    {
+      //trace(_HERE_7, "iorLinked <- (rootComp = %d, startIndex = %d)", lIndex, lStartIndex);
+
+      index = lIndex;
+
+      i = lStartIndex;
+      lStartIndex = -1;
+
+      for(fFound = false; i < ec[index].linkedComponents.length() && !fFound; i++)
+      {
+        link = ec[index].linkedComponents[i];
+
+        //trace(_HERE_7, "checking  linked component [%d](%s)", link, ec[link].virtualComponentName);
+
+        if(!strcmp("Dispenser", ec[link].virtualComponentName) && (dispenser[link].dispensertype == dispensertype))
+        {
+          // found !!
+
+          trace(_HERE_7, "returning linked component [%d](%s) for component [%d](%s)",
+                       link,
+                       ec[link].virtualComponentName.in(),
+                       lIndex,
+                       ec[index].virtualComponentName.in());
+
+          fFound = true;
+
+          // save the IOR
+
+          strcpy(szIOR, ec[link].virtualComponentRef);
+
+          // return start index, too
+
+          lStartIndex = i;
+        }
+      }
+
+      //trace(_HERE_7, "iorLinked -> (rootComp = %d, startIndex = %d)", lIndex, lStartIndex);
+
+      if(fFound)
+        return(szIOR);
+      else
+        return(NULL);
+    }
+
+    return(NULL);
+}
+/** Query all linked components from the components table.
+    @param lIndex - Index of component with linked components
+*/
+void amInterface::queryLinkedComponents(long lIndex,  std::list<long>& linked, const char *pszVirtualCompName)
+{
+  std::vector<ComponentTraversal> visit(ec->length(), NOT_FOUND);
+  bool active= false;
+  CORBA::ULong i= lIndex;
+  CORBA::ULong j;
+  if(i < ec->length())
+  {
+    if(!pszVirtualCompName)
+    {
+      linked.push_back(i);
+    }
+    else if(strcmp(pszVirtualCompName, ec[i].virtualComponentName) == 0)
+    {
+      linked.push_back(i);
+    }
+    visit[i]= VISITED;
+    active= true;
+  }
+  while(active)
+  {
+    for(j= 0; j < ec[i].linkedComponents.length(); j++)
+    {
+      if(visit[ec[i].linkedComponents[j]] == NOT_FOUND)
+      {
+        visit[ec[i].linkedComponents[j]]= FOUND;
+      }
+    }
+    active= false;
+    for(i= 0; i < ec->length(); ++i)
+    {
+      if(visit[i] == FOUND)
+      {
+        if(!pszVirtualCompName)
+        {
+          linked.push_back(i);
+        }
+        else if(strcmp(pszVirtualCompName, ec[i].virtualComponentName) == 0)
+        {
+          linked.push_back(i);
+        }
+        visit[i]= VISITED;
+        active= true;
+        break;
+      }
+    }
+  }
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   const char *amInterface::iorExclude(long&       lIndex,
+//                                                  const char *pszRealCompName,
+//                                                  const char *pszVirtualCompName,
+//                                                  const char *pszE1,
+//                                                  const char *pszE2)
+//
+//  purpose:    find IOR of component NOT containing E1 and E2 in
+//              linked component list
+//
+//  date:       24.04.2002, 10:09
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+const char *amInterface::iorExclude(long&       lIndex,
+                                    const char *pszRealCompName,
+                                    const char *pszVirtualCompName,
+                                    const char *pszE1,
+                                    const char *pszE2)
+{
+static char szIOR[1024];
+bool        fFound;
+bool        fExclude;
+char        szE1[256];
+char        szE2[256];
+
+CORBA::ULong i, j, linked;
+
+    i      = lIndex;
+    lIndex = -1;
+
+    if(pszRealCompName && pszVirtualCompName && ec != NULL)
+    {
+      for(fFound = false; i < ec->length() && !fFound; i++)
+      {
+        // check first level
+
+        if(!strcmp(pszRealCompName, ec[i].realComponentName))
+        {
+          if(!strcmp(pszVirtualCompName, ec[i].virtualComponentName))
+          {
+            if(pszE1 || pszE2)
+            {
+              for(j = 0, fExclude = false; j < ec[i].linkedComponents.length() && !fExclude; j++)
+              {
+                pszE1 ? strcpy(szE1, pszE1) : strcpy(szE1, "???");
+                pszE2 ? strcpy(szE2, pszE2) : strcpy(szE2, "???");
+
+                // check linked components for excludes
+
+                linked = ec[i].linkedComponents[j];
+
+                if(!strcmp(szE1, ec[linked].virtualComponentName) ||
+                   !strcmp(szE2, ec[linked].virtualComponentName)   )
+                {
+                  // found exclude1 or exclude2 in linked list
+
+/*
+                  trace(_HERE_7, "exclude [%d] --> [%d] for %s, %s (%s, %s)",
+                               i, linked,
+                               pszRealCompName,
+                               pszVirtualCompName,
+                               pszE1 ? pszE1 : "NULL",
+                               pszE2 ? pszE2 : "NULL");
+*/
+                  fExclude = true;
+                }
+              }
+            }
+
+            // found component that matches ??
+
+            if(!fExclude)
+            {
+              fFound = true;
+
+              trace(_HERE_7, "returning comp [%d] for (%s, %s) excluded %s | %s, noOfLinkedComps = %d",
+                           i,
+                           pszRealCompName,
+                           pszVirtualCompName,
+                           pszE1 ? pszE1 : "NULL",
+                           pszE2 ? pszE2 : "NULL",
+                           ec[i].linkedComponents.length());
+
+              // save the IOR
+
+              strcpy(szIOR, ec[i].virtualComponentRef);
+
+              // return index, too
+
+              lIndex = i;
+            }
+          }
+        }
+      }
+
+      if(fFound)
+        return(szIOR);
+      else
+        return(NULL);
+    }
+
+    return(NULL);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   const char *amInterface::iorExclude(long&       lIndex,
+//                                                  const char *pszRealCompName,
+//                                                  const char *pszVirtualCompName,
+//                                                  const char *pszI1,
+//                                                  const char *pszI2)
+//
+//  purpose:    find IOR of component containing I1 or I2 in
+//              linked component list
+//
+//  date:       24.04.2002, 10:09
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+const char *amInterface::iorInclude(long&       lIndex,
+                                    const char *pszRealCompName,
+                                    const char *pszVirtualCompName,
+                                    const char *pszI1,
+                                    const char *pszI2)
+{
+static char szIOR[1024];
+bool        fFound;
+bool        fInclude1;
+bool        fInclude2;
+
+CORBA::ULong i, j, linked;
+
+    i      = lIndex;
+    lIndex = -1;
+
+    if(pszRealCompName && pszVirtualCompName && ec != NULL)
+    {
+      for(fFound = false; i < ec->length() && !fFound; i++)
+      {
+        // check first level
+
+        if(!strcmp(pszRealCompName, ec[i].realComponentName))
+        {
+          if(!strcmp(pszVirtualCompName, ec[i].virtualComponentName))
+          {
+            fInclude1 = fInclude2 = false;
+
+            if(pszI1 && *pszI1)
+            {
+              for(j = 0; j < ec[i].linkedComponents.length() && !fInclude1; j++)
+              {
+                // check linked components for necessary includes
+
+                linked = ec[i].linkedComponents[j];
+
+                if(!strcmp(pszI1, ec[linked].virtualComponentName))
+                {
+                  // found include1
+
+                  fInclude1 = true;
+
+/*
+                  trace(_HERE_7, "found --> [%d] for %s, %s 1=(%s)",
+                               linked,
+                               pszRealCompName,
+                               pszVirtualCompName,
+                               pszI1 ? pszI1 : "NULL");
+*/
+                }
+              }
+            }
+            else
+              fInclude1 = true; // I1 not specified -> Ok.
+
+            if(pszI2 && *pszI2)
+            {
+              for(j = 0, fInclude2 = false; j < ec[i].linkedComponents.length() && !fInclude2; j++)
+              {
+                // check linked components for necessary includes
+
+                linked = ec[i].linkedComponents[j];
+
+                if(!strcmp(pszI2, ec[linked].virtualComponentName))
+                {
+                  // found exclude1 or exclude2 in linked list
+
+                  fInclude2 = true;
+/*
+                  trace(_HERE_7, "found --> [%d] for %s, %s 2=(%s)",
+                               linked,
+                               pszRealCompName,
+                               pszVirtualCompName,
+                               pszI2 ? pszI2 : "NULL");
+*/
+                }
+              }
+            }
+            else
+              fInclude2 = true; // I2 not specified -> Ok.
+
+            // found component that matches ??
+
+            if(fInclude1 && fInclude2)
+            {
+              fFound = true;
+
+              // save the IOR
+
+              trace(_HERE_7, "returning comp [%d] for (%s, %s) included %s | %s, noOfLinkedComps = %d",
+                           i,
+                           pszRealCompName,
+                           pszVirtualCompName,
+                           pszI1 ? pszI1 : "NULL",
+                           pszI2 ? pszI2 : "NULL",
+                           ec[i].linkedComponents.length());
+
+              strcpy(szIOR, ec[i].virtualComponentRef);
+
+              // return index, too
+
+              lIndex = i;
+            }
+          }
+        }
+      }
+
+      if(fFound)
+        return(szIOR);
+      else
+        return(NULL);
+    }
+
+    return(NULL);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   const char *amInterface::iorInclude(long& lIndex,
+//                                                  const char *pszRealCompName,
+//                                                  const char *pszInclude,
+//                                                  Characteristics::Dispenser::DispenserType dispensertype)
+//
+//  purpose:    find IOR of component containing I1 or I2 in
+//              linked component list
+//
+//  date:       24.04.2002, 10:09
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+const char*amInterface::iorInclude(long& lIndex,
+                                   const char *pszRealCompName,
+                                   const char *pszInclude,
+                                   Characteristics::Dispenser::DispenserType dispensertype)
+{
+static char szIOR[1024];
+bool        fFound;
+CORBA::ULong i, j, linked;
+
+    i      = lIndex;
+    lIndex = -1;
+
+    if(pszRealCompName && ec != NULL)
+    {
+      for(fFound = false; i < ec->length() && !fFound; i++)
+      {
+        // check first level
+        if(!strcmp(pszRealCompName, ec[i].realComponentName))
+        {
+          if(!strcmp("Dispenser", ec[i].virtualComponentName))
+          {
+            if(dispenser[i].dispensertype == dispensertype)
+            {
+              if(pszInclude && *pszInclude)
+              {
+                for(j = 0; j < ec[i].linkedComponents.length() && !fFound; j++)
+                {
+                  // check linked components for necessary includes
+                  linked = ec[i].linkedComponents[j];
+                  if(!strcmp(pszInclude, ec[linked].virtualComponentName))
+                  {
+                    // found include
+                    fFound = true;
+                  }
+                }
+              }
+              else
+                fFound = true; // I1 not specified -> Ok.
+            }
+
+            // found component that matches ??
+
+            if(fFound)
+            {
+              // save the IOR
+              trace(_HERE_7, "returning comp [%d] for (%s) included %s | type %d, noOfLinkedComps = %d",
+                           i,
+                           pszRealCompName,
+                           pszInclude ? pszInclude : "NULL",
+                           dispensertype,
+                           ec[i].linkedComponents.length());
+
+              strcpy(szIOR, ec[i].virtualComponentRef);
+              // return index, too
+              lIndex = i;
+            }
+          }
+        }
+      }
+
+      if(fFound)
+        return szIOR;
+      else
+        return NULL;
+    }
+    return(NULL);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   long amInterface::noOfComponents()
+//
+//  purpose:    return number of virtual components found
+//
+//  date:       12.09.00, 14:28
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long amInterface::noOfComponents()
+{
+long n;
+CORBA::ULong i;
+
+    if(ec)
+    {
+      // no of first level comonents
+
+      n = ec->length();
+
+      for(i = 0; i < ec->length(); i++)
+      {
+        // check no of second level components
+
+        n += ec[i].linkedComponents.length();
+      }
+
+      return(n);
+    }
+    else
+    {
+      lError = -1;
+      return(error());
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long amInterface::error()
+//
+//  purpose:    returns current error
+//
+//  date:       12.09.00, 14:23
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long amInterface::error()
+{
+    return(lError);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long amInterface::connect(char *pszIOR)
+//
+//  purpose:    connect the application manager
+//
+//  date:       21.12.00, 10:17
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long amInterface::connect(char *pszIOR)
+{
+int  i;
+bool fDone;
+char szIOR[1024];
+long rc = 0;
+
+    // still somthing to do ??
+
+    if(!CORBA::is_nil(ami))
+    {
+      // return immediately if already connected
+      return(0);
+    }
+
+    strcpy(szIOR, pszIOR);
+    _strlwr(szIOR);
+
+    if(strstr(szIOR, "corbaloc:") != szIOR && strstr(szIOR, "ior:") != szIOR)
+    {
+      // IP address/name only ?? -> build corbaloc ior
+      sprintf(szIOR, "corbaloc::%s:20000/ApplicationManager", pszIOR);
+    }
+    else
+      strcpy(szIOR, pszIOR);
+    iorRef= szIOR;
+
+    for(i = 0, fDone = FALSE; i < 30 && !fDone; i++)
+    {
+      try
+      {
+        // everything OK ??
+        if(connect())
+        {
+          trace(_HERE_7, "app manager connected");
+          fDone = true;
+        }
+        else
+        {
+          trace(_HERE_7, "app manager not connected\nior = [%s]", pszIOR);
+          rc = -1;
+        }
+      }
+      catch(CORBA::SystemException& ex)
+      {
+        trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+        rc = -1;
+      }
+    }
+    if(!rc)
+      fConnected = true;
+    return(rc);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   amInterface::amInterface(char *pszIOR)
+//
+//  purpose:    class constructor
+//
+//  date:       12.09.00, 13:31
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+amInterface::amInterface(char *pszIOR,
+                         char *pszCompanyCode,
+                         char *pszApplicationName,
+                         char *pszVendorCode):
+                         state(CS_NOT_CONNECTED),
+                         registered(false)
+{
+long rc;
+
+    cclnt      = NULL;
+    ami        = NULL;
+    ec         = NULL;
+    el         = NULL;
+    fConnected = false;
+
+    *szAppRef          = '\0';
+    *szApplicationName = '\0';
+    *szCompanyCode     = '\0';
+
+    if(pszCompanyCode)
+      strcpy(szCompanyCode, pszCompanyCode);
+
+    if(pszApplicationName)
+      strcpy(szApplicationName, pszApplicationName);
+
+    if(pszVendorCode)
+      strcpy(szVendorCode, pszVendorCode);
+    else
+      strcpy(szVendorCode, "MAT");
+
+    akid.companyCode     = string_dup(szCompanyCode);
+    akid.applicationName = string_dup(szApplicationName);
+    akid.vendorCode      = string_dup(szVendorCode);
+    akid.kioskName       = string_dup("None");
+
+    if(pszIOR && *pszIOR)
+      rc = connect(pszIOR);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   amInterface::~amInterface()
+//
+//  purpose:    class destructor
+//
+//  date:       06.09.00, 11:39
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+amInterface::~amInterface()
+{
+    if(cclnt) delete cclnt;
+}
+
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/atb2.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/atb2.cpp
new file mode 100644
index 00000000..4b8d87f6
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/atb2.cpp
@@ -0,0 +1,2642 @@
+//---------------------------------------------------------------------------
+//
+//  file:       atb2.cpp
+//
+//  purpose:    atb2 device implementation
+//
+//  date:       14.09.00
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+//#define SHOW_INCLUDE_FILES
+
+#include "cussif.h"
+#include "bppdev.h"
+#include "check.h"
+#include "tracedef.h"
+#include "orbs.h"
+
+#include "atb2Scanner.h"
+#include "textIDL/textcodes.h"
+#include "textIDL/texttypes.h"
+#include "textIDL/textcharacteristics.h"
+
+using namespace MASSAI::codes_text;
+using namespace MASSAI::characteristics_text;
+using namespace MASSAI::types_text;
+
+//#define SUPERUSER  // uses "moohuhn" token
+
+#define NSC_MI Characteristics::MediaInput
+
+using namespace MASSAI;
+
+namespace
+{
+  Characteristics::MediaOutput::MediaType getPaperTypeMediaOutput(bppDevice::papertype paper)
+  {
+    switch(paper)
+    {
+      case bppDevice::PT_TICKET:               return Characteristics::MediaOutput::Ticket;
+      case bppDevice::PT_BOARDINGPASS:         return Characteristics::MediaOutput::BoardingPass;
+      case bppDevice::PT_INSERTEDDOC:          return Characteristics::MediaOutput::InsertedDoc;
+      case bppDevice::PT_GENERALPURPOSEDOC:    return Characteristics::MediaOutput::GeneralPurposeDoc;
+      case bppDevice::PT_BOARDINGPASSFIRST:    return Characteristics::MediaOutput::BoardingPassFirst;
+      case bppDevice::PT_BOARDINGPASSBUSINESS: return Characteristics::MediaOutput::BoardingPassBusiness;
+      case bppDevice::PT_BOARDINGPASSECONOMY:  return Characteristics::MediaOutput::BoardingPassEconomy;
+      default:                                 return Characteristics::MediaOutput::BoardingPass;
+    }
+  }
+  int getFeederPriority(int state)
+  {
+    switch(state)
+    {
+      case m_statuscodes::OK:                      return 0;
+      case m_statuscodes::MEDIA_HIGH:              return 1;
+      case m_statuscodes::MEDIA_FULL:              return 2;
+      case m_statuscodes::MEDIA_LOW:               return 3;
+      case m_statuscodes::MEDIA_EMPTY:             return 4;
+      case m_statuscodes::TIMEOUT:                 return 5;
+      case m_statuscodes::WRONG_STATE:             return 6;
+      case m_statuscodes::CANCELLED:               return 7;
+      case m_statuscodes::SOFTWARE_ERROR:          return 8;
+      case m_statuscodes::MEDIA_JAMMED:            return 9;
+      case m_statuscodes::MEDIA_MISPLACED:         return 10;
+      case m_statuscodes::HARDWARE_ERROR:          return 11;
+      case m_statuscodes::CRITICAL_SOFTWARE_ERROR: return 12;
+      case m_statuscodes::NOT_REACHABLE:           return 13;
+      case m_statuscodes::NOT_RESPONDING:          return 14;
+      case m_statuscodes::THRESHOLD_ERROR:         return 15;
+      case m_statuscodes::THRESHOLD_USAGE:         return 16;
+      case m_statuscodes::CONFIGURATION_ERROR:     return 17;
+      case m_returncodes::RC_REFERENCE:            return 19;
+      case m_returncodes::RC_STATE:                return 20;
+      case m_returncodes::RC_DENIED:               return 21;
+      case m_returncodes::RC_PARAMETER:            return 22;
+      case m_returncodes::RC_ANY_PARAMETER:        return 23;
+      case m_returncodes::RC_LISTENER:             return 24;
+      case m_returncodes::RC_SHARE:                return 25;
+      case m_returncodes::RC_UNAUTHORIZED:         return 26;
+      case m_returncodes::RC_ERROR:                return 27;
+      case m_returncodes::RC_NOT_SUPPORTED:        return 28;
+      case missingComponent:                       return 29;
+      default:                                     return 30;
+    }
+  }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long bppDevice::tktDocsAvailable()
+//
+//  purpose:    return the number of available docs
+//
+//  date:       31.07.2002, 09:56
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long bppDevice::tktDocsAvailable()
+{
+long  noOfDocsAvailable = 0;
+long  i, j;
+
+    for(i = 0; i < 3 && vcWriterBin[i].vcWriter.isConnected(); i++)
+    {
+      if(MediaOutput::Ticket == vcWriterBin[i].vcWriter.getType())
+      {
+        for(j = 0; j < 3 && vcWriterBin[i].vcBin[j].isConnected(); j++)
+          noOfDocsAvailable += vcWriterBin[i].vcBin[j].getCurrentNoOfDocuments();
+
+        trace(_HERE_7, "no. of docs for MediaOutput::Ticket = %d", noOfDocsAvailable);
+      }
+    }
+
+    return noOfDocsAvailable;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long bppDevice::bpDocsAvailable(int boardingclass=0)
+//
+//  purpose:    return the number of available docs
+//
+//  date:       31.07.2002, 09:56
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long bppDevice::bpDocsAvailable(int boardingclass)
+{
+long  noOfDocsAvailable = 0;
+long  i, j;
+
+    trace(_HERE_7, "bpDocsAvailable called for BoardingPass Class = %d", boardingclass);
+
+    for(i = 0; i < 3 && vcWriterBin[i].vcWriter.isConnected(); i++)
+    {
+      Characteristics::MediaOutput::MediaType type= vcWriterBin[i].vcWriter.getType();
+      trace(_HERE_7, "vcWriterBin[i].vcWriter.type() = (%s) (%d)", mediaTypeText(type).c_str(), type);
+
+      if(((boardingclass==0) && (type == MediaOutput::BoardingPass))
+      || ((boardingclass==1) && (type == MediaOutput::BoardingPassFirst))
+      || ((boardingclass==2) && (type == MediaOutput::BoardingPassBusiness))
+      || ((boardingclass==3) && (type == MediaOutput::BoardingPassEconomy)))
+      {
+        for(j = 0; j < 3 && vcWriterBin[i].vcBin[j].isConnected(); j++)
+          noOfDocsAvailable += vcWriterBin[i].vcBin[j].getCurrentNoOfDocuments();
+
+        trace(_HERE_7, "no. of docs for MediaOutput::BoardingPass = %d", noOfDocsAvailable);
+      }
+    }
+
+    return noOfDocsAvailable;
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   long bppDevice::gpDocsAvailable()
+//
+//  purpose:    return the number of available docs
+//
+//  date:       31.07.2002, 09:56
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long bppDevice::gpDocsAvailable()
+{
+long  noOfDocsAvailable = 0;
+long  i, j;
+
+    for(i = 0; i < 3 && vcWriterBin[i].vcWriter.isConnected(); i++)
+    {
+      if(vcWriterBin[i].vcWriter.getType() == MediaOutput::GeneralPurposeDoc)
+      {
+        for(j = 0; j < 3 && vcWriterBin[i].vcBin[j].isConnected(); j++)
+          noOfDocsAvailable += vcWriterBin[i].vcBin[j].getCurrentNoOfDocuments();
+
+        trace(_HERE_7, "no. of docs for MediaOutput::GeneralPurposeDoc = %d", noOfDocsAvailable);
+      }
+    }
+
+    return noOfDocsAvailable;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool bppDevice::hasPaperTypeSupport(papertype paper)
+//
+//  purpose:    Checks if the device supports a specified papertype.
+//
+//  date:       08.03.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+bool bppDevice::hasPaperTypeSupport(papertype paper)
+{
+  bool result= false;
+
+  Characteristics::MediaOutput::MediaType type= getPaperTypeMediaOutput(paper);
+  for(int i= 0; i < 3 && vcWriterBin[i].vcWriter.isConnected(); i++)
+  {
+    if(type == vcWriterBin[i].vcWriter.getType())
+    {
+      result= true;
+      break;
+    }
+  }
+
+  return result;
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   Characteristics::IOMode::InputOutputMode bppDevice::ioMode()
+//
+//  purpose:    Return current IO-Mode for BPP device
+//
+//  date:       24.06.2002, 13:51
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+Characteristics::IOMode::InputOutputMode bppDevice::ioMode()
+{
+    if(vcWriter.isConnected())
+      return vcWriter.getMode();
+    else
+    {
+      vCompWriter::lError = missingComponent;
+      return Characteristics::IOMode::nonApplicableInputOutputMode;
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long bppDevice::setIOMode(Characteristics::IOMode::InputOutputMode ioMode)
+//
+//  purpose:    Set new IO-Mode for BPP device
+//
+//  date:       24.06.2002, 13:52
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long bppDevice::setIOMode(Characteristics::IOMode::InputOutputMode ioMode)
+{
+long rc = -1;
+
+    if(vcWriter.isConnected())
+      rc = vcWriter.setIOMode(ioMode);
+    else
+      rc = missingComponent;
+
+    return rc;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   massai::cussif::MediaOutput*  bppDevice::getVirtualWriter(Characteristics::MediaOutput::MediaType type, ...
+//
+//  purpose:    Try to find the correct virtual printer for the passed MediaType
+//
+//  date:       03.05.2002, 14:51
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+massai::cussif::MediaOutput*  bppDevice::getVirtualWriter
+(
+  Characteristics::MediaOutput::MediaType type,
+  errorCodes& lErr,
+  errorCodes noStock,
+  errorCodes emptyStock
+)
+{
+  bool            fFound;
+  long            noOfDocsAvailable = 0;
+  long            i, j;
+  massai::cussif::MediaOutput*  vc = NULL;
+
+  lErr = noStock;
+
+  for(i = 0, fFound = false; !fFound && i < 3 && vcWriterBin[i].vcWriter.isConnected(); i++)
+  {
+    trace(_HERE_7, "checking bin[%d] for (%s) (%d)", i, mediaTypeText(type).c_str(), type);
+
+    if(type == vcWriterBin[i].vcWriter.getType())
+    {
+      for(j = 0; j < 3 && vcWriterBin[i].vcBin[j].isConnected(); j++)
+        noOfDocsAvailable += vcWriterBin[i].vcBin[j].getCurrentNoOfDocuments();
+
+      trace(_HERE_7, "no. of docs for (%s) (%d) = %d", mediaTypeText(type).c_str(), type, noOfDocsAvailable);
+
+      if(noOfDocsAvailable)
+      {
+        // save virtual components and terminate loop !!
+
+        vc = &(vcWriterBin[i].vcWriter);
+        fFound = true;
+
+        lErr = noError;
+      }
+      else
+        lErr = emptyStock;
+    }
+  }
+  return vc;
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   massai::cussif::MediaOutput* bppDevice::getDefaultVirtualWriter(long *plError)
+//
+//  purpose:    Try to find the correct virtual printer for the default paper type
+//
+//  author:     Materna Information & Communications
+//
+//---------------------------------------------------------------------------
+massai::cussif::MediaOutput* bppDevice::getDefaultVirtualWriter(long *plError)
+{
+  massai::cussif::MediaOutput* vc = NULL;
+  errorCodes lErr = noError;
+  switch(papertypeDefault)
+  {
+    case PT_TICKET:
+    {
+      vc= getVirtualWriter(MediaOutput::Ticket, lErr, noTicketStock, emptyTicketStock);
+      break;
+    }
+    case PT_BOARDINGPASS:
+    {
+      vc= getVirtualWriter(MediaOutput::BoardingPass, lErr, noBoardingPassStock, emptyBoardingPassStock);
+      break;
+    }
+    case PT_INSERTEDDOC:
+    {
+      vc = &vcWriter;
+      break;
+    }
+    case PT_GENERALPURPOSEDOC:
+    {
+      vc= getVirtualWriter(MediaOutput::GeneralPurposeDoc, lErr, noGeneralPurposeStock, emptyGeneralPurposeStock);
+      break;
+    }
+    case PT_BOARDINGPASSFIRST:
+    {
+      vc= getVirtualWriter(MediaOutput::BoardingPassFirst, lErr, noBoardingPassFirstStock, emptyBoardingPassFirstStock);
+      break;
+    }
+    case PT_BOARDINGPASSBUSINESS:
+    {
+      vc= getVirtualWriter(MediaOutput::BoardingPassBusiness, lErr, noBoardingPassBusinessStock, emptyBoardingPassBusinessStock);
+      break;
+    }
+    case PT_BOARDINGPASSECONOMY:
+    {
+      vc= getVirtualWriter(MediaOutput::BoardingPassEconomy, lErr, noBoardingPassEconomyStock, emptyBoardingPassEconomyStock);
+      break;
+    }
+  }
+  if(lErr != noError && plError != 0)
+  {
+    *plError = lErr;
+  }
+  return vc;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   massai::cussif::MediaOutput*  bppDevice::findVirtualWriter(char *pszData, PaperTypes *pt)
+//
+//  purpose:    Try to find the correct virtual printer for the passed data stream
+//
+//  date:       03.05.2002, 14:51
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+massai::cussif::MediaOutput*  bppDevice::findVirtualWriter(char *pszData,
+                                             MASSAI::atb2Scanner::PaperTypes *pt,
+                                             long *plError)
+{
+atb2Scanner             scanner;
+atb2Scanner::PaperTypes paperType;
+
+massai::cussif::MediaOutput*  vc = NULL;
+errorCodes      lErr = noError;
+
+    if(pszData && *pszData)
+    {
+      paperType = scanner.checkPaperType(pszData);
+
+      // save this value, too
+
+      if(pt) { *pt = paperType; }
+
+      switch(paperType)
+      {
+      case atb2Scanner::Setup:
+
+           // PECTABS, LOGOS etc. all to the same virtual printer
+
+           trace(_HERE_7, "atb2Scanner::Setup, using standard writer component");
+
+           if(vcWriter.isConnected())
+             vc = &vcWriter;
+           else
+           {
+             lErr= missingComponent;
+             bool fFound;
+             long i;
+             for(i = 0, fFound = false; !fFound && i < 3 && vcWriterBin[i].vcWriter.isConnected(); i++)
+             {
+               trace(_HERE_7, "checking bin[%d] for MediaOutput::Ticket", i);
+               vc= &(vcWriterBin[i].vcWriter);
+               fFound= true;
+               lErr= noError;
+             }
+           }
+           break;
+
+      case atb2Scanner::InsertedDoc:
+
+           trace(_HERE_7, "atb2Scanner::InsertedDoc, using standard writer component");
+
+           vc = &vcWriter;
+           break;
+
+      case atb2Scanner::Ticket:
+
+           trace(_HERE_7, "atb2Scanner::Ticket");
+           vc= getVirtualWriter(MediaOutput::Ticket, lErr, noTicketStock, emptyTicketStock);
+           break;
+
+      case atb2Scanner::BoardingPass:
+
+           trace(_HERE_7, "atb2Scanner::BoardingPass");
+           vc= getVirtualWriter(MediaOutput::BoardingPass, lErr, noBoardingPassStock, emptyBoardingPassStock);
+           break;
+
+      case atb2Scanner::BoardingPassFirst:
+
+           trace(_HERE_7, "atb2Scanner::BoardingPassFirst");
+           vc= getVirtualWriter(MediaOutput::BoardingPassFirst, lErr, noBoardingPassFirstStock, emptyBoardingPassFirstStock);
+           if(lErr == noBoardingPassFirstStock)
+           {
+             vc= getVirtualWriter(MediaOutput::BoardingPass, lErr, noBoardingPassStock, emptyBoardingPassStock);
+           }
+           break;
+
+      case atb2Scanner::BoardingPassBusiness:
+
+           trace(_HERE_7, "atb2Scanner::BoardingPassBusiness");
+           vc= getVirtualWriter(MediaOutput::BoardingPassBusiness, lErr, noBoardingPassBusinessStock, emptyBoardingPassBusinessStock);
+           if(lErr == noBoardingPassBusinessStock)
+           {
+             vc= getVirtualWriter(MediaOutput::BoardingPass, lErr, noBoardingPassStock, emptyBoardingPassStock);
+           }
+           break;
+
+      case atb2Scanner::BoardingPassEconomy:
+
+           trace(_HERE_7, "atb2Scanner::BoardingPassEconomy");
+           vc= getVirtualWriter(MediaOutput::BoardingPassEconomy, lErr, noBoardingPassEconomyStock, emptyBoardingPassEconomyStock);
+           if(lErr == noBoardingPassEconomyStock)
+           {
+             vc= getVirtualWriter(MediaOutput::BoardingPass, lErr, noBoardingPassStock, emptyBoardingPassStock);
+           }
+           break;
+
+      case atb2Scanner::GeneralPuposeDoc:
+
+           trace(_HERE_7, "atb2Scanner::GeneralPuposeDoc");
+           vc= getVirtualWriter(MediaOutput::GeneralPurposeDoc, lErr, noGeneralPurposeStock, emptyGeneralPurposeStock);
+           break;
+
+      case atb2Scanner::PreferTicket:
+           trace(_HERE_7, "atb2Scanner::Ticket");
+           vc= getVirtualWriter(MediaOutput::Ticket, lErr, noTicketStock, emptyTicketStock);
+           if(vc == 0)
+           {
+             trace(_HERE_7, "atb2Scanner::GeneralPuposeDoc");
+             vc= getVirtualWriter(MediaOutput::GeneralPurposeDoc, lErr, noGeneralPurposeStock, emptyGeneralPurposeStock);
+           }
+           break;
+
+      case atb2Scanner::PreferBoardingPass:
+           trace(_HERE_7, "atb2Scanner::BoardingPass");
+           vc= getVirtualWriter(MediaOutput::BoardingPass, lErr, noBoardingPassStock, emptyBoardingPassStock);
+           if(vc == 0)
+           {
+             trace(_HERE_7, "atb2Scanner::GeneralPuposeDoc");
+             vc= getVirtualWriter(MediaOutput::GeneralPurposeDoc, lErr, noGeneralPurposeStock, emptyGeneralPurposeStock);
+           }
+           break;
+
+      case atb2Scanner::Error:
+      default:
+
+           lErr = atb2ScannerError;
+
+           // do nothing in these cases !!
+
+           trace(_HERE_7, "no appropriate paper type for [%s]", pszData);
+           break;
+      }
+
+      if(lErr != noError && plError)
+        *plError = lErr;
+
+      // return the component found, if any !!
+
+      return vc;
+    }
+    else
+    {
+      if(plError)
+        *plError = parameterError;
+
+      return vc;
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   char *bppDevice::checkATBResponse(char *pszData, long *plStatusCode)
+//
+//  purpose:    Check ATB data for errors
+//
+//  date:       23.03.2001, 16:11
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+char *bppDevice::checkATBResponse(char *pszData, long *plStatusCode)
+{
+static char  szError[256];
+
+char *pStr;
+char  szTmp  [256];
+
+    *szError = '\0';
+
+    trace(_HERE_7, "checking response ...");
+
+    if(!pszData || !plStatusCode)
+    {
+      sprintf(szError, "parameter error");
+
+      trace(_HERE_7, "%s", szError);
+
+      return szError;
+    }
+
+    *plStatusCode = m_statuscodes::OK;
+
+    // @$/PROK!VSR!4C085!4D0103339955
+
+    if((pStr = strstr(pszData, "@@@HWE")) != NULL)
+    {
+      // printer HW error (Swissair only ??)
+
+      sprintf(szError, "Hardware error (@@@HWE)");
+      *plStatusCode = m_statuscodes::HARDWARE_ERROR;
+    }
+    else if((pStr = strstr(pszData, "ERR45")) != NULL)
+    {
+      // ribbon end !!
+
+      sprintf(szError, "RIBBON end (ERR45)");
+      *plStatusCode =  m_statuscodes::CONSUMABLES;
+    }
+    else if((pStr = strstr(pszData, "ERR")))
+    {
+       pStr += 3;
+
+       int i;
+       for(i = 0; *pStr && isdigit(*pStr); pStr++, i++)
+         szTmp[i] = *pStr;
+
+       szTmp[i] = '\0';
+
+       if(*pStr && *pStr == 'S')
+       {
+         *plStatusCode =  m_statuscodes::CONSUMABLES;
+          sprintf(szError, "document unknown to printer, %s", pszData);
+       }
+       else switch(atoi(szTmp))
+       {
+       case 1:  *plStatusCode =  m_statuscodes::HARDWARE_ERROR;
+                 sprintf(szError, "manually ejected, %s", pszData);
+                 break;
+
+       case 2:  *plStatusCode =  m_statuscodes::FORMAT_ERROR;
+                 sprintf(szError, "illogical command, %s", pszData);
+                 break;
+
+       case 3:  *plStatusCode =  m_statuscodes::FORMAT_ERROR;
+                 sprintf(szError, "incorrect field, %s", pszData);
+                 break;
+
+       case 4:  *plStatusCode =  m_statuscodes::FORMAT_ERROR;
+                 sprintf(szError, "out of sequence, %s", pszData);
+                 break;
+
+       case 5:  *plStatusCode =  m_statuscodes::HARDWARE_ERROR;
+                 sprintf(szError, "unsuccessful print, %s", pszData);
+                 break;
+
+       case 6:  *plStatusCode =  m_statuscodes::DATA_MISSING;
+                 sprintf(szError, "pectab not available, %s", pszData);
+                 break;
+
+       case 7:  *plStatusCode =  m_statuscodes::OUT_OF_SEQUENCE;
+                 sprintf(szError, "check-in in progress, %s", pszData);
+                 break;
+
+       default: *plStatusCode =  400; //m_statuscodes::APPLICATION_TECHNICAL_FIRST;
+                sprintf(szError, "unknown error, %s", pszData);
+                break;
+       }
+    }
+
+    trace(_HERE_7, "checking response done. err = %s", szError);
+
+    return szError;
+}
+
+
+void bppDevice::callback(CallbackComponent component, const types::Event& ev, int id)
+{
+  switch(component)
+  {
+    case CC_READER:
+      process_readerCallback(ev, id);
+      break;
+    case CC_WRITER:
+      process_writerCallback(ev, id);
+      break;
+    case CC_DISPENSER:
+      process_dispenserCallback(ev, id);
+      break;
+    case CC_FEEDER:
+      process_feederCallback(ev, id);
+      break;
+  }
+}
+void bppDevice::readerCallback(const Event& ev, int id)
+{
+  enqueue(CC_READER, ev, id);
+}
+void bppDevice::writerCallback(const Event& ev, int id)
+{
+  enqueue(CC_WRITER, ev, id);
+}
+void bppDevice::dispenserCallback(const Event& ev, int id)
+{
+  enqueue(CC_DISPENSER, ev, id);
+}
+void bppDevice::feederCallback(const Event &ev, int id)
+{
+  enqueue(CC_FEEDER, ev, id);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bppDevice::process_readerCallback(const Event &ev, int id)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void bppDevice::process_readerCallback(const Event &ev, int id)
+{
+char szFName[512];
+
+    try
+    {
+      vCompReader::lError = ev.statusCode;
+
+      trace(_HERE_1, "Reader (%d); event code: (%s) (%d), status code: (%s) (%d) for %s", id, eventCodesText(ev.eventCode).c_str(), ev.eventCode, scString(ev.statusCode).c_str(), ev.statusCode, ev.functionName.in());
+
+      if(ev.statusCode  == m_statuscodes::DATA_MISSING)
+      {
+        clearData();
+      }
+
+      TypeCode_ptr tcp = ev.eventData.type();
+      trace(_HERE_9, "Typecode parsed");
+      if(tcp->equivalent(_tc_aeaDataType))
+      {
+        trace(_HERE_7, "received aeaDataType");
+
+        // try to save any ATB response
+
+        saveData(ev.eventData);
+      }
+      if(id >= 0 && id < sizeof(compId)/sizeof(*compId))
+      {
+        if(!eventReceived(ev, compId[id]))
+        {
+          strcpy(szFName, ev.functionName.in());
+
+          if(!*ev.functionName && ev.statusCode == m_statuscodes::OK)
+          {
+            // unsolicited event ??
+
+            handleException(ev.eventCode, ev.statusCode, ev.functionName.in(), compId[id]);
+          }
+          else if(strstr(_strlwr(szFName), "disable"))
+          {
+            // special handler call for this function
+
+            printerClosed(ev.statusCode);
+          }
+          else switch(ev.statusCode)
+          {
+          case m_statuscodes::OK:                              break;
+
+          case m_statuscodes::MEDIA_PRESENT: couponInserted(); break;
+          case m_statuscodes::DATA_PRESENT:  dataPresent();    break;
+
+          case m_statuscodes::TIMEOUT:       commandTimeout(compId[id]); break;
+          case m_statuscodes::CANCELLED:     commandCancelled(compId[id]); break;
+          default:                           handleException(ev.eventCode, ev.statusCode, ev.functionName.in(), compId[id]); break;
+          }
+        }
+      }
+      else if(!eventReceived(ev))
+      {
+        strcpy(szFName, ev.functionName.in());
+
+        if(!*ev.functionName && ev.statusCode == m_statuscodes::OK)
+        {
+          // unsolicited event ??
+
+          handleException(ev.eventCode, ev.statusCode, ev.functionName.in());
+        }
+        else if(strstr(_strlwr(szFName), "disable"))
+        {
+          // special handler call for this function
+
+          printerClosed(ev.statusCode);
+        }
+        else switch(ev.statusCode)
+        {
+        case m_statuscodes::OK:                              break;
+
+        case m_statuscodes::MEDIA_PRESENT: couponInserted(); break;
+        case m_statuscodes::DATA_PRESENT:  dataPresent();    break;
+
+        case m_statuscodes::TIMEOUT:       commandTimeout(); break;
+        case m_statuscodes::CANCELLED:     commandCancelled(); break;
+        default:                           handleException(ev.eventCode, ev.statusCode, ev.functionName.in()); break;
+        }
+      }
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+    }
+    catch(...)
+    {
+      trace(_HERE_1, "... exception occured");
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bppDevice::process_writerCallback(const Event &ev, int id)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void bppDevice::process_writerCallback(const Event &ev, int id)
+{
+char szError[256];
+long lStatusCode;
+
+    vCompWriter::lError = ev.statusCode;
+
+    trace(_HERE_1, "Writer (%d); event code: (%s) (%d), status code: (%s) (%d) for %s", id, eventCodesText(ev.eventCode).c_str(), ev.eventCode, scString(ev.statusCode).c_str(), ev.statusCode, ev.functionName.in());
+
+    try
+    {
+      if(*ev.functionName && strcmp(ev.functionName.in(), "send") == 0)
+      {
+        disable(id);
+      }
+
+
+      TypeCode_ptr tcp = ev.eventData.type();
+      trace(_HERE_9, "Typecode parsed");
+      if(tcp->equivalent(_tc_aeaDataType))
+      {
+          trace(_HERE_9, "Typecode is aea");
+        //if(ev.statusCode == m_statuscodes::DATA_PRESENT)
+          saveData(ev.eventData);
+      }
+
+      if(!*ev.functionName && ev.statusCode == m_statuscodes::OK)
+      {
+        // unsolicited event ??
+
+        if(id >= 0 && id < sizeof(compId)/sizeof(*compId))
+        {
+          if(!eventReceived(ev, compId[id]))
+          {
+            handleException(ev.eventCode, ev.statusCode, ev.functionName.in(), compId[id]);
+          }
+        }
+        else
+        {
+          if(!eventReceived(ev))
+          {
+            handleException(ev.eventCode, ev.statusCode, ev.functionName.in());
+          }
+        }
+      }
+      else
+      {
+        bool processed= false;
+        if(id >= 0 && id < sizeof(compId)/sizeof(*compId))
+        {
+          processed= eventReceived(ev, compId[id]);
+        }
+        else
+        {
+          processed= eventReceived(ev);
+        }
+        if(!processed)
+        {
+          switch(ev.statusCode)
+          {
+          case m_statuscodes::OK:
+          case m_statuscodes::MEDIA_PRESENT:
+          case m_statuscodes::DATA_PRESENT:
+
+             if(*ev.functionName && (!strcmp(ev.functionName.in(), "send") || !strcmp(ev.functionName.in(), "setup")))
+               {
+                 // handle returned data directly if synchronous call !!
+
+                 TypeCode_ptr tcp = ev.eventData.type();
+
+                 if(tcp->equivalent(_tc_aeaDataType))
+                 {
+                   saveData(ev.eventData);
+
+                   trace(_HERE_7, "BPP-RSP [%s], func = %s", getData(), ev.functionName.in());
+
+                   strcpy(szError, checkATBResponse(getData(), &lStatusCode));
+
+                   if(*szError)
+                     printError(lStatusCode, szError);
+                   else
+                   {
+                     if(!strcmp(ev.functionName.in(), "setup"))
+                     {
+                       if(id >= 0 && id < sizeof(compId)/sizeof(*compId))
+                       {
+                         setupResponse(compId[id]);
+                       }
+                       else
+                       {
+                         setupResponse();
+                       }
+                     }
+                     else
+                     {
+                       if(id >= 0 && id < sizeof(compId)/sizeof(*compId))
+                       {
+                         couponPrinted(compId[id]);
+                       }
+                       else
+                       {
+                         couponPrinted();
+                       }
+                     }
+                   }
+                 }
+               }
+               break;
+
+          case m_statuscodes::TIMEOUT:
+            if(id >= 0 && id < sizeof(compId)/sizeof(*compId))
+            {
+              commandTimeout(compId[id]);
+            }
+            else
+            {
+              commandTimeout();
+            }
+            break;
+          case m_statuscodes::CANCELLED:
+            if(id >= 0 && id < sizeof(compId)/sizeof(*compId))
+            {
+              commandCancelled(compId[id]);
+            }
+            else
+            {
+              commandCancelled();
+            }
+            break;
+          default:
+            if(id >= 0 && id < sizeof(compId)/sizeof(*compId))
+            {
+              handleException(ev.eventCode, ev.statusCode, ev.functionName.in(), compId[id]);
+            }
+            else
+            {
+              handleException(ev.eventCode, ev.statusCode, ev.functionName.in());
+            }
+            break;
+          }
+        }
+      }
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+    }
+    catch(...)
+    {
+      trace(_HERE_1, "... exception occured");
+    }
+
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bppDevice::process_dispenserCallback(const Event &ev, int id)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void bppDevice::process_dispenserCallback(const Event &ev, int id)
+{
+    vCompDispenser::lError = ev.statusCode;
+
+    trace(_HERE_1, "Dispenser (%d); event code: (%s) (%d), status code: (%s) (%d) for %s", id, eventCodesText(ev.eventCode).c_str(), ev.eventCode, scString(ev.statusCode).c_str(), ev.statusCode, ev.functionName.in());
+    if(*ev.functionName && strcmp(ev.functionName.in(), "offer") == 0)
+    {
+      disable(id);
+    }
+
+    TypeCode_ptr tcp = ev.eventData.type();
+
+    if(tcp->equivalent(_tc_aeaDataType))
+    {
+      trace(_HERE_7, "received aeaDataType");
+
+      // try to save any ATB response
+
+      saveData(ev.eventData);
+    }
+
+    if(id >= 0 && id < sizeof(compId)/sizeof(*compId))
+    {
+      if(!*ev.functionName && ev.statusCode == m_statuscodes::OK)
+      {
+        // unsolicited event ??
+        if(!eventReceived(ev, compId[id]))
+          handleException(ev.eventCode, ev.statusCode, ev.functionName.in(), compId[id]);
+      }
+      else if(!eventReceived(ev, compId[id]))
+      {
+        switch(ev.statusCode)
+        {
+        case m_statuscodes::OK:           if(*ev.functionName) couponEjected(); break;
+
+        case m_statuscodes::TIMEOUT:      commandTimeout(compId[id]); break;
+        case m_statuscodes::CANCELLED:    commandCancelled(compId[id]); break;
+        default:                          handleException(ev.eventCode, ev.statusCode, ev.functionName.in(), compId[id]); break;
+        }
+      }
+    }
+    else if(!*ev.functionName && ev.statusCode == m_statuscodes::OK)
+    {
+      // unsolicited event ??
+      if(!eventReceived(ev))
+        handleException(ev.eventCode, ev.statusCode, ev.functionName.in());
+    }
+    else if(!eventReceived(ev))
+    {
+      switch(ev.statusCode)
+      {
+      case m_statuscodes::OK:           if(*ev.functionName) couponEjected(); break;
+
+      case m_statuscodes::TIMEOUT:      commandTimeout(); break;
+      case m_statuscodes::CANCELLED:    commandCancelled(); break;
+      default:                          handleException(ev.eventCode, ev.statusCode, ev.functionName.in()); break;
+      }
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bppDevice::process_feederCallback(const Event &ev, int id)
+//
+//  purpose:
+//
+//  date:       25.04.2002, 12:01
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void bppDevice::process_feederCallback(const Event &ev, int id)
+{
+    vCompFeeder::lError = ev.statusCode;
+
+    trace(_HERE_1, "Feeder (%d); event code: (%s) (%d), status code: (%s) (%d) for %s", id, eventCodesText(ev.eventCode).c_str(), ev.eventCode, scString(ev.statusCode).c_str(), ev.statusCode, ev.functionName.in());
+
+    TypeCode_ptr tcp = ev.eventData.type();
+
+    if(id >= 0 && id < sizeof(compId)/sizeof(*compId))
+    {
+      if(!eventReceived(ev, compId[id]))
+      {
+        handleException(ev.eventCode, ev.statusCode, ev.functionName.in(), compId[id]);
+      }
+    }
+    else
+    {
+      if(!eventReceived(ev))
+      {
+        handleException(ev.eventCode, ev.statusCode, ev.functionName.in());
+      }
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long bppDevice::open(long lTimeOut)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long bppDevice::open(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+    clearData();
+
+    if(vcReader.isConnected())
+    {
+      if(((rc = vcReader.enable(lTimeOut, ev)) != 0) || (lTimeOut < 0))
+        return rc;
+      else
+        return checkStatusCode(ev);
+    }
+    else
+      return missingComponent;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long bppDevice::close(long lTimeOut)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long bppDevice::close(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcReader.isConnected())
+    {
+      if(((rc = vcReader.disable(lTimeOut, ev)) != 0) || (lTimeOut < 0))
+        return rc;
+      else
+        return checkStatusCode(ev);
+    }
+    else
+      return missingComponent;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long bppDevice::eject(long lTimeOut)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long bppDevice::eject(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+long rc1 = 0;
+Event_var ev1;
+
+  if(vcDispenser.isConnected())
+  {
+     // enable before offer
+     if((rc1 = vcDispenser.enable(0, ev1)) != 0)
+     {
+       trace(_HERE_7, "error enabling dispenser, rc = (%s) (%d)", rcString(rc1).c_str(), rc1);
+       return(rc1);
+     }
+     else
+       trace(_HERE_7, "enabling dispenser, rc = (%s) (%d)", rcString(rc1).c_str(), rc1);
+
+     if((rc = vcDispenser.offer(lTimeOut, ev)) != 0)
+       trace(_HERE_7, "error offering dispenser, rc = (%s) (%d)", rcString(rc).c_str(), rc);
+        //return rc;
+     else
+       trace(_HERE_7, "offering dispenser, rc = (%s) (%d)", rcString(rc).c_str(), rc);
+          //return checkStatusCode(ev);
+
+     // disable after synchron offer
+     if(lTimeOut >= 0  || rc != m_returncodes::RC_OK)
+     {
+       if((rc1 = vcDispenser.disable(0, ev1)) != 0)
+         trace(_HERE_7, "error disabling dispenser, rc = (%s) (%d)", rcString(rc1).c_str(), rc1);
+       else
+         trace(_HERE_7, "disabling dispenser, rc = (%s) (%d)", rcString(rc1).c_str(), rc1);
+     }
+
+     if((rc != 0) || (lTimeOut < 0))
+       return rc;
+     else
+       return checkStatusCode(ev);
+   }
+   else
+     return missingComponent;
+}
+
+// // discard old response/indication
+void bppDevice::clearData()
+{
+  abData[0] = '\0';
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bppDevice::saveData(const datastream ds)
+//
+//  purpose:    save data from AEA data stream
+//
+//  date:       15.01.01, 14:20
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void bppDevice::saveData(const datastream ds)
+{
+aeaDataType *pData;
+
+    ds >>= pData;
+
+    if(pData)
+    {
+      unsigned int i;
+      for(i = 0; i < pData->length(); i++)
+        abData[i] = (*pData)[i];
+
+      abData[i] = '\0';
+    }
+    return;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long bppDevice::read(long lTimeOut)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long bppDevice::read(long lTimeOut, Event_out ev)
+{
+long rc = -1;
+
+    clearData();
+    if(vcReader.isConnected())
+    {
+
+      if(((rc = vcReader.receive(lTimeOut, ev)) != 0) || (lTimeOut < 0))
+      {
+        trace(_HERE_7, "receive() for atb data, rc = (%s) (%d)", rcString(rc).c_str(), rc);
+
+        return rc;
+      }
+      else
+      {
+        // handle returned data directly if synchronous call !!
+
+        TypeCode_ptr tcp = ev->eventData.type();
+
+        if(tcp->equivalent(_tc_aeaDataType))
+        {
+          trace(_HERE_7, "received aeaDataType");
+
+          // try to save any ATB response
+
+          saveData(ev->eventData);
+
+          if(ev->statusCode != m_statuscodes::OK            &&
+             ev->statusCode != m_statuscodes::MEDIA_PRESENT &&
+             ev->statusCode != m_statuscodes::DATA_PRESENT     )
+          {
+            // call default handler in any case of error
+
+            eventReceived(*ev, compId[vcReader.getId()]);
+          }
+        }
+        else
+        {
+          trace(_HERE_7, "received invalid DataType");
+        }
+      }
+
+      return checkStatusCode(ev);
+    }
+    else
+      return missingComponent;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long bppDevice::write(long lTimeOut, char *pszData, long lLen)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long bppDevice::write(long lTimeOut, char *pszData, long lLen, Event_out ev)
+{
+long        rc  = 0;
+long        rc1 = 0;
+long        lLength;
+long        lStatusCode;
+errorCodes  ec;
+Event_var   ev1;
+datastream  ds;
+aeaDataType atbData;
+
+atb2Scanner::PaperTypes paperType;
+
+massai::cussif::MediaOutput* vcWriter = NULL;
+
+
+    // discard old printer response/indication
+    clearData();
+
+    // anything to do ??
+    if(!pszData || !*pszData)
+      return -1;
+
+    // create datastream for atb printer
+
+    if(!lLen)
+      lLength = strlen(pszData);
+    else
+      lLength = lLen;
+
+    atbData.length(lLength);
+
+    for(int i = 0; i < lLength; i++)
+       atbData[i] = *(pszData +i);
+
+    ds <<= atbData;
+    ds.type(types::_tc_aeaDataType);
+
+    // try to find the right virtual printer
+
+    if(useDSPaperType)
+    {
+      vcWriter = findVirtualWriter(pszData, &paperType, (long *) &ec);
+    }
+    else
+    {
+      vcWriter = getDefaultVirtualWriter((long *) &ec);
+    }
+
+    if(vcWriter)
+    {
+      if(paperType != atb2Scanner::Setup)
+      {
+        // enable the writer before sending
+
+        if((rc1 = vcWriter->enable(0, ev1)) != 0)
+        {
+          trace(_HERE_1, "error enabling writer, rc = (%s) (%d)", rcString(rc1).c_str(), rc1);
+          return rc1;
+        }
+
+        // send the normal way
+
+        if((rc = vcWriter->send(lTimeOut, ds, ev)) != 0)
+        {
+          trace(_HERE_1, "sending atb data (send()), rc = (%s) (%d)", rcString(rc).c_str(), rc);
+        }
+        else
+          trace(_HERE_1, "atb data sent. (send()), rc = (%s) (%d)", rcString(rc).c_str(), rc);
+
+        // disable the writer after sending
+        if(lTimeOut >= 0 || rc != m_returncodes::RC_OK)
+        {
+          if((rc1 = vcWriter->disable(0, ev1)) != 0)
+            trace(_HERE_1, "error disabling writer, rc = (%s) (%d)", rcString(rc1).c_str(), rc1);
+        }
+
+        // return if send returned error !
+
+        if((rc) || (lTimeOut < 0))
+          return rc;
+      }
+      else
+      {
+        // use setup instead of 'send()'
+
+        if(((rc = vcWriter->setup(lTimeOut, ds, ev)) != 0) || (lTimeOut < 0))
+        {
+          trace(_HERE_1, "sending atb data (setup()), rc = (%s) (%d)", rcString(rc).c_str(), rc);
+
+          return rc;
+        }
+        else
+          trace(_HERE_1 , "atb data sent. (setup()), rc = (%s) (%d)", rcString(rc).c_str(), rc);
+      }
+
+      // handle returned data directly if synchronous call !!
+
+      TypeCode_ptr tcp = ev->eventData.type();
+
+      if(tcp->equivalent(_tc_aeaDataType))
+      {
+        saveData(ev->eventData);
+
+        if(*checkATBResponse(getData(), &lStatusCode))
+          return lStatusCode;
+        else
+        {
+          trace(_HERE_7, "BPP-RSP [%s]", getData());
+        }
+      }
+
+      return checkStatusCode(ev);
+    }
+    else
+    {
+      trace(_HERE_1, "NO CUSS WRITER COMPONENT, rc = %d", ec);
+      return ec;
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long bppDevice::cancel(long lTimeOut)
+//
+//  purpose:    cancel the last command
+//
+//  date:       17.11.2005
+//
+//  author:     Dr. Materna GmbH (TS)
+//
+//---------------------------------------------------------------------------
+
+long bppDevice::cancel(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcReader.isConnected()
+      || vcWriter.isConnected()
+      || vcWriterBin[0].vcWriter.isConnected()
+      || vcWriterBin[1].vcWriter.isConnected()
+      || vcWriterBin[2].vcWriter.isConnected())
+    {
+      if(vcWriter.isConnected())
+        rc = vcWriter.cancel(ev);
+
+      if(vcReader.isConnected())
+        rc = vcReader.cancel(ev);
+
+      if(vcDispenser.isConnected())
+        rc = vcDispenser.cancel(ev);
+
+      if(vcWriterBin[0].vcWriter.isConnected())
+        rc = vcWriterBin[0].vcWriter.cancel(ev);
+
+      if(vcWriterBin[1].vcWriter.isConnected())
+        rc = vcWriterBin[1].vcWriter.cancel(ev);
+
+      if(vcWriterBin[2].vcWriter.isConnected())
+        rc = vcWriterBin[2].vcWriter.cancel(ev);
+
+      return rc;
+    }
+    else
+      return missingComponent;
+}
+
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bppDevice::couponInserted()
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void bppDevice::couponInserted()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bppDevice::dataPresent()
+//
+//  purpose:    data present handler
+//
+//  date:       24.07.2002, 08:47
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void bppDevice::dataPresent()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bppDevice::couponEjected()
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void bppDevice::couponEjected()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bppDevice::couponPrinted()
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void bppDevice::couponPrinted()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bppDevice::couponPrinted(const ComponentId& id)
+//
+//  purpose:
+//
+//  date:       20.11.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+void bppDevice::couponPrinted(const ComponentId& id)
+{
+  couponPrinted();
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        void bppDevice::setupResponse()
+ *
+ *  @brief
+ *
+ *  @date      02.02.2005
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+void bppDevice::setupResponse()
+{
+}
+//---------------------------------------------------------------------------
+//
+//  function:   void bppDevice::setupResponse(const ComponentId& id)
+//
+//  purpose:
+//
+//  date:       20.11.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+void bppDevice::setupResponse(const ComponentId& id)
+{
+  setupResponse();
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bppDevice::printerClosed(long lStatusCode)
+//
+//  purpose:
+//
+//  date:       01.08.2001, 15:19
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void bppDevice::printerClosed(long lStatusCode)
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bppDevice::printError (const long lStatusCode, const char *pszError)
+//
+//  purpose:
+//
+//  date:       23.03.2001, 16:10
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void bppDevice::printError (const long lStatusCode, const char *pszError)
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bppDevice::commandTimeout()
+//
+//  purpose:    called if command timeout has occurred
+//
+//  date:       21.02.01, 10:35
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void bppDevice::commandTimeout()
+{
+}
+//---------------------------------------------------------------------------
+//
+//  function:   void bppDevice::commandTimeout(const ComponentId& id)
+//
+//  purpose:    called if command timeout has occurred
+//
+//  date:       20.11.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+void bppDevice::commandTimeout(const ComponentId& id)
+{
+  commandTimeout();
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bppDevice::commandCancelled()
+//
+//  purpose:    calles if command has been cancelled
+//
+//  date:       21.02.01, 10:35
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void bppDevice::commandCancelled()
+{
+}
+//---------------------------------------------------------------------------
+//
+//  function:   void bppDevice::commandCancelled(const ComponentId& id)
+//
+//  purpose:    calles if command has been cancelled
+//
+//  date:       20.11.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+void bppDevice::commandCancelled(const ComponentId& id)
+{
+  commandCancelled();
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bppDevice::handleException(long eventCode,
+//                                              long statusCode,
+//                                              const char *pszFunction)
+//
+//  purpose:    called if an unhandled status code (error) has been received
+//
+//  date:       21.02.01, 10:36
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void bppDevice::handleException(long eventCode, long statusCode, const char *pszFunction)
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bppDevice::handleException(long eventCode, long statusCode, const char *pszFunction, const ComponentId& id)
+//
+//  purpose:
+//
+//  date:       20.11.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+void bppDevice::handleException(long eventCode, long statusCode, const char *pszFunction, const ComponentId& id)
+{
+  handleException(eventCode, statusCode, pszFunction);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool bppDevice::eventReceived(long eventCode,
+//                                            long statusCode,
+//                                            const char *pszFunction)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+bool bppDevice::eventReceived (const Event& ev)
+{
+  return eventReceived(ev.eventCode, ev.statusCode, ev.functionName.in());
+}
+bool bppDevice::eventReceived(long eventCode, long statusCode, const char *pszFunction)
+{
+    return false;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bppDevice::eventReceived(long eventCode, long statusCode, const char *pszFunction, const ComponentId& id)
+//
+//  purpose:
+//
+//  date:       20.11.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+bool bppDevice::eventReceived (const Event& ev, const ComponentId& id)
+{
+  return eventReceived(ev.eventCode, ev.statusCode, ev.functionName.in(), id);
+}
+bool bppDevice::eventReceived(long eventCode, long statusCode, const char *pszFunction, const ComponentId& id)
+{
+  return eventReceived(eventCode, statusCode, pszFunction);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   char *bppDevice::getData()
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+char *bppDevice::getData()
+{
+    return abData;
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool bppDevice::documentNumber()
+//
+//  purpose:    Return the current document number of first feeder
+//
+//  date:       04.08.2006
+//
+//  author:     Materna Information & Communications (CMe)
+//
+//---------------------------------------------------------------------------
+
+const char *bppDevice::documentNumber()
+{
+  std::string modelNumber= vcWriterBin[0].vcBin[0].getModelNumber();
+  std::string::size_type start= modelNumber.find("documentNumber");
+  if(start != std::string::npos && start + 15 < modelNumber.size())
+  {
+    start+= 15;
+    std::string::size_type end = modelNumber.find(" ", start);
+    if(end != std::string::npos)
+    {
+      m_documentNumber= std::string(modelNumber, start, end - start);
+    }
+    else
+    {
+      m_documentNumber= std::string(modelNumber, start, modelNumber.size() - start);
+    }
+  }
+  else
+  {
+    m_documentNumber= "???";
+  }
+  return m_documentNumber.c_str();
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool bppDevice::hasAEASupport()
+//
+//  purpose:    Check if this is an AEA printer
+//
+//  date:       26.08.2002, 08:58
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+bool bppDevice::hasAEASupport()
+{
+bool fRet = false;
+
+Characteristics::DataTypeList_var dtl;
+
+    if(vcReader.isConnected())
+    {
+      dtl= vcReader.getSupportedDataTypes();
+
+      for(unsigned int i = 0; i < dtl->length() && !fRet; i++)
+        if(dtl[i] == Characteristics::AEA)
+          fRet = true;
+
+      return fRet;
+    }
+    else if(vcWriter.isConnected())
+    {
+      dtl= vcWriter.getSupportedDataTypes();
+
+      for(unsigned int i = 0; i < dtl->length() && !fRet; i++)
+        if(dtl[i] == Characteristics::AEA)
+          fRet = true;
+
+      return fRet;
+    }
+
+    return fRet;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool bppDevice::hasEscrow()
+//
+//  purpose:    Check availability of ESCROW device
+//
+//  date:       26.08.2002, 08:55
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+bool bppDevice::hasEscrow()
+{
+    return hasEscrowDispenser;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool bppDevice::hasReaderEscrow()
+//
+//  purpose:    Check availability of ESCROW device
+//
+//  date:       20.11.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+bool bppDevice::hasReaderEscrow()
+{
+    return hasReaderEscrowDispenser;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool bppDevice::hasReader()
+//
+//  purpose:    Check availability of MediaInput device
+//
+//  date:       16.11.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+bool bppDevice::hasReader()
+{
+    return vcReader.canConnect();
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   readertype bppDevice::readerType()
+//
+//  purpose:    return the reader type from characteristics
+//
+//  date:       05.09.2002, 14:21
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+bppDevice::readertype bppDevice::readerType()
+{
+bppDevice::readertype rt = RT_ERROR;
+char       szTmp[256];
+
+    if(vcReader.isConnected())
+    {
+
+      switch(vcReader.getTypeOfReader())
+      {
+      case NSC_MI::Motorized:
+
+           strcpy(szTmp, "Motorized");
+           rt = RT_MOTORIZED;
+           break;
+
+      case NSC_MI::Swipe:
+
+           strcpy(szTmp, "Swipe");
+           rt = RT_SWIPE;
+           break;
+
+      case NSC_MI::Contactless:               // not useful for atb printers
+
+           strcpy(szTmp, "Contactless");
+           rt = RT_ERROR;
+           break;
+
+      case NSC_MI::DIP:                       // not useful for atb printers
+
+           strcpy(szTmp, "DIP");
+           rt = RT_ERROR;
+           break;
+
+      case NSC_MI::nonApplicableReaderType:   // not useful for atb printers
+
+           strcpy(szTmp, "nonApplicableReaderType");
+           rt = RT_ERROR;
+           break;
+
+      case NSC_MI::FlatbedScan:               // not useful for atb printers
+
+           strcpy(szTmp, "FlatbedScan");
+           rt = RT_ERROR;
+           break;
+
+      case NSC_MI::PenScan:                   // not useful for atb printers
+
+           strcpy(szTmp, "PenScan");
+           rt = RT_ERROR;
+           break;
+      }
+
+      trace(_HERE_7, "ReaderType = %s", szTmp);
+    }
+
+    return rt;
+}
+
+/** Returns bin size of the dispenser */
+
+long bppDevice::dispenserBinSize()
+{
+  long result= 0;
+  if(vcDispenser.isConnected())
+  {
+    result= vcDispenser.getBinSize();
+  }
+  else
+  {
+    trace(_HERE_7, "vcDispenser not connected");
+  }
+  return result;
+}
+
+
+long bppDevice::error()
+{
+  return vCompWriter::error();
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long bppDevice::status(comptype ct)
+ *
+ *  @brief     query status on specific virtual component
+ *
+ *  @date      20.10.2004
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long bppDevice::status(comptype ct, Event_out ev)
+{
+    return status(BLOCK_, ct, ev);
+}
+long bppDevice::status(long lTimeout, comptype ct, Event_out ev)
+{
+long      rc = missingComponent;
+
+    try
+    {
+      switch(ct)
+      {
+      case vCompReader::reader:
+
+           if(vcReader.isConnected())
+           {
+             if((rc = vcReader.query(lTimeout, ev)) == 0 && (lTimeout >= 0))
+               rc = ev->statusCode;
+           }
+           else
+             trace(_HERE_7, "vcReader not connected");
+           break;
+
+      case vCompWriter::writer:
+
+           if(vcWriter.isConnected())
+           {
+             if((rc = vcWriter.query(lTimeout, ev)) == 0 && (lTimeout >= 0))
+               rc = ev->statusCode;
+           }
+           else
+             trace(_HERE_7, "vcWriter not connected");
+           break;
+
+      case vCompDispenser::dispenser:
+
+           if(vcDispenser.isConnected())
+           {
+             if((rc = vcDispenser.query(lTimeout, ev)) == 0 && (lTimeout >= 0))
+               rc = ev->statusCode;
+           }
+           else
+             trace(_HERE_7, "vcDispenser not connected");
+           break;
+      }
+    }
+    catch(...) {}
+
+    trace(_HERE_7, "status query result: %s, rc = %d", scString(rc).c_str(), rc);
+
+    return rc;
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long bppDevice::feederStatus (papertype pt)
+ *
+ *  @brief     query status on specific virtual component
+ *
+ *  @date      21.11.2006
+ *
+ *  @author    Materna Information & Communications (SteT)
+ */
+//------------------------------------------------------------------------
+
+long bppDevice::feederStatus(papertype pt, Event_out ev)
+{
+  Event_var ev2;
+  long rc = missingComponent;
+  long rc2 = missingComponent;
+  int i;
+  int index;
+  int j;
+  bool fFound;
+
+  try
+  {
+    for(i= 0, fFound = false; !fFound && i < 3 && vcWriterBin[i].vcWriter.canConnect(); i++)
+    {
+      if(vcWriterBin[i].vcWriter.getType() == getPaperTypeMediaOutput(pt))
+      {
+        fFound = true;
+        index= i;
+      }
+    }
+    if(fFound)
+    {
+      for(j= 0; j < 3 && vcWriterBin[index].vcBin[j].canConnect(); j++)
+      {
+        if((rc2 = vcWriterBin[index].vcBin[j].query(0, ev2)) == m_returncodes::RC_OK)
+        {
+          rc2= ev2->statusCode;
+          trace(_HERE_7, "status query result: %s, rc = %d", scString(rc2).c_str(), rc2);
+          if(getFeederPriority(rc2) < getFeederPriority(rc))
+          {
+            rc= rc2;
+            ev= ev2._retn();
+          }
+        }
+        else
+        {
+          trace(_HERE_7, "status query result: %s, rc = %d", scString(rc2).c_str(), rc2);
+          if(getFeederPriority(rc2) < getFeederPriority(rc))
+          {
+            rc= rc2;
+            ev= ev2._retn();
+          }
+        }
+      }
+    }
+  }
+  catch(CORBA::SystemException& ex)
+  {
+      trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+  }
+  catch(...)
+  {
+      trace(_HERE_1, "Unknown exception");
+  }
+
+  trace(_HERE_7, "status query result: %s, rc = %d", scString(rc).c_str(), rc);
+  return rc;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bppDevice::disable(int id)
+//
+//  purpose:    disable the component by id
+//
+//  date:       30.04.2007
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+void bppDevice::disable(int id)
+{
+  trace(_HERE_1, "disable %d", id);
+  try
+  {
+    Event_var ev;
+    switch(id)
+    {
+      case 0:
+        vcReader.disable(0, ev);
+        break;
+      case 1:
+        vcDispenser.disable(0, ev);
+        break;
+      case 2:
+        vcWriter.disable(0, ev);
+        break;
+      default:
+      {
+        int writer= (id - 3) / 4;
+        int bin= (id - 3) % 4;
+        if(0 <= writer && writer < 3)
+        {
+          if(bin == 0)
+          {
+            vcWriterBin[writer].vcWriter.disable(0, ev);
+          }
+        }
+      }
+    }
+  }
+  catch(CORBA::SystemException& ex)
+  {
+    trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+  }
+  catch(...)
+  {
+    trace(_HERE_1, "... exception occured");
+  }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   bppDevice::init(amInterface *pAmi, const char* pszRealComponent, bppType readerCreation)
+//
+//  purpose:    called by class constructor - acquire virtual components
+//
+//  date:       26.04.06
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+void bppDevice::init(amInterface *pAmi, const char* pszRealComponent, bppType readerCreation)
+{
+    char             szTmp[256];
+    long             rc = 0;
+    long             i, j, k, lIndex, lLinked;
+    long             lDispenserIndex= 0;
+
+
+    compId[ 0].component= MASSAI::vComponent::reader;
+    compId[ 1].component= MASSAI::vComponent::dispenser;
+    compId[ 2].component= MASSAI::vComponent::writer;
+    compId[ 3].component= MASSAI::vComponent::writer;
+    compId[ 4].component= MASSAI::vComponent::feeder;
+    compId[ 5].component= MASSAI::vComponent::feeder;
+    compId[ 6].component= MASSAI::vComponent::feeder;
+    compId[ 7].component= MASSAI::vComponent::writer;
+    compId[ 8].component= MASSAI::vComponent::feeder;
+    compId[ 9].component= MASSAI::vComponent::feeder;
+    compId[10].component= MASSAI::vComponent::feeder;
+    compId[11].component= MASSAI::vComponent::writer;
+    compId[12].component= MASSAI::vComponent::feeder;
+    compId[13].component= MASSAI::vComponent::feeder;
+    compId[14].component= MASSAI::vComponent::feeder;
+    for(i= 0; i < sizeof(compId)/sizeof(*compId); i++)
+    {
+      compId[i].feeder_count= 0;
+    }
+
+    try
+    {
+      if(pszRealComponent)
+      {
+        realComponent= pszRealComponent;
+        trace(_HERE_7, "use realcomponent: %s", pszRealComponent);
+
+        if(readerCreation == READER_INCLUSIVE)
+        {
+          lIndex = 0;
+          vcReader.storeIOR(pAmi->ior(lIndex, pszRealComponent, "MediaInput"));
+          long lStartIndex= 0;
+          if(pAmi->iorLinked(lIndex, lStartIndex, "Dispenser") != 0)
+          {
+            EnvironmentComponents_var ec(pAmi->getComponents());
+            CORBA::ULong index= lIndex;
+            lIndex= ec[index].linkedComponents[lStartIndex];
+
+            lStartIndex= 0;
+            // SteT EDB 27096 +>
+            // if(pAmi->iorLinked(lIndex, lStartIndex, Characteristics::Dispenser::real_) != 0)
+            // SteT EDB 27096 <+ ->
+            if(pAmi->iorLinked(lIndex, lStartIndex, "Dispenser") != 0)
+            // SteT EDB 27096 <-
+            {
+              hasReaderEscrowDispenser= true;
+            }
+          }
+        }
+
+        lIndex = 0;
+        vcWriter.storeIOR(pAmi->iorExclude(lIndex, pszRealComponent, "MediaOutput", "Feeder"));
+        if(!vcWriter.canConnect())
+        {
+          trace(_HERE_7, "vcWriter try patch");
+          lIndex = 0;
+          vcWriter.storeIOR(pAmi->ior(lIndex, pszRealComponent, "MediaOutput"));
+        }
+
+        vcDispenser.storeIOR(pAmi->iorLinked(lIndex, lDispenserIndex, "Dispenser")); // use MediaOutput-Dispenser
+        if(vcDispenser.canConnect())
+        {
+          EnvironmentComponents_var ec(pAmi->getComponents());
+          CORBA::ULong index= lIndex;
+          lDispenserIndex= ec[index].linkedComponents[lDispenserIndex];
+        }
+
+
+        // try to get all MediaOutput components and its Feeders
+        for(i = lIndex = lLinked = 0; lIndex >= 0 && i < 3;)
+        {
+          vcWriterBin[i].vcWriter.storeIOR(pAmi->iorInclude(lIndex, pszRealComponent, "MediaOutput", "Feeder"));
+          if(vcWriterBin[i].vcWriter.canConnect())
+          {
+            // try to get all ATB bins for this writer
+
+            for(j = lLinked = 0; lLinked >= 0 && j < 3;)
+            {
+              vcWriterBin[i].vcBin[j].storeIOR(pAmi->iorLinked(lIndex, lLinked, "Feeder"));
+              if(vcWriterBin[i].vcBin[j].canConnect())
+              {
+                // increment only, if something was found
+                j++;
+                // don't increment if return value is below zero !!
+                lLinked++;
+              }
+            }
+            for(k= 0; k < 4; k++)
+            {
+              compId[4*i+k+3].feeder_count= j;
+            }
+            // increment only, if something was found
+            i++;
+            // don't increment if return value is below zero !!
+            lIndex++;
+          }
+        }
+      }
+      else
+      {
+        trace(_HERE_7, "no component found for atb");
+      }
+
+      strcpy(vCompReader::szAppRef,   pAmi->getAppReference());
+      strcpy(vCompWriter::szAppRef,   pAmi->getAppReference());
+      strcpy(vCompDispenser::szAppRef, pAmi->getAppReference());
+      strcpy(vCompFeeder::szAppRef,   pAmi->getAppReference());
+
+#ifdef SUPERUSER
+
+      strcpy(vCompReader::szAppRef,   "moorhuhn");
+      strcpy(vCompWriter::szAppRef,   "moorhuhn");
+      strcpy(vCompDispenser::szAppRef, "moorhuhn");
+      strcpy(vCompFeeder::szAppRef,   "moorhuhn");
+
+#endif
+
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+    }
+
+    vcReader.connect();
+    vcReader.setListener();
+    vcDispenser.connect();
+    vcDispenser.setListener();
+    vcWriter.connect();
+    vcWriter.setListener();
+    readerType(); // for debug output only !!
+
+    if(vcDispenser.canConnect())
+    {
+      // MediaOutput Dispenser is a real Dispenser => escrow dispenser
+      if(vcDispenser.getKind() == Characteristics::Dispenser::real_)
+      {
+        hasEscrowDispenser= true;
+      }
+      else
+      {
+        // or MediaOutput Dispenser has a second Dispenser => escrow dispenser
+        long lStartIndex= 0;
+        // SteT EDB 27096: ->
+        if(pAmi->iorLinked(lDispenserIndex, lStartIndex, "Dispenser") != 0)
+        {
+          hasEscrowDispenser= true;
+        }
+        // SteT EDB 27096: <-
+      /* SteT EDB 27096 +>
+        while(pAmi->iorLinked(lDispenserIndex, lStartIndex, "Dispenser") != 0)
+        {
+          EnvironmentComponents_var ec(pAmi->getComponents());
+          CORBA::ULong lDispenderIdx= lDispenserIndex;
+          long lSecondDispenserIndex= ec[lDispenderIdx].linkedComponents[lStartIndex];
+          long lSecondStartIndex= 0;
+          // and the second Dispenser is not the dispenser of the MediaInput => escrow dispenser
+          if(pAmi->iorLinked(lSecondDispenserIndex, lSecondStartIndex, "MediaInput") == 0)
+          {
+            hasEscrowDispenser= true;
+            break;
+          }
+          lStartIndex++;
+        }
+        SteT EDB 27096 <+ */
+      }
+    }
+    startProcessing();
+
+    for(i = 0; i < 3; i++)
+    {
+      vcWriterBin[i].vcWriter.connect();
+      vcWriterBin[i].vcWriter.setListener();
+      if(vcWriterBin[i].vcWriter.isConnected())
+      {
+        for(j = 0; j < 3; j++)
+        {
+          vcWriterBin[i].vcBin[j].connect();
+          vcWriterBin[i].vcBin[j].setListener();
+          bppDevice::papertype pt;
+          switch(vcWriterBin[i].vcWriter.getType())
+          {
+            case MediaOutput::BoardingPass:         strcpy(szTmp, "BoardingPass");         pt= bppDevice::PT_BOARDINGPASS;         break;
+            case MediaOutput::Ticket:               strcpy(szTmp, "Ticket");               pt= bppDevice::PT_TICKET;               break;
+            case MediaOutput::BoardingPassEconomy:  strcpy(szTmp, "BoardingPassEconomy");  pt= bppDevice::PT_BOARDINGPASSECONOMY;  break;
+            case MediaOutput::BoardingPassBusiness: strcpy(szTmp, "BoardingPassBusiness"); pt= bppDevice::PT_BOARDINGPASSBUSINESS; break;
+            case MediaOutput::BoardingPassFirst:    strcpy(szTmp, "BoardingPassFirst");    pt= bppDevice::PT_BOARDINGPASSFIRST;    break;
+            case MediaOutput::GeneralPurposeDoc:    strcpy(szTmp, "GeneralPurposeDoc");    pt= bppDevice::PT_GENERALPURPOSEDOC;    break;
+            case MediaOutput::InsertedDoc:          strcpy(szTmp, "InsertedDoc");          pt= bppDevice::PT_INSERTEDDOC;          break;
+          }
+
+          for(k= 0; k < 4; k++)
+          {
+            compId[4*i+k+3].paper= pt;
+          }
+
+          trace(_HERE_7, "BPP[%d]:Bin[%d]:PaperType           = %s", i, j, szTmp);
+          trace(_HERE_7, "BPP[%d]:Bin[%d]:almostFullLevel     = %d", i, j, vcWriterBin[i].vcBin[j].getAllmostFullLevel());
+          trace(_HERE_7, "BPP[%d]:Bin[%d]:almostEmptyLevel    = %d", i, j, vcWriterBin[i].vcBin[j].getAllmostEmptyLevel());
+          trace(_HERE_7, "BPP[%d]:Bin[%d]:BinSize             = %d", i, j, vcWriterBin[i].vcBin[j].getBinSize());
+          trace(_HERE_7, "BPP[%d]:Bin[%d]:currentNumberOfDocs = %d", i, j, vcWriterBin[i].vcBin[j].getCurrentNoOfDocuments());
+        }
+      }
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   bppDevice::bppDevice(amInterface *pAmi)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:42
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+bppDevice::bppDevice(amInterface *pAmi, bppType readerCreation):
+  vCompReader   (pAmi),
+  vCompWriter   (pAmi),
+  vCompDispenser(pAmi),
+  vCompFeeder   (pAmi),
+  vcReader(static_cast<vCompReader*>(this), 0),
+  vcDispenser(static_cast<vCompDispenser*>(this), 1),
+  vcWriter(static_cast<vCompWriter*>(this), 2),
+  hasEscrowDispenser(false),
+  hasReaderEscrowDispenser(false),
+  useDSPaperType(true)
+{
+  long i, j, lIndex;
+  for(i= 0; i < 3; i++)
+  {
+    vcWriterBin[i].vcWriter= massai::cussif::MediaOutput(static_cast<vCompWriter*>(this), 4*i+3);
+    for(j= 0; j < 3; j++)
+    {
+      vcWriterBin[i].vcBin[j]= massai::cussif::Feeder(static_cast<vCompFeeder*>(this), 4*i+j+4);
+    }
+  }
+
+  try
+  {
+    // try to connect all virtual components
+
+    if(pAmi->queryRealComponent("ATB2DeviceWithEscrow"))
+    {
+      init(pAmi, "ATB2DeviceWithEscrow", readerCreation);
+    }
+    else if(pAmi->queryRealComponent("ATB2Device"))
+    {
+      init(pAmi, "ATB2Device", readerCreation);
+    }
+    else if(pAmi->queryRealComponent("BoardingPassPrinter"))
+    {
+      init(pAmi, "BoardingPassPrinter", readerCreation);
+    }
+    else
+    {
+      // no atb device found by name, check characteristics
+      const char* pszRealComponent;
+
+      amInterface::MediaTypeSet mediatype;
+      amInterface::DataTypeSet datatype;
+
+      //  check for AEA with MagneticStripe
+      mediatype.insert(Characteristics::MediaType::MagneticStripe);
+      datatype.insert(Characteristics::AEA);
+
+      lIndex= 0;
+      pszRealComponent= pAmi->queryMediaOutput(lIndex, Characteristics::MediaOutput::Ticket, mediatype, datatype);
+      if(!pszRealComponent)
+      {
+        lIndex= 0;
+        pszRealComponent= pAmi->queryMediaOutput(lIndex, Characteristics::MediaOutput::BoardingPass, mediatype, datatype);
+      }
+      if(!pszRealComponent)
+      {
+        lIndex= 0;
+        pszRealComponent= pAmi->queryMediaOutput(lIndex, Characteristics::MediaOutput::BoardingPassFirst, mediatype, datatype);
+      }
+      if(!pszRealComponent)
+      {
+        lIndex= 0;
+        pszRealComponent= pAmi->queryMediaOutput(lIndex, Characteristics::MediaOutput::BoardingPassBusiness, mediatype, datatype);
+      }
+      if(!pszRealComponent)
+      {
+        lIndex= 0;
+        pszRealComponent= pAmi->queryMediaOutput(lIndex, Characteristics::MediaOutput::BoardingPassEconomy, mediatype, datatype);
+      }
+      if(!pszRealComponent)
+      {
+        lIndex= 0;
+        pszRealComponent= pAmi->queryMediaOutput(lIndex, Characteristics::MediaOutput::InsertedDoc, mediatype, datatype);
+      }
+      if(!pszRealComponent)
+      {
+        lIndex= 0;
+        pszRealComponent= pAmi->queryMediaOutput(lIndex, Characteristics::MediaOutput::GeneralPurposeDoc, mediatype, datatype);
+      }
+      if(!pszRealComponent)
+      {
+        //  check for AEA
+        mediatype.clear();
+        mediatype.insert(Characteristics::MediaType::Printed);
+        lIndex= 0;
+        pszRealComponent= pAmi->queryMediaOutput(lIndex, Characteristics::MediaOutput::Ticket, mediatype, datatype);
+        if(!pszRealComponent)
+        {
+          lIndex= 0;
+          pszRealComponent= pAmi->queryMediaOutput(lIndex, Characteristics::MediaOutput::BoardingPass, mediatype, datatype);
+        }
+        if(!pszRealComponent)
+        {
+          lIndex= 0;
+          pszRealComponent= pAmi->queryMediaOutput(lIndex, Characteristics::MediaOutput::BoardingPassFirst, mediatype, datatype);
+        }
+        if(!pszRealComponent)
+        {
+          lIndex= 0;
+          pszRealComponent= pAmi->queryMediaOutput(lIndex, Characteristics::MediaOutput::BoardingPassBusiness, mediatype, datatype);
+        }
+        if(!pszRealComponent)
+        {
+          lIndex= 0;
+          pszRealComponent= pAmi->queryMediaOutput(lIndex, Characteristics::MediaOutput::BoardingPassEconomy, mediatype, datatype);
+        }
+        if(!pszRealComponent)
+        {
+          lIndex= 0;
+          pszRealComponent= pAmi->queryMediaOutput(lIndex, Characteristics::MediaOutput::InsertedDoc, mediatype, datatype);
+        }
+        if(!pszRealComponent)
+        {
+          lIndex= 0;
+          pszRealComponent= pAmi->queryMediaOutput(lIndex, Characteristics::MediaOutput::GeneralPurposeDoc, mediatype, datatype);
+        }
+      }
+      if(pszRealComponent)
+      {
+        init(pAmi, pszRealComponent, readerCreation);
+      }
+      else
+      {
+        trace(_HERE_7, "no component found for atb");
+      }
+    }
+  }
+  catch(CORBA::SystemException& ex)
+  {
+    trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+  }
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   bppDevice::bppDevice(amInterface *pAmi, papertype paper)
+//
+//  purpose:
+//
+//  date:       08.03.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+bppDevice::bppDevice(amInterface *pAmi, papertype paper, bppType readerCreation, papertypehandling handlepapertype):
+  vCompReader   (pAmi),
+  vCompWriter   (pAmi),
+  vCompDispenser(pAmi),
+  vCompFeeder   (pAmi),
+  vcReader(static_cast<vCompReader*>(this), 0),
+  vcDispenser(static_cast<vCompDispenser*>(this), 1),
+  vcWriter(static_cast<vCompWriter*>(this), 2),
+  hasEscrowDispenser(false),
+  hasReaderEscrowDispenser(false),
+  papertypeDefault(paper)
+{
+  switch(handlepapertype)
+  {
+    case PH_PAPERTYPE_FROM_DATASTREAM:
+      useDSPaperType= true;
+      break;
+    default:
+      useDSPaperType= false;
+      break;
+  }
+  long i, j, lIndex;
+  for(i= 0; i < 3; i++)
+  {
+    vcWriterBin[i].vcWriter= massai::cussif::MediaOutput(static_cast<vCompWriter*>(this), 4*i+3);
+    for(j= 0; j < 3; j++)
+    {
+      vcWriterBin[i].vcBin[j]= massai::cussif::Feeder(static_cast<vCompFeeder*>(this), 4*i+j+4);
+    }
+  }
+  try
+  {
+    // check characteristics
+    const char* pszRealComponent;
+
+    amInterface::MediaTypeSet mediatype;
+    amInterface::DataTypeSet datatype;
+    mediatype.insert(Characteristics::MediaType::MagneticStripe);
+    datatype.insert(Characteristics::AEA);
+
+    lIndex= 0;
+    pszRealComponent= pAmi->queryMediaOutput(lIndex, getPaperTypeMediaOutput(paper), mediatype, datatype);
+    if(!pszRealComponent)
+    {
+      mediatype.clear();
+      mediatype.insert(Characteristics::MediaType::Printed);
+      lIndex= 0;
+      pszRealComponent= pAmi->queryMediaOutput(lIndex, getPaperTypeMediaOutput(paper), mediatype, datatype);
+    }
+    if(pszRealComponent)
+    {
+      init(pAmi, pszRealComponent, readerCreation);
+    }
+    else
+    {
+      trace(_HERE_7, "no component found for atb");
+    }
+  }
+  catch(CORBA::SystemException& ex)
+  {
+    trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+  }
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   bppDevice::~bppDevice()
+//
+//  purpose:    class destructor
+//
+//  date:       29.11.00, 15:42
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+bppDevice::~bppDevice()
+{
+  vcReader.clearListener();
+  vcWriter.clearListener();
+  vcDispenser.clearListener();
+
+  for(long i = 0; i < 3 && vcWriterBin[i].vcWriter.isConnected(); i++)
+  {
+    vcWriterBin[i].vcWriter.clearListener();
+    for(long j = 0; j < 3 && vcWriterBin[i].vcBin[j].isConnected(); j++)
+    {
+      vcWriterBin[i].vcBin[j].clearListener();
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/atbreader.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/atbreader.cpp
new file mode 100644
index 00000000..17736300
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/atbreader.cpp
@@ -0,0 +1,1218 @@
+//---------------------------------------------------------------------------
+//
+//  file:       atbReader.cpp
+//
+//  purpose:    atbReader device implementation
+//
+//  date:       14.09.00
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+//#define SHOW_INCLUDE_FILES
+
+#include "cussif.h"
+#include "atbreader.h"
+#include "check.h"
+#include "tracedef.h"
+#include "orbs.h"
+
+#include "atb2Scanner.h"
+
+#include "textIDL/textcodes.h"
+#include "textIDL/texttypes.h"
+#include "textIDL/textcharacteristics.h"
+
+using namespace MASSAI::codes_text;
+using namespace MASSAI::characteristics_text;
+using namespace MASSAI::types_text;
+
+//#define SUPERUSER  // uses "moohuhn" token
+
+#define NSC_MI Characteristics::MediaInput
+
+using namespace MASSAI;
+
+//---------------------------------------------------------------------------
+//
+//  function:   Characteristics::IOMode::InputOutputMode atbReader::ioMode()
+//
+//  purpose:    Return current IO-Mode for BPP device
+//
+//  date:       24.06.2002, 13:51
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+Characteristics::IOMode::InputOutputMode atbReader::ioMode()
+{
+    if(vcReader.isConnected())
+      return(vcReader.getMode());
+    else
+    {
+      vCompReader::lError = missingComponent;
+      return(Characteristics::IOMode::nonApplicableInputOutputMode);
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long atbReader::setIOMode(Characteristics::IOMode::InputOutputMode ioMode)
+//
+//  purpose:    Set new IO-Mode for BPP device
+//
+//  date:       24.06.2002, 13:52
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long atbReader::setIOMode(Characteristics::IOMode::InputOutputMode ioMode)
+{
+long rc = -1;
+
+    if(vcReader.isConnected())
+      rc = vcReader.setIOMode(ioMode);
+    else
+      rc = missingComponent;
+
+    return(rc);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   char *atbReader::checkATBResponse(char *pszData, long *plStatusCode)
+//
+//  purpose:    Check ATB data for errors
+//
+//  date:       23.03.2001, 16:11
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+char *atbReader::checkATBResponse(char *pszData, long *plStatusCode)
+{
+static char  szError[256];
+
+char *pStr;
+char  szTmp  [256];
+
+    *szError = '\0';
+
+    trace(_HERE_7, "checking response ...");
+
+    if(!pszData || !plStatusCode)
+    {
+      sprintf(szError, "parameter error");
+
+      trace(_HERE_7, "%s", szError);
+
+      return(szError);
+    }
+
+    *plStatusCode = m_statuscodes::OK;
+
+    // @$/PROK!VSR!4C085!4D0103339955
+
+    if((pStr = strstr(pszData, "@@@HWE")) != NULL)
+    {
+      // printer HW error (Swissair only ??)
+
+      sprintf(szError, "Hardware error (@@@HWE)");
+      *plStatusCode = m_statuscodes::HARDWARE_ERROR;
+    }
+    else if((pStr = strstr(pszData, "ERR45")) != NULL)
+    {
+      // ribbon end !!
+
+      sprintf(szError, "RIBBON end (ERR45)");
+      *plStatusCode =  m_statuscodes::CONSUMABLES;
+    }
+    else if((pStr = strstr(pszData, "ERR")))
+    {
+       pStr += 3;
+
+	   int i;
+       for(i = 0; *pStr && isdigit(*pStr); pStr++, i++)
+         szTmp[i] = *pStr;
+
+       szTmp[i] = '\0';
+
+       if(*pStr && *pStr == 'S')
+       {
+         *plStatusCode =  m_statuscodes::CONSUMABLES;
+          sprintf(szError, "document unknown to printer, %s", pszData);
+       }
+       else switch(atoi(szTmp))
+       {
+       case 1:  *plStatusCode =  m_statuscodes::HARDWARE_ERROR;
+                 sprintf(szError, "manually ejected, %s", pszData);
+                 break;
+
+       case 2:  *plStatusCode =  m_statuscodes::FORMAT_ERROR;
+                 sprintf(szError, "illogical command, %s", pszData);
+                 break;
+
+       case 3:  *plStatusCode =  m_statuscodes::FORMAT_ERROR;
+                 sprintf(szError, "incorrect field, %s", pszData);
+                 break;
+
+       case 4:  *plStatusCode =  m_statuscodes::FORMAT_ERROR;
+                 sprintf(szError, "out of sequence, %s", pszData);
+                 break;
+
+       case 5:  *plStatusCode =  m_statuscodes::HARDWARE_ERROR;
+                 sprintf(szError, "unsuccessful print, %s", pszData);
+                 break;
+
+       case 6:  *plStatusCode =  m_statuscodes::DATA_MISSING;
+                 sprintf(szError, "pectab not available, %s", pszData);
+                 break;
+
+       case 7:  *plStatusCode =  m_statuscodes::OUT_OF_SEQUENCE;
+                 sprintf(szError, "check-in in progress, %s", pszData);
+                 break;
+
+       default: *plStatusCode =  400; //m_statuscodes::APPLICATION_TECHNICAL_FIRST;
+                sprintf(szError, "unknown error, %s", pszData);
+                break;
+       }
+    }
+
+    trace(_HERE_7, "checking response done. err = %s", szError);
+
+    return(szError);
+}
+
+void atbReader::callback(CallbackComponent component, const types::Event& ev, int id)
+{
+  switch(component)
+  {
+    case CC_READER:
+      process_readerCallback(ev, id);
+      break;
+    case CC_DISPENSER:
+      process_dispenserCallback(ev, id);
+      break;
+  }
+}
+void atbReader::readerCallback(const Event& ev, int id)
+{
+  enqueue(CC_READER, ev, id);
+}
+void atbReader::dispenserCallback(const Event& ev, int id)
+{
+  enqueue(CC_DISPENSER, ev, id);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   void atbReader::process_readerCallback(const Event &ev, int id)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void atbReader::process_readerCallback(const Event &ev, int id)
+{
+char szFName[512];
+char szError[256];
+long lStatusCode;
+
+  try
+  {
+    vCompReader::lError = ev.statusCode;
+
+    trace(_HERE_1, "Reader (%d); event code: (%s) (%d), status code: (%s) (%d) for %s", id, eventCodesText(ev.eventCode).c_str(), ev.eventCode, scString(ev.statusCode).c_str(), ev.statusCode, ev.functionName.in());
+
+    if(ev.statusCode  == m_statuscodes::DATA_MISSING)
+    {
+      clearData();
+    }
+
+    TypeCode_ptr tcp = ev.eventData.type();
+
+    if(tcp->equivalent(_tc_aeaDataType))
+    {
+      trace(_HERE_7, "received aeaDataType");
+
+      // try to save any ATB response
+
+      saveData(ev.eventData);
+    }
+
+    if(!eventReceived(ev))
+    {
+      strcpy(szFName, ev.functionName.in());
+
+      if(!*ev.functionName && ev.statusCode == m_statuscodes::OK)
+      {
+        // unsolicited event ??
+
+        handleException(ev.eventCode, ev.statusCode, ev.functionName.in());
+      }
+      else if(strstr(_strlwr(szFName), "disable"))
+      {
+        // special handler call for this function
+
+        printerClosed(ev.statusCode);
+      }
+      else switch(ev.statusCode)
+      {
+      case m_statuscodes::OK:
+        if(*ev.functionName)
+        {
+          // handle returned data directly if synchronous call !!
+
+          TypeCode_ptr tcp = ev.eventData.type();
+
+          if(tcp->equivalent(_tc_aeaDataType))
+          {
+            saveData(ev.eventData);
+
+            trace(_HERE_7, "BPP-RSP [%s], func = %s", getData(), ev.functionName.in());
+
+            strcpy(szError, checkATBResponse(getData(), &lStatusCode));
+
+            if(*szError)
+              setupError(lStatusCode, szError);
+            else
+            {
+              if(!strcmp(ev.functionName.in(), "setup"))
+                setupResponse();
+            }
+          }
+        }
+        break;
+      case m_statuscodes::MEDIA_PRESENT: couponInserted(); break;
+      case m_statuscodes::MEDIA_ABSENT:  couponRemoved(); break;
+      case m_statuscodes::DATA_PRESENT:  dataPresent();    break;
+
+      case m_statuscodes::TIMEOUT:       commandTimeout(); break;
+      case m_statuscodes::CANCELLED:     commandCancelled(); break;
+      default:                           handleException(ev.eventCode, ev.statusCode, ev.functionName.in()); break;
+      }
+    }
+  }
+  catch(CORBA::SystemException& ex)
+  {
+    trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+  }
+  catch(...)
+  {
+    trace(_HERE_1, "... exception occured");
+  }
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   void atbReader::process_dispenserCallback(const Event &ev, int id)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void atbReader::process_dispenserCallback(const Event &ev, int id)
+{
+    vCompDispenser::lError = ev.statusCode;
+
+    trace(_HERE_1, "Dispenser (%d); event code: (%s) (%d), status code: (%s) (%d) for %s", id, eventCodesText(ev.eventCode).c_str(), ev.eventCode, scString(ev.statusCode).c_str(), ev.statusCode, ev.functionName.in());
+
+    if(*ev.functionName && strcmp(ev.functionName.in(), "offer") == 0)
+    {
+      try
+      {
+        Event_var ev1;
+        vcDispenser.disable(0, ev1);
+      }
+      catch(CORBA::SystemException& ex)
+      {
+        trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+      }
+      catch(...)
+      {
+        trace(_HERE_1, "... exception occured");
+      }
+    }
+
+
+    TypeCode_ptr tcp = ev.eventData.type();
+
+    if(tcp->equivalent(_tc_aeaDataType))
+    {
+      trace(_HERE_7, "received aeaDataType");
+
+      // try to save any ATB response
+
+      saveData(ev.eventData);
+    }
+
+    if(!*ev.functionName && ev.statusCode == m_statuscodes::OK)
+    {
+      // unsolicited event ??
+      if(!eventReceived(ev))
+        handleException(ev.eventCode, ev.statusCode, ev.functionName.in());
+    }
+    else if(!eventReceived(ev))
+    {
+      switch(ev.statusCode)
+      {
+      case m_statuscodes::OK:           if(*ev.functionName) couponEjected(); break;
+
+      case m_statuscodes::TIMEOUT:      commandTimeout(); break;
+      case m_statuscodes::CANCELLED:    commandCancelled(); break;
+      default:                          handleException(ev.eventCode, ev.statusCode, ev.functionName.in()); break;
+      }
+    }
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   long atbReader::open(long lTimeOut)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long atbReader::open(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    clearData();
+    if(vcReader.isConnected())
+    {
+
+      if(((rc = vcReader.enable(lTimeOut, ev)) != 0) || (lTimeOut < 0))
+        return(rc);
+      else
+        return(checkStatusCode(ev));
+    }
+    else
+      return(missingComponent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long atbReader::close(long lTimeOut)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long atbReader::close(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcReader.isConnected())
+    {
+      if(((rc = vcReader.disable(lTimeOut, ev)) != 0) || (lTimeOut < 0))
+        return(rc);
+      else
+        return(checkStatusCode(ev));
+    }
+    else
+      return(missingComponent);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   long atbReader::cancel(long lTimeOut)
+//
+//  purpose:    cancel the last command
+//
+//  date:       17.11.2005
+//
+//  author:     Dr. Materna GmbH (TS)
+//
+//---------------------------------------------------------------------------
+
+long atbReader::cancel(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcReader.isConnected())
+    {
+      if(vcDispenser.isConnected())
+        rc = vcDispenser.cancel(ev);
+      rc = vcReader.cancel(ev);
+
+      return(rc);
+    }
+    else
+      return(missingComponent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long atbReader::eject(long lTimeOut)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long atbReader::eject(long lTimeOut, Event_out ev)
+{
+  long rc = 0;
+  long rc1 = 0;
+  Event_var ev1;
+
+  if(vcDispenser.isConnected())
+  {
+    // enable before offer
+    if((rc1 = vcDispenser.enable(0, ev1)) != 0)
+    {
+      trace(_HERE_7, "error enabling dispenser, rc = (%s) (%d)", rcString(rc1).c_str(), rc1);
+      return rc1;
+    }
+    else
+      trace(_HERE_7, "enabling dispenser, rc = (%s) (%d)", rcString(rc1).c_str(), rc1);
+
+    if((rc = vcDispenser.offer(lTimeOut, ev)) != 0)
+      trace(_HERE_7, "error offering dispenser, rc = (%s) (%d)", rcString(rc).c_str(), rc);
+       //return(rc);
+    else
+      trace(_HERE_7, "offering dispenser, rc = (%s) (%d)", rcString(rc).c_str(), rc);
+      //return(checkStatusCode(ev));
+
+    // disable after offer
+    if(lTimeOut >= 0  || rc != m_returncodes::RC_OK)
+    {
+      if((rc1 = vcDispenser.disable(0, ev1)) != 0)
+        trace(_HERE_7, "error disabling dispenser, rc = (%s) (%d)", rcString(rc1).c_str(), rc1);
+      else
+        trace(_HERE_7, "disabling dispenser, rc = (%s) (%d)", rcString(rc1).c_str(), rc1);
+    }
+    if((rc != 0) || (lTimeOut < 0))
+      return rc;
+    else
+      return checkStatusCode(ev);
+   }
+   else
+     return missingComponent;
+}
+
+// discard old response/indication
+void atbReader::clearData()
+{
+  abData[0] = '\0';
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void atbReader::saveData(const datastream ds)
+//
+//  purpose:    save data from AEA data stream
+//
+//  date:       15.01.01, 14:20
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void atbReader::saveData(const datastream ds)
+{
+aeaDataType *pData;
+
+    ds >>= pData;
+
+    if(pData)
+    {
+	     unsigned int i;
+      for(i = 0; i < pData->length(); i++)
+        abData[i] = (*pData)[i];
+
+      abData[i] = '\0';
+    }
+    return;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long atbReader::read(long lTimeOut)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long atbReader::read(long lTimeOut, Event_out ev)
+{
+long rc = -1;
+
+    clearData();
+    if(vcReader.isConnected())
+    {
+      if(((rc = vcReader.receive(lTimeOut, ev)) != 0) || (lTimeOut < 0))
+      {
+        trace(_HERE_7, "receive() for atbreader data, rc = (%s) (%d)", rcString(rc).c_str(), rc);
+
+        return(rc);
+      }
+      else
+      {
+        // handle returned data directly if synchronous call !!
+
+        TypeCode_ptr tcp = ev->eventData.type();
+
+        if(tcp->equivalent(_tc_aeaDataType))
+        {
+          trace(_HERE_7, "received aeaDataType");
+
+          // try to save any ATB response
+          saveData(ev->eventData);
+
+          if(ev->statusCode != m_statuscodes::OK            &&
+             ev->statusCode != m_statuscodes::MEDIA_PRESENT &&
+             ev->statusCode != m_statuscodes::DATA_PRESENT     )
+          {
+            // call default handler in any case of error
+
+            eventReceived(*ev);
+          }
+        }
+        else
+        {
+          trace(_HERE_7, "received invalid DataType");
+        }
+      }
+
+      return(checkStatusCode(ev));
+    }
+    else
+      return(missingComponent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long atbReader::write(long lTimeOut, char *pszData, long lLen)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long atbReader::write(long lTimeOut, char *pszData, long lLen, Event_out ev)
+{
+long        rc  = 0;
+long        rc1 = 0;
+long        lLength;
+long        lStatusCode;
+errorCodes  ec;
+datastream  ds;
+aeaDataType atbData;
+
+atb2Scanner::PaperTypes paperType;
+
+    // discard old printer response/indication
+    clearData();
+
+    // anything to do ??
+    if(!pszData || !*pszData)
+      return(-1);
+
+    // create datastream for atb printer
+
+    if(!lLen)
+      lLength = strlen(pszData);
+    else
+      lLength = lLen;
+
+    atbData.length(lLength);
+
+    for(int i = 0; i < lLength; i++)
+       atbData[i] = *(pszData +i);
+
+    ds <<= atbData;
+    ds.type(types::_tc_aeaDataType);
+
+    if(!pszData || !*pszData)
+    {
+      ec = parameterError;
+    }
+    else
+    {
+      atb2Scanner scanner;
+      paperType = scanner.checkPaperType(pszData);
+      switch(paperType)
+      {
+      case atb2Scanner::Setup:
+           ec= noError;
+           break;
+      case atb2Scanner::InsertedDoc:
+           ec= missingComponent;
+           break;
+      case atb2Scanner::Ticket:
+           ec = noTicketStock;
+           break;
+      case atb2Scanner::BoardingPass:
+           ec = noBoardingPassStock;
+           break;
+      case atb2Scanner::BoardingPassFirst:
+           ec = noBoardingPassFirstStock;
+           break;
+      case atb2Scanner::BoardingPassBusiness:
+           ec = noBoardingPassBusinessStock;
+           break;
+      case atb2Scanner::BoardingPassEconomy:
+           ec = noBoardingPassEconomyStock;
+           break;
+      case atb2Scanner::GeneralPuposeDoc:
+           ec = noGeneralPurposeStock;
+           break;
+      case atb2Scanner::Error:
+      case atb2Scanner::PreferTicket:
+      case atb2Scanner::PreferBoardingPass:
+      default:
+           ec = atb2ScannerError;
+           trace(_HERE_7, "no appropriate paper type for [%s]", pszData);
+           break;
+      }
+    }
+    if(vcReader.isConnected())
+    {
+      if(ec == noError)
+      {
+        clearData();
+        if(paperType == atb2Scanner::Setup)
+        {
+          // use setup instead of 'send()'
+
+          if(((rc = vcReader.setup(lTimeOut, ds, ev)) != 0) || (lTimeOut < 0))
+          {
+            trace(_HERE_1, "sending atbreader data (setup()), rc = (%s) (%d)", rcString(rc).c_str(), rc);
+
+            return(rc);
+          }
+          else
+            trace(_HERE_1, "atbreader data sent. (setup()), rc = (%s) (%d)", rcString(rc1).c_str(), rc1);
+        }
+        else
+        {
+          ec= missingComponent;
+          trace(_HERE_1, "NO CUSS READER COMPONENT for PaperType: (%d), rc = (%s) (%d)", paperType, rcString(rc).c_str(), rc);
+          return(ec);
+        }
+
+        // handle returned data directly if synchronous call !!
+
+        TypeCode_ptr tcp = ev->eventData.type();
+
+        if(tcp->equivalent(_tc_aeaDataType))
+        {
+          saveData(ev->eventData);
+
+          if(*checkATBResponse(getData(), &lStatusCode))
+            return(lStatusCode);
+          else
+          {
+            trace(_HERE_7, "BPP-RSP [%s]", getData());
+          }
+        }
+
+        return(checkStatusCode(ev));
+      }
+      else
+      {
+        trace(_HERE_1, "NO CUSS READER COMPONENT, rc = %d", ec);
+        return(ec);
+      }
+    }
+    else
+    {
+      ec= missingComponent;
+      trace(_HERE_1, "NO CUSS READER COMPONENT, rc = %d", ec);
+      return(ec);
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void atbReader::couponInserted()
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void atbReader::couponInserted()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void atbReader::couponRemoved()
+//
+//  purpose:
+//
+//  date:       04.01.07
+//
+//  author:     Materna Information & Communications (CMe)
+//
+//---------------------------------------------------------------------------
+
+void atbReader::couponRemoved()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void atbReader::dataPresent()
+//
+//  purpose:    data present handler
+//
+//  date:       24.07.2002, 08:47
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void atbReader::dataPresent()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void atbReader::couponEjected()
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void atbReader::couponEjected()
+{
+}
+
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        void atbReader::setupResponse()
+ *
+ *  @brief
+ *
+ *  @date      02.02.2005
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+void atbReader::setupResponse()
+{
+}
+
+
+void atbReader::setupError(const long lStatusCode, const char*pszError)
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void atbReader::printerClosed(long lStatusCode)
+//
+//  purpose:
+//
+//  date:       01.08.2001, 15:19
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void atbReader::printerClosed(long lStatusCode)
+{
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   void atbReader::commandTimeout()
+//
+//  purpose:    called if command timeout has occurred
+//
+//  date:       21.02.01, 10:35
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void atbReader::commandTimeout()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void atbReader::commandCancelled()
+//
+//  purpose:    calles if command has been cancelled
+//
+//  date:       21.02.01, 10:35
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void atbReader::commandCancelled()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void atbReader::handleException(long eventCode,
+//                                              long statusCode,
+//                                              const char *pszFunction)
+//
+//  purpose:    called if an unhandled status code (error) has been received
+//
+//  date:       21.02.01, 10:36
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void atbReader::handleException(long eventCode, long statusCode, const char *pszFunction)
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool atbReader::eventReceived(long eventCode,
+//                                            long statusCode,
+//                                            const char *pszFunction)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+bool atbReader::eventReceived (const Event& ev)
+{
+  return eventReceived(ev.eventCode, ev.statusCode, ev.functionName.in());
+}
+bool atbReader::eventReceived(long eventCode, long statusCode, const char *pszFunction)
+{
+    return(false);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   char *atbReader::getData()
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+char *atbReader::getData()
+{
+    return(abData);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool atbReader::hasEscrow()
+//
+//  purpose:    Check availability of ESCROW device
+//
+//  date:       26.08.2002, 08:55
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+bool atbReader::hasEscrow()
+{
+    return hasEscrowDispenser;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   readertype atbReader::readerType()
+//
+//  purpose:    return the reader type from characteristics
+//
+//  date:       05.09.2002, 14:21
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+atbReader::readertype atbReader::readerType()
+{
+atbReader::readertype rt = RT_ERROR;
+char       szTmp[256];
+
+    if(vcReader.isConnected())
+    {
+      switch(vcReader.getTypeOfReader())
+      {
+      case NSC_MI::Motorized:
+
+           strcpy(szTmp, "Motorized");
+           rt = RT_MOTORIZED;
+           break;
+
+      case NSC_MI::Swipe:
+
+           strcpy(szTmp, "Swipe");
+           rt = RT_SWIPE;
+           break;
+
+      case NSC_MI::Contactless:               // not useful for atb printers
+
+           strcpy(szTmp, "Contactless");
+           rt = RT_ERROR;
+           break;
+
+      case NSC_MI::DIP:                       // not useful for atb printers
+
+           strcpy(szTmp, "DIP");
+           rt = RT_ERROR;
+           break;
+
+      case NSC_MI::nonApplicableReaderType:   // not useful for atb printers
+
+           strcpy(szTmp, "nonApplicableReaderType");
+           rt = RT_ERROR;
+           break;
+
+      case NSC_MI::FlatbedScan:               // not useful for atb printers
+
+           strcpy(szTmp, "FlatbedScan");
+           rt = RT_ERROR;
+           break;
+
+      case NSC_MI::PenScan:                   // not useful for atb printers
+
+           strcpy(szTmp, "PenScan");
+           rt = RT_ERROR;
+           break;
+      }
+
+      trace(_HERE_7, "ReaderType = %s", szTmp);
+    }
+
+    return(rt);
+}
+
+long atbReader::error()
+{
+  return vCompReader::error();
+}
+//------------------------------------------------------------------------
+/**
+ *  @fn        long atbReader::status(comptype ct)
+ *
+ *  @brief     query status on specific virtual component
+ *
+ *  @date      20.09.2005
+ *
+ *  @author    Materna Information & Communications (BrN)
+ */
+//------------------------------------------------------------------------
+
+long atbReader::status(comptype ct, Event_out ev)
+{
+  return status(BLOCK_, ct, ev);
+}
+long atbReader::status(long lTimeout, comptype ct, Event_out ev)
+{
+long      rc = missingComponent;
+
+    try
+    {
+      switch(ct)
+      {
+      case vCompReader::reader:
+
+           if(vcReader.isConnected())
+           {
+             if((rc = vcReader.query(lTimeout, ev)) == 0 && (lTimeout >= 0))
+               rc = ev->statusCode;
+           }
+           break;
+      }
+    }
+    catch(...) {}
+
+    trace(_HERE_7, "status query result: %s, rc = %d", scString(rc).c_str(), rc);
+
+    return(rc);
+}
+
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   atbReader::atbReader(amInterface *pAmi)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:42
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+atbReader::atbReader(amInterface *pAmi, atbReaderType readerCreation):
+  vCompReader(pAmi),
+  vCompDispenser(pAmi),
+  vcReader(static_cast<vCompReader*>(this)),
+  vcDispenser(static_cast<vCompDispenser*>(this)),
+  hasEscrowDispenser(false)
+{
+  long             rc = 0;
+  long             lIndex;
+
+    try
+    {
+      // try to connect all virtual components
+
+      // check characteristics
+      const char* pszRealComponent= 0;
+      lIndex= 0;
+
+      // find MediaInput with AEA and MagneticStripe
+      amInterface::MediaTypeSet mediatype;
+      amInterface::DataTypeSet datatype;
+      mediatype.insert(Characteristics::MediaType::MagneticStripe);
+      datatype.insert(Characteristics::AEA);
+      std::list<long> linkedComponents;
+
+      long lTestIndex= 0;
+      const char* pszTestRealComponent= 0;
+      do
+      {
+        pszTestRealComponent= pAmi->queryMediaInput(lTestIndex, mediatype, datatype);
+        pAmi->queryLinkedComponents(lTestIndex, linkedComponents, "MediaOutput");
+        if(linkedComponents.size() == 0)
+        {
+          // use the first MediaInput without MediaOutput
+          pszRealComponent= pszTestRealComponent;
+          lIndex= lTestIndex;
+          break;
+        }
+        if((!pszRealComponent) && (readerCreation == USE_ANY_READER))
+        {
+          // use a MediaInput with MediaOutput if there is no MediaInput without MediaOutput
+          pszRealComponent= pszTestRealComponent;
+          lIndex= lTestIndex;
+        }
+        lTestIndex++;
+      } while(pszTestRealComponent != 0);
+
+      if(pszRealComponent)
+      {
+        realComponent= pszRealComponent;
+        trace(_HERE_7, "use realcomponent: %s", pszRealComponent);
+        vcReader.storeIOR(pAmi->ior(lIndex, pszRealComponent, "MediaInput"));
+
+        long lStartIndex= 0;
+        vcDispenser.storeIOR(pAmi->iorLinked(lIndex, lStartIndex, "Dispenser"));
+
+        if(vcDispenser.canConnect())
+        {
+          EnvironmentComponents_var ec(pAmi->getComponents());
+          CORBA::ULong index= lIndex;
+          lIndex= ec[index].linkedComponents[lStartIndex];
+
+          lStartIndex= 0;
+          if(pAmi->iorLinked(lIndex, lStartIndex, "Dispenser") != 0)
+          {
+            hasEscrowDispenser= true;
+          }
+        }
+      }
+      else
+      {
+        trace(_HERE_7, "no component found for atbreader");
+      }
+
+      strcpy(vCompReader::szAppRef,   pAmi->getAppReference());
+      strcpy(vCompDispenser::szAppRef, pAmi->getAppReference());
+
+#ifdef SUPERUSER
+
+      strcpy(vCompReader::szAppRef,   "moorhuhn");
+      strcpy(vCompDispenser::szAppRef, "moorhuhn");
+
+#endif
+
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+    }
+
+    startProcessing();
+
+    vcReader.connect();
+    vcReader.setListener();
+    vcDispenser.connect();
+    vcDispenser.setListener();
+    readerType(); // for debug output only !!
+
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   atbReader::~atbReader()
+//
+//  purpose:    class destructor
+//
+//  date:       29.11.00, 15:42
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+atbReader::~atbReader()
+{
+  vcReader.clearListener();
+  vcDispenser.clearListener();
+}
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/baggage.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/baggage.cpp
new file mode 100644
index 00000000..a584507d
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/baggage.cpp
@@ -0,0 +1,887 @@
+//---------------------------------------------------------------------------
+//
+//  file:       baggage.cpp
+//
+//  purpose:    escrow device implementation
+//
+//  date:       07.11.2002
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include "cussif.h"
+#include "baggagedev.h"
+#include "check.h"
+#include "tracedef.h"
+#include "orbs.h"
+
+#include "textIDL/textcodes.h"
+#include "textIDL/texttypes.h"
+#include "textIDL/textcharacteristics.h"
+
+using namespace MASSAI::codes_text;
+using namespace MASSAI::characteristics_text;
+using namespace MASSAI::types_text;
+//#define SUPERUSER  // uses "moohuhn" token
+
+#define NSCC Characteristics::Conveyor
+
+using namespace MASSAI;
+
+//---------------------------------------------------------------------------
+//
+//  function:   long baggageDevice::accept(long lTimeOut)
+//
+//  purpose:    accept current bag
+//
+//  date:       07.11.2002, 12:01
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long baggageDevice::accept(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcConveyor.isConnected())
+      rc = vcConveyor.accept(lTimeOut, ev);
+    else
+      rc = missingComponent;
+
+    return(rc);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long baggageDevice::reject(long lTimeOut)
+//
+//  purpose:    return current bag to user
+//
+//  date:       07.11.2002, 12:01
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long baggageDevice::reject(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcConveyor.isConnected())
+      rc = vcConveyor.reject(lTimeOut, ev);
+    else
+      rc = missingComponent;
+
+    return(rc);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long baggageDevice::acceptAll(long lTimeOut)
+//
+//  purpose:    accept all bags, including parked
+//
+//  date:       07.11.2002, 12:01
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long baggageDevice::acceptAll(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcConveyor.isConnected())
+      rc = vcConveyor.forwardParked(lTimeOut, ev);
+    else
+      rc = missingComponent;
+
+    return(rc);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long baggageDevice::rejectAll(long lTimeOut)
+//
+//  purpose:    return all bags, including parked
+//
+//  date:       07.11.2002, 12:01
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long baggageDevice::rejectAll(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcConveyor.isConnected())
+      rc = vcConveyor.returnParked(lTimeOut, ev);
+    else
+      rc = missingComponent;
+
+    return(rc);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long baggageDevice::waitRemoved(long lTimeOut)
+//
+//  purpose:    wait for baggage to be removed from scale
+//
+//  date:       05.02.2003, 12:01
+//
+//  author:     Materna Information & Communications (MaK)
+//
+//---------------------------------------------------------------------------
+
+long baggageDevice::waitRemoved(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcConveyor.isConnected())
+      rc = vcConveyor.waitForRemovedBaggage(lTimeOut, ev);
+    else
+      rc = missingComponent;
+
+    return(rc);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long baggageDevice::getData(long lTimeOut)
+//
+//  purpose:    read data from vitual component
+//
+//  date:       07.11.2002
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long baggageDevice::getData(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcConveyor.isConnected())
+    {
+      if(((rc = vcConveyor.receive(lTimeOut, ev)) != 0) || (lTimeOut < 0))
+      {
+        trace(_HERE_1, "receive() for baggage data, rc = (%s) %d", rcString(rc).c_str(), rc);
+
+        return(rc);
+      }
+      else
+      {
+        // handle returned data directly if synchronous call !!
+
+        TypeCode_ptr tcp = ev->eventData.type();
+
+        if(tcp->equivalent(_tc_msgDataType))
+        {
+          trace(_HERE_1, "received msgDataType");
+
+          if(ev->statusCode  == m_statuscodes::OK
+            || ev->statusCode == m_statuscodes::DATA_PRESENT)
+          {
+            saveData(ev->eventData);
+          }
+          else
+          {
+            if(ev->statusCode  == m_statuscodes::DATA_MISSING)
+            {
+              clearData();
+            }
+            eventReceived(*ev);
+          }
+        }
+        else
+        {
+          trace(_HERE_1, "received invalid DataType");
+        }
+      }
+
+      return(checkStatusCode(ev));
+    }
+    else
+      return(missingComponent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long baggageDevice::noOfTags()
+//
+//  purpose:    return the number of scanned tags
+//
+//  date:       07.11.2002, 12:49
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long baggageDevice::noOfTags()
+{
+    return(lNoOfTags);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   char *baggageDevice::getTagData()
+//
+//  purpose:    return last saved baggage tag data
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+char *baggageDevice::getTagData(long index)
+{
+    if(index >= 0 && index < MAX_TAGS)
+    {
+      trace(_HERE_1, "scanner data[%d] = [%s], noOfTags = %d", lNoOfTags, abData[index], lNoOfTags);
+
+      return(abData[index]);
+    }
+    else
+    {
+      trace(_HERE_1, "index out of range, n = %d", index);
+      return(NULL);
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long baggageDevice::getWeight(float& weight, long lTimeOut)
+//
+//  purpose:    return the last saved weight
+//
+//  date:       07.11.2002, 12:20
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long baggageDevice::getWeight(float& weight)
+{
+long rc= m_returncodes::RC_OK;
+
+    /*
+    rc = getData(lTimeOut, ev);
+
+    trace(_HERE_1, "getData(%d ms), rc = %d", lTimeOut, rc);
+    */
+
+    weight = fWeight;
+
+    return(rc);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void baggageDevice::saveData(const datastream ds)
+//
+//  purpose:    save data from MSG data stream
+//
+//  date:       07.11.2002
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void baggageDevice::saveData(const datastream ds)
+{
+msgDataType *pData;
+char szTmp[256];
+
+    ds >>= pData;
+
+    if(pData->records.length())
+    {
+      trace(_HERE_1, "no. of records  = %d", pData->records.length());
+
+      // save weight data which must be in record [0]
+      unsigned int i;
+      for
+      (
+        i = 0;
+        pData->records.length() >= 1
+          && i < pData->records[0].message.length()
+          && i < sizeof(szTmp) - 1;
+        i++
+      )
+      {
+        szTmp[i] = pData->records[0].message[i];
+      }
+
+      szTmp[i] = '\0';
+
+      // convert to float value
+
+      fWeight = static_cast<float>(atof(szTmp));
+
+      fWeight /= 1000.00;
+
+      trace(_HERE_1, "scale data      = [%sg, %3.3fkg]", szTmp, fWeight);
+
+      // following records should contain data from the scanner
+      // more than one tag could be read at one time
+
+      if(pData->records.length() >= 2)
+      {
+        // start with record [1]
+
+        for(unsigned int j = 1, lNoOfTags = 0; j < pData->records.length() && j <= MAX_TAGS; j++)
+        {
+          // save data for each record
+
+          for(i = 0; i < pData->records[j].message.length() && i < sizeof(abData[j-1]); i++)
+            abData[j-1][i] = pData->records[j].message[i];
+
+          abData[j-1][i] = '\0';
+
+          lNoOfTags++;
+
+          trace(_HERE_1, "scanner data[%d] = [%s], noOfTags = %d", lNoOfTags, abData[j-1], lNoOfTags);
+        }
+      }
+      else
+      {
+        lNoOfTags = 0;
+
+        trace(_HERE_1, "no scanner data stored");
+      }
+    }
+    else
+      trace(_HERE_1, "no baggage data stored");
+
+    return;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void baggageDevice::clearData()
+//
+//  purpose:    helper function
+//
+//  date:       07.11.2002, 12:37
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void baggageDevice::clearData()
+{
+int i;
+
+    for(i = 0; i < MAX_TAGS; i++)
+       abData[i][0] = '\0';
+
+    lNoOfTags = 0;
+    fWeight   = 0.000;
+
+    return;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   baggageDevice::long open(long lTimeOut)
+//
+//  purpose:    opens device for coupon removal
+//
+//  date:       12.09.00, 10:33
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long baggageDevice::open(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    clearData();
+
+    if(vcConveyor.isConnected())
+    {
+      if(((rc = vcConveyor.enable(lTimeOut, ev)) != 0) || (lTimeOut < 0))
+        return(rc);
+      else
+        return(checkStatusCode(ev));
+    }
+    else
+      return(missingComponent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   baggageDevice::long close(long lTimeOut)
+//
+//  purpose:    closes device
+//
+//  date:       12.09.00, 10:35
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long baggageDevice::close(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    clearData();
+
+    if(vcConveyor.isConnected())
+    {
+      if(((rc = vcConveyor.disable(lTimeOut, ev)) != 0) || (lTimeOut < 0))
+        return(rc);
+      else
+        return(checkStatusCode(ev));
+    }
+    else
+      return(missingComponent);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   long baggageDevice::cancel(long lTimeOut)
+//
+//  purpose:    cancel the last command
+//
+//  date:       05.02.2003
+//
+//  author:     Dr. Materna GmbH (TS)
+//
+//---------------------------------------------------------------------------
+
+long baggageDevice::cancel(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcConveyor.isConnected())
+    {
+      rc = vcConveyor.cancel(ev);
+      return(rc);
+    }
+    else
+      return(missingComponent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void baggageDevice::conveyorCallback(const Event &ev, int id)
+//
+//  purpose:    Check events sent by the component here
+//
+//  date:       29.11.00, 15:07
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void baggageDevice::conveyorCallback(const Event &ev, int id)
+{
+    vCompConveyor::lError = ev.statusCode;
+
+    trace(_HERE_1, "Conveyor (%d); event code: (%s) (%d), status code: (%s) (%d) for %s", id, eventCodesText(ev.eventCode).c_str(), ev.eventCode, scString(ev.statusCode).c_str(), ev.statusCode, ev.functionName.in());
+
+
+    if(!*ev.functionName && ev.statusCode == m_statuscodes::OK)
+    {
+      // unsolicited event ??
+      if(!eventReceived(ev))
+        handleException(ev.eventCode, ev.statusCode, ev.functionName.in());
+    }
+    else if(!eventReceived(ev))
+    {
+      switch(ev.statusCode)
+      {
+      //case m_statuscodes::BAGGAGE_READY_FOR_TAKE_IN:      baggageParked();        break;
+      case m_statuscodes::BAGGAGE_DELIVER:                baggageDelivered();     break;
+
+      case m_statuscodes::BAGGAGE_PRESENT:                baggagePresent();       break;
+      case m_statuscodes::BAGGAGE_ABSENT:                 baggageRemoved();       break;
+      case m_statuscodes::BAGGAGE_OVERSIZED:              baggageOversized();     break;
+      case m_statuscodes::BAGGAGE_ILLICIT_WEIGHT_CHANGE:  baggageWeightChanged(); break;
+
+      case m_statuscodes::DATA_PRESENT:                   dataPresent();          break;
+      case m_statuscodes::TIMEOUT:                        commandTimeout();       break;
+      case m_statuscodes::CANCELLED:                      commandCancelled();     break;
+
+      case m_statuscodes::OK:
+
+        if(strcmp(ev.functionName, "accept") == 0)
+        {
+          baggageParked();
+        }
+        else if(strcmp(ev.functionName, "waitForRemovedBaggage") == 0)
+        {
+          baggageRemoved();
+        }
+        commandPerformed(ev.eventCode, ev.statusCode, ev.functionName.in());
+        break;
+
+      case m_statuscodes::BAGGAGE_FULL:
+      case m_statuscodes::BAGGAGE_UNDETECTED:
+
+      default:                                            handleException(ev.eventCode,
+                                                                          ev.statusCode,
+                                                                          ev.functionName.in());
+                                                                                  break;
+      }
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void baggageDevice::baggagePresent()
+//
+//  purpose:    called on baggage presence (virtual)
+//
+//  date:       07.11.2002, 15:48
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void baggageDevice::baggagePresent()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void baggageDevice::baggageRemoved()
+//
+//  purpose:    called on baggage removal (virtual)
+//
+//  date:       07.11.2002, 15:48
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void baggageDevice::baggageRemoved()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void baggageDevice::baggageParked()
+//
+//  purpose:    called when baggage in park position (virtual)
+//
+//  date:       07.11.2002, 15:48
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void baggageDevice::baggageParked()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void baggageDevice::baggageDelivered()
+//
+//  purpose:    called on baggage delivery to airport baggage system (virtual)
+//
+//  date:       07.11.2002, 15:48
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void baggageDevice::baggageDelivered()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void baggageDevice::baggageOversized()
+//
+//  purpose:    called on baggage oversize detection (virtual)
+//
+//  date:       07.11.2002, 15:48
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void baggageDevice::baggageOversized()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void baggageDevice::baggageWeightChanged()
+//
+//  purpose:    called on baggage weight change (virtual)
+//
+//  date:       07.11.2002, 15:48
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void baggageDevice::baggageWeightChanged()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void baggageDevice::dataPresent()
+//
+//  purpose:    called upon baggage data presence (virtual)
+//
+//  date:       07.11.2002
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void baggageDevice::dataPresent()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void baggageDevice::commandTimeout()
+//
+//  purpose:    called if command timeout has occurred
+//
+//  date:       21.02.01, 10:35
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void baggageDevice::commandTimeout()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void baggageDevice::commandCancelled()
+//
+//  purpose:    calles if command has been cancelled
+//
+//  date:       21.02.01, 10:35
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void baggageDevice::commandCancelled()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void baggageDevice::commandPerformed(long eventCode,
+//                                                   long statusCode,
+//                                                   const char *pszFunction)
+//
+//  purpose:    called if async call returned OK
+//
+//  date:       10.02.2003, 12:04
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void baggageDevice::commandPerformed(long eventCode, long statusCode, const char *pszFunction)
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void baggageDevice::handleException(long eventCode,
+//                                              long statusCode,
+//                                              const char *pszFunction)
+//
+//  purpose:    called if an unhandled status code (error) has been received
+//
+//  date:       21.02.01, 10:36
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void baggageDevice::handleException(long eventCode, long statusCode, const char *pszFunction)
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool baggageDevice::eventReceived(long eventCode,
+//                                            long statusCode,
+//                                            const char *pszFunction)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+bool baggageDevice::eventReceived (const Event& ev)
+{
+  return eventReceived(ev.eventCode, ev.statusCode, ev.functionName.in());
+}
+bool baggageDevice::eventReceived(long eventCode, long statusCode, const char *pszFunction)
+{
+    trace(_HERE_1, "eventReceived(ec = %d, sc = %d, function = %s)", eventCode, statusCode, pszFunction);
+    return(false);
+}
+
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   baggageDevice::baggageDevice(amInterface  *pAmi)
+//
+//  purpose:    class constructor, aquires the virtual component
+//
+//  date:       12.09.00, 10:36
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+baggageDevice::baggageDevice(amInterface  *pAmi):
+  vCompConveyor(pAmi),
+  vcConveyor(static_cast<vCompConveyor*>(this))
+{
+const char      *pszIOR;
+long             lIndex;
+char             szTmp[256];
+
+    clearData();
+
+    try
+    {
+      // try to connect all virtual components
+
+      lIndex = 0;
+      vcConveyor.storeIOR(pAmi->ior(lIndex, "Conveyor", "Conveyor"));
+
+      if(vcConveyor.canConnect())
+      {
+        realComponent= "Conveyor";
+        trace(_HERE_7, "use realcomponent: Conveyor");
+      }
+      else
+      {
+        const char* pszRealComponent;
+        lIndex= 0;
+        if(((pszRealComponent= pAmi->queryConveyor(lIndex)) != NULL)
+          && ((pszIOR = pAmi->ior(lIndex, pszRealComponent, "Conveyor")) != NULL))
+        {
+          // a conveyor component must be in the linked component list
+          realComponent= pszRealComponent;
+          trace(_HERE_7, "use realcomponent: %s", pszRealComponent);
+          vcConveyor.storeIOR(pszIOR);
+        }
+      }
+
+      strcpy(vCompConveyor::szAppRef,     pAmi->getAppReference());
+
+#ifdef SUPERUSER
+
+      strcpy(vCompConveyor::szAppRef,     "moorhuhn");
+
+#endif
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+    }
+
+    vcConveyor.connect();
+    vcConveyor.setListener();
+    if(vcConveyor.isConnected())
+    {
+      trace(_HERE_1, "CONVEYOR Characteristics:");
+
+      *szTmp = '\0';
+
+      switch(vcConveyor.getTypeOfConveyor())
+      {
+      case NSCC::Scale:                  strcpy(szTmp, "Conveyor has a scale only"); break;
+      case NSCC::BCR:                    strcpy(szTmp, "Conveyor has a barcode reader only"); break;
+      case NSCC::Scale_BCR:              strcpy(szTmp, "Conveyor has a scale and a barcode reader"); break;
+      case NSCC::Scale_ParkPosition:     strcpy(szTmp, "Conveyor has a scale and a park position for bags"); break;
+      case NSCC::BCR_ParkPosition:       strcpy(szTmp, "Conveyor has a barcode reader and a park position for bags"); break;
+      case NSCC::Scale_BCR_ParkPosition: strcpy(szTmp, "Conveyor has a scale, a barcode reader and a park position for bags"); break;
+
+      default: strcpy(szTmp, "Non applicable characteristic value"); break;
+      }
+
+      trace(_HERE_1, "CONVEYOR:Type                  = %s", szTmp);
+
+      trace(_HERE_1, "CONVEYOR:maxWidth              = %d", vcConveyor.getMaxWidth());
+      trace(_HERE_1, "CONVEYOR:maxHeigth             = %d", vcConveyor.getMaxHeigth());
+      trace(_HERE_1, "CONVEYOR:maxLength             = %d", vcConveyor.getMaxLength());
+      trace(_HERE_1, "CONVEYOR:maxWeight             = %d", vcConveyor.getMaxWeight());
+      trace(_HERE_1, "CONVEYOR:guarenteedNoOfBags    = %d", vcConveyor.getGuarenteedNoOfBags());
+      trace(_HERE_1, "CONVEYOR:currentNoOfBagsParked = %d", vcConveyor.getCurrentNoOfBagsParked());
+
+      char* pDefault= "";
+      trace(_HERE_1, "CONVEYOR:manufacturerName            = %s", vcConveyor.manufacturerName());
+      trace(_HERE_1, "CONVEYOR:firmwareVersion             = %s", vcConveyor.firmwareVersion());
+      trace(_HERE_1, "CONVEYOR:modelNumber                 = %s", vcConveyor.modelNumber());
+      trace(_HERE_1, "CONVEYOR:realComponentIdentification = %s", vcConveyor.realComponentIdentification());
+      trace(_HERE_1, "CONVEYOR:serialNumber                = %s", vcConveyor.serialNumber());
+    }
+    else
+      trace(_HERE_1, "CONVEYOR not connected.");
+}
+
+long baggageDevice::status(comptype ct, Event_out ev)
+{
+   return status(BLOCK_, ct, ev);
+}
+long baggageDevice::status(long lTimeout, comptype ct, Event_out ev)
+{
+    long      rc = missingComponent;
+
+    try
+    {
+        if(vcConveyor.isConnected())
+        {
+            if((rc = vcConveyor.query(lTimeout, ev)) == 0 && (lTimeout >= 0))
+            rc = ev->statusCode;
+        }
+        else
+            trace(_HERE_7, "vcConveyor not connected");
+    }
+    catch(...) {}
+
+    trace(_HERE_7, "status query result: %s, rc = %d", scString(rc).c_str(), rc);
+
+    return rc;
+}
+
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   baggageDevice::~baggageDevice()
+//
+//  purpose:    class destructor, releases the device
+//
+//  date:       07.11.2002
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+baggageDevice::~baggageDevice()
+{
+  vcConveyor.clearListener();
+}
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/bcs.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/bcs.cpp
new file mode 100644
index 00000000..1b33005c
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/bcs.cpp
@@ -0,0 +1,682 @@
+/**
+ *  @file      bcs.cpp
+ *
+ *  @brief     barcode reader device implementation
+ *
+ *  @date      27.09.2005
+ *
+ *  @author    Materna Information & Communications (AGe)
+ *
+ ************************************************************************/
+
+#include "cussif.h"
+#include "bcsdev.h"
+#include "check.h"
+#include "tracedef.h"
+#include "orbs.h"
+
+#include "textIDL/textcodes.h"
+#include "textIDL/texttypes.h"
+#include "textIDL/textcharacteristics.h"
+
+using namespace MASSAI::codes_text;
+using namespace MASSAI::characteristics_text;
+using namespace MASSAI::types_text;
+
+using namespace MASSAI;
+
+#define NSC_MI Characteristics::MediaInput
+
+namespace
+{
+  Characteristics::ComponentFonts::BarcodeStandard getBarcodeStandard(bcsDevice::barcodetype bc)
+  {
+    switch(bc)
+    {
+      case bcsDevice::BT_CODE39:      return Characteristics::ComponentFonts::Code39;
+      case bcsDevice::BT_CODE128:     return Characteristics::ComponentFonts::Code128;
+      case bcsDevice::BT_CODE2OF5:    return Characteristics::ComponentFonts::Code2of5;
+      default:                        return Characteristics::ComponentFonts::nonApplicableBarcodeStandard;
+    }
+  }
+  bcsDevice::barcodetype getBarcodeStandard(Characteristics::ComponentFonts::BarcodeStandard bc)
+  {
+    switch(bc)
+    {
+      case Characteristics::ComponentFonts::Code39:      return bcsDevice::BT_CODE39;
+      case Characteristics::ComponentFonts::Code128:     return bcsDevice::BT_CODE128;
+      case Characteristics::ComponentFonts::Code2of5:    return bcsDevice::BT_CODE2OF5;
+      default:                                           return bcsDevice::BT_ERROR;
+    }
+  }
+}
+
+// discard old response/indication
+void bcsDevice::clearData()
+{
+  abData[0] = '\0';
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bcsDevice::saveData(const datastream ds)
+//
+//  purpose:    save data from MSG data stream
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void bcsDevice::saveData(const datastream ds)
+{
+msgDataType *pData;
+    ds >>= pData;
+
+    memset(abData, 0, sizeof(abData));
+
+    if(pData->records.length())
+    {
+      for
+      (
+        unsigned int i = 0;
+        pData->records.length() >= 1
+          && i < pData->records[0].message.length()
+          && i < sizeof(abData);
+          i++
+      )
+      {
+        abData[i] = pData->records[0].message[i];
+      }
+
+      trace(_HERE_7, "DATA = [%s]", abData);
+    }
+    else
+      trace(_HERE_7, "no bcs data stored");
+
+    return;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bcsDevice::readerCallback(const Event &ev, int id)
+//
+//  purpose:    callback function for the reader component
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void bcsDevice::readerCallback(const Event &ev, int id)
+{
+    vCompReader::lError = ev.statusCode;
+
+    trace(_HERE_1, "Reader (%d); event code: (%s) (%d), status code: (%s) (%d) for %s", id, eventCodesText(ev.eventCode).c_str(), ev.eventCode, scString(ev.statusCode).c_str(), ev.statusCode, ev.functionName.in());
+
+    if(!*ev.functionName && ev.statusCode == m_statuscodes::OK)
+    {
+      // unsolicited event ??
+      if(!eventReceived(ev))
+        handleException(ev.eventCode, ev.statusCode, ev.functionName.in());
+    }
+    else if(!eventReceived(ev))
+    {
+      switch(ev.statusCode)
+      {
+      case m_statuscodes::OK:                                break;
+      case m_statuscodes::MEDIA_PRESENT: documentInserted(); break;
+      case m_statuscodes::MEDIA_ABSENT:  documentRemoved();  break;
+
+      case m_statuscodes::DATA_PRESENT:  dataPresent();      break;
+
+      case m_statuscodes::TIMEOUT:       commandTimeout();   break;
+      case m_statuscodes::CANCELLED:     commandCancelled(); break;
+      default:                           handleException(ev.eventCode, ev.statusCode, ev.functionName.in()); break;
+      }
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long bcsDevice::open(long lTimeOut)
+//
+//  purpose:    enable device for document insertion
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long bcsDevice::open(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+    clearData();
+    if(vcReader.isConnected())
+    {
+      if(((rc = vcReader.enable(lTimeOut, ev)) != 0) || (lTimeOut < 0))
+      {
+        trace(_HERE_7, "open bcs: (%s) (%d)", rcString(rc).c_str(), rc);
+        return(rc);
+      }
+      else
+        return(checkStatusCode(ev));
+    }
+    else
+      return(missingComponent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long bcsDevice::close(long lTimeOut)
+//
+//  purpose:    disable device from document insertion
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long bcsDevice::close(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcReader.isConnected())
+    {
+      if(((rc = vcReader.disable(lTimeOut, ev)) != 0) || (lTimeOut < 0))
+        return(rc);
+      else
+        return(checkStatusCode(ev));
+    }
+    else
+      return(missingComponent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long bcsDevice::cancel(long lTimeOut)
+//
+//  purpose:    cancel the last command (read or eject)
+//
+//  date:       26.03.2004
+//
+//  author:      Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long bcsDevice::cancel(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcReader.isConnected())
+    {
+      rc = vcReader.cancel(ev);
+
+      return(rc);
+    }
+    else
+      return(missingComponent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long bcsDevice::read(long lTimeOut)
+//
+//  purpose:    read bdata from vitual component
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long bcsDevice::read(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcReader.isConnected())
+    {
+      if(((rc = vcReader.receive(lTimeOut, ev)) != 0) || (lTimeOut < 0))
+      {
+        trace(_HERE_7, "receive() for document data, rc = (%s) (%d)", rcString(rc).c_str(), rc);
+
+        return(rc);
+      }
+      else
+      {
+        // handle returned data directly if synchronous call !!
+
+        TypeCode_ptr tcp = ev->eventData.type();
+
+        if(tcp->equivalent(_tc_msgDataType))
+        {
+          trace(_HERE_7, "received msgDataType");
+
+          if(ev->statusCode  == m_statuscodes::OK
+            || ev->statusCode == m_statuscodes::DATA_PRESENT)
+          {
+            saveData(ev->eventData);
+          }
+          else
+          {
+            if(ev->statusCode  == m_statuscodes::DATA_MISSING)
+            {
+              clearData();
+            }
+            eventReceived(*ev);
+          }
+        }
+        else
+        {
+          trace(_HERE_7, "received invalid DataType");
+        }
+      }
+
+      return(checkStatusCode(ev));
+    }
+    else
+      return(missingComponent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   char *bcsDevice::getData()
+//
+//  purpose:    return data from track 1
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+char *bcsDevice::getData()
+{
+    return(abData);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bcsDevice::documentInserted()
+//
+//  purpose:    called upon document insertion event (virtual)
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void bcsDevice::documentInserted()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bcsDevice::dataPresent()
+//
+//  purpose:    called upon document data presence (virtual)
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void bcsDevice::dataPresent()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bcsDevice::documentRemoved()
+//
+//  purpose:    called upon document rempval event (virtual)
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void bcsDevice::documentRemoved()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bcsDevice::commandTimeout()
+//
+//  purpose:    called if command timeout has occurred
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void bcsDevice::commandTimeout()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bcsDevice::commandCancelled()
+//
+//  purpose:    calles if command has been cancelled
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void bcsDevice::commandCancelled()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void bcsDevice::handleException(long eventCode,
+//                                              long statusCode,
+//                                              const char *pszFunction)
+//
+//  purpose:    called if an unhandled status code (error) has been received
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void bcsDevice::handleException(long eventCode, long statusCode, const char *pszFunction)
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool bcsDevice::eventReceived(long eventCode,
+//                                            long statusCode,
+//                                            const char *pszFunction)
+//
+//  purpose:
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+bool bcsDevice::eventReceived (const Event& ev)
+{
+  return eventReceived(ev.eventCode, ev.statusCode, ev.functionName.in());
+}
+bool bcsDevice::eventReceived(long eventCode, long statusCode, const char *pszFunction)
+{
+    return(false);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   readertype bcsDevice::readerType()
+//
+//  purpose:    return the reader type from characteristics
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+bcsDevice::readertype bcsDevice::readerType()
+{
+bcsDevice::readertype rt = RT_ERROR;
+char       szTmp[256];
+
+    if(vcReader.isConnected())
+    {
+      switch(vcReader.getTypeOfReader())
+      {
+      case NSC_MI::Motorized:
+
+           strcpy(szTmp, "Motorized");
+           rt = RT_MOTORIZED;
+           break;
+
+      case NSC_MI::Swipe:
+
+           strcpy(szTmp, "Swipe");
+           rt = RT_SWIPE;
+           break;
+
+      case NSC_MI::Contactless:
+
+           strcpy(szTmp, "Contactless");
+           rt = RT_CONTACTLESS;
+           break;
+
+      case NSC_MI::DIP:
+
+           strcpy(szTmp, "DIP");
+           rt = RT_DIP;
+           break;
+
+      case NSC_MI::nonApplicableReaderType:
+
+           strcpy(szTmp, "nonApplicableReaderType");
+           rt = RT_ERROR;
+           break;
+
+      case NSC_MI::FlatbedScan:
+
+           strcpy(szTmp, "FlatbedScan");
+           rt = RT_FLATBED;
+           break;
+
+      case NSC_MI::PenScan:
+
+           strcpy(szTmp, "PenScan");
+           rt = RT_PENSCAN;
+           break;
+      }
+
+      trace(_HERE_7, "ReaderType = %s", szTmp);
+    }
+
+    return(rt);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   barcodeType bcsDevice::barcodeType()
+//
+//  purpose:    return the barcodeType from characteristics
+//
+//  date:       28.03.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+bcsDevice::barcodetype bcsDevice::barcodeType()
+{
+  bcsDevice::barcodetype result= BT_ERROR;
+  if(vcReader.isConnected())
+  {
+    result= getBarcodeStandard(vcReader.getUsedStandard());
+  }
+  return result;
+}
+
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long bcsDevice::status(comptype ct)
+ *
+ *  @brief     query status on specific virtual component
+ *
+ *  @date      20.10.2004
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long bcsDevice::status(comptype ct, Event_out ev)
+{
+  return status(BLOCK_, ct, ev);
+}
+long bcsDevice::status(long lTimeout, comptype ct, Event_out ev)
+{
+long      rc = missingComponent;
+
+    try
+    {
+      switch(ct)
+      {
+      case vCompReader::reader:
+
+           if(vcReader.isConnected())
+           {
+             if((rc = vcReader.query(lTimeout, ev)) == 0 && (lTimeout >= 0))
+               rc = ev->statusCode;
+           }
+           break;
+      }
+    }
+    catch(...) {}
+
+    trace(_HERE_7, "status query result: %s, rc = %d", scString(rc).c_str(), rc);
+
+    return(rc);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   bcsDevice::bcsDevice(amInterface *pAmi)
+//
+//  purpose:    class constructor - aquire virutal components
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+bcsDevice::bcsDevice(amInterface *pAmi):
+  vCompReader(pAmi),
+  vcReader(static_cast<vCompReader*>(this))
+{
+long             lIndex;
+
+    memset(abData, 0, sizeof(abData));
+
+    try
+    {
+      // try to connect all virtual components
+      lIndex = 0;
+      vcReader.storeIOR(pAmi->ior(lIndex, "BarCodeScanner", "MediaInput"));
+      if(vcReader.canConnect())
+      {
+        realComponent= "BarCodeScanner";
+        trace(_HERE_7, "use realcomponent: BarCodeScanner");
+      }
+      else
+      {
+        const char* pszRealComponent= 0;
+        amInterface::MediaTypeSet mediatype;
+        amInterface::DataTypeSet datatype;
+        mediatype.insert(Characteristics::MediaType::Printed);
+        datatype.insert(Characteristics::MSG);
+        lIndex= 0;
+        pszRealComponent= pAmi->queryMediaInputNegateBarcode(lIndex, Characteristics::ComponentFonts::nonApplicableBarcodeStandard, mediatype, datatype);
+        //pszRealComponent= pAmi->queryMediaInput(lIndex, mediatype, datatype);
+        if(pszRealComponent)
+        {
+          realComponent= pszRealComponent;
+          trace(_HERE_7, "use realcomponent: %s", pszRealComponent);
+          vcReader.storeIOR(pAmi->ior(lIndex, pszRealComponent, "MediaInput"));
+        }
+      }
+      strcpy(vCompReader::szAppRef, pAmi->getAppReference());
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      trace(_HERE_7, "CORBA::SystemException:\n%s", ex._message());
+    }
+
+    vcReader.connect();
+    vcReader.setListener();
+
+    readerType(); // for debug output only !!
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   bcsDevice::bcsDevice(amInterface *pAmi)
+//
+//  purpose:    class constructor - aquire virutal components
+//
+//  date:       28.03.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+bcsDevice::bcsDevice(amInterface *pAmi, barcodetype select):
+  vCompReader(pAmi),
+  vcReader(static_cast<vCompReader*>(this))
+{
+long             lIndex;
+
+    memset(abData, 0, sizeof(abData));
+
+    try
+    {
+      // try to connect virtual components
+
+      const char* pszRealComponent= 0;
+      amInterface::MediaTypeSet mediatype;
+      amInterface::DataTypeSet datatype;
+      mediatype.insert(Characteristics::MediaType::Printed);
+      datatype.insert(Characteristics::MSG);
+      lIndex= 0;
+      pszRealComponent= pAmi->queryMediaInput(lIndex, getBarcodeStandard(select), mediatype, datatype);
+      if(pszRealComponent)
+      {
+        realComponent= pszRealComponent;
+        trace(_HERE_7, "use realcomponent: %s", pszRealComponent);
+        vcReader.storeIOR(pAmi->ior(lIndex, pszRealComponent, "MediaInput"));
+        strcpy(vCompReader::szAppRef, pAmi->getAppReference());
+      }
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      trace(_HERE_7, "CORBA::SystemException:\n%s", ex._message());
+    }
+
+    vcReader.connect();
+    vcReader.setListener();
+
+    readerType(); // for debug output only !!
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   bcsDevice::~bcsDevice()
+//
+//  purpose:    class destructor - release aquired virtual components
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+bcsDevice::~bcsDevice()
+{
+  vcReader.clearListener();
+}
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/btp.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/btp.cpp
new file mode 100644
index 00000000..5de33668
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/btp.cpp
@@ -0,0 +1,1048 @@
+//---------------------------------------------------------------------------
+//
+//  file:       btp.cpp
+//
+//  purpose:    btp device implementation
+//
+//  date:       24.07.2001
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include "cussif.h"
+#include "btpdev.h"
+#include "check.h"
+#include "tracedef.h"
+#include "orbs.h"
+#include "textIDL/textcodes.h"
+#include "textIDL/texttypes.h"
+#include "textIDL/textcharacteristics.h"
+
+using namespace MASSAI::codes_text;
+using namespace MASSAI::characteristics_text;
+using namespace MASSAI::types_text;
+
+
+//#define SUPERUSER  // uses "moohuhn" token
+
+#include "btpscanner.h"
+
+using namespace MASSAI;
+
+//---------------------------------------------------------------------------
+//
+//  function:   massai::cussif::MediaOutput* btpDevice::findVirtualWriter(char *pszData, PaperTypes *pt)
+//
+//  purpose:    Try to find the correct virtual printer for the passed data stream
+//
+//  date:       03.05.2002, 14:51
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+massai::cussif::MediaOutput* btpDevice::findVirtualWriter(char *pszData,
+                                             MASSAI::btpScanner::PaperTypes *pt)
+{
+btpScanner             scanner;
+btpScanner::PaperTypes paperType;
+
+massai::cussif::MediaOutput* vc = 0;
+
+long noOfDocsAvailable = 0;
+
+    if(pszData && *pszData)
+    {
+      paperType = scanner.checkPaperType(pszData);
+
+      // save this value, too
+
+      if(pt) { *pt = paperType; }
+
+      switch(paperType)
+      {
+      case btpScanner::Setup:
+
+           // PECTABS, LOGOS etc. all to the same virtual printer
+
+           trace(_HERE_7, "btpScanner::Setup, using standard writer component");
+
+           vc = &vcWriter;
+           break;
+
+      case btpScanner::BaggageTag:
+
+           trace(_HERE_7, "btpScanner::BaggageTag, using standard writer component");
+
+           vc = &vcWriter;
+           break;
+
+      case btpScanner::Error:
+      default:
+
+           // do nothing in these cases !!
+
+           trace(_HERE_7, "no appropriate paper type for [%s]", pszData);
+           break;
+      }
+
+      // return the component found, if any !!
+
+      return(vc);
+    }
+    else
+      return(vc);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   long bppDevice::docsAvailable()
+//
+//  purpose:    return the number of available docs
+//
+//---------------------------------------------------------------------------
+
+long btpDevice::docsAvailable()
+{
+  long noOfDocsAvailable= vcBin1.getCurrentNoOfDocuments();
+  trace(_HERE_7, "no. of docs  = %d", noOfDocsAvailable);
+  return noOfDocsAvailable;
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   char *btpDevice::checkBTPResponse(char *pszData, long *plStatusCode)
+//
+//  purpose:    Check BTP data for errors
+//
+//  date:       23.03.2001, 16:11
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+char *btpDevice::checkBTPResponse(char *pszData, long *plStatusCode)
+{
+static char  szError[256];
+
+char *pStr;
+char  c;
+long  n;
+
+    *szError = '\0';
+
+    trace(_HERE_7, "checking response ...");
+
+    if(!pszData || !plStatusCode)
+    {
+      sprintf(szError, "parameter error");
+
+      trace(_HERE_7, "%s", szError);
+
+      return(szError);
+    }
+
+    *plStatusCode = m_statuscodes::OK;
+
+    if((pStr = strstr(pszData, "PROK")) != NULL)
+    {
+      pStr += 4;
+
+      c = *pStr;
+
+      // check for paper out flag !!
+
+      if(*pStr == 'O')
+      {
+        trace(_HERE_7, "BTP out of paper.");
+
+        sprintf(szError, "Paper out");
+        *plStatusCode = m_statuscodes::CONSUMABLES;
+      }
+
+      pStr += 1; // number of tags printed
+
+      n = atoi(pStr);
+
+      trace(_HERE_7, "no. of tags printed: %d", n);
+    }
+    else if((pStr = strstr(pszData, "ERR")) != NULL)
+    {
+      pStr += 4;
+
+      c = *pStr;
+
+      // check for paper out flag !!
+
+      if(*pStr == 'O')
+      {
+        trace(_HERE_7, "BTP out of paper.");
+
+        sprintf(szError, "Paper out");
+        *plStatusCode = m_statuscodes::CONSUMABLES;
+      }
+      else
+      {
+        trace(_HERE_7, "BTP error.");
+
+        *plStatusCode =  m_statuscodes::HARDWARE_ERROR;
+         sprintf(szError, "unsuccessful print, %s", pszData);
+      }
+    }
+
+    trace(_HERE_7, "checking response done. err = %s", szError);
+
+    return(szError);
+}
+
+void btpDevice::callback(CallbackComponent component, const types::Event& ev, int id)
+{
+  switch(component)
+  {
+    case CC_WRITER:
+      process_writerCallback(ev, id);
+      break;
+    case CC_DISPENSER:
+      process_dispenserCallback(ev, id);
+      break;
+    case CC_FEEDER:
+      process_feederCallback(ev, id);
+      break;
+  }
+}
+void btpDevice::writerCallback(const Event& ev, int id)
+{
+  enqueue(CC_WRITER, ev, id);
+}
+void btpDevice::dispenserCallback(const Event& ev, int id)
+{
+  enqueue(CC_DISPENSER, ev, id);
+}
+void btpDevice::feederCallback(const Event &ev, int id)
+{
+  enqueue(CC_FEEDER, ev, id);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   void btpDevice::process_writerCallback(const Event &ev, int id)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void btpDevice::process_writerCallback(const Event &ev, int id)
+{
+char szError[256];
+long lStatusCode;
+
+    //0.1 strcpy(vCompWriter::sz3LCode, ev.machineLocationCode);
+    //0.1 strcpy(vCompWriter::szID, ev.machineIdentifier);
+
+    vCompWriter::lError = ev.statusCode;
+
+    trace(_HERE_1, "Writer (%d); event code: (%s) (%d), status code: (%s) (%d) for %s", id, eventCodesText(ev.eventCode).c_str(), ev.eventCode, scString(ev.statusCode).c_str(), ev.statusCode, ev.functionName.in());
+
+    if(*ev.functionName && strcmp(ev.functionName.in(), "send") == 0)
+    {
+      try
+      {
+        Event_var ev1;
+        vcWriter.disable(0, ev1);
+      }
+      catch(CORBA::SystemException& ex)
+      {
+        trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+      }
+      catch(...)
+      {
+        trace(_HERE_1, "... exception occured");
+      }
+    }
+
+
+    TypeCode_ptr tcp = ev.eventData.type();
+    trace(_HERE_9, "Typecode parsed");
+    if(tcp->equivalent(_tc_aeaDataType))
+    {
+        trace(_HERE_9, "Typecode is aea");
+      //if(ev.statusCode == m_statuscodes::DATA_PRESENT)
+        saveData(ev.eventData);
+    }
+
+    if(!*ev.functionName && ev.statusCode == m_statuscodes::OK)
+    {
+      // unsolicited event ??
+      if(!eventReceived(ev))
+        handleException(ev.eventCode, ev.statusCode, ev.functionName.in());
+    }
+    else if(!eventReceived(ev))
+    {
+      switch(ev.statusCode)
+      {
+      case m_statuscodes::OK:
+      case m_statuscodes::MEDIA_PRESENT:
+
+           if(*ev.functionName)
+           {
+             // handle returned data directly if synchronous call !!
+
+             TypeCode_ptr tcp = ev.eventData.type();
+
+             if(tcp->equivalent(_tc_aeaDataType))
+             {
+               saveData(ev.eventData);
+
+               trace(_HERE_7, "BTP-RSP [%s], func = %s", getData(), ev.functionName.in());
+
+               strcpy(szError, checkBTPResponse(getData(), &lStatusCode));
+
+               if(*szError)
+                 printError(lStatusCode, szError);
+               else
+               {
+                 if(!strcmp(ev.functionName.in(), "setup"))
+                   setupResponse();
+                 else
+                   bagtagPrinted();
+               }
+             }
+           }
+           break;
+
+      case m_statuscodes::TIMEOUT:   commandTimeout(); break;
+      case m_statuscodes::CANCELLED: commandCancelled(); break;
+      default:                     handleException(ev.eventCode, ev.statusCode, ev.functionName.in()); break;
+      }
+    }
+}
+//---------------------------------------------------------------------------
+//
+//  function:   void btpDevice::process_dispenserCallback(const Event &ev, int id)
+//
+//  purpose:
+//
+//---------------------------------------------------------------------------
+
+void btpDevice::process_dispenserCallback(const Event &ev, int id)
+{
+  vCompDispenser::lError = ev.statusCode;
+
+  trace(_HERE_1, "Dispenser (%d); event code: (%s) (%d), status code: (%s) (%d) for %s", id, eventCodesText(ev.eventCode).c_str(), ev.eventCode, scString(ev.statusCode).c_str(), ev.statusCode, ev.functionName.in());
+
+  if(*ev.functionName && strcmp(ev.functionName.in(), "offer") == 0)
+  {
+    try
+    {
+      Event_var ev;
+      vcDispenser.disable(0, ev);
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+    }
+    catch(...)
+    {
+      trace(_HERE_1, "... exception occured");
+    }
+  }
+
+  TypeCode_ptr tcp = ev.eventData.type();
+
+  if(tcp->equivalent(_tc_aeaDataType))
+  {
+    trace(_HERE_7, "received aeaDataType");
+
+    // try to save any ATB response
+
+    saveData(ev.eventData);
+  }
+
+  if(!*ev.functionName && ev.statusCode == m_statuscodes::OK)
+  {
+    // unsolicited event ??
+    if(!eventReceived(ev))
+      handleException(ev.eventCode, ev.statusCode, ev.functionName.in());
+  }
+  else if(!eventReceived(ev))
+  {
+    switch(ev.statusCode)
+    {
+    case m_statuscodes::OK:           if(*ev.functionName) bagtagEjected(); break;
+
+    case m_statuscodes::TIMEOUT:      commandTimeout(); break;
+    case m_statuscodes::CANCELLED:    commandCancelled(); break;
+    default:                          handleException(ev.eventCode, ev.statusCode, ev.functionName.in()); break;
+    }
+  }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void btpDevice::process_feederCallback(const Event &ev, int id)
+//
+//  purpose:
+//
+//---------------------------------------------------------------------------
+
+void btpDevice::process_feederCallback(const Event &ev, int id)
+{
+  vCompFeeder::lError = ev.statusCode;
+
+  trace(_HERE_1, "Feeder (%d); event code: (%s) (%d), status code: (%s) (%d) for %s", id, eventCodesText(ev.eventCode).c_str(), ev.eventCode, scString(ev.statusCode).c_str(), ev.statusCode, ev.functionName.in());
+
+  TypeCode_ptr tcp = ev.eventData.type();
+
+  if(!eventReceived(ev))
+  {
+    handleException(ev.eventCode, ev.statusCode, ev.functionName.in());
+  }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool btpDevice::hasEscrow()
+//
+//  purpose:    Check availability of ESCROW device
+//
+//---------------------------------------------------------------------------
+
+bool btpDevice::hasEscrow()
+{
+    return hasEscrowDispenser;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long btpDevice::eject(long lTimeOut)
+//
+//  purpose:
+//
+//---------------------------------------------------------------------------
+
+long btpDevice::eject(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+long rc1 = 0;
+Event_var ev1;
+
+  if(vcDispenser.isConnected())
+  {
+     // enable before offer
+     if((rc1 = vcDispenser.enable(0, ev1)) != 0)
+     {
+       trace(_HERE_7, "error enabling dispenser, rc = (%s) (%d)", rcString(rc1).c_str(), rc1);
+       return(rc1);
+     }
+     else
+       trace(_HERE_7, "enabling dispenser, rc = (%s) (%d)", rcString(rc1).c_str(), rc1);
+
+     if((rc = vcDispenser.offer(lTimeOut, ev)) != 0)
+       trace(_HERE_7, "error offering dispenser, rc = (%s) (%d)", rcString(rc).c_str(), rc);
+        //return rc;
+     else
+       trace(_HERE_7, "offering dispenser, rc = (%s) (%d)", rcString(rc).c_str(), rc);
+          //return checkStatusCode(ev);
+
+     // disable after synchron offer
+     if(lTimeOut >= 0  || rc != m_returncodes::RC_OK)
+     {
+       if((rc1 = vcDispenser.disable(0, ev1)) != 0)
+         trace(_HERE_7, "error disabling dispenser, rc = (%s) (%d)", rcString(rc1).c_str(), rc1);
+       else
+         trace(_HERE_7, "disabling dispenser, rc = (%s) (%d)", rcString(rc1).c_str(), rc1);
+     }
+
+     if((rc != 0) || (lTimeOut < 0))
+       return rc;
+     else
+       return checkStatusCode(ev);
+   }
+   else
+     return missingComponent;
+}
+
+// discard old response/indication
+void btpDevice::clearData()
+{
+  abData[0] = '\0';
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   void btpDevice::saveData(const datastream ds)
+//
+//  purpose:    save data from AEA data stream
+//
+//  date:       15.01.01, 14:20
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void btpDevice::saveData(const datastream ds)
+{
+aeaDataType *pData;
+
+    ds >>= pData;
+
+    if(pData)
+    {
+	     unsigned int i;
+      for(i = 0; i < pData->length(); i++)
+        abData[i] = (*pData)[i];
+
+      abData[i] = '\0';
+    }
+    return;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long btpDevice::write(long lTimeOut, char *pszData, long lLen)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long btpDevice::write(long lTimeOut, char *pszData, long lLen, Event_out ev)
+{
+long        rc  = 0;
+long        rc1 = 0;
+long        lLength;
+Event_var   ev1;
+datastream  ds;
+aeaDataType btpData;
+
+btpScanner::PaperTypes paperType;
+
+massai::cussif::MediaOutput* vcWriter = NULL;
+
+    // discard old printer response/indication
+    clearData();
+
+    // anything to do??
+    if(!pszData || !*pszData)
+      return(-1);
+
+    // create datastream for btp printer
+
+    if(!lLen)
+      lLength = strlen(pszData);
+    else
+      lLength = lLen;
+
+    btpData.length(lLength);
+
+    for(int i = 0; i < lLength; i++)
+       btpData[i] = *(pszData +i);
+
+    ds <<= btpData;
+    ds.type(types::_tc_aeaDataType);
+
+    // try to find the right virtual printer
+
+    vcWriter = findVirtualWriter(pszData, &paperType);
+
+    if(vcWriter)
+    {
+      if(paperType != btpScanner::Setup)
+      {
+        // enable the writer before sending
+
+        if((rc1 = vcWriter->enable(0, ev1)) != 0)
+        {
+          trace(_HERE_1, "error enabling writer, rc = (%s) (%d)", rcString(rc1).c_str(), rc1);
+          return(rc1);
+        }
+
+        // send the normal way
+
+        if((rc = vcWriter->send(lTimeOut, ds, ev)) != 0)
+        {
+          // return immediately !!
+
+          trace(_HERE_1, "sending btp data, rc = (%s) (%d)", rcString(rc).c_str(), rc);
+        }
+
+        // disable the writer after sending
+
+        if(lTimeOut >= 0  || rc != m_returncodes::RC_OK)
+        {
+          if((rc1 = vcWriter->disable(0, ev1)) != 0)
+            trace(_HERE_1, "error disabling writer, rc = (%s) (%d)", rcString(rc1).c_str(), rc1);
+        }
+
+        // return if send returned error !
+
+        if((rc) || (lTimeOut < 0))
+          return(rc);
+      }
+      else
+      {
+        // use setup instead of 'send()'
+
+        if(((rc = vcWriter->setup(lTimeOut, ds, ev)) != 0) || (lTimeOut < 0))
+        {
+          // return immediately !!
+
+          return(rc);
+        }
+      }
+
+      // handle returned data directly if synchronous call !!
+
+      TypeCode_ptr tcp = ev->eventData.type();
+
+      if(tcp->equivalent(_tc_aeaDataType))
+      {
+        saveData(ev->eventData);
+
+        trace(_HERE_7, "BTP-RSP [%s]", getData());
+      }
+
+      return(checkStatusCode(ev));
+    }
+    else
+      return(missingComponent);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   long btpDevice::cancel(long lTimeOut)
+//
+//  purpose:    cancel the last command
+//
+//  date:       17.11.2005
+//
+//  author:     Dr. Materna GmbH (TS)
+//
+//---------------------------------------------------------------------------
+
+long btpDevice::cancel(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcWriter.isConnected()
+    || vcDispenser.isConnected())
+    {
+      if(vcWriter.isConnected())
+        rc = vcWriter.cancel(ev);
+
+      if(vcDispenser.isConnected())
+        rc = vcDispenser.cancel(ev);
+
+
+      return(rc);
+    }
+    else
+      return(missingComponent);
+}
+
+/** Returns bin size of the dispenser */
+
+long btpDevice::dispenserBinSize()
+{
+  long result= 0;
+  if(vcDispenser.isConnected())
+  {
+    result= vcDispenser.getBinSize();
+  }
+  else
+  {
+    trace(_HERE_7, "vcDispenser not connected");
+  }
+  return result;
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   void btpDevice::bagtagEjected()
+//
+//  purpose:
+//
+//---------------------------------------------------------------------------
+
+void btpDevice::bagtagEjected()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void btpDevice::bagtagPrinted()
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void btpDevice::bagtagPrinted()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void btpDevice::printError (const long lStatusCode, const char *pszError)
+//
+//  purpose:
+//
+//  date:       23.03.2001, 16:10
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void btpDevice::printError (const long lStatusCode, const char *pszError)
+{
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        void btpDevice::setupResponse()
+ *
+ *  @brief
+ *
+ *  @date      02.02.2005
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+void btpDevice::setupResponse()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void btpDevice::commandTimeout()
+//
+//  purpose:    called if command timeout has occurred
+//
+//  date:       21.02.01, 10:35
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void btpDevice::commandTimeout()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void btpDevice::commandCancelled()
+//
+//  purpose:    calles if command has been cancelled
+//
+//  date:       21.02.01, 10:35
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void btpDevice::commandCancelled()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void btpDevice::handleException(long eventCode,
+//                                              long statusCode,
+//                                              const char *pszFunction)
+//
+//  purpose:    called if an unhandled status code (error) has been received
+//
+//  date:       21.02.01, 10:36
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void btpDevice::handleException(long eventCode, long statusCode, const char *pszFunction)
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool btpDevice::eventReceived(long eventCode,
+//                                            long statusCode,
+//                                            const char *pszFunction)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+bool btpDevice::eventReceived (const Event& ev)
+{
+  return eventReceived(ev.eventCode, ev.statusCode, ev.functionName.in());
+}
+bool btpDevice::eventReceived(long eventCode, long statusCode, const char *pszFunction)
+{
+    return(false);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   char *btpDevice::getData()
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+char *btpDevice::getData()
+{
+    return(abData);
+}
+
+long btpDevice::error()
+{
+  return vCompWriter::error();
+}
+//------------------------------------------------------------------------
+/**
+ *  @fn        long btpDevice::status(comptype ct)
+ *
+ *  @brief     query status on specific virtual component
+ *
+ *  @date      20.10.2004
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long btpDevice::status(comptype ct, Event_out ev)
+{
+  return status(BLOCK_, ct, ev);
+}
+long btpDevice::status(long lTimeout, comptype ct, Event_out ev)
+{
+long      rc = missingComponent;
+
+    try
+    {
+      switch(ct)
+      {
+      case vCompWriter::writer:
+
+           if(vcWriter.isConnected())
+           {
+             if((rc = vcWriter.query(lTimeout, ev)) == 0 && (lTimeout >= 0))
+               rc = ev->statusCode;
+           }
+           break;
+      case vCompDispenser::dispenser:
+
+           if(vcDispenser.isConnected())
+           {
+             if((rc = vcDispenser.query(lTimeout, ev)) == 0 && (lTimeout >= 0))
+               rc = ev->statusCode;
+           }
+           else
+             trace(_HERE_7, "vcDispenser not connected");
+           break;
+      case vCompDispenser::feeder:
+
+           if(vcBin1.isConnected())
+           {
+             if((rc = vcBin1.query(lTimeout, ev)) == 0 && (lTimeout >= 0))
+               rc = ev->statusCode;
+           }
+           else
+             trace(_HERE_7, "vcBin1 not connected");
+           break;
+      }
+    }
+    catch(...) {}
+
+    trace(_HERE_7, "status query result: %s, rc = %d", scString(rc).c_str(), rc);
+
+    return(rc);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   btpDevice::btpDevice(amInterface *pAmi)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:42
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+btpDevice::btpDevice(amInterface *pAmi):
+  vCompWriter(pAmi),
+  vCompDispenser(pAmi),
+  vCompFeeder(pAmi),
+  vcDispenser(static_cast<vCompDispenser*>(this)),
+  vcWriter(static_cast<vCompWriter*>(this)),
+  vcBin1(static_cast<vCompFeeder*>(this)),
+  hasEscrowDispenser(false),
+  fHasAEASupport(false)
+{
+    long             lIndex;
+    const char      *pszIOR;
+    long             lDispenserIndex= 0;
+
+
+    try
+    {
+      // try to connect all virtual components
+
+      if(pAmi->queryRealComponent("BagTagPrinter"))
+      {
+        // first option for BTP components
+
+        realComponent= "BagTagPrinter";
+        trace(_HERE_7, "use realcomponent: BagTagPrinter");
+
+        lIndex = 0;
+        vcWriter.storeIOR(pAmi->ior(lIndex, "BagTagPrinter", "MediaOutput"));
+
+        fHasAEASupport = true;
+      }
+      else
+      {
+        // no btp device found by name, check characteristics
+        const char* pszRealComponent;
+
+        amInterface::MediaTypeSet mediatype;
+        amInterface::DataTypeSet datatype;
+        mediatype.insert(Characteristics::MediaType::Printed);
+        datatype.insert(Characteristics::AEA);
+        lIndex= 0;
+        if(((pszRealComponent= pAmi->queryMediaOutput(lIndex, Characteristics::MediaOutput::BaggageTag, mediatype, datatype)) != NULL)
+         && ((pszIOR = pAmi->ior(lIndex, pszRealComponent, "MediaOutput")) != NULL))
+        {
+          realComponent= pszRealComponent;
+          trace(_HERE_7, "use realcomponent: %s", pszRealComponent);
+          vcWriter.storeIOR(pszIOR);
+          fHasAEASupport = true;
+        }
+      }
+      vcDispenser.storeIOR(pAmi->iorLinked(lIndex, lDispenserIndex, "Dispenser")); // use MediaOutput-Dispenser
+      if(vcDispenser.canConnect())
+      {
+        EnvironmentComponents_var ec(pAmi->getComponents());
+        CORBA::ULong index= lIndex;
+        lDispenserIndex= ec[index].linkedComponents[lDispenserIndex];
+      }
+      long lLinked= 0;
+      vcBin1.storeIOR(pAmi->iorLinked(lIndex, lLinked, "Feeder"));
+
+      strcpy(vCompWriter::szAppRef, pAmi->getAppReference());
+      strcpy(vCompDispenser::szAppRef, pAmi->getAppReference());
+      strcpy(vCompFeeder::szAppRef, pAmi->getAppReference());
+
+#ifdef SUPERUSER
+
+      strcpy(vCompWriter::szAppRef, "moorhuhn");
+      strcpy(vCompDispenser::szAppRef, "moorhuhn");
+      strcpy(vCompFeeder::szAppRef, "moorhuhn");
+
+#endif
+
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+    }
+
+    startProcessing();
+    vcWriter.connect();
+    vcWriter.setListener();
+    vcDispenser.connect();
+    vcDispenser.setListener();
+    vcBin1.connect();
+    vcBin1.setListener();
+
+    if(vcDispenser.canConnect())
+    {
+      // MediaOutput Dispenser is a real Dispenser => escrow dispenser
+      if(vcDispenser.getKind() == Characteristics::Dispenser::real_)
+      {
+        hasEscrowDispenser= true;
+      }
+      else
+      {
+        // or MediaOutput Dispenser has a second Dispenser => escrow dispenser
+        long lStartIndex= 0;
+        // SteT EDB 27096: ->
+        if(pAmi->iorLinked(lDispenserIndex, lStartIndex, "Dispenser") != 0)
+        {
+          hasEscrowDispenser= true;
+        }
+        // SteT EDB 27096: <-
+      /* SteT EDB 27096 +>
+        while(pAmi->iorLinked(lDispenserIndex, lStartIndex, "Dispenser") != 0)
+        {
+          EnvironmentComponents_var ec(pAmi->getComponents());
+          CORBA::ULong lDispenderIdx= lDispenserIndex;
+          long lSecondDispenserIndex= ec[lDispenderIdx].linkedComponents[lStartIndex];
+          long lSecondStartIndex= 0;
+          // and the second Dispenser is not the dispenser of the MediaInput => escrow dispenser
+          if(pAmi->iorLinked(lSecondDispenserIndex, lSecondStartIndex, "MediaInput") == 0)
+          {
+            hasEscrowDispenser= true;
+            break;
+          }
+          lStartIndex++;
+        }
+        SteT EDB 27096 <+ */
+      }
+    }
+
+    if(vcBin1.isConnected())
+    {
+      trace(_HERE_7, "BTP:Bin:almostFullLevel     = %d", vcBin1.getAllmostFullLevel());
+      trace(_HERE_7, "BTP:Bin:almostEmptyLevel    = %d", vcBin1.getAllmostEmptyLevel());
+      trace(_HERE_7, "BTP:Bin:BinSize             = %d", vcBin1.getBinSize());
+      trace(_HERE_7, "BTP:Bin:currentNumberOfDocs = %d", vcBin1.getCurrentNoOfDocuments());
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   btpDevice::~btpDevice()
+//
+//  purpose:    class destructor
+//
+//  date:       29.11.00, 15:42
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+btpDevice::~btpDevice()
+{
+  vcDispenser.clearListener();
+  vcWriter.clearListener();
+  vcBin1.clearListener();
+}
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/btpScanner.l b/SelfServiceCommon/Massai/cpp/CussIF/src/btpScanner.l
new file mode 100644
index 00000000..843f3898
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/btpScanner.l
@@ -0,0 +1,263 @@
+%{
+
+//---------------------------------------------------------------------------
+//
+//  file:       btpScanner.l
+//
+//  purpose:    Scanner to find CUSS papertype from AEA commands
+//
+//  date:       30.04.2002, 13:58
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "btpScanner.h"
+#include "tracedef.h"
+
+using namespace MASSAI;
+
+static btpScanner::PaperTypes prevPaperType;
+static long  count = 0;
+
+%}
+
+/* specify options for the scanner */
+
+%option c++
+%option yylineno
+%option noyywrap
+%option never-interactive
+
+%option prefix="btp"
+
+/* regular expression definitions */
+
+sep               [^0-9A-Z]
+seps              {sep}+
+
+sapp              (\$[A-Za-z]{1,4}\$)?
+
+logo              {sapp}"LT"[0-9A-Z]{2}|{sapp}"LC"[0-9A-Z]{2}|{sapp}"LS"
+tmplate           {sapp}"TT"[0-9]{2}|{sapp}"TC"[0-9]{2}|{sapp}"TA"
+font              {sapp}"FT"[0-9A-Z]{2}|{sapp}"FC"[0-9A-Z]{2}|{sapp}"FS"
+program           {sapp}"PD"([0-9A-Z]|[:punct:]){10}|{sapp}"PV"
+killprog          {sapp}"KP"
+hardcode          {sapp}"CT"[0-9A-Z]{1,5}|{sapp}"CT"
+pectab            {sapp}"BTT"[0-9]{1,6}{sep}|{sapp}"PS"|{sapp}"PC"
+
+baggagetag        "BTP"[0-9]{1,6}{sep}
+
+%%
+
+^{hardcode}       { trace(_HERE,"scanner: hardcode, yytext = [%s]",YYText());
+                    yy_flush_buffer(YY_CURRENT_BUFFER);
+                    return(btpScanner::Setup);
+                  }
+
+^{logo}           { trace(_HERE,"scanner: logo, yytext = [%s]",YYText());
+                    yy_flush_buffer(YY_CURRENT_BUFFER);
+                    return(btpScanner::Setup);
+                  }
+
+^{tmplate}        { trace(_HERE,"scanner: template, yytext = [%s]",YYText());
+                    yy_flush_buffer(YY_CURRENT_BUFFER);
+                    return(btpScanner::Setup);
+                  }
+
+^{font}            { trace(_HERE,"scanner: font, yytext = [%s]",YYText());
+                    yy_flush_buffer(YY_CURRENT_BUFFER);
+                    return(btpScanner::Setup);
+                  }
+
+^{program}        { trace(_HERE,"scanner: program, yytext = [%s]",YYText());
+                    yy_flush_buffer(YY_CURRENT_BUFFER);
+                    return(btpScanner::Setup);
+                  }
+
+^{pectab}          { trace(_HERE,"scanner: pectab, yytext = [%s]",YYText());
+                    yy_flush_buffer(YY_CURRENT_BUFFER);
+                    return(btpScanner::Setup);
+                  }
+
+^{killprog}       { trace(_HERE,"scanner: kill program, yytext = [%s]",YYText());
+                    yy_flush_buffer(YY_CURRENT_BUFFER);
+                    return(btpScanner::Error);
+                  }
+
+{baggagetag}      { trace(_HERE,"scanner: BaggageTag from stock, yytext = [%s]",YYText());
+
+                    btpScanner::PaperTypes pt;
+
+                    count++;
+
+                    // if((pt = checkPaperType(YYText())) == btpScanner::Error)
+                    pt = btpScanner::BaggageTag;
+
+                    if(count > 1 && pt != prevPaperType)
+                    {
+                      // can't handle different papertypes in one CP message !!
+
+                      trace(_HERE,"scanner: DIFFERENT PAPER TYPES IN AEA DATA STREAM !!");
+
+                      yy_flush_buffer(YY_CURRENT_BUFFER);
+
+                      return(btpScanner::Error);
+                    }
+                    else
+                      prevPaperType = pt;
+                  }
+
+%%
+
+//int yywrap() { return(1); } // have defined [%option noyywrap] ???
+
+//---------------------------------------------------------------------------
+//
+//  function:   class btpScannerHandle : public yyFlexLexer
+//
+//  purpose:    the bsic scanner class
+//
+//  date:       30.04.2002, 16:43
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+class btpScannerHandle : public yyFlexLexer
+{
+private:
+
+    // scan buffer definition
+
+    char szScanBuffer[8096];
+
+    void LexerOutput(const char *p, int size)
+    {
+      //printf("LexerOutput(%s, size = %d)\n",p,size);
+    }
+
+    // redefine standard LexerInput()
+
+    int LexerInput(char *p,int n)
+    {
+      int rc;
+
+      if(*szScanBuffer)
+      {
+        // copy scan buffer to FLEX scan buffer
+
+        strcpy(p,szScanBuffer);
+
+        rc = strlen(szScanBuffer);
+
+        // do this only one time !!
+
+        *szScanBuffer = '\0';
+
+        // return length of buffer
+
+        return(rc);
+      }
+      else
+      {
+        // stops scanner
+
+        return(0);
+      }
+    }
+
+public:
+
+    void setBuffer(const char *pszBuffer)
+    {
+      count = 0;
+
+      if(pszBuffer)
+      {
+        trace(_HERE,"AEA input: %s",pszBuffer);
+
+        strncpy(szScanBuffer,pszBuffer, sizeof(szScanBuffer));
+        szScanBuffer[sizeof(szScanBuffer)-1]= 0;
+      }
+      else
+        *szScanBuffer = '\0';
+    }
+};
+
+//---------------------------------------------------------------------------
+//
+//  function:   btpScanner::PaperTypes btpScanner::checkPaperType(const char *pszAEA)
+//
+//  purpose:    try to scan the given buffer for any CUSS-known paper types
+//
+//  date:       30.04.2002, 16:42
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+btpScanner::PaperTypes btpScanner::checkPaperType(const char *pszAEA)
+{
+PaperTypes rc = Unknown;
+
+    if(scanner && pszAEA)
+    {
+      scanner->setBuffer(pszAEA);
+
+      rc = (PaperTypes) scanner->yylex();
+
+      if(rc != Error && count >= 1)
+      {
+        // handled more than 1 CI/CP/TR in one AEA data stream
+        //
+        // if scanner returns something != Error, we can use the
+        // previous paper type for return !!
+
+        rc = prevPaperType;
+      }
+
+      trace(_HERE,"scanner returned papertype %d",rc);
+
+      return(rc);
+    }
+    else
+      return(Error);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   btpScanner::btpScanner() : scanner( new btpScannerHandle )
+//
+//  purpose:    class constructor
+//
+//  date:       30.04.2002, 16:42
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+btpScanner::btpScanner() : scanner( new btpScannerHandle )
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   btpScanner::~btpScanner()
+//
+//  purpose:    class destructor
+//
+//  date:       30.04.2002, 16:43
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+btpScanner::~btpScanner()
+{
+    delete scanner;
+}
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/callbackthread.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/callbackthread.cpp
new file mode 100644
index 00000000..9d3ff5af
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/callbackthread.cpp
@@ -0,0 +1,162 @@
+//---------------------------------------------------------------------------
+//
+//  file:       callbackthread.cpp
+//
+//  purpose:    Thread processing queued component callbacks
+//
+//  date:       20.04.2007
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+#include "callbackthread.h"
+#include "mThreadEx.h"
+#include "mMutexSem.hpp"
+#include "mEventSem.hpp"
+#include "types.h"
+#include "tracedef.h"
+#include "sysTools/mSysException.hpp"
+#include <windows.h>
+#include <list>
+
+
+namespace MASSAI
+{
+  CallbackHandler::CallbackHandler()
+  {}
+  CallbackHandler::~CallbackHandler()
+  {}
+  void CallbackHandler::process()
+  {}
+  CallbackProcessor::CallbackProcessor():
+    m_pHandler(0)
+  {}
+  void CallbackProcessor::startProcessing(CallbackHandler* pHandler)
+  {
+    m_pHandler = pHandler;
+    run();
+  }
+  long CallbackProcessor::function()
+  {
+    m_pHandler->process();
+    return -1;
+  }
+
+
+  CallbackThread::CallbackData::CallbackData(CallbackComponent component_, const types::Event& ev_, int id_):
+    component(component_),
+    ev(new types::Event(ev_)),
+    id(id_)
+  {}
+  CallbackThread::CallbackData::CallbackData()
+  {}
+  CallbackThread::CallbackData::CallbackData(const CallbackData& assign):
+    component(assign.component),
+    ev(assign.ev),
+    id(assign.id)
+  {}
+  CallbackThread::CallbackData::~CallbackData()
+  {}
+
+  CallbackThread::CallbackThread():
+    m_stopped(false),
+    m_processor()
+  {}
+  void CallbackThread::enqueue(CallbackComponent component, const types::Event& ev, int id)
+  {
+    trace(_HERE_1, "enqueue callback...");
+    mThreadAutoMutex request(&m_queueMutex);
+    m_queue.push_back(CallbackData(component, ev, id));
+    m_queueEvent.post();
+    trace(_HERE_1, "enqueue callback done");
+  }
+  void CallbackThread::startProcessing()
+  {
+    m_processor.startProcessing(this);
+  }
+  void CallbackThread::stopProcessing()
+  {
+    m_stopped= true;
+    m_queueEvent.post();
+  }
+  void CallbackThread::process()
+  {
+    trace(_HERE_1, "callback thread started");
+    mSysException::standardException guard;
+    while(!m_stopped)
+    {
+      try
+      {
+        trace(_HERE_1, "wait for callback...");
+        m_queueEvent.wait();
+        bool empty= false;
+        while(!empty)
+        {
+          trace(_HERE_1, "get next callback...");
+          try
+          {
+            CallbackData data;
+            {
+              mThreadAutoMutex request(&m_queueMutex);
+              if(m_queue.size() > 0)
+              {
+                data= m_queue.front();
+                m_queue.pop_front();
+              }
+              else
+              {
+                empty= true;
+                m_queueEvent.reset();
+                trace(_HERE_1, "no entry found");
+              }
+            }
+            if(!empty)
+            {
+              try
+              {
+                trace(_HERE_1, "process callback ..");
+                callback(data.component, data.ev, data.id);
+              }
+              catch(std::exception& ex)
+              {
+                trace(_HERE_1, "exception in callback: %.3500s", ex.what());
+                Sleep(100);
+              }
+              catch(...)
+              {
+                trace(_HERE_1, "unknown exception in callback");
+                Sleep(100);
+              }
+              trace(_HERE_1, "process callback done");
+            }
+            trace(_HERE_1, "callback done...");
+          }
+          catch(std::exception& ex)
+          {
+            trace(_HERE_1, "exception in callback: %.3500s", ex.what());
+            Sleep(100);
+          }
+          catch(...)
+          {
+            trace(_HERE_1, "unknown exception in callback");
+            Sleep(100);
+          }
+          trace(_HERE_1, "callback done.");
+        }
+      }
+      catch(std::exception& ex)
+      {
+        trace(_HERE_1, "exception in callback: %.3500s", ex.what());
+        Sleep(100);
+      }
+      catch(...)
+      {
+        trace(_HERE_1, "unknown exception in callback");
+        Sleep(100);
+      }
+    }
+    trace(_HERE_1, "callback thread finish");
+  }
+}; // namespace MASSAI
+
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/check.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/check.cpp
new file mode 100644
index 00000000..65704c41
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/check.cpp
@@ -0,0 +1,38 @@
+//---------------------------------------------------------------------------
+//
+//  file:       check.cpp
+//
+//  purpose:    Return value check functions
+//
+//  date:       23.02.01, 12:19
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+#ifndef _ORBACUS_
+
+#include "tao/corba.h"
+#include "orbIncDefs.h"
+
+#else
+
+#include "OB/CORBA.h"
+
+#endif
+
+#include "check.h"
+
+using namespace types;
+
+long checkStatusCode(Event_out ev)
+{
+long rc;
+
+    if(ev->eventType == invalid_ || ev->statusCode < 0)
+      rc = 0;
+    else
+      rc = ev->statusCode;
+
+    return(rc);
+}
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/client.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/client.cpp
new file mode 100644
index 00000000..65446aec
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/client.cpp
@@ -0,0 +1,628 @@
+//---------------------------------------------------------------------------
+//
+//  file:       main.cpp
+//
+//  purpose:    Main module CUSSIF-tests
+//
+//  date:       19.04.2002, 12:16
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+//#define SHOW_INCLUDE_FILES
+
+#include <conio.h>
+#include <iostream>
+
+#include "client.h"
+#include "tracedef.h"
+#include "atb2Scanner.h"
+
+#include "massai.hpp"
+#include "mThread.hpp"
+
+char *atb2Test[24] = {"PT||?B2Z|@;|TK/|@$/|@*/|0101110112011301210122012301310132013301410142014301E|",
+/*
+                      "TK#R#",
+                      "TK#0R#",
+                      "TK!1R1#",
+                      "TK#2R3#",
+                      "TK#3C03#4D0103340890!583!A7BOARDING",
+                      "TK%4F3#",
+                      "TK#5I3#",
+                      "TK#6R3#4D0103340890!583!A7BOARDING",
+                      "TK#7U3#",
+                      "TK/8S3#",
+                      "TK#9X3#4D0103340890!583!A7BOARDING",
+                      "TK#R1#",
+                      "TK#R3#",
+                      "TK?C03#",
+                      "TK#F3#",
+                      "TK#I3#",
+                      "TK#R3#4D0103340890!583!A7BOARDING",
+                      "TK#U3#",
+                      "TK#S3#",
+                      "TK#X3#",
+*/
+                      "KP",
+                      "LT92929",
+                      "TT9320",
+                      "CP!3C01!01B!4C085!4D0103340890!583!A7BOARDING PASS!B0$T!B31500!B4BUSINESS!B5ZRH!B6C!B9D10!C58C!CD8C!CFNO!D00007!",
+                      "TR#A#CI!3C01?01B?4C085?4D0103340890?583?A7BOARDING PASS?B0$T?B31500?B4BUSINESS?B5ZRH?B6C?B9D10?C58C?CD8C?CFNO?D00007?CI!2C01?01B?4C085?4D0103340890?583?A7BOARDING PASS?B0$T?B31500?B4BUSINESS?B5ZRH?B6C?B9D10?C58C?CD8C?CFNO?D00007?",
+                      NULL
+                    };
+
+class userInput : public mThread
+{
+private:
+
+    testApplication& application;
+
+    long function()
+    {
+      static int level   = 0;
+      static bool fFirst = true;
+      char c;
+
+        if(fFirst)
+        {
+          OS_Sleep(10000);
+
+          fFirst = false;
+        }
+
+        fprintf(stderr, "\n\nplease select a function(%d):\n\n", level);
+
+        switch(level)
+        {
+        case 0:
+
+             //printf("[a] - ATB Printer test\n");
+             //printf("[b] - BTP Printer test\n");
+             //printf("[c] - Card Reader test\n");
+             //printf("[e] - ESCROW      test\n\n");
+
+             fprintf(stderr, "[q] - quits application\n\n>>> ");
+             break;
+
+        case 1:
+
+             fprintf(stderr, "ATB Printer tests\n\n");
+             fprintf(stderr, "[-] - back to revious menu\n\n>>> ");
+             break;
+
+        case 2:
+
+             fprintf(stderr, "BTP Printer tests\n\n");
+             fprintf(stderr, "[-] - back to revious menu\n\n>>> ");
+             break;
+
+        case 3:
+
+             fprintf(stderr, "Card Reader tests\n\n");
+
+             fprintf(stderr, "[o] - open reader for insertion\n");
+             fprintf(stderr, "[c] - close reader insertion\n");
+
+             fprintf(stderr, "[-] - back to revious menu\n\n>>> ");
+             break;
+
+        case 4:
+
+             fprintf(stderr, "ESCROW tests\n\n");
+             fprintf(stderr, "[-] - back to revious menu\n\n>>> ");
+             break;
+        case 5:
+             fprintf(stderr, "GPPrinter tests\n\n");
+             fprintf(stderr, "[-] - back to revious menu\n\n>>> ");
+             break;
+
+        }
+
+        c = _getch();
+
+        switch(level)
+        {
+        case 1:
+        case 2:
+        case 3:
+        case 4:
+        case 5: if(c == '-') { level > 0 ? level = 0 : level = level; } break;
+        }
+
+        switch(level)
+        {
+        case 0: switch(c)
+                {
+                case 'a': level = 1; break;
+                case 'b': level = 2; break;
+                case 'c': level = 3; break;
+                case 'e': level = 4; break;
+                case 'g': level = 5; break;
+                case '-' : break;
+
+                case 'q':
+
+                     fprintf(stderr, "terminating, please wait...\n");
+                     application.terminate();
+                     break;
+
+                default:
+
+                     fprintf(stderr, "%c ???\n");
+                     break;
+                }
+                break;
+
+        case 3: switch(c)
+                {
+                case 'o': if(application.pCardDev)
+                          {
+                            fprintf(stderr, "open() returns: %s\n", rcString(application.pCardDev->open()).c_str());
+                          }
+                          break;
+
+                case 'c': if(application.pCardDev)
+                          {
+                            fprintf(stderr, "close() returns: %s\n", rcString(application.pCardDev->close()).c_str());
+                          }
+                }         break;
+                break;
+        case 5:
+                switch(c)
+                {
+                case 't': if (application.pgppDevice)
+                          {
+                             fprintf(stderr, "print() returns: %s\n",
+                                rcString(application.pgppDevice->write(10000, "FORM#1|1|20|Das ist der CPP TEST")).c_str());
+                          }
+                case 'p': if (application.pgppDevice)
+                          {
+                               char buffer[81];
+                               int i, ch;
+
+                               /* Read in single line from "stdin": */
+                               for( i = 0; (i < 80)          &&
+                                   ((ch = getchar()) != EOF) &&
+                                    (ch != '\n'); i++ )
+                                  buffer[i] = (char)ch;
+
+                               /* Terminate string with null character: */
+                               buffer[i] = '\0';
+                               fprintf(stderr, "print() returns: %s\n",
+                                   rcString(application.pgppDevice->write(10000, buffer)).c_str());
+                          }
+                }
+
+
+        default:  fprintf(stderr, "%c ???\n"); break;
+        }
+
+        if(c == 'q')
+        {
+          // wait a bit and terminate thread
+
+          OS_Sleep(100);
+          return(-1);
+        }
+        else
+          return(0);
+    }
+
+public:
+
+    userInput(testApplication& app) : application(app)
+    {
+      run();
+    }
+};
+
+//---------------------------------------------------------------------------
+//
+//  function:   long testApplication::connectHardwareDevices()
+//
+//  purpose:    connect all required hardware devices
+//
+//  date:       23.04.2002, 12:06
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long testApplication::connectHardwareDevices()
+{
+    if(!pCardDev)
+      pCardDev = new magCardDevice(this);
+    pCardDev->error();
+
+    if(!pEscrow)
+      pEscrow = new escrowDevice(this);
+    pEscrow->error();
+
+    if(!pBPPrinter)
+      pBPPrinter = new bppDevice(this);
+    pBPPrinter->error();
+
+    if(!pBTPrinter)
+      pBTPrinter = new btpDevice(this);
+    pBTPrinter->error();
+
+    if(!pgppDevice)
+      pgppDevice = new gppDevice(this);
+    pgppDevice->error();
+
+    if(pBPPrinter && pBTPrinter && pEscrow && pCardDev && pgppDevice)
+    {
+      trace(_HERE_7, "all hardware devices connected");
+
+      return(0);
+    }
+    else
+    {
+      trace(_HERE_7, "NOT all hardware devices connected");
+      return(-1);
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long testApplication::releaseHardwareDevices()
+//
+//  purpose:    release all connected hardware devices
+//
+//  date:       23.04.2002, 12:06
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long testApplication::releaseHardwareDevices()
+{
+    if(pBPPrinter)
+      delete pBPPrinter;
+
+    if(pEscrow)
+      delete pEscrow;
+
+    if(pBTPrinter)
+      delete pBTPrinter;
+
+    if(pCardDev)
+      delete pCardDev;
+
+    if (pgppDevice)
+      delete pgppDevice;
+
+    pEscrow    = NULL;
+    pBPPrinter = NULL;
+    pBTPrinter = NULL;
+    pCardDev   = NULL;
+    pgppDevice = NULL;
+
+    return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long testApplication::userBreak(int signal)
+//
+//  purpose:    Handle user exceptions
+//
+//  date:       18.01.01, 09:07
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long testApplication::userBreak(int signal)
+{
+bool fDone = true;
+
+    std::cout << "user break...\n" << std::endl;
+
+    releaseHardwareDevices();
+
+    idleMe(fDone);
+
+    return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long testApplication::criticalError(int signal)
+//
+//  purpose:    Handle software exceptions
+//
+//  date:       18.01.01, 09:07
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long testApplication::criticalError(int signal)
+{
+bool fDone = true;
+
+    std::cout << "Critical error...\n" << std::endl;
+
+    releaseHardwareDevices();
+
+    idleMe(fDone);
+
+    return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long testApplication::initialize()
+//
+//  purpose:    Initialize handler
+//
+//  date:       27.12.00, 10:58
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long testApplication::initialize(EnvironmentLevel_var el)
+{
+bool fDone = true;
+long rc;
+
+    trace(_HERE_1, "AppManager requests initialize()");
+
+    rc = connectHardwareDevices();
+
+    //setKioskIdentification (el->machineIdentifier);
+    //setCKILocation         (el->machineLocationCode);
+
+    return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long testApplication::terminate()
+//
+//  purpose:    terminates application
+//
+//  date:       22.04.2002, 10:42
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long testApplication::terminate()
+{
+bool fDone = true;
+
+    trace(_HERE_1, "terminate()");
+
+    releaseHardwareDevices();
+
+    if(1)
+    {
+      trace(_HERE_7, "leaving application in IDLE state...");
+
+      idleMe(fDone);
+
+      return(0);
+    }
+    else
+    {
+      // set application into stopped state if anything was WRONG
+
+      trace(_HERE_7, "leaving application in STOPPED state...");
+
+      stopMe(fDone);
+
+      return(-1);
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long testApplication::idle()
+//
+//  purpose:    Idle Handler
+//
+//  date:       27.12.00, 10:58
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long testApplication::idle()
+{
+    trace(_HERE_1, "AppManager requests idle()");
+    return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long testApplication::activate()
+//
+//  purpose:    Activate handler
+//
+//  date:       27.12.00, 10:58
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long testApplication::activate(EnvironmentLevel_var el)
+{
+    trace(_HERE_1, "AppManager requests activate()");
+
+    return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long testApplication::disable()
+//
+//  purpose:    disable handler
+//
+//  date:       28.12.00, 10:17
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long testApplication::disable()
+{
+    trace(_HERE_1, "AppManager requests disable()");
+    return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long testApplication::stop()
+//
+//  purpose:    stop handler
+//
+//  date:       28.12.00, 10:17
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long testApplication::stop()
+{
+    trace(_HERE_1, "AppManager requests stop()");
+
+    terminate();
+
+    return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long testApplication::suspend()
+//
+//  purpose:    suspend handler
+//
+//  date:       28.12.00, 10:17
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long testApplication::suspend()
+{
+    trace(_HERE_1, "AppManager requests suspend()");
+    return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long testApplication::resume()
+//
+//  purpose:    resume handler
+//
+//  date:       28.12.00, 10:17
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long testApplication::resume()
+{
+    trace(_HERE_1, "AppManager requests resume()");
+    return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void testApplication::platformEvent(long eventCode,
+//                                                 long statusCode)
+//
+//  purpose:    genral platform event handler
+//
+//  date:       28.12.00, 10:17
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void testApplication::platformEvent(long eventCode, long statusCode)
+{
+    trace(_HERE_1, "CUSS platform event(%s, %s)", ecString(eventCode).c_str(), scString(statusCode).c_str());
+
+    return;
+}
+
+/*
+long testApplication::massaiTrace(long lLevel, char *pszFile, long sLine, char *pText)
+{
+    trace(lLevel, pszFile, sLine, pText);
+    return(0);
+}
+*/
+
+long setLevel(long level);
+
+/*---------------------------------------------------------------------------
+
+ FUNCTION:  PUBLIC INT main (INT, CHAR **)
+
+ COMMENTS:  main function
+
+ DATE:      02/14/96 - 13:45:32
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+---------------------------------------------------------------------------*/
+
+int main(int argc, char **argv)
+{
+long rc = -1;
+
+  std::cout << "Usage: client.exe [-r:ApplicationReference] [-d:DisplayIOR] [-a:ApplicationManagerIOR]" << std::endl;
+  setLevel(9);
+
+#if 0
+
+int  i;
+
+   atb2Scanner scanner;
+
+   for(i = 0; atb2Test[i]; i++)
+     scanner.checkPaperType(atb2Test[i]);
+
+#else
+
+    try
+    {
+      if(argc > 1)
+      {
+        mBasicRefs refs(argc, argv);
+
+        std::cout << "appmgr  = " << refs.appMgrIOR()  << std::endl;
+        //std::cout << "token   = " << refs.appRef()     << std::endl;
+        //std::cout << "display = " << refs.displayIOR() << std::endl;
+
+        // setLevel(256);
+
+        testApplication app(refs.appMgrIOR(), "BER", "CKI");
+
+        userInput ui(app);
+
+        rc = app.cussApplication::run();
+      }
+      else
+      {
+        std::cout << "exit with no arguments." << std::endl;
+      }
+    }
+    catch(...)
+    {
+      std::cout << "Unknown Exception" << std::endl;
+    }
+
+    std::cout << "test application terminated, rc = " << rc << std::endl;
+
+ #endif
+
+    return(rc);
+}
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/clock.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/clock.cpp
new file mode 100644
index 00000000..6cdb9db7
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/clock.cpp
@@ -0,0 +1,392 @@
+//---------------------------------------------------------------------------
+//
+//  file:       clock.cpp
+//
+//  purpose:    clock device implementation
+//
+//  date:       11.11.2005
+//
+//  author:     Materna Information & Communications (TS)
+//
+//---------------------------------------------------------------------------
+
+//#define SHOW_INCLUDE_FILES
+
+#include "cussif.h"
+#include "clock.h"
+#include "check.h"
+#include "tracedef.h"
+#include "orbs.h"
+
+#include "textIDL/textcodes.h"
+#include "textIDL/texttypes.h"
+#include "textIDL/textcharacteristics.h"
+
+using namespace MASSAI::codes_text;
+using namespace MASSAI::characteristics_text;
+using namespace MASSAI::types_text;
+
+//#define SUPERUSER  // uses "moohuhn" token
+
+using namespace MASSAI;
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   void clock::readerCallback(const Event &ev, int id)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void clock::readerCallback(const Event &ev, int id)
+{
+char szFName[512];
+
+    vCompReader::lError = ev.statusCode;
+
+    trace(_HERE_1, "Reader (%d); event code: (%s) (%d), status code: (%s) (%d) for %s", id, eventCodesText(ev.eventCode).c_str(), ev.eventCode, scString(ev.statusCode).c_str(), ev.statusCode, ev.functionName.in());
+
+    // try to save any response
+
+    if(!eventReceived(ev))
+    {
+      strcpy(szFName, ev.functionName.in());
+
+      if(!*ev.functionName && ev.statusCode == m_statuscodes::OK)
+      {
+        // unsolicited event ??
+
+        handleException(ev.eventCode, ev.statusCode, ev.functionName.in());
+      }
+      else switch(ev.statusCode)
+      {
+      case m_statuscodes::OK:
+        if(*ev.functionName)
+        {
+          // handle returned data directly if synchronous call !!
+
+          if(saveData(ev.eventData))
+          {
+            trace(_HERE_7, "CLOCK-RSP [%s], func = %s", getData(), ev.functionName.in());
+          }
+        }
+        break;
+      case m_statuscodes::TIMEOUT:       commandTimeout(); break;
+      case m_statuscodes::CANCELLED:     commandCancelled(); break;
+      default:                           handleException(ev.eventCode, ev.statusCode, ev.functionName.in()); break;
+      }
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long clock::timezone ()
+//
+//  purpose:    time difference in minutes relative to GMT
+//
+//  date:       14.11.2005
+//
+//  author:     Materna Information & Communications (TS)
+//
+//---------------------------------------------------------------------------
+long clock::timezone ()
+{
+    if(vcReader.isConnected())
+      return vcReader.getTimeZone();
+    else
+      return 0;
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool clock::saveData(const datastream ds)
+//
+//  purpose:    save data from data stream
+//
+//  date:       15.01.01, 14:20
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+bool clock::saveData(const datastream ds)
+{
+  bool result= false;
+  TypeCode_ptr tcp = ds.type();
+  if(tcp->equivalent(_tc_string))
+  {
+    trace(_HERE_7, "received string");
+    const char *pData;
+    if(ds >>= CORBA::Any::to_string(pData, 0))
+    {
+      strncpy(time, pData, sizeof(time));
+      time[sizeof(time)-1] = '\0';
+      result= true;
+    }
+  }
+  else if(tcp->equivalent(_tc_msgDataType))
+  {
+    trace(_HERE_7, "received msgDataType");
+    msgDataType* pData= 0;
+
+    ds >>= pData;
+    if(pData)
+    {
+      for(unsigned int i= 0; i < pData->records.length(); ++i)
+      {
+        if(pData->records[i].status == m_datastatus::DS_OK)
+        {
+          if(pData->records[i].message.length() > 0)
+          {
+            for(unsigned int j= 0; j < pData->records[i].message.length() && j < 14; ++j)
+            {
+              time[j]= pData->records[i].message[j];
+            }
+            result= true;
+            break;
+          }
+        }
+      }
+    }
+  }
+  return result;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long clock::read(long lTimeOut)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long clock::read(long lTimeOut, Event_out ev)
+{
+long rc = -1;
+
+    if(vcReader.isConnected())
+    {
+      try
+      {
+        trace(_HERE_7, "call receive for %s...", vCompReader::szAppRef);
+        if(((rc = vcReader.receive(lTimeOut, ev)) != 0) || (lTimeOut < 0))
+        {
+          trace(_HERE_7, "receive() for clock data, rc = (%s) (%d)", rcString(rc).c_str(), rc);
+
+          return(rc);
+        }
+        else
+        {
+          trace(_HERE_7, "receive() for clock data, rc = (%s) (%d)", rcString(rc).c_str(), rc);
+          // handle returned data directly if synchronous call !!
+
+          if(saveData(ev->eventData))
+          {
+            if(ev->statusCode != m_statuscodes::OK            &&
+               ev->statusCode != m_statuscodes::MEDIA_PRESENT &&
+               ev->statusCode != m_statuscodes::DATA_PRESENT     )
+            {
+              // call default handler in any case of error
+
+              eventReceived(*ev);
+            }
+          }
+          else
+          {
+            trace(_HERE_7, "received invalid DataType");
+          }
+        }
+      }
+      catch(CORBA::SystemException& ex)
+      {
+        trace(_HERE, "CORBA::SystemException:\n%s", ex._message());
+      }
+
+      return(checkStatusCode(ev));
+    }
+    else
+      return(missingComponent);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   void clock::commandTimeout()
+//
+//  purpose:    called if command timeout has occurred
+//
+//  date:       21.02.01, 10:35
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void clock::commandTimeout()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void clock::commandCancelled()
+//
+//  purpose:    calles if command has been cancelled
+//
+//  date:       21.02.01, 10:35
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void clock::commandCancelled()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void clock::handleException(long eventCode,
+//                                              long statusCode,
+//                                              const char *pszFunction)
+//
+//  purpose:    called if an unhandled status code (error) has been received
+//
+//  date:       21.02.01, 10:36
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void clock::handleException(long eventCode, long statusCode, const char *pszFunction)
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool clock::eventReceived(long eventCode,
+//                                            long statusCode,
+//                                            const char *pszFunction)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+bool clock::eventReceived (const Event& ev)
+{
+  return eventReceived(ev.eventCode, ev.statusCode, ev.functionName.in());
+}
+bool clock::eventReceived(long eventCode, long statusCode, const char *pszFunction)
+{
+    return(false);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   char *clock::getData()
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+char *clock::getData()
+{
+    return(time);
+}
+
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long clock::status()
+ *
+ *  @brief     query status on specific virtual component
+ *
+ *  @date      20.09.2005
+ *
+ *  @author    Materna Information & Communications (BrN)
+ */
+//------------------------------------------------------------------------
+
+long clock::status(Event_out ev)
+{
+  return status(BLOCK_, ev);
+}
+long clock::status(long lTimeout, Event_out ev)
+{
+  long      rc = missingComponent;
+  try
+  {
+       if(vcReader.isConnected())
+       {
+         if((rc = vcReader.query(lTimeout, ev)) == 0 && (lTimeout >= 0))
+           rc = ev->statusCode;
+       }
+  }
+  catch(...) {}
+
+  trace(_HERE_7, "status query result: %s, rc = %d", scString(rc).c_str(), rc);
+  return(rc);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   clock::clock(amInterface *pAmi)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:42
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+clock::clock(amInterface *pAmi):
+  vCompReader(pAmi),
+  vcReader(static_cast<vCompReader*>(this))
+{
+  long lIndex= 0;
+
+  trace(_HERE_7, "use realcomponent: Clock");
+  vcReader.storeIOR(pAmi->ior(lIndex, "Clock", "DataInput"));
+  realComponent= "Clock";
+
+  strcpy(vCompReader::szAppRef,   pAmi->getAppReference());
+#ifdef SUPERUSER
+  strcpy(vCompReader::szAppRef,   "moorhuhn");
+#endif
+
+  vcReader.connect();
+  vcReader.setListener();
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   clock::~clock()
+//
+//  purpose:    class destructor
+//
+//  date:       29.11.00, 15:42
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+clock::~clock()
+{
+  vcReader.clearListener();
+}
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/cuss_component.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/cuss_component.cpp
new file mode 100644
index 00000000..830c37f2
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/cuss_component.cpp
@@ -0,0 +1,1390 @@
+#include "cussif/cuss_component.h"
+#include "cussif/vcomp.h"
+#include "textIDL/textcodes.h"
+#include "tracedef.h"
+
+
+using namespace MASSAI::codes_text;
+
+namespace
+{
+  class Callback
+  {
+    public:
+      virtual ~Callback() {};
+      virtual long execute()= 0;
+  };
+  template <class Component, class Method>
+  class CussEventCall: public Callback
+  {
+    public:
+      CussEventCall(Component& component, Method method, types::Event_out event):
+        m_component(component),
+        m_method(method),
+        m_event(event)
+      {}
+      long execute()
+      {
+        return (m_component.getServant()->*m_method)(CORBA::string_dup(m_component.getAppRef()), m_event);
+      }
+    private:
+      Component& m_component;
+      Method m_method;
+      types::Event_out m_event;
+  };
+  template <class Component, class Method>
+  class CussTimeoutEventCall: public Callback
+  {
+    public:
+      CussTimeoutEventCall(Component& component, Method method, long timeout, types::Event_out event):
+        m_component(component),
+        m_method(method),
+        m_timeout(timeout),
+        m_event(event)
+      {}
+      long execute()
+      {
+        return (m_component.getServant()->*m_method)(m_timeout, CORBA::string_dup(m_component.getAppRef()), m_event);
+      }
+    private:
+      Component& m_component;
+      Method m_method;
+      long m_timeout;
+      types::Event_out m_event;
+  };
+  template <class Component, class Method>
+  class CussTimeoutEventDatastreamCall: public Callback
+  {
+    public:
+      CussTimeoutEventDatastreamCall(Component& component, Method method, long timeout, const types::datastream& datastream, types::Event_out event):
+        m_component(component),
+        m_method(method),
+        m_timeout(timeout),
+        m_event(event),
+        m_datastream(datastream)
+      {}
+      long execute()
+      {
+        return (m_component.getServant()->*m_method)(m_timeout, CORBA::string_dup(m_component.getAppRef()), m_datastream, m_event);
+      }
+    private:
+      Component& m_component;
+      Method m_method;
+      long m_timeout;
+      types::Event_out m_event;
+      const types::datastream& m_datastream;
+  };
+  template <class Component, class Method, class Parameter>
+  class CussCharacteristicCall: public Callback
+  {
+    public:
+      CussCharacteristicCall(Component& component, Method method, Parameter parameter):
+        m_component(component),
+        m_method(method),
+        m_parameter(parameter)
+      {}
+      long execute()
+      {
+        return (m_component.getServant()->*m_method)(CORBA::string_dup(m_component.getAppRef()), m_parameter);
+      }
+    private:
+      Component& m_component;
+      Method m_method;
+      Parameter m_parameter;
+  };
+
+  template <class T>
+  long cuss_single_call(T& component, Callback& cb)
+  {
+    long rc= returncodes::RC_ERROR;
+    try
+    {
+      rc= cb.execute();
+    }
+    catch(...)
+    {
+      if(component.exception())
+      {
+        try
+        {
+          rc= cb.execute();
+        }
+        catch(...)
+        {
+          component.exception(false);
+        }
+      }
+    }
+    return rc;
+  }
+  template <class T>
+  long cuss_call(T& component, Callback& cb)
+  {
+    long rc= returncodes::RC_ERROR;
+    if(component.connect())
+    {
+      rc = cuss_single_call(component, cb);
+      if(rc == returncodes::RC_LISTENER)
+      {
+        if(component.setListener() == returncodes::RC_OK)
+        {
+          rc = cuss_single_call(component, cb);
+        }
+      }
+    }
+    return rc;
+  }
+  template <class T, class M>
+  long cuss_call(T& component, M method, types::Event_out e)
+  {
+    CussEventCall<T, M> cb(component, method, e);
+    return cuss_call(component, cb);
+  }
+  template <class T, class M>
+  long cuss_call(T& component, M method, long timeout, types::Event_out e)
+  {
+    CussTimeoutEventCall<T, M> cb(component, method, timeout, e);
+    long oldTimeout= component.setTimeout(timeout);
+    long rc = cuss_call(component, cb);
+    component.resetTimeout(oldTimeout);
+    return rc;
+  }
+  template <class T, class M>
+  long cuss_call(T& component, M method, long timeout, const types::datastream& ds, types::Event_out e)
+  {
+    CussTimeoutEventDatastreamCall<T, M> cb(component, method, timeout, ds, e);
+    long oldTimeout= component.setTimeout(timeout);
+    long rc = cuss_call(component, cb);
+    component.resetTimeout(oldTimeout);
+    return rc;
+  }
+  template <class T, class M, class P>
+  long cuss_characteristic_call(T& component, M method, P p)
+  {
+    CussCharacteristicCall<T, M, P> cb(component, method, p);
+    return cuss_single_call(component, cb);
+  }
+  template <class T, class R, class M>
+  R cuss_characteristic_attribute(T& component, massai::Cache<R>& cache, M method)
+  {
+    if(!cache.isCached())
+    {
+      if(component.connect())
+      {
+        try
+        {
+          cache.set((component.getServant()->*method)());
+        }
+        catch(...)
+        {
+          if(component.exception())
+          {
+            try
+            {
+              cache.set((component.getServant()->*method)());
+            }
+            catch(...)
+            {
+              component.exception(false);
+            }
+          }
+        }
+      }
+    }
+    return cache.get();
+  }
+  template <class T, class R, class M>
+  bool cuss_characteristic_attribute(T& component, massai::Cache<R>& cache, R& def, M method)
+  {
+    cuss_characteristic_attribute(component, cache, method);
+    return cache.get(def);
+  }
+}
+
+
+namespace massai
+{
+  ComponentBase::ComponentBase():
+    m_id(0),
+    m_state(CS_NOT_CONNECTED),
+    m_pComponent(0)
+  {}
+  void ComponentBase::storeIOR(const char* pszIOR)
+  {
+    if(pszIOR != 0)
+    {
+      m_ior= pszIOR;
+    }
+  }
+  void ComponentBase::setId(int id)
+  {
+    m_id= id;
+  }
+  int ComponentBase::getId()
+  {
+    return m_id;
+  }
+  void ComponentBase::setComponent(MASSAI::vComponent* pComponent)
+  {
+    m_pComponent= pComponent;
+  }
+  ComponentBase::~ComponentBase()
+  {
+    m_pComponent= 0;
+  }
+  bool ComponentBase::isConnected()
+  {
+    return m_state == CS_CONNECTED || m_state == CS_NOT_CONNECTED_RETRY;
+  }
+  bool ComponentBase::canConnect()
+  {
+    return m_ior.size() != 0;
+  }
+  bool ComponentBase::connect()
+  {
+    if(m_state == CS_CONNECTED)
+    {}
+    else if(m_state == CS_FAILED)
+    {
+      trace(_HERE_1, "not connected state is: failed");
+    }
+    else if(m_ior.size() == 0)
+    {
+      trace(_HERE_8, "not connected no ior");
+      m_state= CS_NOT_CONNECTED;
+    }
+    else if(m_pComponent == 0)
+    {
+      trace(_HERE_1, "not connected no component");
+      m_state= CS_NOT_CONNECTED;
+    }
+    else
+    {
+      try
+      {
+        narrow(m_pComponent, m_ior.c_str());
+        m_state= CS_CONNECTED;
+      }
+      catch(const CORBA::TRANSIENT& ex)
+      {
+        trace(_HERE_1, "CORBA::TRANSIENT (%s):\n%s", m_ior.c_str(), ex._message());
+        m_state= CS_NOT_CONNECTED_RETRY;
+      }
+      catch(const CORBA::COMM_FAILURE& ex)
+      {
+        trace(_HERE_1, "CORBA::COMM_FAILURE (%s):\n%s", m_ior.c_str(), ex._message());
+        m_state= CS_NOT_CONNECTED_RETRY;
+      }
+      catch(const CORBA::SystemException& ex)
+      {
+        trace(_HERE_1, "CORBA::SystemException (%s):\n%s", m_ior.c_str(), ex._message());
+      }
+      catch(std::exception& ex)
+      {
+        trace(_HERE_1, "std::exception (%s):\n%s", m_ior.c_str(), ex.what());
+      }
+      catch(...)
+      {
+        trace(_HERE_1, "unknown exception (%s)", m_ior.c_str());
+      }
+    }
+    return m_state == CS_CONNECTED;
+  }
+  bool ComponentBase::exception(bool retry)
+  {
+    bool reconnect= false;
+    bool result= false;
+    try
+    {
+      throw;
+    }
+    catch(const CORBA::TRANSIENT& ex)
+    {
+      trace(_HERE_1, "CORBA::TRANSIENT(%s):\n%s", m_ior.c_str(), ex._message());
+      m_state= CS_NOT_CONNECTED_RETRY;
+      reconnect= retry;
+    }
+    catch(const CORBA::COMM_FAILURE& ex)
+    {
+      trace(_HERE_1, "CORBA::COMM_FAILURE(%s):\n%s", m_ior.c_str(), ex._message());
+      m_state= CS_NOT_CONNECTED_RETRY;
+      reconnect= retry;
+    }
+    catch(const CORBA::INITIALIZE& ex)
+    {
+      trace(_HERE_1, "CORBA::INITIALIZE (%s):\n%s", m_ior.c_str(), ex._message());
+      m_state= CS_FAILED;
+    }
+    catch(const CORBA::SystemException& ex)
+    {
+      trace(_HERE_1, "CORBA::SystemException (%s):\n%s", m_ior.c_str(), ex._message());
+    }
+    catch(std::exception& ex)
+    {
+      trace(_HERE_1, "std::exception (%s):\n%s", m_ior.c_str(), ex.what());
+    }
+    catch(...)
+    {
+      trace(_HERE_1, "Unknown exception (%s)", m_ior.c_str());
+    }
+    if(reconnect)
+    {
+      connect();
+      result= (m_state == CS_CONNECTED);
+    }
+    return result;
+  }
+  const char* ComponentBase::getAppRef()
+  {
+    return m_pComponent->appRef();
+  }
+  long ComponentBase::setTimeout(long timeout)
+  {
+    return m_pComponent->setTimeout(timeout);
+  }
+  void ComponentBase::resetTimeout(long oldTimeout)
+  {
+    m_pComponent->resetTimeout(oldTimeout);
+  }
+  long ComponentBase::acquire(types::Event_out e)
+  {
+    trace(_HERE_7, "acquire (%s)", m_ior.c_str());
+    return acquire(m_pComponent->listener(m_id), e);
+  }
+  long ComponentBase::acquire()
+  {
+    long rc= returncodes::RC_ERROR;
+    Event_var ev;
+    rc= acquire(ev);
+    if(rc == returncodes::RC_OK)
+    {
+      trace(_HERE_4, "acquire (%s)(%d)", scString(ev->statusCode).c_str(), ev->statusCode);
+      if(ev->statusCode == statuscodes::WRONG_STATE)
+      {
+        clearListener();
+        rc= acquire(ev);
+        if(rc == returncodes::RC_OK)
+        {
+          trace(_HERE_4, "acquire (%s)(%d)", scString(ev->statusCode).c_str(), ev->statusCode);
+        }
+        else
+        {
+          trace(_HERE_4, "acquire (%s)(%d)", rcString(rc).c_str(), rc);
+        }
+      }
+    }
+    else
+    {
+      trace(_HERE_4, "acquire (%s)(%d)", rcString(rc).c_str(), rc);
+    }
+    return rc;
+  }
+  long ComponentBase::setListener()
+  {
+    long rc= returncodes::RC_ERROR;
+    if(connect())
+    {
+      try
+      {
+        rc= acquire();
+      }
+      catch(...)
+      {
+        if(exception())
+        {
+          try
+          {
+            rc= acquire();
+          }
+          catch(...)
+          {
+            exception(false);
+          }
+        }
+      }
+    }
+    return rc;
+  }
+  long ComponentBase::clearListener()
+  {
+    long rc= returncodes::RC_ERROR;
+    if(m_state == CS_CONNECTED)
+    {
+      Event_var ev;
+      try
+      {
+        trace(_HERE_7, "release (%s)", m_ior.c_str());
+        rc = release(ev);
+        trace(_HERE_4, "release (%s)(%d)", rcString(rc).c_str(), rc);
+      }
+      catch(...)
+      {
+        exception(false);
+      }
+    }
+    return rc;
+  }
+  template<class T>
+  Cache<T>::Cache(const T& defaultValue, bool doCache):
+    m_value(defaultValue),
+    m_doCache(doCache),
+    m_isCached(false)
+  {
+  }
+  template<class T>
+  void Cache<T>::doCache(bool doCache)
+  {
+    m_doCache= doCache;
+  }
+  template<class T>
+  bool Cache<T>::isCached()
+  {
+    return m_doCache && m_isCached;
+  }
+  template<class T>
+  void Cache<T>::set(const T& value)
+  {
+    m_value= value;
+  }
+  template<class T>
+  bool Cache<T>::get(T& value)
+  {
+    bool result= false;
+    if(m_isCached)
+    {
+      value= m_value;
+      result= true;
+    }
+    return result;
+  }
+  template<class T>
+  T Cache<T>::get()
+  {
+    return m_value;
+  }
+
+  namespace cuss_characteristics
+  {
+    Manufacturer::Manufacturer():
+      m_realComponentIdentification(""),
+      m_downloadableFirmware(false),
+      m_firmwareVersion(""),
+      m_manufacturerName(""),
+      m_modelNumber("", false),
+      m_serialNumber("")
+    {}
+    std::string Manufacturer::getRealComponentIdentification()
+    {
+      return cuss_characteristic_attribute(*this, m_realComponentIdentification, &Characteristics::Manufacturer::realComponentIdentification);
+    }
+    bool Manufacturer::getRealComponentIdentification(std::string& realComponentIdentification)
+    {
+      return cuss_characteristic_attribute(*this, m_realComponentIdentification, realComponentIdentification, &Characteristics::Manufacturer::realComponentIdentification);
+    }
+    bool Manufacturer::getDownloadableFirmware()
+    {
+      return cuss_characteristic_attribute(*this, m_downloadableFirmware, &Characteristics::Manufacturer::downloadableFirmware);
+    }
+    bool Manufacturer::getDownloadableFirmware(bool& downloadableFirmware)
+    {
+      return cuss_characteristic_attribute(*this, m_downloadableFirmware, downloadableFirmware, &Characteristics::Manufacturer::downloadableFirmware);
+    }
+    std::string Manufacturer::getFirmwareVersion()
+    {
+      return cuss_characteristic_attribute(*this, m_firmwareVersion, &Characteristics::Manufacturer::firmwareVersion);
+    }
+    bool Manufacturer::getFirmwareVersion(std::string& firmwareVersion)
+    {
+      return cuss_characteristic_attribute(*this, m_firmwareVersion, firmwareVersion, &Characteristics::Manufacturer::firmwareVersion);
+    }
+    std::string Manufacturer::getManufacturerName()
+    {
+      return cuss_characteristic_attribute(*this, m_manufacturerName, &Characteristics::Manufacturer::manufacturerName);
+    }
+    bool Manufacturer::getManufacturerName(std::string& manufacturerName)
+    {
+      return cuss_characteristic_attribute(*this, m_manufacturerName, manufacturerName, &Characteristics::Manufacturer::manufacturerName);
+    }
+    std::string Manufacturer::getModelNumber()
+    {
+      return cuss_characteristic_attribute(*this, m_modelNumber, &Characteristics::Manufacturer::modelNumber);
+    }
+    bool Manufacturer::getModelNumber(std::string& modelNumber)
+    {
+      return cuss_characteristic_attribute(*this, m_modelNumber, modelNumber, &Characteristics::Manufacturer::modelNumber);
+    }
+    std::string Manufacturer::getSerialNumber()
+    {
+      return cuss_characteristic_attribute(*this, m_serialNumber, &Characteristics::Manufacturer::serialNumber);
+    }
+    bool Manufacturer::getSerialNumber(std::string& serialNumber)
+    {
+      return cuss_characteristic_attribute(*this, m_serialNumber, serialNumber, &Characteristics::Manufacturer::serialNumber);
+    }
+    Characteristics::Manufacturer_ptr Manufacturer::getServant()
+    {
+      return getCharacteristicsManufacturer();
+    }
+    const char* Manufacturer::firmwareVersion()
+    {
+      return getFirmwareVersion().c_str();
+    }
+    const char* Manufacturer::manufacturerName()
+    {
+      return getManufacturerName().c_str();
+    }
+    const char* Manufacturer::modelNumber()
+    {
+      return getModelNumber().c_str();
+    }
+    const char* Manufacturer::realComponentIdentification()
+    {
+      return getRealComponentIdentification().c_str();
+    }
+    const char* Manufacturer::serialNumber()
+    {
+      return getSerialNumber().c_str();
+    }
+
+    MediaType::MediaType():
+      m_type(Characteristics::MediaType::nonApplicableMediaType)
+    {}
+    Characteristics::MediaType::MediaTypeDef MediaType::getType()
+    {
+      return cuss_characteristic_attribute(*this, m_type, &Characteristics::MediaType::type);
+    }
+    bool MediaType::getType(Characteristics::MediaType::MediaTypeDef& type)
+    {
+      return cuss_characteristic_attribute(*this, m_type, type, &Characteristics::MediaType::type);
+    }
+    Characteristics::MediaType_ptr MediaType::getServant()
+    {
+      return getCharacteristicsMediaType();
+    }
+
+    MediaTypeList::MediaTypeList():
+      m_mtList(Characteristics::MediaTypeListDef_var())
+    {}
+    Characteristics::MediaTypeListDef_var MediaTypeList::getMtList()
+    {
+      return cuss_characteristic_attribute(*this, m_mtList, &Characteristics::MediaTypeList::mtList);
+    }
+    bool MediaTypeList::getMtList(Characteristics::MediaTypeListDef_var& mtList)
+    {
+      return cuss_characteristic_attribute(*this, m_mtList, mtList, &Characteristics::MediaTypeList::mtList);
+    }
+    Characteristics::MediaTypeList_ptr MediaTypeList::getServant()
+    {
+      return getCharacteristicsMediaTypeList();
+    }
+
+    Location::Location():
+      m_Map(""),
+      m_mapType(Characteristics::Location::nonApplicableImageType),
+      m_howTo(""),
+      m_howToType(Characteristics::Location::nonApplicableImageType),
+      m_componentLocation(Characteristics::Location::nonApplicableLocationType)
+    {}
+    std::string Location::getMap()
+    {
+      return cuss_characteristic_attribute(*this, m_Map, &Characteristics::Location::Map);
+    }
+    bool Location::getMap(std::string& Map)
+    {
+      return cuss_characteristic_attribute(*this, m_Map, Map, &Characteristics::Location::Map);
+    }
+    Characteristics::Location::ImageType Location::getMapType()
+    {
+      return cuss_characteristic_attribute(*this, m_mapType, &Characteristics::Location::mapType);
+    }
+    bool Location::getMapType(Characteristics::Location::ImageType& mapType)
+    {
+      return cuss_characteristic_attribute(*this, m_mapType, mapType, &Characteristics::Location::mapType);
+    }
+    std::string Location::getHowTo()
+    {
+      return cuss_characteristic_attribute(*this, m_howTo, &Characteristics::Location::howTo);
+    }
+    bool Location::getHowTo(std::string& howTo)
+    {
+      return cuss_characteristic_attribute(*this, m_howTo, howTo, &Characteristics::Location::howTo);
+    }
+    Characteristics::Location::ImageType Location::getHowToType()
+    {
+      return cuss_characteristic_attribute(*this, m_howToType, &Characteristics::Location::howToType);
+    }
+    bool Location::getHowToType(Characteristics::Location::ImageType& howToType)
+    {
+      return cuss_characteristic_attribute(*this, m_howToType, howToType, &Characteristics::Location::howToType);
+    }
+    Characteristics::Location::LocationType Location::getComponentLocation()
+    {
+      return cuss_characteristic_attribute(*this, m_componentLocation, &Characteristics::Location::componentLocation);
+    }
+    bool Location::getComponentLocation(Characteristics::Location::LocationType& componentLocation)
+    {
+      return cuss_characteristic_attribute(*this, m_componentLocation, componentLocation, &Characteristics::Location::componentLocation);
+    }
+    Characteristics::Location_ptr Location::getServant()
+    {
+      return getCharacteristicsLocation();
+    }
+
+    ComponentFonts::ComponentFonts():
+      m_usedStandard(Characteristics::ComponentFonts::nonApplicableBarcodeStandard),
+      m_Fonts(Characteristics::ComponentFonts::FontList_var())
+    {}
+    Characteristics::ComponentFonts::BarcodeStandard ComponentFonts::getUsedStandard()
+    {
+      return cuss_characteristic_attribute(*this, m_usedStandard, &Characteristics::ComponentFonts::usedStandard);
+    }
+    bool ComponentFonts::getUsedStandard(Characteristics::ComponentFonts::BarcodeStandard& usedStandard)
+    {
+      return cuss_characteristic_attribute(*this, m_usedStandard, usedStandard, &Characteristics::ComponentFonts::usedStandard);
+    }
+    Characteristics::ComponentFonts::FontList_var ComponentFonts::getFonts()
+    {
+      return cuss_characteristic_attribute(*this, m_Fonts, &Characteristics::ComponentFonts::Fonts);
+    }
+    bool ComponentFonts::getFonts(Characteristics::ComponentFonts::FontList_var& Fonts)
+    {
+      return cuss_characteristic_attribute(*this, m_Fonts, Fonts, &Characteristics::ComponentFonts::Fonts);
+    }
+    Characteristics::ComponentFonts_ptr ComponentFonts::getServant()
+    {
+      return getCharacteristicsComponentFonts();
+    }
+
+    Bin::Bin():
+      m_binSize(0),
+      m_allmostFullLevel(0),
+      m_allmostEmptyLevel(0),
+      m_currentNoOfDocuments(-1, false)
+    {}
+    long Bin::getBinSize()
+    {
+      return cuss_characteristic_attribute(*this, m_binSize, &Characteristics::Bin::BinSize);
+    }
+    bool Bin::getBinSize(long& binSize)
+    {
+      return cuss_characteristic_attribute(*this, m_binSize, binSize, &Characteristics::Bin::BinSize);
+    }
+    long Bin::getAllmostFullLevel()
+    {
+      return cuss_characteristic_attribute(*this, m_allmostFullLevel, &Characteristics::Bin::AllmostFullLevel);
+    }
+    bool Bin::getAllmostFullLevel(long& allmostFullLevel)
+    {
+      return cuss_characteristic_attribute(*this, m_allmostFullLevel, allmostFullLevel, &Characteristics::Bin::AllmostFullLevel);
+    }
+    long Bin::getAllmostEmptyLevel()
+    {
+      return cuss_characteristic_attribute(*this, m_allmostEmptyLevel, &Characteristics::Bin::AllmostEmptyLevel);
+    }
+    bool Bin::getAllmostEmptyLevel(long& allmostEmptyLevel)
+    {
+      return cuss_characteristic_attribute(*this, m_allmostEmptyLevel, allmostEmptyLevel, &Characteristics::Bin::AllmostEmptyLevel);
+    }
+    long Bin::getCurrentNoOfDocuments()
+    {
+      return cuss_characteristic_attribute(*this, m_currentNoOfDocuments, &Characteristics::Bin::currentNoOfDocuments);
+    }
+    bool Bin::getCurrentNoOfDocuments(long& currentNoOfDocuments)
+    {
+      return cuss_characteristic_attribute(*this, m_currentNoOfDocuments, currentNoOfDocuments, &Characteristics::Bin::currentNoOfDocuments);
+    }
+    Characteristics::Bin_ptr Bin::getServant()
+    {
+      return getCharacteristicsBin();
+    }
+
+    IOMode::IOMode():
+      m_mode(Characteristics::IOMode::nonApplicableInputOutputMode, false)
+    {}
+    Characteristics::IOMode::InputOutputMode IOMode::getMode()
+    {
+      return cuss_characteristic_attribute(*this, m_mode, &Characteristics::IOMode::mode);
+    }
+    bool IOMode::getMode(Characteristics::IOMode::InputOutputMode& mode)
+    {
+      return cuss_characteristic_attribute(*this, m_mode, mode, &Characteristics::IOMode::mode);
+    }
+    returncodes::rc IOMode::setIOMode(const Characteristics::IOMode::InputOutputMode& mode)
+    {
+      return cuss_characteristic_call(*this, &Characteristics::IOMode::setIOMode, mode);
+    }
+    Characteristics::IOMode_ptr IOMode::getServant()
+    {
+      return getCharacteristicsIOMode();
+    }
+
+    DataInput::DataInput():
+      m_timeZone(0, false)
+    {}
+    long DataInput::getTimeZone()
+    {
+      return cuss_characteristic_attribute(*this, m_timeZone, &Characteristics::DataInput::timeZone);
+    }
+    bool DataInput::getTimeZone(long& timeZone)
+    {
+      return cuss_characteristic_attribute(*this, m_timeZone, timeZone, &Characteristics::DataInput::timeZone);
+    }
+    Characteristics::DataInput_ptr DataInput::getServant()
+    {
+      return getCharacteristicsDataInput();
+    }
+
+    Dispenser::Dispenser():
+      m_kind(Characteristics::Dispenser::nonApplicableDispenserType)
+    {}
+    Characteristics::Dispenser::DispenserType Dispenser::getKind()
+    {
+      return cuss_characteristic_attribute(*this, m_kind, &Characteristics::Dispenser::kind);
+    }
+    bool Dispenser::getKind(Characteristics::Dispenser::DispenserType& kind)
+    {
+      return cuss_characteristic_attribute(*this, m_kind, kind, &Characteristics::Dispenser::kind);
+    }
+    Characteristics::Dispenser_ptr Dispenser::getServant()
+    {
+      return getCharacteristicsDispenser();
+    }
+
+    MediaInput::MediaInput():
+      m_typeOfReader(Characteristics::MediaInput::nonApplicableReaderType),
+      m_supportedDataTypes(Characteristics::DataTypeList_var()),
+      m_setupDataType(Characteristics::nonApplicableDataType),
+      m_numberOfTracks(-1)
+    {}
+    Characteristics::MediaInput::ReaderType MediaInput::getTypeOfReader()
+    {
+      return cuss_characteristic_attribute(*this, m_typeOfReader, &Characteristics::MediaInput::typeOfReader);
+    }
+    bool MediaInput::getTypeOfReader(Characteristics::MediaInput::ReaderType& typeOfReader)
+    {
+      return cuss_characteristic_attribute(*this, m_typeOfReader, typeOfReader, &Characteristics::MediaInput::typeOfReader);
+    }
+    Characteristics::DataTypeList_var MediaInput::getSupportedDataTypes()
+    {
+      return cuss_characteristic_attribute(*this, m_supportedDataTypes, &Characteristics::MediaInput::supportedDataTypes);
+    }
+    bool MediaInput::getSupportedDataTypes(Characteristics::DataTypeList_var& supportedDataTypes)
+    {
+      return cuss_characteristic_attribute(*this, m_supportedDataTypes, supportedDataTypes, &Characteristics::MediaInput::supportedDataTypes);
+    }
+    Characteristics::DataType MediaInput::getSetupDataType()
+    {
+      return cuss_characteristic_attribute(*this, m_setupDataType, &Characteristics::MediaInput::setupDataType);
+    }
+    bool MediaInput::getSetupDataType(Characteristics::DataType& setupDataType)
+    {
+      return cuss_characteristic_attribute(*this, m_setupDataType, setupDataType, &Characteristics::MediaInput::setupDataType);
+    }
+    long MediaInput::getNumberOfTracks()
+    {
+      return cuss_characteristic_attribute(*this, m_numberOfTracks, &Characteristics::MediaInput::numberOfTracks);
+    }
+    bool MediaInput::getNumberOfTracks(long& numberOfTracks)
+    {
+      return cuss_characteristic_attribute(*this, m_numberOfTracks, numberOfTracks, &Characteristics::MediaInput::numberOfTracks);
+    }
+    Characteristics::MediaInput_ptr MediaInput::getServant()
+    {
+      return getCharacteristicsMediaInput();
+    }
+
+    MediaOutput::MediaOutput():
+      m_type(Characteristics::MediaOutput::nonApplicableMediaType),
+      m_supportedDataTypes(Characteristics::DataTypeList_var()),
+      m_bufferSize(0),
+      m_numberOfTracks(-1),
+      m_minDocumentLength(0),
+      m_maxDocumentLength(0),
+      m_maxPrintSizeX(0),
+      m_maxPrintSizeY(0),
+      m_printOrientation(Characteristics::MediaOutput::nonApplicablePrintOrientation, false)
+    {}
+    Characteristics::MediaOutput::MediaType MediaOutput::getType()
+    {
+      return cuss_characteristic_attribute(*this, m_type, &Characteristics::MediaOutput::type);
+    }
+    bool MediaOutput::getType(Characteristics::MediaOutput::MediaType& type)
+    {
+      return cuss_characteristic_attribute(*this, m_type, type, &Characteristics::MediaOutput::type);
+    }
+    Characteristics::DataTypeList_var MediaOutput::getSupportedDataTypes()
+    {
+      return cuss_characteristic_attribute(*this, m_supportedDataTypes, &Characteristics::MediaOutput::supportedDataTypes);
+    }
+    bool MediaOutput::getSupportedDataTypes(Characteristics::DataTypeList_var& supportedDataTypes)
+    {
+      return cuss_characteristic_attribute(*this, m_supportedDataTypes, supportedDataTypes, &Characteristics::MediaOutput::supportedDataTypes);
+    }
+    long MediaOutput::getBufferSize()
+    {
+      return cuss_characteristic_attribute(*this, m_bufferSize, &Characteristics::MediaOutput::bufferSize);
+    }
+    bool MediaOutput::getBufferSize(long& bufferSize)
+    {
+      return cuss_characteristic_attribute(*this, m_bufferSize, bufferSize, &Characteristics::MediaOutput::bufferSize);
+    }
+    long MediaOutput::getNumberOfTracks()
+    {
+      return cuss_characteristic_attribute(*this, m_numberOfTracks, &Characteristics::MediaOutput::numberOfTracks);
+    }
+    bool MediaOutput::getNumberOfTracks(long& numberOfTracks)
+    {
+      return cuss_characteristic_attribute(*this, m_numberOfTracks, numberOfTracks, &Characteristics::MediaOutput::numberOfTracks);
+    }
+    long MediaOutput::getMinDocumentLength()
+    {
+      return cuss_characteristic_attribute(*this, m_minDocumentLength, &Characteristics::MediaOutput::minDocumentLength);
+    }
+    bool MediaOutput::getMinDocumentLength(long& minDocumentLength)
+    {
+      return cuss_characteristic_attribute(*this, m_minDocumentLength, minDocumentLength, &Characteristics::MediaOutput::minDocumentLength);
+    }
+    long MediaOutput::getMaxDocumentLength()
+    {
+      return cuss_characteristic_attribute(*this, m_maxDocumentLength, &Characteristics::MediaOutput::maxDocumentLength);
+    }
+    bool MediaOutput::getMaxDocumentLength(long& maxDocumentLength)
+    {
+      return cuss_characteristic_attribute(*this, m_maxDocumentLength, maxDocumentLength, &Characteristics::MediaOutput::maxDocumentLength);
+    }
+    long MediaOutput::getMaxPrintSizeX()
+    {
+      return cuss_characteristic_attribute(*this, m_maxPrintSizeX, &Characteristics::MediaOutput::maxPrintSizeX);
+    }
+    bool MediaOutput::getMaxPrintSizeX(long& maxPrintSizeX)
+    {
+      return cuss_characteristic_attribute(*this, m_maxPrintSizeX, maxPrintSizeX, &Characteristics::MediaOutput::maxPrintSizeX);
+    }
+    long MediaOutput::getMaxPrintSizeY()
+    {
+      return cuss_characteristic_attribute(*this, m_maxPrintSizeY, &Characteristics::MediaOutput::maxPrintSizeY);
+    }
+    bool MediaOutput::getMaxPrintSizeY(long& maxPrintSizeY)
+    {
+      return cuss_characteristic_attribute(*this, m_maxPrintSizeY, maxPrintSizeY, &Characteristics::MediaOutput::maxPrintSizeY);
+    }
+    Characteristics::MediaOutput::PrintOrientationDef MediaOutput::getPrintOrientation()
+    {
+      return cuss_characteristic_attribute(*this, m_printOrientation, &Characteristics::MediaOutput::printOrientation);
+    }
+    bool MediaOutput::getPrintOrientation(Characteristics::MediaOutput::PrintOrientationDef& printOrientation)
+    {
+      return cuss_characteristic_attribute(*this, m_printOrientation, printOrientation, &Characteristics::MediaOutput::printOrientation);
+    }
+    returncodes::rc MediaOutput::setPrintOrientation(const Characteristics::MediaOutput::PrintOrientationDef& orientation)
+    {
+      return cuss_characteristic_call(*this, &Characteristics::MediaOutput::setPrintOrientation, orientation);
+    }
+    Characteristics::MediaOutput_ptr MediaOutput::getServant()
+    {
+      return getCharacteristicsMediaOutput();
+    }
+
+    Storage::Storage():
+      m_size(0),
+      m_path("")
+    {}
+    long Storage::getSize()
+    {
+      return cuss_characteristic_attribute(*this, m_size, &Characteristics::Storage::size);
+    }
+    bool Storage::getSize(long& size)
+    {
+      return cuss_characteristic_attribute(*this, m_size, size, &Characteristics::Storage::size);
+    }
+    std::string Storage::getPath()
+    {
+      return cuss_characteristic_attribute(*this, m_path, &Characteristics::Storage::path);
+    }
+    bool Storage::getPath(std::string& path)
+    {
+      return cuss_characteristic_attribute(*this, m_path, path, &Characteristics::Storage::path);
+    }
+    Characteristics::Storage_ptr Storage::getServant()
+    {
+      return getCharacteristicsStorage();
+    }
+
+    Display::Display():
+      m_displayResolution(Characteristics::Display::ResolutionList_var()),
+      m_currentResolution(0, false),
+      m_screenDiagonal(0)
+    {}
+    Characteristics::Display::ResolutionList_var Display::getDisplayResolution()
+    {
+      return cuss_characteristic_attribute(*this, m_displayResolution, &Characteristics::Display::displayResolution);
+    }
+    bool Display::getDisplayResolution(Characteristics::Display::ResolutionList_var& displayResolution)
+    {
+      return cuss_characteristic_attribute(*this, m_displayResolution, displayResolution, &Characteristics::Display::displayResolution);
+    }
+    long Display::getCurrentResolution()
+    {
+      return cuss_characteristic_attribute(*this, m_currentResolution, &Characteristics::Display::currentResolution);
+    }
+    bool Display::getCurrentResolution(long& currentResolution)
+    {
+      return cuss_characteristic_attribute(*this, m_currentResolution, currentResolution, &Characteristics::Display::currentResolution);
+    }
+    returncodes::rc Display::setScreenResolution(long resolution)
+    {
+      return cuss_characteristic_call(*this, &Characteristics::Display::setScreenResolution, resolution);
+    }
+    long Display::getScreenDiagonal()
+    {
+      return cuss_characteristic_attribute(*this, m_screenDiagonal, &Characteristics::Display::screenDiagonal);
+    }
+    bool Display::getScreenDiagonal(long& screenDiagonal)
+    {
+      return cuss_characteristic_attribute(*this, m_screenDiagonal, screenDiagonal, &Characteristics::Display::screenDiagonal);
+    }
+    Characteristics::Display_ptr Display::getServant()
+    {
+      return getCharacteristicsDisplay();
+    }
+
+    Application::Application():
+      m_identification(types::akID_var()),
+      m_allContacts(Characteristics::Application::ContactList_var()),
+      m_firstIPPort(0),
+      m_lastIPPort(0)
+    {}
+    types::akID_var Application::getIdentification()
+    {
+      return cuss_characteristic_attribute(*this, m_identification, &Characteristics::Application::identification);
+    }
+    bool Application::getIdentification(types::akID_var& identification)
+    {
+      return cuss_characteristic_attribute(*this, m_identification, identification, &Characteristics::Application::identification);
+    }
+    Characteristics::Application::ContactList_var Application::getAllContacts()
+    {
+      return cuss_characteristic_attribute(*this, m_allContacts, &Characteristics::Application::allContacts);
+    }
+    bool Application::getAllContacts(Characteristics::Application::ContactList_var& allContacts)
+    {
+      return cuss_characteristic_attribute(*this, m_allContacts, allContacts, &Characteristics::Application::allContacts);
+    }
+    long Application::getFirstIPPort()
+    {
+      return cuss_characteristic_attribute(*this, m_firstIPPort, &Characteristics::Application::firstIPPort);
+    }
+    bool Application::getFirstIPPort(long& firstIPPort)
+    {
+      return cuss_characteristic_attribute(*this, m_firstIPPort, firstIPPort, &Characteristics::Application::firstIPPort);
+    }
+    long Application::getLastIPPort()
+    {
+      return cuss_characteristic_attribute(*this, m_lastIPPort, &Characteristics::Application::lastIPPort);
+    }
+    bool Application::getLastIPPort(long& lastIPPort)
+    {
+      return cuss_characteristic_attribute(*this, m_lastIPPort, lastIPPort, &Characteristics::Application::lastIPPort);
+    }
+    Characteristics::Application_ptr Application::getServant()
+    {
+      return getCharacteristicsApplication();
+    }
+
+    Conveyor::Conveyor():
+      m_maxWeight(0),
+      m_typeOfConveyor(Characteristics::Conveyor::nonApplicableConveyorType),
+      m_maxWidth(0),
+      m_maxHeigth(0),
+      m_maxLength(0),
+      m_guarenteedNoOfBags(0),
+      m_currentNoOfBagsParked(0, false)
+    {}
+    long Conveyor::getMaxWeight()
+    {
+      return cuss_characteristic_attribute(*this, m_maxWeight, &Characteristics::Conveyor::maxWeight);
+    }
+    bool Conveyor::getMaxWeight(long& maxWeight)
+    {
+      return cuss_characteristic_attribute(*this, m_maxWeight, maxWeight, &Characteristics::Conveyor::maxWeight);
+    }
+    Characteristics::Conveyor::ConveyorType Conveyor::getTypeOfConveyor()
+    {
+      return cuss_characteristic_attribute(*this, m_typeOfConveyor, &Characteristics::Conveyor::typeOfConveyor);
+    }
+    bool Conveyor::getTypeOfConveyor(Characteristics::Conveyor::ConveyorType& typeOfConveyor)
+    {
+      return cuss_characteristic_attribute(*this, m_typeOfConveyor, typeOfConveyor, &Characteristics::Conveyor::typeOfConveyor);
+    }
+    long Conveyor::getMaxWidth()
+    {
+      return cuss_characteristic_attribute(*this, m_maxWidth, &Characteristics::Conveyor::maxWidth);
+    }
+    bool Conveyor::getMaxWidth(long& maxWidth)
+    {
+      return cuss_characteristic_attribute(*this, m_maxWidth, maxWidth, &Characteristics::Conveyor::maxWidth);
+    }
+    long Conveyor::getMaxHeigth()
+    {
+      return cuss_characteristic_attribute(*this, m_maxHeigth, &Characteristics::Conveyor::maxHeigth);
+    }
+    bool Conveyor::getMaxHeigth(long& maxHeigth)
+    {
+      return cuss_characteristic_attribute(*this, m_maxHeigth, maxHeigth, &Characteristics::Conveyor::maxHeigth);
+    }
+    long Conveyor::getMaxLength()
+    {
+      return cuss_characteristic_attribute(*this, m_maxLength, &Characteristics::Conveyor::maxLength);
+    }
+    bool Conveyor::getMaxLength(long& maxLength)
+    {
+      return cuss_characteristic_attribute(*this, m_maxLength, maxLength, &Characteristics::Conveyor::maxLength);
+    }
+    long Conveyor::getGuarenteedNoOfBags()
+    {
+      return cuss_characteristic_attribute(*this, m_guarenteedNoOfBags, &Characteristics::Conveyor::guarenteedNoOfBags);
+    }
+    bool Conveyor::getGuarenteedNoOfBags(long& guarenteedNoOfBags)
+    {
+      return cuss_characteristic_attribute(*this, m_guarenteedNoOfBags, guarenteedNoOfBags, &Characteristics::Conveyor::guarenteedNoOfBags);
+    }
+    long Conveyor::getCurrentNoOfBagsParked()
+    {
+      return cuss_characteristic_attribute(*this, m_currentNoOfBagsParked, &Characteristics::Conveyor::currentNoOfBagsParked);
+    }
+    bool Conveyor::getCurrentNoOfBagsParked(long& currentNoOfBagsParked)
+    {
+      return cuss_characteristic_attribute(*this, m_currentNoOfBagsParked, currentNoOfBagsParked, &Characteristics::Conveyor::currentNoOfBagsParked);
+    }
+    Characteristics::Conveyor_ptr Conveyor::getServant()
+    {
+      return getCharacteristicsConveyor();
+    }
+  }
+  namespace cuss_components
+  {
+    returncodes::rc CUSSCntl::query(long to, types::Event_out e)
+    {
+      return cuss_call(*this, &Components::CUSSCntl::query, to, e);
+    }
+    Components::CUSSCntl_ptr CUSSCntl::getServant()
+    {
+      return getComponentsCUSSCntl();
+    }
+    returncodes::rc Peripheral::acquire(types::evtListener_ptr el, types::Event_out e)
+    {
+      evtAcquireFilter acquireFilter;
+      Any              elud;
+      Any              any;
+      elud <<= (Long)0;
+      any  <<= all_;
+      acquireFilter.filterALLorNIL(any);
+      return getServant()->acquire(0, string_dup(getAppRef()), acquireFilter, el, elud, e);
+    }
+    returncodes::rc Peripheral::release(types::Event_out e)
+    {
+      return getServant()->release(0, string_dup(getAppRef()), e);
+    }
+    returncodes::rc Peripheral::setup(long to, const types::datastream& ds, types::Event_out e)
+    {
+      return cuss_call(*this, &Components::Peripheral::setup, to, ds, e);
+    }
+    returncodes::rc Peripheral::cancel(types::Event_out e)
+    {
+      return cuss_call(*this, &Components::Peripheral::cancel, e);
+    }
+    returncodes::rc Peripheral::test(long to, types::Event_out e)
+    {
+      return cuss_call(*this, &Components::Peripheral::test, to, e);
+    }
+    Components::Peripheral_ptr Peripheral::getServant()
+    {
+      return getComponentsPeripheral();
+    }
+    returncodes::rc Input::receive(long to, types::Event_out e)
+    {
+      return cuss_call(*this, &Components::Input::receive, to, e);
+    }
+    Components::Input_ptr Input::getServant()
+    {
+      return getComponentsInput();
+    }
+    returncodes::rc Output::send(long to, const types::datastream&  ds, types::Event_out e)
+    {
+      return cuss_call(*this, &Components::Output::send, to, ds, e);
+    }
+    Components::Output_ptr Output::getServant()
+    {
+      return getComponentsOutput();
+    }
+    returncodes::rc User::enable(long to, types::Event_out e)
+    {
+      return cuss_call(*this, &Components::User::enable, to, e);
+    }
+    returncodes::rc User::disable(long to, types::Event_out e)
+    {
+      return cuss_call(*this, &Components::User::disable, to, e);
+    }
+    Components::User_ptr User::getServant()
+    {
+      return getComponentsUser();
+    }
+/*
+    returncodes::rc ManagementInterface::level(const types::akID& appid, types::EnvironmentLevel_out el)
+    {
+      // return cuss_call(*this, Components::ManagementInterface::level, appid, el);
+      return returncodes::RC_ERROR;
+    }
+    returncodes::rc ManagementInterface::components(types::EnvironmentComponents_out ec)
+    {
+      // return cuss_call(*this, Components::ManagementInterface::components, ec);
+      return returncodes::RC_ERROR;
+    }
+    returncodes::rc ManagementInterface::waitEvent(long to, const types::evtFilter& ef, types::Event_out e)
+    {
+      // return cuss_call(*this, Components::ManagementInterface::waitEvent, to, ef, e);
+      return returncodes::RC_ERROR;
+    }
+    returncodes::rc ManagementInterface::generateEvent(const types::Event& ie, types::Event_out oe)
+    {
+      // return cuss_call(*this, Components::ManagementInterface::generateEvent, ie, oe);
+      return returncodes::RC_ERROR;
+    }
+    returncodes::rc ManagementInterface::queryEvent(const types::evtFilter& ef, types::evtDescription_out ed)
+    {
+      // return cuss_call(*this, Components::ManagementInterface::queryEvent, ef, ed);
+      return returncodes::RC_ERROR;
+    }
+    returncodes::rc ManagementInterface::registerEvent(const types::action& act, const types::evtFilter& ef, const types::evtListener& el, const types::correlation& elud, types::Event_out e)
+    {
+      // return cuss_call(*this, Components::ManagementInterface::registerEvent, act, ef el, elud, e);
+      return returncodes::RC_ERROR;
+    }
+    Components::ManagementInterface_ptr ManagementInterface::getServant()
+    {
+      return getComponentsManagementInterface();
+    }
+*/
+    returncodes::rc Capture::retain(long to, types::Event_out e)
+    {
+      return cuss_call(*this, &Components::Capture::retain, to, e);
+    }
+    Components::Capture_ptr Capture::getServant()
+    {
+      return getComponentsCapture();
+    }
+    returncodes::rc Dispenser::offer(long to, types::Event_out e)
+    {
+      return cuss_call(*this, &Components::Dispenser::offer, to, e);
+    }
+    Components::Dispenser_ptr Dispenser::getServant()
+    {
+      return getComponentsDispenser();
+    }
+    returncodes::rc Feeder::offer(long to, types::Event_out e)
+    {
+      return cuss_call(*this, &Components::Feeder::offer, to, e);
+    }
+    Components::Feeder_ptr Feeder::getServant()
+    {
+      return getComponentsFeeder();
+    }
+/*
+    returncodes::rc ApplicationManager::initrequest(types::Event_out e)
+    {
+      // return cuss_call(*this, Components::ApplicationManager::initrequest, e);
+      return returncodes::RC_ERROR;
+    }
+    returncodes::rc ApplicationManager::notify(const types::akID& id, const types::evtCode& ec, types::Event_out e)
+    {
+      // return cuss_call(*this, Components::ApplicationManager::notify, id, ec, e);
+      return returncodes::RC_ERROR;
+    }
+    Components::ApplicationManager_ptr ApplicationManager::getServant()
+    {
+      return getComponentsApplicationManager();
+    }
+*/
+    returncodes::rc Conveyor::accept(long to, types::Event_out e)
+    {
+      return cuss_call(*this, &Components::Conveyor::accept, to, e);
+    }
+    returncodes::rc Conveyor::reject(long to, types::Event_out e)
+    {
+      return cuss_call(*this, &Components::Conveyor::reject, to, e);
+    }
+    returncodes::rc Conveyor::forwardParked(long to, types::Event_out e)
+    {
+      return cuss_call(*this, &Components::Conveyor::forwardParked, to, e);
+    }
+    returncodes::rc Conveyor::returnParked(long to, types::Event_out e)
+    {
+      return cuss_call(*this, &Components::Conveyor::returnParked, to, e);
+    }
+    returncodes::rc Conveyor::waitForRemovedBaggage(long to, types::Event_out e)
+    {
+      return cuss_call(*this, &Components::Conveyor::waitForRemovedBaggage, to, e);
+    }
+    Components::Conveyor_ptr Conveyor::getServant()
+    {
+      return getComponentsConveyor();
+    }
+    Capture& Capture::operator=(const Capture& assign)
+    {
+      Peripheral::operator=(assign);
+      Userless::operator=(assign);
+      Media::operator=(assign);
+      Dataless::operator=(assign);
+      cuss_characteristics::Capture& self = *this;
+      self = assign;
+      ComponentBase::operator=(assign);
+      return *this;
+    }
+    Dispenser& Dispenser::operator=(const Dispenser& assign)
+    {
+      Peripheral::operator=(assign);
+      User::operator=(assign);
+      Media::operator=(assign);
+      Dataless::operator=(assign);
+      cuss_characteristics::Dispenser& self = *this;
+      self = assign;
+      ComponentBase::operator=(assign);
+      return *this;
+    }
+    Feeder& Feeder::operator=(const Feeder& assign)
+    {
+      Peripheral::operator=(assign);
+      Userless::operator=(assign);
+      Media::operator=(assign);
+      Dataless::operator=(assign);
+      cuss_characteristics::Feeder& self = *this;
+      self = assign;
+      ComponentBase::operator=(assign);
+      return *this;
+    }
+    DataInput& DataInput::operator=(const DataInput& assign)
+    {
+      Peripheral::operator=(assign);
+      Userless::operator=(assign);
+      Medialess::operator=(assign);
+      Data::operator=(assign);
+      Input::operator=(assign);
+      cuss_characteristics::DataInput& self = *this;
+      self = assign;
+      ComponentBase::operator=(assign);
+      return *this;
+    }
+    DataOutput& DataOutput::operator=(const DataOutput& assign)
+    {
+      Peripheral::operator=(assign);
+      Userless::operator=(assign);
+      Medialess::operator=(assign);
+      Data::operator=(assign);
+      Output::operator=(assign);
+      cuss_characteristics::DataOutput& self = *this;
+      self = assign;
+      ComponentBase::operator=(assign);
+      return *this;
+    }
+    UserInput& UserInput::operator=(const UserInput& assign)
+    {
+      Peripheral::operator=(assign);
+      User::operator=(assign);
+      Medialess::operator=(assign);
+      Data::operator=(assign);
+      Input::operator=(assign);
+      cuss_characteristics::UserInput& self = *this;
+      self = assign;
+      ComponentBase::operator=(assign);
+      return *this;
+    }
+    UserOutput& UserOutput::operator=(const UserOutput& assign)
+    {
+      Peripheral::operator=(assign);
+      User::operator=(assign);
+      Medialess::operator=(assign);
+      Data::operator=(assign);
+      Output::operator=(assign);
+      cuss_characteristics::UserOutput& self = *this;
+      self = assign;
+      ComponentBase::operator=(assign);
+      return *this;
+    }
+    MediaInput& MediaInput::operator=(const MediaInput& assign)
+    {
+      Peripheral::operator=(assign);
+      User::operator=(assign);
+      Media::operator=(assign);
+      Data::operator=(assign);
+      Input::operator=(assign);
+      cuss_characteristics::MediaInput& self = *this;
+      self = assign;
+      ComponentBase::operator=(assign);
+      return *this;
+    }
+    MediaOutput& MediaOutput::operator=(const MediaOutput& assign)
+    {
+      Peripheral::operator=(assign);
+      User::operator=(assign);
+      Media::operator=(assign);
+      Data::operator=(assign);
+      Output::operator=(assign);
+      cuss_characteristics::MediaOutput& self = *this;
+      self = assign;
+      ComponentBase::operator=(assign);
+      return *this;
+    }
+    Storage& Storage::operator=(const Storage& assign)
+    {
+      Peripheral::operator=(assign);
+      Userless::operator=(assign);
+      Media::operator=(assign);
+      cuss_characteristics::Storage& self = *this;
+      self = assign;
+      ComponentBase::operator=(assign);
+      return *this;
+    }
+    Display& Display::operator=(const Display& assign)
+    {
+      Peripheral::operator=(assign);
+      User::operator=(assign);
+      Medialess::operator=(assign);
+      cuss_characteristics::Display& self = *this;
+      self = assign;
+      ComponentBase::operator=(assign);
+      return *this;
+    }
+    Network& Network::operator=(const Network& assign)
+    {
+      Peripheral::operator=(assign);
+      Userless::operator=(assign);
+      Medialess::operator=(assign);
+      cuss_characteristics::Network& self = *this;
+      self = assign;
+      ComponentBase::operator=(assign);
+      return *this;
+    }
+/*
+    Application& Application::operator=(const Application& assign)
+    {
+      CUSSCntl::operator=(assign);
+      cuss_characteristics::Application& self = *this;
+      self = assign;
+      ComponentBase::operator=(assign);
+      return *this;
+    }
+*/
+    Conveyor& Conveyor::operator=(const Conveyor& assign)
+    {
+      Peripheral::operator=(assign);
+      User::operator=(assign);
+      Medialess::operator=(assign);
+      Data::operator=(assign);
+      Input::operator=(assign);
+      cuss_characteristics::Conveyor& self = *this;
+      self = assign;
+      ComponentBase::operator=(assign);
+      return *this;
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/cussapp.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/cussapp.cpp
new file mode 100644
index 00000000..371ad3e5
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/cussapp.cpp
@@ -0,0 +1,1509 @@
+//---------------------------------------------------------------------------
+//
+//  file:       cussapp.cpp
+//
+//  purpose:    CUSS application class implementation
+//
+//  date:       01.12.00, 10:40
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include "cussif.h"
+#include "tracedef.h"
+#include "orbs.h"
+#include "iorparser.h"
+
+#include "ping.h"
+#include "ping_skel.h"
+
+#include "massai.hpp"
+#include "mAutoMutex.hpp"
+
+#include "polling.h"
+#include "mThreadEx.h"
+
+#include "textIDL/textcodes.h"
+#include "textIDL/texttypes.h"
+#include "textIDL/textcharacteristics.h"
+
+using namespace MASSAI::codes_text;
+using namespace MASSAI::characteristics_text;
+using namespace MASSAI::types_text;
+
+using namespace std;
+using namespace MASSAI;
+
+cussApplication *pCussApp = NULL;
+
+namespace
+{
+  // local used constants & definitions --------------------------------------
+
+  const  long STOP_ME       = 1001;
+  const  long IDLE_ME       = 1002;
+  const  long INIT_ME       = 1003;
+  const  long START_ME      = 1004;
+  const  long ENABLE_ME     = 1005;
+  const  long DISABLE_ME    = 1006;
+  const  long REACTIVATE_ME = 1007;
+
+  const  long SLEEP_VAL     = 1000;
+
+  // global vars for this module ----------------------------------------------
+
+  cussApplication *pApp = NULL;
+  cussApplication::appState applicationState = cussApplication::STOPPED; // the starting state
+
+  const char* appStateString()
+  {
+    const char* szState = "UNKNOWN";
+
+    switch(applicationState)
+    {
+    case cussApplication::STOPPED:      szState = "STOPPED";      break;
+    case cussApplication::INITIALIZING: szState = "INITIALIZING"; break;
+    case cussApplication::DISABLED:     szState = "DISABLED";     break;
+    case cussApplication::ACTIVE:       szState = "ACTIVE";       break;
+    case cussApplication::SUSPENDED:    szState = "SUSPENDED";    break;
+    case cussApplication::IDLE:         szState = "IDLE";         break;
+    case cussApplication::UNAVAILABLE:  szState = "UNAVAILABLE";  break;
+    }
+
+    return szState;
+  }
+
+  /*---------------------------------------------------------------------------
+
+   FUNCTION:  VOID exitHandler(INT iSignal)
+
+   COMMENTS:  Signal handler
+
+   DATE:      04/11/97 - 11:58:33
+
+   AUTHOR:    Dr. Materna GmbH   (AGe)
+
+  ---------------------------------------------------------------------------*/
+
+  void exitHandler(int iSignal)
+  {
+    const char* szTmp;
+
+    switch(iSignal)
+    {
+    case SIGABRT:   szTmp = "SIGABRT";  break;
+    case SIGBREAK:  szTmp = "SIGBREAK"; break;
+    case SIGTERM:   szTmp = "SIGTERM";  break;
+    case SIGINT:    szTmp = "SIGINT" ;  break;
+
+    case SIGFPE:    szTmp = "SIGFPE" ;  break;
+    case SIGSEGV:   szTmp = "SIGSEGV";  break;
+    case SIGILL:    szTmp = "SIGILL" ;  break;
+    default:        szTmp = "UNKNOWN";  break;
+    }
+
+    if(pApp)
+    {
+        std::cout << "signal [" << szTmp << "]" << std::endl;
+
+        trace(_HERE,"signal [%s]",szTmp);
+
+        switch(iSignal)
+        {
+        case SIGBREAK:
+        case SIGTERM:
+        case SIGINT: pApp->userBreak(iSignal); break;
+
+        case SIGABRT:
+        case SIGFPE:
+        case SIGSEGV:
+        case SIGILL: pApp->criticalError(iSignal); break;
+             break;
+        }
+    }
+
+    return;
+  }
+
+
+  void trim(std::string& data)
+  {
+    data.erase(data.find_last_not_of(" ") + 1);
+    data.erase(0, data.find_first_not_of(" "));
+  }
+
+  bool isSAM(std::string& msg)
+  {
+    bool result= false;
+    std::string SAM= " SINGLEAPP MODE";
+    std::string::size_type pos= msg.find(SAM);
+    while(pos != std::string::npos)
+    {
+      result= true;
+      msg.erase(pos, SAM.size());
+      pos= msg.find(SAM);
+    }
+    return result;
+  }
+  std::string checkLanguage(std::string& msg)
+  {
+    std::string result;
+    std::string Lang= " Language=";
+    std::string::size_type pos= msg.find(Lang);
+    while(pos != std::string::npos)
+    {
+      std::string::size_type begin= pos + Lang.size();
+      while(msg[begin] == ' ')
+      {
+        begin++;
+      }
+      std::string::size_type end= begin;
+      while(isalpha(msg[end]) || msg[end] == '_')
+      {
+        end++;
+      }
+      result= msg.substr(begin, end - begin);
+      msg.erase(pos, end - pos);
+      pos= msg.find(Lang);
+    }
+    return result;
+  }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long cussApplication::massaiTrace(int iSignal)
+//
+//  purpose:    Handler for default tracing
+//
+//  date:       31.03.2006
+//
+//  author:     Dr. Materna GmbH (PtM)
+//
+//---------------------------------------------------------------------------
+
+long cussApplication::massaiTrace(long lLevel, char *pszFile, long sLine, char *pText)
+{
+    OutputDebugString(pText);
+
+    return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long cussApplication::massaiCryptTrace(long lLevel, char *pszFile, long sLine, char *pData, long lLen)
+//
+//  purpose:    Handler for default crypt tracing
+//
+//  date:       28.08.2008
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+long cussApplication::massaiCryptTrace(long lLevel, char *pszFile, long sLine, char *pData, long lLen)
+{
+  // default action: do nothing
+  return 0;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long cussApplication::criticalError(int iSignal)
+//
+//  purpose:    Handler for critical SW errors (signal handler)
+//
+//  date:       07.12.00, 10:51
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long cussApplication::criticalError(int iSignal)
+{
+    trace(_HERE_7, "criticalError handler!");
+
+    return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long cussApplication::userBreak(int iSignal)
+//
+//  purpose:    Signal handler for CTRL-C etc.
+//
+//  date:       07.12.00, 10:51
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long cussApplication::userBreak(int iSignal)
+{
+    trace(_HERE_7, "userBreak handler!");
+
+    return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void cussApplication::amInterfaceCallback(const Event &ev)
+//
+//  purpose:    Callback from the application manager interface
+//
+//  date:       01.12.00, 12:21
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void cussApplication::amInterfaceCallback(const Event &ev)
+{
+    //0.1 trace(_HERE_7, "comp type      : %s", ev.componentType);
+
+    trace(_HERE_7, "event: %s", eventText(ev).c_str());
+
+    // SAM implementation .....
+
+    // datastream  eventData -> MSG
+    // "SINGLEAPP MODE"
+
+    try
+    {
+      TypeCode_ptr tcp = ev.eventData.type();
+
+      if(tcp->equivalent(_tc_msgDataType))
+      {
+        trace(_HERE_1, "msgDataTyp received in event...");
+      }
+    }
+    catch(...)
+    {
+        trace(_HERE_1, "no data received in event...");
+    }
+
+    if(!appManagerEvent(ev))
+    {
+      // call event handler if not processed by FSM
+
+      platformEvent(ev.eventCode, ev.statusCode);
+    }
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool cussApplication::isTerminating() const
+//
+//  purpose:    check if application is terminating
+//
+//  date:       15.01.2009
+//
+//---------------------------------------------------------------------------
+
+bool cussApplication::isTerminating() const
+{
+  return fTerminate;
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   long cussApplication::disable()
+//
+//  purpose:    application handler
+//
+//  date:       01.12.00, 12:21
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long cussApplication::disable()
+{
+    trace(_HERE_7, "disable()");
+
+    return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long cussApplication::activate(EnvironmentLevel_var el)
+//
+//  purpose:    application handler
+//
+//  date:       01.12.00, 12:22
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long cussApplication::activate(EnvironmentLevel_var el)
+{
+    trace(_HERE_7, "activate()");
+
+    return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long cussApplication::stop()
+//
+//  purpose:    application handler
+//
+//  date:       01.12.00, 12:22
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long cussApplication::stop()
+{
+    trace(_HERE_7, "stop()");
+
+    return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long cussApplication::suspend()
+//
+//  purpose:    application handler
+//
+//  date:       01.12.00, 12:22
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long cussApplication::suspend()
+{
+    trace(_HERE_7, "suspend()");
+
+    return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long cussApplication::resume()
+//
+//  purpose:    application handler
+//
+//  date:       01.12.00, 12:22
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long cussApplication::resume()
+{
+    trace(_HERE_7, "resume()");
+
+    return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long cussApplication::idle()
+//
+//  purpose:    application handler
+//
+//  date:       01.12.00, 12:22
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long cussApplication::idle()
+{
+    trace(_HERE_7, "idle()");
+
+    return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long cussApplication::initialize(EnvironmentLevel_var el)
+//
+//  purpose:    application handler
+//
+//  date:       01.12.00, 12:22
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long cussApplication::initialize(EnvironmentLevel_var el)
+{
+    trace(_HERE_7, "initialize()");
+
+    return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void cussApplication::platformEvent (long eventCode, long statusCode)
+//
+//  purpose:    application handler
+//
+//  date:       01.12.00, 12:22
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void cussApplication::platformEvent(long eventCode, long statusCode)
+{
+    trace(_HERE_7, "platformEvent(%s %d, %s %d)", eventCodesText(eventCode).c_str(), eventCode, scString(statusCode).c_str(), statusCode);
+
+    return;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long cussApplication::idleMe(bool fTerminate)
+//
+//  purpose:    Go into idle state and terminate the application if required.
+//
+//  date:       04.12.00, 11:56
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long cussApplication::idleMe(bool fTerminate)
+{
+long rc;
+
+    trace(_HERE_7, "idleMe(fTerminate = %d)", fTerminate);
+
+    rc = applicationEvent(IDLE_ME);
+
+    trace(_HERE_7, "idleMe(), done: %d", rc);
+
+    this->fTerminate = fTerminate;
+
+    trace(_HERE_7, "idleMe()::return()");
+
+    return rc;
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long cussApplication::reactivateMe()
+ *
+ *  @brief     Call this function to indicate a new customer in SAM.
+ *
+ *  @date      06.07.2005
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long cussApplication::reactivateMe()
+{
+long rc;
+
+    trace(_HERE_7, "reactivateMe()");
+
+    rc = applicationEvent(REACTIVATE_ME);
+
+    trace(_HERE_7, "reactivateMe(), done: %d" , rc);
+
+    return rc;
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long cussApplication::mode()
+ *
+ *  @brief     return the application mode (valid after activate)
+ *
+ *  @date      06.07.2005
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+cussApplication::appMode cussApplication::mode()
+{
+  return applicationMode;
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        cussApplication::appState cussApplication::state()
+ *
+ *  @brief     return the application state
+ *
+ *  @date      26.02.2008
+ */
+//------------------------------------------------------------------------
+
+cussApplication::appState cussApplication::state()
+{
+  return applicationState;
+}
+
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   std::string cussApplication::getLanguage()
+//
+//  purpose:    return the language selected in cla (valid after activate)
+//
+//  date:       30.10.2007
+//
+//  author:     Materna Information & Communications
+//
+//---------------------------------------------------------------------------
+/*
+std::string cussApplication::getLanguage()
+{
+  return language;
+}
+*/
+//---------------------------------------------------------------------------
+//
+//  function:   std::string cussApplication::getBranding()
+//
+//  purpose:    return the branding (valid after activate)
+//
+//  date:       30.10.2007
+//
+//  author:     Materna Information & Communications
+//
+//---------------------------------------------------------------------------
+
+std::string cussApplication::getBranding()
+{
+  return branding;
+}
+
+
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long cussApplication::enableMe()
+ *
+ *  @brief     Set application to AVALABLE on the kiosk
+ *
+ *  @date      20.10.2004
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long cussApplication::enableMe()
+{
+long rc;
+
+    trace(_HERE_7, "enableMe()");
+
+    rc = applicationEvent(ENABLE_ME);
+
+    trace(_HERE_7, "enableMe(), done: %d" , rc);
+
+    return rc;
+}
+
+
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long cussApplication::disableMe()
+ *
+ *  @brief     Set application to UNAVALABLE on the kiosk
+ *
+ *  @date      20.10.2004
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long cussApplication::disableMe()
+{
+long rc;
+
+    trace(_HERE_7, "disableMe()");
+
+    rc = applicationEvent(DISABLE_ME);
+
+    trace(_HERE_7, "disableMe(), done: %d" , rc);
+
+    return rc;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long cussApplication::stopMe(bool fTerminate)
+//
+//  purpose:    Go into the stopped state and terminate the application.
+//
+//  date:       04.12.00, 11:57
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long cussApplication::stopMe(bool fTerminate)
+{
+long rc;
+
+    trace(_HERE_7, "stopMe(fTerminate = %d)", fTerminate);
+
+    rc = applicationEvent(STOP_ME);
+
+    trace(_HERE_7, "stopMe(), done: %d" , rc);
+
+    this->fTerminate = fTerminate;
+
+    trace(_HERE_7, "stopMe()::return()");
+
+    return rc;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long cussApplication::terminate()
+//
+//  purpose:    Terminates the run() loop
+//
+//  date:       11.01.01, 11:02
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long cussApplication::terminate()
+{
+    fTerminate = true;
+
+    trace(_HERE_1, "cussApplication::terminate() = %s, tid = %x", fTerminate ? "yes" : "no", GetCurrentThreadId());
+
+    return(0);
+}
+
+long cussApplication::handleSuspend(long evc)
+{
+long rc = 0;
+
+    mThreadAutoMutex request(&transitionMutex);
+
+    applicationState = SUSPENDED;
+
+    rc = suspend();
+
+    return(rc);
+}
+
+long cussApplication::handleResume(long evc)
+{
+long rc = 0;
+
+    mThreadAutoMutex request(&transitionMutex);
+
+    if(evc == m_eventcodes::SUSPENDED_UNAVAILABLE)
+        applicationState = UNAVAILABLE;
+    else if(evc == m_eventcodes::SUSPENDED_AVAILABLE)
+        applicationState = IDLE;
+    else if(evc == m_eventcodes::SUSPENDED_INITIALIZE)
+        applicationState = INITIALIZING;
+
+    rc = resume();
+
+    return(rc);
+}
+
+long cussApplication::handleInit(long evc)
+{
+long rc = 0;
+
+    mThreadAutoMutex request(&transitionMutex);
+
+    applicationState = INITIALIZING;
+
+    // initial startup
+
+    rc = waitToInitialize();
+
+    if(!rc)
+      rc = initialize(getEnvironment());
+
+    return(rc);
+}
+
+
+long cussApplication::handleReactivate(long evc)
+{
+long rc = 0;
+
+    rc = notify(m_eventcodes::ACTIVE_ACTIVE);
+    return(rc);
+}
+
+long cussApplication::handleStart(long evc)
+{
+long rc = 0;
+
+    mThreadAutoMutex request(&transitionMutex);
+
+    applicationState = INITIALIZING;
+
+    // initial startup
+
+    rc = waitToInitialize();
+
+    if(!rc)
+      rc = initialize(getEnvironment());
+
+    return(rc);
+}
+
+long cussApplication::handleIdle(long evc)
+{
+long rc = 0;
+
+    mThreadAutoMutex request(&transitionMutex);
+
+    if(!evc)
+    {
+      if(applicationState == INITIALIZING)
+      {
+        rc = notify(m_eventcodes::INITIALIZE_UNAVAILABLE);
+        if(rc == returncodes::RC_OK || rc == statuscodes::AL_APPLICATION_REQUEST)
+        {
+          applicationState = UNAVAILABLE;
+          rc = notify(m_eventcodes::UNAVAILABLE_AVAILABLE);
+          if(rc == returncodes::RC_OK || rc == statuscodes::AL_APPLICATION_REQUEST)
+          {
+            applicationState = IDLE;
+          }
+        }
+      }
+      else if(applicationState == UNAVAILABLE)
+      {
+        rc = notify(m_eventcodes::UNAVAILABLE_AVAILABLE);
+        if(rc == returncodes::RC_OK || rc == statuscodes::AL_APPLICATION_REQUEST)
+        {
+          applicationState = IDLE;
+        }
+      }
+      else
+      {
+        rc = notify(m_eventcodes::ACTIVE_AVAILABLE);
+        if(rc == returncodes::RC_OK || rc == statuscodes::AL_APPLICATION_REQUEST)
+        {
+          applicationState = IDLE;
+        }
+      }
+    }
+    else
+    {
+      //applicationState = IDLE;
+
+      idle();
+    }
+
+    return(rc);
+}
+
+long cussApplication::handleActivate(long evc)
+{
+long rc = 0;
+
+    mThreadAutoMutex request(&transitionMutex);
+
+    applicationState = ACTIVE;
+
+    rc = activate(getEnvironment());
+
+    return(rc);
+}
+
+long cussApplication::handleOnScreen(long evc)
+{
+long rc = 0;
+
+    mThreadAutoMutex request(&transitionMutex);
+
+    if(applicationState == UNAVAILABLE)
+    {
+      rc = notify(m_eventcodes::UNAVAILABLE_AVAILABLE);
+      if(rc == returncodes::RC_OK || rc == statuscodes::AL_APPLICATION_REQUEST)
+      {
+        applicationState = IDLE;
+      }
+    }
+    else
+      rc = -1;
+    return(rc);
+}
+
+long cussApplication::handleOffScreen(long evc)
+{
+long rc = 0;
+
+    mThreadAutoMutex request(&transitionMutex);
+
+    if(applicationState == IDLE)
+    {
+      rc = notify(m_eventcodes::AVAILABLE_UNAVAILABLE);
+      if(rc == returncodes::RC_OK || rc == statuscodes::AL_APPLICATION_REQUEST)
+      {
+        applicationState = UNAVAILABLE;
+      }
+    }
+    else if(applicationState == INITIALIZING)
+    {
+      rc = notify(m_eventcodes::INITIALIZE_UNAVAILABLE);
+      if(rc == returncodes::RC_OK || rc == statuscodes::AL_APPLICATION_REQUEST)
+      {
+        applicationState = UNAVAILABLE;
+      }
+    }
+    else if(applicationState == ACTIVE)
+    {
+      rc = notify(m_eventcodes::ACTIVE_AVAILABLE);
+      if(rc == returncodes::RC_OK || rc == statuscodes::AL_APPLICATION_REQUEST)
+      {
+        applicationState = IDLE;
+        rc = notify(m_eventcodes::AVAILABLE_UNAVAILABLE);
+        if(rc == returncodes::RC_OK || rc == statuscodes::AL_APPLICATION_REQUEST)
+        {
+          applicationState = UNAVAILABLE;
+        }
+      }
+    }
+    else
+      rc = -1;
+
+    return(rc);
+}
+
+long cussApplication::handleStop(long evc)
+{
+long rc = 0;
+
+    mThreadAutoMutex request(&transitionMutex);
+
+    if(!evc)
+    {
+      switch(applicationState)
+      {
+      case INITIALIZING: rc = notify(m_eventcodes::INITIALIZE_STOPPED_STOP);  break;
+      case IDLE:         rc = notify(m_eventcodes::AVAILABLE_STOPPED_STOP);   break;
+      case ACTIVE:       rc = notify(m_eventcodes::ACTIVE_STOPPED_STOP);      break;
+      case UNAVAILABLE:  rc = notify(m_eventcodes::UNAVAILABLE_STOPPED_STOP); break;
+      case SUSPENDED:    rc = notify(m_eventcodes::SUSPENDED_STOPPED_STOP);   break;
+      }
+    }
+    else
+    {
+      rc = stop();
+    }
+    if(rc == returncodes::RC_OK || rc == statuscodes::AL_APPLICATION_REQUEST)
+    {
+      applicationState = STOPPED;
+    }
+    return(rc);
+}
+
+long cussApplication::handleDisable(long evc)
+{
+long rc = 0;
+
+    mThreadAutoMutex request(&transitionMutex);
+
+    applicationState = DISABLED;
+
+    rc = disable();
+
+    return(rc);
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        bool cussApplication::appManagerEvent(const Event& ev)
+ *
+ *  @brief     handle events from CUSS application manager
+ *
+ *  @date      30.03.2005
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+bool cussApplication::appManagerEvent(const Event& ev)
+{
+bool fDone = false;
+long rc    = 0;
+
+    trace(_HERE_1, "APP-STATE: %s, evc = %s %d", appStateString(), eventCodesText(ev.eventCode).c_str(), ev.eventCode);
+
+    switch(ev.eventCode)
+    {
+    case m_eventcodes::STOPPED_INITIALIZE:          /**< State transition INITILAIZE */
+    case m_eventcodes::DISABLED_INITIALIZE:
+
+         rc = handleInit(ev.eventCode);
+         break;
+
+    case m_eventcodes::SUSPENDED_INITIALIZE:
+    case m_eventcodes::SUSPENDED_AVAILABLE:
+    case m_eventcodes::SUSPENDED_UNAVAILABLE:
+
+        rc = handleResume(ev.eventCode);
+        break;
+
+    case m_eventcodes::INITIALIZE_SUSPENDED:
+    case m_eventcodes::AVAILABLE_SUSPENDED:
+    case m_eventcodes::UNAVAILABLE_SUSPENDED:
+    case m_eventcodes::DISABLED_SUSPENDED:                 // Not used in CUSS 1.0
+
+
+        rc = handleSuspend(ev.eventCode);
+        break;
+
+    case m_eventcodes::AVAILABLE_ACTIVE:            /**< State transition ACTIVATE */
+
+         // extract eventData
+         try
+         {
+           trace(_HERE_1, "AVAILABLE_ACTIVE: eventData(%s)", ev.eventData.type()->name());
+
+           applicationMode = MULTI_APPLICATION;
+           branding= "";
+           if (ev.eventData.type()->equivalent(_tc_msgDataType))
+           {
+             trace(_HERE_1, "eventData: _tc_msgDataType");
+             const msgDataType* pMsgData;
+             ev.eventData >>= pMsgData;
+             if(pMsgData)
+             {
+               for (unsigned int i = 0; i < pMsgData->records.length(); i++)
+               {
+                 if(pMsgData->records[i].status == datastatus::DS_OK)
+                 {
+                   std::string msg(reinterpret_cast<const char*>(pMsgData->records[i].message.get_buffer()), pMsgData->records[i].message.length());
+                   trace(_HERE_1, "msgData[%d]: %s", i, msg.c_str());
+                   msg= " " + msg;
+                   if(isSAM(msg))
+                   {
+                     trace(_HERE_1, "SINGLEAPP MODE found");
+                     applicationMode = SINGLE_APPLICATION;
+                     //break;
+                   }
+                   language= checkLanguage(msg);
+                   trace(_HERE_1, "Language (%.1000s)", language.c_str());
+
+                   if(i == 0)
+                   {
+                     if(msg.size() > 0)
+                     {
+                       branding= msg;
+                       trim(branding);
+                       trace(_HERE_1, "branding (%.1000s)", branding.c_str());
+                     }
+                   }
+                 }
+               }
+             }
+           }
+         }
+         catch(...)
+         {
+           trace(_HERE_1, "no data in event -> MAM");
+         }
+
+         rc = handleActivate(ev.eventCode);
+         break;
+
+    case m_eventcodes::ACTIVE:
+    case m_eventcodes::INITIALIZE:
+    case m_eventcodes::ACTIVE_AVAILABLE:            /**< State transition WAIT */
+    case m_eventcodes::INITIALIZE_UNAVAILABLE:
+
+         rc = handleIdle(ev.eventCode);
+         break;
+
+    case m_eventcodes::UNAVAILABLE_STOPPED_STOP:    /**< State transition STOP */
+    case m_eventcodes::INITIALIZE_STOPPED_STOP:
+    case m_eventcodes::AVAILABLE_STOPPED_STOP:
+    case m_eventcodes::ACTIVE_STOPPED_STOP:
+    case m_eventcodes::SUSPENDED_STOPPED_STOP:
+    case m_eventcodes::DISABLED_STOPPED_STOP:
+    case m_eventcodes::INITIALIZE_STOPPED_RESTART:  /**< State transition RESTART */
+    case m_eventcodes::AVAILABLE_STOPPED_RESTART:
+    case m_eventcodes::ACTIVE_STOPPED_RESTART:
+    case m_eventcodes::DISABLED_STOPPED_RESTART:
+    case m_eventcodes::SUSPENDED_STOPPED_RESTART:
+    case m_eventcodes::UNAVAILABLE_STOPPED_RESTART:
+
+         rc = handleStop(ev.eventCode);
+         break;
+
+    case m_eventcodes::INITIALIZE_DISABLED:         /**< State transition DISABLE */
+    case m_eventcodes::AVAILABLE_DISABLED:
+    case m_eventcodes::ACTIVE_DISABLED:
+    case m_eventcodes::UNAVAILABLE_DISABLED:
+    case m_eventcodes::SUSPENDED_DISABLED:
+
+         rc = handleDisable(ev.eventCode);
+         break;
+    }
+
+    trace(_HERE_1, "APP-STATE: %s, rc = %s %d", appStateString(), scString(rc).c_str(), rc);
+
+    if(!rc)
+      fDone = true;
+    else
+      fDone = false;
+
+    return(fDone);
+}
+
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        bool cussApplication::applicationEvent(long evc)
+ *
+ *  @brief     handle events from the application
+ *
+ *  @date      30.03.2005
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+bool cussApplication::applicationEvent(long evc)
+{
+    const char* szEvent = NULL;
+bool fDone = false;
+long rc    = 0;
+
+    switch(evc)
+    {
+    case STOP_ME:       szEvent = "STOP_ME";       break;
+    case IDLE_ME:       szEvent = "IDLE_ME";       break;
+    case INIT_ME:       szEvent = "INIT_ME";       break;
+    case START_ME:      szEvent = "START_ME";      break;
+    case ENABLE_ME:     szEvent = "ENABLE_ME";     break;
+    case DISABLE_ME:    szEvent = "DISABLE_ME";    break;
+    case REACTIVATE_ME: szEvent = "REACTIVATE_ME"; break;
+    default:            szEvent = "UNKNOWN";       break;
+    }
+
+    trace(_HERE_1, "APP-STATE: %s, evc = %s (in)", appStateString(), szEvent);
+
+    switch(evc)
+    {
+    case START_ME:      rc = handleStart(0);     break;
+    case IDLE_ME:       rc = handleIdle (0);     break;
+    case STOP_ME:       rc = handleStop (0);     break;
+    case ENABLE_ME:     rc = handleOnScreen(0);  break;
+    case DISABLE_ME:    rc = handleOffScreen(0); break;
+    case REACTIVATE_ME: rc = handleReactivate(0); break;
+
+    default:
+
+         trace(_HERE_1, "EVENT CODE NOT HANDLED: %d", evc);
+         rc = -1;
+         break;
+    }
+
+    trace(_HERE_1, "APP-STATE: %s, rc = %s %d", appStateString(), scString(rc).c_str(), rc);
+
+    if(!rc)
+     fDone = true;
+    else
+    {
+      platformEvent(evc, rc);
+      fDone = false;
+    }
+
+    return(fDone);
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        void cussApplication::appmgrLost()
+ *
+ *  @brief     handle lost connection to appmanager/kproxy
+ *             (to be overloaded in app implementation to handle this event)
+ *
+ *  @date      22.10.2005
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+void cussApplication::appmgrLost()
+{
+    trace(_HERE_1, "appmgrLost() not overloaded...");
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void cussApplication::startHandlingEvents()
+//
+//  purpose:
+//
+//  date:       01.12.00, 14:45
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void cussApplication::startHandlingEvents()
+{
+long rc;
+
+    if(getAppReference() == NULL || *getAppReference() == '\0')
+      rc = queryEnvironment();
+
+    rc = registerForEvents();
+
+    fEventsRegistered = true;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void cussApplication::stopHandlingEvents()
+//
+//  purpose:
+//
+//  date:       01.12.00, 14:45
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void cussApplication::stopHandlingEvents()
+{
+long rc;
+
+    if(fEventsRegistered)
+    {
+      //if(corbaClient::orb())
+        rc = registerForEvents(false);
+      //else
+      //  trace(_HERE_7, "cussApplication::stopHandlingEvents() called after destroying ORB.");
+    }
+
+    fEventsRegistered = false;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long cussApplication::function()
+//              overwrite function of mThreadEx
+//
+//  purpose:    send pings to pingClnt
+//
+//  date:       26.05.2009
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+long cussApplication::function()
+{
+DWORD lastPing= GetTickCount() - (checkAppMgrMinutes * 60000);
+
+  while(!fTerminate)
+  {
+    OS_Sleep(SLEEP_VAL);
+
+    if(!fTerminate && checkAppMgrMinutes && pingClnt)
+    {
+      DWORD now= GetTickCount();
+
+      // check every minute for appmgr availability ...
+
+      if((now - lastPing) >= static_cast<DWORD>(checkAppMgrMinutes * 60000))
+      {
+        lastPing= now;
+
+        try
+        {
+          if(pingClnt->proxy())
+          {
+            trace(_HERE_1, "APPMANAGER CHECK ...");
+            pingResult = pingClnt->proxy()->ping();
+            trace(_HERE_7, "appmanager check ok, rc = %d", pingResult);
+          }
+          else
+          {
+            trace(_HERE_1, "APPMANAGER CHECK FAILED -> NO PING SERVANT/PROXY ...");
+
+            // call the emergency handler
+
+            appmgrLost();
+          }
+        }
+        catch(CORBA::SystemException& ex)
+        {
+          trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+
+          trace(_HERE_1, "APPMANAGER CHECK FAILED -> CORBA::SYSTEMEXCEPTION ...");
+
+          // call the emergency handler
+
+          appmgrLost();
+        }
+      }
+    }
+    else if (!checkAppMgrMinutes)
+    {
+        // trace(_HERE_1, "Discard pinging kiosk proxy: no ping interval available");
+    }
+    else if(!pingClnt)
+    {
+        trace(_HERE_1, "Discard pinging kiosk proxy: no ping client available");
+    }
+  }
+  pingThreadStopped.post();
+  return -1;  // do not restart this function
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   long cussApplication::run(bool fBlock)
+//
+//  purpose:    start the applications (blocking/nonblocking)
+//
+//  date:       04.12.00, 12:31
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long cussApplication::run(bool fBlock)
+{
+long rc     = 0;
+
+    startProcessing();
+    trace(_HERE,"Activate() ret %d", rc );
+    if( rc < 0 )
+    {
+        trace(_HERE,"run() failed %d in Activate(), bail out", rc );
+        return rc;
+    }
+
+    rc = 0;
+
+    if(fBlock)
+    {
+      pingResult= 0;
+      mThreadEx::run(); // start ping thread
+    }
+
+    try
+    {
+      if(getAppReference() == NULL || *getAppReference() == '\0')
+      {
+        rc = queryEnvironment();
+
+        if(rc)
+          return(rc);
+      }
+
+      rc = queryComponents();
+
+      if(rc)
+        return(rc);
+
+      // check if we have to register for events
+
+      if(!fEventsRegistered)
+        startHandlingEvents();
+
+      trace(_HERE_1, "applicationType = %s", applicationType == INIT ? "INIT" : "BUSINESS");
+
+      //if(applicationType == INIT)
+        applicationEvent(START_ME);
+
+      // check if running in blocking mode
+
+      trace(_HERE_1, "cussApplication::run(), tid = %x", GetCurrentThreadId());
+
+      if(fBlock)
+      {
+        pingThreadStopped.wait();
+        rc= pingResult;
+        trace(_HERE_7, "cussApplication::run() terminated.");
+        // deregister for events only in blocking mode !!
+
+        trace(_HERE_7, "run()::stopHandlingEvents()");
+
+        // wenn SAM, dann berschneidung von INIT und CKI -> dann besser kein stopHandlingEvents(;-0)
+//      stopHandlingEvents();
+
+        // need this for sending the last request before
+        // terminating the thread ??
+
+        OS_Sleep(500);
+      }
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+      rc = -1;
+    }
+
+    trace(_HERE_1, "run()::return()");
+
+    return(rc);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long cussApplication::setTraceLevel(long level)
+//
+//  purpose:    set trace level for debugging the interface
+//
+//  date:       12.04.2001, 15:11
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long cussApplication::setTraceLevel(long level)
+{
+    return(setLevel(level));
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        void cussApplication::checkAppManager(long minutes)
+ *
+ *  @brief     Check availability of appmanager/kiosk proxy ...
+ *
+ *  @date      21.10.2005
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+void cussApplication::checkAppManager(long minutes)
+{
+    checkAppMgrMinutes = minutes;
+
+    if(!pingClnt && minutes > 0)
+    {
+      iorParser ior(szIOR);
+
+      if(!ior.error())
+      {
+        trace(_HERE_1, "IOR details:\n%s", ior.infoText());
+
+        sprintf(szPingerIOR, "corbaloc:iiop:%s:%d/Pinger", ior.hostName(), ior.hostPort());
+
+        trace(_HERE_1, "creating ping client: %s", szPingerIOR);
+
+        pingClnt = new corbaClientTerminator <massaiPinger::Pinger> (this, szPingerIOR);
+      }
+      else
+        trace(_HERE_1, "failed to parse application manager IOR");
+    }
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        void cussApplication::initialize()
+ *
+ *  @brief     Implement same constructor initializations only once
+ *
+ *  @date      21.04.2005
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+void cussApplication::initialize()
+{
+    fSelfSuspended    = false;
+    fTerminate        = false;
+    fEventsRegistered = false;
+    fOrbDestroyed     = false;
+
+    signal(SIGABRT, exitHandler);
+    signal(SIGBREAK, exitHandler);
+    signal(SIGTERM, exitHandler);
+    signal(SIGINT,  exitHandler);
+
+    signal(SIGSEGV, exitHandler);
+    signal(SIGILL,  exitHandler);
+    signal(SIGFPE,  exitHandler);
+
+    pApp = this;
+    pCussApp = this;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   cussApplication::cussApplication(char *pszObjRef)
+//
+//  purpose:    Class constructor
+//
+//  date:       01.12.00, 10:43
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+cussApplication::cussApplication(char *pszObjRef,
+                                 char *pszCompanyCode,
+                                 char *pszApplicationName,
+                                 char *pszVendorCode) : amInterface(pszObjRef,
+                                                                    pszCompanyCode,
+                                                                    pszApplicationName,
+                                                                    pszVendorCode),
+                                                        applicationMode(MULTI_APPLICATION),
+                                                        vCompApp(this)
+{
+    applicationType = BUSINESS;
+
+    checkAppMgrMinutes = 0;
+    pingClnt           = NULL;
+    *szPingerIOR       = '\0';
+
+    initialize();
+
+    strcpy(szIOR, pszObjRef);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   cussApplication::~cussApplication();
+//
+//  purpose:    Class destructor
+//
+//  date:       05.12.00, 10:04
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+cussApplication::~cussApplication()
+{
+    signal(SIGABRT, NULL);
+    signal(SIGBREAK, NULL);
+    signal(SIGTERM, NULL);
+    signal(SIGINT,  NULL);
+
+    signal(SIGSEGV, NULL);
+    signal(SIGILL,  NULL);
+    signal(SIGFPE,  NULL);
+
+    pApp = NULL;
+    pCussApp = NULL;
+
+    delete pingClnt;
+    pingClnt = NULL;
+
+}
+
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/cussif.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/cussif.cpp
new file mode 100644
index 00000000..47bb1b40
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/cussif.cpp
@@ -0,0 +1,89 @@
+//---------------------------------------------------------------------------
+//
+//  file:       cussif.cpp
+//
+//  purpose:    virtual component implemenatation
+//
+//  date:       12.09.00, 10:06
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include "cussif.h"
+#include "tracedef.h"
+
+using namespace MASSAI;
+
+//---------------------------------------------------------------------------
+//
+//  function:   vComponent::Object_var connect(const char *pszVCompIOR)
+//
+//  purpose:    connect the virtual component and return the object
+//
+//  date:       28.11.00, 13:44
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+Object_var vComponent::connect(const char *pszVCompIOR)
+{
+    if(pszVCompIOR)
+      obj = vcOrb->string_to_object(pszVCompIOR);
+
+    return(obj);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function: vComponent::vComponent(const char *pszVCompIOR)
+//
+//  purpose:  class constructor
+//
+//  date:     12.09.00, 10:11
+//
+//  author:   Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+vComponent::vComponent(ostream *pStream)
+{
+    cclnt   = NULL;
+    obj     = NULL;
+    pOutput = pStream;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   vComponent::~vComponent()
+//
+//  purpose:    class destructor
+//
+//  date:       06.12.2001, 11:37
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+vComponent::~vComponent()
+{
+    if(cclnt) delete cclnt;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long vComponent::error()
+//
+//  purpose:    return virtual components error code
+//
+//  date:       12.09.00, 11:40
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long vComponent::error()
+{
+    return(lError);
+}
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/cussif_component.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/cussif_component.cpp
new file mode 100644
index 00000000..1bb1c396
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/cussif_component.cpp
@@ -0,0 +1,676 @@
+#include "cussif/cussif_component.h"
+#include "cussif/vcomp.h"
+
+
+namespace massai
+{
+  namespace cussif
+  {
+
+
+/*
+    Application& Application::operator=(const Application& assign)
+    {
+      massai::cuss_components::Application& self = *this;
+      self = assign;
+      m_component = assign.m_component;
+      return *this;
+    }
+    Application::Application()
+    {
+      setComponent(0);
+      setId(0);
+    }
+    Application::Application(MASSAI::vComponent* pComp, int ident)
+    {
+      setComponent(pComp);
+      setId(ident);
+    }
+    void Application::narrow(MASSAI::vComponent*& pComponent, const char* pszIOR)
+    {
+      m_component= Components::Application::_narrow(pComponent->connect(pszIOR));
+    }
+    Characteristics::Manufacturer_ptr Application::getCharacteristicsManufacturer()
+    {
+      return m_component.inout();
+    }
+    Components::CUSSCntl_ptr Application::getComponentsCUSSCntl()
+    {
+      return m_component.inout();
+    }
+    Characteristics::Application_ptr Application::getCharacteristicsApplication()
+    {
+      return m_component.inout();
+    }
+*/
+    Capture& Capture::operator=(const Capture& assign)
+    {
+      massai::cuss_components::Capture& self = *this;
+      self = assign;
+      m_component = assign.m_component;
+      return *this;
+    }
+    Capture::Capture()
+    {
+      setComponent(0);
+      setId(0);
+    }
+    Capture::Capture(MASSAI::vComponent* pComp, int ident)
+    {
+      setComponent(pComp);
+      setId(ident);
+    }
+    void Capture::narrow(MASSAI::vComponent*& pComponent, const char* pszIOR)
+    {
+      m_component= Components::Capture::_narrow(pComponent->connect(pszIOR));
+    }
+    Characteristics::Bin_ptr Capture::getCharacteristicsBin()
+    {
+      return m_component.inout();
+    }
+    Characteristics::Manufacturer_ptr Capture::getCharacteristicsManufacturer()
+    {
+      return m_component.inout();
+    }
+    Components::CUSSCntl_ptr Capture::getComponentsCUSSCntl()
+    {
+      return m_component.inout();
+    }
+    Components::Peripheral_ptr Capture::getComponentsPeripheral()
+    {
+      return m_component.inout();
+    }
+    Components::Userless_ptr Capture::getComponentsUserless()
+    {
+      return m_component.inout();
+    }
+    Components::Capture_ptr Capture::getComponentsCapture()
+    {
+      return m_component.inout();
+    }
+
+    Conveyor& Conveyor::operator=(const Conveyor& assign)
+    {
+      massai::cuss_components::Conveyor& self = *this;
+      self = assign;
+      m_component = assign.m_component;
+      return *this;
+    }
+    Conveyor::Conveyor()
+    {
+      setComponent(0);
+      setId(0);
+    }
+    Conveyor::Conveyor(MASSAI::vComponent* pComp, int ident)
+    {
+      setComponent(pComp);
+      setId(ident);
+    }
+    void Conveyor::narrow(MASSAI::vComponent*& pComponent, const char* pszIOR)
+    {
+      m_component= Components::Conveyor::_narrow(pComponent->connect(pszIOR));
+    }
+    Characteristics::Location_ptr Conveyor::getCharacteristicsLocation()
+    {
+      return m_component.inout();
+    }
+    Characteristics::Manufacturer_ptr Conveyor::getCharacteristicsManufacturer()
+    {
+      return m_component.inout();
+    }
+    Components::CUSSCntl_ptr Conveyor::getComponentsCUSSCntl()
+    {
+      return m_component.inout();
+    }
+    Components::Peripheral_ptr Conveyor::getComponentsPeripheral()
+    {
+      return m_component.inout();
+    }
+    Components::User_ptr Conveyor::getComponentsUser()
+    {
+      return m_component.inout();
+    }
+    Components::Input_ptr Conveyor::getComponentsInput()
+    {
+      return m_component.inout();
+    }
+    Characteristics::Conveyor_ptr Conveyor::getCharacteristicsConveyor()
+    {
+      return m_component.inout();
+    }
+    Components::Conveyor_ptr Conveyor::getComponentsConveyor()
+    {
+      return m_component.inout();
+    }
+
+    DataInput& DataInput::operator=(const DataInput& assign)
+    {
+      massai::cuss_components::DataInput& self = *this;
+      self = assign;
+      m_component = assign.m_component;
+      return *this;
+    }
+    DataInput::DataInput()
+    {
+      setComponent(0);
+      setId(0);
+    }
+    DataInput::DataInput(MASSAI::vComponent* pComp, int ident)
+    {
+      setComponent(pComp);
+      setId(ident);
+    }
+    void DataInput::narrow(MASSAI::vComponent*& pComponent, const char* pszIOR)
+    {
+      m_component= Components::DataInput::_narrow(pComponent->connect(pszIOR));
+    }
+    Characteristics::Manufacturer_ptr DataInput::getCharacteristicsManufacturer()
+    {
+      return m_component.inout();
+    }
+    Components::CUSSCntl_ptr DataInput::getComponentsCUSSCntl()
+    {
+      return m_component.inout();
+    }
+    Components::Peripheral_ptr DataInput::getComponentsPeripheral()
+    {
+      return m_component.inout();
+    }
+    Components::Userless_ptr DataInput::getComponentsUserless()
+    {
+      return m_component.inout();
+    }
+    Components::Input_ptr DataInput::getComponentsInput()
+    {
+      return m_component.inout();
+    }
+    Characteristics::DataInput_ptr DataInput::getCharacteristicsDataInput()
+    {
+      return m_component.inout();
+    }
+
+    DataOutput& DataOutput::operator=(const DataOutput& assign)
+    {
+      massai::cuss_components::DataOutput& self = *this;
+      self = assign;
+      m_component = assign.m_component;
+      return *this;
+    }
+    DataOutput::DataOutput()
+    {
+      setComponent(0);
+      setId(0);
+    }
+    DataOutput::DataOutput(MASSAI::vComponent* pComp, int ident)
+    {
+      setComponent(pComp);
+      setId(ident);
+    }
+    void DataOutput::narrow(MASSAI::vComponent*& pComponent, const char* pszIOR)
+    {
+      m_component= Components::DataOutput::_narrow(pComponent->connect(pszIOR));
+    }
+    Characteristics::Manufacturer_ptr DataOutput::getCharacteristicsManufacturer()
+    {
+      return m_component.inout();
+    }
+    Components::CUSSCntl_ptr DataOutput::getComponentsCUSSCntl()
+    {
+      return m_component.inout();
+    }
+    Components::Peripheral_ptr DataOutput::getComponentsPeripheral()
+    {
+      return m_component.inout();
+    }
+    Components::Userless_ptr DataOutput::getComponentsUserless()
+    {
+      return m_component.inout();
+    }
+    Components::Output_ptr DataOutput::getComponentsOutput()
+    {
+      return m_component.inout();
+    }
+
+    Dispenser& Dispenser::operator=(const Dispenser& assign)
+    {
+      massai::cuss_components::Dispenser& self = *this;
+      self = assign;
+      m_component = assign.m_component;
+      return *this;
+    }
+    Dispenser::Dispenser()
+    {
+      setComponent(0);
+      setId(0);
+    }
+    Dispenser::Dispenser(MASSAI::vComponent* pComp, int ident)
+    {
+      setComponent(pComp);
+      setId(ident);
+    }
+    void Dispenser::narrow(MASSAI::vComponent*& pComponent, const char* pszIOR)
+    {
+      m_component= Components::Dispenser::_narrow(pComponent->connect(pszIOR));
+    }
+    Characteristics::Bin_ptr Dispenser::getCharacteristicsBin()
+    {
+      return m_component.inout();
+    }
+    Characteristics::Location_ptr Dispenser::getCharacteristicsLocation()
+    {
+      return m_component.inout();
+    }
+    Characteristics::Manufacturer_ptr Dispenser::getCharacteristicsManufacturer()
+    {
+      return m_component.inout();
+    }
+    Components::CUSSCntl_ptr Dispenser::getComponentsCUSSCntl()
+    {
+      return m_component.inout();
+    }
+    Components::Peripheral_ptr Dispenser::getComponentsPeripheral()
+    {
+      return m_component.inout();
+    }
+    Components::User_ptr Dispenser::getComponentsUser()
+    {
+      return m_component.inout();
+    }
+    Characteristics::Dispenser_ptr Dispenser::getCharacteristicsDispenser()
+    {
+      return m_component.inout();
+    }
+    Components::Dispenser_ptr Dispenser::getComponentsDispenser()
+    {
+      return m_component.inout();
+    }
+
+    Display& Display::operator=(const Display& assign)
+    {
+      massai::cuss_components::Display& self = *this;
+      self = assign;
+      m_component = assign.m_component;
+      return *this;
+    }
+    Display::Display()
+    {
+      setComponent(0);
+      setId(0);
+    }
+    Display::Display(MASSAI::vComponent* pComp, int ident)
+    {
+      setComponent(pComp);
+      setId(ident);
+    }
+    void Display::narrow(MASSAI::vComponent*& pComponent, const char* pszIOR)
+    {
+      m_component= Components::Display::_narrow(pComponent->connect(pszIOR));
+    }
+    Characteristics::Display_ptr Display::getCharacteristicsDisplay()
+    {
+      return m_component.inout();
+    }
+    Characteristics::Location_ptr Display::getCharacteristicsLocation()
+    {
+      return m_component.inout();
+    }
+    Characteristics::Manufacturer_ptr Display::getCharacteristicsManufacturer()
+    {
+      return m_component.inout();
+    }
+    Components::CUSSCntl_ptr Display::getComponentsCUSSCntl()
+    {
+      return m_component.inout();
+    }
+    Components::Peripheral_ptr Display::getComponentsPeripheral()
+    {
+      return m_component.inout();
+    }
+    Components::User_ptr Display::getComponentsUser()
+    {
+      return m_component.inout();
+    }
+
+    Feeder& Feeder::operator=(const Feeder& assign)
+    {
+      massai::cuss_components::Feeder& self = *this;
+      self = assign;
+      m_component = assign.m_component;
+      return *this;
+    }
+    Feeder::Feeder()
+    {
+      setComponent(0);
+      setId(0);
+    }
+    Feeder::Feeder(MASSAI::vComponent* pComp, int ident)
+    {
+      setComponent(pComp);
+      setId(ident);
+    }
+    void Feeder::narrow(MASSAI::vComponent*& pComponent, const char* pszIOR)
+    {
+      m_component= Components::Feeder::_narrow(pComponent->connect(pszIOR));
+    }
+    Characteristics::Bin_ptr Feeder::getCharacteristicsBin()
+    {
+      return m_component.inout();
+    }
+    Characteristics::Manufacturer_ptr Feeder::getCharacteristicsManufacturer()
+    {
+      return m_component.inout();
+    }
+    Components::CUSSCntl_ptr Feeder::getComponentsCUSSCntl()
+    {
+      return m_component.inout();
+    }
+    Components::Peripheral_ptr Feeder::getComponentsPeripheral()
+    {
+      return m_component.inout();
+    }
+    Components::Userless_ptr Feeder::getComponentsUserless()
+    {
+      return m_component.inout();
+    }
+    Components::Feeder_ptr Feeder::getComponentsFeeder()
+    {
+      return m_component.inout();
+    }
+
+    MediaInput& MediaInput::operator=(const MediaInput& assign)
+    {
+      massai::cuss_components::MediaInput& self = *this;
+      self = assign;
+      m_component = assign.m_component;
+      return *this;
+    }
+    MediaInput::MediaInput()
+    {
+      setComponent(0);
+      setId(0);
+    }
+    MediaInput::MediaInput(MASSAI::vComponent* pComp, int ident)
+    {
+      setComponent(pComp);
+      setId(ident);
+    }
+    void MediaInput::narrow(MASSAI::vComponent*& pComponent, const char* pszIOR)
+    {
+      m_component= Components::MediaInput::_narrow(pComponent->connect(pszIOR));
+    }
+    Characteristics::IOMode_ptr MediaInput::getCharacteristicsIOMode()
+    {
+      return m_component.inout();
+    }
+    Characteristics::MediaTypeList_ptr MediaInput::getCharacteristicsMediaTypeList()
+    {
+      return m_component.inout();
+    }
+    Characteristics::ComponentFonts_ptr MediaInput::getCharacteristicsComponentFonts()
+    {
+      return m_component.inout();
+    }
+    Characteristics::Location_ptr MediaInput::getCharacteristicsLocation()
+    {
+      return m_component.inout();
+    }
+    Characteristics::Manufacturer_ptr MediaInput::getCharacteristicsManufacturer()
+    {
+      return m_component.inout();
+    }
+    Components::CUSSCntl_ptr MediaInput::getComponentsCUSSCntl()
+    {
+      return m_component.inout();
+    }
+    Components::Peripheral_ptr MediaInput::getComponentsPeripheral()
+    {
+      return m_component.inout();
+    }
+    Components::User_ptr MediaInput::getComponentsUser()
+    {
+      return m_component.inout();
+    }
+    Components::Input_ptr MediaInput::getComponentsInput()
+    {
+      return m_component.inout();
+    }
+    Characteristics::MediaInput_ptr MediaInput::getCharacteristicsMediaInput()
+    {
+      return m_component.inout();
+    }
+
+    MediaOutput& MediaOutput::operator=(const MediaOutput& assign)
+    {
+      massai::cuss_components::MediaOutput& self = *this;
+      self = assign;
+      m_component = assign.m_component;
+      return *this;
+    }
+    MediaOutput::MediaOutput()
+    {
+      setComponent(0);
+      setId(0);
+    }
+    MediaOutput::MediaOutput(MASSAI::vComponent* pComp, int ident)
+    {
+      setComponent(pComp);
+      setId(ident);
+    }
+    void MediaOutput::narrow(MASSAI::vComponent*& pComponent, const char* pszIOR)
+    {
+      m_component= Components::MediaOutput::_narrow(pComponent->connect(pszIOR));
+    }
+    Characteristics::IOMode_ptr MediaOutput::getCharacteristicsIOMode()
+    {
+      return m_component.inout();
+    }
+    Characteristics::MediaTypeList_ptr MediaOutput::getCharacteristicsMediaTypeList()
+    {
+      return m_component.inout();
+    }
+    Characteristics::ComponentFonts_ptr MediaOutput::getCharacteristicsComponentFonts()
+    {
+      return m_component.inout();
+    }
+    Characteristics::Location_ptr MediaOutput::getCharacteristicsLocation()
+    {
+      return m_component.inout();
+    }
+    Characteristics::Manufacturer_ptr MediaOutput::getCharacteristicsManufacturer()
+    {
+      return m_component.inout();
+    }
+    Components::CUSSCntl_ptr MediaOutput::getComponentsCUSSCntl()
+    {
+      return m_component.inout();
+    }
+    Components::Peripheral_ptr MediaOutput::getComponentsPeripheral()
+    {
+      return m_component.inout();
+    }
+    Components::User_ptr MediaOutput::getComponentsUser()
+    {
+      return m_component.inout();
+    }
+    Components::Output_ptr MediaOutput::getComponentsOutput()
+    {
+      return m_component.inout();
+    }
+    Characteristics::MediaOutput_ptr MediaOutput::getCharacteristicsMediaOutput()
+    {
+      return m_component.inout();
+    }
+
+    Network& Network::operator=(const Network& assign)
+    {
+      massai::cuss_components::Network& self = *this;
+      self = assign;
+      m_component = assign.m_component;
+      return *this;
+    }
+    Network::Network()
+    {
+      setComponent(0);
+      setId(0);
+    }
+    Network::Network(MASSAI::vComponent* pComp, int ident)
+    {
+      setComponent(pComp);
+      setId(ident);
+    }
+    void Network::narrow(MASSAI::vComponent*& pComponent, const char* pszIOR)
+    {
+      m_component= Components::Network::_narrow(pComponent->connect(pszIOR));
+    }
+    Characteristics::Manufacturer_ptr Network::getCharacteristicsManufacturer()
+    {
+      return m_component.inout();
+    }
+    Components::CUSSCntl_ptr Network::getComponentsCUSSCntl()
+    {
+      return m_component.inout();
+    }
+    Components::Peripheral_ptr Network::getComponentsPeripheral()
+    {
+      return m_component.inout();
+    }
+    Components::Userless_ptr Network::getComponentsUserless()
+    {
+      return m_component.inout();
+    }
+
+    Storage& Storage::operator=(const Storage& assign)
+    {
+      massai::cuss_components::Storage& self = *this;
+      self = assign;
+      m_component = assign.m_component;
+      return *this;
+    }
+    Storage::Storage()
+    {
+      setComponent(0);
+      setId(0);
+    }
+    Storage::Storage(MASSAI::vComponent* pComp, int ident)
+    {
+      setComponent(pComp);
+      setId(ident);
+    }
+    void Storage::narrow(MASSAI::vComponent*& pComponent, const char* pszIOR)
+    {
+      m_component= Components::Storage::_narrow(pComponent->connect(pszIOR));
+    }
+    Characteristics::Manufacturer_ptr Storage::getCharacteristicsManufacturer()
+    {
+      return m_component.inout();
+    }
+    Components::CUSSCntl_ptr Storage::getComponentsCUSSCntl()
+    {
+      return m_component.inout();
+    }
+    Components::Peripheral_ptr Storage::getComponentsPeripheral()
+    {
+      return m_component.inout();
+    }
+    Components::Userless_ptr Storage::getComponentsUserless()
+    {
+      return m_component.inout();
+    }
+    Characteristics::Storage_ptr Storage::getCharacteristicsStorage()
+    {
+      return m_component.inout();
+    }
+
+    UserInput& UserInput::operator=(const UserInput& assign)
+    {
+      massai::cuss_components::UserInput& self = *this;
+      self = assign;
+      m_component = assign.m_component;
+      return *this;
+    }
+    UserInput::UserInput()
+    {
+      setComponent(0);
+      setId(0);
+    }
+    UserInput::UserInput(MASSAI::vComponent* pComp, int ident)
+    {
+      setComponent(pComp);
+      setId(ident);
+    }
+    void UserInput::narrow(MASSAI::vComponent*& pComponent, const char* pszIOR)
+    {
+      m_component= Components::UserInput::_narrow(pComponent->connect(pszIOR));
+    }
+    Characteristics::Location_ptr UserInput::getCharacteristicsLocation()
+    {
+      return m_component.inout();
+    }
+    Characteristics::Manufacturer_ptr UserInput::getCharacteristicsManufacturer()
+    {
+      return m_component.inout();
+    }
+    Components::CUSSCntl_ptr UserInput::getComponentsCUSSCntl()
+    {
+      return m_component.inout();
+    }
+    Components::Peripheral_ptr UserInput::getComponentsPeripheral()
+    {
+      return m_component.inout();
+    }
+    Components::User_ptr UserInput::getComponentsUser()
+    {
+      return m_component.inout();
+    }
+    Components::Input_ptr UserInput::getComponentsInput()
+    {
+      return m_component.inout();
+    }
+
+    UserOutput& UserOutput::operator=(const UserOutput& assign)
+    {
+      massai::cuss_components::UserOutput& self = *this;
+      self = assign;
+      m_component = assign.m_component;
+      return *this;
+    }
+    UserOutput::UserOutput()
+    {
+      setComponent(0);
+      setId(0);
+    }
+    UserOutput::UserOutput(MASSAI::vComponent* pComp, int ident)
+    {
+      setComponent(pComp);
+      setId(ident);
+    }
+    void UserOutput::narrow(MASSAI::vComponent*& pComponent, const char* pszIOR)
+    {
+      m_component= Components::UserOutput::_narrow(pComponent->connect(pszIOR));
+    }
+    Characteristics::Location_ptr UserOutput::getCharacteristicsLocation()
+    {
+      return m_component.inout();
+    }
+    Characteristics::Manufacturer_ptr UserOutput::getCharacteristicsManufacturer()
+    {
+      return m_component.inout();
+    }
+    Components::CUSSCntl_ptr UserOutput::getComponentsCUSSCntl()
+    {
+      return m_component.inout();
+    }
+    Components::Peripheral_ptr UserOutput::getComponentsPeripheral()
+    {
+      return m_component.inout();
+    }
+    Components::User_ptr UserOutput::getComponentsUser()
+    {
+      return m_component.inout();
+    }
+    Components::Output_ptr UserOutput::getComponentsOutput()
+    {
+      return m_component.inout();
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/dispMap.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/dispMap.cpp
new file mode 100644
index 00000000..7ab7c5e3
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/dispMap.cpp
@@ -0,0 +1,1414 @@
+/**
+ **************************************************************************
+ *
+ * @file dispMap.cpp
+ *
+ * dispXTRA device implementation: showDisplay(aMap& screen)
+ *
+ * @author TS
+ *
+ * Copyright (c) 2001, MATERNA Information & Communications
+ *
+ **************************************************************************
+**/
+/*
+  History:
+    31.10.2001 use TXT-Files for ids
+    20.09.2004 ts long showDisplay(aMap& screen, bool xml= false) parameter xml added
+
+*/
+
+#include <string>
+
+#if defined(_TAO_)
+
+#include "tao/corba.h"
+#include "orbIncDefs.h"
+
+#elif defined(_ORBACUS_)
+
+#include "OB/CORBA.h"
+#include "OB/Properties.h"
+#include "OB\CORBAClient.h"
+#include "OB\POAInterface.h"
+#include "OB\BootManager.h"
+#include "OB\ORB_init.h"
+#include "OB\OBORB.h"
+
+#endif
+
+#include "boost\regex.hpp"
+#include "tracedef.h"
+#include "language.h"
+#include "asso.h"
+#include "assotrace.h"
+
+#include "dispdev.h"
+#include "dispMap.h"
+#include <algorithm>
+#include <string>
+
+
+enum ValueIds
+{
+  ID_SCREEN= 0,
+  ID_DATA,
+  ID_RTF,
+  ID_ENCODING,
+  ID_LANGUAGE,
+};
+const char* ValueName[]=
+{
+  "ScreenId",
+  "Data",
+  "RTF",
+  "CODE",
+  "LangId"
+};
+
+using std::string;
+using boost::/*cmatch;*/smatch;
+using boost::regex_search;
+using boost::regex;
+
+using namespace MASSAI;
+
+/*
+  regular expression to find
+  variable ids in the template file
+*/
+regex expression("%([A-Za-z0-9_]+)%");
+/*
+  file ending for the template files
+  values with this ending are filenames (and replaced by the content of the file)
+  if no template is set for a screen member the member name and this ending is assumed as filename
+*/
+const char* pszTPLEnd= ".rtf";
+// 31.10.2001 use TXT-Files for ids
+const char* pszTXTEnd= ".txt";
+/*
+  template filenames are stored in the map of a screen member or of a listbox under this TPL
+*/
+const aObject TPL= -1;
+/*
+  additional parameter are stored in the map of a screen member or of a listbox under this Param
+*/
+const aObject Param= -2;
+/*
+  error messages (rtf)
+*/
+const char* szErrorPre[]=
+{
+  "{\\rtf1\\ansi\\ansicpg1252\\deff0\\deftab720{\\fonttbl{\\f0\\fswiss\\fprq2 Arial;}}\n"
+  "{\\colortbl\\red0\\green0\\blue0;}\n"
+  "\\deflang1031\\horzdoc{\\*\\fchars }{\\*\\lchars }\\pard\\plain\\f0\\fs40 ",
+  ""
+};
+const char* szErrorPost[]=
+{
+  "\n\\par }",
+  ""
+};
+
+/*
+  test if the id is the TPL id
+*/
+bool isTPL(const aObject& Test)
+{
+  if (Test.getTag() == OBJ_NUM && Test.numObject() == -1)
+    return true;
+  else
+    return false;
+}
+/*
+  test if a value is a template filename
+*/
+bool isRTF(const aObject& Test)
+{
+  bool result;
+  const char* pData;
+  int iLength;
+  result= false;
+  pData= Test.strObject();
+  if (pData != 0)  // test only OBJ_STR objects
+  {
+    iLength= strlen(pData);
+    if (iLength >= sizeof(pszTPLEnd))
+    {
+      // test if the last characters of the zero terminated string are equal to the ending
+      if (strcmp(pData + iLength - sizeof(pszTPLEnd), pszTPLEnd) == 0)
+         result= true;
+    }
+  }
+  return result;
+}
+/*
+  test if a value is a txt filename
+  31.10.2001 use TXT-Files for ids
+*/
+bool isTXT(const aObject& Test)
+{
+  bool result;
+  const char* pData;
+  int iLength;
+  result= false;
+  pData= Test.strObject();
+  if (pData != 0)  // test only OBJ_STR objects
+  {
+    iLength= strlen(pData);
+    if (iLength >= sizeof(pszTXTEnd))
+    {
+      // test if the last characters of the zero terminated string are equal to the ending
+      if (strcmp(pData + iLength - sizeof(pszTXTEnd), pszTXTEnd) == 0)
+         result= true;
+    }
+  }
+  return result;
+}
+/*
+  replace all variables in the template file by the values of DataIn
+*/
+int fillTemplate(string Template, const aMap& DataIn, string& result, aMap& DataUsed, aMap& NotFound)
+{
+  /*cmatch */smatch parsed;
+  string id;
+  aObject Value;
+  std::string::const_iterator position= Template.begin();
+  std::string::const_iterator end= Template.end();
+  trace(_HERE_8, "fillTemplate <- (%s)", Template.c_str());
+  while(regex_search(position, end, parsed, expression))
+  {
+    if(parsed[0].first != position)
+    {
+      result.append(position, parsed[0].first);  // no variable found in this part
+    }
+    id= std::string(parsed[1].first, parsed[1].second);  // first variable found
+    position= parsed[0].second;
+    trace(_HERE_8, "result = %s", result.c_str());
+
+
+    Value= DataIn.get(id.c_str());
+    if (Value.getTag() == OBJ_STR)
+    {
+      result.append(Value.strObject());  // add the value of the variable
+      DataUsed.set(id.c_str(), 1);
+      trace(_HERE_8, "result = %s", result.c_str());
+    }
+    else if (Value.getTag() == OBJ_NUM)
+    {
+      char Buffer[30];
+      sprintf(Buffer, "%d", Value.numObject());
+      result.append(Buffer);                    // add the value of the variable
+
+      trace(_HERE_8, "result = %s", result.c_str());
+      DataUsed.set(id.c_str(), 1);
+    }
+    else
+    {
+      NotFound.set(id.c_str(), 1);
+      trace(_HERE_8, "fillTemplate id (%s) not found", id.c_str());
+    }
+  }
+  result.append(position, end);// no further variable found
+  trace(_HERE_9, "fillTemplate -> (%s)", result.c_str());
+  return 0;
+}
+/*
+  read the template file to Template (if not found use pAlternative)
+*/
+int loadTemplate(const char* pFile, const char* pAlternative, string& Template, language& resource, bool isRtf)
+{
+  int result;
+  char *pTemplate;
+  pTemplate= 0;
+  char szPath[1024];
+  if (pFile)
+    pTemplate= resource.resourceFile(pFile, szPath);
+  if (pTemplate)
+  {
+    Template= pTemplate;
+    delete[] pTemplate;
+    result= 0;
+  }
+  else
+  {
+    trace(_HERE_7, "no template found for (%s) in (%s)", pFile, szPath);
+    /*
+    if(pAlternative)
+      Template= pAlternative;
+    */
+    if (isRtf)
+    {
+      Template= pFile;
+      std::replace(Template.begin(), Template.end() , '\\', '/');
+      Template= szErrorPre[0] + Template + szErrorPost[0];
+    }
+    else
+    {
+      Template= pFile;
+      std::replace(Template.begin(), Template.end() , '\\', '/');
+      Template= szErrorPre[1] + Template + szErrorPost[1];
+    }
+    result= -1;
+  }
+  trace(_HERE_9, "loadTemplate (%s) for (%s)", Template.c_str(), pFile);
+  return result;
+}
+/*
+  read the template file to Template (if not found use pAlternative)
+*/
+int loadTemplate(const char* pScreenId, const char* pTemplate, const char* pAlternative, string& Template, language& resource)
+{
+  int result;
+  string File;
+  if (pScreenId && pTemplate)
+  {
+    File= pScreenId;
+    File+= "\\";
+    File+= pTemplate;  // search the template in the directory named by screenid
+    result= loadTemplate(File.c_str(), pAlternative, Template, resource, true);
+    if (result != 0)
+    {
+      // if template does not exist in the ScreenId directory, search in language directory
+      result= loadTemplate(pTemplate, pAlternative, Template, resource, true);
+    }
+  }
+  else
+  {
+    trace(_HERE_7, "loadTemplate Error ScreenId(%s), Template(%s)", pScreenId, pTemplate);
+    if(pAlternative)
+      Template= pAlternative;
+    result= -1;
+  }
+  return result;
+}
+void rtfcoding(std::string& text, char value)
+{
+  char buf[10];
+  unsigned int i= static_cast<unsigned char>(value);
+  sprintf(buf, "%x", i);
+  text+= "\\'";
+  text+= buf;
+}
+
+int transCoding(const aObject DataIn, aObject& DataOut, aObject& DataError, screen::Encoding enc)
+{
+  switch(enc)
+  {
+    case screen::ENCODING_GB2312:
+    {
+      std::string buf;
+      const char* pData= DataIn.strObject();
+      buf.reserve(4 * strlen(pData));
+      while((*pData) != 0)
+      {
+        if((0 <= *pData) && (*pData <= 128))
+        {
+          buf+= *pData;
+          ++pData;
+        }
+        else
+        {
+          char codepage= *pData;
+          ++pData;
+          if(*pData == 0)
+          {
+            DataError= DataIn;
+            break;
+          }
+          char character= *pData;
+          ++pData;
+          rtfcoding(buf, codepage);
+          rtfcoding(buf, character);
+        }
+      }
+      DataOut= buf.c_str();
+      break;
+    }
+    default:
+      DataOut= DataIn;
+  }
+  return 0;
+}
+/*
+  translate the values of the data entries (if a filename is found use the content of the file)
+*/
+int transData(const aObject& ScreenId, const aObject DataIn, aObject& DataOut, aObject& DataError, language& resource, screen::Encoding enc)
+{
+  string Template;
+  string File;
+  int result;
+  if (DataIn.getTag() == OBJ_STR)
+  {
+    // 31.10.2001 use TXT-Files for ids
+    if (isTXT(DataIn))
+    {
+      if (ScreenId.getTag() == OBJ_STR)
+      {
+        File= ScreenId.strObject();
+        File+= "\\";
+        File+= DataIn.strObject();  // search the file in the directory named by screenid
+        result= loadTemplate(File.c_str(), DataIn.strObject(), Template, resource, false);
+      }
+      else
+        result= -1;
+      if (result != 0)
+      {
+        // if file does not exist in the ScreenId directory, search in language directory
+        result= loadTemplate(DataIn.strObject(), DataIn.strObject(), Template, resource, false);
+      }
+      if (result != 0)
+        DataError= Template.c_str();
+      DataOut= Template.c_str();
+    }
+    else
+    {
+      transCoding(DataIn, DataOut, DataError, enc);
+    }
+    trace(_HERE_9, "transData (%s) to (%s)", DataIn.strObject(), DataOut.strObject());
+  }
+  return 0;
+}
+/*
+  collect the dataentries and fill the template
+*/
+int transDataSection(const aObject& ScreenId, const aObject& TemplateIn, const aMap& SectionIn,
+  aObject& SectionOut, aMap& SectionError, bool bList, language& resource, screen::Encoding enc)
+{
+  aMap DataEntries, DataUsed;
+  aObject DataOut, DataError, Template, Value;
+  const aObject *pItem;
+  string FileContent, Result;
+  // get the template filename
+  if (bList)  // already done if not in a list entry
+  {
+    Template= SectionIn.get(TPL);
+    if (Template.getTag() != OBJ_STR)
+    {
+      if (Template.getTag() != OBJ_NIL)
+      {
+        trace(_HERE_7, "invalid template");
+        SectionError.set(TPL, Template);
+      }
+      Template= TemplateIn;
+    }
+  }
+  else
+    Template= TemplateIn;
+
+  // iterate section entries
+  // collect translated values in DataEntries
+  pItem= 0;
+  while((pItem= SectionIn.getNextKey(pItem)) != 0)
+  {
+    Value= SectionIn.get(*pItem);
+    if (isTPL(*pItem))
+    {}
+    else if ( pItem->getTag() == OBJ_STR)
+    {
+      if (Value.getTag() == OBJ_STR)
+      {
+        DataOut.clr();
+        DataError.clr();
+        transData(ScreenId, Value, DataOut, DataError, resource, enc);
+        if (DataError.getTag() == OBJ_STR)
+        {
+          SectionError.set(*pItem, DataError);
+          trace(_HERE_7, "transData error for (%s)", pItem->strObject());
+        }
+        if (DataOut.getTag() == OBJ_STR)
+        {
+          DataEntries.set(*pItem, DataOut);
+          trace(_HERE_9, "transData response for (%s) is (%s)", pItem->strObject(), DataOut.strObject());
+        }
+        else
+          trace(_HERE_9, "transData response for (%s) is empty", pItem->strObject());
+      }
+      else if (Value.getTag() == OBJ_NUM)
+      {
+        // numObject need not to be translated
+        DataEntries.set(*pItem, Value);
+      }
+      else
+      {
+        SectionError.set(*pItem, Value);
+        trace(_HERE_7, "transData invalid data for (%s)", pItem->strObject());
+      }
+    }
+    else if (bList)
+    {
+      SectionError.set(*pItem, Value);
+      trace(_HERE_7, "transData invalid data for (%s)", pItem->strObject());
+    }
+  }
+
+  // fill the template
+  if (loadTemplate(ScreenId.strObject(), Template.strObject(), Template.strObject(), FileContent, resource) != 0)
+    SectionError.set(TPL, Template);
+  fillTemplate(FileContent, DataEntries, Result, DataUsed, SectionError);
+  SectionOut= Result.c_str();
+
+  // check unused entries
+  pItem= 0;
+  while((pItem= DataEntries.getNextKey(pItem)) != 0)
+    if (DataUsed.get(*pItem).numObject() != 1)
+    {
+      trace(_HERE_7, "(%s)->(%s) not used", pItem->strObject(), DataEntries.get(*pItem).strObject());
+      SectionError.set(*pItem, DataEntries.get(*pItem));
+    }
+  return 0;
+}
+/*
+  collect the dataentries and fill the template for a screen member
+  for a listbox create the listbox entries
+*/
+int transSection(const aObject& ScreenId, const aObject& TemplateIn, const aMap& SectionIn,
+  aObject& SectionOut, aMap& SectionError, language& resource, screen::Encoding enc)
+{
+  aMap ListError, SectionOutList;
+  aObject ListOut, Value, Template;
+  const aObject *pItem;
+  bool bListSection;
+  // get the template filename
+  Template= SectionIn.get(TPL);
+  if (Template.getTag() != OBJ_STR)
+  {
+    if (Template.getTag() != OBJ_NIL)
+    {
+      trace(_HERE_7, "invalid template");
+      SectionError.set(TPL, Template);
+    }
+    Template= TemplateIn;
+  }
+
+  // iterate section entries, collect the list box entries
+  pItem= 0;
+  bListSection= false;
+  while((pItem= SectionIn.getNextKey(pItem)) != 0)
+  {
+    Value= SectionIn.get(*pItem);
+    if (isTPL(*pItem) || pItem->getTag() == OBJ_STR)
+    {}
+    else if (pItem->getTag() == OBJ_NUM)
+    {
+      // listbox entry
+      if (Value.getTag() == OBJ_MAP)
+      {
+        ListOut.clr();
+        ListError.clr();
+        transDataSection(ScreenId, Template, Value.mapObject(), ListOut, ListError, true, resource, enc);
+        if (ListOut.getTag() == OBJ_STR)
+        {
+          trace(_HERE_9, "transDataSection for (%d) is (%s)", pItem->numObject(), ListOut.strObject());
+          SectionOutList.set(*pItem, ListOut);
+          bListSection= true;
+        }
+        else
+        {
+          trace(_HERE_7, "transDataSection for (%d) is empty", pItem->numObject());
+        }
+        if (ListError.count() > 0)
+        {
+          trace(_HERE_7, "transDataSection error for (%d)", pItem->numObject());
+          SectionError.set(*pItem, ListError);
+        }
+       }
+       else
+       {
+         trace(_HERE_7, "transDataSection invalid data for (%d)", pItem->numObject());
+         SectionError.set(*pItem, Value);
+       }
+    }
+    else
+    {
+      trace(_HERE_7, "transSection invalid data for (%s)", pItem->strObject());
+      SectionError.set(*pItem, Value);
+    }
+  }
+  if (bListSection)
+  {
+    // in a list box no further data entries are expected
+    pItem= 0;
+    while((pItem= SectionIn.getNextKey(pItem)) != 0)
+      if (!isTPL(*pItem) && pItem->getTag() == OBJ_STR)
+      {
+        trace(_HERE_7, "transDataSection further data entries in a list box: (%s)", pItem->strObject());
+        SectionError.set(*pItem, SectionIn.get(*pItem));
+      }
+    SectionOut= SectionOutList;
+  }
+  else
+  {
+    // not a list box => fill the templatae
+    transDataSection(ScreenId, Template, SectionIn, SectionOut, SectionError, false, resource, enc);
+  }
+  return 0;
+}
+/*
+  get template name from the sectionname
+ */
+int getTemplate(const aObject& Section, aObject& Template)
+{
+  if (Section.getTag() == OBJ_STR)
+  {
+    string File;
+    File= Section.strObject();
+    File+= pszTPLEnd;
+    Template= aObject(File.data(), File.size());
+  }
+  return 0;
+}
+/*
+  get the values for the screen member
+  string or list(for listbox)
+*/
+int transScreen(const aObject& ScreenId, const aMap& ScreenIn,
+  aMap& ScreenOut, aMap& ScreenError, language& resource, screen::Encoding enc)
+{
+  aMap SectionError;
+  aObject SectionOut, Template, Value;
+  const aObject *pItem;
+  // iterate screen entries
+
+  pItem= 0;
+  while((pItem= ScreenIn.getNextKey(pItem)) != 0)
+  {
+    Value= ScreenIn.get(*pItem);
+    if (pItem->getTag() == OBJ_STR && Value.getTag() == OBJ_MAP)
+    {
+      SectionOut.clr();
+      SectionError.clr();
+      getTemplate(*pItem, Template);
+      transSection(ScreenId, Template, Value.mapObject(),
+        SectionOut, SectionError, resource, enc);
+      if (SectionOut.getTag() == OBJ_STR)
+      {
+        ScreenOut.set(*pItem, SectionOut);
+        trace(_HERE_9, "transSection for (%s) is (%s)", pItem->strObject(), SectionOut.strObject());
+      }
+      else if (SectionOut.getTag() == OBJ_MAP)
+      {
+        ScreenOut.set(*pItem, SectionOut);
+        trace(_HERE_8, "transSection for (%s) is a list box", pItem->strObject(), SectionOut.strObject());
+      }
+      else
+        trace(_HERE_7, "transSection for (%s) is empty", pItem->strObject());
+
+      if (SectionError.count() > 0)
+      {
+        ScreenError.set(*pItem, SectionError);
+        trace(_HERE_7, "transScreen error for (%s)", pItem->strObject());
+      }
+    }
+    else
+    {
+      ScreenError.set(*pItem, Value);
+      trace(_HERE_7, "transScreen invalid data for (%s)", pItem->strObject());
+    }
+  }
+  return 0;
+}
+
+/*
+  transform the ScreenId map
+  replace template file name and data entries by the filled template
+
+  Input:
+  ScreenId= "ScreenId"
+  RTF=
+   "Member"*=
+    TPL?= "Template.rtf"           # language\ScreenId\Template.rtf  else use language\ScreenId\Section.rtf
+    "id"*= "Value"|"Template.rtf"  # language\Template.rtf
+   "ListBox"*=
+    TPL?= "Template.rtf"           # language\ScreenId\Template.rtf  else use language\ScreenId\ListSection.rtf
+    n*=
+     TPL?= "Template.rtf"          # language\ScreenId\Template.rtf
+     "id"*= "Value"|"Template.rtf" # language\Template.rtf
+  Data=
+    n*= "Data"
+
+  Output:
+  ScreenId= "ScreenId"
+  RTF=
+   "Member"*= "Value"
+   "ListBox"*=
+    n*= "Value"
+  Data=
+    n*= "Data"
+  LangId= "LanguageId"
+*/
+int transScreenId(const aMap& ScreenIdIn, aMap& ScreenIdOut,
+  aMap& ScreenIdError, language& resource)
+{
+/*
+  aMap ScreenOut, ScreenError;
+  aObject Value;
+  const aObject *pItem;
+  bool bScreenFound;
+  // iterate screenid entries
+  bScreenFound= false;  // transform only one screen id (more are not expected)
+  pItem= 0;
+  while((pItem= ScreenIdIn.getNextKey(pItem)) != 0)
+  {
+    Value= ScreenIdIn.get(*pItem);
+
+    if ((!bScreenFound) && pItem->getTag() == OBJ_STR
+      && Value.getTag() == OBJ_MAP)
+    {
+      ScreenOut.clr();
+      ScreenError.clr();
+      transScreen(*pItem, Value.mapObject(), ScreenOut, ScreenError, resource);
+      if (ScreenOut.count() > 0)
+      {
+        bScreenFound= true;
+        ScreenIdOut.set(*pItem, ScreenOut);
+        trace(_HERE_9, "transScreen for (%s) is valid", pItem->strObject());
+      }
+      else
+      {
+        trace(_HERE_7, "transScreen for (%s) is empty", pItem->strObject());
+      }
+
+      if (ScreenError.count() > 0)
+      {
+        ScreenIdError.set(*pItem, ScreenError);
+        trace(_HERE_7, "transScreen error for (%s)", pItem->strObject());
+      }
+    }
+    else
+    {
+      trace(_HERE_7, "transScreenId invalid data for (%s)", pItem->strObject());
+      ScreenIdError.set(*pItem, Value);
+    }
+  }
+*/
+  aObject ScreenId, ScreenIn, EncodingIn;
+  screen::Encoding enc= screen::ENCODING_NO;
+  aMap ScreenOut, ScreenError;
+  ScreenId= ScreenIdIn.get(ValueName[ID_SCREEN]);
+  ScreenIn= ScreenIdIn.get(ValueName[ID_RTF]);
+  EncodingIn= ScreenIdIn.get(ValueName[ID_ENCODING]);
+  ScreenIdOut.set(ValueName[ID_SCREEN], ScreenId);
+  {
+    char Buffer[30];
+    sprintf(Buffer, "%d", resource.languageId());
+    ScreenIdOut.set(ValueName[ID_LANGUAGE], Buffer);
+  }
+
+
+  if(EncodingIn.getTag() != OBJ_NUM)
+  {
+    trace(_HERE_7, "transScreenId invalid data for (%s)", ValueName[ID_ENCODING]);
+  }
+  else
+  {
+    enc= screen::Encoding(EncodingIn.numObject());
+  }
+  if (ScreenId.getTag() != OBJ_STR)
+  {
+    trace(_HERE_7, "transScreenId invalid data for (%s)", ValueName[ID_SCREEN]);
+    ScreenIdError.set(ValueName[ID_SCREEN], ScreenId);
+  }
+  else if (ScreenIn.getTag() != OBJ_MAP)
+  {
+    trace(_HERE_7, "transScreenId invalid data for (%s)", ValueName[ID_RTF]);
+    ScreenIdError.set(ValueName[ID_RTF], ScreenIn);
+  }
+  else
+  {
+    transScreen(ScreenId, ScreenIn.mapObject(), ScreenOut, ScreenError, resource, enc);
+    if (ScreenOut.count() > 0)
+    {
+      ScreenIdOut.set(ValueName[ID_RTF], ScreenOut);
+      trace(_HERE_9, "transScreen for (%s) is valid", ScreenId.strObject());
+    }
+    else
+    {
+      trace(_HERE_7, "transScreen for (%s) is empty", ScreenId.strObject());
+    }
+    if (ScreenError.count() > 0)
+    {
+      ScreenIdError.set(ValueName[ID_RTF], ScreenError);
+      trace(_HERE_7, "transScreen error for (%s)", ValueName[ID_RTF]);
+    }
+  }
+
+  ScreenIdOut.set(ValueName[ID_DATA], ScreenIdIn.get(ValueName[ID_DATA]));
+
+  return 0;
+}
+
+
+
+
+/** This method requests the XTRA to display a specific screen.
+    @param screen - A map decribing all screen parameters
+*/
+
+long displayXTRA::showDisplay(const aMap& screen, bool xml, long lTimeout)
+{
+  aMap out, error;
+  trace(_HERE_9, "showDisplay");
+  transScreenId(screen, out, error, *this);
+  //assoTrace(_HERE_7, error);
+  //assoTrace(_HERE_9, screen);
+  //assoTrace(_HERE_9, out);
+
+  trace(_HERE_1, "reqDisplay() ...");
+
+  reqDisplay(out, xml, lTimeout);
+
+  trace(_HERE_1, "reqDisplay(), done.");
+
+  return 0;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long screen::error()
+//
+//  purpose:    Returns the current error, 0 if none
+//
+//  date:       05.09.2001, 13:28
+//
+//  author:     Materna Information & Communications (AGe/TS)
+//
+//---------------------------------------------------------------------------
+
+long screen::error()
+{
+    return(lError);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   screen& screen::member(char *pszName);
+//
+//  purpose:    Creates a new member for this screen.
+//
+//  date:       05.09.2001, 13:28
+//
+//  author:     Materna Information & Communications (AGe/TS)
+//
+//---------------------------------------------------------------------------
+
+screen& screen::member(char *pszName)
+{
+    aMap Member;
+    lError= 0;
+    if (get(ValueName[ID_RTF]).getTag() != OBJ_MAP)
+    {
+      lError= INVALID_DATA;
+      trace(_HERE_7, "screen::member(%s), INVALID_DATA", pszName);
+    }
+    else
+    {
+      Member= get(ValueName[ID_RTF]).mapObject();
+      Member.set(pszName, aMap());
+      set(ValueName[ID_RTF], Member);
+    }
+    return(*this);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   screen& member(char *pszName, char *pszFile);
+//
+//  purpose:    Creates a new member for this screen.
+//
+//  date:       05.09.2001, 13:28
+//
+//  author:     Materna Information & Communications (AGe/TS)
+//
+//---------------------------------------------------------------------------
+
+screen& screen::member(char *pszName, char *pszFile)
+{
+    aMap Member, Data;
+    lError= 0;
+    if (get(ValueName[ID_RTF]).getTag() != OBJ_MAP)
+    {
+      lError= INVALID_DATA;
+      trace(_HERE_7, "screen::member(%s, %s), INVALID_DATA", pszName, pszFile);
+    }
+    else
+    {
+      Data.set(TPL, pszFile);
+      Member= get(ValueName[ID_RTF]).mapObject();
+      Member.set(pszName, Data);
+      set(ValueName[ID_RTF], Member);
+    }
+    return(*this);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   screen& member(char *pszName, aMap& data);
+//
+//  purpose:    Creates a new member for this screen.
+//
+//  date:       05.09.2001, 13:28
+//
+//  author:     Materna Information & Communications (AGe/TS)
+//
+//---------------------------------------------------------------------------
+
+screen& screen::member(char *pszName, aMap& data)
+{
+    aMap Member;
+    lError= 0;
+    if (get(ValueName[ID_RTF]).getTag() != OBJ_MAP)
+    {
+      lError= INVALID_DATA;
+      trace(_HERE_7, "screen::member(%s, data), INVALID_DATA", pszName);
+    }
+    else
+    {
+      Member= get(ValueName[ID_RTF]).mapObject();
+      Member.set(pszName, data);
+      set(ValueName[ID_RTF], Member);
+    }
+    return(*this);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   screen& member(char *pszName, char *pszFile, aMap& data);
+//
+//  purpose:    Creates a new member for this screen.
+//
+//  date:       05.09.2001, 13:28
+//
+//  author:     Materna Information & Communications (AGe/TS)
+//
+//---------------------------------------------------------------------------
+
+screen& screen::member(char *pszName, char *pszFile, aMap& data)
+{
+    aMap Member;
+    lError= 0;
+    if (get(ValueName[ID_RTF]).getTag() != OBJ_MAP)
+    {
+      lError= INVALID_DATA;
+      trace(_HERE_7, "screen::member(%s, %s, data), INVALID_DATA", pszName, pszFile);
+    }
+    else
+    {
+      data.set(TPL, pszFile);
+      Member= get(ValueName[ID_RTF]).mapObject();
+      Member.set(pszName, data);
+      set(ValueName[ID_RTF], Member);
+    }
+    return(*this);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   screen& list(char *pszName);
+//
+//  purpose:    Creates a new list for this screen.
+//
+//  date:       05.09.2001, 13:28
+//
+//  author:     Materna Information & Communications (AGe/TS)
+//
+//---------------------------------------------------------------------------
+
+screen& screen::list(char *pszName)
+{
+    aMap Member;
+    lError= 0;
+    if (get(ValueName[ID_RTF]).getTag() != OBJ_MAP)
+    {
+      lError= INVALID_DATA;
+      trace(_HERE_7, "screen::list(%s), INVALID_DATA", pszName);
+    }
+    else
+    {
+      Member= get(ValueName[ID_RTF]).mapObject();
+      Member.set(pszName, aMap());
+      set(ValueName[ID_RTF], Member);
+      CurrentListId= pszName;
+    }
+    return(*this);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   screen& list(char *pszName, char* pszFile)
+//
+//  purpose:    Creates a new list for this screen.
+//
+//  date:       05.09.2001, 13:28
+//
+//  author:     Materna Information & Communications (AGe/TS)
+//
+//---------------------------------------------------------------------------
+
+screen& screen::list(char *pszName, char* pszFile)
+{
+    aMap data, Member;
+    lError= 0;
+    if (get(ValueName[ID_RTF]).getTag() != OBJ_MAP)
+    {
+      lError= INVALID_DATA;
+      trace(_HERE_7, "screen::list(%s, %s), INVALID_DATA", pszName, pszFile);
+    }
+    else
+    {
+      data.set(TPL, pszFile);
+      Member= get(ValueName[ID_RTF]).mapObject();
+      Member.set(pszName, data);
+      set(ValueName[ID_RTF], Member);
+      CurrentListId= pszName;
+    }
+    return(*this);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   screen& list(long lIndex, char *pszFile)
+//
+//  purpose:    Creates a new list item for previously created list
+//
+//  date:       05.09.2001, 13:28
+//
+//  author:     Materna Information & Communications (AGe/TS)
+//
+//---------------------------------------------------------------------------
+
+screen& screen::list(long lIndex, char *pszFile)
+{
+    aMap Member, List, Data;
+    lError= 0;
+    if (lIndex <= 0)
+    {
+      lError= INVALID_PARAM;
+      trace(_HERE_7, "screen::list(%d, %s), INVALID_PARAM", lIndex, pszFile);
+    }
+    else if (get(ValueName[ID_RTF]).getTag() != OBJ_MAP)
+    {
+      lError= INVALID_DATA;
+      trace(_HERE_7, "screen::list(%d, %s), INVALID_DATA", lIndex, pszFile);
+    }
+    else if (CurrentListId.getTag() != OBJ_STR)
+    {
+      lError= INVALID_DATA;
+      trace(_HERE_7, "screen::list(%d, %s), INVALID_DATA", lIndex, pszFile);
+    }
+    else
+    {
+      Member= get(ValueName[ID_RTF]).mapObject();
+      if (Member.get(CurrentListId).getTag() != OBJ_MAP)
+      {
+        lError= INVALID_DATA;
+        trace(_HERE_7, "screen::list(%d, %s), INVALID_DATA", lIndex, pszFile);
+      }
+      else
+      {
+        List= Member.get(CurrentListId).mapObject();
+        Data.set(TPL, pszFile);
+        List.set(lIndex, Data);
+        Member.set(CurrentListId, List);
+        set(ValueName[ID_RTF], Member);
+      }
+    }
+    return(*this);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   screen& list(long lIndex, aMap& data);
+//
+//  purpose:    Creates a new list item for previously created list
+//
+//  date:       05.09.2001, 13:28
+//
+//  author:     Materna Information & Communications (AGe/TS)
+//
+//---------------------------------------------------------------------------
+
+screen& screen::list(long lIndex, aMap& data)
+{
+    aMap Member, List;
+    lError= 0;
+    if (lIndex <= 0)
+    {
+      lError= INVALID_PARAM;
+      trace(_HERE_7, "screen::list(%d, data), INVALID_PARAM", lIndex);
+    }
+    else if (get(ValueName[ID_RTF]).getTag() != OBJ_MAP)
+    {
+      lError= INVALID_DATA;
+      trace(_HERE_7, "screen::list(%d, data), INVALID_DATA", lIndex);
+    }
+    else if (CurrentListId.getTag() != OBJ_STR)
+    {
+      lError= INVALID_DATA;
+      trace(_HERE_7, "screen::list(%d, data), INVALID_DATA", lIndex);
+    }
+    else
+    {
+      Member= get(ValueName[ID_RTF]).mapObject();
+      if (Member.get(CurrentListId).getTag() != OBJ_MAP)
+      {
+        lError= INVALID_DATA;
+        trace(_HERE_7, "screen::list(%d, data), INVALID_DATA", lIndex);
+      }
+      else
+      {
+        List= Member.get(CurrentListId).mapObject();
+        List.set(lIndex, data);
+        Member.set(CurrentListId, List);
+        set(ValueName[ID_RTF], Member);
+      }
+    }
+    return(*this);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   screen& list(long lIndex, char *pszFile, aMap& data);
+//
+//  purpose:    Creates a new list item for previously created list
+//
+//  date:       05.09.2001, 13:28
+//
+//  author:     Materna Information & Communications (AGe/TS)
+//
+//---------------------------------------------------------------------------
+
+screen& screen::list(long lIndex, char *pszFile, aMap& data)
+{
+    aMap Member, List;
+    lError= 0;
+    if (lIndex <= 0)
+    {
+      lError= INVALID_PARAM;
+      trace(_HERE_7, "screen::list(%d, %s, data), INVALID_PARAM", lIndex, pszFile);
+    }
+    else if (get(ValueName[ID_RTF]).getTag() != OBJ_MAP)
+    {
+      lError= INVALID_DATA;
+      trace(_HERE_7, "screen::list(%d, %s, data), INVALID_DATA", lIndex, pszFile);
+    }
+    else if (CurrentListId.getTag() != OBJ_STR)
+    {
+      lError= INVALID_DATA;
+      trace(_HERE_7, "screen::list(%d, %s, data), INVALID_DATA", lIndex, pszFile);
+    }
+    else
+    {
+      Member= get(ValueName[ID_RTF]).mapObject();
+      if (Member.get(CurrentListId).getTag() != OBJ_MAP)
+      {
+        lError= INVALID_DATA;
+        trace(_HERE_7, "screen::list(%d, %s, data), INVALID_DATA", lIndex, pszFile);
+      }
+      else
+      {
+        List= Member.get(CurrentListId).mapObject();
+        data.set(TPL, pszFile);
+        List.set(lIndex, data);
+        Member.set(CurrentListId, List);
+        set(ValueName[ID_RTF], Member);
+      }
+    }
+    return(*this);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   const char *screen::id()
+//
+//  purpose:    return the screen identifier
+//
+//  date:       24.10.2002, 11:55
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+const char *screen::id()
+{
+    return(get(ValueName[ID_SCREEN]).strObject());
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   screen::screenId(char *pszId)
+//
+//  purpose:    set/reset the screen id
+//
+//  date:       21.09.2001, 12:39
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+screen& screen::screenId(char *pszId)
+{
+    lError = 0;
+    set(ValueName[ID_SCREEN], pszId);
+    return(*this);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   Encoding screen::encoding()
+//
+//  purpose:    Returns the current screen encoding
+//
+//  date:       23.03.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+screen::Encoding screen::encoding()
+{
+   if(get(ValueName[ID_ENCODING]).getTag() == OBJ_NUM)
+   {
+    return Encoding(get(ValueName[ID_ENCODING]).numObject());
+   }
+   else
+   {
+     return ENCODING_NO;
+   }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   screen::screenEncoding(Encoding enc)
+//
+//  purpose:    set/reset the screen encoding
+//
+//  date:       23.03.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+screen& screen::screenEncoding(Encoding enc)
+{
+    lError = 0;
+    set(ValueName[ID_ENCODING], enc);
+    return(*this);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   screen(char *pszId, Encoding enc);
+//
+//  purpose:    class constructor
+//
+//  date:       05.09.2001, 13:28
+//
+//  author:     Materna Information & Communications (AGe/TS)
+//
+//---------------------------------------------------------------------------
+
+screen::screen(char *pszId, Encoding enc)
+{
+    lError = 0;
+    if (count() > 0)
+      lError= ID_ALREADY_SET;    // Id already set
+    else
+    {
+      set(ValueName[ID_SCREEN], pszId);
+      set(ValueName[ID_RTF], aMap());
+      set(ValueName[ID_DATA], aMap());
+      set(ValueName[ID_ENCODING], enc);
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   screen(Encoding enc);
+//
+//  purpose:    class constructor
+//
+//  date:       05.09.2001, 13:28
+//
+//  author:     Materna Information & Communications (AGe/TS)
+//
+//---------------------------------------------------------------------------
+
+screen::screen(Encoding enc)
+{
+    lError = 0;
+    if (count() > 0)
+      lError= ID_ALREADY_SET;    // Id already set
+    else
+    {
+      set(ValueName[ID_SCREEN], (char*)0);
+      set(ValueName[ID_RTF], aMap());
+      set(ValueName[ID_DATA], aMap());
+      set(ValueName[ID_ENCODING], enc);
+    }
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   screen& screen::data(long lIndex, char *pszData)
+//
+//  purpose:    Set an entry in the list of data
+//
+//  date:       19.09.2001
+//
+//  author:     Materna Information & Communications (TS)
+//
+//---------------------------------------------------------------------------
+
+screen& screen::data(long lIndex, char *pszData)
+{
+    aMap data;
+    lError= 0;
+    if (lIndex <= 0)
+    {
+      lError= INVALID_PARAM;
+      trace(_HERE_7, "screen::data(%d, %s), INVALID_PARAM", lIndex, pszData);
+    }
+    else if (get(ValueName[ID_DATA]).getTag() != OBJ_MAP)
+    {
+      lError= INVALID_DATA;
+      trace(_HERE_7, "screen::data(%d, %s), INVALID_DATA", lIndex, pszData);
+    }
+    else
+    {
+      data= get(ValueName[ID_DATA]).mapObject();
+      data.set(lIndex, pszData);
+      set(ValueName[ID_DATA], data);
+    }
+    return (*this);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   screen& screen::data(char *pszData)
+//
+//  purpose:    add an entry to the list of data
+//
+//  date:       19.09.2001
+//
+//  author:     Materna Information & Communications (TS)
+//
+//---------------------------------------------------------------------------
+
+screen& screen::data(char *pszData)
+{
+    aMap data;
+    lError= 0;
+    if (get(ValueName[ID_DATA]).getTag() != OBJ_MAP)
+    {
+      lError= INVALID_DATA;
+      trace(_HERE_7, "screen::data(%s), INVALID_DATA", pszData);
+    }
+    else
+    {
+      data= get(ValueName[ID_DATA]).mapObject();
+      data.set(data.count()+1, pszData);
+      set(ValueName[ID_DATA], data);
+    }
+    return (*this);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   screen& screen::data(long lIndex, long lData)
+//
+//  purpose:    Set an entry in the list of data
+//
+//  date:       19.09.2001
+//
+//  author:     Materna Information & Communications (TS)
+//
+//---------------------------------------------------------------------------
+
+screen& screen::data(long lIndex, long lData)
+{
+    aMap data;
+    lError= 0;
+    if (lIndex <= 0)
+    {
+      lError= INVALID_PARAM;
+      trace(_HERE_7, "screen::data(%d, %d), INVALID_PARAM", lIndex, lData);
+    }
+    else if (get(ValueName[ID_DATA]).getTag() != OBJ_MAP)
+    {
+      lError= INVALID_DATA;
+      trace(_HERE_7, "screen::data(%d, %d), INVALID_DATA", lIndex, lData);
+    }
+    else
+    {
+      data= get(ValueName[ID_DATA]).mapObject();
+      data.set(lIndex, lData);
+      set(ValueName[ID_DATA], data);
+    }
+    return (*this);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   screen& screen::data(long lData)
+//
+//  purpose:    Add an entry to the list of data
+//
+//  date:       19.09.2001
+//
+//  author:     Materna Information & Communications (TS)
+//
+//---------------------------------------------------------------------------
+
+screen& screen::data(long lData)
+{
+    aMap data;
+    lError= 0;
+    if (get(ValueName[ID_DATA]).getTag() != OBJ_MAP)
+    {
+      lError= INVALID_DATA;
+      trace(_HERE_7, "screen::data(%d), INVALID_DATA", lData);
+    }
+    else
+    {
+      data= get(ValueName[ID_DATA]).mapObject();
+      data.set(data.count()+1, lData);
+      set(ValueName[ID_DATA], data);
+    }
+    return (*this);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   screen& screen::data(aMap data)
+//
+//  purpose:    Overwrite the list of data
+//
+//  date:       19.09.2001
+//
+//  author:     Materna Information & Communications (TS)
+//
+//---------------------------------------------------------------------------
+
+screen& screen::data(aMap data)
+{
+    lError= 0;
+    set(ValueName[ID_DATA], data);
+    return (*this);
+}
+
+
+
+/**
+ **************************************************************************
+ *
+ * End of file
+ *
+ **************************************************************************
+**/
+
+
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/dispXTRA.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/dispXTRA.cpp
new file mode 100644
index 00000000..cb944d4a
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/dispXTRA.cpp
@@ -0,0 +1,397 @@
+//---------------------------------------------------------------------------
+//
+//  file:       dispXTRA.cpp
+//
+//  purpose:    dispXTRA device implementation
+//
+//  date:       14.09.00
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//  22.01.2007 SteT 27095: im CussIF den Parameter Timeout fr die Funktion showDisplay hinzufgen
+//---------------------------------------------------------------------------
+
+#include "cussif.h"
+#include "dispdev.h"
+#include "tracedef.h"
+
+using namespace MASSAI;
+
+//---------------------------------------------------------------------------
+//
+//  function:   static char *cleanUpStrValue(char *pszValue)
+//
+//  purpose:    remove unnecessary characters from string
+//
+//  date:       19.04.2001, 14:31
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+static char *cleanUpStrValue(char *pszValue)
+{
+char *pStr;
+
+    if(pszValue && *pszValue)
+    {
+      pStr = pszValue + strlen(pszValue) -1;
+
+      while(*pStr && pStr != pszValue && (*pStr <= ' ' || *pStr == '~'))
+      {
+        *pStr = '\0';
+         pStr --;
+      }
+    }
+
+    return(pszValue);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void displayXTRA::indication(const dspReturnTyp& dr)
+//
+//  purpose:    call back function
+//
+//  date:       12.04.2001, 14:41
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void displayXTRA::indication(const dspReturnTyp& dr)
+{
+dspReturnTyp ldr = dr;
+
+    displayInput((char *)ldr.sid.in(),
+                         ldr.languageId,
+                         ldr.error,
+                         ldr.lValue,
+                 (char *)ldr.sButton.in(),
+                 (char *)ldr.strValue.in());
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void displayXTRA::displayInput(char *pszScreenId,
+//
+//  purpose:    handler function
+//
+//  date:       12.04.2001, 14:41
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void displayXTRA::displayInput(char *pszScreenId,
+                               long  languageId,
+                               long  lError,
+                               long  lValue,
+                               char *pszButton,
+                               char *pszValue)
+{
+    trace(_HERE_7, "displayXTRA::ScreenId    : %s\n",
+                "displayXTRA::ButtonId    : %s\n",
+                "displayXTRA::LanguageId  : %d\n",
+                "displayXTRA::Error       : %d\n",
+                "displayXTRA::Num. Value  : %d\n",
+                "displayXTRA::Alnum. Value: %s\n",
+                 pszScreenId,
+                 pszButton,
+                 languageId,
+                 lError,
+                 lValue,
+                 pszValue);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long displayXTRA::showDisplay(char *pszScreenId,
+//
+//  purpose:    request a screen (base function)
+//
+//  date:       12.04.2001, 14:41
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long displayXTRA::showDisplay(char *pszScreenId,
+                              long  lLanguageId,
+                              char *pszInstructionId,
+                              char *pszButtons,
+                              char *pszStringValue,
+                              long lTimeout)
+{
+displayTyp dt;
+
+    dt.languageId    = lLanguageId;
+    dt.timeout       = 120;
+    dt.sid           = string_dup(pszScreenId);
+    dt.instructionId = string_dup(pszInstructionId);
+    dt.buttons       = string_dup(pszButtons);
+
+    dt.strValue      = string_dup(cleanUpStrValue(pszStringValue));
+
+    reqDisplay(&dt, lTimeout);
+
+    return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long displayXTRA::showDisplay(char *pszScreenId, long lLanguageId, char *pszStringValue, long lTimeout)
+//
+//  purpose:    request a screen
+//
+//  date:       12.04.2001, 14:41
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long displayXTRA::showDisplay(char *pszScreenId, long lLanguageId, char *pszStringValue, long lTimeout)
+{
+    return(showDisplay(pszScreenId, lLanguageId, "", "", pszStringValue, lTimeout));
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long displayXTRA::showDisplay(char *pszScreenId, char *pszStringValue, long lTimeout)
+//
+//  purpose:    request a screen
+//
+//  date:       12.04.2001, 14:42
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long displayXTRA::showDisplay(char *pszScreenId, char *pszStringValue, long lTimeout)
+{
+    return(showDisplay(pszScreenId, 0, "", "", pszStringValue, lTimeout));
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long displayXTRA::showDisplay(char *pszScreenId, long lTimeout)
+//
+//  purpose:    request a screen
+//
+//  date:       12.04.2001, 14:42
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long displayXTRA::showDisplay(char *pszScreenId, long lTimeout)
+{
+    return(showDisplay(pszScreenId, 0, "", "", "", lTimeout));
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   displayXTRA::resolution displayXTRA::currentResolution()
+//
+//  purpose:    returns the current resolution on the kiosk
+//
+//  date:       19.06.2002, 12:28
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+displayXTRA::resolution displayXTRA::currentResolution()
+{
+displayXTRA::resolution res;
+
+    if(vcDisplay.isConnected())
+    {
+      switch(vcDisplay.getCurrentResolution())
+      {
+      case 800:  res = RES_800x600;   break;
+      case 1024: res = RES_1024x768;  break;
+      case 1280: res = RES_1280x1024; break;
+      case 1600: res = RES_1600x1200; break;
+
+      default: res = RES_ERROR;       break;
+      }
+
+      return(res);
+    }
+    else
+      return(RES_ERROR);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool displayXTRA::supportsResolution(resolution res)
+//
+//  purpose:    Check if given resolution is supported
+//
+//  date:       19.06.2002, 12:28
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+bool displayXTRA::supportsResolution(resolution res)
+{
+bool fFound = false;
+long lRes   = 0;
+
+    if(rl.ptr())
+    {
+      switch(res)
+      {
+      case RES_800x600  : lRes = 800;  break;
+      case RES_1024x768 : lRes = 1024; break;
+      case RES_1280x1024: lRes = 1280; break;
+      case RES_1600x1200: lRes = 1600; break;
+      }
+
+      for(unsigned int i = 0; i < rl->length() && !fFound; i++)
+      {
+        if(rl[i] == lRes)
+          fFound = true;
+      }
+
+      return(fFound);
+    }
+    else
+      return(false);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool displayXTRA::supportsMultipleResolutions()
+//
+//  purpose:    Chgeck if kiosk supports more than one resolution
+//
+//  date:       19.06.2002, 12:28
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+bool displayXTRA::supportsMultipleResolutions()
+{
+    if(rl.ptr() && rl->length() > 1)
+      return(true);
+    else
+      return(false);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long displayXTRA::switchResolution(resolution newRes)
+//
+//  purpose:    switch display resolution on the kiosk
+//
+//  date:       19.06.2002, 12:29
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long displayXTRA::switchResolution(resolution newRes)
+{
+long lRes;
+
+    if(vcDisplay.isConnected())
+    {
+       switch(newRes)
+       {
+       case RES_800x600:   lRes = 800;  break;
+       case RES_1024x768:  lRes = 1024; break;
+       case RES_1280x1024: lRes = 1280; break;
+       case RES_1600x1200: lRes = 1600; break;
+
+       default: return(-1); break;
+       }
+       return vcDisplay.setScreenResolution(lRes);
+    }
+    else
+      return(missingComponent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void displayXTRA::displayCallback (const Event& ev, int id)
+//
+//  purpose:    prevents applications from implementing this handler
+//
+//  date:       24.06.2002, 13:50
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void displayXTRA::displayCallback (const Event& ev, int id)
+{
+    return;
+}
+
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   displayXTRA::displayXTRA(amInterface *pAmi, char *pszIOR)
+//
+//  purpose:    class constructor
+//
+//  date:       12.04.2001, 14:42
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+displayXTRA::displayXTRA(char *pszIOR, amInterface *pAmi):
+  vCompDisplay(pAmi),
+  vcDisplay(static_cast<vCompDisplay*>(this)),
+  displayClient(pAmi, pszIOR)
+{
+long             lIndex;
+
+    rl        = NULL;
+    try
+    {
+      if(pAmi)
+      {
+        if(pAmi->queryRealComponent("TouchScreen"))
+        {
+          realComponent= "TouchScreen";
+          trace(_HERE_7, "use realcomponent: TouchScreen");
+
+          lIndex = 0;
+          vcDisplay.storeIOR(pAmi->ior(lIndex, "TouchScreen", "Display"));
+        }
+
+        strcpy(vCompDisplay::szAppRef, pAmi->getAppReference());
+
+#ifdef SUPERUSER
+
+        strcpy(vCompDisplay::szAppRef, "moorhuhn");
+
+#endif
+      }
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+    }
+
+    vcDisplay.connect();
+    vcDisplay.setListener();
+
+    if(vcDisplay.isConnected())
+    {
+      rl= vcDisplay.getDisplayResolution();
+
+      for(unsigned int i = 0; i < rl->length(); i++)
+        trace(_HERE_7, "Display::Resolution[%d] = %d", i, rl[i]);
+
+      trace(_HERE_7, "Display::currentResolution = %d", vcDisplay.getCurrentResolution());
+      trace(_HERE_7, "Display::screenDiagonal = %d mm", vcDisplay.getScreenDiagonal());
+    }
+}
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/dispclnt.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/dispclnt.cpp
new file mode 100644
index 00000000..4e476174
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/dispclnt.cpp
@@ -0,0 +1,507 @@
+//---------------------------------------------------------------------------
+//
+//  file:       dispclnt.cpp
+//
+//  purpose:    display client
+//
+//  date:       26.10.99, 11:17
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//  30.07.2001 ts void reqDisplay(aMap& screen) added
+//  20.09.2004 ts void reqDisplay(aMap& screen, bool xml= false) parameter xml added
+//                     uses xml for sending the data structure
+//  22.01.2007 SteT 27095: im CussIF den Parameter Timeout fr die Funktion showDisplay hinzufgen
+//
+//---------------------------------------------------------------------------
+
+#include "corbaclnt.h"
+
+#include "dispclnt.h"
+#include "tracedef.h"
+
+#include "massai.hpp"
+#include "mThread.hpp"
+
+//  30.07.2001 ts void reqDisplay(aMap& screen) added
+#include "asso.h"
+#include "assostream.h"
+#include "orbs.h"
+//  20.09.2004 ts void reqDisplay(aMap& screen, bool xml= false) parameter xml added
+//                     uses xml for sending the data structure
+#include "XMLScreen.h"
+#include "cussif.h"
+
+
+#define STATUS_REQUEST "statusRequest_23_"
+
+// private definition for the screen indication  handler
+
+class indicationServer: public POA_mDisplay::IndicationListener
+{
+private:
+
+    displayClient *pDisplayClient;
+
+    void indication(const dspReturnTyp& dr)
+    {
+        if(pDisplayClient) {
+          if(strcmp(dr.sid.in(), STATUS_REQUEST) == 0)
+          {
+            pDisplayClient->statusCallback(dr);
+          }
+          else
+          {
+            pDisplayClient->indication(dr);
+          }
+        }
+    }
+
+public:
+
+    void setDisplayClient(displayClient *p) { pDisplayClient = p; }
+
+    indicationServer()
+    {
+      pDisplayClient = NULL;
+    }
+};
+
+//---------------------------------------------------------------------------
+//
+//  function:   void displayClient::reqDone()
+//
+//  purpose:    call the servant
+//
+//  date:       07.12.00, 13:50
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void displayClient::reqDone()
+{
+    if(pScreen)
+    {
+       try
+       {
+         pScreen->done();
+       }
+       catch(CORBA::SystemException& ex)
+       {
+         trace(_HERE_1, "CORBA::SystemException: %s", ex._message());
+       }
+    }
+    return;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void displayClient::reqDisplay(display_dspTyp* pdt, long lTimeout)
+//
+//  purpose:    call the servant
+//
+//  date:       05.11.99, 17:12
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void displayClient::reqDisplay(displayTyp* pdt, long lTimeout)
+{
+bool fDone;
+long i;
+long rc;
+
+    if(pScreen)
+    {
+      DWORD startTime= GetTickCount();
+
+      for(i = 0, fDone = false; (i < 2) && !fDone && !fAbort; i++)
+      {
+        if(lTimeout >= 0)
+        {
+          if(lTimeout - (GetTickCount() - startTime) < 0)
+          {
+            break;
+          }
+        }
+        try
+        {
+          /* rc = */
+          pScreen->nextDisplay(*pdt);
+          /*
+          if (rc == mDisplay::RC_LISTENER)
+          {
+            // set the listener again
+            trace(_HERE_1, "setIndicationListener again");
+            pScreen->setIndicationListener(pIndicationServer->_this());
+          }
+          */
+
+          fDone        = true;
+          fReconnected = false;
+        }
+        catch(CORBA::SystemException& ex)
+        {
+          if(!fReconnected)
+          {
+            trace(_HERE_1, "CORBA::SystemException: %s", ex._message());
+
+            long connectTimeout= lTimeout;
+            if(lTimeout >= 0)
+            {
+              connectTimeout= lTimeout - (GetTickCount() - startTime);
+              if(connectTimeout < 0)
+              {
+                connectTimeout= 0;
+              }
+            }
+            rc = connect(true, connectTimeout);
+
+            // don't try another re-connect !!
+
+            fReconnected = true;
+          }
+        }
+      }
+    }
+    fAbort= false;
+    return;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void displayClient::abort()
+//
+//  purpose:    abort pending calls of reqDisplay and connect
+//
+//  date:       05.07.2007
+//
+//  author:     MATERNA Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+void displayClient::abort()
+{
+  fAbort= true;
+}
+//---------------------------------------------------------------------------
+//
+//  function:   void displayClient::reqDisplay(const aMap& screen, bool xml, long lTimeout)
+//
+//  purpose:    call the servant
+//
+//  date:       30.07.2001
+//
+//  author:     MATERNA Information & Communications (TS)
+//
+//---------------------------------------------------------------------------
+
+void displayClient::reqDisplay(const aMap& screen, bool xml, long lTimeout)
+{
+bool fDone;
+long i;
+long rc;
+
+    if(pScreen)
+    {
+      if(xml)
+      {
+        //  20.09.2004 ts void reqDisplay(aMap& screen, bool xml= false) parameter xml added
+        //                     uses xml for sending the data structure
+
+        std::string xmlstream;
+
+        convertScreenToXML(screen, xmlstream);
+
+        trace(_HERE_8, "reqDisplayXML = %s", xmlstream.c_str());
+
+        DWORD startTime= GetTickCount();
+
+        for(i = 0, fDone = false; i < 2 && !fDone && !fAbort; i++)
+        {
+          if(lTimeout >= 0)
+          {
+            if(lTimeout - (GetTickCount() - startTime) < 0)
+            {
+              break;
+            }
+          }
+          try
+          {
+            /* rc = */
+            pScreen->nextDisplayXML(string_dup(xmlstream.c_str()));
+            /*
+            if (rc == mDisplay::RC_LISTENER)
+            {
+              // set the listener again
+              trace(_HERE_1, "setIndicationListener again");
+              pScreen->setIndicationListener(pIndicationServer->_this());
+            }
+            */
+
+            fDone        = true;
+            fReconnected = false;
+          }
+          catch(CORBA::SystemException& ex)
+          {
+            if(!fReconnected)
+            {
+              trace(_HERE_1, "CORBA::SystemException: %s", ex._message());
+
+              long connectTimeout= lTimeout;
+              if(lTimeout >= 0)
+              {
+                connectTimeout= lTimeout - (GetTickCount() - startTime);
+                if(connectTimeout < 0)
+                {
+                  connectTimeout= 0;
+                }
+              }
+              rc = connect(true, connectTimeout);
+
+              // don't try another re-connect !!
+
+              fReconnected = true;
+            }
+          }
+        }
+      }
+      else
+      {
+        mDisplay::datastream ds;
+
+        trace(_HERE_1, "reqDisplay");
+
+        DWORD startTime= GetTickCount();
+
+        if(AssoToStream<mDisplay::datastream>(ds, screen) != 0)
+          trace(_HERE_7, "reqDisplay convert error");
+
+        for(i = 0, fDone = false; i < 2 && !fDone && !fAbort; i++)
+        {
+          if(lTimeout >= 0)
+          {
+            if(lTimeout - (GetTickCount() - startTime) < 0)
+            {
+              break;
+            }
+          }
+          try
+          {
+            /* rc = */
+            pScreen->nextDisplayDS(ds);
+            /*
+            if (rc == mDisplay::RC_LISTENER)
+            {
+              // set the listener again
+              trace(_HERE_1, "setIndicationListener again");
+              pScreen->setIndicationListener(pIndicationServer->_this());
+            }
+            */
+
+            fDone        = true;
+            fReconnected = false;
+          }
+          catch(CORBA::SystemException& ex)
+          {
+            if(!fReconnected)
+            {
+              trace(_HERE_1, "CORBA::SystemException: %s", ex._message());
+
+              long connectTimeout= lTimeout;
+              if(lTimeout >= 0)
+              {
+                connectTimeout= lTimeout - (GetTickCount() - startTime);
+                if(connectTimeout < 0)
+                {
+                  connectTimeout= 0;
+                }
+              }
+              rc = connect(true, connectTimeout);
+
+              // don't try another re-connect !!
+
+              fReconnected = true;
+            }
+          }
+        }
+      }
+    }
+    fAbort= false;
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long displayClient::connect(bool fReconnect, long lTimeout)
+ *
+ *  @brief     Connect/Re-connect display servant
+ *
+ *  @date      22.10.2005
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long displayClient::connect(bool fReconnect, long lTimeout)
+{
+long  rc = -1;
+int   i;
+bool  fDone;
+
+    DWORD startTime= GetTickCount();
+
+    if(fReconnect)
+    {
+      if(pIndicationServer) delete pIndicationServer;
+      if(cclnt)             delete cclnt;
+
+      trace(_HERE_1, "re-connecting display client...");
+    }
+
+    for(i = 0, fDone = false; i < 30 && !fDone && !fAbort; i++)
+    {
+      if(lTimeout >= 0)
+      {
+        if(lTimeout - (GetTickCount() - startTime) < 0)
+        {
+          break;
+        }
+      }
+      try
+      {
+        trace(_HERE_7, "display IOR = %s", szIOR);
+
+        cclnt = new MASSAI::corbaCallbackClientTerminator<Screen> (pAmi, szIOR);
+
+        pScreen = cclnt->proxy();
+
+        // everything OK ??
+
+        if(pScreen)
+        {
+          pIndicationServer = new indicationServer;
+
+          if(pIndicationServer)
+          {
+            pIndicationServer->setDisplayClient(this);
+
+            // set the listener
+
+            pScreen->setIndicationListener(pIndicationServer->_this());
+          }
+
+          fDone = true;
+          rc    = 0;
+        }
+        else
+          trace(_HERE_7, "screen service not connected");
+      }
+      catch(CORBA::SystemException& ex)
+      {
+        trace(_HERE_1, "CORBA::SystemException: %s", ex._message());
+
+        OS_Sleep(1000);
+      }
+    }
+
+    return(rc);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   displayClient::displayClient(char *pszIOR)
+//
+//  purpose:    class constructor
+//
+//  date:       06.09.00
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+displayClient::displayClient(MASSAI::amInterface* pAmi, char *pszIOR):
+  pAmi(pAmi)
+{
+long rc;
+
+    pScreen      = NULL;
+    cclnt        = NULL;
+    fReconnected = false;
+    fAbort       = false;
+
+    strcpy(szIOR, pszIOR);
+    _strlwr(szIOR);
+
+    if(strstr(szIOR, "corbaloc:") != szIOR && strstr(szIOR, "ior:") != szIOR)
+    {
+      // IP address/name only ?? -> build corbaloc ior
+
+      sprintf(szIOR, "corbaloc::%s:60000/MassaiDisplay", pszIOR);
+    }
+    else
+      strcpy(szIOR, pszIOR);
+
+    rc = connect();
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   displayClient::~displayClient()
+//
+//  purpose:    class destructor
+//
+//  date:       28.10.99, 17:10
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+displayClient::~displayClient()
+{
+    if(pIndicationServer) delete pIndicationServer;
+    if(cclnt)             delete cclnt;
+}
+
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   int displayClient::status()
+//
+//  purpose:    send status request to display
+//
+//---------------------------------------------------------------------------
+int displayClient::status()
+{
+  int result= -1;
+  displayTyp request;
+  request.sid= STATUS_REQUEST;
+
+  if(pScreen)
+  {
+    try
+    {
+      pScreen->nextDisplay(request);
+      result= 0;
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      trace(_HERE_1, "status request to display failed: (%s)", ex._message());
+    }
+  }
+  return result;
+}
+//---------------------------------------------------------------------------
+//
+//  function:   void displayClient::statusCallback()
+//
+//  purpose:    status response from display
+//
+//---------------------------------------------------------------------------
+void displayClient::statusCallback(const dspReturnTyp& dr)
+{
+  trace(_HERE_7, "statusCallback from display");
+}
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/displayTest.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/displayTest.cpp
new file mode 100644
index 00000000..e568ecfa
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/displayTest.cpp
@@ -0,0 +1,114 @@
+//---------------------------------------------------------------------------
+//
+//  file:       DisplayTest.cpp
+//
+//  purpose:    driver test
+//
+//---------------------------------------------------------------------------
+
+#include "systools/Console.h"
+#include "cussif/dispdev.h"
+#include "tools/stringbuffer.h"
+#include "tracedef.h"
+
+
+
+namespace
+{
+  class displayTest: public MASSAI::displayXTRA
+  {
+    public:
+      displayTest(char *pszIOR):
+        displayXTRA(pszIOR)
+      {}
+
+
+      /** This handler is called upon data reception from the screen.
+          @param pszScreenId - The name of the screen
+          @param languageId - The current language for that screen
+          @param lError - Error value, if <> 0
+          @param lValue - Numerical value
+          @param pszButton - The name of the button that nhas been touched
+          @param pszValue - Alpha-numerical value
+      */
+
+      virtual void displayInput(char *pszScreenId,
+                                long  languageId,
+                                long  lError,
+                                long  lValue,
+                                char *pszButton,
+                                char *pszValue)
+      {
+        std::cout << "displayInput: "
+                  << "screen: (" << pszScreenId << "),"
+                  << "language: (" << languageId << "),"
+                  << "error: (" << lError << "),"
+                  << "value: (" << lValue << "),"
+                  << "button: (" << pszButton << "),"
+                  << "value: (" << pszValue << ")" << std::endl;
+
+      }
+  };
+
+  displayTest* testClient;
+
+  class ShowDisplay: public Console::SelectionCommandBase
+  {
+    public:
+      Console::ResultCode execute(char selector, int parameter, const Console::Strings& parameterList)
+      {
+        Console::ResultCode rc= Console::RC_FAILED;
+        if(parameterList.size() > 0)
+        {
+          MASSAI::text::StringBuffer buf(parameterList[0]);
+          std::cout << testClient->showDisplay(buf.data());
+          rc= Console::RC_SUCCESS;
+        }
+        return rc;
+      }
+  };
+
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   int main( int argc, char ** argv )
+//
+//  purpose:    main.
+//
+//  date:       get user input
+//
+//  author:     Dr. Materna GmbH (PtM)
+//
+//---------------------------------------------------------------------------
+
+int main( int argc, char ** argv )
+{
+  setLevel(9);
+  const char* ior = (argc > 1) ? argv[1] : "corbaloc:iiop:localhost:20098/CLA_Display";
+  MASSAI::text::StringBuffer buf(ior);
+  std::cout << "IOR: (" << ior << ")" << std::endl;
+  testClient= new displayTest(buf.data());
+
+  Console::ConsoleSelection selection;
+  selection.addSimple(&selection, "h",     "help", Console::ConsoleSelection::P_HELP);
+  selection.addSimple(&selection, "q\x03", "quit", Console::ConsoleSelection::P_QUIT);
+  ShowDisplay showDisplay;
+  Console::Selection showDisplayInput=
+    {&showDisplay, "s", "show display",
+      {Console::IT_INPUT, "enter screen id"}};
+  selection.add(showDisplayInput);
+
+  selection.loop();
+
+  delete testClient;
+
+  return 0;
+}
+
+//-------------------------------------------------------------------------
+//
+// End of file
+//
+//-------------------------------------------------------------------------
+
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/escrow.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/escrow.cpp
new file mode 100644
index 00000000..bf86c48f
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/escrow.cpp
@@ -0,0 +1,870 @@
+//---------------------------------------------------------------------------
+//
+//  file:       escrow.cpp
+//
+//  purpose:    escrow device implementation
+//
+//  date:       12.09.00, 12:12
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include "cussif.h"
+#include "escrowdev.h"
+#include "check.h"
+#include "tracedef.h"
+#include "orbs.h"
+
+#include "textIDL/textcodes.h"
+#include "textIDL/texttypes.h"
+#include "textIDL/textcharacteristics.h"
+
+using namespace MASSAI::codes_text;
+using namespace MASSAI::characteristics_text;
+using namespace MASSAI::types_text;
+
+//#define SUPERUSER  // uses "moohuhn" token
+
+#define NSCD Characteristics::Dispenser
+
+using namespace MASSAI;
+
+static bool fEscrowAvailable = false;
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool escrowAvailable()
+//
+//  purpose:    Access for ATB2 device implemetation
+//
+//  date:       26.08.2002, 08:54
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+bool escrowAvailable()
+{
+    return(fEscrowAvailable);
+}
+
+/** Returns bin size of the dispenser */
+
+long escrowDevice::dispenserBinSize()
+{
+  long result= 0;
+  if(vcDispenser.isConnected())
+  {
+    result= vcDispenser.getBinSize();
+  }
+  else
+  {
+    trace(_HERE_7, "vcDispenser not connected");
+  }
+  return result;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   escrowDevice::long open(long lTimeOut)
+//
+//  purpose:    opens Escrow device for coupon removal
+//
+//  date:       12.09.00, 10:33
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long escrowDevice::open(long lTimeOut, Event_out ev)
+{
+  long rc = 0;
+  long rc1 = 0;
+  Event_var ev1;
+
+  if(vcDispenser.isConnected())
+  {
+    // enable before offer
+    if((rc1 = vcDispenser.enable(0, ev1)) != 0)
+    {
+      trace(_HERE_7, "error enabling escrow, rc = (%s) (%d)", rcString(rc1).c_str(), rc1);
+      return rc1;
+    }
+    else
+      trace(_HERE_7, "enabling escrow, rc = (%s) (%d)", rcString(rc1).c_str(), rc1);
+
+    if((rc = vcDispenser.offer(lTimeOut, ev)) != 0)
+      trace(_HERE_7, "error offering escrow, rc = (%s) (%d)", rcString(rc).c_str(), rc);
+      //return(rc);
+    else
+      trace(_HERE_7, "offering escrow, rc = (%s) (%d)", rcString(rc).c_str(), rc);
+      //return(checkStatusCode(ev));
+
+    // disable after offer
+    if(lTimeOut >= 0  || rc != m_returncodes::RC_OK)
+    {
+      if((rc1 = vcDispenser.disable(0, ev1)) != 0)
+        trace(_HERE_7, "error disabling escrow, rc = (%s) (%d)", rcString(rc1).c_str(), rc1);
+      else
+        trace(_HERE_7, "disabling escrow, rc = (%s) (%d)", rcString(rc1).c_str(), rc1);
+    }
+
+    if((rc != 0) || (lTimeOut < 0))
+      return rc;
+    else
+      return checkStatusCode(ev);
+  }
+  else
+    return missingComponent;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   escrowDevice::long close(long lTimeOut)
+//
+//  purpose:    closes Escrow device
+//
+//  date:       12.09.00, 10:35
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long escrowDevice::close(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcDispenser.isConnected())
+    {
+      // cancel all pending commands first !!
+
+      if((rc = vcDispenser.cancel(ev)) != 0)
+      //if((rc = vcDispenser.component->disable(lTimeOut, string_dup(vCompDispenser::szAppRef), ev)) != 0)
+        return(rc);
+      else
+        return(checkStatusCode(ev));
+    }
+    else
+      return(missingComponent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long escrowDevice::cancel(long lTimeOut)
+//
+//  purpose:    cancel the last command
+//
+//  date:       17.11.2005
+//
+//  author:     Dr. Materna GmbH (TS)
+//
+//---------------------------------------------------------------------------
+
+long escrowDevice::cancel(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcDispenser.isConnected() || vcCapture.isConnected())
+    {
+      if(vcCapture.isConnected())
+        rc = vcCapture.cancel(ev);
+      if(vcDispenser.isConnected())
+        rc = vcDispenser.cancel(ev);
+      return(rc);
+    }
+    else
+      return(missingComponent);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   escrowDevice::long retract(long lTimeOut)
+//
+//  purpose:    retract the coupon(s) in the device
+//
+//  date:       12.09.00, 10:35
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long escrowDevice::retract(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcCapture.isConnected())
+    {
+      rc = close();
+
+      if(((rc = vcCapture.retain(lTimeOut, ev)) != 0) || (lTimeOut < 0))
+        return(rc);
+      else
+        return(checkStatusCode(ev));
+    }
+    else
+      return(missingComponent);
+}
+
+void escrowDevice::callback(CallbackComponent component, const types::Event& ev, int id)
+{
+  switch(component)
+  {
+    case CC_CAPTURE:
+      process_captureCallback(ev, id);
+      break;
+    case CC_DISPENSER:
+      process_dispenserCallback(ev, id);
+      break;
+  }
+}
+void escrowDevice::captureCallback(const Event& ev, int id)
+{
+  enqueue(CC_CAPTURE, ev, id);
+}
+void escrowDevice::dispenserCallback(const Event& ev, int id)
+{
+  enqueue(CC_DISPENSER, ev, id);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   void escrowDevice::process_captureCallback(const Event &ev, int id)
+//
+//  purpose:    Check events sent by the component here
+//
+//  date:       29.11.00, 15:07
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void escrowDevice::process_captureCallback(const Event &ev, int id)
+{
+    //0.1 strcpy(vCompCapture::sz3LCode, ev.machineLocationCode);
+    //0.1 strcpy(vCompCapture::szID, ev.machineIdentifier);
+
+    vCompCapture::lError = ev.statusCode;
+
+    trace(_HERE_1, "Capture (%d); event code: (%s) (%d), status code: (%s) (%d) for %s", id, eventCodesText(ev.eventCode).c_str(), ev.eventCode, scString(ev.statusCode).c_str(), ev.statusCode, ev.functionName.in());
+
+    if(!*ev.functionName && ev.statusCode == m_statuscodes::OK)
+    {
+      // unsolicited event ??
+      if(!eventReceived(ev))
+        handleException(ev.eventCode, ev.statusCode, ev.functionName.in());
+    }
+    else if(!eventReceived(ev))
+    {
+      switch(ev.statusCode)
+      {
+      case m_statuscodes::OK:         couponsRetracted(); break;
+
+      case m_statuscodes::TIMEOUT:    commandTimeout(); break;
+      case m_statuscodes::CANCELLED:  commandCancelled(); break;
+      default:                        handleException(ev.eventCode, ev.statusCode, ev.functionName.in()); break;
+      }
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void escrowDevice::process_dispenserCallback(const Event &ev, int id)
+//
+//  purpose:    Check events sent by the component here
+//
+//  date:       29.11.00, 15:07
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void escrowDevice::process_dispenserCallback(const Event &ev, int id)
+{
+    //0.1 strcpy(vCompDispenser::sz3LCode, ev.machineLocationCode);
+    //0.1 strcpy(vCompDispenser::szID, ev.machineIdentifier);
+
+    vCompDispenser::lError = ev.statusCode;
+
+    trace(_HERE_1, "Dispenser (%d); event code: (%s) (%d), status code: (%s) (%d) for %s", id, eventCodesText(ev.eventCode).c_str(), ev.eventCode, scString(ev.statusCode).c_str(), ev.statusCode, ev.functionName.in());
+
+    if(*ev.functionName && strcmp(ev.functionName.in(), "offer") == 0)
+    {
+      try
+      {
+        Event_var ev1;
+        vcDispenser.disable(0, ev1);
+      }
+      catch(CORBA::SystemException& ex)
+      {
+        trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+      }
+      catch(...)
+      {
+        trace(_HERE_1, "... exception occured");
+      }
+    }
+
+    if(!*ev.functionName && ev.statusCode == m_statuscodes::OK)
+    {
+      // unsolicited event ??
+      if(!eventReceived(ev))
+        handleException(ev.eventCode, ev.statusCode, ev.functionName.in());
+    }
+    else if(!eventReceived(ev))
+    {
+      switch(ev.statusCode)
+      {
+      case m_statuscodes::OK:         couponsRemoved(); break;
+
+      case m_statuscodes::TIMEOUT:    commandTimeout(); break;
+      case m_statuscodes::CANCELLED:  commandCancelled(); break;
+      default:                        handleException(ev.eventCode, ev.statusCode, ev.functionName.in()); break;
+      }
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool escrowDevice::isEmpty()
+//
+//  purpose:    returns TRUE is there are no coupons in the device
+//
+//  date:       12.09.00, 13:08
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+bool escrowDevice::isEmpty()
+{
+    return(fIsEmpty);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void escrowDevice::couponsRemoved()
+//
+//  purpose:    called when coupons have been removed
+//              can be overwritten by application
+//
+//  date:       12.09.00, 13:09
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void escrowDevice::couponsRemoved()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void escrowDevice::couponsRetracted()
+//
+//  purpose:    called when coupons have been retracted
+//              can be overwritten by application
+//
+//  date:       12.09.00, 13:09
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void escrowDevice::couponsRetracted()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void escrowDevice::commandTimeout()
+//
+//  purpose:    called if command timeout has occurred
+//
+//  date:       21.02.01, 10:35
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void escrowDevice::commandTimeout()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void escrowDevice::commandCancelled()
+//
+//  purpose:    calles if command has been cancelled
+//
+//  date:       21.02.01, 10:35
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void escrowDevice::commandCancelled()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void escrowDevice::handleException(long eventCode,
+//                                              long statusCode,
+//                                              const char *pszFunction)
+//
+//  purpose:    called if an unhandled status code (error) has been received
+//
+//  date:       21.02.01, 10:36
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void escrowDevice::handleException(long eventCode, long statusCode, const char *pszFunction)
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool escrowDevice::eventReceived(long eventCode,
+//                                            long statusCode,
+//                                            const char *pszFunction)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+bool escrowDevice::eventReceived (const Event& ev)
+{
+  return eventReceived(ev.eventCode, ev.statusCode, ev.functionName.in());
+}
+bool escrowDevice::eventReceived(long eventCode, long statusCode, const char *pszFunction)
+{
+    return(false);
+}
+
+
+long escrowDevice::error()
+{
+  return vCompDispenser::error();
+}
+
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long escrowDevice::status(comptype ct)
+ *
+ *  @brief     query status on specific virtual component
+ *
+ *  @date      20.10.2004
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long escrowDevice::status(comptype ct, Event_out ev)
+{
+  return status(BLOCK_, ct, ev);
+}
+long escrowDevice::status(long lTimeout, comptype ct, Event_out ev)
+{
+long      rc = missingComponent;
+
+    try
+    {
+      switch(ct)
+      {
+      case vCompCapture::capture:
+
+           if(vcCapture.isConnected())
+           {
+             if((rc = vcCapture.query(lTimeout, ev)) == 0 && (lTimeout >= 0))
+               rc = ev->statusCode;
+           }
+           break;
+
+      case vCompDispenser::dispenser:
+
+           if(vcDispenser.isConnected())
+           {
+             if((rc = vcDispenser.query(lTimeout, ev)) == 0 && (lTimeout >= 0))
+               rc = ev->statusCode;
+           }
+           break;
+      }
+    }
+    catch(...) {}
+
+    trace(_HERE_7, "status query result: %s, rc = %d", scString(rc).c_str(), rc);
+
+    return(rc);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   escrowDevice::escrowDevice(amInterface  *pAmi)
+//
+//  purpose:    class constructor, aquires the virtual component
+//
+//  date:       12.09.00, 10:36
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+escrowDevice::escrowDevice(amInterface  *pAmi):
+  vCompDispenser(pAmi),
+  vCompCapture  (pAmi),
+  vcDispenser(static_cast<vCompDispenser*>(this)),
+  vcCapture(static_cast<vCompCapture*>(this))
+{
+long             lIndex;
+
+    fIsEmpty = true;
+
+    try
+    {
+      // try to connect all virtual components
+      // an ESCROW device can't have MediaInput or MediaOutput attached !!!
+
+      if(pAmi->queryRealComponent("ATB2DeviceWithEscrow"))
+      {
+        // first option for Escrow components
+        realComponent= "ATB2DeviceWithEscrow";
+        trace(_HERE_7, "use realcomponent: ATB2DeviceWithEscrow");
+
+        lIndex = 0;
+        vcDispenser.storeIOR(pAmi->iorInclude(lIndex, "ATB2DeviceWithEscrow", "Capture", Characteristics::Dispenser::real_));
+
+        lIndex = 0;
+        vcCapture.storeIOR(pAmi->ior(lIndex, "ATB2DeviceWithEscrow", "Capture"));
+      }
+      else
+      {
+        // second option for Escrow components
+        realComponent= "BoardingPassDispenserBin";
+        trace(_HERE_7, "use realcomponent: BoardingPassDispenserBin");
+
+        lIndex = 0;
+        vcDispenser.storeIOR(pAmi->iorInclude(lIndex, "BoardingPassDispenserBin", "Capture", Characteristics::Dispenser::real_));
+
+        lIndex = 0;
+        vcCapture.storeIOR(pAmi->ior(lIndex, "BoardingPassCaptureBin", "Capture"));
+      }
+
+      strcpy(vCompDispenser::szAppRef, pAmi->getAppReference());
+      strcpy(vCompCapture::szAppRef,  pAmi->getAppReference());
+
+#ifdef SUPERUSER
+
+      strcpy(vCompDispenser::szAppRef, "moorhuhn");
+      strcpy(vCompCapture::szAppRef,  "moorhuhn");
+
+#endif
+
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+    }
+
+    init();
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   escrowDevice::escrowDevice(amInterface  *pAmi, vManufacturer& component)
+//
+//  purpose:    class constructor, aquires the virtual component
+//
+//  date:       23.10.06
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+escrowDevice::escrowDevice(amInterface  *pAmi, vManufacturer& component):
+  vCompDispenser(pAmi),
+  vCompCapture  (pAmi),
+  vcDispenser(static_cast<vCompDispenser*>(this)),
+  vcCapture(static_cast<vCompCapture*>(this))
+{
+long             lIndex;
+
+    fIsEmpty = true;
+
+    try
+    {
+      if(pAmi->queryRealComponent(component.realComponentName()))
+      {
+        realComponent= component.realComponentName();
+        trace(_HERE_7, "use realcomponent: %s", component.realComponentName());
+
+        lIndex = 0;
+        vcDispenser.storeIOR(pAmi->iorInclude(lIndex, component.realComponentName(), "Capture", Characteristics::Dispenser::real_));
+        if(vcDispenser.canConnect())
+        {
+          long lStartIndex = 0;
+          vcCapture.storeIOR(pAmi->iorLinked(lIndex, lStartIndex, "Capture"));
+        }
+        else
+        {
+          lIndex= 0;
+          vcDispenser.storeIOR(pAmi->iorInclude(lIndex, component.realComponentName(), "Dispenser", Characteristics::Dispenser::real_));
+          if(!vcDispenser.canConnect())
+          {
+            lIndex= 0;
+            vcDispenser.storeIOR(pAmi->iorInclude(lIndex, component.realComponentName(), "MediaOutput", Characteristics::Dispenser::real_));
+          /* SteT EDB 27096 +>
+            long lFirstDispenserIndex= 0;
+            pAmi->iorInclude(lFirstDispenserIndex, component.realComponentName(), "Dispenser", "MediaOutput");
+            long lStartIndex= 0;
+            const char* ior= 0;
+            while((ior= pAmi->iorLinked(lFirstDispenserIndex, lStartIndex, "Dispenser")) != 0)
+            {
+              EnvironmentComponents_var ec(pAmi->getComponents());
+              CORBA::ULong lDispenserIdx= lFirstDispenserIndex;
+              lIndex= ec[lDispenserIdx].linkedComponents[lStartIndex];
+              long lSecondStartIndex= 0;
+              // and the second Dispenser is not the dispenser of the MediaInput => escrow dispenser
+              if(pAmi->iorLinked(lIndex, lSecondStartIndex, "MediaInput") == 0)
+              {
+                vcDispenser.storeIOR(ior);
+                break;
+              }
+              lStartIndex++;
+            }
+            SteT EDB 27096 <+ */
+          }
+          /* SteT EDB 27096 +>
+          if(vcDispenser.ior.size() == 0)
+          {
+            lIndex = 0;
+            long lFirstDispenserIndex= 0;
+            if(pAmi->iorInclude(lFirstDispenserIndex, component.realComponentName(), "Dispenser", "MediaInput"))
+            {
+              long lStartIndex= 0;
+              vcDispenser.storeIOR(pAmi->iorLinked(lFirstDispenserIndex, lStartIndex, Characteristics::Dispenser::real_));
+              if(vcDispenser.canConnect())
+              {
+                EnvironmentComponents_var ec(pAmi->getComponents());
+                CORBA::ULong lDispenserIdx= lFirstDispenserIndex;
+                lIndex= ec[lDispenserIdx].linkedComponents[lStartIndex];
+              }
+            }
+          }
+            SteT EDB 27096 <+ */
+        }
+      }
+
+      strcpy(vCompDispenser::szAppRef, pAmi->getAppReference());
+      strcpy(vCompCapture::szAppRef,  pAmi->getAppReference());
+
+#ifdef SUPERUSER
+
+      strcpy(vCompDispenser::szAppRef, "moorhuhn");
+      strcpy(vCompCapture::szAppRef,  "moorhuhn");
+
+#endif
+
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+    }
+
+    init();
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   escrowDevice::escrowDevice(amInterface  *pAmi, vManufacturer& component)
+//
+//  purpose:    class constructor, aquires the virtual component
+//
+//  date:       23.10.06
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+escrowDevice::escrowDevice(amInterface  *pAmi, vManufacturer& component, MASSAI::vComponent::comptype comp):
+  vCompDispenser(pAmi),
+  vCompCapture  (pAmi),
+  vcDispenser(static_cast<vCompDispenser*>(this)),
+  vcCapture(static_cast<vCompCapture*>(this))
+{
+long             lIndex;
+
+    fIsEmpty = true;
+
+    try
+    {
+      if(pAmi->queryRealComponent(component.realComponentName()))
+      {
+        realComponent= component.realComponentName();
+        trace(_HERE_7, "use realcomponent: %s", component.realComponentName());
+
+        switch(comp)
+        {
+          case MASSAI::vComponent::writer:
+          {
+            lIndex= 0;
+            vcDispenser.storeIOR(pAmi->iorInclude(lIndex, component.realComponentName(), "MediaOutput", Characteristics::Dispenser::real_));
+
+          /* SteT EDB 27096 +>
+            if(vcDispenser.ior.size() == 0)
+            {
+              long lFirstDispenserIndex= 0;
+              pAmi->iorInclude(lFirstDispenserIndex, component.realComponentName(), "Dispenser", "MediaOutput");
+              long lStartIndex= 0;
+              const char* ior= 0;
+              while((ior= pAmi->iorLinked(lFirstDispenserIndex, lStartIndex, "Dispenser")) != 0)
+              {
+                EnvironmentComponents_var ec(pAmi->getComponents());
+                CORBA::ULong lDispenserIdx= lFirstDispenserIndex;
+                lIndex= ec[lDispenserIdx].linkedComponents[lStartIndex];
+                long lSecondStartIndex= 0;
+                // and the second Dispenser is not the dispenser of the MediaInput => escrow dispenser
+                if(pAmi->iorLinked(lIndex, lSecondStartIndex, "MediaInput") == 0)
+                {
+                  vcDispenser.storeIOR(ior);
+                  break;
+                }
+                lStartIndex++;
+              }
+            }
+             SteT EDB 27096 <+ */
+            break;
+          }
+          case MASSAI::vComponent::capture:
+          {
+            lIndex = 0;
+            vcDispenser.storeIOR(pAmi->iorInclude(lIndex, component.realComponentName(), "Capture", Characteristics::Dispenser::real_));
+            break;
+          }
+          // SteT EDB 27096: ->
+          case MASSAI::vComponent::dispenser:
+          {
+            lIndex= 0;
+            vcDispenser.storeIOR(pAmi->iorInclude(lIndex, component.realComponentName(), "Dispenser", Characteristics::Dispenser::real_));
+            break;
+          }
+          // SteT EDB 27096: <-
+        /* SteT EDB 27096 +>
+          case MASSAI::vComponent::reader:
+          {
+            lIndex = 0;
+            long lFirstDispenserIndex= 0;
+            if(pAmi->iorInclude(lFirstDispenserIndex, component.realComponentName(), "Dispenser", "MediaInput"))
+            {
+              long lStartIndex= 0;
+              vcDispenser.storeIOR(pAmi->iorLinked(lFirstDispenserIndex, lStartIndex, Characteristics::Dispenser::real_));
+              if(vcDispenser.canConnect())
+              {
+                EnvironmentComponents_var ec(pAmi->getComponents());
+                CORBA::ULong lDispenserIdx= lFirstDispenserIndex;
+                lIndex= ec[lDispenserIdx].linkedComponents[lStartIndex];
+              }
+            }
+            break;
+          }
+           SteT EDB 27096 <+ */
+        }
+        if(vcDispenser.canConnect())
+        {
+          long lStartIndex = 0;
+          vcCapture.storeIOR(pAmi->iorLinked(lIndex, lStartIndex, "Capture"));
+        }
+      }
+
+      strcpy(vCompDispenser::szAppRef, pAmi->getAppReference());
+      strcpy(vCompCapture::szAppRef,  pAmi->getAppReference());
+
+#ifdef SUPERUSER
+
+      strcpy(vCompDispenser::szAppRef, "moorhuhn");
+      strcpy(vCompCapture::szAppRef,  "moorhuhn");
+
+#endif
+
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+    }
+
+    init();
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   escrowDevice::escrowDevice(amInterface  *pAmi, vManufacture& component)
+//
+//  purpose:    acquires the virtual component
+//
+//  date:       23.10.06
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+void escrowDevice::init()
+{
+    startProcessing();
+    vcDispenser.connect();
+    vcDispenser.setListener();
+    vcCapture.connect();
+    vcCapture.setListener();
+
+    trace(_HERE_7, "ESCROW Characteristics:");
+
+    if(vcDispenser.isConnected())
+    {
+      trace(_HERE_7, "ESCROW:Dispenser:Type                = %s", (vcDispenser.getKind() == NSCD::real_) ? "real" : "virtual");
+      trace(_HERE_7, "ESCROW:Dispenser:almostFullLevel     = %d", vcDispenser.getAllmostFullLevel());
+      trace(_HERE_7, "ESCROW:Dispenser:almostEmptyLevel    = %d", vcDispenser.getAllmostEmptyLevel());
+      trace(_HERE_7, "ESCROW:Dispenser:BinSize             = %d", vcDispenser.getBinSize());
+      trace(_HERE_7, "ESCROW:Dispenser:currentNumberOfDocs = %d", vcDispenser.getCurrentNoOfDocuments());
+    }
+    else
+      trace(_HERE_7, "ESCROW:Dispenser not connected.");
+
+    if(vcCapture.isConnected())
+    {
+      trace(_HERE_7, "ESCROW:Capture:almostFullLevel       = %d", vcCapture.getAllmostFullLevel());
+      trace(_HERE_7, "ESCROW:Capture:almostEmptyLevel      = %d", vcCapture.getAllmostEmptyLevel());
+      trace(_HERE_7, "ESCROW:Capture:BinSize               = %d", vcCapture.getBinSize());
+      trace(_HERE_7, "ESCROW:Capture:currentNumberOfDocs   = %d", vcCapture.getCurrentNoOfDocuments());
+    }
+    else
+      trace(_HERE_7, "ESCROW:Capture not connected.");
+
+    if(vcDispenser.isConnected() && vcCapture.isConnected())
+      fEscrowAvailable = true;
+    else
+      fEscrowAvailable = false;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   escrowDevice::~escrowDevice()
+//
+//  purpose:    class destructor, releases the device
+//
+//  date:       12.09.00, 10:39
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+escrowDevice::~escrowDevice()
+{
+  vcDispenser.clearListener();
+  vcCapture.clearListener();
+}
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/fpr.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/fpr.cpp
new file mode 100644
index 00000000..651816b3
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/fpr.cpp
@@ -0,0 +1,421 @@
+/**
+ *  @file      fpr.cpp
+ *
+ *  @brief     fingerprint reader device implementation
+ *
+ *  @author    Materna Information & Communications
+ *
+ ************************************************************************/
+
+#include "cussif.h"
+#include "fprdev.h"
+#include "check.h"
+#include "tracedef.h"
+#include "orbs.h"
+
+#include "textIDL/textcodes.h"
+#include "textIDL/texttypes.h"
+#include "textIDL/textcharacteristics.h"
+
+using namespace MASSAI::codes_text;
+using namespace MASSAI::characteristics_text;
+using namespace MASSAI::types_text;
+
+using namespace MASSAI;
+
+
+// discard old response/indication
+void fprDevice::clearData()
+{
+  image= "";
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void fprDevice::saveData(const datastream ds)
+//
+//  purpose:    save data from MSG data stream
+//
+//  author:     Materna Information & Communications
+//
+//---------------------------------------------------------------------------
+
+void fprDevice::saveData(const datastream ds)
+{
+  msgDataType *pData;
+  ds >>= pData;
+  image= "";
+  if(pData->records.length() >= 1)
+  {
+    image.reserve(pData->records[0].message.length());
+    for(unsigned int i = 0; i < pData->records[0].message.length(); i++)
+    {
+      image.append(1, pData->records[0].message[i]);
+    }
+    trace(_HERE_7, "image length %d", image.size());
+  }
+  else
+  {
+    trace(_HERE_7, "no fpr data stored");
+  }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void fprDevice::readerCallback(const Event &ev, int id)
+//
+//  purpose:    callback function for the reader component
+//
+//  author:     Materna Information & Communications
+//
+//---------------------------------------------------------------------------
+
+void fprDevice::readerCallback(const Event &ev, int id)
+{
+  vCompReader::lError = ev.statusCode;
+
+  trace(_HERE_1, "Reader (%d); event code: (%s) (%d), status code: (%s) (%d) for %s", id, eventCodesText(ev.eventCode).c_str(), ev.eventCode, scString(ev.statusCode).c_str(), ev.statusCode, ev.functionName.in());
+
+  if(!*ev.functionName && ev.statusCode == m_statuscodes::OK)
+  {
+    // unsolicited event ??
+    if(!eventReceived(ev))
+    {
+      handleException(ev.eventCode, ev.statusCode, ev.functionName.in());
+    }
+  }
+  else if(!eventReceived(ev))
+  {
+    switch(ev.statusCode)
+    {
+      case m_statuscodes::OK:                                break;
+      case m_statuscodes::DATA_PRESENT:  dataPresent();      break;
+      case m_statuscodes::TIMEOUT:       commandTimeout();   break;
+      case m_statuscodes::CANCELLED:     commandCancelled(); break;
+      default:                           handleException(ev.eventCode, ev.statusCode, ev.functionName.in()); break;
+    }
+  }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long fprDevice::open(long lTimeOut)
+//
+//  purpose:    enable device for scanning fingerprints
+//
+//  author:     Materna Information & Communications
+//
+//---------------------------------------------------------------------------
+
+long fprDevice::open(long lTimeOut, Event_out ev)
+{
+  clearData();
+  if(vcReader.isConnected())
+  {
+    long rc = vcReader.enable(lTimeOut, ev);
+    if((rc != 0) || (lTimeOut < 0))
+    {
+      trace(_HERE_7, "open fpr: (%s) (%d)", rcString(rc).c_str(), rc);
+      return rc;
+    }
+    else
+    {
+      return checkStatusCode(ev);
+    }
+  }
+  else
+  {
+    return missingComponent;
+  }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long fprDevice::close(long lTimeOut)
+//
+//  purpose:    disable device
+//
+//  author:     Materna Information & Communications
+//
+//---------------------------------------------------------------------------
+
+long fprDevice::close(long lTimeOut, Event_out ev)
+{
+  if(vcReader.isConnected())
+  {
+    long rc = vcReader.disable(lTimeOut, ev);
+    if((rc != 0) || (lTimeOut < 0))
+    {
+      return rc;
+    }
+    else
+    {
+      return checkStatusCode(ev);
+    }
+  }
+  else
+  {
+    return missingComponent;
+  }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long fprDevice::cancel(long lTimeOut)
+//
+//  purpose:    cancel the last command (read or eject)
+//
+//  author:     Materna Information & Communications
+//
+//---------------------------------------------------------------------------
+
+long fprDevice::cancel(long lTimeOut, Event_out ev)
+{
+  if(vcReader.isConnected())
+  {
+    long rc = vcReader.cancel(ev);
+    return rc;
+  }
+  else
+  {
+    return missingComponent;
+  }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long fprDevice::read(long lTimeOut)
+//
+//  purpose:    read data from vitual component
+//
+//  author:     Materna Information & Communications
+//
+//---------------------------------------------------------------------------
+
+long fprDevice::read(long lTimeOut, Event_out ev)
+{
+  if(vcReader.isConnected())
+  {
+    long rc = vcReader.receive(lTimeOut, ev);
+    if((rc != 0) || (lTimeOut < 0))
+    {
+      trace(_HERE_7, "receive() for fingerprint data, rc = (%s) (%d)", rcString(rc).c_str(), rc);
+      return rc;
+    }
+    else
+    {
+      // handle returned data directly if synchronous call !!
+      TypeCode_ptr tcp = ev->eventData.type();
+      if(tcp->equivalent(_tc_msgDataType))
+      {
+        trace(_HERE_7, "received msgDataType");
+        if(ev->statusCode  == m_statuscodes::OK
+          || ev->statusCode == m_statuscodes::DATA_PRESENT)
+        {
+          saveData(ev->eventData);
+        }
+        else
+        {
+          if(ev->statusCode  == m_statuscodes::DATA_MISSING)
+          {
+            clearData();
+          }
+          eventReceived(*ev);
+        }
+      }
+      else
+      {
+        trace(_HERE_7, "received invalid DataType");
+      }
+    }
+    return checkStatusCode(ev);
+  }
+  else
+  {
+    return missingComponent;
+  }
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   std::string fprDevice::getImage()
+//
+//  purpose:    get the image data, use read(...) to read the image
+//
+//  author:     Materna Information & Communications
+//
+//---------------------------------------------------------------------------
+
+std::string fprDevice::getImage()
+{
+  return image;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void fprDevice::dataPresent()
+//
+//  purpose:    called upon fingerprint data presence (virtual)
+//
+//  author:     Materna Information & Communications
+//
+//---------------------------------------------------------------------------
+
+void fprDevice::dataPresent() {}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   void fprDevice::commandTimeout()
+//
+//  purpose:    called if command timeout has occurred
+//
+//  author:     Materna Information & Communications
+//
+//---------------------------------------------------------------------------
+
+void fprDevice::commandTimeout() {}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void fprDevice::commandCancelled()
+//
+//  purpose:    called if command has been cancelled
+//
+//  author:     Materna Information & Communications
+//
+//---------------------------------------------------------------------------
+
+void fprDevice::commandCancelled() {}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void fprDevice::handleException(long eventCode,
+//                                              long statusCode,
+//                                              const char *pszFunction)
+//
+//  purpose:    called if an unhandled status code (error) has been received
+//
+//  author:     Materna Information & Communications
+//
+//---------------------------------------------------------------------------
+
+void fprDevice::handleException(long eventCode, long statusCode, const char *pszFunction) {}
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool fprDevice::eventReceived(long eventCode,
+//                                            long statusCode,
+//                                            const char *pszFunction)
+//
+//  purpose:
+//
+//  author:     Materna Information & Communications
+//
+//---------------------------------------------------------------------------
+
+bool fprDevice::eventReceived (const Event& ev)
+{
+  return eventReceived(ev.eventCode, ev.statusCode, ev.functionName.in());
+}
+bool fprDevice::eventReceived(long eventCode, long statusCode, const char *pszFunction)
+{
+  return false;
+}
+
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long fprDevice::status(comptype ct)
+ *
+ *  @brief     query status on specific virtual component
+ *
+ *  @author    Materna Information & Communications
+ */
+//------------------------------------------------------------------------
+
+long fprDevice::status(comptype ct, Event_out ev)
+{
+  return status(BLOCK_, ct, ev);
+}
+
+long fprDevice::status(long lTimeout, comptype ct, Event_out ev)
+{
+  long rc = missingComponent;
+  try
+  {
+    switch(ct)
+    {
+      case vCompReader::reader:
+      {
+        if(vcReader.isConnected())
+        {
+          rc = vcReader.query(lTimeout, ev);
+          if((rc == 0) && (lTimeout >= 0))
+          {
+            rc = ev->statusCode;
+          }
+        }
+        break;
+      }
+    }
+  }
+  catch(...) {}
+  trace(_HERE_7, "status query result: %s, rc = %d", scString(rc).c_str(), rc);
+  return rc;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   fprDevice::fprDevice(amInterface *pAmi)
+//
+//  purpose:    class constructor - acquire virtual components
+//
+//  author:     Materna Information & Communications
+//
+//---------------------------------------------------------------------------
+
+fprDevice::fprDevice(amInterface *pAmi):
+  vCompReader(pAmi),
+  vcReader(static_cast<vCompReader*>(this))
+{
+  try
+  {
+    // try to connect all virtual components
+    long lIndex = 0;
+    vcReader.storeIOR(pAmi->ior(lIndex, "FingerprintReader", "UserInput"));
+    if(vcReader.canConnect())
+    {
+      realComponent= "FingerprintReader";
+      trace(_HERE_7, "use realcomponent: FingerprintReader");
+    }
+    else
+    {
+      // No Characteristic to identify FingerprintReader
+    }
+    strcpy(vCompReader::szAppRef, pAmi->getAppReference());
+  }
+  catch(CORBA::SystemException& ex)
+  {
+    trace(_HERE_7, "CORBA::SystemException:\n%s", ex._message());
+  }
+
+  vcReader.connect();
+  vcReader.setListener();
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   fprDevice::~fprDevice()
+//
+//  purpose:    class destructor - release acquired virtual components
+//
+//  author:     Materna Information & Communications
+//
+//---------------------------------------------------------------------------
+
+fprDevice::~fprDevice()
+{
+  vcReader.clearListener();
+}
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/gpp.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/gpp.cpp
new file mode 100644
index 00000000..33f123d6
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/gpp.cpp
@@ -0,0 +1,508 @@
+//---------------------------------------------------------------------------
+//
+//  file:       gppDevice.cpp
+//
+//  purpose:    gp printer device implementation
+//
+//  date:       04.09.2003
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include "cussif.h"
+#include "gppdevice.h"
+#include "check.h"
+#include "tracedef.h"
+#include "orbs.h"
+#include "textIDL/textcodes.h"
+#include "textIDL/texttypes.h"
+#include "textIDL/textcharacteristics.h"
+
+using namespace MASSAI::codes_text;
+using namespace MASSAI::characteristics_text;
+using namespace MASSAI::types_text;
+
+using namespace MASSAI;
+
+void gppDevice::callback(CallbackComponent component, const types::Event& ev, int id)
+{
+  switch(component)
+  {
+    case CC_WRITER:
+      process_writerCallback(ev, id);
+      break;
+  }
+}
+void gppDevice::writerCallback(const Event& ev, int id)
+{
+  enqueue(CC_WRITER, ev, id);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void gppDevice::process_writerCallback(const Event &ev, int id)
+//
+//  purpose:
+//
+//  date:       04.09.2003
+//
+//  author:     Dr. Materna GmbH (PtM)
+//
+//---------------------------------------------------------------------------
+
+void gppDevice::process_writerCallback(const Event &ev, int id)
+{
+    //0.1 strcpy(vCompWriter::sz3LCode, ev.machineLocationCode);
+    //0.1 strcpy(vCompWriter::szID, ev.machineIdentifier);
+
+    vCompWriter::lError = ev.statusCode;
+
+    trace(_HERE_1, "Writer (%d); event code: (%s) (%d), status code: (%s) (%d) for %s", id, eventCodesText(ev.eventCode).c_str(), ev.eventCode, scString(ev.statusCode).c_str(), ev.statusCode, ev.functionName.in());
+
+    if(*ev.functionName && strcmp(ev.functionName.in(), "send") == 0)
+    {
+      try
+      {
+        Event_var ev1;
+        vcWriter.disable(0, ev1);
+      }
+      catch(CORBA::SystemException& ex)
+      {
+        trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+      }
+      catch(...)
+      {
+        trace(_HERE_1, "... exception occured");
+      }
+    }
+
+    TypeCode_ptr tcp = ev.eventData.type();
+
+    if(tcp->equivalent(_tc_svgDataType))
+    {
+        saveData(ev.eventData);
+    }
+
+
+      if(!*ev.functionName && ev.statusCode == m_statuscodes::OK)
+      {
+        // unsolicited event ??
+        if(!eventReceived(ev))
+          handleException(ev.eventCode, ev.statusCode, ev.functionName.in());
+      }
+      else if(!eventReceived(ev))
+      {
+
+        switch(ev.statusCode)
+        {
+        case m_statuscodes::OK:
+        case m_statuscodes::MEDIA_PRESENT: dataPrinted(); break;
+
+        case m_statuscodes::TIMEOUT:   commandTimeout(); break;
+        case m_statuscodes::CANCELLED: commandCancelled(); break;
+        default:                       handleException(ev.eventCode, ev.statusCode, ev.functionName.in()); break;
+        }
+    }
+}
+// discard old response/indication
+void gppDevice::clearData()
+{
+  abData[0] = '\0';
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void gppDevice::saveData(const datastream ds)
+//
+//  purpose:    save data from SVG data stream
+//
+//  date:       04.09.2003
+//
+//  author:     Dr. Materna GmbH (PtM)
+//
+//---------------------------------------------------------------------------
+
+void gppDevice::saveData(const datastream ds)
+{
+    svgDataType *pData;
+
+    ds >>= pData;
+
+    if(pData)
+    {
+	     unsigned int i;
+      for(i = 0; i < pData->length(); i++)
+        abData[i] = (*pData)[i];
+
+      abData[i] = '\0';
+    }
+    return;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long gppDevice::write(long lTimeOut, char *pszData, long lLen)
+//
+//  purpose:
+//
+//  date:       04.09.2003
+//
+//  author:     Dr. Materna GmbH (PtM)
+//
+//---------------------------------------------------------------------------
+
+long gppDevice::write(long lTimeOut, char *pszData, long lLen, Event_out ev)
+{
+long        rc  = 0;
+long        rc1 = 0;
+long        lLength;
+Event_var   ev1;
+datastream  ds;
+svgDataType svgData;
+
+    // discard old printer response/indication
+    clearData();
+
+    // anything to do??
+    if(!pszData || !*pszData)
+      return(-1);
+
+    // create datastream for gp printer
+
+    if(!lLen)
+      lLength = strlen(pszData);
+    else
+      lLength = lLen;
+
+    svgData.length(lLength);
+
+    for(int i = 0; i < lLength; i++)
+       svgData[i] = *(pszData + i);
+
+    ds <<= svgData;
+    ds.type(types::_tc_svgDataType);
+
+    if(vcWriter.isConnected())
+    {
+        // enable the writer before sending
+
+        if((rc1 = vcWriter.enable(0, ev1)) != 0)
+        {
+          trace(_HERE_1, "error enabling writer, rc = (%s) (%d)", rcString(rc1).c_str(), rc1);
+          return(rc1);
+        }
+
+        // send the normal way
+
+        if((rc = vcWriter.send(lTimeOut, ds, ev)) != 0)
+        {
+          // return immediately !!
+
+          trace(_HERE_1, "sending svg data, rc = (%s) (%d)", rcString(rc).c_str(), rc);
+        }
+
+        // disable the writer after sending
+
+        if(lTimeOut >= 0  || rc != m_returncodes::RC_OK)
+        {
+          if((rc1 = vcWriter.disable(0, ev1)) != 0)
+            trace(_HERE_1, "error disabling writer, rc = (%s) (%d)", rcString(rc1).c_str(), rc1);
+        }
+
+        // return if send returned error !
+
+        if((rc) || (lTimeOut < 0))
+          return(rc);
+
+      // handle returned data directly if synchronous call !!
+
+      TypeCode_ptr tcp = ev->eventData.type();
+
+      if(tcp->equivalent(_tc_svgDataType))
+      {
+        saveData(ev->eventData);
+
+        trace(_HERE_7, "SVG-RSP [%s]", getData());
+      }
+
+      return(checkStatusCode(ev));
+    }
+    else
+      return(missingComponent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long gppDevice::cancel(long lTimeOut)
+//
+//  purpose:    cancel the last command
+//
+//  date:       17.11.2005
+//
+//  author:     Dr. Materna GmbH (TS)
+//
+//---------------------------------------------------------------------------
+
+long gppDevice::cancel(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcWriter.isConnected())
+    {
+      rc = vcWriter.cancel(ev);
+      return(rc);
+    }
+    else
+      return(missingComponent);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   void gppDevice::dataPrinted()
+//
+//  purpose:
+//
+//  date:       04.09.2003
+//
+//  author:     Dr. Materna GmbH (PtM)
+//
+//---------------------------------------------------------------------------
+
+void gppDevice::dataPrinted()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void gppDevice::commandTimeout()
+//
+//  purpose:    called if command timeout has occurred
+//
+//  date:       21.02.01, 10:35
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void gppDevice::commandTimeout()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void gppDevice::commandCancelled()
+//
+//  purpose:    calles if command has been cancelled
+//
+//  date:       21.02.01, 10:35
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void gppDevice::commandCancelled()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void gppDevice::handleException(long eventCode,
+//                                              long statusCode,
+//                                              const char *pszFunction)
+//
+//  purpose:    called if an unhandled status code (error) has been received
+//
+//  date:       21.02.01, 10:36
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void gppDevice::handleException(long eventCode, long statusCode, const char *pszFunction)
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool gppDevice::eventReceived(long eventCode,
+//                                            long statusCode,
+//                                            const char *pszFunction)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+bool gppDevice::eventReceived (const Event& ev)
+{
+  return eventReceived(ev.eventCode, ev.statusCode, ev.functionName.in());
+}
+bool gppDevice::eventReceived(long eventCode, long statusCode, const char *pszFunction)
+{
+    return(false);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   char *gppDevice::getData()
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+char *gppDevice::getData()
+{
+    return(abData);
+}
+
+
+long gppDevice::error()
+{
+  return vCompWriter::error();
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long gppDevice::status(comptype ct)
+ *
+ *  @brief     query status on specific virtual component
+ *
+ *  @date      20.10.2004
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long gppDevice::status(comptype ct, Event_out ev)
+{
+  return status(BLOCK_, ct, ev);
+}
+long gppDevice::status(long lTimeout, comptype ct, Event_out ev)
+{
+long      rc = missingComponent;
+
+    try
+    {
+      switch(ct)
+      {
+      case vCompWriter::writer:
+
+           if(vcWriter.isConnected())
+           {
+             if((rc = vcWriter.query(lTimeout, ev)) == 0 && (lTimeout >= 0))
+               rc = ev->statusCode;
+           }
+           break;
+      }
+    }
+    catch(...) {}
+
+    trace(_HERE_7, "status query result: %s, rc = %d", scString(rc).c_str(), rc);
+
+    return(rc);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   gppDevice::gppDevice(amInterface *pAmi)
+//
+//  purpose:
+//
+//  date:       04.09.2003
+//
+//  author:     Dr. Materna GmbH (PtM)
+//
+//---------------------------------------------------------------------------
+
+gppDevice::gppDevice(amInterface *pAmi):
+  vCompWriter(pAmi),
+  vcWriter(static_cast<vCompWriter*>(this))
+
+{
+    const char      *pszIOR;
+    long             lIndex;
+
+    try
+    {
+      // try to connect all virtual components
+
+      if(pAmi->queryRealComponent("GPPrinter"))
+      {
+        // first option for BTP components
+        realComponent= "GPPrinter";
+        trace(_HERE_7, "use realcomponent: GPPrinter");
+
+        lIndex = 0;
+        vcWriter.storeIOR(pAmi->ior(lIndex, "GPPrinter", "MediaOutput"));
+      }
+      else
+      {
+        // no gpp device found by name, check characteristics
+        const char* pszRealComponent;
+
+        amInterface::MediaTypeSet mediatype;
+        amInterface::DataTypeSet datatype;
+        mediatype.insert(Characteristics::MediaType::Printed);
+        datatype.insert(Characteristics::SVG);
+        lIndex= 0;
+        pszRealComponent= pAmi->queryMediaOutput(lIndex, Characteristics::MediaOutput::GeneralPurposeDoc, mediatype, datatype);
+        if(!pszRealComponent)
+        {
+          datatype.clear();
+          datatype.insert(Characteristics::AEA);
+          lIndex= 0;
+          pszRealComponent= pAmi->queryMediaOutput(lIndex, Characteristics::MediaOutput::GeneralPurposeDoc, mediatype, datatype);
+        }
+        if((pszRealComponent != NULL)
+         && ((pszIOR = pAmi->ior(lIndex, pszRealComponent, "MediaOutput")) != NULL))
+        {
+          realComponent= pszRealComponent;
+          trace(_HERE_7, "use realcomponent: %s", pszRealComponent);
+          vcWriter.storeIOR(pszIOR);
+        }
+      }
+
+      strcpy(vCompWriter::szAppRef, pAmi->getAppReference());
+
+#ifdef SUPERUSER
+
+      strcpy(vCompWriter::szAppRef, "moorhuhn");
+
+#endif
+
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+    }
+
+    startProcessing();
+    vcWriter.connect();
+    vcWriter.setListener();
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   gppDevice::~gppDevice()
+//
+//  purpose:    class destructor
+//
+//  date:       04.09.2003
+//
+//  author:     Dr. Materna GmbH (PtM)
+//
+//---------------------------------------------------------------------------
+
+gppDevice::~gppDevice()
+{
+  vcWriter.clearListener();
+}
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/language.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/language.cpp
new file mode 100644
index 00000000..835a45d8
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/language.cpp
@@ -0,0 +1,224 @@
+//---------------------------------------------------------------------------
+//
+//  file:       language.cpp
+//
+//  purpose:    Language DLL interface implementation
+//
+//  date:       02.04.2001, 12:11
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//  history:
+//  30.07.2001 ts char *resourceFile(char* pszPath) added
+//  05.09.2001 ts loadLanguage doesnt check if the axs dll exist
+//---------------------------------------------------------------------------
+
+#include "language.h"
+#include "tracedef.h"
+#include "version.h"
+
+//---------------------------------------------------------------------------
+//
+//  function:   long language::loadLanguage(long lLanguage, char *pszPath)
+//
+//  purpose:    try to load a new language dll
+//
+//  date:       02.04.2001, 13:29
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long language::loadLanguage(long lLanguage, char *pszPath)
+{
+long rc;
+char szName[1024];
+
+    if(lLanguage != lCurrent || strcmp(pszPath, szCurrent))
+    {
+      if(hModule)
+        OS_FreeModule(hModule);
+
+      if(*pszPath)
+        sprintf(szName, "%s\\lang%04d", pszPath, lLanguage);
+      else
+        sprintf(szName, "lang%04d", lLanguage);
+
+      rc = OS_LoadModule(NULL, 0, szName, &hModule);
+
+//  05.09.2001 ts loadLanguage doesnt check if the axs dll exist
+/*
+      if(!rc)
+      {
+*/
+        lCurrent = lLanguage;
+        strcpy(szCurrent, pszPath);
+/*
+      }
+      else
+      {
+        lCurrent   = 0;
+        *szCurrent = '\0';
+      }
+*/
+      return(rc);
+    }
+    else
+      return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   char *language::resourceText(long id)
+//
+//  purpose:    Try to load a string from a resource dll
+//
+//  date:       02.04.2001, 13:28
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+char *language::resourceText(long id)
+{
+static char szBuffer[2048];
+long rc = -1;
+
+    *szBuffer = '\0';
+
+    if(hModule)
+    {
+      rc = OS_LoadString(hModule, id, szBuffer, sizeof(szBuffer));
+
+      if(rc)
+        sprintf(szBuffer, "String not loaded, rc = %d", rc);
+    }
+    else
+      sprintf(szBuffer, "String not loaded, no resource DLL.");
+
+    return(szBuffer);
+}
+//---------------------------------------------------------------------------
+//
+//  function:   char *language::resourceFile(const char* pszPath, char *pszFullPath)
+//
+//  purpose:    Try to load a string from a file
+//
+//  date:       30.07.2001
+//
+//  author:     Materna Information & Communications (TS/AGe)
+//
+//---------------------------------------------------------------------------
+
+char *language::resourceFile(const char* pszPath, char *pszFullPath)
+{
+char* rc;
+FILE *Tpl;
+size_t count;
+
+    rc= 0;
+
+    if(pszPath)
+    {
+      if(*szCurrent)
+        sprintf(pszFullPath, "%s\\tpl%04d\\%s", szCurrent, lCurrent, pszPath);
+      else
+        sprintf(pszFullPath, "tpl%04d\\%s", lCurrent, pszPath);
+
+      Tpl= fopen(pszFullPath, "rb");
+
+      // AGe: Not found, check above TPL folders ...
+
+      if(!Tpl && *szCurrent)
+      {
+        trace(_HERE_1, "resourceFile: can't open [%s]", pszFullPath);
+
+        sprintf(pszFullPath, "%s\\%s", szCurrent, pszPath);
+
+        trace(_HERE_1, "resourceFile: trying [%s]", pszFullPath);
+
+        Tpl= fopen(pszFullPath, "rb");
+      }
+
+      if(Tpl)
+      {
+        if (fseek(Tpl, 0, SEEK_END) == 0)
+        {
+          count= ftell(Tpl);
+          rc= new char[count+1];
+          fseek(Tpl, 0, SEEK_SET);
+          count= fread(rc, sizeof(rc[0]), count, Tpl);
+          rc[count]= 0;
+          char* versionstring= strstr(rc, "\n#"MAT_VERS_ID);
+          if(versionstring != 0)
+          {
+            versionstring[0]= 0;
+            if(versionstring > rc && versionstring[-1] == 13)
+              versionstring[-1]= 0;
+          }
+        }
+        fclose(Tpl);
+      }
+    }
+
+    return rc;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long language::languageId()
+//
+//  purpose:    returns current language ID
+//
+//  date:       09.04.2001, 12:14
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long language::languageId()
+{
+    return(lCurrent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   language::language(long lLanguage, char *pszPath)
+//
+//  purpose:    class constructor
+//
+//  date:       02.04.2001, 13:28
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+language::language(long lLanguage, char *pszPath)
+{
+    hModule = NULL;
+
+    lCurrent= 0;
+    *szCurrent= 0;
+    if(lLanguage)
+      loadLanguage(lLanguage, pszPath);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   language::~language()
+//
+//  purpose:    class destructor
+//
+//  date:       02.04.2001, 13:28
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+language::~language()
+{
+    if(hModule)
+      OS_FreeModule(hModule);
+
+    hModule = NULL;
+}
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/local_def.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/local_def.cpp
new file mode 100644
index 00000000..db6bee34
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/local_def.cpp
@@ -0,0 +1,211 @@
+#include "versionlib.h"
+
+VERSION_ID_DT(cussif, 1, 0, 0, 66);
+
+/*! \page c++ CussIF - Release Notes
+ *
+ *  \date 08.10.2012 \li V1.0.0.66
+ *                   \li bugfix,      SteT Mantis 0024440: c++cussif: response from event to platform always return success
+ *
+ *  \date 21.08.2012 \li V1.0.0.65
+ *                   \li bugfix,      SteT Mantis 0024310: c++cussif: ppr, mcr: third track is ignored if more than three tracks are found
+ *
+ *  \date 10.07.2012 \li V1.0.0.64
+ *                   \li bugfix,      SteT Mantis 0023901: c++cussif: crash with tracelevel 9
+ *
+ *  \date 26.04.2012 \li V1.0.0.63
+ *                   \li bugfix,      SteT Mantis 0022809: c++-CUSSIF; reset data received by platform
+ *
+ *  \date 28.07.2011 \li V1.0.0.62
+ *                   \li bugfix,      SteT Mantis 0017200: C++-Cussif: Characteristic Cache, trace fixed
+ *
+ *  \date 27.07.2011 \li V1.0.0.61
+ *                   \li bugfix,      VJ Mantis 0019016: application hung, platform did not react
+ *
+ *  \date 27.06.2011 \li V1.0.0.60
+ *                   \li bugfix,      SteT Mantis 0011749: notify may return AL_APPLICATION_REQUEST
+ *
+ *  \date 22.06.2011 \li V1.0.0.59
+ *                   \li enhancement, SteT Mantis 0017200: C++-Cussif: Characteristic Cache
+ *                   \li bugfix,      SteT Mantis 0011673: C++-Cussif: Initialization of characteristics in components query
+ *
+ *  \date 11.04.2011 \li V1.0.0.58
+ *                   \li Mantis 18673: After an exception occurred CallbackThread is stuck in an infinite loop
+ *                   \li  => more traces to improve debugging
+ *
+ *  \date 07.04.2011 \li V1.0.0.57
+ *                   \li Mantis 18600: indication of printer not forwared to application
+ *                   \li  no action of callbackthread => more traces to improve debugging
+ *
+ *  \date 01.03.2011 \li V1.0.0.56
+ *                   \li bugfix, SteT fingerprintreader device added
+ *
+ *  \date 18.01.2011 \li V1.0.0.55
+ *                   \li bugfix, SteT 20110118, escrowDevice has not found a real-Dispenser linked to a MediaOutput
+ *                       extension SteT 20010118, parameter added to bppDevice-Constructor: handlepapertype
+ *                          PH_PAPERTYPE_FROM_DATASTREAM:  scan datastream for paper type (default)
+ *                          PH_PAPERTYPE_FROM_CONSTRUCTOR: use the paper type from constructor
+ *
+ *  \date 23.02.2010 \li V1.0.0.54
+ *                   \li bugfix, SteT 20100223, cpp-cussif, accept AL_APPLICATION_REQUEST for applicationManagerRequests
+ *
+ *  \date 09.02.2010 \li V1.0.0.53
+ *                   \li extension, SteT status request for mdisplay
+ *
+ *  \date 28.10.2009 \li V1.0.0.52
+ *                   \li bugfix, SteT Mantis 11673: add method queryFailedComponents() to amInterface
+ *
+ *  \date 15.10.2009 \li V1.0.0.51
+ *                   \li bugfix, SteT Mantis 11350: synchronization of ApplicationManager-Callbacks
+ *
+ *  \date 15.01.2009 \li V1.0.0.50
+ *                   \li bugfix, SteT Mantis 7398: start pinging before component search
+ *                               SelfServiceCUSS\Interfaces\inc\CussIF\cussif.h changed (private attributes added)
+ *                                      public interface not changed
+ *
+ *  \date 15.01.2009 \li V1.0.0.49
+ *                   \li enhancement, SteT stop polling when terminating
+ *
+ *  \date 08.01.2009 \li V1.0.0.48
+ *                   \li bugfix, SteT use appref for dispenser in btp
+ *
+ *  \date 16.12.2008 \li V1.0.0.47
+ *                   \li extension, SteT add timeout to status requests
+ *
+ *  \date 16.06.2008 \li V1.0.0.46
+ *                   \li bugfix, SteT 20080616, cpp-CussIF, BTP does not find Feeder and Dispenser
+ *
+ *  \date 15.05.2008 \li V1.0.0.45
+ *                   \li bugfix, SteT Invocation Timeout > CUSS Timeout
+ *
+ *  \date 07.04.2008 \li V1.0.0.44
+ *                   \li bugfix, SteT Invocation Timeout > CUSS Timeout
+ *
+ *  \date 27.02.2008 \li V1.0.0.43
+ *                   \li bugfix, SteT EDB 27982: c++-Cussif reset timeout after call
+ *
+ *  \date 26.02.2008 \li V1.0.0.42
+ *                   \li change, implement cussApplication::appState
+ *
+ *  \date 26.02.2008 \li V1.0.0.41
+ *                   \li bugfix, SteT EDB 27881: support branding in SAM
+ *
+ *  \date 25.02.2008 \li V1.0.0.40
+ *                   \li change, SteT EDB 27982: c++-Cussif CORBA-Timeout depends on timeout parameter
+ *
+ *  \date 25.02.2008 \li V1.0.0.39
+ *                   \li change, SteT EDB 28002: cussApplication::disableMe, ... return false in case of error
+ *
+ *  \date 11.12.2007 \li V1.0.0.38
+ *                   \li bugfix, SteT EDB 27957: do not evaluate event after asynchronous call
+ *  \li Testfall: Da die Auswertung bei allen Aufrufe zu allen CUSS-Komponenten gendert wurden, muss ein voller Funktionstest durchgefhrt werden.
+ *
+ *  \date 21.11.2007 \li V1.0.0.37
+ *                   \li bugfix, SteT, Catch possible exceptions in callbackthread (thrown in destructor)
+ *
+ *  \date 03.05.2007 \li V1.0.0.36
+ *                   \li SteT EDB 27871: support btp dispenser
+ *
+ *  \date 03.05.2007 \li V1.0.0.35
+ *                   \li SteT EDB 27881: support branding
+ *
+ *  \date 03.05.2007 \li V1.0.0.34
+ *                   \li SteT EDB 27824: delayed ping caused by high cpu load
+ *
+ *  \date 03.05.2007 \li V1.0.0.33
+ *                   \li SteT EDB 27776: encrypt track data, PCIDSS
+ *
+ *  \date 03.05.2007 \li V1.0.0.32
+ *                   \li SteT EDB 27096: correction of reading escrow linking, wieder rckgngig gemacht
+ *
+ *  \date 05.07.2007 \li V1.0.0.31
+ *                   \li SteT EDB 27637: abortable reqDisplay
+ *
+ *  \date 21.06.2007 \li V1.0.0.30
+ *                   \li SteT EDB 27593: cpp-cussif: saveData for MediaOutput corrected
+ *
+ *  \date 14.06.2007 \li V1.0.0.29
+ *                   \li SteT EDB 27098: ignore version number in resource files
+ *
+ *  \date 05.06.2007 \li V1.0.0.28
+ *                   \li SteT EDB 27542: dont cut ior in trace
+ *
+ *  \date 05.06.2007 \li V1.0.0.27
+ *                   \li SteT EDB 27541: bpp correction, call eventreceived with componentid
+ *
+ *  \date 03.05.2007 \li V1.0.0.26
+ *                   \li SteT EDB 27096: correction of reading escrow linking
+ *
+ *  \date 30.04.2007 \li V1.0.0.25
+ *                   \li SteT EDB 27339: transmit languageid at call nextDisplayDS and nextDisplayXML
+ *
+ *  \date 30.04.2007 \li V1.0.0.24
+ *                   \li SteT EDB 26701: corrected enable/disable for asynchron calls
+ *
+ *  \date 22.01.2007 \li V1.0.0.23
+ *                   \li SteT EDB 27095: add timeout parameter to the function showDisplay
+ *
+ *  \date 04.01.2007 \li V1.0.0.22
+ *                   \li SteT: atbr MEDIA_ABSENT handling added (couponRemoved)
+ *
+ *  \date 11.12.2006 \li V1.0.0.21
+ *                   \li SteT 26927: WRONG_STATE on acquire: call release and acquire again
+ *                   \li SteT traces added here
+ *
+ *  \date 11.12.2006 \li V1.0.0.20
+ *                   \li SteT EDB 26927: WRONG_STATE on acquire: call release and acquire again
+ *                   \li SteT traces added here
+ *
+ *  \date 08.12.2006 \li V1.0.0.19
+ *                   \li SteT EDB 26927: WRONG_STATE on acquire: call release and acquire again
+ *
+ *  \date 27.11.2006 \li V1.0.0.18
+ *                   \li SteT EDB 26865: added Parameter Event to the function eventReceived
+ *
+ *  \date 20.11.2006 \li V1.0.0.17
+ *                   \li SteT EDB 26792: atbReader should not use the MediaInput that is used in bpp
+ *                   \li bug in implementation of isSameDevice fixed
+ *
+ *  \date 08.11.2006 \li V1.0.0.16
+ *                   \li SteT EDB 26792: atbReader should not use the MediaInput that is used in bpp
+ *
+ *  \date 08.11.2006 \li V1.0.0.15
+ *                   \li SteT EDB 26742: function passportRemoved added
+ *
+ *  \date 25.10.2006 \li V1.0.0.14
+ *                   \li SteT EDB 26693: changes from old streams merged to new CC Streams SelfServicePlatform
+ *                   \li bpp returns dispenser bin size
+ *                   \li guess papertype if none found in print command
+ *                       for cp try boarding pass, if not exist try gpp
+ *                       for tk try ticket, if not exist try gpp
+ *                   \li supend-resume-handling added
+ *                   \li timeout for ping client set to 10000 msec
+ *                   \li massaiTrace added in cussApp (SteT merged from MaternAir)
+ *                   \li use comps.tao140.idl (sollte keine Aenderung darstellen)
+ *                   \li bugfix - handle RC_LISTENER from component methods, acquire the component again(SteT)
+ *                   \li bugfix - handle CorbaException, reconnect on CommFailure  (SteT)
+ *
+ *                   \li escrow dispenser is a real dispenser with capture (was a dispenser with dispenser(virtual) and capture)
+ *                   \li escrow can be created from an other component
+ *
+ *  \date 16.10.2006 \li V1.0.0.13
+ *                   \li SteT EDB 26621: Adaption to Emirates IER Test
+ *                   \li escrow can be created from an other component
+ *
+ *  \date 16.10.2006 \li V1.0.0.12
+ *                   \li SteT EDB 26408: initrequest with CORBA-Timeout
+ *
+ *  \date 09.10.2006 \li V1.0.0.11
+ *                   \li SteT EDB 26561: write CussIF-Trace to file
+ *
+ *  \date 09.10.2006 \li V1.0.0.10
+ *                   \li SteT EDB 26560: found passport reader for barcode scanner
+ *
+ *  \date 09.10.2006 \li V1.0.0.9
+ *                   \li SteT EDB 26559: found MagneticCardReader for ChipReader
+ *
+ *  \date 21.09.2006 \li V1.0.0.8
+ *                   \li SteT EDB 26462: change the status of the component for synchronous call, too
+ *
+ */
+
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/magcard.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/magcard.cpp
new file mode 100644
index 00000000..0188cf24
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/magcard.cpp
@@ -0,0 +1,1239 @@
+//---------------------------------------------------------------------------
+//
+//  file:       magcard.cpp
+//
+//  purpose:    magnetic card device implementation
+//
+//  date:       12.09.00, 17:37
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include "cussif.h"
+#include "mcdev.h"
+#include "check.h"
+#include "tracedef.h"
+#include "orbs.h"
+
+#include "textIDL/textcodes.h"
+#include "textIDL/texttypes.h"
+#include "textIDL/textcharacteristics.h"
+
+using namespace MASSAI::codes_text;
+using namespace MASSAI::characteristics_text;
+using namespace MASSAI::types_text;
+
+using namespace MASSAI;
+
+#define NSC_MI Characteristics::MediaInput
+
+namespace
+{
+  Characteristics::MediaType::MediaTypeDef getCardTypeMediaType(magCardDevice::cardtype card)
+  {
+    switch(card)
+    {
+      case magCardDevice::CT_MAGNETICSTRIPE:   return Characteristics::MediaType::MagneticStripe;
+      case magCardDevice::CT_CHIP:             return Characteristics::MediaType::Chip;
+      case magCardDevice::CT_JIS:              return Characteristics::MediaType::JIS;
+      default:                                 return Characteristics::MediaType::MagneticStripe;
+    }
+  }
+  bool contains(Characteristics::MediaTypeListDef_var list, Characteristics::MediaType::MediaTypeDef element)
+  {
+    bool result= false;
+    for(CORBA::ULong i= 0; i < list->length(); ++i)
+    {
+      if(list[i]->type() == element)
+      {
+        result= true;
+      }
+    }
+    return result;
+  }
+
+}
+
+// discard old response/indication
+void magCardDevice::clearData()
+{
+  memset(abTrack1, 0, sizeof(abTrack1));
+  memset(abTrack2, 0, sizeof(abTrack2));
+  memset(abTrack3, 0, sizeof(abTrack3));
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void magCardDevice::saveData(const datastream ds)
+//
+//  purpose:    save data from MSG data stream
+//
+//  date:       15.01.01, 14:20
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void magCardDevice::saveData(const datastream ds)
+{
+msgDataType *pData;
+
+    ds >>= pData;
+
+    memset(abTrack1, 0, sizeof(abTrack1));
+    memset(abTrack2, 0, sizeof(abTrack2));
+    memset(abTrack3, 0, sizeof(abTrack3));
+
+    if(pData->records.length())
+    {
+      unsigned int i;
+      for
+      (
+        i = 0;
+        pData->records.length() >= 1
+          && i < pData->records[0].message.length()
+          && i < sizeof(abTrack1);
+        i++
+      )
+      {
+        abTrack1[i] = pData->records[0].message[i];
+      }
+
+      for
+      (
+        i = 0;
+        pData->records.length() >= 2
+          && i < pData->records[1].message.length()
+          && i < sizeof(abTrack2);
+        i++
+      )
+      {
+        abTrack2[i] = pData->records[1].message[i];
+      }
+
+      for
+      (
+        i = 0;
+        pData->records.length() >= 3
+          && i < pData->records[2].message.length()
+          && i < sizeof(abTrack3);
+        i++
+      )
+      {
+        abTrack3[i] = pData->records[2].message[i];
+      }
+
+      cryptTrace(_HERE_7, abTrack1, strlen(abTrack1));
+      cryptTrace(_HERE_7, abTrack2, strlen(abTrack2));
+      cryptTrace(_HERE_7, abTrack3, strlen(abTrack3));
+    }
+    else
+      trace(_HERE_7, "no card data stored");
+
+    return;
+}
+
+
+void magCardDevice::callback(CallbackComponent component, const types::Event& ev, int id)
+{
+  switch(component)
+  {
+    case CC_READER:
+      process_readerCallback(ev, id);
+      break;
+    case CC_WRITER:
+      process_writerCallback(ev, id);
+      break;
+    case CC_DISPENSER:
+      process_dispenserCallback(ev, id);
+      break;
+    case CC_CAPTURE:
+      process_captureCallback(ev, id);
+      break;
+  }
+}
+void magCardDevice::readerCallback(const Event& ev, int id)
+{
+  enqueue(CC_READER, ev, id);
+}
+void magCardDevice::captureCallback(const Event& ev, int id)
+{
+  enqueue(CC_CAPTURE, ev, id);
+}
+void magCardDevice::dispenserCallback(const Event& ev, int id)
+{
+  enqueue(CC_DISPENSER, ev, id);
+}
+void magCardDevice::writerCallback(const Event &ev, int id)
+{
+  enqueue(CC_WRITER, ev, id);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void magCardDevice::captureCallback(const Event &ev, int id)
+//
+//  purpose:    callback for Capture component
+//
+//  date:       21.02.01, 09:32
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void magCardDevice::process_captureCallback(const Event &ev, int id)
+{
+    vCompCapture::lError = ev.statusCode;
+
+    trace(_HERE_1, "Capture (%d); event code: (%s) (%d), status code: (%s) (%d) for %s", id, eventCodesText(ev.eventCode).c_str(), ev.eventCode, scString(ev.statusCode).c_str(), ev.statusCode, ev.functionName.in());
+
+    if(!*ev.functionName && ev.statusCode == m_statuscodes::OK)
+    {
+      // unsolicited event ??
+      if(!eventReceived(ev))
+        handleException(ev.eventCode, ev.statusCode, ev.functionName.in());
+    }
+    else if(!eventReceived(ev))
+    {
+      switch(ev.statusCode)
+      {
+      case m_statuscodes::OK:           cardRetracted(); break;
+
+      case m_statuscodes::TIMEOUT:      commandTimeout(); break;
+      case m_statuscodes::CANCELLED:    commandCancelled(); break;
+      default:                          handleException(ev.eventCode, ev.statusCode, ev.functionName.in()); break;
+      }
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void magCardDevice::dispenserCallback(const Event &ev, int id)
+//
+//  purpose:    callback for Dispenser component
+//
+//  date:       21.02.01, 09:32
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void magCardDevice::process_dispenserCallback(const Event &ev, int id)
+{
+    vCompDispenser::lError = ev.statusCode;
+
+    trace(_HERE_1, "Dispenser (%d); event code: (%s) (%d), status code: (%s) (%d) for %s", id, eventCodesText(ev.eventCode).c_str(), ev.eventCode, scString(ev.statusCode).c_str(), ev.statusCode, ev.functionName.in());
+
+    if(!*ev.functionName && ev.statusCode == m_statuscodes::OK)
+    {
+      // unsolicited event ??
+      if(!eventReceived(ev))
+        handleException(ev.eventCode, ev.statusCode, ev.functionName.in());
+    }
+    else if(!eventReceived(ev))
+    {
+      switch(ev.statusCode)
+      {
+      case m_statuscodes::OK:
+      case m_statuscodes::MEDIA_ABSENT: cardRemoved(); break;
+
+      case m_statuscodes::TIMEOUT:      commandTimeout(); break;
+      case m_statuscodes::CANCELLED:    commandCancelled(); break;
+      default:                          handleException(ev.eventCode, ev.statusCode, ev.functionName.in()); break;
+      }
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void magCardDevice::readerCallback(const Event &ev, int id)
+//
+//  purpose:    callback function for the reader component
+//
+//  date:       15.09.00, 12:19
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void magCardDevice::process_readerCallback(const Event &ev, int id)
+{
+    vCompReader::lError = ev.statusCode;
+
+    trace(_HERE_1, "Reader (%d); event code: (%s) (%d), status code: (%s) (%d) for %s", id, eventCodesText(ev.eventCode).c_str(), ev.eventCode, scString(ev.statusCode).c_str(), ev.statusCode, ev.functionName.in());
+
+    if(!*ev.functionName && ev.statusCode == m_statuscodes::OK)
+    {
+      // unsolicited event ??
+      if(!eventReceived(ev))
+        handleException(ev.eventCode, ev.statusCode, ev.functionName.in());
+    }
+    else if(!eventReceived(ev))
+    {
+      switch(ev.statusCode)
+      {
+      case m_statuscodes::OK:                                break;
+      case m_statuscodes::MEDIA_PRESENT: cardInserted();     break;
+
+      case m_statuscodes::DATA_PRESENT:  dataPresent();      break;
+
+      case m_statuscodes::TIMEOUT:       commandTimeout();   break;
+      case m_statuscodes::CANCELLED:     commandCancelled(); break;
+
+      case m_statuscodes::MEDIA_ABSENT:  if((NSC_MI::Swipe == vcReader.getTypeOfReader())
+                                          ||
+                                            (NSC_MI::DIP == vcReader.getTypeOfReader()))
+                                         {
+                                           // this is valid for swipe and dip readers
+                                           trace(_HERE_7, "Media Absent -> call card removed!");
+                                           cardRemoved();
+                                         }
+                                         else
+                                           trace(_HERE_7, "Media Absent -> no DIP or SWIPE, do nothing");
+                                         break;
+
+      default:                           handleException(ev.eventCode, ev.statusCode, ev.functionName.in());
+                                         break;
+      }
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void magCardDevice::writerCallback(const Event &ev, int id)
+//
+//  purpose:    callbackfunction for the writer component
+//
+//  date:       15.09.00, 12:20
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void magCardDevice::process_writerCallback(const Event &ev, int id)
+{
+    // discard old card reader response/indication
+
+    abTrack1[0] = '\0';
+    abTrack2[0] = '\0';
+    abTrack3[0] = '\0';
+
+    //0.1 strcpy(vCompWriter::sz3LCode, ev.machineLocationCode);
+    //0.1 strcpy(vCompWriter::szID, ev.machineIdentifier);
+
+    vCompWriter::lError = ev.eventCode;
+
+    trace(_HERE_1, "Writer (%d); event code: (%s) (%d), status code: (%s) (%d) for %s", id, eventCodesText(ev.eventCode).c_str(), ev.eventCode, scString(ev.statusCode).c_str(), ev.statusCode, ev.functionName.in());
+
+/*
+    if(!*ev.functionName && ev.statusCode == m_statuscodes::OK)
+    {
+      // unsolicited event ??
+
+      handleException(ev.eventCode, ev.statusCode, ev.functionName.in());
+    }
+    else if(!eventReceived(ev))
+    {
+      switch(ev.statusCode)
+      {
+      }
+    }
+*/
+}
+
+
+long magCardDevice::error()
+{
+  return vCompReader::error();
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long magCardDevice::status(comptype ct)
+ *
+ *  @brief     query status on specific virtual component
+ *
+ *  @date      20.10.2004
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long magCardDevice::status(comptype ct, Event_out ev)
+{
+  return status(BLOCK_, ct, ev);
+}
+long magCardDevice::status(long lTimeout, comptype ct, Event_out ev)
+{
+long      rc = missingComponent;
+
+    try
+    {
+      switch(ct)
+      {
+      case vCompReader::reader:
+
+           if(vcReader.isConnected())
+           {
+             if((rc = vcReader.query(lTimeout, ev)) == 0 && (lTimeout >= 0))
+               rc = ev->statusCode;
+           }
+           break;
+
+      case vCompWriter::writer:
+
+           if(vcWriter.isConnected())
+           {
+             if((rc = vcWriter.query(lTimeout, ev)) == 0 && (lTimeout >= 0))
+               rc = ev->statusCode;
+           }
+           break;
+
+      case vCompCapture::capture:
+
+           if(vcCapture.isConnected())
+           {
+             if((rc = vcCapture.query(lTimeout, ev)) == 0 && (lTimeout >= 0))
+               rc = ev->statusCode;
+           }
+           break;
+
+      case vCompDispenser::dispenser:
+
+           if(vcDispenser.isConnected())
+           {
+             if((rc = vcDispenser.query(lTimeout, ev)) == 0 && (lTimeout >= 0))
+               rc = ev->statusCode;
+           }
+           break;
+      }
+    }
+    catch(...) {}
+
+    trace(_HERE_7, "status query result: %s, rc = %d", scString(rc).c_str(), rc);
+
+    return(rc);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long magCardDevice::open(long lTimeOut)
+//
+//  purpose:    enable device for card insertion
+//
+//  date:       15.09.00, 12:20
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long magCardDevice::open(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    // reset all track data before reading a new card...
+    clearData();
+
+    if(vcReader.isConnected())
+    {
+      if(((rc = vcReader.enable(lTimeOut, ev)) != 0) || (lTimeOut < 0))
+        return(rc);
+      else
+        return(checkStatusCode(ev));
+    }
+    else
+      return(missingComponent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long magCardDevice::close(long lTimeOut)
+//
+//  purpose:    disable device from card insertion
+//
+//  date:       15.09.00, 12:20
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long magCardDevice::close(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcReader.isConnected())
+    {
+      if(((rc = vcReader.disable(lTimeOut, ev)) != 0) || (lTimeOut < 0))
+        return(rc);
+      else
+        return(checkStatusCode(ev));
+    }
+    else
+      return(missingComponent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long magCardDevice::cancel(long lTimeOut)
+//
+//  purpose:    cancel the last command (read or eject)
+//
+//  date:       06.10.00 16:48 @@MaK
+//
+//  author:     Dr. Materna GmbH (MaK)
+//
+//---------------------------------------------------------------------------
+
+long magCardDevice::cancel(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcReader.isConnected() && vcDispenser.isConnected())
+    {
+      rc = vcDispenser.cancel(ev);
+      rc = vcReader.cancel(ev);
+
+      return(rc);
+    }
+    else
+      return(missingComponent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long magCardDevice::read(long lTimeOut)
+//
+//  purpose:    read bdata from vitual component
+//
+//  date:       15.09.00, 12:21
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long magCardDevice::read(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcReader.isConnected())
+    {
+      if(((rc = vcReader.receive(lTimeOut, ev)) != 0) || (lTimeOut < 0))
+      {
+        trace(_HERE_7, "receive() for card data, rc = (%s) (%d)", rcString(rc).c_str(), rc);
+
+        return(rc);
+      }
+      else
+      {
+        // handle returned data directly if synchronous call !!
+
+        TypeCode_ptr tcp = ev->eventData.type();
+
+        if(tcp->equivalent(_tc_msgDataType))
+        {
+          trace(_HERE_7, "received msgDataType");
+
+          if(ev->statusCode  == m_statuscodes::OK
+            || ev->statusCode == m_statuscodes::DATA_PRESENT)
+          {
+            saveData(ev->eventData);
+          }
+          else
+          {
+            if(ev->statusCode  == m_statuscodes::DATA_MISSING)
+            {
+              clearData();
+            }
+            eventReceived(*ev);
+          }
+        }
+        else
+        {
+          trace(_HERE_7, "received invalid DataType");
+        }
+      }
+
+      return(checkStatusCode(ev));
+    }
+    else
+      return(missingComponent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long magCardDevice::eject(long lTimeOut)
+//
+//  purpose:    offer the card to the user
+//
+//  date:       15.09.00, 12:21
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long magCardDevice::eject(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcDispenser.isConnected())
+    {
+      if(((rc = vcDispenser.offer(lTimeOut, ev)) != 0) || (lTimeOut < 0))
+        return(rc);
+      else
+        return(checkStatusCode(ev));
+    }
+    else
+      return(missingComponent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long magCardDevice::retract(long lTimeOut)
+//
+//  purpose:    retract card (e.g. after timeout)
+//
+//  date:       15.09.00, 12:21
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long magCardDevice::retract(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcCapture.isConnected())
+    {
+      rc = close();
+
+      if(((rc = vcCapture.retain(lTimeOut, ev)) != 0) || (lTimeOut < 0))
+        return(rc);
+      else
+        return(checkStatusCode(ev));
+    }
+    else
+      return(missingComponent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long magCardDevice::write(long lTimeOut)
+//
+//  purpose:    write all tracks onto the card
+//
+//  date:       15.09.00, 12:22
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long magCardDevice::write(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+Any       ds;
+
+#pragma COMPLETE
+
+    // create datastream for card reader
+
+    ds <<= (Long) 0;
+
+    if(vcWriter.isConnected())
+    {
+      if(((rc = vcWriter.send(lTimeOut, ds, ev)) != 0) || (lTimeOut < 0))
+        return(rc);
+      else
+        return(checkStatusCode(ev));
+    }
+    else
+      return(missingComponent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void magCardDevice::setTrack1(char *pszTrack)
+//
+//  purpose:    store data for track 1
+//
+//  date:       15.09.00, 12:22
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void magCardDevice::setTrack1(char *pszTrack)
+{
+    if(pszTrack)
+      memcpy(abTrack1, pszTrack, strlen((char *)abTrack1));
+    else
+      memset(abTrack1, 0, sizeof(abTrack1));
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void magCardDevice::setTrack2(char *pszTrack)
+//
+//  purpose:    store data for track 2
+//
+//  date:       15.09.00, 12:23
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void magCardDevice::setTrack2(char *pszTrack)
+{
+    if(pszTrack)
+      memcpy(abTrack2, pszTrack, strlen((char *)abTrack2));
+    else
+      memset(abTrack2, 0, sizeof(abTrack2));
+
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void magCardDevice::setTrack3(char *pszTrack)
+//
+//  purpose:    store data for track 3
+//
+//  date:       15.09.00, 12:23
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void magCardDevice::setTrack3(char *pszTrack)
+{
+    if(pszTrack)
+      memcpy(abTrack3, pszTrack, strlen((char *)abTrack3));
+    else
+      memset(abTrack3, 0, sizeof(abTrack3));
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   char *magCardDevice::getTrack1()
+//
+//  purpose:    return data from track 1
+//
+//  date:       15.09.00, 12:23
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+char *magCardDevice::getTrack1()
+{
+    return(abTrack1);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   char *magCardDevice::getTrack2()
+//
+//  purpose:    return data from track 2
+//
+//  date:       15.09.00, 12:23
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+char *magCardDevice::getTrack2()
+{
+    return(abTrack2);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   char *magCardDevice::getTrack3()
+//
+//  purpose:    return data from track 3
+//
+//  date:       15.09.00, 12:24
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+char *magCardDevice::getTrack3()
+{
+    return(abTrack3);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void magCardDevice::setTracks(char *pszTrack1, char *pszTrack2, char *pszTrack3)
+//
+//  purpose:    store data for all tracks
+//
+//  date:       15.09.00, 12:24
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void magCardDevice::setTracks(char *pszTrack1, char *pszTrack2, char *pszTrack3)
+{
+    setTrack1(pszTrack1);
+    setTrack2(pszTrack2);
+    setTrack3(pszTrack3);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void magCardDevice::clearTracks()
+//
+//  purpose:    clears data for all tracks
+//
+//  date:       15.09.00, 12:24
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void magCardDevice::clearTracks()
+{
+    setTracks(NULL, NULL, NULL);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void magCardDevice::cardInserted()
+//
+//  purpose:    called upon card insertion event (virtual)
+//
+//  date:       15.09.00, 12:24
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void magCardDevice::cardInserted()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void magCardDevice::dataPresent()
+//
+//  purpose:    called upon card data presence (virtual)
+//
+//  date:       17.06.2002, 12:06
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void magCardDevice::dataPresent()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void magCardDevice::cardEjected()
+//
+//  purpose:    called upon card eject event (virtual)
+//
+//  date:       15.09.00, 12:25
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void magCardDevice::cardEjected()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void magCardDevice::cardRemoved()
+//
+//  purpose:    called upon card rempval event (virtual)
+//
+//  date:       15.09.00, 12:25
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void magCardDevice::cardRemoved()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void magCardDevice::cardRetracted()
+//
+//  purpose:    called upon card retraction event (virtual)
+//
+//  date:       15.09.00, 12:26
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+void magCardDevice::cardRetracted()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void magCardDevice::commandTimeout()
+//
+//  purpose:    called if command timeout has occurred
+//
+//  date:       21.02.01, 10:35
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void magCardDevice::commandTimeout()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void magCardDevice::commandCancelled()
+//
+//  purpose:    calles if command has been cancelled
+//
+//  date:       21.02.01, 10:35
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void magCardDevice::commandCancelled()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void magCardDevice::handleException(long eventCode,
+//                                              long statusCode,
+//                                              const char *pszFunction)
+//
+//  purpose:    called if an unhandled status code (error) has been received
+//
+//  date:       21.02.01, 10:36
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void magCardDevice::handleException(long eventCode, long statusCode, const char *pszFunction)
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool magCardDevice::eventReceived(long eventCode,
+//                                            long statusCode,
+//                                            const char *pszFunction)
+//
+//  purpose:
+//
+//  date:       29.11.00, 15:41
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+bool magCardDevice::eventReceived (const Event& ev)
+{
+  return eventReceived(ev.eventCode, ev.statusCode, ev.functionName.in());
+}
+bool magCardDevice::eventReceived(long eventCode, long statusCode, const char *pszFunction)
+{
+    return(false);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   readertype magCardDevice::readerType()
+//
+//  purpose:    return the reader type from characteristics
+//
+//  date:       05.09.2002, 14:21
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+magCardDevice::readertype magCardDevice::readerType()
+{
+magCardDevice::readertype rt = RT_ERROR;
+char       szTmp[256];
+
+    if(vcReader.isConnected())
+    {
+      switch(vcReader.getTypeOfReader())
+      {
+      case NSC_MI::Motorized:
+
+           strcpy(szTmp, "Motorized");
+           rt = RT_MOTORIZED;
+           break;
+
+      case NSC_MI::Swipe:
+
+           strcpy(szTmp, "Swipe");
+           rt = RT_SWIPE;
+           break;
+
+      case NSC_MI::Contactless:
+
+           strcpy(szTmp, "Contactless");
+           rt = RT_CONTACTLESS;
+           break;
+
+      case NSC_MI::DIP:
+
+           strcpy(szTmp, "DIP");
+           rt = RT_DIP;
+           break;
+
+      case NSC_MI::nonApplicableReaderType:   // not useful for card readers
+
+           strcpy(szTmp, "nonApplicableReaderType");
+           rt = RT_ERROR;
+           break;
+
+      case NSC_MI::FlatbedScan:               // not useful for card readers
+
+           strcpy(szTmp, "FlatbedScan");
+           rt = RT_ERROR;
+           break;
+
+      case NSC_MI::PenScan:                   // not useful for card readers
+
+           strcpy(szTmp, "PenScan");
+           rt = RT_ERROR;
+           break;
+      }
+
+      trace(_HERE_7, "ReaderType = %s", szTmp);
+    }
+
+    return(rt);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   void magCardDevice::init(amInterface *pAmi, const char* pszRealComponent)
+//
+//  purpose:    called by class constructor - acquire virtual components
+//
+//  date:       15.09.00, 12:27
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+void magCardDevice::init(amInterface *pAmi, const char* pszRealComponent)
+{
+  if(pszRealComponent)
+  {
+    realComponent= pszRealComponent;
+    trace(_HERE_7, "use realcomponent: %s", pszRealComponent);
+
+    long             lIndex;
+
+    try
+    {
+      // try to connect all virtual components
+
+      lIndex = 0;
+      vcReader.storeIOR(pAmi->ior(lIndex, pszRealComponent, "MediaInput"));
+
+      trace(_HERE_7, "use realcomponent: %s", pszRealComponent);
+
+      lIndex = 0;
+      vcWriter.storeIOR(pAmi->ior(lIndex, pszRealComponent, "MediaOutput"));
+
+      lIndex = 0;
+      vcDispenser.storeIOR(pAmi->ior(lIndex, pszRealComponent, "Dispenser"));
+
+      lIndex = 0;
+      vcCapture.storeIOR(pAmi->ior(lIndex, pszRealComponent, "Capture"));
+
+      strcpy(vCompReader::szAppRef,   pAmi->getAppReference());
+      strcpy(vCompWriter::szAppRef,   pAmi->getAppReference());
+      strcpy(vCompDispenser::szAppRef, pAmi->getAppReference());
+      strcpy(vCompCapture::szAppRef,  pAmi->getAppReference());
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+    }
+
+    setTracks(NULL, NULL, NULL);
+
+    vcReader.connect();
+    vcReader.setListener();
+    vcWriter.connect();
+    vcWriter.setListener();
+    vcDispenser.connect();
+    vcDispenser.setListener();
+    vcCapture.connect();
+    vcCapture.setListener();
+
+    readerType(); // for debug output only !!
+    if(vcWriter.isConnected())
+      fHasWriter = true;
+    if(vcDispenser.isConnected())
+      fHasDispenser = true;
+    if(vcCapture.isConnected())
+      fHasCapture = true;
+  }
+  startProcessing();
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   magCardDevice::magCardDevice(amInterface *pAmi, ostream *pStream)
+//
+//  purpose:    class constructor - aquire virutal components
+//
+//  date:       15.09.00, 12:27
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+magCardDevice::magCardDevice(amInterface *pAmi):
+  vCompReader   (pAmi),
+  vCompWriter   (pAmi),
+  vCompDispenser(pAmi),
+  vCompCapture  (pAmi),
+  vcReader(static_cast<vCompReader*>(this)),
+  vcWriter(static_cast<vCompWriter*>(this)),
+  vcDispenser(static_cast<vCompDispenser*>(this)),
+  vcCapture(static_cast<vCompCapture*>(this))
+{
+  // assume no features at first
+
+  fHasCapture   = false;
+  fHasWriter    = false;
+  fHasDispenser = false;
+
+  const char* pszRealComponent= "MagneticCardReader";
+  try
+  {
+    const char* pszIOR= 0;
+
+    long lIndex = 0;
+    pszIOR= pAmi->ior(lIndex, pszRealComponent, "MediaInput");
+    if(pszIOR == 0)
+    {
+      amInterface::MediaTypeSet mediatype;
+      amInterface::DataTypeSet datatype;
+      mediatype.insert(Characteristics::MediaType::MagneticStripe);
+      datatype.insert(Characteristics::MSG);
+      lIndex= 0;
+      pszRealComponent= pAmi->queryMediaInput(lIndex, mediatype, datatype);
+    }
+  }
+  catch(CORBA::SystemException& ex)
+  {
+    trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+  }
+  init(pAmi, pszRealComponent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   magCardDevice::magCardDevice(amInterface *pAmi, const cardselection& select)
+//
+//  purpose:    class constructor - aquire virutal components
+//
+//  date:       09.03.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+magCardDevice::magCardDevice(amInterface *pAmi, const cardselection& select):
+  vCompReader   (pAmi),
+  vCompWriter   (pAmi),
+  vCompDispenser(pAmi),
+  vCompCapture  (pAmi),
+  vcReader(static_cast<vCompReader*>(this)),
+  vcWriter(static_cast<vCompWriter*>(this)),
+  vcDispenser(static_cast<vCompDispenser*>(this)),
+  vcCapture(static_cast<vCompCapture*>(this))
+{
+  // assume no features at first
+
+  fHasCapture   = false;
+  fHasWriter    = false;
+  fHasDispenser = false;
+
+  const char* pszRealComponent= 0;
+  try
+  {
+    cardselection::const_iterator it= select.begin();
+    cardselection::const_iterator end= select.end();
+    amInterface::DataTypeSet datatype;
+    datatype.insert(Characteristics::MSG);
+    amInterface::MediaTypeSet mediatype;
+    for(; it != end; ++it)
+      mediatype.insert(getCardTypeMediaType(*it));
+    long lIndex = 0;
+    pszRealComponent= pAmi->queryMediaInput(lIndex, mediatype, datatype);
+  }
+  catch(CORBA::SystemException& ex)
+  {
+    trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+  }
+  init(pAmi, pszRealComponent);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   magCardDevice::~magCardDevice()
+//
+//  purpose:    class destructor - release aquired virtual components
+//
+//  date:       15.09.00, 12:28
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+magCardDevice::~magCardDevice()
+{
+  vcReader.clearListener();
+  vcWriter.clearListener();
+  vcDispenser.clearListener();
+  vcCapture.clearListener();
+}
+
+bool magCardDevice::hasMediaInputCardTypeSupport(cardtype card)
+{
+  bool result= false;
+  if(vcReader.isConnected())
+  {
+    Characteristics::MediaTypeListDef_var mtl;
+    Characteristics::MediaType::MediaTypeDef type= getCardTypeMediaType(card);
+    result= contains(vcReader.getMtList(), type);
+  }
+  return result;
+}
+bool magCardDevice::hasMediaOutputCardTypeSupport(cardtype card)
+{
+  bool result= false;
+  if(vcWriter.isConnected())
+  {
+    Characteristics::MediaTypeListDef_var mtl;
+    Characteristics::MediaType::MediaTypeDef type= getCardTypeMediaType(card);
+    result= contains(vcWriter.getMtList(), type);
+  }
+  return result;
+}
+
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/manufacturer.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/manufacturer.cpp
new file mode 100644
index 00000000..d0977409
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/manufacturer.cpp
@@ -0,0 +1,67 @@
+//---------------------------------------------------------------------------
+//
+//  file:       manufacturer.cpp
+//
+//  purpose:    class implementation
+//
+//  date:       31.07.2002, 14:44
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include "orbincdefs.h"
+
+#include "comps.h"
+#include "types.h"
+#include "codes.h"
+
+#include "orbs.h"
+#include "vcomp.h"
+
+#include "manufacturer.h"
+
+using namespace MASSAI;
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   const char *vManufacturer::realComponentName()
+//
+//  purpose:
+//
+//  date:       23.10.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+const char *vManufacturer::realComponentName()
+{
+  return realComponent.c_str();
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   const char *vManufacturer::isSameDevice(vManufacturer& cmp);
+//
+//  purpose:
+//
+//  date:       16.11.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+bool vManufacturer::isSameDevice(vManufacturer& cmp)
+{
+  bool result= false;
+  if(&cmp == this)
+  {
+    result= true;
+  }
+  else if(realComponent == cmp.realComponent)
+  {
+    result= true;
+  }
+  return result;
+}
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/pdf417.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/pdf417.cpp
new file mode 100644
index 00000000..bf346c4d
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/pdf417.cpp
@@ -0,0 +1,230 @@
+//------------------------------------------------------------------------
+/**
+ *  @fn        #include <string.h>
+ *
+ *  @brief     PDF417 Barcode Conversion
+ *
+ *  @date      01.07.2004
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "pdf417.h"
+#include "pdf417lib.h"
+#include "tracedef.h"
+
+static pdf417param params;
+static char *pszOutBuf = NULL;
+
+char *pdf417::svg()
+{
+    if(pszOutBuf)
+      return(pszOutBuf);
+    else
+      return("");
+}
+
+long pdf417::convert(char *pszInput)
+{
+int  cols;
+int  k, n;
+int  x, y;
+int  width;
+int  dx = 1;
+int  dy = 1;
+char b;
+
+long len = 0;
+
+    trace(_HERE_1, "converting to PDF417: %s", pszInput);
+
+    if(*pszInput)
+      params.text = pszInput;
+    else
+      params.text = szInBuf;
+
+    if(!pszOutBuf)
+      return(-1);
+
+    params.options     = PDF417_INVERT_BITMAP | PDF417_USE_ASPECT_RATIO;
+    params.aspectRatio = (float) 3.00 / (float) 4.00;
+    params.errorLevel  = 3;
+
+    paintCode(&params);
+
+    if(params.error)
+      return(-10 * params.error);
+
+    len += sprintf(pszOutBuf +len, "<g>\n");
+
+    cols = (params.bitColumns -1) / 8 + 1;
+
+    for(k = 0, x = 0, y = -dy; k < params.lenBits; ++k)
+    {
+       if(!(k % cols))
+       {
+         y += dy;
+         x  = 0;
+
+         len += sprintf(pszOutBuf +len, "\n");
+       }
+
+       b = params.outBits[k] & 0xff;
+
+#if 0
+       for(n = 7; n >= 0; n--, x += dx)
+       {
+         // don't print white fields - 1. optimization (50% - 60%)
+
+         if((b & (1 << n)) == 0)
+           len += sprintf(pszOutBuf +len, "<rect x=\"%dpt\" y=\"%dpt\" width=\"%dpt\" height=\"%dpt\" fill=\"black\" />\n",
+                                         x, y, dx, dy);
+       }
+
+#else
+       // 2. optimization -> in X direction (70% - 80%)
+
+       for(n = 7; n >= 0; n--)
+       {
+         // reset width for every byte
+
+         width = 0;
+
+         // check byte for all black values
+
+         while((n >= 0) && (b & (1 << n)) == 0)
+         {
+            width += dx; // increase width
+            x     += dx; // and also coordinates
+            n--;         // one bit furhter
+         }
+
+         // found one? -> print it out
+
+         if(width)
+           len += sprintf(pszOutBuf +len, "<rect x=\"%dpt\" y=\"%dpt\" width=\"%dpt\" height=\"%dpt\" fill=\"black\" />\n",
+                                          x-width, y, width, dy);
+
+         // do this only when bit count is NOT below zero !!!
+
+         if(n >= 0)
+           x += dx;
+       }
+#endif
+    }
+
+    len += sprintf(pszOutBuf +len, "\n</g>");
+
+    return(len);
+}
+
+pdf417::pdf417(char *pszInput)
+{
+    if(pszInput)
+      strcpy(szInBuf, pszInput);
+    else
+      *szInBuf = '\0';
+
+    pdf417init(&params);
+
+    pszOutBuf = NULL;
+
+    pszOutBuf = (char *) malloc(1024 * 512);
+
+    if(*szInBuf)
+      convert();
+}
+
+pdf417::~pdf417()
+{
+    if(pszOutBuf) free(pszOutBuf);
+
+    pdf417free(&params);
+}
+
+
+#if 0
+
+int main(int argc, char* argv[])
+{
+    pdf417param p;
+    FILE* f;
+    pdf417init(&p);
+
+    //p.text = "11KULM/STEVEN ABCDEFYFAIANCAS00146121006B";
+    p.text =  "14KULM/STEVEN ABCDEFYFAIANCAS00146121Y006B1631XXXXXXANCPDXAS00100122Y008E241XXXXXXPDXSFOAS02580122Y012A21XXXXXXSFOSJDAS02420122Y007F11XXXXXX";
+
+    p.options     = PDF417_INVERT_BITMAP | PDF417_USE_ASPECT_RATIO;
+    p.aspectRatio = 1.00/3.00;
+    p.errorLevel  = 3;
+
+    paintCode(&p);
+
+    if (p.error) {
+        pdf417free(&p);
+        return 0;
+    }
+
+    f = fopen("pdf417.svg", "wb");
+
+    if(f)
+    {
+        int  cols = p.bitColumns / 8 + 1;
+        int  k, n;
+        int  x, y;
+        int  dx = 2;
+        int  dy = 4;
+        char b;
+
+        fprintf(f, "<?xml version=\"1.0\" standalone=\"no\"?>\n", 0);
+        fprintf(f, "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n", 0);
+
+        fprintf(f, " <svg width=\"600pt\" height=\"400pt\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">\n\n", 0);
+
+        for(k = 0, x = 0, y = -dy; k < p.lenBits; ++k)
+        {
+           if(!(k % cols))
+           {
+             y += dy;
+             x  = 0;
+
+             fprintf(f, "\n");
+           }
+
+           b = p.outBits[k] & 0xff;
+
+/*
+           fprintf(f, "<!-- b = 0x%02X , ", b & 0xff);
+
+           for(n = 7; n >= 0; n--)
+           {
+             if((b & (1 << n)))
+              fprintf(f, "1");
+             else
+              fprintf(f, "0");
+           }
+
+           fprintf(f, "-->\n");
+*/
+           for(n = 7; n >= 0; n--, x += dx)
+           {
+             if((b & (1 << n)) == 0)
+              fprintf(f, "<rect x=\"%dpt\" y=\"%dpt\" width=\"%dpt\" height=\"%dpt\" fill=\"black\" />\n", x, y, dx, dy);
+             else
+              fprintf(f, "<rect x=\"%dpt\" y=\"%dpt\" width=\"%dpt\" height=\"%dpt\" fill=\"white\" />\n", x, y, dx, dy);
+           }
+        }
+
+        fprintf(f, "\n</svg>");
+        fclose(f);
+    }
+
+    pdf417free(&p);
+    return 0;
+}
+#endif
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/pdf417lib.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/pdf417lib.cpp
new file mode 100644
index 00000000..e3aa8a12
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/pdf417lib.cpp
@@ -0,0 +1,815 @@
+/*
+ * Copyright 2003 by Paulo Soares.
+ *
+ * The contents of this file are subject to the Mozilla Public License Version 1.1
+ * (the "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the License.
+ *
+ * The Original Code is 'pdf417lib, a library to generate the bidimensional barcode PDF417'.
+ *
+ * The Initial Developer of the Original Code is Paulo Soares. Portions created by
+ * the Initial Developer are Copyright (C) 2003 by Paulo Soares.
+ * All Rights Reserved.
+ *
+ * Contributor(s): all the names of the contributors are added in the source code
+ * where applicable.
+ *
+ * Alternatively, the contents of this file may be used under the terms of the
+ * LGPL license (the "GNU LIBRARY GENERAL PUBLIC LICENSE"), in which case the
+ * provisions of LGPL are applicable instead of those above.  If you wish to
+ * allow use of your version of this file only under the terms of the LGPL
+ * License and not to allow others to use your version of this file under
+ * the MPL, indicate your decision by deleting the provisions above and
+ * replace them with the notice and other provisions required by the LGPL.
+ * If you do not delete the provisions above, a recipient may use your version
+ * of this file under either the MPL or the GNU LIBRARY GENERAL PUBLIC LICENSE.
+ *
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the MPL as stated above or under the terms of the GNU
+ * Library General Public License as published by the Free Software Foundation;
+ * either version 2 of the License, or any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU Library general Public License for more
+ * details.
+ *
+ * If you didn't download this code from the following link, you should check if
+ * you aren't using an obsolete version:
+ * http://sourceforge.net/projects/pdf417lib
+ */
+#include <malloc.h>
+#include <string.h>
+#include <stdio.h>
+#include <math.h>
+#define __INCLUDE_PDF417LIBIMP_H__
+#include "pdf417libimp.h"
+#undef __INCLUDE_PDF417LIBIMP_H__
+#include "pdf417lib.h"
+
+#ifndef NULL
+#ifdef  __cplusplus
+#define NULL    0
+#else
+#define NULL    ((void *)0)
+#endif
+#endif
+
+char* MIXED_SET = "0123456789&\r\t,:#-.$/+%*=^";
+char* PUNCTUATION_SET = ";<>@[\\]_`~!\r\t,:\n-.$/\"|*()?{}'";
+
+typedef struct _listElement {
+    char type;
+    int start;
+    int end;
+} listElement, *pListElement;
+
+typedef struct _arrayList {
+    pListElement array;
+    int size;
+    int capacity;
+} arrayList, *pArrayList;
+
+typedef struct _pdf417class {
+    int bitPtr;
+    int cwPtr;
+    pdf417param *param;
+} pdf417class, *pPdf417class;
+
+
+void listInit(pArrayList list) {
+    list->capacity = 20;
+    list->size = 0;
+    list->array = (pListElement)malloc(list->capacity * sizeof(listElement));
+}
+
+void listFree(pArrayList list) {
+    free(list->array);
+    list->array = NULL;
+}
+
+void listAdd(pArrayList list, char type, int start, int end) {
+    if (list->size == list->capacity) {
+        pListElement temp;
+        list->capacity *= 2;
+        temp = (pListElement)malloc(list->capacity * sizeof(listElement));
+        memcpy(temp, list->array, list->size * sizeof(listElement));
+        free(list->array);
+        list->array = temp;
+    }
+    list->array[list->size].type = type;
+    list->array[list->size].start = start;
+    list->array[list->size].end = end;
+    ++list->size;
+}
+
+pListElement listGet(pArrayList list, int idx) {
+    if (idx >= list->size || idx < 0)
+        return NULL;
+    return list->array + idx;
+}
+
+void listRemove(pArrayList list, int idx) {
+    if (idx >= list->size || idx < 0)
+        return;
+    --list->size;
+    memmove(list->array + idx, list->array + (idx + 1), (list->size - idx) * sizeof(listElement));
+}
+
+int checkElementType(pListElement p, char type) {
+    if (!p)
+        return 0;
+    return (p->type == type);
+}
+
+int getElementLength(pListElement p) {
+    if (!p)
+        return 0;
+    return p->end - p->start;
+}
+
+void pdf417init(pPdf417param param) {
+    param->options = 0;
+    param->outBits = NULL;
+    param->lenBits = 0;
+    param->error = 0;
+    param->lenText = -1;
+    param->text = "";
+    param->yHeight = 3;
+    param->aspectRatio = 0.5;
+}
+
+void pdf417free(pPdf417param param) {
+    if (param->outBits != NULL) {
+        free(param->outBits);
+        param->outBits = NULL;
+    }
+}
+
+void outCodeword17(pPdf417class p, int codeword) {
+    int bytePtr = p->bitPtr / 8;
+    int bit = p->bitPtr - bytePtr * 8;
+    p->param->outBits[bytePtr++] |= codeword >> (9 + bit);
+    p->param->outBits[bytePtr++] |= codeword >> (1 + bit);
+    codeword <<= 8;
+    p->param->outBits[bytePtr] |= codeword >> (1 + bit);
+    p->bitPtr += 17;
+}
+
+void outCodeword18(pPdf417class p, int codeword) {
+    int bytePtr = p->bitPtr / 8;
+    int bit = p->bitPtr - bytePtr * 8;
+    p->param->outBits[bytePtr++] |= codeword >> (10 + bit);
+    p->param->outBits[bytePtr++] |= codeword >> (2 + bit);
+    codeword <<= 8;
+    p->param->outBits[bytePtr] |= codeword >> (2 + bit);
+    if (bit == 7)
+        p->param->outBits[++bytePtr] |= 0x80;
+    p->bitPtr += 18;
+}
+
+void outCodeword(pPdf417class p, int codeword) {
+    outCodeword17(p, codeword);
+}
+
+void outStopPattern(pPdf417class p) {
+    outCodeword18(p, STOP_PATTERN);
+}
+
+void outStartPattern(pPdf417class p) {
+    outCodeword17(p, START_PATTERN);
+}
+
+void outPaintCode(pPdf417class p) {
+    int codePtr = 0;
+    int row;
+    int rowMod;
+    int *cluster;
+    int edge;
+    int column;
+    p->param->bitColumns = START_CODE_SIZE * (p->param->codeColumns + 3) + STOP_SIZE;
+    p->param->lenBits = ((p->param->bitColumns - 1) / 8 + 1) * p->param->codeRows;
+    p->param->outBits = (char*)malloc(p->param->lenBits);
+    memset(p->param->outBits, 0, p->param->lenBits);
+    for (row = 0; row < p->param->codeRows; ++row) {
+        p->bitPtr = ((p->param->bitColumns - 1) / 8 + 1) * 8 * row;
+        rowMod = row % 3;
+        cluster = CLUSTERS[rowMod];
+        outStartPattern(p);
+        edge = 0;
+        switch (rowMod) {
+        case 0:
+            edge = 30 * (row / 3) + ((p->param->codeRows - 1) / 3);
+            break;
+        case 1:
+            edge = 30 * (row / 3) + p->param->errorLevel * 3 + ((p->param->codeRows - 1) % 3);
+            break;
+        default:
+            edge = 30 * (row / 3) + p->param->codeColumns - 1;
+            break;
+        }
+        outCodeword(p, cluster[edge]);
+
+        for (column = 0; column < p->param->codeColumns; ++column) {
+            outCodeword(p, cluster[p->param->codewords[codePtr++]]);
+        }
+
+        switch (rowMod) {
+        case 0:
+            edge = 30 * (row / 3) + p->param->codeColumns - 1;
+            break;
+        case 1:
+            edge = 30 * (row / 3) + ((p->param->codeRows - 1) / 3);
+            break;
+        default:
+            edge = 30 * (row / 3) + p->param->errorLevel * 3 + ((p->param->codeRows - 1) % 3);
+            break;
+        }
+        outCodeword(p, cluster[edge]);
+        outStopPattern(p);
+    }
+    if (p->param->options & PDF417_INVERT_BITMAP) {
+        char* pm = p->param->outBits;
+        char* end = pm + p->param->lenBits;
+        while (pm < end)
+            *(pm++) ^= 0xff;
+    }
+}
+
+void calculateErrorCorrection(pPdf417class p, int dest) {
+    int t1 = 0;
+    int t2 = 0;
+    int t3 = 0;
+    int *A;
+    int Alength;
+    int *E;
+    int lastE;
+    int k, e, j;
+    if (p->param->errorLevel < 0 || p->param->errorLevel > 8)
+        p->param->errorLevel = 0;
+    A = ERROR_LEVEL[p->param->errorLevel];
+    Alength = 2 << p->param->errorLevel;
+    E = p->param->codewords + dest;
+    memset(E, 0, Alength * sizeof(int));
+    lastE = Alength - 1;
+    for (k = 0; k < p->param->lenCodewords; ++k) {
+        t1 = p->param->codewords[k] + E[0];
+        for (e = 0; e <= lastE; ++e) {
+            t2 = (t1 * A[lastE - e]) % MOD;
+            t3 = MOD - t2;
+            E[e] = ((e == lastE ? 0 : E[e + 1]) + t3) % MOD;
+        }
+    }
+    for (j = 0; j < Alength; ++j)
+        E[j] = (MOD - E[j]) % MOD;
+}
+
+static int getTextTypeAndValue(char* text, int size, int idx) {
+    int c;
+    char *ms, *ps;
+    if (idx >= size)
+        return 0;
+    c = text[idx];
+    if (c >= 'A' && c <= 'Z')
+        return (ALPHA + c - 'A');
+    if (c >= 'a' && c <= 'z')
+        return (LOWER + c - 'a');
+    if (c == ' ')
+        return (ALPHA + LOWER + MIXED + SPACE);
+    ms = strchr(MIXED_SET, c);
+    ps = strchr(PUNCTUATION_SET, c);
+    if (!ms && !ps)
+        return (ISBYTE + (c & 0xff));
+    if (ms - MIXED_SET == ps - PUNCTUATION_SET)
+        return (MIXED + PUNCTUATION + (ms - MIXED_SET));
+    if (ms != NULL)
+        return (MIXED + (ms - MIXED_SET));
+    return (PUNCTUATION + (ps - PUNCTUATION_SET));
+}
+
+void textCompaction(pPdf417class p, int start, int length) {
+    int dest[ABSOLUTE_MAX_TEXT_SIZE * 2];
+    char* text = p->param->text;
+    int mode = ALPHA;
+    int ptr = 0;
+    int fullBytes = 0;
+    int v = 0;
+    int k;
+    int size;
+    memset(dest, 0, sizeof(dest));
+    length += start;
+    for (k = start; k < length; ++k) {
+        v = getTextTypeAndValue(text, length, k);
+        if ((v & mode) != 0) {
+            dest[ptr++] = v & 0xff;
+            continue;
+        }
+        if ((v & ISBYTE) != 0) {
+            if ((ptr & 1) != 0) {
+                dest[ptr++] = (mode & PUNCTUATION) != 0 ? PAL : PS;
+                mode = (mode & PUNCTUATION) != 0 ? ALPHA : mode;
+            }
+            dest[ptr++] = BYTESHIFT;
+            dest[ptr++] = v & 0xff;
+            fullBytes += 2;
+            continue;
+        }
+        switch (mode) {
+        case ALPHA:
+            if ((v & LOWER) != 0) {
+                dest[ptr++] = LL;
+                dest[ptr++] = v & 0xff;
+                mode = LOWER;
+            }
+            else if ((v & MIXED) != 0) {
+                dest[ptr++] = ML;
+                dest[ptr++] = v & 0xff;
+                mode = MIXED;
+            }
+            else if ((getTextTypeAndValue(text, length, k + 1) & getTextTypeAndValue(text, length, k + 2) & PUNCTUATION) != 0) {
+                dest[ptr++] = ML;
+                dest[ptr++] = PL;
+                dest[ptr++] = v & 0xff;
+                mode = PUNCTUATION;
+            }
+            else {
+                dest[ptr++] = PS;
+                dest[ptr++] = v & 0xff;
+            }
+            break;
+        case LOWER:
+            if ((v & ALPHA) != 0) {
+                if ((getTextTypeAndValue(text, length, k + 1) & getTextTypeAndValue(text, length, k + 2) & ALPHA) != 0) {
+                    dest[ptr++] = ML;
+                    dest[ptr++] = AL;
+                    mode = ALPHA;
+                }
+                else {
+                    dest[ptr++] = AS;
+                }
+                dest[ptr++] = v & 0xff;
+            }
+            else if ((v & MIXED) != 0) {
+                dest[ptr++] = ML;
+                dest[ptr++] = v & 0xff;
+                mode = MIXED;
+            }
+            else if ((getTextTypeAndValue(text, length, k + 1) & getTextTypeAndValue(text, length, k + 2) & PUNCTUATION) != 0) {
+                dest[ptr++] = ML;
+                dest[ptr++] = PL;
+                dest[ptr++] = v & 0xff;
+                mode = PUNCTUATION;
+            }
+            else {
+                dest[ptr++] = PS;
+                dest[ptr++] = v & 0xff;
+            }
+            break;
+        case MIXED:
+            if ((v & LOWER) != 0) {
+                dest[ptr++] = LL;
+                dest[ptr++] = v & 0xff;
+                mode = LOWER;
+            }
+            else if ((v & ALPHA) != 0) {
+                dest[ptr++] = AL;
+                dest[ptr++] = v & 0xff;
+                mode = ALPHA;
+            }
+            else if ((getTextTypeAndValue(text, length, k + 1) & getTextTypeAndValue(text, length, k + 2) & PUNCTUATION) != 0) {
+                dest[ptr++] = PL;
+                dest[ptr++] = v & 0xff;
+                mode = PUNCTUATION;
+            }
+            else {
+                dest[ptr++] = PS;
+                dest[ptr++] = v & 0xff;
+            }
+            break;
+        case PUNCTUATION:
+            dest[ptr++] = PAL;
+            mode = ALPHA;
+            --k;
+            break;
+        }
+    }
+    if ((ptr & 1) != 0)
+        dest[ptr++] = PS;
+    size = (ptr + fullBytes) / 2;
+    if (size + p->cwPtr > MAX_DATA_CODEWORDS) {
+        p->param->error = PDF417_ERROR_TEXT_TOO_BIG;
+        return;
+    }
+    length = ptr;
+    ptr = 0;
+    while (ptr < length) {
+        v = dest[ptr++];
+        if (v >= 30) {
+            p->param->codewords[p->cwPtr++] = v;
+            p->param->codewords[p->cwPtr++] = dest[ptr++];
+        }
+        else
+            p->param->codewords[p->cwPtr++] = v * 30 + dest[ptr++];
+    }
+}
+
+static void basicNumberCompaction(pPdf417class p, int start, int length) {
+    char* text = p->param->text;
+    int* ret = p->param->codewords + p->cwPtr;
+    int retLast = length / 3;
+    int ni, k;
+    p->cwPtr += retLast + 1;
+    memset(ret, 0, (retLast + 1) * sizeof(int));
+    ret[retLast] = 1;
+    length += start;
+    for (ni = start; ni < length; ++ni) {
+        // multiply by 10
+        for (k = retLast; k >= 0; --k)
+            ret[k] *= 10;
+        // add the digit
+        ret[retLast] += text[ni] - '0';
+        // propagate carry
+        for (k = retLast; k > 0; --k) {
+            ret[k - 1] += ret[k] / 900;
+            ret[k] %= 900;
+        }
+    }
+}
+
+void numberCompaction(pPdf417class p, int start, int length) {
+    int full = (length / 44) * 15;
+    int size = length % 44;
+    int k;
+    if (size == 0)
+        size = full;
+    else
+        size = full + size / 3 + 1;
+    if (size + p->cwPtr > MAX_DATA_CODEWORDS) {
+        p->param->error = PDF417_ERROR_TEXT_TOO_BIG;
+        return;
+    }
+    length += start;
+    for (k = start; k < length; k += 44) {
+        size = length - k < 44 ? length - k : 44;
+        basicNumberCompaction(p, k, size);
+    }
+}
+
+static void byteCompaction6(pPdf417class p, int start) {
+    int length = 6;
+    char* text = p->param->text;
+    int* ret = p->param->codewords + p->cwPtr;
+    int retLast = 4;
+    int ni, k;
+    p->cwPtr += retLast + 1;
+    memset(ret, 0, (retLast + 1) * sizeof(int));
+    length += start;
+    for (ni = start; ni < length; ++ni) {
+        // multiply by 256
+        for (k = retLast; k >= 0; --k)
+            ret[k] *= 256;
+        // add the digit
+        ret[retLast] += (int)text[ni] & 0xff;
+        // propagate carry
+        for (k = retLast; k > 0; --k) {
+            ret[k - 1] += ret[k] / 900;
+            ret[k] %= 900;
+        }
+    }
+}
+
+void byteCompaction(pPdf417class p, int start, int length) {
+    int k, j;
+    int size = (length / 6) * 5 + (length % 6);
+    if (size + p->cwPtr > MAX_DATA_CODEWORDS) {
+        p->param->error = PDF417_ERROR_TEXT_TOO_BIG;
+        return;
+    }
+    length += start;
+    for (k = start; k < length; k += 6) {
+        size = length - k < 44 ? length - k : 6;
+        if (size < 6) {
+            for (j = 0; j < size; ++j)
+                p->param->codewords[p->cwPtr++] = (int)p->param->text[k + j] & 0xff;
+        }
+        else {
+            byteCompaction6(p, k);
+        }
+    }
+}
+
+void breakString(pPdf417class p, pArrayList list) {
+    char* text = p->param->text;
+    int textLength = p->param->lenText;
+    int lastP = 0;
+    int startN = 0;
+    int nd = 0;
+    char c = 0;
+    int k, ptrS, lastTxt, j, txt;
+    pListElement v;
+    pListElement vp;
+    pListElement vn;
+    list->size = 0;
+    for (k = 0; k < textLength; ++k) {
+        c = text[k];
+        if (c >= '0' && c <= '9') {
+            if (nd == 0)
+                startN = k;
+            ++nd;
+            continue;
+        }
+        if (nd >= 13) {
+            if (lastP != startN) {
+                c = text[lastP];
+                ptrS = lastP;
+                lastTxt = (c >= ' ' && c < 127) || c == '\r' || c == '\n' || c == '\t';
+                for (j = lastP; j < startN; ++j) {
+                    c = text[j];
+                    txt = (c >= ' ' && c < 127) || c == '\r' || c == '\n' || c == '\t';
+                    if (txt != lastTxt) {
+                        listAdd(list, (char)(lastTxt ? 'T' : 'B'), lastP, j);
+                        lastP = j;
+                        lastTxt = txt;
+                    }
+                }
+                listAdd(list, (char)(lastTxt ? 'T' : 'B'), lastP, startN);
+            }
+            listAdd(list, 'N', startN, k);
+            lastP = k;
+        }
+        nd = 0;
+    }
+    if (nd < 13)
+        startN = textLength;
+    if (lastP != startN) {
+        c = text[lastP];
+        ptrS = lastP;
+        lastTxt = (c >= ' ' && c < 127) || c == '\r' || c == '\n' || c == '\t';
+        for (j = lastP; j < startN; ++j) {
+            c = text[j];
+            txt = (c >= ' ' && c < 127) || c == '\r' || c == '\n' || c == '\t';
+            if (txt != lastTxt) {
+                listAdd(list, (char)(lastTxt ? 'T' : 'B'), lastP, j);
+                lastP = j;
+                lastTxt = txt;
+            }
+        }
+        listAdd(list, (char)(lastTxt ? 'T' : 'B'), lastP, startN);
+    }
+    if (nd >= 13)
+        listAdd(list, 'N', startN, textLength);
+    //optimize
+    //merge short binary
+    for (k = 0; k < list->size; ++k) {
+        v = listGet(list, k);
+        vp = listGet(list, k - 1);
+        vn = listGet(list, k + 1);;
+        if (checkElementType(v, 'B') && getElementLength(v) == 1) {
+            if (checkElementType(vp, 'T') && checkElementType(vn, 'T')
+                && getElementLength(vp) + getElementLength(vn) >= 3) {
+                vp->end = vn->end;
+                listRemove(list, k);
+                listRemove(list, k);
+                k = -1;
+                continue;
+            }
+        }
+    }
+    //merge text sections
+    for (k = 0; k < list->size; ++k) {
+        v = listGet(list, k);
+        vp = listGet(list, k - 1);
+        vn = listGet(list, k + 1);;
+        if (checkElementType(v, 'T') && getElementLength(v) >= 5) {
+            int redo = 0;
+            if ((checkElementType(vp, 'B') && getElementLength(vp) == 1) || checkElementType(vp, 'T')) {
+                redo = 1;
+                v->start = vp->start;
+                listRemove(list, k - 1);
+                --k;
+            }
+            if ((checkElementType(vn, 'B') && getElementLength(vn) == 1) || checkElementType(vn, 'T')) {
+                redo = 1;
+                v->end = vn->end;
+                listRemove(list, k + 1);
+            }
+            if (redo) {
+                k = -1;
+                continue;
+            }
+        }
+    }
+    //merge binary sections
+    for (k = 0; k < list->size; ++k) {
+        v = listGet(list, k);
+        vp = listGet(list, k - 1);
+        vn = listGet(list, k + 1);;
+        if (checkElementType(v, 'B')) {
+            int redo = 0;
+            if ((checkElementType(vp, 'T') && getElementLength(vp) < 5) || checkElementType(vp, 'B')) {
+                redo = 1;
+                v->start = vp->start;
+                listRemove(list, k - 1);
+                --k;
+            }
+            if ((checkElementType(vn, 'T') && getElementLength(vn) < 5) || checkElementType(vn, 'B')) {
+                redo = 1;
+                v->end = vn->end;
+                listRemove(list, k + 1);
+            }
+            if (redo) {
+                k = -1;
+                continue;
+            }
+        }
+    }
+    // check if all numbers
+    if (list->size == 1 && (v = listGet(list, 0))->type == 'T' && getElementLength(v) >= 8) {
+        for (k = v->start; k < v->end; ++k) {
+            c = text[k];
+            if (c < '0' || c > '9')
+                break;
+        }
+        if (k == v->end)
+            v->type = 'N';
+    }
+}
+
+void assemble(pPdf417class p, pArrayList list) {
+    int k;
+    if (list->size == 0)
+        return;
+    p->cwPtr = 1;
+    for (k = 0; k < list->size; ++k) {
+        pListElement v = listGet(list, k);
+        switch (v->type) {
+        case 'T':
+            if (k != 0)
+                p->param->codewords[p->cwPtr++] = TEXT_MODE;
+            textCompaction(p, v->start, v->end - v->start);
+            break;
+        case 'N':
+            p->param->codewords[p->cwPtr++] = NUMERIC_MODE;
+            numberCompaction(p, v->start, v->end - v->start);
+            break;
+        case 'B':
+            p->param->codewords[p->cwPtr++] = (v->end - v->start) % 6 ? BYTE_MODE : BYTE_MODE_6;
+            byteCompaction(p, v->start, v->end - v->start);
+            break;
+        }
+        if (p->param->error)
+            return;
+    }
+}
+
+static int maxPossibleErrorLevel(int remain) {
+    int level = 8;
+    int size = 512;
+    while (level > 0) {
+        if (remain >= size)
+            return level;
+        --level;
+        size >>= 1;
+    }
+    return 0;
+}
+
+void dumpList(pPdf417class p, pArrayList list) {
+    int k;
+    if (list->size == 0)
+        return;
+    for (k = 0; k < list->size; ++k) {
+        pListElement v = listGet(list, k);
+        printf("%c%.*s\n", v->type, v->end - v->start, p->param->text + v->start);
+    }
+}
+
+static int getMaxSquare(pPdf417param p) {
+    if (p->codeColumns > 21) {
+        p->codeColumns = 29;
+        p->codeRows = 32;
+    }
+    else {
+        p->codeColumns = 16;
+        p->codeRows = 58;
+    }
+    return MAX_DATA_CODEWORDS + 2;
+}
+
+void paintCode(pPdf417param p) {
+    pdf417class pp;
+    arrayList list;
+    int maxErr, fixedColumn, lenErr, tot, skipRowColAdjust, pad;
+    pp.param = p;
+    p->error = 0;
+    if (p->options & PDF417_USE_RAW_CODEWORDS) {
+        if (p->lenCodewords > MAX_DATA_CODEWORDS || p->lenCodewords < 1 || p->lenCodewords != p->codewords[0]) {
+            p->error = PDF417_ERROR_INVALID_PARAMS;
+            return;
+        }
+    }
+    else {
+        if (p->lenText < 0)
+            p->lenText = strlen(p->text);
+        if (p->lenText > ABSOLUTE_MAX_TEXT_SIZE) {
+            p->error = PDF417_ERROR_TEXT_TOO_BIG;
+            return;
+        }
+        listInit(&list);
+        breakString(&pp, &list);
+        //dumpList(&pp, &list);
+        assemble(&pp, &list);
+        listFree(&list);
+        if (p->error)
+            return;
+        p->codewords[0] = p->lenCodewords = pp.cwPtr;
+    }
+    maxErr = maxPossibleErrorLevel(MAX_DATA_CODEWORDS + 2 - p->lenCodewords);
+    if (!(p->options & PDF417_USE_ERROR_LEVEL)) {
+        if (p->lenCodewords < 41)
+            p->errorLevel = 2;
+        else if (p->lenCodewords < 161)
+            p->errorLevel = 3;
+        else if (p->lenCodewords < 321)
+            p->errorLevel = 4;
+        else
+            p->errorLevel = 5;
+    }
+    if (p->errorLevel < 0)
+        p->errorLevel = 0;
+    else if (p->errorLevel > maxErr)
+        p->errorLevel = maxErr;
+    if (p->codeColumns < 1)
+        p->codeColumns = 1;
+    else if (p->codeColumns > 30)
+        p->codeColumns = 30;
+    if (p->codeRows < 3)
+        p->codeRows = 3;
+    else if (p->codeRows > 90)
+        p->codeRows = 90;
+    lenErr = 2 << p->errorLevel;
+    fixedColumn = !(p->options & PDF417_FIXED_ROWS);
+    skipRowColAdjust = 0;
+    tot = p->lenCodewords + lenErr;
+    if (p->options & PDF417_FIXED_RECTANGLE) {
+        tot = p->codeColumns * p->codeRows;
+        if (tot > MAX_DATA_CODEWORDS + 2) {
+            tot = getMaxSquare(p);
+        }
+        if (tot < p->lenCodewords + lenErr)
+            tot = p->lenCodewords + lenErr;
+        else
+            skipRowColAdjust = 1;
+    }
+    else if (!(p->options & (PDF417_FIXED_COLUMNS | PDF417_FIXED_ROWS))) {
+        double c, b;
+        fixedColumn = 1;
+        if (p->aspectRatio < 0.001)
+            p->aspectRatio = 0.001f;
+        else if (p->aspectRatio > 1000)
+            p->aspectRatio = 1000;
+        b = 73 * p->aspectRatio - 4;
+        c = (-b + sqrt(b * b + 4 * 17 * p->aspectRatio * (p->lenCodewords + lenErr) * p->yHeight)) / (2 * 17 * p->aspectRatio);
+        p->codeColumns = (int)(c + 0.5);
+        if (p->codeColumns < 1)
+            p->codeColumns = 1;
+        else if (p->codeColumns > 30)
+            p->codeColumns = 30;
+    }
+    if (!skipRowColAdjust) {
+        if (fixedColumn) {
+            p->codeRows = (tot - 1) / p->codeColumns + 1;
+            if (p->codeRows < 3)
+                p->codeRows = 3;
+            else if (p->codeRows > 90) {
+                p->codeRows = 90;
+                p->codeColumns = (tot - 1) / 90 + 1;
+            }
+        }
+        else {
+            p->codeColumns = (tot - 1) / p->codeRows + 1;
+            if (p->codeColumns > 30) {
+                p->codeColumns = 30;
+                p->codeRows = (tot - 1) / 30 + 1;
+            }
+        }
+        tot = p->codeRows * p->codeColumns;
+    }
+    if (tot > MAX_DATA_CODEWORDS + 2) {
+        tot = getMaxSquare(p);
+    }
+    p->errorLevel = maxPossibleErrorLevel(tot - p->lenCodewords);
+    lenErr = 2 << p->errorLevel;
+    pad = tot - lenErr - p->lenCodewords;
+    pp.cwPtr = p->lenCodewords;
+    while (pad--)
+        p->codewords[pp.cwPtr++] = TEXT_MODE;
+    p->codewords[0] = p->lenCodewords = pp.cwPtr;
+    calculateErrorCorrection(&pp, pp.param->lenCodewords);
+    pp.param->lenCodewords = tot;
+    outPaintCode(&pp);
+}
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/ppr.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/ppr.cpp
new file mode 100644
index 00000000..e6632146
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/ppr.cpp
@@ -0,0 +1,654 @@
+/**
+ *  @file      ppr.cpp
+ *
+ *  @brief     passport reader device implementation
+ *
+ *  @date      26.03.2004
+ *
+ *  @author    Materna Information & Communications (AGe)
+ *
+ ************************************************************************/
+
+#include "cussif.h"
+#include "pprdev.h"
+#include "check.h"
+#include "tracedef.h"
+#include "orbs.h"
+#include "textIDL/textcodes.h"
+#include "textIDL/texttypes.h"
+#include "textIDL/textcharacteristics.h"
+
+using namespace MASSAI::codes_text;
+using namespace MASSAI::characteristics_text;
+using namespace MASSAI::types_text;
+
+using namespace MASSAI;
+
+#define NSC_MI Characteristics::MediaInput
+
+// discard old response/indication
+void pprDevice::clearData()
+{
+  memset(abTrack1, 0, sizeof(abTrack1));
+  memset(abTrack2, 0, sizeof(abTrack2));
+  memset(abTrack3, 0, sizeof(abTrack3));
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void pprDevice::saveData(const datastream ds)
+//
+//  purpose:    save data from MSG data stream
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void pprDevice::saveData(const datastream ds)
+{
+msgDataType *pData;
+
+    ds >>= pData;
+
+    memset(abTrack1, 0, sizeof(abTrack1));
+    memset(abTrack2, 0, sizeof(abTrack2));
+    memset(abTrack3, 0, sizeof(abTrack3));
+
+    if(pData->records.length())
+    {
+      unsigned int i;
+      for
+      (
+        i = 0;
+        pData->records.length() >= 1
+          && i < pData->records[0].message.length()
+          && i < sizeof(abTrack1);
+        i++
+      )
+      {
+        abTrack1[i] = pData->records[0].message[i];
+      }
+
+      for
+      (
+        i = 0;
+        pData->records.length() >= 2
+          && i < pData->records[1].message.length()
+          && i < sizeof(abTrack2);
+        i++
+      )
+      {
+        abTrack2[i] = pData->records[1].message[i];
+      }
+
+      for
+      (
+        i = 0;
+        pData->records.length() >= 3
+          && i < pData->records[2].message.length()
+          && i < sizeof(abTrack3);
+        i++
+      )
+      {
+        abTrack3[i] = pData->records[2].message[i];
+      }
+
+      trace(_HERE_7, "T1 = [%s]", abTrack1);
+      trace(_HERE_7, "T2 = [%s]", abTrack2);
+      trace(_HERE_7, "T3 = [%s]", abTrack3);
+    }
+    else
+      trace(_HERE_7, "no ppr data stored");
+
+    return;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void pprDevice::readerCallback(const Event &ev, int id)
+//
+//  purpose:    callback function for the reader component
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void pprDevice::readerCallback(const Event &ev, int id)
+{
+    vCompReader::lError = ev.statusCode;
+
+    trace(_HERE_1, "Reader (%d); event code: (%s) (%d), status code: (%s) (%d) for %s", id, eventCodesText(ev.eventCode).c_str(), ev.eventCode, scString(ev.statusCode).c_str(), ev.statusCode, ev.functionName.in());
+
+    if(!*ev.functionName && ev.statusCode == m_statuscodes::OK)
+    {
+      // unsolicited event ??
+      if(!eventReceived(ev))
+        handleException(ev.eventCode, ev.statusCode, ev.functionName.in());
+    }
+    else if(!eventReceived(ev))
+    {
+      switch(ev.statusCode)
+      {
+      case m_statuscodes::OK:                                break;
+      case m_statuscodes::MEDIA_PRESENT: passportInserted(); break;
+      case m_statuscodes::MEDIA_ABSENT:  passportRemoved();  break;
+
+      case m_statuscodes::DATA_PRESENT:  dataPresent();      break;
+
+      case m_statuscodes::TIMEOUT:       commandTimeout();   break;
+      case m_statuscodes::CANCELLED:     commandCancelled(); break;
+      default:                           handleException(ev.eventCode, ev.statusCode, ev.functionName.in()); break;
+      }
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long pprDevice::open(long lTimeOut)
+//
+//  purpose:    enable device for passport insertion
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long pprDevice::open(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+    clearData();
+    if(vcReader.isConnected())
+    {
+      if(((rc = vcReader.enable(lTimeOut, ev)) != 0) || (lTimeOut < 0))
+      {
+        trace(_HERE_7, "open ppr: (%s) (%d)", rcString(rc).c_str(), rc);
+        return(rc);
+      }
+      else
+        return(checkStatusCode(ev));
+    }
+    else
+      return(missingComponent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long pprDevice::close(long lTimeOut)
+//
+//  purpose:    disable device from passport insertion
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long pprDevice::close(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcReader.isConnected())
+    {
+      if(((rc = vcReader.disable(lTimeOut, ev)) != 0) || (lTimeOut < 0))
+        return(rc);
+      else
+        return(checkStatusCode(ev));
+    }
+    else
+      return(missingComponent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long pprDevice::cancel(long lTimeOut)
+//
+//  purpose:    cancel the last command (read or eject)
+//
+//  date:       26.03.2004
+//
+//  author:      Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long pprDevice::cancel(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcReader.isConnected())
+    {
+      rc = vcReader.cancel(ev);
+
+      return(rc);
+    }
+    else
+      return(missingComponent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long pprDevice::read(long lTimeOut)
+//
+//  purpose:    read bdata from vitual component
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long pprDevice::read(long lTimeOut, Event_out ev)
+{
+long rc = 0;
+
+    if(vcReader.isConnected())
+    {
+      if(((rc = vcReader.receive(lTimeOut, ev)) != 0) || (lTimeOut < 0))
+      {
+        trace(_HERE_7, "receive() for passport data, rc = (%s) (%d)", rcString(rc).c_str(), rc);
+
+        return(rc);
+      }
+      else
+      {
+        // handle returned data directly if synchronous call !!
+
+        TypeCode_ptr tcp = ev->eventData.type();
+
+        if(tcp->equivalent(_tc_msgDataType))
+        {
+          trace(_HERE_7, "received msgDataType");
+
+          if(ev->statusCode  == m_statuscodes::OK
+            || ev->statusCode == m_statuscodes::DATA_PRESENT)
+          {
+            saveData(ev->eventData);
+          }
+          else
+          {
+            if(ev->statusCode  == m_statuscodes::DATA_MISSING)
+            {
+              clearData();
+            }
+            eventReceived(*ev);
+          }
+        }
+        else
+        {
+          trace(_HERE_7, "received invalid DataType");
+        }
+      }
+
+      return(checkStatusCode(ev));
+    }
+    else
+      return(missingComponent);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   char *pprDevice::getTrack1()
+//
+//  purpose:    return data from track 1
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+char *pprDevice::getTrack1()
+{
+    return(abTrack1);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   char *pprDevice::getTrack2()
+//
+//  purpose:    return data from track 2
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+char *pprDevice::getTrack2()
+{
+    return(abTrack2);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   char *pprDevice::getTrack3()
+//
+//  purpose:    return data from track 3
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+char *pprDevice::getTrack3()
+{
+    return(abTrack3);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void pprDevice::passportInserted()
+//
+//  purpose:    called upon passport insertion event (virtual)
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void pprDevice::passportInserted()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void pprDevice::dataPresent()
+//
+//  purpose:    called upon passport data presence (virtual)
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void pprDevice::dataPresent()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void pprDevice::passportRemoved()
+//
+//  purpose:    called upon passport rempval event (virtual)
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void pprDevice::passportRemoved()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void pprDevice::commandTimeout()
+//
+//  purpose:    called if command timeout has occurred
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void pprDevice::commandTimeout()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void pprDevice::commandCancelled()
+//
+//  purpose:    calles if command has been cancelled
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void pprDevice::commandCancelled()
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void pprDevice::handleException(long eventCode,
+//                                              long statusCode,
+//                                              const char *pszFunction)
+//
+//  purpose:    called if an unhandled status code (error) has been received
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void pprDevice::handleException(long eventCode, long statusCode, const char *pszFunction)
+{
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   bool pprDevice::eventReceived(long eventCode,
+//                                            long statusCode,
+//                                            const char *pszFunction)
+//
+//  purpose:
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+bool pprDevice::eventReceived (const Event& ev)
+{
+  return eventReceived(ev.eventCode, ev.statusCode, ev.functionName.in());
+}
+bool pprDevice::eventReceived(long eventCode, long statusCode, const char *pszFunction)
+{
+    return(false);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   readertype pprDevice::readerType()
+//
+//  purpose:    return the reader type from characteristics
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+pprDevice::readertype pprDevice::readerType()
+{
+pprDevice::readertype rt = RT_ERROR;
+char       szTmp[256];
+
+    if(vcReader.isConnected())
+    {
+      switch(vcReader.getTypeOfReader())
+      {
+      case NSC_MI::Motorized:
+
+           strcpy(szTmp, "Motorized");
+           rt = RT_MOTORIZED;
+           break;
+
+      case NSC_MI::Swipe:
+
+           strcpy(szTmp, "Swipe");
+           rt = RT_SWIPE;
+           break;
+
+      case NSC_MI::Contactless:
+
+           strcpy(szTmp, "Contactless");
+           rt = RT_CONTACTLESS;
+           break;
+
+      case NSC_MI::DIP:
+
+           strcpy(szTmp, "DIP");
+           rt = RT_DIP;
+           break;
+
+      case NSC_MI::nonApplicableReaderType:
+
+           strcpy(szTmp, "nonApplicableReaderType");
+           rt = RT_ERROR;
+           break;
+
+      case NSC_MI::FlatbedScan:
+
+           strcpy(szTmp, "FlatbedScan");
+           rt = RT_FLATBED;
+           break;
+
+      case NSC_MI::PenScan:
+
+           strcpy(szTmp, "PenScan");
+           rt = RT_PENSCAN;
+           break;
+      }
+
+      trace(_HERE_7, "ReaderType = %s", szTmp);
+    }
+
+    return(rt);
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long pprDevice::status(comptype ct)
+ *
+ *  @brief     query status on specific virtual component
+ *
+ *  @date      20.10.2004
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long pprDevice::status(comptype ct, Event_out ev)
+{
+  return status(BLOCK_, ct, ev);
+}
+long pprDevice::status(long lTimeout, comptype ct, Event_out ev)
+{
+long      rc = missingComponent;
+
+    try
+    {
+      switch(ct)
+      {
+      case vCompReader::reader:
+
+           if(vcReader.isConnected())
+           {
+             if((rc = vcReader.query(lTimeout, ev)) == 0 &&(lTimeout >= 0))
+               rc = ev->statusCode;
+           }
+           break;
+      }
+    }
+    catch(...) {}
+
+    trace(_HERE_7, "status query result: %s, rc = %d", scString(rc).c_str(), rc);
+
+    return(rc);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   pprDevice::pprDevice(amInterface *pAmi)
+//
+//  purpose:    class constructor - aquire virutal components
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+pprDevice::pprDevice(amInterface *pAmi):
+  vCompReader(pAmi),
+  vcReader(static_cast<vCompReader*>(this))
+{
+long             lIndex;
+
+    memset(abTrack1, 0, sizeof(abTrack1));
+    memset(abTrack2, 0, sizeof(abTrack2));
+    memset(abTrack3, 0, sizeof(abTrack3));
+
+    try
+    {
+      // try to connect all virtual components
+
+      lIndex = 0;
+      vcReader.storeIOR(pAmi->ior(lIndex, "PassportReader", "MediaInput"));
+
+      if(vcReader.canConnect())
+      {
+        realComponent= "PassportReader";
+        trace(_HERE_7, "use realcomponent: PassportReader");
+      }
+      else
+      {
+        const char* pszRealComponent= 0;
+        amInterface::MediaTypeSet mediatype;
+        amInterface::DataTypeSet datatype;
+        mediatype.insert(Characteristics::MediaType::Printed);
+        datatype.insert(Characteristics::MSG);
+        lIndex= 0;
+        pszRealComponent= pAmi->queryMediaInput(lIndex, Characteristics::ComponentFonts::nonApplicableBarcodeStandard, mediatype, datatype);
+        // pszRealComponent= pAmi->queryMediaInput(lIndex, mediatype, datatype);
+        if(pszRealComponent)
+        {
+          realComponent= pszRealComponent;
+          trace(_HERE_7, "use realcomponent: %s", pszRealComponent);
+          vcReader.storeIOR(pAmi->ior(lIndex, pszRealComponent, "MediaInput"));
+        }
+      }
+
+      strcpy(vCompReader::szAppRef, pAmi->getAppReference());
+    }
+    catch(CORBA::SystemException& ex)
+    {
+      trace(_HERE_7, "CORBA::SystemException:\n%s", ex._message());
+    }
+
+    vcReader.connect();
+    vcReader.setListener();
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   pprDevice::~pprDevice()
+//
+//  purpose:    class destructor - release aquired virtual components
+//
+//  date:       26.03.2004
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+pprDevice::~pprDevice()
+{
+  vcReader.clearListener();
+}
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/svg.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/svg.cpp
new file mode 100644
index 00000000..d9abe096
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/svg.cpp
@@ -0,0 +1,212 @@
+/**
+ **************************************************************************
+ *
+ * @file svg.cpp
+ *
+ * svg template implementation
+ *
+ * @author SteT
+ *
+ * Copyright (c) 2003, MATERNA Information & Communications
+ *
+ **************************************************************************
+**/
+
+#include "language.h"
+#include "gppdevice.h"
+#include "dispMap.h"
+#include "asso.h"
+
+#include "tracedef.h"
+#include "assotrace.h"
+
+
+/** Wrapper class for easier SVG construction */
+
+/*
+    long    lError;
+    long    lLangId;
+    //char  fileName[1024];
+    //char   *pBuffer;
+    aMap    memberMap;
+    string  fileName;
+    string  buffer;
+*/
+
+/** Returns the current error, 0 if none */
+
+using namespace MASSAI;
+
+
+long svg::error()
+{
+  return lError;
+}
+
+
+
+int loadTemplate(const char* pScreenId, const char* pTemplate, string& Template, language& resource)
+{
+  string File;
+  int result;
+
+  File= pScreenId;
+  File+= "\\";
+  File+= pTemplate;  // search the file in the directory named by screenid
+  result= loadTemplate(File.c_str(), pTemplate, Template, resource, false);
+  if (result != 0)
+  {
+    // if file does not exist in the ScreenId directory, search in language directory
+    result= loadTemplate(pTemplate, pTemplate, Template, resource, false);
+  }
+  return result;
+}
+
+/** Returns the final SVG data stream, NULL on error */
+
+const char *svg::getData()
+{
+  if (buffer.length() == 0)
+  {
+    language lang(lLangId, (char *) langPath.c_str());
+    aMap DataIn, DataUsed, SectionError;
+    aObject DataOut, DataError, Value;
+    string ScreenId("SVG");
+    const aObject *pItem;
+    string FileContent, Result;
+    // get the template filename
+
+    // iterate section entries
+    // collect translated values in DataIn
+    pItem= 0;
+    while((pItem= memberMap.getNextKey(pItem)) != 0)
+    {
+      Value= memberMap.get(*pItem);
+      if (pItem->getTag() == OBJ_STR)
+      {
+        if (Value.getTag() == OBJ_STR)
+        {
+          DataOut.clr();
+          DataError.clr();
+          transData(ScreenId.c_str(), Value, DataOut, DataError, lang);
+          if (DataError.getTag() == OBJ_STR)
+          {
+            SectionError.set(*pItem, DataError);
+            trace(_HERE_7, "getData error for (%s)", pItem->strObject());
+          }
+          if (DataOut.getTag() == OBJ_STR)
+          {
+            DataIn.set(*pItem, DataOut);
+            trace(_HERE_9, "getData response for (%s) is (%s)", pItem->strObject(), DataOut.strObject());
+          }
+          else
+            trace(_HERE_9, "getData response for (%s) is empty", pItem->strObject());
+        }
+        else if (Value.getTag() == OBJ_NUM)
+        {
+          // numObject need not to be translated
+          DataIn.set(*pItem, Value);
+        }
+        else
+        {
+          SectionError.set(*pItem, Value);
+          trace(_HERE_7, "getData invalid data for (%s)", pItem->strObject());
+        }
+      }
+      else
+      {
+        SectionError.set(*pItem, Value);
+        trace(_HERE_7, "getData invalid data for (%s)", pItem->strObject());
+      }
+    }
+
+    // fill the template
+    if (loadTemplate(ScreenId.c_str(), fileName.c_str(), FileContent, lang) != 0)
+      SectionError.set(-1, fileName.c_str());
+    fillTemplate(FileContent, DataIn, Result, DataUsed, SectionError);
+    buffer= Result.c_str();
+
+    // check unused entries
+    pItem= 0;
+    while((pItem= DataIn.getNextKey(pItem)) != 0)
+    {
+      if (DataUsed.get(*pItem).numObject() != 1)
+      {
+        trace(_HERE_7, "(%s)->(%s) not used", pItem->strObject(), DataIn.get(*pItem).strObject());
+        SectionError.set(*pItem, DataIn.get(*pItem));
+      }
+    }
+  }
+  if (buffer.length() == 0)
+    return 0;
+  else
+    return buffer.c_str();
+}
+
+/** Substitutes a member in the SVG file.
+    @param pszName - The name of the variable
+    @param pszText - The text for the specified variable
+*/
+
+svg& svg::member(const char *pszName, const char *pszText)
+{
+  buffer.erase();
+  if (pszName != 0 && pszText != 0)
+  {
+    memberMap.set(pszName, pszText);
+    lError= 0;
+  }
+  else
+    lError= INVALID_PARAM;
+  return *this;
+}
+
+/** Substitutes one or more members in the SVG file as specified in the map.
+    @param data - A map specifying the data to be used for the template file
+*/
+
+svg& svg::member(const aMap& data)
+{
+  buffer.erase();
+  lError= 0;
+  const aObject *pKey = 0;
+  while((pKey= data.getNextKey(pKey)) != 0)
+  {
+    if (pKey->getTag() == OBJ_STR && data.get(*pKey).getTag() == OBJ_STR)
+    {
+      memberMap.set(pKey->strObject(), data.get(pKey->strObject()));
+    }
+    else
+      lError= INVALID_PARAM;
+  }
+  return *this;
+}
+
+/** Class constructor.
+    @param pszFile - The name of the SVG template file to use for this member
+    @param languageId - The language identifier
+*/
+
+svg::svg(const char *pszFile, long languageId, const char* pszLangPath)
+{
+  lError= 0;
+  if (pszFile != 0)
+    fileName= pszFile;
+  else
+    lError= INVALID_PARAM;
+  if (pszLangPath != 0)
+    langPath= pszLangPath;
+
+  lLangId= languageId;
+}
+
+
+/**
+ **************************************************************************
+ *
+ * End of file
+ *
+ **************************************************************************
+**/
+
+
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/testLevel.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/testLevel.cpp
new file mode 100644
index 00000000..b7874f26
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/testLevel.cpp
@@ -0,0 +1,118 @@
+// call level on ApplicationManager
+#include "comps.h"
+#include "massaiCorba/corbaclnt.h"
+#include "text/mArgScan.hpp"
+#include "textIDL/texttypes.h"
+#include "tools/localtrace.h"
+#include <iostream>
+
+using namespace MASSAI::localtrace;
+using namespace massaiCorba;
+
+namespace
+{
+  std::string option(argScan& args, const std::string& key, const std::string& defaultValue)
+  {
+    std::string result;
+    const char* value = args.option(key.c_str());
+    if(value)
+    {
+      result = value;
+    }
+    else
+    {
+      result = defaultValue;
+    }
+    return result;
+  }
+
+  void printUsage(int argc, char** argv, char* error= 0)
+  {
+    std::cout << std::endl;
+    std::cout << argv[0];
+    std::cout << " [-host:<remoteServantHost, default localhost>]";
+    std::cout << " [-port:<remoteservantPort, default 20000>]";
+    std::cout << " [-servant:<remoteServantName, default ApplicationManager>]";
+    std::cout << " [-comp:<companyCode, default MAT>]";
+    std::cout << " [-app:<applicationName, default CLA>]";
+    std::cout << " [-host:<remoteServantHost, default localhost>]";
+    std::cout << std::endl;
+    if(error)
+    {
+      std::cout << error << std::endl;
+    }
+    else
+    {
+      std::cout << "repeated create and destroy corba clients" << std::endl;
+    }
+  }
+}
+
+int main(int argc, char** argv)
+{
+  int result = 0;
+  argScan args(argc, argv);
+  std::string host= option(args, "HOST", "localhost");
+  std::string servant= option(args, "SERVANT", "ApplicationManager");
+  int port = args.optionInteger("PORT", 20000);
+  std::string companyCode= option(args, "COMP", "MAT");
+  std::string applicationName= option(args, "APP", "CLA");
+  if(args.help())
+  {
+    printUsage(argc, argv);
+    result= 1;
+  }
+  else
+  {
+    openTrace(argv[0]);
+    try
+    {
+      writeTrace(BasicRuntime_HERE, "create client (%s:%d/%s)", host.c_str(), port, servant.c_str());
+      corbaClient<Components::ApplicationManager> clt(host.c_str(), port, servant.c_str());
+      Components::ApplicationManager* clientProxy = clt.proxy();
+      if(clientProxy != 0)
+      {
+        for(;;)
+        {
+          try
+          {
+            types::EnvironmentLevel_var el;
+            types::akID akid;
+            akid.companyCode     = string_dup(companyCode.c_str());
+            akid.applicationName = string_dup(applicationName.c_str());
+            akid.vendorCode      = string_dup("None");
+            akid.kioskName       = string_dup("None");
+            writeTrace(BasicRuntime_HERE, "call level (%s)", MASSAI::types_text::akIDText(akid).c_str());
+            clientProxy->level(akid, el);
+            writeTrace(BasicRuntime_HERE, "Environment: (%s)", MASSAI::types_text::environmentLevelText(el).c_str());
+          }
+          catch(const CORBA::Exception& ex)
+          {
+            writeTrace(MajorError_HERE, "call level (%s)", ex._message());
+          }
+          catch(...)
+          {
+            writeTraceText(MajorError_HERE, "call level failed");
+          }
+          std::cout << "continue?" << std::endl;
+          char buffer[20];
+          std::cin >> buffer;
+        }
+      }
+      else
+      {
+        writeTraceText(MajorError_HERE, "client proxy ist null");
+      }
+    }
+    catch(const CORBA::Exception& ex)
+    {
+      writeTrace(MajorError_HERE, "create client failed (%s)", ex._message());
+    }
+    catch(...)
+    {
+      writeTraceText(MajorError_HERE, "create client failed");
+    }
+    closeTrace();
+  }
+  return result;
+}
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/testScreenConversion.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/testScreenConversion.cpp
new file mode 100644
index 00000000..edf80b34
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/testScreenConversion.cpp
@@ -0,0 +1,84 @@
+#include "dispmap.h"
+#include "language.h"
+#include "dispdev.h"
+#include <iostream>
+
+int transScreenId(const aMap& ScreenIdIn, aMap& ScreenIdOut, aMap& ScreenIdError, language& resource);
+
+static void dumpMap( long lLevel, const aMap& Map, std::ostream& os, const char * pszTab )
+{
+   const aObject *pKey = 0;
+   while( ( pKey = Map.getNextKey( pKey )) != 0 )
+   {
+      //
+      // Write indentation
+      //
+      for( int i=0; i< lLevel; i++ ) os << pszTab;
+      //
+      // Write key
+      //
+      switch(pKey->getTag())
+      {
+      case OBJ_NUM:
+         os << pKey->numObject();
+         break;
+      case OBJ_STR:
+         os << pKey->strObject();
+         break;
+      }
+      //
+      // Write value
+      //
+      switch (Map.get(*pKey).getTag())
+      {
+      case OBJ_NUM:
+         os << " = " << Map.get(*pKey).numObject() << std::endl;
+         break;
+      case OBJ_STR:
+         os << " = " << Map.get(*pKey).strObject() << std::endl;
+         break;
+      case OBJ_MAP:
+         os << " =" << std::endl;
+         dumpMap( lLevel+1, Map.get(*pKey).mapObject(), os, pszTab );
+         break;
+      }
+   }
+}
+
+void dumpMap( std::ostream *pOS, const aMap& Map )
+{
+   if( pOS ) dumpMap( 1, Map, *pOS, " " );
+}
+
+
+
+int main(int argc, char** argv)
+{
+  MASSAI::screen scr("TestScreen", MASSAI::screen::ENCODING_GB2312);
+  aMap data;
+  char c1[]= {0xbb, 0xc6, 0};
+  char c2[]= {0xce, 0xb0, 0};
+  char c3[]= {0xba, 0xc0, 0};
+  std::string text= "Zeichen 1: ";
+  text+= c1;
+  text+= "; Zeichen 2 und 3: ";
+  text+= c2;
+  text+= c3;
+  text+= "!";
+
+  data.set("TestValue", text.c_str());
+  scr.member("TestMember", data);
+  aMap output;
+  aMap error;
+  language lang;
+  transScreenId(scr, output, error, lang);
+
+  std::cout << "screen" << std::endl;
+  dumpMap(&std::cout, scr);
+  std::cout << "output" << std::endl;
+  dumpMap(&std::cout, output);
+  std::cout << "error" << std::endl;
+  dumpMap(&std::cout, error);
+
+  return 0;
+}
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/testapp.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/testapp.cpp
new file mode 100644
index 00000000..c14d1ca2
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/testapp.cpp
@@ -0,0 +1,649 @@
+#include "cussif/atb2Scanner.h"
+#include "cussif/atbreader.h"
+#include "cussif/baggagedev.h"
+#include "cussif/bcsdev.h"
+#include "cussif/bppdev.h"
+#include "cussif/btpdev.h"
+#include "cussif/btpScanner.h"
+#include "cussif/clock.h"
+#include "cussif/cussif.h"
+#include "cussif/dispclnt.h"
+#include "cussif/dispdev.h"
+#include "cussif/escrowdev.h"
+#include "cussif/fprdev.h"
+#include "cussif/gppdevice.h"
+#include "cussif/manufacturer.h"
+#include "cussif/mcdev.h"
+#include "cussif/pprdev.h"
+#include "text/mArgScan.hpp"
+#include "Tools/localtrace.h"
+#include "mEventSem.hpp"
+
+
+
+using namespace MASSAI;
+using namespace MASSAI::localtrace;
+
+
+namespace
+{
+  Materna::MSSD::eventSemaphore initDone;
+
+  class my_cussApplication: public cussApplication
+  {
+    public:
+      my_cussApplication(const char* pszApplicationManagagerIOR, const char* pszCompanyCode, const char* pszApplicationName):
+        cussApplication((char*)pszApplicationManagagerIOR, (char*)pszCompanyCode, (char*)pszApplicationName, 0)
+      {}
+      ~my_cussApplication()
+      {}
+    private:
+      virtual void appmgrLost()
+      {
+        writeTraceText(MajorError_HERE, "appmgrLost");
+      }
+      virtual void platformEvent(long eventCode, long statusCode)
+      {
+      }
+      virtual long disable()
+      {
+        writeTraceText(MajorError_HERE, "disable");
+        return 0;
+      }
+      virtual long activate(EnvironmentLevel_var el)
+      {
+        writeTraceText(MajorError_HERE, "activate");
+        return 0;
+      }
+      virtual long stop()
+      {
+        writeTraceText(MajorError_HERE, "stop");
+        return 0;
+      }
+      virtual long suspend()
+      {
+        writeTraceText(MajorError_HERE, "suspend");
+        return 0;
+      }
+      virtual long resume()
+      {
+        writeTraceText(MajorError_HERE, "resume");
+        return 0;
+      }
+      virtual long idle()
+      {
+        writeTraceText(MajorError_HERE, "idle");
+        return 0;
+      }
+      virtual long initialize(EnvironmentLevel_var el)
+      {
+        writeTraceText(MajorError_HERE, "initialize");
+        initDone.post();
+        return 0;
+      }
+      virtual long massaiTrace(long lLevel, char *pszFile, long sLine, char *pText)
+      {
+        writeTraceText(lLevel, pszFile, static_cast<short>(sLine), "", pText);
+        return 0;
+      }
+      virtual long massaiCryptTrace(long lLevel, char *pszFile, long sLine, char *pData, long lLen)
+      {
+        dumpTrace(lLevel, pszFile, static_cast<short>(sLine), "", lLen, pData);
+        return 0;
+      }
+      virtual long criticalError(int iSignal)
+      {
+        writeTrace(MajorError_HERE, "criticalError (%d)", iSignal);
+        return 0;
+      }
+      virtual long userBreak(int iSignal)
+      {
+        writeTrace(MajorError_HERE, "userBreak (%d)", iSignal);
+        return 0;
+      }
+  };
+
+  class my_atbReader: public atbReader
+  {
+    public:
+      my_atbReader(amInterface *pAmi):
+        atbReader(pAmi)
+      {}
+      ~my_atbReader()
+      {}
+    private:
+      virtual void couponInserted()
+      {
+      }
+      virtual void dataPresent()
+      {
+      }
+      virtual void couponEjected()
+      {
+      }
+      virtual void couponRemoved()
+      {
+      }
+      virtual void printerClosed(long lStatusCode)
+      {
+      }
+      virtual void setupError(const long lStatusCode, const char *pszError)
+      {
+      }
+      virtual void setupResponse()
+      {
+      }
+      virtual void commandTimeout()
+      {
+      }
+      virtual void commandCancelled()
+      {
+      }
+      virtual void handleException(long eventCode, long statusCode, const char *pszFunction)
+      {
+      }
+      virtual bool eventReceived(const Event& ev)
+      {
+        return false;
+      }
+      virtual bool eventReceived(long eventCode, long statusCode, const char *pszFunction)
+      {
+        return false;
+      }
+  };
+
+  class my_baggageDevice: public baggageDevice
+  {
+    public:
+      my_baggageDevice(amInterface *pAmi):
+        baggageDevice(pAmi)
+      {}
+      ~my_baggageDevice()
+      {}
+    private:
+      virtual void baggagePresent()
+      {
+      }
+      virtual void baggageRemoved()
+      {
+      }
+      virtual void baggageParked()
+      {
+      }
+      virtual void baggageDelivered()
+      {
+      }
+      virtual void baggageOversized()
+      {
+      }
+      virtual void baggageWeightChanged()
+      {
+      }
+      virtual void dataPresent()
+      {
+      }
+      virtual void commandTimeout()
+      {
+      }
+      virtual void commandCancelled()
+      {
+      }
+      virtual void commandPerformed(long eventCode, long statusCode, const char *pszFunction)
+      {
+      }
+      virtual void handleException(long eventCode, long statusCode, const char *pszFunction)
+      {
+      }
+      virtual bool eventReceived(const Event& ev)
+      {
+        return false;
+      }
+      virtual bool eventReceived(long eventCode, long statusCode, const char *pszFunction)
+      {
+        return false;
+      }
+  };
+
+  class my_bcsDevice: public bcsDevice
+  {
+    public:
+      my_bcsDevice(amInterface *pAmi):
+        bcsDevice(pAmi)
+      {}
+      ~my_bcsDevice()
+      {}
+    private:
+      virtual void dataPresent()
+      {
+      }
+      virtual void documentInserted()
+      {
+      }
+      virtual void documentRemoved()
+      {
+      }
+      virtual void commandTimeout()
+      {
+      }
+      virtual void commandCancelled()
+      {
+      }
+      virtual void handleException(long eventCode, long statusCode, const char *pszFunction)
+      {
+      }
+      virtual bool eventReceived(const Event& ev)
+      {
+        return false;
+      }
+      virtual bool eventReceived(long eventCode, long statusCode, const char *pszFunction)
+      {
+        return false;
+      }
+  };
+
+  class my_bppDevice: public bppDevice
+  {
+    public:
+      my_bppDevice(amInterface *pAmi):
+        bppDevice(pAmi)
+      {}
+      ~my_bppDevice()
+      {}
+    private:
+      virtual void couponInserted()
+      {
+      }
+      virtual void dataPresent()
+      {
+      }
+      virtual void couponEjected()
+      {
+      }
+      virtual void printerClosed(long lStatusCode)
+      {
+      }
+      virtual void printError(const long lStatusCode, const char *pszError)
+      {
+      }
+      virtual void couponPrinted()
+      {
+      }
+      virtual void couponPrinted(const ComponentId& id)
+      {
+      }
+      virtual void setupResponse()
+      {
+      }
+      virtual void setupResponse(const ComponentId& id)
+      {
+      }
+      virtual void commandTimeout()
+      {
+      }
+      virtual void commandTimeout(const ComponentId& id)
+      {
+      }
+      virtual void commandCancelled()
+      {
+      }
+      virtual void commandCancelled(const ComponentId& id)
+      {
+      }
+      virtual void handleException(long eventCode, long statusCode, const char *pszFunction)
+      {
+      }
+      virtual void handleException(long eventCode, long statusCode, const char *pszFunction, const ComponentId& id)
+      {
+      }
+      virtual bool eventReceived(const Event& ev)
+      {
+        return false;
+      }
+      virtual bool eventReceived(const Event& ev, const ComponentId& id)
+      {
+        return false;
+      }
+      virtual bool eventReceived(long eventCode, long statusCode, const char *pszFunction)
+      {
+        return false;
+      }
+      virtual bool eventReceived(long eventCode, long statusCode, const char *pszFunction, const ComponentId& id)
+      {
+        return false;
+      }
+  };
+
+  class my_btpDevice: public btpDevice
+  {
+    public:
+      my_btpDevice(amInterface *pAmi):
+        btpDevice(pAmi)
+      {}
+      ~my_btpDevice()
+      {}
+    private:
+      virtual void bagtagEjected()
+      {
+      }
+      virtual void printError(const long lStatusCode, const char *pszError)
+      {
+      }
+      virtual void bagtagPrinted()
+      {
+      }
+      virtual void setupResponse()
+      {
+      }
+      virtual void commandTimeout()
+      {
+      }
+      virtual void commandCancelled()
+      {
+      }
+      virtual void handleException(long eventCode, long statusCode, const char *pszFunction)
+      {
+      }
+      virtual bool eventReceived(const Event& ev)
+      {
+        return false;
+      }
+      virtual bool eventReceived(long eventCode, long statusCode, const char *pszFunction)
+      {
+        return false;
+      }
+  };
+
+  class my_clock: public clock
+  {
+    public:
+      my_clock(amInterface *pAmi):
+        clock(pAmi)
+      {}
+      ~my_clock()
+      {}
+    private:
+
+      virtual void commandTimeout()
+      {
+      }
+      virtual void commandCancelled()
+      {
+      }
+      virtual void handleException(long eventCode, long statusCode, const char *pszFunction)
+      {
+      }
+      virtual bool eventReceived(const Event& ev)
+      {
+        return false;
+      }
+      virtual bool eventReceived(long eventCode, long statusCode, const char *pszFunction)
+      {
+        return false;
+      }
+  };
+
+  class my_displayXTRA: public displayXTRA
+  {
+    public:
+      my_displayXTRA(char *pszIOR, amInterface *pAmi):
+        displayXTRA(pszIOR, pAmi)
+      {}
+      ~my_displayXTRA()
+      {}
+    private:
+       virtual void displayInput
+       (
+         char *pszScreenId,
+         long  languageId,
+         long  lError,
+         long  lValue,
+         char *pszButton,
+         char *pszValue
+       )
+       {
+       }
+  };
+
+  class my_escrowDevice: public escrowDevice
+  {
+    public:
+      my_escrowDevice(amInterface *pAmi):
+        escrowDevice(pAmi)
+      {}
+      ~my_escrowDevice()
+      {}
+    private:
+      virtual void couponsRemoved()
+      {
+      }
+      virtual void couponsRetracted()
+      {
+      }
+      virtual void commandTimeout()
+      {
+      }
+      virtual void commandCancelled()
+      {
+      }
+      virtual void handleException(long eventCode, long statusCode, const char *pszFunction)
+      {
+      }
+      virtual bool eventReceived(const Event& ev)
+      {
+        return false;
+      }
+      virtual bool eventReceived(long eventCode, long statusCode, const char *pszFunction)
+      {
+        return false;
+      }
+  };
+
+  class my_fprDevice: public fprDevice
+  {
+    public:
+      my_fprDevice(amInterface *pAmi):
+        fprDevice(pAmi)
+      {}
+      ~my_fprDevice()
+      {}
+    private:
+      virtual void dataPresent()
+      {
+      }
+      virtual void commandTimeout()
+      {
+      }
+      virtual void commandCancelled()
+      {
+      }
+      virtual void handleException(long eventCode, long statusCode, const char *pszFunction)
+      {
+      }
+      virtual bool eventReceived(const Event& ev)
+      {
+        return false;
+      }
+      virtual bool eventReceived(long eventCode, long statusCode, const char *pszFunction)
+      {
+        return false;
+      }
+  };
+
+  class my_gppDevice: public gppDevice
+  {
+    public:
+      my_gppDevice(amInterface *pAmi):
+        gppDevice(pAmi)
+      {}
+      ~my_gppDevice()
+      {}
+    private:
+      virtual void dataPrinted()
+      {
+      }
+      virtual void commandTimeout()
+      {
+      }
+      virtual void commandCancelled()
+      {
+      }
+      virtual void handleException(long eventCode, long statusCode, const char *pszFunction)
+      {
+      }
+      virtual bool eventReceived(const Event& ev)
+      {
+        return false;
+      }
+      virtual bool eventReceived(long eventCode, long statusCode, const char *pszFunction)
+      {
+        return false;
+      }
+  };
+
+  class my_magCardDevice: public magCardDevice
+  {
+    public:
+      my_magCardDevice(amInterface *pAmi):
+        magCardDevice(pAmi)
+      {}
+      ~my_magCardDevice()
+      {}
+    private:
+      virtual void cardInserted()
+      {
+      }
+      virtual void dataPresent()
+      {
+      }
+      virtual void cardEjected()
+      {
+      }
+      virtual void cardRemoved()
+      {
+      }
+      virtual void cardRetracted()
+      {
+      }
+      virtual void commandTimeout()
+      {
+      }
+      virtual void commandCancelled()
+      {
+      }
+      virtual void handleException(long eventCode, long statusCode, const char *pszFunction)
+      {
+      }
+      virtual bool eventReceived(const Event& ev)
+      {
+        return false;
+      }
+      virtual bool eventReceived(long eventCode, long statusCode, const char *pszFunction)
+      {
+        return false;
+      }
+  };
+
+  class my_pprDevice: public pprDevice
+  {
+    public:
+      my_pprDevice(amInterface *pAmi):
+        pprDevice(pAmi)
+      {}
+      ~my_pprDevice()
+      {}
+    private:
+      virtual void passportInserted()
+      {
+      }
+      virtual void dataPresent()
+      {
+      }
+      virtual void passportRemoved()
+      {
+      }
+      virtual void commandTimeout()
+      {
+      }
+      virtual void commandCancelled()
+      {
+      }
+      virtual void handleException(long eventCode, long statusCode, const char *pszFunction)
+      {
+      }
+      virtual bool eventReceived(const Event& ev)
+      {
+        return false;
+      }
+      virtual bool eventReceived(long eventCode, long statusCode, const char *pszFunction)
+      {
+        return false;
+      }
+  };
+
+
+  void printUsage(int argc, char** argv, char* error= 0)
+  {
+    std::cout << std::endl;
+    std::cout << argv[0];
+    std::cout << " -APP_MGR:<ApplicationManagerIOR>";
+    std::cout << " -APP_COMPANY:<CompanyCode>";
+    std::cout << " -APP_ID:<ApplicationName>";
+    std::cout << std::endl;
+    if(error)
+    {
+      std::cout << error << std::endl;
+    }
+  }
+}
+
+int main(int argc, char** argv)
+{
+  int result= 0;
+  argScan args(argc, argv);
+  const char* ior= args.option("APP_MGR");
+  const char* app= args.option("APP_ID");
+  const char* company= args.option("APP_COMPANY");
+  if(args.help())
+  {
+    printUsage(argc, argv);
+    result= 1;
+  }
+  else if(!ior)
+  {
+    printUsage(argc, argv, "Please specify the ApplicationManagerIOR");
+    result= 2;
+  }
+  else if(!company)
+  {
+    printUsage(argc, argv, "Please specify the CompanyCode");
+    result= 3;
+  }
+  else if(!app)
+  {
+    printUsage(argc, argv, "Please specify the ApplicationName");
+    result= 2;
+  }
+  else
+  {
+    my_cussApplication m_cussApplication(ior, company, app);
+    m_cussApplication.setTraceLevel(9);
+    m_cussApplication.run(false);
+
+    initDone.wait();
+
+    my_bppDevice m_bppDevice(&m_cussApplication);
+    my_atbReader m_atbReader(&m_cussApplication);
+    my_baggageDevice m_baggageDevice(&m_cussApplication);
+    my_bcsDevice m_bcsDevice(&m_cussApplication);
+    my_btpDevice m_btpDevice(&m_cussApplication);
+    my_clock m_clock(&m_cussApplication);
+    // my_displayXTRA m_displayXTRA("", &m_cussApplication);
+    my_escrowDevice m_escrowDevice(&m_cussApplication);
+    my_fprDevice m_fprDevice(&m_cussApplication);
+    my_gppDevice m_gppDevice(&m_cussApplication);
+    my_magCardDevice m_magCardDevice(&m_cussApplication);
+    my_pprDevice m_pprDevice(&m_cussApplication);
+  }
+
+  return result;
+}
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/testscanner.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/testscanner.cpp
new file mode 100644
index 00000000..3885704e
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/testscanner.cpp
@@ -0,0 +1,100 @@
+#include "tracedef.h"
+#include "atb2scanner.h"
+#include "btpScanner.h"
+#include <iostream>
+#include <sstream>
+
+using namespace MASSAI;
+
+bool testbt(btpScanner::PaperTypes expect, const char* str)
+{
+    bool rc= false;
+    try
+    {
+        btpScanner scanner;
+        btpScanner::PaperTypes scan= scanner.checkPaperType(str);
+        if(scan == expect)
+        {
+            rc= true;
+        }
+        else
+        {
+            std::cout << "Unexpected result: " << scan << "!=" << expect << " in " << str << std::endl;
+        }
+    }
+    catch(...)
+    {
+        std::cout << "Exception occured while scanning document data: " << str << std::endl;
+    }
+    return rc;
+}
+bool testtk(atb2Scanner::PaperTypes expect, const char* str)
+{
+    bool rc= false;
+    try
+    {
+        atb2Scanner scanner;
+        atb2Scanner::PaperTypes scan= scanner.checkPaperType(str);
+        if(scan == expect)
+        {
+            rc= true;
+        }
+        else
+        {
+            std::cout << "Unexpected result: " << scan << "!=" << expect << " in " << str << std::endl;
+        }
+    }
+    catch(...)
+    {
+        std::cout << "Exception occured while scanning document data: " << str << std::endl;
+    }
+    return rc;
+}
+
+int main(int argc, char** argv)
+{
+    bool result= true;
+    setLevel(9);
+    if(argc == 2)
+    {
+      atb2Scanner scanner;
+      std::cout << argv[1] << std::endl;
+      atb2Scanner::PaperTypes scan= scanner.checkPaperType(argv[1]);
+      std::cout << "result: " << scan << std::endl;
+      return 0;
+    }
+    else if (argc > 2)
+    {
+      std::stringstream in;
+      std::cin >> in.rdbuf();
+      atb2Scanner scanner;
+      std::cout << in.str().c_str() << std::endl;
+      atb2Scanner::PaperTypes scan= scanner.checkPaperType(in.str().c_str());
+      std::cout << "result: " << scan << std::endl;
+      return 0;
+    }
+    else
+    {
+      if(!testbt( btpScanner::Setup,               "PS")) result= false;
+      if(!testbt( btpScanner::BaggageTag,          "BTP030801#0250D99F#031234345678#05345678#07XXX#10$Q#12MASSAITEST/DMR#14123/4567#15ZRH#42PHX#43TO #4423JAN#46PHX#48SR7001#5423JAN#57BWN#92PHX SR7001/08#")) result= false;
+      if(!testbt( btpScanner::Setup,               "BTT0308*F0540164$#01C0 1080080302BTP ADDR#02C0 1080320302#03I1 E154276141#04I1 E214276041$03#05K0 E2262703020085#07C1 5240450303#08K1 5240320303$05#10C0 7239480302#11C0 7248480302AGT#12C0 5244450302#13C0 5248450302#14C0 5248230302#15C0 7248030302#17C0 B086270503#18C0 F221270503$17#20S0M1249020850#22C0M7261480302#23C0M7264030302#24C0M5253490302#26C0ME266271207#28C0ME273270504#30S0M1274020850#32C0M7286480302#33C0M7288030302#34C0M5278490302#35C0M7297030302#36C0ME291271207#38C0ME298270504#40S0M1299020850#42C0M5303490302#43C0M7311480302#44C0M7312030302#45C0M7321030302#46C0ME315271207#48C0ME322270504#50C0 5335480302$07#52K0 5335400302$05#54C0 5335150302#56C0 5340480302$12#57C0 5340110302#82C0 5365480302$12#84C0 5369480302$13#86C0 5369220302$14#90C0 E374270302#91C0 E379270302#92C0 E384270302#95I1 E394270822$03#96C0 5398400302$07#97K0 5398270302$05#")) result= false;
+      if(!testtk(atb2Scanner::Ticket,              "TK!A!01B!020!0414DEC01!059361!09VQQ@@!0A0000/!0C CUSSAIR!10MASSAITEST/DMR!11MASSAITEST/DMR!12MASSAITEST/DMR!130!19      EUR50!1A50!1BEUR!1F    EUR15D!27      EUR65!291!2A DTM CA KRK END!2DDTM CA KRK END!32MS/ID 118293 EUR65!387!450!4600000000!47 CA MASSAI TEST / BBERG CGPR!48D!49SITI!4A1!4B0!4C000!4D0103340891!4E000 0103340891!51 OF!521!550!560!580!5BFLIGHT COUPON!FF !TK!C01!03 !06 !07 !14C/ID90R2/5O72!15B!4B3!4F1!50 1!553!561!8BC!91SA!922!93SUBJECT TO LOAD!9630OCT!97087!9830K!99CA!9ACUSSAIR!9DDTM!9F2!A0KRK!A1DORTMUND!A2KRAKOW!")) result= false;
+      if(!testtk(atb2Scanner::Ticket,              "TK(C01(01B(03 (06 (07 (14C/ID90R2/5O72(15B(4B3(4F1(50 1(553(561(8BC(91SA(922(93SUBJECT TO LOAD(9630OCT(97087(9830K(99CA(9ACUSSAIR(9DDTM(9F2(A0KRK(A1DORTMUND(A2KRAKOW(")) result= false;
+      if(!testtk(atb2Scanner::BoardingPass,        "CP#A#01W#CP#C01#02Lufthansa ETIX#04AAKATLD/KAGO MRS#07AAKATLD/KAGO MRS#08LH#09M/M #0DFRA#10KHQT2#11FRA#14MUC#15M/M #17MUC#1ALH#1D4055 #21M#22M#2410JAN#27A10 #2A0900#4BM#4CAWP2#60STAND BY#61SB M 5872 #7A005004#860#8D7#B6 #C300#C4#C7ETKT 220 1110000138#C8etix etkt etix etkt     #C9ELECTRONIC TICKET   220 1110000138#EB0122011100001383#F1010#FA0 1 211 1 1 #FF220#G0A10 #H020K#H1028#")) result= false;
+      if(!testtk(atb2Scanner::BoardingPass,        "CP:C01:01W:02Lufthansa ETIX:04AAKATLD/KAGO MRS:07AAKATLD/KAGO MRS:08LH:09M/M :0DFRA:10KHQT2:11FRA:14MUC:15M/M :17MUC:1ALH:1D4055 :21M:22M:2410JAN:27A10 :2A0900:4BM:4CAWP2:60STAND BY:61SB M 5872 :7A005004:860:8D7:B6 :C300:C4:C7ETKT 220 1110000138:C8etix etkt etix etkt     :C9ELECTRONIC TICKET   220 1110000138:EB0122011100001383:F1010:FA0 1 211 1 1 :FF220:G0A10 :H020K:H1028:")) result= false;
+      if(!testtk(atb2Scanner::InsertedDoc,         "CI$01B$4C000$4D0103340891$583$8E067$925$A7BOARDING PASS$B0XZ$B31410$B4BUSINESS$B5DTM$B6C$B9A07$BBSR$BFC$C031JAN$C10802$C55A$C81500$CBR IDS1/YCF$CD5A$CFNO$D00238$D2XXX$D4XXXXX$D5XXXXX$D6XXXX$")) result= false;
+      if(!testtk(atb2Scanner::GeneralPuposeDoc,    "CP-A-01L-CP-4C01-02General Purpose-03Test-04-")) result= false;
+      if(!testtk(atb2Scanner::GeneralPuposeDoc,    "CP_4C01_01L_02General Purpose_03Test_04_")) result= false;
+      if(!testtk(atb2Scanner::GeneralPuposeDoc,    "CP_A_CP_4C01_CP_2C01__CP_3C01_")) result= false;
+      if(!result)
+      {
+          std::cout << "!!!! Error !!!!" << std::endl;
+          return 1;
+      }
+      else
+      {
+          std::cout << "OK." << std::endl;
+          return 0;
+      }
+    }
+}
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/trace.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/trace.cpp
new file mode 100644
index 00000000..36239dff
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/trace.cpp
@@ -0,0 +1,449 @@
+//---------------------------------------------------------------------------
+//
+//  file:       trace.cpp
+//
+//  purpose:    trace functionality for the CUSS interface
+//
+//  date:       12.04.2001, 12:41
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//  history:
+//  02.08.2001 ts dump characters > 127 as 2 hex-digits
+//
+//
+//---------------------------------------------------------------------------
+
+#include "cussif.h"
+using namespace MASSAI;
+
+extern cussApplication *pCussApp;
+#include <iostream>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <time.h>
+#include <sys/types.h>
+#include <sys/timeb.h>
+#include <windows.h>
+
+#include "orbs.h"
+#include "tracedef.h"
+#include "textIDL/textcodes.h"
+
+using namespace MASSAI::codes_text;
+
+
+#define MAX_TRACE_BUF (1024L * 32L)
+
+static int traceLevel = 0;
+
+//---------------------------------------------------------------------------
+//
+//  function:   std::string rcString(long code)
+//
+//  purpose:    code translation
+//
+//  date:       22.04.2002, 11:44
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+std::string rcString(long code)
+{
+  switch(code)
+  {
+    case missingComponent:               return "missingComponent";
+    case atb2ScannerError:               return "atb2ScannerError";
+    case btpScannerError:                return "btpScannerError";
+    case noGeneralPurposeStock:          return "noGeneralPurposeStock";
+    case noBoardingPassStock:            return "noBoardingPassStock";
+    case noTicketStock:                  return "noTicketStock";
+    case noBoardingPassEconomyStock:     return "noBoardingPassEconomyStock";
+    case noBoardingPassBusinessStock:    return "noBoardingPassBusinessStock";
+    case noBoardingPassFirstStock:       return "noBoardingPassFirstStock";
+    case emptyGeneralPurposeStock:       return "emptyGeneralPurposeStock";
+    case emptyBoardingPassStock:         return "emptyBoardingPassStock";
+    case emptyTicketStock:               return "emptyTicketStock";
+    case emptyBoardingPassEconomyStock:  return "emptyBoardingPassEconomyStock";
+    case emptyBoardingPassBusinessStock: return "emptyBoardingPassBusinessStock";
+    case emptyBoardingPassFirstStock:    return "emptyBoardingPassFirstStock";
+    case parameterError:                 return "parameterError";
+    default:                             return returnCodesText(code);
+  }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   std::string dsString(long code)
+//
+//  purpose:    code translation
+//
+//  date:       22.04.2002, 11:44
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+std::string dsString(long code)
+{
+  return dataStatusText(code);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   std::string ecString(long code)
+//
+//  purpose:    code translation
+//
+//  date:       22.04.2002, 11:44
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+std::string ecString(long code)
+{
+  return eventCodesText(code);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   std::string scString(long code)
+//
+//  purpose:    code translation
+//
+//  date:       22.04.2002, 11:44
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+std::string scString(long code)
+{
+  switch(code)
+  {
+    case missingComponent:               return "missingComponent";
+    case atb2ScannerError:               return "atb2ScannerError";
+    case btpScannerError:                return "btpScannerError";
+    case noGeneralPurposeStock:          return "noGeneralPurposeStock";
+    case noBoardingPassStock:            return "noBoardingPassStock";
+    case noTicketStock:                  return "noTicketStock";
+    case noBoardingPassEconomyStock:     return "noBoardingPassEconomyStock";
+    case noBoardingPassBusinessStock:    return "noBoardingPassBusinessStock";
+    case noBoardingPassFirstStock:       return "noBoardingPassFirstStock";
+    case emptyGeneralPurposeStock:       return "emptyGeneralPurposeStock";
+    case emptyBoardingPassStock:         return "emptyBoardingPassStock";
+    case emptyTicketStock:               return "emptyTicketStock";
+    case emptyBoardingPassEconomyStock:  return "emptyBoardingPassEconomyStock";
+    case emptyBoardingPassBusinessStock: return "emptyBoardingPassBusinessStock";
+    case emptyBoardingPassFirstStock:    return "emptyBoardingPassFirstStock";
+    case parameterError:                 return "parameterError";
+    default:                             return statusCodesText(code);
+  }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long setLevel(long level)
+//
+//  purpose:    set new trace level and return the old one
+//
+//  date:       12.04.2001, 12:46
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long setLevel(long level)
+{
+long oldLevel = traceLevel;
+
+    if(level >= 0)
+    {
+      traceLevel = level;
+      return(oldLevel);
+    }
+    else
+      return(-1);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void cryptTrace(long lLevel, char *pszFile, long sLine, char *pData, long lLen)
+//
+//  purpose:    trace function, write traces encrypted
+//
+//  date:       28.08.2007
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+void cryptTrace(long lLevel, char *pszFile, long lLine, char *pData, long lLen)
+{
+  // send trace to application, do not write crypt-traces on my own
+  if (pCussApp && (lLevel <= traceLevel || lLevel == 255))
+  {
+    pCussApp->massaiCryptTrace(lLevel, pszFile, lLine, pData, lLen);
+  }
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   void trace(long lLevel, char *pszFile, long sLine, char *pszFormat, ...)
+//
+//  purpose:    trace function
+//
+//  date:       12.04.2001, 12:47
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void trace(long lLevel, char *pszFile, long sLine, char *pszFormat, ...)
+{
+long     rc = 0;
+long     ulLen;
+long     ulDump;
+long     ulTmp;
+char     *pTmp;
+char     *pArg;
+char     *pStr;
+char      szFile[256];
+
+va_list       arg_ptr;
+time_t        ltime;
+struct  tm   *today;
+struct _timeb tstruct;
+
+    if (pCussApp && (lLevel <= traceLevel || lLevel == 255))
+    {
+        if((pTmp = (char*) malloc(MAX_TRACE_BUF)) == NULL)
+          return;
+        if(*pszFormat == '%' && *(pszFormat +1) == 'T')
+        {
+          // comes from mTrace.dump() -> copy only !!
+          va_start(arg_ptr, pszFormat);
+          // get pointer to first argument
+          pArg = (char *)va_arg(arg_ptr, char*);
+          // get length of dump
+          ulDump = (long) va_arg(arg_ptr, long);
+          /* copy to buffer */
+          strncpy(pTmp, pArg, MAX_TRACE_BUF);
+          va_end(arg_ptr);
+        }
+        else
+        {
+          /* get pointer to first argument */
+          va_start(arg_ptr, pszFormat);
+          /* print into buffer */
+
+#ifdef _COMPILER_VERSION_VC6
+          _vsnprintf(pTmp, MAX_TRACE_BUF, pszFormat, arg_ptr);
+#else
+          vsnprintf(pTmp, MAX_TRACE_BUF, pszFormat, arg_ptr);
+#endif
+          va_end(arg_ptr);
+        }
+        pTmp[MAX_TRACE_BUF - 1] = 0;
+        pCussApp->massaiTrace(lLevel, pszFile, sLine, pTmp);
+
+        free (pTmp);
+    }
+    else if(lLevel <= traceLevel || lLevel == 255)
+    {
+
+      time(&ltime);
+      _ftime(&tstruct);
+
+      today = localtime(&ltime);
+
+      if((pTmp = (char*) malloc(MAX_TRACE_BUF)) == NULL)
+        return;
+
+      /* write traces with date and time */
+
+      memset(pTmp, 0, MAX_TRACE_BUF);
+
+      ulLen = ulTmp = 0;
+
+      long added = _snprintf(pTmp + ulLen, MAX_TRACE_BUF - ulLen, "%02d%02d %02d%02d:%02d.%02d ",
+                                    today->tm_mday,
+                                    today->tm_mon + 1,
+                                    today->tm_hour,
+                                    today->tm_min,
+                                    today->tm_sec,
+                                    tstruct.millitm /10);
+      ulLen += (added>0)?added:0;
+
+      /* check given arguments */
+
+      if(pszFile && pszFormat)
+      {
+        strncpy(szFile, pszFile, sizeof(szFile));
+        szFile[sizeof(szFile)-1]= 0;
+
+        // cut path from file name
+
+        if((pStr = strrchr(szFile, '\\')) != NULL)
+          strcpy(szFile, pStr +1);
+
+        // cut file name extension
+
+        if((pStr = strrchr(szFile, '.')) != NULL)
+          *pStr = '\0';
+
+        added = _snprintf(pTmp + ulLen, MAX_TRACE_BUF - ulLen, "%-16s(%4d): ", szFile, sLine);
+        ulLen += (added>0)?added:0;
+
+        if(*pszFormat == '%' && *(pszFormat +1) == 'T')
+        {
+          // comes from mTrace.dump() -> copy only !!
+
+          va_start(arg_ptr, pszFormat);
+
+          // get pointer to first argument
+
+          pArg = (char *)va_arg(arg_ptr, char*);
+
+          // get length of dump
+
+          ulDump = (long) va_arg(arg_ptr, long);
+
+          /* copy to buffer */
+
+          strncpy(pTmp + ulLen, pArg, MAX_TRACE_BUF - ulLen);
+
+          ulLen += ulDump;
+
+          va_end(arg_ptr);
+        }
+        else
+        {
+          /* get pointer to first argument */
+
+          va_start(arg_ptr, pszFormat);
+
+          /* print into buffer */
+
+#ifdef _COMPILER_VERSION_VC6
+          added = _vsnprintf(pTmp + ulLen, MAX_TRACE_BUF - ulLen, pszFormat, arg_ptr);
+#else
+          added = vsnprintf(pTmp + ulLen, MAX_TRACE_BUF - ulLen, pszFormat, arg_ptr);
+#endif
+          ulLen += (added>0)?added:0;
+
+          va_end(arg_ptr);
+        }
+
+        added = _snprintf(pTmp + ulLen, MAX_TRACE_BUF - ulLen, "\n");
+        ulLen += (added>0)?added:0;
+      }
+      else
+      {
+        ulLen = _snprintf(pTmp, MAX_TRACE_BUF - ulLen, "<< INVALID TRACE >>");
+        if(ulLen < 0)
+        {
+          ulLen = 0;
+        }
+      }
+
+      if(0 <= ulLen && ulLen < MAX_TRACE_BUF)
+      {
+        pTmp[ulLen] = 0;
+      }
+      else
+      {
+        pTmp[MAX_TRACE_BUF - 1] = 0;
+      }
+
+      if(ulTmp)
+      {
+        if(traceLevel > 255)
+          std::cout << ((char *)(pTmp + ulTmp));
+
+        OutputDebugString((char *)(pTmp + ulTmp));
+      }
+      else
+      {
+        if(traceLevel > 255)
+          std::cout << (char *)(pTmp);
+
+        OutputDebugString((char *)pTmp);
+      }
+
+      free(pTmp);
+    }
+
+    return;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void dump(long lLevel, char *pszFile, long sLine, char *pData, long usLen)
+//
+//  purpose:    dump function (using trace function)
+//
+//  date:       12.04.2001, 12:47
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void dump(long lLevel, char *pszFile, long sLine, char *pData, long usLen)
+{
+long   i, j;
+long   rc;
+char  *pTmp;
+long   ulSize;
+
+    if(lLevel <= traceLevel || lLevel == 255)
+    {
+      ulSize = ((usLen >> 4) +1) * 80;
+
+      if(!pData || !usLen || ulSize > MAX_TRACE_BUF -128)
+        return;
+
+      if((pTmp = (char*) malloc(ulSize)) == NULL) // XXX
+        return;
+
+      rc = _snprintf(pTmp, ulSize, "%c", '\n');
+
+      for(i = 0; i < usLen; i += 16)
+      {
+        rc += _snprintf(pTmp + rc, ulSize - rc, "[%04x, %04d] ", i, i);
+
+        for(j = 0; j < 16 && (i+j) < usLen; j++)
+        {
+          if(j == 8)
+            rc += _snprintf(pTmp + rc, ulSize - rc, "- %02x ", (unsigned char)(pData)[i+j]);
+          else
+            rc += _snprintf(pTmp + rc, ulSize - rc, "%02x ", (unsigned char)(pData[i+j]));
+        }
+
+        while(j < 16)
+        {
+          if(j == 8)
+            rc += _snprintf(pTmp + rc, ulSize - rc, "     ");
+          else
+            rc += _snprintf(pTmp + rc, ulSize - rc, "   ");
+
+          j++;
+        }
+
+        for(j = 0; j < 16 && (i+j) < usLen; j++)
+          rc += _snprintf(pTmp + rc, ulSize - rc, "%c", (pData[i+j] >= ' ') ? pData[i+j]: '.');
+
+        rc += _snprintf(pTmp + rc, ulSize - rc, "\n");
+      }
+      pTmp[ulSize - 1] = 0;
+      trace(lLevel, pszFile, sLine, "%T", pTmp, rc);
+
+      free(pTmp);
+    }
+
+    return;
+}
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/src/vcomp.cpp b/SelfServiceCommon/Massai/cpp/CussIF/src/vcomp.cpp
new file mode 100644
index 00000000..d1145a24
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/src/vcomp.cpp
@@ -0,0 +1,278 @@
+//---------------------------------------------------------------------------
+//
+//  file:       cussif.cpp
+//
+//  purpose:    virtual component implemenatation
+//
+//  date:       12.09.00, 10:06
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include "cussif.h"
+#include "tracedef.h"
+
+using namespace MASSAI;
+
+namespace MASSAI
+{
+  class vComponent::mEventListener : public POA_types::evtListener
+  {
+  private:
+
+      vComponent *vComp;
+      int m_id;
+
+      void callback(const types::Event& ev)
+      {
+        try
+        {
+          if(vComp)
+            vComp->callback(ev, m_id);
+        }
+        catch(CORBA::SystemException& ex)
+        {
+          trace(_HERE_1, "CORBA::SystemException:\n%s", ex._message());
+        }
+        catch(...)
+        {
+          trace(_HERE_1, "... exception occured");
+        }
+      }
+
+  public:
+
+      /** Returns the listener */
+
+      types::evtListener *listener() { return(_this()); }
+
+      /** Class constructor
+          @param pVComp - A valid virtual component reference
+       */
+
+      mEventListener(MASSAI::vComponent *pVComp, int id):
+        m_id(id),
+        vComp(pVComp)
+      {}
+
+      /** Class destructor */
+
+      ~mEventListener()
+      {
+        PortableServer::POA_var      poa;
+        PortableServer::ObjectId_var id;
+
+        try
+        {
+          poa = _default_POA();
+          id  = poa->servant_to_id(this);
+
+          poa->deactivate_object(id);
+        }
+        catch(...)
+        {
+           std::cout << "problem deactivating servant." << std::endl;
+        }
+      }
+  };
+};
+
+//---------------------------------------------------------------------------
+//
+//  function:   types::evtListener *vComponent::listener()
+//
+//  purpose:    return listener
+//
+//  date:       06.12.2001, 14:28
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+types::evtListener *vComponent::listener(int id)
+{
+  mEventListener*& eListener= m_listener[id];
+  if(eListener == 0)
+    eListener= new mEventListener(this, id);
+  return(eListener->listener());
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   const char* vComponent::appRef()
+//
+//  purpose:    return the application reference
+//
+//  date:       19.04.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+const char* vComponent::appRef()
+{
+  return szAppRef;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   vComponent::Object_var connect(const char *pszVCompIOR)
+//
+//  purpose:    connect the virtual component and return the object
+//
+//  date:       28.11.00, 13:44
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+Object_var vComponent::connect(const char *pszVCompIOR)
+{
+    if(pszVCompIOR)
+    {
+      //obj = vcOrb->string_to_object(pszVCompIOR);
+
+      cclnt = new corbaCallbackClientTerminator<Component> (pAmi, pszVCompIOR);
+
+      obj = cclnt->orb()->string_to_object(cclnt->ior());
+    }
+
+    if(cclnt)
+      lError = 0;
+
+    return(obj);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function: vComponent::vComponent(const char *pszVCompIOR)
+//
+//  purpose:  class constructor
+//
+//  date:     12.09.00, 10:11
+//
+//  author:   Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+vComponent::vComponent(amInterface *pAmi):
+ pAmi(pAmi)
+{
+    lError    = missingComponent;
+    cclnt     = NULL;
+    obj       = NULL;
+
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   vComponent::~vComponent()
+//
+//  purpose:    class destructor
+//
+//  date:       06.12.2001, 11:37
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+vComponent::~vComponent()
+{
+    if(cclnt)     delete cclnt;
+    mEventListenerMap::iterator it= m_listener.begin();
+    mEventListenerMap::iterator end= m_listener.end();
+    for(;it != end; it++)
+    {
+      delete it->second;
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long vComponent::error()
+//
+//  purpose:    return virtual components error code
+//
+//  date:       12.09.00, 11:40
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long vComponent::error()
+{
+    return(lError);
+}
+void vComponent::error(long store)
+{
+   lError= store;
+}
+
+long vComponent::setTimeout(long timeout)
+{
+  long oldTimeout= -1;
+  if(cclnt && timeout >= 0)
+  {
+    try
+    {
+      long newTimeout = 30*60*1000;
+      trace(_HERE_8, "GetInvocationTimeout...");
+      oldTimeout= GetInvocationTimeout(cclnt->orb(), true);    // store invocation timeout for this thread
+      trace(_HERE_8, "GetInvocationTimeout: (%d)", oldTimeout);
+      if(timeout != 0)
+      {
+        newTimeout= timeout + (timeout * 5) / 100 + 2000;  // Invocation Timeout = 105% * CUSS Timeout + 2 s
+      }
+      trace(_HERE_8, "SetInvocationTimeout: (%d)/(%d)", timeout, newTimeout);
+      SetInvocationTimeout(cclnt->orb(), newTimeout, true);    // change the invocation timeout for this thread, for a blocking call wait up to 30 minutes
+      trace(_HERE_8, "SetInvocationTimeout.");
+    }
+    catch(const CORBA::SystemException& ex)
+    {
+      trace(_HERE_1, "store timeout, CORBA::SystemException:\n%s", ex._message());
+    }
+    catch(std::exception& ex)
+    {
+      trace(_HERE_1, "store timeout, std::exception:\n%s", ex.what());
+    }
+    catch(...)
+    {
+      trace(_HERE_1, "store timeout, unknown exception");
+    }
+  }
+  return oldTimeout;
+}
+void vComponent::resetTimeout(long oldTimeout)
+{
+  if(cclnt)
+  {
+    try
+    {
+      if(oldTimeout > 0)
+      {
+        trace(_HERE_8, "Re-SetInvocationTimeout: (%d)", oldTimeout);
+        SetInvocationTimeout(cclnt->orb(), oldTimeout, true); // reset the invocation timeout for this thread
+        trace(_HERE_8, "Re-SetInvocationTimeout.");
+      }
+      else
+      {
+        trace(_HERE_1, "ClearInvocationTimeout...");
+        ClearInvocationTimeout(cclnt->orb(), true);                // reset the invocation timeout for this thread
+        trace(_HERE_1, "ClearInvocationTimeout.");
+      }
+    }
+    catch(const CORBA::SystemException& ex)
+    {
+      trace(_HERE_1, "restore timeout, CORBA::SystemException:\n%s", ex._message());
+    }
+    catch(std::exception& ex)
+    {
+      trace(_HERE_1, "restore timeout, std::exception:\n%s", ex.what());
+    }
+    catch(...)
+    {
+      trace(_HERE_1, "restore timeout, unknown exception");
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/static/makefile.mak b/SelfServiceCommon/Massai/cpp/CussIF/static/makefile.mak
new file mode 100644
index 00000000..69e98aa5
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/static/makefile.mak
@@ -0,0 +1,77 @@
+######################################################################
+#
+# /vob/SelfServicePlatform/Massai/cpp/CussIF/makefile.mak
+#
+######################################################################
+
+!include $(BUILDROOT)\Build\cpp\makefile.common.mak
+
+MY_CFLAGS = \
+    $(MY_CFLAGS_3) \
+    -DTAO_AS_STATIC_LIBS -DACE_AS_STATIC_LIBS \
+    -I$(P_INC) \
+    $(INC_INTERFACES) \
+    $(INC_ACETAO) \
+    $(INC_REGEX) \
+    $(INC_ZLIB)
+
+STDCFLAGS = $(INC_FLEX) $(INC_PLATFORM_INTER) $(STDCFLAGS)
+
+######################################################################
+
+MY_LIB1 = $(LIB_DST_CUSSIFS)
+
+MY_LIB1_OBJS = \
+    $(_OBJ)\codes.obj \
+    $(_OBJ)\codes_skel.obj \
+    $(_OBJ)\types.obj \
+    $(_OBJ)\types_skel.obj \
+    $(_OBJ)\characteristics.obj \
+    $(_OBJ)\characteristics_skel.obj \
+    $(_OBJ)\comps.obj \
+    $(_OBJ)\comps_skel.obj \
+    $(_OBJ)\ping.obj \
+    $(_OBJ)\ping_skel.obj \
+    $(_OBJ)\display.obj \
+    $(_OBJ)\display_skel.obj\
+    $(_OBJ)\dispclnt.obj \
+    $(_OBJ)\appmgr.obj \
+    $(_OBJ)\assotrace.obj \
+    $(_OBJ)\atb2.obj \
+    $(_OBJ)\atb2Scanner.obj \
+    $(_OBJ)\atbreader.obj \
+    $(_OBJ)\clock.obj \
+    $(_OBJ)\baggage.obj \
+    $(_OBJ)\bcs.obj \
+    $(_OBJ)\btp.obj \
+    $(_OBJ)\btpScanner.obj \
+    $(_OBJ)\check.obj \
+    $(_OBJ)\cussapp.obj \
+    $(_OBJ)\dispMap.obj \
+    $(_OBJ)\dispXTRA.obj \
+    $(_OBJ)\escrow.obj \
+    $(_OBJ)\gpp.obj \
+    $(_OBJ)\language.obj \
+    $(_OBJ)\magcard.obj \
+    $(_OBJ)\manufacturer.obj \
+    $(_OBJ)\pdf417.obj \
+    $(_OBJ)\pdf417lib.obj \
+    $(_OBJ)\ppr.obj \
+    $(_OBJ)\fpr.obj \
+    $(_OBJ)\svg.obj \
+    $(_OBJ)\trace.obj \
+    $(_OBJ)\vcomp.obj \
+    $(_OBJ)\XMLScreen.obj \
+    $(_OBJ)\callbackthread.obj \
+    $(_OBJ)\cuss_component.obj \
+    $(_OBJ)\cussif_component.obj \
+    $(_OBJ)\local_def.obj
+
+MY_LIB1_GEN_DIRS = \
+    $(GEN_MASSAI_COMMON) \
+    $(GEN_CUSS)
+
+######################################################################
+
+
+!include $(BUILDROOT)\Build\cpp\makefile.rules.mak
diff --git a/SelfServiceCommon/Massai/cpp/CussIF/static/sed.inp b/SelfServiceCommon/Massai/cpp/CussIF/static/sed.inp
new file mode 100644
index 00000000..d92e9cbe
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/CussIF/static/sed.inp
@@ -0,0 +1,2 @@
+s/TAO140//g
+s/.tao140//g
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/initIDL/makefile.mak b/SelfServiceCommon/Massai/cpp/initIDL/makefile.mak
new file mode 100644
index 00000000..c0dadd68
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/initIDL/makefile.mak
@@ -0,0 +1,26 @@
+######################################################################
+#
+# /vob/SelfServicePlatform/Massai/cpp/initIDL/makefile.mak
+#
+######################################################################
+
+!include $(BUILDROOT)\Build\cpp\makefile.common.mak
+
+MY_CFLAGS = \
+    $(INC_INTERFACES) \
+    $(INC_ACETAO)
+
+######################################################################
+
+MY_LIB1 = $(LIB_DST_INITIDL)
+
+MY_LIB1_OBJS = \
+    $(_OBJ)\initgmrdev.obj \
+    $(_OBJ)\local_def.obj
+
+######################################################################
+
+
+!include $(BUILDROOT)\Build\cpp\makefile.rules.mak
+
+######################################################################
diff --git a/SelfServiceCommon/Massai/cpp/initIDL/src/initgmrdev.cpp b/SelfServiceCommon/Massai/cpp/initIDL/src/initgmrdev.cpp
new file mode 100644
index 00000000..6bfcb36a
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/initIDL/src/initgmrdev.cpp
@@ -0,0 +1,53 @@
+#include "initgmrdev.h"
+
+namespace gmrdev
+{
+  void init_multiCompCmdData(multiCompCmdData& init, const multidevices::compType& comp)
+  {
+    init.comp= comp;
+  }
+  multiCompCmdData init_multiCompCmdData(const multidevices::compType& comp)
+  {
+    multiCompCmdData init;
+    init_multiCompCmdData(init, comp);
+    return init;
+  }
+
+  void init_dataTrack(dataTrack& init)
+  {
+    init.ds = ZERO_LENGTH;
+    init.dt = DT_UNKNOWN;
+  }
+  dataTrack init_dataTrack()
+  {
+    dataTrack init;
+    init_dataTrack(init);
+    return init;
+  }
+
+  void init_readerDataType(readerDataType& init, const multidevices::compType& comp)
+  {
+    init.type= comp;
+  }
+  readerDataType init_readerDataType(const multidevices::compType& comp)
+  {
+    readerDataType init;
+    init_readerDataType(init, comp);
+    return init;
+  }
+
+  void init_compStatus(compStatus& init, const multidevices::compType& comp)
+  {
+    init.componentType= comp;
+    init.completionCode= CMPL_COMPLETED;
+    init.errorStatus= ERR_NONE;
+    init.mediaStatus= MEDIA_UNKNOWN;
+  }
+  compStatus init_compStatus(multidevices::compType comp)
+  {
+    compStatus init;
+    init_compStatus(init, comp);
+    return init;
+  }
+
+}
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/initIDL/src/local_def.cpp b/SelfServiceCommon/Massai/cpp/initIDL/src/local_def.cpp
new file mode 100644
index 00000000..e817a5a1
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/initIDL/src/local_def.cpp
@@ -0,0 +1,17 @@
+#include "versionlib.h"
+
+/*! \page initidl initIDL - Release Notes
+ *
+ *
+ *  \date 23.09.2011 \li V1.0.0.1
+ *                   \li JK - Modify "gmrdev.idl" to include dataType
+ *                   \li      handling.
+ *                   \li    - Remove "gmrdev_bcr.idl", functionality is
+ *                   \li      now in "gmrdev.idl".
+ *
+ *  \date 08.12.2010 \li V1.0.0.0
+ *                   \li SteT Initial Version
+ *
+ */
+
+VERSION_ID_DT(initIDL, 1, 0, 0, 1);
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/textIDL/inc/textIDL.h b/SelfServiceCommon/Massai/cpp/textIDL/inc/textIDL.h
new file mode 100644
index 00000000..6baed923
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/textIDL/inc/textIDL.h
@@ -0,0 +1,18 @@
+#ifndef TEXTIDL_H_INCLUDED
+#define TEXTIDL_H_INCLUDED
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include <string>
+
+namespace MASSAI
+{
+  namespace idl_text
+  {
+    std::string unknown(const std::string& type, int code);
+    std::string description(const std::string& description, int code);
+    std::string booleanText(bool value);
+  }
+}
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/textIDL/makefile.mak b/SelfServiceCommon/Massai/cpp/textIDL/makefile.mak
new file mode 100644
index 00000000..28fada6f
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/textIDL/makefile.mak
@@ -0,0 +1,32 @@
+######################################################################
+#
+# /vob/SelfServicePlatform/Massai/cpp/textIDL/makefile.mak
+#
+######################################################################
+
+!include $(BUILDROOT)\Build\cpp\makefile.common.mak
+
+MY_CFLAGS = \
+    $(INC_INTERFACES) \
+    $(INC_ACETAO)
+
+######################################################################
+
+MY_LIB1 = $(LIB_DST_TEXTIDL)
+
+MY_LIB1_OBJS = \
+    $(_OBJ)\textgppdev.obj \
+    $(_OBJ)\textidl.obj \
+    $(_OBJ)\textmdci.obj \
+    $(_OBJ)\textcodes.obj \
+    $(_OBJ)\textcharacteristics.obj \
+    $(_OBJ)\texttypes.obj \
+    $(_OBJ)\textappcontrol.obj \
+    $(_OBJ)\local_def.obj
+
+######################################################################
+
+
+!include $(BUILDROOT)\Build\cpp\makefile.rules.mak
+
+######################################################################
diff --git a/SelfServiceCommon/Massai/cpp/textIDL/src/local_def.cpp b/SelfServiceCommon/Massai/cpp/textIDL/src/local_def.cpp
new file mode 100644
index 00000000..16a6fec2
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/textIDL/src/local_def.cpp
@@ -0,0 +1,43 @@
+#include "versionlib.h"
+
+VERSION_ID_DT(textIDL, 1, 0, 0, 7);
+
+/*! \page textidl textidl - Release Notes
+
+
+\date 05.07.2017
+\li V1.0.0.7
+applicationStart.cmdLine changed from String to List of Strings
+
+\date 05.07.2017 \li V1.0.0.6
+                 \li SteT Mantis 23800: cussif: SITA platform sends activation event with simple type, cussif throws BadKind
+
+\date 20.12.2011 \li V1.0.0.5
+                 \li SteT Mantis 0022538: Platform_Extension_CUSS_1_2: IDL use cuss 1.2 idls
+                       added:
+                          STATE_EXPLANATION
+                          ACTIVE_TRANSFER
+                          TRANSACTION_EXPLANATION
+
+\date 20.12.2011 \li V1.0.0.4
+                 \li SteT textappcontrol added
+
+\date 08.11.2011 \li V1.0.0.3
+                 \li SteT cuss codes extended
+                       added:
+                          BAGGAGE_WEIGHT_OUT_OF_RANGE
+
+\date 28.07.2011 \li V1.0.0.2
+                 \li SteT cuss codes extended
+                       added:
+                          BAGGAGE_INVALID_DATA
+                          BAGGAGE_TRANSPORT_FAILED
+
+\date 22.06.2011 \li V1.0.0.1
+                 \li SteT cuss codes added
+
+\date 08.12.2010 \li V1.0.0.0
+                 \li SteT Initial Version
+
+*/
+
diff --git a/SelfServiceCommon/Massai/cpp/textIDL/src/textappcontrol.cpp b/SelfServiceCommon/Massai/cpp/textIDL/src/textappcontrol.cpp
new file mode 100644
index 00000000..0b747272
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/textIDL/src/textappcontrol.cpp
@@ -0,0 +1,84 @@
+#include "textIDL/textappcontrol.h"
+#include "textIDL/textmdci.h"
+#include "textidl.h"
+#include <sstream>
+
+using MASSAI::idl_text::unknown;
+using namespace MASSAI::appcontrol_text;
+
+namespace MASSAI
+{
+  namespace appcontrol_text
+  {
+    std::string resolutionsText(const appControl::resolutions& code)
+    {
+      switch(code)
+      {
+        case appControl::RES_800x600:   return "800x600";
+        case appControl::RES_1024x768:  return "1024x768";
+        case appControl::RES_1280x1024: return "1280x1024";
+        case appControl::RES_1600x1200: return "1600x1200";
+        case appControl::RES_DEFAULT:   return "Default";
+        default:                        return unknown("resolutions", code);
+      }
+    }
+
+    std::string commandTypeText(const appControl::commandType& code)
+    {
+      switch(code)
+      {
+        case appControl::CMD_START:          return "start";
+        case appControl::CMD_SWITCH:         return "switch";
+        case appControl::CMD_KILL:           return "kill";
+        case appControl::CMD_KILLALL:        return "killall";
+        case appControl::CMD_SWITCHMAIN:     return "switchmain";
+        case appControl::CMD_SHOW:           return "show";
+        case appControl::CMD_SET_RESOLUTION: return "set_resolution";
+        default:                             return unknown("commandType", code);
+      }
+    }
+
+    std::string applicationText(const appControl::application& data)
+    {
+      std::ostringstream out;
+      out << data;
+      return out.str();
+    }
+
+    std::string applicationStartText(const appControl::applicationStart& data)
+    {
+      std::ostringstream out;
+      out << data;
+      return out.str();
+    }
+  }
+}
+
+std::ostream& operator<<(std::ostream& out, const appControl::resolutions& code)
+{
+  out << resolutionsText(code);
+  return out;
+}
+
+std::ostream& operator<<(std::ostream& out, const appControl::commandType& code)
+{
+  out << commandTypeText(code);
+  return out;
+}
+
+std::ostream& operator<<(std::ostream& out, const appControl::application& app)
+{
+  out << "appName: (" << app.appName.in()  << ")";
+  return out;
+}
+
+std::ostream& operator<<(std::ostream& out, const appControl::applicationStart& app)
+{
+  out << "appName: ("       << app.appName.in()  << ")\n";
+  for(unsigned int i = 0; i < app.cmdLine.length(); i++)
+  {
+    out << "cmdLine[" << i << "]: (" << app.cmdLine[i].in()  << ")\n";
+  }
+  out << "switchTimeout: (" << app.switchTimeout << ")\n";
+  return out;
+}
diff --git a/SelfServiceCommon/Massai/cpp/textIDL/src/textcharacteristics.cpp b/SelfServiceCommon/Massai/cpp/textIDL/src/textcharacteristics.cpp
new file mode 100644
index 00000000..d943314b
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/textIDL/src/textcharacteristics.cpp
@@ -0,0 +1,381 @@
+#include "textIDL/textcharacteristics.h"
+#include "cuss/orbs.h"
+#include "textidl.h"
+#include <sstream>
+
+using namespace MASSAI::idl_text;
+using namespace MASSAI::characteristics_text;
+
+
+namespace MASSAI
+{
+  namespace characteristics_text
+  {
+    std::string mediaTypeDefText(Characteristics::MediaType::MediaTypeDef mediaTypeDef)
+    {
+      switch(mediaTypeDef)
+      {
+        case Characteristics::MediaType::nonApplicableMediaType: return "nonApplicableMediaType";
+        case Characteristics::MediaType::MagneticStripe:         return "MagneticStripe";
+        case Characteristics::MediaType::Chip:                   return "Chip";
+        case Characteristics::MediaType::Printed:                return "Printed";
+        case Characteristics::MediaType::JIS:                    return "JIS";
+        default:                                                 return unknown("MediaTypeDef", mediaTypeDef);
+      }
+    }
+    std::string imageTypeText(Characteristics::Location::ImageType imageType)
+    {
+      switch(imageType)
+      {
+        case Characteristics::Location::nonApplicableImageType: return "nonApplicableImageType";
+        case Characteristics::Location::notAvailable:           return "notAvailable";
+        case Characteristics::Location::BMP:                    return "BMP";
+        case Characteristics::Location::JPEG:                   return "JPEG";
+        case Characteristics::Location::PNG:                    return "PNG";
+        case Characteristics::Location::Flash:                  return "Flash";
+        default:                                                return unknown("ImageType", imageType);
+      }
+    }
+    std::string locationTypeText(Characteristics::Location::LocationType locationType)
+    {
+      switch(locationType)
+      {
+        case Characteristics::Location::nonApplicableLocationType: return "nonApplicableLocationType";
+        case Characteristics::Location::inKiosk:                   return "inKiosk";
+        case Characteristics::Location::inArea:                    return "inArea";
+        default:                                                   return unknown("LocationType", locationType);
+      }
+    }
+    std::string barcodeStandardText(Characteristics::ComponentFonts::BarcodeStandard barcodeStandard)
+    {
+      switch(barcodeStandard)
+      {
+        case Characteristics::ComponentFonts::nonApplicableBarcodeStandard: return "nonApplicableBarcodeStandard";
+        case Characteristics::ComponentFonts::Code39:                       return "Code39";
+        case Characteristics::ComponentFonts::Code128:                      return "Code128";
+        case Characteristics::ComponentFonts::Code2of5:                     return "Code2of5";
+        default:                                                            return unknown("BarcodeStandard", barcodeStandard);
+      }
+    }
+    std::string inputOutputModeText(Characteristics::IOMode::InputOutputMode inputOutputMode)
+    {
+      switch(inputOutputMode)
+      {
+        case Characteristics::IOMode::nonApplicableInputOutputMode: return "nonApplicableInputOutputMode";
+        case Characteristics::IOMode::CheckIn:                      return "CheckIn";
+        case Characteristics::IOMode::Revalidation:                 return "Revalidation";
+        default:                                                    return unknown("InputOutputMode", inputOutputMode);
+      }
+    }
+    std::string dispenserTypeText(Characteristics::Dispenser::DispenserType dispenserType)
+    {
+      switch(dispenserType)
+      {
+        case Characteristics::Dispenser::nonApplicableDispenserType: return "nonApplicableDispenserType";
+        case Characteristics::Dispenser::real_:                      return "real_";
+        case Characteristics::Dispenser::virtual_:                   return "virtual_";
+        default:                                                     return unknown("DispenserType", dispenserType);
+      }
+    }
+    std::string dataTypeText(Characteristics::DataType dataType)
+    {
+      switch(dataType)
+      {
+        case Characteristics::nonApplicableDataType: return "nonApplicableDataType";
+        case Characteristics::AEA:                   return "AEA";
+        case Characteristics::MSG:                   return "MSG";
+        case Characteristics::SVG:                   return "SVG";
+        default:                                     return unknown("DataType", dataType);
+      }
+    }
+    std::string readerTypeText(Characteristics::MediaInput::ReaderType readerType)
+    {
+      switch(readerType)
+      {
+        case Characteristics::MediaInput::nonApplicableReaderType: return "nonApplicableReaderType";
+        case Characteristics::MediaInput::Motorized:               return "Motorized";
+        case Characteristics::MediaInput::DIP:                     return "DIP";
+        case Characteristics::MediaInput::Swipe:                   return "Swipe";
+        case Characteristics::MediaInput::Contactless:             return "Contactless";
+        case Characteristics::MediaInput::FlatbedScan:             return "FlatbedScan";
+        case Characteristics::MediaInput::PenScan:                 return "PenScan";
+        default:                                                   return unknown("ReaderType", readerType);
+      }
+    }
+    std::string mediaTypeText(Characteristics::MediaOutput::MediaType mediaType)
+    {
+      switch(mediaType)
+      {
+        case Characteristics::MediaOutput::nonApplicableMediaType: return "nonApplicableMediaType";
+        case Characteristics::MediaOutput::Ticket:                 return "Ticket";
+        case Characteristics::MediaOutput::BoardingPass:           return "BoardingPass";
+        case Characteristics::MediaOutput::GeneralPurposeDoc:      return "GeneralPurposeDoc";
+        case Characteristics::MediaOutput::BaggageTag:             return "BaggageTag";
+        case Characteristics::MediaOutput::InsertedDoc:            return "InsertedDoc";
+        case Characteristics::MediaOutput::Card:                   return "Card";
+        case Characteristics::MediaOutput::BoardingPassFirst:      return "BoardingPassFirst";
+        case Characteristics::MediaOutput::BoardingPassBusiness:   return "BoardingPassBusiness";
+        case Characteristics::MediaOutput::BoardingPassEconomy:    return "BoardingPassEconomy";
+        default:                                                   return unknown("MediaType", mediaType);
+      }
+    }
+    std::string printOrientationDefText(Characteristics::MediaOutput::PrintOrientationDef printOrientationDef)
+    {
+      switch(printOrientationDef)
+      {
+        case Characteristics::MediaOutput::nonApplicablePrintOrientation: return "nonApplicablePrintOrientation";
+        case Characteristics::MediaOutput::Portrait:                      return "Portrait";
+        case Characteristics::MediaOutput::Landscape:                     return "Landscape";
+        default:                                                          return unknown("PrintOrientationDef", printOrientationDef);
+      }
+    }
+    std::string mediaTransferTypeText(Characteristics::MediaOutput::MediaTransferType mediaTransferType)
+    {
+      switch(mediaTransferType)
+      {
+        case Characteristics::MediaOutput::nonApplicableMediaTransferType: return "nonApplicableMediaTransferType";
+        case Characteristics::MediaOutput::DirectThermal:                  return "DirectThermal";
+        case Characteristics::MediaOutput::ThermalTransfer:                return "ThermalTransfer";
+        default:                                                           return unknown("MediaTransferType", mediaTransferType);
+      }
+    }
+    std::string contactAddressTypeText(Characteristics::Application::ContactAddressType contactAddressType)
+    {
+      switch(contactAddressType)
+      {
+        case Characteristics::Application::nonApplicableContactAddress: return "nonApplicableContactAddress";
+        case Characteristics::Application::None:                        return "None";
+        case Characteristics::Application::Pager:                       return "Pager";
+        case Characteristics::Application::EMail:                       return "EMail";
+        case Characteristics::Application::Phone:                       return "Phone";
+        case Characteristics::Application::Postal:                      return "Postal";
+        case Characteristics::Application::Fax:                         return "Fax";
+        case Characteristics::Application::Network:                     return "Network";
+        case Characteristics::Application::URL:                         return "URL";
+        case Characteristics::Application::IOR:                         return "IOR";
+        default:                                                        return unknown("ContactAddressType", contactAddressType);
+      }
+    }
+    std::string conveyorTypeText(Characteristics::Conveyor::ConveyorType conveyorType)
+    {
+      switch(conveyorType)
+      {
+        case Characteristics::Conveyor::nonApplicableConveyorType: return "nonApplicableConveyorType";
+        case Characteristics::Conveyor::Scale:                     return "Scale";
+        case Characteristics::Conveyor::BCR:                       return "BCR";
+        case Characteristics::Conveyor::Scale_BCR:                 return "Scale_BCR";
+        case Characteristics::Conveyor::Scale_ParkPosition:        return "Scale_ParkPosition";
+        case Characteristics::Conveyor::BCR_ParkPosition:          return "BCR_ParkPosition";
+        case Characteristics::Conveyor::Scale_BCR_ParkPosition:    return "Scale_BCR_ParkPosition";
+        default:                                                   return unknown("ConveyorType", conveyorType);
+      }
+    }
+    std::string resolutionText(long resolution)
+    {
+      switch(resolution)
+      {
+        case 800:  return "800 x 600";
+        case 1024: return "1024 x 768";
+        case 1280: return "1280 x 1024";
+        case 1600: return "1600 x 1200";
+        default:   return unknown("Resolution", resolution);
+      }
+    }
+
+    std::string fontSpecText(const Characteristics::ComponentFonts::FontSpec& fontSpec)
+    {
+      std::ostringstream out;
+      out << fontSpec;
+      return out.str();
+    }
+    std::string contactText(const Characteristics::Application::Contact& contact)
+    {
+      std::ostringstream out;
+      out << contact;
+      return out.str();
+    }
+    std::string mediaTypeListDefText(const Characteristics::MediaTypeListDef& mediaTypeListDef)
+    {
+      std::ostringstream out;
+      out << mediaTypeListDef;
+      return out.str();
+    }
+    std::string fontListText(const Characteristics::ComponentFonts::FontList& fontList)
+    {
+      std::ostringstream out;
+      out << fontList;
+      return out.str();
+    }
+    std::string dataTypeListText(const Characteristics::DataTypeList& dataTypeList)
+    {
+      std::ostringstream out;
+      out << dataTypeList;
+      return out.str();
+    }
+    std::string resolutionListText(const Characteristics::Display::ResolutionList& resolutionList)
+    {
+      std::ostringstream out;
+      out << resolutionList;
+      return out.str();
+    }
+    std::string contactListText(const Characteristics::Application::ContactList& contactList)
+    {
+      std::ostringstream out;
+      out << contactList;
+      return out.str();
+    }
+  }
+}
+
+std::ostream& operator<<(std::ostream& out, Characteristics::MediaType::MediaTypeDef mediaTypeDef)
+{
+  out << mediaTypeDefText(mediaTypeDef);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, Characteristics::Location::ImageType imageType)
+{
+  out << imageTypeText(imageType);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, Characteristics::Location::LocationType locationType)
+{
+  out << locationTypeText(locationType);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, Characteristics::ComponentFonts::BarcodeStandard barcodeStandard)
+{
+  out << barcodeStandardText(barcodeStandard);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, Characteristics::IOMode::InputOutputMode inputOutputMode)
+{
+  out << inputOutputModeText(inputOutputMode);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, Characteristics::Dispenser::DispenserType dispenserType)
+{
+  out << dispenserTypeText(dispenserType);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, Characteristics::DataType dataType)
+{
+  out << dataTypeText(dataType);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, Characteristics::MediaInput::ReaderType readerType)
+{
+  out << readerTypeText(readerType);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, Characteristics::MediaOutput::MediaType mediaType)
+{
+  out << mediaTypeText(mediaType);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, Characteristics::MediaOutput::PrintOrientationDef printOrientationDef)
+{
+  out << printOrientationDefText(printOrientationDef);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, Characteristics::MediaOutput::MediaTransferType mediaTransferType)
+{
+  out << mediaTransferTypeText(mediaTransferType);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, Characteristics::Application::ContactAddressType contactAddressType)
+{
+  out << contactAddressTypeText(contactAddressType);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, Characteristics::Conveyor::ConveyorType conveyorType)
+{
+  out << conveyorTypeText(conveyorType);
+  return out;
+}
+
+std::ostream& operator<<(std::ostream& out, const Characteristics::ComponentFonts::FontSpec& fontSpec)
+{
+  out << "fontName: ("        << fontSpec.fontName.in()        << ")\n";
+  out << "fontSizes: (";
+  for(CORBA::ULong i= 0; i < fontSpec.fontSizes.length(); i++)
+  {
+    out << fontSpec.fontSizes[i] << ", ";
+  }
+  out << ")\n";
+  out << "vectorFont: ("      << fontSpec.vectorFont      << ")\n";
+  out << "bold: ("            << fontSpec.bold            << ")\n";
+  out << "italic: ("          << fontSpec.italic          << ")\n";
+  out << "underlined: ("      << fontSpec.underlined      << ")\n";
+  out << "strikeThrough: ("   << fontSpec.strikeThrough   << ")\n";
+  out << "reverse: ("         << fontSpec.reverse         << ")\n";
+  out << "superScript: ("     << fontSpec.superScript     << ")\n";
+  out << "subScript: ("       << fontSpec.subScript       << ")\n";
+  out << "colorDepth: ("      << fontSpec.colorDepth      << ")\n";
+  out << "spacing: ("         << fontSpec.spacing         << ")\n";
+  out << "characterLength: (" << fontSpec.characterLength << ")\n";
+  return out;
+}
+
+std::ostream& operator<<(std::ostream& out, const Characteristics::Application::Contact& contact)
+{
+  out << "name: ("    << contact.name    << ")\n";
+  out << "company: (" << contact.company << ")\n";
+  out << "note: ("    << contact.note    << ")\n";
+  out << "address: (" << contact.address << ")\n";
+  out << "type: ("    << contact.type    << ")\n";
+  return out;
+}
+
+std::ostream& operator<<(std::ostream& out, const Characteristics::MediaTypeListDef& mediaTypeListDef)
+{
+  out << "MediaTypeListDef: (\n";
+  for(CORBA::ULong i= 0; i < mediaTypeListDef.length(); i++)
+  {
+    out << mediaTypeListDef[i] << "\n";
+  }
+  out << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const Characteristics::ComponentFonts::FontList& fontList)
+{
+  out << "FontList: (\n";
+  for(CORBA::ULong i= 0; i < fontList.length(); i++)
+  {
+    out << fontList[i] << "\n";
+  }
+  out << ")\n";
+  return out;
+}
+
+std::ostream& operator<<(std::ostream& out, const Characteristics::DataTypeList& dataTypeList)
+{
+  out << "DataTypeList: (\n";
+  for(CORBA::ULong i= 0; i < dataTypeList.length(); i++)
+  {
+    out << dataTypeList[i] << "\n";
+  }
+  out << ")\n";
+  return out;
+}
+
+std::ostream& operator<<(std::ostream& out, const Characteristics::Display::ResolutionList& resolutionList)
+{
+  out << "ResolutionList: (\n";
+  for(CORBA::ULong i= 0; i < resolutionList.length(); i++)
+  {
+    out << resolutionText(resolutionList[i]) << "\n";
+  }
+  out << ")\n";
+  return out;
+}
+
+std::ostream& operator<<(std::ostream& out, const Characteristics::Application::ContactList& contactList)
+{
+  out << "ContactList: (\n";
+  for(CORBA::ULong i= 0; i < contactList.length(); i++)
+  {
+    out << contactList[i] << "\n";
+  }
+  out << ")\n";
+  return out;
+}
diff --git a/SelfServiceCommon/Massai/cpp/textIDL/src/textcodes.cpp b/SelfServiceCommon/Massai/cpp/textIDL/src/textcodes.cpp
new file mode 100644
index 00000000..07fd83a4
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/textIDL/src/textcodes.cpp
@@ -0,0 +1,335 @@
+#include "textIDL/textcodes.h"
+#include "cuss/orbs.h"
+#include "textidl.h"
+#include <sstream>
+
+using namespace MASSAI::idl_text;
+using namespace MASSAI::codes_text;
+using namespace m_returncodes;
+using namespace m_datastatus;
+using namespace m_eventcodes;
+using namespace m_statuscodes;
+
+
+namespace MASSAI
+{
+  namespace codes_text
+  {
+    std::string returnCodesText(long code)
+    {
+      switch(code)
+      {
+        case RC_OK:            return "OK";
+        case RC_REFERENCE:     return "REFERENCE";
+        case RC_STATE:         return "STATE";
+        case RC_DENIED:        return "DENIED";
+        case RC_PARAMETER:     return "PARAMETER";
+        case RC_ANY_PARAMETER: return "ANY_PARAMETER";
+        case RC_LISTENER:      return "LISTENER";
+        case RC_SHARE:         return "SHARE";
+        case RC_UNAUTHORIZED:  return "UNAUTHORIZED";
+        case RC_ERROR:         return "ERROR";
+        case RC_NOT_SUPPORTED: return "NOT_SUPPORTED";
+        default:               return unknown("ReturnCode", code);
+      }
+    }
+    std::string dataStatusTypeText(long code)
+    {
+      switch(code)
+      {
+        case DS_TYPES_FOID_ISO:                 return "FOID_ISO";
+        case DS_TYPES_PAYMENT_ISO:              return "PAYMENT_ISO";
+        case DS_TYPES_DISCRETIONARY_ISO:        return "DISCRETIONARY_ISO";
+        case DS_TYPES_VING:                     return "VING";
+        case DS_TYPES_TESSA:                    return "TESSA";
+        case DS_TYPES_SAFLOK:                   return "SAFLOK";
+        case DS_TYPES_TIMELOX:                  return "TIMELOX";
+        case DS_TYPES_KABA_ILCO:                return "KABA_ILCO";
+        case DS_TYPES_KABA_ILCO_FOLIO:          return "KABA_ILCO_FOLIO";
+        case DS_TYPES_IMAGE_IR:                 return "IMAGE_IR";
+        case DS_TYPES_IMAGE_VIS:                return "IMAGE_VIS";
+        case DS_TYPES_IMAGE_UV:                 return "IMAGE_UV";
+        case DS_TYPES_IMAGE_PHOTO:              return "IMAGE_PHOTO";
+        case DS_TYPES_IMAGE_COAX:               return "IMAGE_COAX";
+        case DS_TYPES_CODELINE:                 return "CODELINE";
+        case DS_TYPES_BARCODE:                  return "BARCODE";
+        // case DS_TYPES_MIWA:                     return "MIWA";
+        case DS_TYPES_JIS2:                     return "JIS2";
+        case DS_TYPES_FOID_JIS2:                return "FOID_JIS2";
+        case DS_TYPES_PAYMENT_JIS2:             return "PAYMENT_JIS2";
+        case DS_TYPES_DISCRETIONARY_JIS2:       return "DISCRETIONARY_JIS2";
+        case DS_TYPES_SCAN_PDF417:              return "SCAN_PDF417";
+        case DS_TYPES_SCAN_AZTEC:               return "SCAN_AZTEC";
+        case DS_TYPES_SCAN_DMATRIX:             return "SCAN_DMATRIX";
+        case DS_TYPES_SCAN_QR:                  return "SCAN_QR";
+
+        case DS_TYPES_SCAN_CODE39:              return "SCAN_CODE39";
+        case DS_TYPES_SCAN_CODE128:             return "SCAN_CODE128";
+        case DS_TYPES_SCAN_CODE2OF5:            return "SCAN_CODE2OF5";
+
+        case DS_TYPES_ISO7816:                  return "ISO7816";
+        case DS_TYPES_PRINT_2S_PAGE:            return "PRINT_2S_PAGE";
+        case DS_TYPES_PRINT_2S_MULTI:           return "PRINT_2S_MULTI";
+        case DS_TYPES_PRINT_PDF:                return "PRINT_PDF";
+        case DS_TYPES_MIFARE:                   return "MIFARE";
+        case DS_TYPES_SUICA:                    return "SUICA";
+
+        case DS_TYPES_ISO15961:                 return "ISO15961";
+        case DS_TYPES_RP1745:                   return "RP1745";
+        case DS_TYPES_WEIGHT:                   return "WEIGHT";
+
+        case DS_TYPES_EPASSPORT_DG1:            return "EPASSPORT_DG1";
+        case DS_TYPES_EPASSPORT_DG2:            return "EPASSPORT_DG2";
+        case DS_TYPES_EPASSPORT_DG3:            return "EPASSPORT_DG3";
+        case DS_TYPES_EPASSPORT_DG4:            return "EPASSPORT_DG4";
+        case DS_TYPES_EPASSPORT_DG5:            return "EPASSPORT_DG5";
+        case DS_TYPES_EPASSPORT_DG6:            return "EPASSPORT_DG6";
+        case DS_TYPES_EPASSPORT_DG7:            return "EPASSPORT_DG7";
+        case DS_TYPES_EPASSPORT_DG8:            return "EPASSPORT_DG8";
+        case DS_TYPES_EPASSPORT_DG9:            return "EPASSPORT_DG9";
+        case DS_TYPES_EPASSPORT_DG10:           return "EPASSPORT_DG10";
+        case DS_TYPES_EPASSPORT_DG11:           return "EPASSPORT_DG11";
+        case DS_TYPES_EPASSPORT_DG12:           return "EPASSPORT_DG12";
+        case DS_TYPES_EPASSPORT_DG13:           return "EPASSPORT_DG13";
+        case DS_TYPES_EPASSPORT_DG14:           return "EPASSPORT_DG14";
+        case DS_TYPES_EPASSPORT_DG15:           return "EPASSPORT_DG15";
+        case DS_TYPES_EPASSPORT_DG16:           return "EPASSPORT_DG16";
+        case DS_TYPES_EPASSPORT_DG17:           return "EPASSPORT_DG17";
+        case DS_TYPES_EPASSPORT_DG18:           return "EPASSPORT_DG18";
+        case DS_TYPES_EPASSPORT_DG19:           return "EPASSPORT_DG19";
+        case DS_TYPES_EPASSPORT_DG20:           return "EPASSPORT_DG20";
+        default:                                return unknown("DataStatusType", code);
+      }
+    }
+    std::string dataStatusStatusText(long code)
+    {
+      switch(code)
+      {
+        case DS_OK:                             return "OK";
+        case DS_CORRUPTED:                      return "CORRUPTED";
+        case DS_INCOMPLETE:                     return "INCOMPLETE";
+        case DS_ZEROLENGTH:                     return "ZEROLENGTH";
+        case DS_DOCUMENT_AUTHENTICATION_FAILED: return "DOCUMENT_AUTHENTICATION_FAILED";
+        case DS_INVALID:                        return "INVALID";
+        case DS_MISMATCH:                       return "MISMATCH";
+        default:                                return unknown("DataStatus", code);
+      }
+    }
+
+    std::string dataStatusText(long code)
+    {
+      long statusMask= 10;
+      long status= code % statusMask;
+      long type= code - status;
+      if(type == DS_TYPES_ISO)
+      {
+        return dataStatusStatusText(status);
+      }
+      else if(status == DS_OK)
+      {
+        return dataStatusTypeText(type);
+      }
+      else
+      {
+        return dataStatusTypeText(type) + "/" + dataStatusStatusText(status);
+      }
+    }
+    std::string eventCodesText(long code)
+    {
+      switch(code)
+      {
+        case EVENTHANDLING_READY:             return "EVENTHANDLING_READY";
+        case UNAVAILABLE_RELEASED_PLATFORM:   return "UNAVAILABLE_RELEASED_PLATFORM";
+        case EVENTHANDLING_UNAVAILABLE:       return "EVENTHANDLING_UNAVAILABLE";
+        case UNAVAILABLE_RELEASED_APPLICATION:return "UNAVAILABLE_RELEASED_APPLICATION";
+        case READY_RELEASED_APPLICATION:      return "READY_RELEASED_APPLICATION";
+        case READY_RELEASED_PLATFORM:         return "READY_RELEASED_PLATFORM";
+        case RELEASED_READY:                  return "RELEASED_READY";
+        case RELEASED_UNAVAILABLE:            return "RELEASED_UNAVAILABLE";
+        case INITIALIZE_DISABLED:             return "INITIALIZE_DISABLED";
+        case AVAILABLE_DISABLED:              return "AVAILABLE_DISABLED";
+        case ACTIVE_DISABLED:                 return "ACTIVE_DISABLED";
+        case UNAVAILABLE_AVAILABLE:           return "UNAVAILABLE_AVAILABLE";
+        case AVAILABLE_ACTIVE:                return "AVAILABLE_ACTIVE";
+        case ACTIVE_AVAILABLE:                return "ACTIVE_AVAILABLE";
+        case INITIALIZE_STOPPED_STOP:         return "INITIALIZE_STOPPED_STOP";
+        case AVAILABLE_STOPPED_STOP:          return "AVAILABLE_STOPPED_STOP";
+        case ACTIVE_STOPPED_STOP:             return "ACTIVE_STOPPED_STOP";
+        case SUSPENDED_STOPPED_STOP:          return "SUSPENDED_STOPPED_STOP";
+        case DISABLED_STOPPED_STOP:           return "DISABLED_STOPPED_STOP";
+        case SUSPENDED_AVAILABLE:             return "SUSPENDED_AVAILABLE";
+        case AVAILABLE_SUSPENDED:             return "AVAILABLE_SUSPENDED";
+        case INITIALIZE_STOPPED_RESTART:      return "INITIALIZE_STOPPED_RESTART";
+        case AVAILABLE_STOPPED_RESTART:       return "AVAILABLE_STOPPED_RESTART";
+        case ACTIVE_STOPPED_RESTART:          return "ACTIVE_STOPPED_RESTART";
+        case DISABLED_STOPPED_RESTART:        return "DISABLED_STOPPED_RESTART";
+        case SUSPENDED_STOPPED_RESTART:       return "SUSPENDED_STOPPED_RESTART";
+        case STOPPED_INITIALIZE:              return "STOPPED_INITIALIZE";
+        case DISABLED_INITIALIZE:             return "DISABLED_INITIALIZE";
+        case UNAVAILABLE_STOPPED_RESTART:     return "UNAVAILABLE_STOPPED_RESTART";
+        case UNAVAILABLE_DISABLED:            return "UNAVAILABLE_DISABLED";
+        case UNAVAILABLE_SUSPENDED:           return "UNAVAILABLE_SUSPENDED";
+        case INITIALIZE_SUSPENDED:            return "INITIALIZE_SUSPENDED";
+        case SUSPENDED_DISABLED:              return "SUSPENDED_DISABLED";
+        case SUSPENDED_INITIALIZE:            return "SUSPENDED_INITIALIZE";
+        case SUSPENDED_UNAVAILABLE:           return "SUSPENDED_UNAVAILABLE";
+        case UNAVAILABLE_STOPPED_STOP:        return "UNAVAILABLE_STOPPED_STOP";
+        case INITIALIZE_UNAVAILABLE:          return "INITIALIZE_UNAVAILABLE";
+        case AVAILABLE_UNAVAILABLE:           return "AVAILABLE_UNAVAILABLE";
+        case DISABLED_SUSPENDED:              return "DISABLED_SUSPENDED";
+        case ACTIVE_ACTIVE:                   return "ACTIVE_ACTIVE";
+        case RELEASED:                        return "RELEASED";
+        case UNAVAILABLE:                     return "UNAVAILABLE";
+        case READY:                           return "READY";
+        case STOPPED:                         return "STOPPED";
+        case SUSPENDED:                       return "SUSPENDED";
+        case DISABLED:                        return "DISABLED";
+        case INITIALIZE:                      return "INITIALIZE";
+        case AVAILABLE:                       return "AVAILABLE";
+        case ACTIVE:                          return "ACTIVE";
+        case BUSY:                            return "BUSY";
+        case STATE_EXPLANATION:               return "STATE_EXPLANATION";
+        case ACTIVE_TRANSFER:                 return "ACTIVE_TRANSFER";
+        case TRANSACTION_EXPLANATION:         return "TRANSACTION_EXPLANATION";
+        case RC_REFERENCE:                    return "REFERENCE";
+        case RC_STATE:                        return "STATE";
+        case RC_DENIED:                       return "DENIED";
+        case RC_PARAMETER:                    return "PARAMETER";
+        case RC_ANY_PARAMETER:                return "ANY_PARAMETER";
+        case RC_LISTENER:                     return "LISTENER";
+        case RC_SHARE:                        return "SHARE";
+        case RC_UNAUTHORIZED:                 return "UNAUTHORIZED";
+        case RC_ERROR:                        return "ERROR";
+        case RC_NOT_SUPPORTED:                return "NOT_SUPPORTED";
+        default:               return unknown("EventCode", code);
+      }
+    }
+    std::string statusCodesText(long code)
+    {
+      switch(code)
+      {
+        case OK:                             return "OK";
+        case TIMEOUT:                        return "TIMEOUT";
+        case WRONG_STATE:                    return "WRONG_STATE";
+        case CANCELLED:                      return "CANCELLED";
+        case SOFTWARE_ERROR:                 return "SOFTWARE_ERROR";
+        case ALMOST_OUT_OF_TIME:             return "ALMOST_OUT_OF_TIME";
+        case OUT_OF_SEQUENCE:                return "OUT_OF_SEQUENCE";
+        case MEDIA_JAMMED:                   return "MEDIA_JAMMED";
+        case MEDIA_MISPLACED:                return "MEDIA_MISPLACED";
+        case MEDIA_PRESENT:                  return "MEDIA_PRESENT";
+        case MEDIA_ABSENT:                   return "MEDIA_ABSENT";
+        case MEDIA_HIGH:                     return "MEDIA_HIGH";
+        case MEDIA_FULL:                     return "MEDIA_FULL";
+        case MEDIA_LOW:                      return "MEDIA_LOW";
+        case MEDIA_EMPTY:                    return "MEDIA_EMPTY";
+        case MEDIA_DAMAGED:                  return "MEDIA_DAMAGED";
+        case MEDIA_INCOMPLETELY_INSERTED:    return "MEDIA_INCOMPLETELY_INSERTED";
+        case BAGGAGE_FULL:                   return "BAGGAGE_FULL";
+        case BAGGAGE_UNDETECTED:             return "BAGGAGE_UNDETECTED";
+        case BAGGAGE_PRESENT:                return "BAGGAGE_PRESENT";
+        case BAGGAGE_ABSENT:                 return "BAGGAGE_ABSENT";
+        case BAGGAGE_OVERSIZED:              return "BAGGAGE_OVERSIZED";
+        case BAGGAGE_ILLICIT_WEIGHT_CHANGE:  return "BAGGAGE_ILLICIT_WEIGHT_CHANGE";
+        case BAGGAGE_READY_FOR_TAKE_IN:      return "BAGGAGE_READY_FOR_TAKE_IN";
+        case BAGGAGE_TOO_MANY_BAGS:          return "BAGGAGE_TOO_MANY_BAGS";
+        case BAGGAGE_DELIVER:                return "BAGGAGE_DELIVER";
+        case BAGGAGE_UNEXPECTED_BAG:         return "BAGGAGE_UNEXPECTED_BAG";
+        case BAGGAGE_TOO_HIGH:               return "BAGGAGE_TOO_HIGH";
+        case BAGGAGE_TOO_LONG:               return "BAGGAGE_TOO_LONG";
+        case BAGGAGE_TOO_FLAT:               return "BAGGAGE_TOO_FLAT";
+        case BAGGAGE_TOO_SHORT:              return "BAGGAGE_TOO_SHORT";
+        case BAGGAGE_PARKED:                 return "BAGGAGE_PARKED";
+        case BAGGAGE_INVALID_DATA:           return "BAGGAGE_INVALID_DATA";
+        case BAGGAGE_TRANSPORT_FAILED:       return "BAGGAGE_TRANSPORT_FAILED";
+        case BAGGAGE_WEIGHT_OUT_OF_RANGE:    return "BAGGAGE_WEIGHT_OUT_OF_RANGE";
+
+        case BAGGAGE_JAMMED:                 return "BAGGAGE_JAMMED";
+        case BAGGAGE_EMERGENCY_STOP:         return "BAGGAGE_EMERGENCY_STOP";
+        case BAGGAGE_RESTLESS:               return "BAGGAGE_RESTLESS";
+        case BAGGAGE_INTRUSION:              return "BAGGAGE_INTRUSION";
+        case BAGGAGE_INTRUSION_FRONT:        return "BAGGAGE_INTRUSION_FRONT";
+        case BAGGAGE_INTRUSION_BACK:         return "BAGGAGE_INTRUSION_BACK";
+        case BAGGAGE_TRANSPORT_BUSY:         return "BAGGAGE_TRANSPORT_BUSY";
+
+        case FORMAT_ERROR:                   return "FORMAT_ERROR";
+        case LENGTH_ERROR:                   return "LENGTH_ERROR";
+        case DATA_MISSING:                   return "DATA_MISSING";
+        case PHYSICAL_ERROR:                 return "PHYSICAL_ERROR";
+        case DATA_PRESENT:                   return "DATA_PRESENT";
+        case CONSUMABLES:                    return "CONSUMABLES";
+        case HARDWARE_ERROR:                 return "HARDWARE_ERROR";
+        case CRITICAL_SOFTWARE_ERROR:        return "CRITICAL_SOFTWARE_ERROR";
+        case NOT_REACHABLE:                  return "NOT_REACHABLE";
+        case NOT_RESPONDING:                 return "NOT_RESPONDING";
+        case THRESHOLD_ERROR:                return "THRESHOLD_ERROR";
+        case THRESHOLD_USAGE:                return "THRESHOLD_USAGE";
+        case CONFIGURATION_ERROR:            return "CONFIGURATION_ERROR";
+        case SESSION_TIMEOUT:                return "SESSION_TIMEOUT";
+        case KILL_TIMEOUT:                   return "KILL_TIMEOUT";
+        case CUSS_MANAGER_REQUEST:           return "CUSS_MANAGER_REQUEST";
+        case SP_SYSTEM_MANAGER_REQUEST:      return "SP_SYSTEM_MANAGER_REQUEST";
+        case AL_SYSTEM_MANAGER_REQUEST:      return "AL_SYSTEM_MANAGER_REQUEST";
+        case CL_APPLICATION_REQUEST:         return "CL_APPLICATION_REQUEST";
+        case AL_APPLICATION_REQUEST:         return "AL_APPLICATION_REQUEST";
+        case RC_REFERENCE:                   return "REFERENCE";
+        case RC_STATE:                       return "STATE";
+        case RC_DENIED:                      return "DENIED";
+        case RC_PARAMETER:                   return "PARAMETER";
+        case RC_ANY_PARAMETER:               return "ANY_PARAMETER";
+        case RC_LISTENER:                    return "LISTENER";
+        case RC_SHARE:                       return "SHARE";
+        case RC_UNAUTHORIZED:                return "UNAUTHORIZED";
+        case RC_ERROR:                       return "ERROR";
+        case RC_NOT_SUPPORTED:               return "NOT_SUPPORTED";
+        default:
+        {
+          if(APPLICATION_TECHNICAL_FIRST <= code && code <= APPLICATION_TECHNICAL_LAST)
+          {
+            return description("APPLICATION_TECHNICAL", code);
+          }
+          else if(APPLICATION_SECURITY_FIRST <= code && code <= APPLICATION_SECURITY_LAST)
+          {
+            return description("APPLICATION_SECURITY", code);
+          }
+          else if(APPLICATION_BUSINESS_FIRST <= code && code <= APPLICATION_BUSINESS_LAST)
+          {
+            return description("APPLICATION_BUSINESS", code);
+          }
+          else
+          {
+            return unknown("StatusCode", code);
+          }
+        }
+      }
+    }
+
+    DataStatus::DataStatus(long code):
+      code(code)
+    {}
+    EventCode::EventCode(long code):
+      code(code)
+    {}
+    StatusCode::StatusCode(long code):
+      code(code)
+    {}
+  }
+}
+
+std::ostream& operator<<(std::ostream& out, const MASSAI::codes_text::DataStatus& code)
+{
+  out << dataStatusText(code.code);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const MASSAI::codes_text::EventCode& code)
+{
+  out << eventCodesText(code.code);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const MASSAI::codes_text::StatusCode& code)
+{
+  out << statusCodesText(code.code);
+  return out;
+}
+
+
diff --git a/SelfServiceCommon/Massai/cpp/textIDL/src/textgppdev.cpp b/SelfServiceCommon/Massai/cpp/textIDL/src/textgppdev.cpp
new file mode 100644
index 00000000..cde19541
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/textIDL/src/textgppdev.cpp
@@ -0,0 +1,294 @@
+#include "textIDL/textgppdev.h"
+#include "textIDL/textmdci.h"
+#include "textidl.h"
+#include "corbasrvr.h"
+#include <sstream>
+
+using MASSAI::idl_text::unknown;
+using namespace MASSAI::gppdev_text;
+
+namespace MASSAI
+{
+  namespace gppdev_text
+  {
+    std::string mediaTypeText(const gppdev::mediaType& code)
+    {
+      switch(code)
+      {
+        case gppdev::AnyType:              return "AnyType";
+        case gppdev::Ticket:               return "Ticket";
+        case gppdev::BoardingPass:         return "BoardingPass";
+        case gppdev::GeneralPurposeDoc:    return "GeneralPurposeDoc";
+        case gppdev::BaggageTag:           return "BaggageTag";
+        case gppdev::BoardingPassFirst:    return "BoardingPassFirst";
+        case gppdev::BoardingPassBusiness: return "BoardingPassBusiness";
+        case gppdev::BoardingPassEconomy:  return "BoardingPassEconomy";
+        default:                           return unknown("mediaType", code);
+      }
+    }
+    std::string completionTypeText(const gppdev::completionType& code)
+    {
+      switch(code)
+      {
+        case gppdev::CMPL_COMPLETED:      return "COMPLETED";
+        case gppdev::CMPL_CANCELLED:      return "CANCELLED";
+        case gppdev::CMPL_CANCEL_FAILED:  return "CANCEL_FAILED";
+        case gppdev::CMPL_TIMEOUT:        return "TIMEOUT";
+        case gppdev::CMPL_ILLOGICAL:      return "ILLOGICAL";
+        case gppdev::CMPL_ABORTED:        return "ABORTED";
+        case gppdev::CMPL_FAILED:         return "FAILED";
+        default:                           return unknown("completionType", code);
+      }
+    }
+
+    std::string errorTypeText(const gppdev::errorType& code)
+    {
+      switch(code)
+      {
+        case gppdev::ERR_NONE:         return "NONE";
+        case gppdev::ERR_BUSY:         return "BUSY";
+        case gppdev::ERR_DISCONNECTED: return "DISCONNECTED";
+        case gppdev::ERR_HARDWARE:     return "HARDWARE";
+        case gppdev::ERR_MEDIA_JAMMED: return "MEDIA_JAMMED";
+        case gppdev::ERR_RIBBON_OUT:   return "RIBBON_OUT";
+        case gppdev::ERR_OFFLINE:      return "OFFLINE";
+        case gppdev::ERR_PAPER_OUT:    return "PAPER_OUT";
+        case gppdev::ERR_WRONG_FORMAT: return "WRONG_FORMAT";
+        case gppdev::ERR_OPEN:         return "OPEN";
+        default:                       return unknown("errorType", code);
+      }
+    }
+
+    std::string mediaStatusTypeText(const gppdev::mediaStatusType& code)
+    {
+      switch(code)
+      {
+        case gppdev::MEDIA_LOW:     return "MEDIA_LOW";
+        case gppdev::MEDIA_ABSENT:  return "MEDIA_ABSENT";
+        case gppdev::MEDIA_PRESENT: return "MEDIA_PRESENT";
+        default:                    return unknown("mediaStatusType", code);
+      }
+    }
+
+    std::string commandTypeText(const gppdev::commandType& code)
+    {
+      switch(code)
+      {
+        case gppdev::CMD_CANCEL:         return "CANCEL";
+        case gppdev::CMD_PRINT:          return "PRINT";
+        case gppdev::CMD_SETUP:          return "SETUP";
+        case gppdev::CMD_STATUS_QUERY:   return "STATUS_QUERY";
+        case gppdev::CMD_CONTEXT_SWITCH: return "CONTEXT_SWITCH";
+        case gppdev::CMD_RESET:          return "RESET";
+        case gppdev::CMD_STOCK_REFILLED: return "STOCK_REFILLED";
+        default:                         return unknown("commandType", code);
+      }
+    }
+
+    std::string printOrientationText(const gppdev::printOrientation& code)
+    {
+      switch(code)
+      {
+        case gppdev::orientationUndefined: return "orientationUndefined";
+        case gppdev::orientationPortrait:  return "orientationPortrait";
+        case gppdev::orientationLandscape: return "orientationLandscape";
+        default:                           return unknown("printOrientation", code);
+      }
+    }
+    std::string indicationTypeText(const gppdev::indicationType& code)
+    {
+      switch(code)
+      {
+        case gppdev::IND_PRINT_DONE:           return "PRINT_DONE";
+        case gppdev::IND_SETUP_DONE:           return "SETUP_DONE";
+        case gppdev::IND_STATUS_INFO:          return "STATUS_INFO";
+        case gppdev::IND_CONTEXT_SWITCH_DONE:  return "CONTEXT_SWITCH_DONE";
+        case gppdev::IND_RESET_DONE:           return "RESET_DONE";
+        case gppdev::IND_STOCK_REFILLED_DONE:  return "STOCK_REFILLED_DONE";
+        case gppdev::IND_RESTART:              return "RESTART";
+        case gppdev::IND_DOCUMENT_REMOVED:     return "DOCUMENT_REMOVED";
+        case gppdev::IND_POWER_SWITCH_REQUEST: return "POWER_SWITCH_REQUEST";
+        default:                               return unknown("indicationType", code);
+      }
+    }
+    std::string stockTypeText(const gppdev::stockType& data)
+    {
+      std::ostringstream out;
+      out << "couponsProduced: (" << data.couponsProduced << "), "
+          << "couponStatus: ("    << data.couponStatus << ")";
+      return out.str();
+    }
+    std::string stockListText(const gppdev::stockList& data)
+    {
+      std::ostringstream out;
+      for(int i= 0; i < data.length(); i++)
+      {
+        out << "Feeder: (" << i << "): (" << data[i] << ")\n";
+      }
+      return out.str();
+    }
+    std::string statusOfMultipleStockPrinterText(const gppdev::statusOfMultipleStockPrinter& data)
+    {
+      std::ostringstream out;
+      out << "media: ("        << data.type << "),\n"
+          << "completion: ("   << data.completionCode << "),\n"
+          << "error: ("        << data.errorStatus << "),\n"
+          << "media status: (" << data.printerMediaStatus << "),\n"
+          << "stock status:\n" << data.stockStatus;
+      return out.str();
+    }
+    std::string extendendPrintDataText(const gppdev::extendendPrintData& data)
+    {
+      std::ostringstream out;
+      out << "orientation: ("  << data.orientation << "), ";
+      CORBA::Any any= data.data;
+      CORBA::TypeCode_var type = any.type();
+      if(type->equal(DeviceComponents::_tc_aeaData))
+      {
+        DeviceComponents::aeaData* pAEAData;
+        any >>= pAEAData;
+        if(pAEAData)
+        {
+          out << "aea: ("  << *pAEAData << ")";
+        }
+        else
+        {
+          out << "aea: (null)";
+        }
+      }
+      else if(type->equal(DeviceComponents::_tc_svgData))
+      {
+        DeviceComponents::svgData* pSVGData;
+        any >>= pSVGData;
+        if(pSVGData)
+        {
+          out << "svg: ("  << *pSVGData << ")";
+        }
+        else
+        {
+          out << "svg: (null)";
+        }
+      }
+      else
+      {
+        out << "unknown data: ("  << type << ")";
+      }
+      return out.str();
+    }
+    std::string gppCommandDataText(const gppdev::gppCommandData& data)
+    {
+      std::ostringstream out;
+      out << "media: ("  << data.type << "), ";
+      CORBA::Any any= data.data;
+      CORBA::TypeCode_var type = any.type();
+      if(type->equal(gppdev::_tc_extendendPrintData))
+      {
+        gppdev::extendendPrintData* pPrintData;
+        any >>= pPrintData;
+        if(pPrintData)
+        {
+          out << "extendendPrintData: ("  << *pPrintData << ")";
+        }
+        else
+        {
+          out << "extendendPrintData: (null)";
+        }
+      }
+      else if(type->equal(DeviceComponents::_tc_aeaData))
+      {
+        DeviceComponents::aeaData* pAEAData;
+        any >>= pAEAData;
+        if(pAEAData)
+        {
+          out << "aea: ("  << *pAEAData << ")";
+        }
+        else
+        {
+          out << "aea: (null)";
+        }
+      }
+      else if(type->equal(DeviceComponents::_tc_svgData))
+      {
+        DeviceComponents::svgData* pSVGData;
+        any >>= pSVGData;
+        if(pSVGData)
+        {
+          out << "svg: ("  << *pSVGData << ")";
+        }
+        else
+        {
+          out << "svg: (null)";
+        }
+      }
+      else
+      {
+        out << "unknown data: ("  << type << ")";
+      }
+      return out.str();
+    }
+  }
+}
+
+
+std::ostream& operator<<(std::ostream& out, const gppdev::mediaType& code)
+{
+  out << mediaTypeText(code);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const gppdev::completionType& code)
+{
+  out << completionTypeText(code);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const gppdev::errorType& code)
+{
+  out << errorTypeText(code);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const gppdev::mediaStatusType& code)
+{
+  out << mediaStatusTypeText(code);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const gppdev::commandType& code)
+{
+  out << commandTypeText(code);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const gppdev::printOrientation& code)
+{
+  out << printOrientationText(code);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const gppdev::indicationType& code)
+{
+  out << indicationTypeText(code);
+  return out;
+}
+
+std::ostream& operator<<(std::ostream& out, const gppdev::stockType& data)
+{
+  out << stockTypeText(data);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const gppdev::stockList& data)
+{
+  out << stockListText(data);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const gppdev::statusOfMultipleStockPrinter& data)
+{
+  out << statusOfMultipleStockPrinterText(data);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const gppdev::extendendPrintData& data)
+{
+  out << extendendPrintDataText(data);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const gppdev::gppCommandData& data)
+{
+  out << gppCommandDataText(data);
+  return out;
+}
+
diff --git a/SelfServiceCommon/Massai/cpp/textIDL/src/textidl.cpp b/SelfServiceCommon/Massai/cpp/textIDL/src/textidl.cpp
new file mode 100644
index 00000000..340929d3
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/textIDL/src/textidl.cpp
@@ -0,0 +1,39 @@
+#ifndef TEXTIDL_H_INCLUDED
+#define TEXTIDL_H_INCLUDED
+#ifdef SHOW_INCLUDE_FILES
+#pragma message("including: " __FILE__)
+#endif
+
+#include <sstream>
+
+namespace MASSAI
+{
+  namespace idl_text
+  {
+    std::string unknown(const std::string& type, int code)
+    {
+      std::ostringstream out;
+      out << "unknown " << type << ":(" << code << ")";
+      return out.str();
+    }
+    std::string description(const std::string& description, int code)
+    {
+      std::ostringstream out;
+      out << description << ":(" << code << ")";
+      return out.str();
+    }
+    std::string booleanText(bool value)
+    {
+      if(value)
+      {
+        return "true";
+      }
+      else
+      {
+        return "false";
+      }
+    }
+
+  }
+}
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/textIDL/src/textmdci.cpp b/SelfServiceCommon/Massai/cpp/textIDL/src/textmdci.cpp
new file mode 100644
index 00000000..d3486557
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/textIDL/src/textmdci.cpp
@@ -0,0 +1,96 @@
+#include "textIDL/textmdci.h"
+#include "textidl.h"
+#include "corbasrvr.h"
+#include "mHexString.hpp"
+#include <sstream>
+
+using MASSAI::idl_text::unknown;
+using namespace MASSAI::mdci_text;
+
+
+namespace MASSAI
+{
+  namespace mdci_text
+  {
+    std::string rcText(const DeviceComponents::RC& code)
+    {
+      switch(code)
+      {
+        case DeviceComponents::RC_ACCEPTED:      return "ACCEPTED";
+        case DeviceComponents::RC_OK:            return "OK";
+        case DeviceComponents::RC_ERROR:         return "ERROR";
+        case DeviceComponents::RC_STATE:         return "STATE";
+        case DeviceComponents::RC_LISTENER:      return "LISTENER";
+        case DeviceComponents::RC_NOT_SUPPORTED: return "NOT_SUPPORTED";
+        case DeviceComponents::RC_CORBA:         return "CORBA";
+        default:                                 return unknown("RC", code);
+      }
+    }
+
+    std::string svgDataText(const DeviceComponents::svgData& data)
+    {
+      return std::string(reinterpret_cast<const char*>(data.get_buffer()), data.length());
+    }
+    std::string aeaDataText(const DeviceComponents::aeaData& data)
+    {
+      return std::string(reinterpret_cast<const char*>(data.get_buffer()), data.length());
+    }
+    std::string strngDataText(const DeviceComponents::strngData& data)
+    {
+      return data;
+    }
+    std::string nullDataText(const DeviceComponents::nullData& data)
+    {
+      return "null";
+    }
+    std::string commandText(const DeviceComponents::command& data)
+    {
+      std::ostringstream out;
+      out << "requestID: (" << data.requestID << ")";
+      return out.str();
+    }
+    std::string indicationText(const DeviceComponents::indication& data)
+    {
+      std::ostringstream out;
+      out << "requestID: (" << data.requestID << ")";
+      return out.str();
+    }
+  }
+}
+
+std::ostream& operator<<(std::ostream& out, const DeviceComponents::RC& code)
+{
+  out << rcText(code);
+  return out;
+}
+
+std::ostream& operator<<(std::ostream& out, const DeviceComponents::svgData& data)
+{
+  mHex::stringConvert convert;
+  std::string text= svgDataText(data);
+  out << text << "[" << convert.toHex(text) << "]";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const DeviceComponents::aeaData& data)
+{
+  mHex::stringConvert convert;
+  std::string text= aeaDataText(data);
+  out << text << "[" << convert.toHex(text) << "]";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const DeviceComponents::nullData& data)
+{
+  out << nullDataText(data);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const DeviceComponents::command& data)
+{
+  out << commandText(data);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const DeviceComponents::indication& data)
+{
+  out << indicationText(data);
+  return out;
+}
+
diff --git a/SelfServiceCommon/Massai/cpp/textIDL/src/texttypes.cpp b/SelfServiceCommon/Massai/cpp/textIDL/src/texttypes.cpp
new file mode 100644
index 00000000..7b88dcd1
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/textIDL/src/texttypes.cpp
@@ -0,0 +1,871 @@
+#include "textIDL/texttypes.h"
+#include "textIDL/textcodes.h"
+#include "cuss/orbs.h"
+#include "textidl.h"
+#include "corbasrvr.h"
+#include "text/mHexString.hpp"
+
+#include <time.h>
+#include <sstream>
+#include <iomanip>
+
+
+using namespace MASSAI::idl_text;
+using namespace MASSAI::types_text;
+
+
+namespace MASSAI
+{
+  namespace types_text
+  {
+    std::string orientationText(types::orientation orientation)
+    {
+      switch(orientation)
+      {
+        case types::north_:     return "north_";
+        case types::south_:     return "south_";
+        case types::east_:      return "east_";
+        case types::west_:      return "west_";
+        case types::undefined_: return "undefined_";
+        default:                return unknown("Orientation", orientation);
+      }
+    }
+    std::string actionText(types::action action)
+    {
+      switch(action)
+      {
+        case types::subscribe_: return "subscribe_";
+        case types::discard_:   return "discard_";
+        default:                return unknown("Action", action);
+      }
+    }
+    std::string evtCategoryText(types::evtCategory evtCategory)
+    {
+      switch(evtCategory)
+      {
+        case types::alarm_:  return "alarm_";
+        case types::alert_:  return "alert_";
+        case types::normal_: return "normal_";
+        default:             return unknown("EvtCategory", evtCategory);
+      }
+    }
+    std::string evtTypeText(types::evtType evtType)
+    {
+      switch(evtType)
+      {
+        case types::invalid_:  return "invalid_";
+        case types::private_:  return "private_";
+        case types::public_:   return "public_";
+        case types::platform_: return "platform_";
+        default:               return unknown("EvtType", evtType);
+      }
+    }
+    std::string evtModeText(types::evtMode evtMode)
+    {
+      switch(evtMode)
+      {
+        case types::solicited_:   return "solicited_";
+        case types::unsolicited_: return "unsolicited_";
+        default:                  return unknown("EvtMode", evtMode);
+      }
+    }
+    std::string evtFilterTypeText(types::evtFilterType evtFilterType)
+    {
+      switch(evtFilterType)
+      {
+        case types::all_:       return "all_";
+        case types::any_:       return "any_";
+        case types::nil_:       return "nil_";
+        case types::code_:      return "code_";
+        case types::type_:      return "type_";
+        case types::component_: return "component_";
+        default:                return unknown("EvtFilterType", evtFilterType);
+      }
+    }
+    std::string dataStatusText(types::dataStatus dataStatus)
+    {
+      return MASSAI::codes_text::dataStatusText(dataStatus);
+    }
+    std::string evtCodeText(types::evtCode evtCode)
+    {
+      return MASSAI::codes_text::eventCodesText(evtCode);
+    }
+    std::string evtStatusCodeText(types::evtStatusCode evtStatusCode)
+    {
+      return MASSAI::codes_text::statusCodesText(evtStatusCode);
+    }
+    std::string akIDText(const types::akID& akID)
+    {
+      std::ostringstream out;
+      out << akID;
+      return out.str();
+    }
+    std::string locationText(const types::location& location)
+    {
+      std::ostringstream out;
+      out << location;
+      return out.str();
+    }
+    std::string coordinateText(const types::coordinate& coordinate)
+    {
+      std::ostringstream out;
+      out << coordinate;
+      return out.str();
+    }
+    std::string gpsText(const types::gps& gps)
+    {
+      std::ostringstream out;
+      out << gps;
+      return out.str();
+    }
+    std::string environmentLevelText(const types::EnvironmentLevel& environmentLevel)
+    {
+      std::ostringstream out;
+      out << environmentLevel;
+      return out.str();
+    }
+    std::string environmentComponentText(const types::EnvironmentComponent& environmentComponent)
+    {
+      std::ostringstream out;
+      out << environmentComponent;
+      return out.str();
+    }
+    std::string dataRecordText(const types::dataRecord& dataRecord)
+    {
+      std::ostringstream out;
+      out << dataRecord;
+      return out.str();
+    }
+    std::string msgDataTypeText(const types::msgDataType& msgDataType)
+    {
+      std::ostringstream out;
+      out << msgDataType;
+      return out.str();
+    }
+    std::string evtCodeFilterElemText(const types::evtCodeFilterElem& evtCodeFilterElem)
+    {
+      std::ostringstream out;
+      out << evtCodeFilterElem;
+      return out.str();
+    }
+    std::string evtTypeFilterElemText(const types::evtTypeFilterElem& evtTypeFilterElem)
+    {
+      std::ostringstream out;
+      out << evtTypeFilterElem;
+      return out.str();
+    }
+    std::string evtComponentFilterElemText(const types::evtComponentFilterElem& evtComponentFilterElem)
+    {
+      std::ostringstream out;
+      out << evtComponentFilterElem;
+      return out.str();
+    }
+    std::string evtDescrText(const types::evtDescr& evtDescr)
+    {
+      std::ostringstream out;
+      out << evtDescr;
+      return out.str();
+    }
+    std::string evtDescrANY_CODE_TYPEText(const types::evtDescrANY_CODE_TYPE& evtDescrANY_CODE_TYPE)
+    {
+      std::ostringstream out;
+      out << evtDescrANY_CODE_TYPE;
+      return out.str();
+    }
+    std::string evtDescrCOMPONENTText(const types::evtDescrCOMPONENT& evtDescrCOMPONENT)
+    {
+      std::ostringstream out;
+      out << evtDescrCOMPONENT;
+      return out.str();
+    }
+    std::string eventText(const types::Event& event)
+    {
+      std::ostringstream out;
+      out << event;
+      return out.str();
+    }
+    std::string evtCodeFilterUnionText(const types::evtCodeFilterUnion& evtCodeFilterUnion)
+    {
+      std::ostringstream out;
+      out << evtCodeFilterUnion;
+      return out.str();
+    }
+    std::string evtTypeFilterUnionText(const types::evtTypeFilterUnion& evtTypeFilterUnion)
+    {
+      std::ostringstream out;
+      out << evtTypeFilterUnion;
+      return out.str();
+    }
+    std::string evtComponentFilterUnionText(const types::evtComponentFilterUnion& evtComponentFilterUnion)
+    {
+      std::ostringstream out;
+      out << evtComponentFilterUnion;
+      return out.str();
+    }
+    std::string evtFilterText(const types::evtFilter& evtFilter)
+    {
+      std::ostringstream out;
+      out << evtFilter;
+      return out.str();
+    }
+    std::string evtAcquireFilterText(const types::evtAcquireFilter& evtAcquireFilter)
+    {
+      std::ostringstream out;
+      out << evtAcquireFilter;
+      return out.str();
+    }
+    std::string evtDescriptionText(const types::evtDescription& evtDescription)
+    {
+      std::ostringstream out;
+      out << evtDescription;
+      return out.str();
+    }
+    std::string namelistText(const types::namelist& namelist)
+    {
+      std::ostringstream out;
+      out << namelist;
+      return out.str();
+    }
+    std::string indexListText(const types::indexList& indexList)
+    {
+      std::ostringstream out;
+      out << indexList;
+      return out.str();
+    }
+    std::string iorlistText(const types::iorlist& iorlist)
+    {
+      std::ostringstream out;
+      out << iorlist;
+      return out.str();
+    }
+    std::string environmentComponentsText(const types::EnvironmentComponents& environmentComponents)
+    {
+      std::ostringstream out;
+      out << environmentComponents;
+      return out.str();
+    }
+    std::string evtCodeFilterText(const types::evtCodeFilter& evtCodeFilter)
+    {
+      std::ostringstream out;
+      out << evtCodeFilter;
+      return out.str();
+    }
+    std::string evtTypeFilterText(const types::evtTypeFilter& evtTypeFilter)
+    {
+      std::ostringstream out;
+      out << evtTypeFilter;
+      return out.str();
+    }
+    std::string evtComponentFilterText(const types::evtComponentFilter& evtComponentFilter)
+    {
+      std::ostringstream out;
+      out << evtComponentFilter;
+      return out.str();
+    }
+    std::string msgDataTypeRecordsSeqText(const types::msgDataType::_records_seq& records)
+    {
+      std::ostringstream out;
+      out << records;
+      return out.str();
+    }
+    std::string evtDescrEventTypesSeq(const types::evtDescr::_eventTypes_seq& eventTypes)
+    {
+      std::ostringstream out;
+      out << eventTypes;
+      return out.str();
+    }
+    std::string evtDescrCOMPONENTEventDescrSeq(const types::evtDescrCOMPONENT::_eventDescr_seq& eventDescr)
+    {
+      std::ostringstream out;
+      out << eventDescr;
+      return out.str();
+    }
+    std::string evtComponentFilterUnionFilterCODESeq(const types::evtComponentFilterUnion::_filterCODE_seq& filterCODE)
+    {
+      std::ostringstream out;
+      out << filterCODE;
+      return out.str();
+    }
+    std::string evtComponentFilterUnionFilterTYPESeq(const types::evtComponentFilterUnion::_filterTYPE_seq& filterTYPE)
+    {
+      std::ostringstream out;
+      out << filterTYPE;
+      return out.str();
+    }
+    std::string evtAcquireFilterFilterCODESeq(const types::evtAcquireFilter::_filterCODE_seq& filterCODE)
+    {
+      std::ostringstream out;
+      out << filterCODE;
+      return out.str();
+    }
+    std::string evtAcquireFilterFilterTYPESeq(const types::evtAcquireFilter::_filterTYPE_seq& filterTYPE)
+    {
+      std::ostringstream out;
+      out << filterTYPE;
+      return out.str();
+    }
+    std::string timestampText(types::TimeT timestamp)
+    {
+      std::ostringstream out;
+      types::TimeT milliseconds = (timestamp / 10000);
+      types::TimeT gregoriandiff = 141427L; // days;
+      gregoriandiff*= 24; // hours
+      gregoriandiff*= 60; // minutes
+      gregoriandiff*= 60; // seconds
+      types::TimeT secondsl= milliseconds;
+      secondsl/=1000;
+      secondsl-= gregoriandiff;
+      time_t seconds = secondsl;
+      milliseconds%= 1000;
+      int millis= milliseconds;
+
+      struct tm* timestruct;
+      timestruct = gmtime(&seconds);
+      if(timestruct != 0)
+      {
+        out << std::setw(2) << std::setfill('0');
+        out << timestruct->tm_mday << ".";
+        out << std::setw(2) << std::setfill('0');
+        out << timestruct->tm_mon+1 << ".";
+        out << std::setw(4) << std::setfill('0');
+        out << (timestruct->tm_year+1900) << " ";
+        out << std::setw(2) << std::setfill('0');
+        out << (timestruct->tm_hour) << ":";
+        out << std::setw(2) << std::setfill('0');
+        out << (timestruct->tm_min) << ":";
+        out << std::setw(2) << std::setfill('0');
+        out << (timestruct->tm_sec) << ".";
+        out << std::setw(3) << std::setfill('0');
+        out << millis;
+      }
+      else
+      {
+        out << seconds;
+        out << std::setw(3) << std::setfill('0');
+        out << millis << " s";
+      }
+      return out.str();
+    }
+    std::string eventDataText(const CORBA::Any& eventData)
+    {
+      std::ostringstream out;
+      try
+      {
+        CORBA::TypeCode_var tcp = eventData.type();
+        if(is_nil(tcp))
+        {
+          out << "type: (null)\n";
+        }
+        else
+        {
+          out << "kind: (" << tcp->kind() << ")\n";
+          try
+          {
+            out << "type: (" << tcp->name() << "/" << tcp->id()<< ")\n";
+          }
+          catch(...)
+          {}
+          if(tcp->equal(CORBA::_tc_string))
+          {
+            const char *pData;
+            eventData >>= pData;
+            if(pData)
+            {
+              out << "data: (\n" << pData << ")\n";
+            }
+          }
+          else if(tcp->equal(types::_tc_msgDataType))
+          {
+            types::msgDataType* pData= 0;
+            eventData >>= pData;
+            if(pData)
+            {
+              out << "data: (\n" << *pData << ")\n";
+            }
+          }
+          else if(tcp->equal(types::_tc_svgDataType))
+          {
+            types::svgDataType *pData;
+            eventData >>= pData;
+            if(pData)
+            {
+              out << "data: (\n" << *pData << ")\n";
+            }
+          }
+          else if(tcp->equal(types::_tc_aeaDataType))
+          {
+            types::aeaDataType *pData;
+            eventData >>= pData;
+            if(pData)
+            {
+              out << "data: (\n" << *pData << ")\n";
+            }
+          }
+          else if(tcp->equal(CORBA::_tc_long))
+          {
+            CORBA::Long ldata;
+            eventData >>= ldata;
+            out << "data: (\n" << ldata << ")\n";
+          }
+        }
+      }
+      catch(const CORBA::Exception& ex)
+      {
+        out << "data: exception(\n" << ex._message() << ")\n";
+      }
+      catch(const std::exception& ex)
+      {
+        out << "data: exception(\n" << ex.what() << ")\n";
+      }
+      catch(...)
+      {
+        out << "data: exception\n";
+      }
+      return out.str();
+    }
+    std::string bytestreamText(const types::bytestream& bytestream)
+    {
+      std::string data(reinterpret_cast<const char*>(bytestream.get_buffer()), bytestream.length());
+      mHex::stringConvert convert;
+      return data + "[" + convert.toHex(data) + "]";
+    }
+
+    std::string eludText(const CORBA::Any& elud)
+    {
+      return "elud";
+    }
+  }
+}
+
+
+std::ostream& operator<<(std::ostream& out, types::orientation orientation)
+{
+  out << orientationText(orientation);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, types::action action)
+{
+  out << actionText(action);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, types::evtCategory evtCategory)
+{
+  out << evtCategoryText(evtCategory);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, types::evtType evtType)
+{
+  out << evtTypeText(evtType);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, types::evtMode evtMode)
+{
+  out << evtModeText(evtMode);
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, types::evtFilterType evtFilterType)
+{
+  out << evtFilterTypeText(evtFilterType);
+  return out;
+}
+
+std::ostream& operator<<(std::ostream& out, const types::akID& akID)
+{
+  out << "companyCode: ("     << akID.companyCode.in()      << ")\n";
+  out << "applicationName: (" << akID.applicationName.in()  << ")\n";
+  out << "vendorCode: ("      << akID.vendorCode.in()       << ")\n";
+  out << "kioskName: ("       << akID.kioskName.in()        << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::location& location)
+{
+  out << "airportCode: (" << location.airportCode.in() << ")\n";
+  out << "terminal: ("    << location.terminal.in()    << ")\n";
+  out << "area: ("        << location.area.in()        << ")\n";
+  out << "address: ("     << location.address.in()     << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::coordinate& coordinate)
+{
+  out << "coordinate: (" << coordinate.direction << " ";
+  out << coordinate.degrees            << "";
+  out << coordinate.minutes            << ":";
+  out << coordinate.seconds            << ".";
+  out << coordinate.hundreths          << ")";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::gps& gps)
+{
+  out << "longitude: (" << gps.longitude << ")\n";
+  out << "latitude: ("  << gps.latitude  << ")\n";
+  out << "altitude: ("  << gps.altitude  << " m)\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::EnvironmentLevel& environmentLevel)
+{
+  out << "sessionTimeout: ("          << environmentLevel.sessionTimeout               << " ms)\n";
+  out << "killTimeout: ("             << environmentLevel.killTimeout                  << " ms)\n";
+  out << "kioskID: (\n"               << environmentLevel.kioskID                      << ")\n";
+  out << "kioskLocation:(\n"          << environmentLevel.kioskLocation                << ")\n";
+  out << "gpsLocation:(\n"            << environmentLevel.gpsLocation                  << ")\n";
+  out << "cussVersion: ("             << environmentLevel.cussVersion.in()             << ")\n";
+  out << "cussInterfaceVersionMin: (" << environmentLevel.cussInterfaceVersionMin.in() << ")\n";
+  out << "cussInterfaceVersionMax: (" << environmentLevel.cussInterfaceVersionMax.in() << ")\n";
+  out << "jvmName: ("                 << environmentLevel.jvmName.in()                 << ")\n";
+  out << "jvmVersion: ("              << environmentLevel.jvmVersion.in()              << ")\n";
+  out << "browserName: ("             << environmentLevel.browserName.in()             << ")\n";
+  out << "browserVersion: ("          << environmentLevel.browserVersion.in()          << ")\n";
+  out << "osName: ("                  << environmentLevel.osName.in()                  << ")\n";
+  out << "osVersion: ("               << environmentLevel.osVersion.in()               << ")\n";
+  out << "applicationToken: ("        << environmentLevel.applicationToken.in()        << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::EnvironmentComponent& environmentComponent)
+{
+  out << "virtualComponentName: (" << environmentComponent.virtualComponentName.in() << ")\n";
+  out << "virtualComponentRef: ("  << environmentComponent.virtualComponentRef.in()  << ")\n";
+  out << "realComponentName: ("    << environmentComponent.realComponentName.in()    << ")\n";
+  out << "linkedComponents: ("     << environmentComponent.linkedComponents          << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::dataRecord& dataRecord)
+{
+  out << "status: ("  << dataStatusText(dataRecord.status)  << ")\n";
+  out << "message: (" << bytestreamText(dataRecord.message) << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::msgDataType& msgDataType)
+{
+  out << msgDataType.records;
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::evtCodeFilterElem& evtCodeFilterElem)
+{
+  out << "eventCode: ("   << evtCodeText(evtCodeFilterElem.eventCode)        << ")\n";
+  out << "statusCode: ("  << evtStatusCodeText(evtCodeFilterElem.statusCode) << ")\n";
+  out << "eventFilter: (" << evtCodeFilterElem.eventFilter                   << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::evtTypeFilterElem& evtTypeFilterElem)
+{
+  out << "eventType: ("   << evtTypeFilterElem.eventType   << ")\n";
+  out << "eventFilter: (" << evtTypeFilterElem.eventFilter << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::evtComponentFilterElem& evtComponentFilterElem)
+{
+  out << "componentName: (" << evtComponentFilterElem.componentName.in() << ")\n";
+  out << "eventFilter: ("   << evtComponentFilterElem.eventFilter        << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::evtDescr& evtDescr)
+{
+  out << "eventCode: ("        << evtCodeText(evtDescr.eventCode)        << ")\n";
+  out << "statusCode: ("       << evtStatusCodeText(evtDescr.statusCode) << ")\n";
+  out << "eventTypes: ("       << evtDescr.eventTypes                    << ")\n";
+  out << "eventDescription: (" << evtDescr.eventDescription.in()         << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::evtDescrANY_CODE_TYPE& evtDescrANY_CODE_TYPE)
+{
+  out << "eventDescr: ("    << evtDescrANY_CODE_TYPE.eventDescr    << ")\n";
+  out << "componentList: (" << evtDescrANY_CODE_TYPE.componentList << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::evtDescrCOMPONENT& evtDescrCOMPONENT)
+{
+  out << "componentName: (" << evtDescrCOMPONENT.componentName.in() << ")\n";
+  out << "eventDescr: ("    << evtDescrCOMPONENT.eventDescr         << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::Event& event)
+{
+  out << "timeStamp: ("       << timestampText(event.timeStamp)      << ")\n";
+  out << "kioskID: (\n"       << event.kioskID                       << ")\n";
+  out << "kioskLocation: (\n" << event.kioskLocation                 << ")\n";
+  out << "gpsLocation: (\n"   << event.gpsLocation                   << ")\n";
+  out << "componentRef: ("    << event.componentRef.in()             << ")\n";
+  out << "functionName: ("    << event.functionName.in()             << ")\n";
+  out << "eventCode: ("       << evtCodeText(event.eventCode)        << ")\n";
+  out << "eventMode: ("       << event.eventMode                     << ")\n";
+  out << "eventType: ("       << event.eventType                     << ")\n";
+  out << "eventCategory: ("   << event.eventCategory                 << ")\n";
+  out << "statusCode: ("      << evtStatusCodeText(event.statusCode) << ")\n";
+  out << "elud: ("            << eludText(event.elud)                << ")\n";
+  out << "eventData: (\n"     << eventDataText(event.eventData)      << ")\n";
+  return out;
+}
+
+std::ostream& operator<<(std::ostream& out, const types::evtComponentFilterUnion::_filterCODE_seq& filterCODE)
+{
+  out << "filterCODE: (\n";
+  for(CORBA::ULong i= 0; i < filterCODE.length(); i++)
+  {
+    out << evtCodeText(filterCODE[i]) << "\n";
+  }
+  out << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::evtComponentFilterUnion::_filterTYPE_seq& filterTYPE)
+{
+  out << "filterTYPE: (\n";
+  for(CORBA::ULong i= 0; i < filterTYPE.length(); i++)
+  {
+    out << filterTYPE[i] << "\n";
+  }
+  out << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::evtAcquireFilter::_filterCODE_seq& filterCODE)
+{
+  out << "filterCODE: (\n";
+  for(CORBA::ULong i= 0; i < filterCODE.length(); i++)
+  {
+    out << evtCodeText(filterCODE[i]) << "\n";
+  }
+  out << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::evtAcquireFilter::_filterTYPE_seq& filterTYPE)
+{
+  out << "filterTYPE: (\n";
+  for(CORBA::ULong i= 0; i < filterTYPE.length(); i++)
+  {
+    out << filterTYPE[i] << "\n";
+  }
+  out << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::evtDescrCOMPONENT::_eventDescr_seq& eventDescr)
+{
+  out << "eventDescr: (\n";
+  for(CORBA::ULong i= 0; i < eventDescr.length(); i++)
+  {
+    out << eventDescr[i] << "\n";
+  }
+  out << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::evtDescr::_eventTypes_seq& eventTypes)
+{
+  out << "eventTypes: (\n";
+  for(CORBA::ULong i= 0; i < eventTypes.length(); i++)
+  {
+    out << eventTypes[i] << "\n";
+  }
+  out << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::msgDataType::_records_seq& records)
+{
+  out << "records: (\n";
+  for(CORBA::ULong i= 0; i < records.length(); i++)
+  {
+    out << records[i] << "\n";
+  }
+  out << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::namelist& namelist)
+{
+  out << "namelist: (\n";
+  for(CORBA::ULong i= 0; i < namelist.length(); i++)
+  {
+    out << namelist[i] << "\n";
+  }
+  out << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::indexList& indexList)
+{
+  out << "indexList: (\n";
+  for(CORBA::ULong i= 0; i < indexList.length(); i++)
+  {
+    out << indexList[i] << "\n";
+  }
+  out << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::iorlist& iorlist)
+{
+  out << "iorlist: (\n";
+  for(CORBA::ULong i= 0; i < iorlist.length(); i++)
+  {
+    out << iorlist[i] << "\n";
+  }
+  out << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::EnvironmentComponents& environmentComponents)
+{
+  out << "EnvironmentComponents: (\n";
+  for(CORBA::ULong i= 0; i < environmentComponents.length(); i++)
+  {
+    out << environmentComponents[i] << "\n";
+  }
+  out << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::evtCodeFilter& evtCodeFilter)
+{
+  out << "EvtCodeFilter: (\n";
+  for(CORBA::ULong i= 0; i < evtCodeFilter.length(); i++)
+  {
+    out << evtCodeFilter[i] << "\n";
+  }
+  out << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::evtTypeFilter& evtTypeFilter)
+{
+  out << "EvtTypeFilter: (\n";
+  for(CORBA::ULong i= 0; i < evtTypeFilter.length(); i++)
+  {
+    out << evtTypeFilter[i] << "\n";
+  }
+  out << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::evtComponentFilter& evtComponentFilter)
+{
+  out << "EvtComponentFilter: (\n";
+  for(CORBA::ULong i= 0; i < evtComponentFilter.length(); i++)
+  {
+    out << evtComponentFilter[i] << "\n";
+  }
+  out << ")\n";
+  return out;
+}
+
+std::ostream& operator<<(std::ostream& out, const types::evtCodeFilterUnion& evtCodeFilterUnion)
+{
+  out << "EvtCodeFilterUnion: (\n";
+  out << "type: (\n" << evtCodeFilterUnion._d() << ")\n";
+  switch(evtCodeFilterUnion._d())
+  {
+    case types::component_:
+    {
+      out << "filterCOMPONENT: (" << evtCodeFilterUnion.filterCOMPONENT() << ")\n";
+      break;
+    }
+  }
+  out << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::evtTypeFilterUnion& evtTypeFilterUnion)
+{
+  out << "EvtTypeFilterUnion: (\n";
+  out << "type: (\n" << evtTypeFilterUnion._d() << ")\n";
+  switch(evtTypeFilterUnion._d())
+  {
+    case types::component_:
+    {
+      out << "filterCOMPONENT: (" << evtTypeFilterUnion.filterCOMPONENT() << ")\n";
+      break;
+    }
+  }
+  out << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::evtComponentFilterUnion& evtComponentFilterUnion)
+{
+  out << "EvtComponentFilterUnion: (\n";
+  out << "type: (\n" << evtComponentFilterUnion._d() << ")\n";
+  switch(evtComponentFilterUnion._d())
+  {
+    case types::code_:
+    {
+      out << "filterCODE: (" << evtComponentFilterUnion.filterCODE() << ")\n";
+      break;
+    }
+    case types::type_:
+    {
+      out << "filterTYPE: (" << evtComponentFilterUnion.filterTYPE() << ")\n";
+      break;
+    }
+  }
+  out << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::evtFilter& evtFilter)
+{
+  out << "EvtFilter: (\n";
+  out << "type: (\n" << evtFilter._d() << ")\n";
+  switch(evtFilter._d())
+  {
+    case types::code_:
+    {
+      out << "filterCODE: (" << evtFilter.filterCODE() << ")\n";
+      break;
+    }
+    case types::type_:
+    {
+      out << "filterTYPE: (" << evtFilter.filterTYPE() << ")\n";
+      break;
+    }
+    case types::component_:
+    {
+      out << "filterCOMPONENT: (" << evtFilter.filterCOMPONENT() << ")\n";
+      break;
+    }
+  }
+  out << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::evtAcquireFilter& evtAcquireFilter)
+{
+  out << "EvtAcquireFilter: (\n";
+  out << "type: (\n" << evtAcquireFilter._d() << ")\n";
+  switch(evtAcquireFilter._d())
+  {
+    case types::code_:
+    {
+      out << "filterCODE: (" << evtAcquireFilter.filterCODE() << ")\n";
+      break;
+    }
+    case types::type_:
+    {
+      out << "filterTYPE: (" << evtAcquireFilter.filterTYPE() << ")\n";
+      break;
+    }
+  }
+  out << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::evtDescription& evtDescription)
+{
+  out << "EvtDescription: (\n";
+  out << "type: (\n" << evtDescription._d() << ")\n";
+  switch(evtDescription._d())
+  {
+    case types::type_:
+    {
+      out << "eventDescrANY_CODE_TYPE: (" << evtDescription.eventDescrANY_CODE_TYPE() << ")\n";
+      break;
+    }
+    case types::component_:
+    {
+      out << "eventDescrCOMPONENT: (" << evtDescription.eventDescrCOMPONENT() << ")\n";
+      break;
+    }
+  }
+  out << ")\n";
+  return out;
+}
+std::ostream& operator<<(std::ostream& out, const types::bytestream& bytestream)
+{
+  out << bytestreamText(bytestream);
+  return out;
+}
+
+/*
+
+module types
+{
+    typedef bytestream aeaDataType;
+    typedef bytestream svgDataType;
+    typedef octet nilDataType;
+    typedef any correlation;
+    typedef any datastream;
+};
+*/
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/textIDL/static/makefile.mak b/SelfServiceCommon/Massai/cpp/textIDL/static/makefile.mak
new file mode 100644
index 00000000..2d8a212e
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/textIDL/static/makefile.mak
@@ -0,0 +1,33 @@
+######################################################################
+#
+# /vob/SelfServicePlatform/Massai/cpp/textIDL/static/makefile.mak
+#
+######################################################################
+
+!include $(BUILDROOT)\Build\cpp\makefile.common.mak
+
+MY_CFLAGS = \
+    -DTAO_AS_STATIC_LIBS -DACE_AS_STATIC_LIBS \
+    -I$(P_INC) \
+    $(INC_INTERFACES) \
+    $(INC_ACETAO)
+
+######################################################################
+
+MY_LIB1 = $(LIB_DST_TEXTIDLS)
+
+MY_LIB1_OBJS = \
+    $(_OBJ)\textgppdev.obj \
+    $(_OBJ)\textidl.obj \
+    $(_OBJ)\textmdci.obj \
+    $(_OBJ)\textcodes.obj \
+    $(_OBJ)\textcharacteristics.obj \
+    $(_OBJ)\texttypes.obj \
+    $(_OBJ)\local_def.obj
+
+######################################################################
+
+
+!include $(BUILDROOT)\Build\cpp\makefile.rules.mak
+
+######################################################################
diff --git a/SelfServiceCommon/Massai/idl/.classpath b/SelfServiceCommon/Massai/idl/.classpath
new file mode 100644
index 00000000..58020eef
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/.classpath
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="Cuss"/>
+	<classpathentry kind="src" path="Massai"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/SelfServiceCommon/Massai/idl/.project b/SelfServiceCommon/Massai/idl/.project
new file mode 100644
index 00000000..a458b824
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>IDL</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/SelfServiceCommon/Massai/idl/Cuss/characteristics.idl b/SelfServiceCommon/Massai/idl/Cuss/characteristics.idl
new file mode 100644
index 00000000..0a582556
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Cuss/characteristics.idl
@@ -0,0 +1,560 @@
+//---------------------------------------------------------------------------
+//
+//  File:      characteristics.idl
+//
+//  Purpose:   CUSS virtual components characteristics
+//
+//  Date:      02.03.2009
+//
+//  Version:   1.3
+//
+//  Author:    CUSS Management Group
+//
+//  Copyright(c) 2003,2009 International Air Transport Association, All Rights Reserved
+//
+//  Note:      This IDL file is backward-compatible with that of CUSS 0.2.1 and CUSS 1.0
+//             Please refer to the CUSS 1.2 Technical Specification for more information
+//
+//  Changed:   Baggage handling support added. (Nicolas Bruns, 29.06.2004)
+//
+//  @date 24.01.2013
+//  @li V1.3
+//  @li Mantis 0025566: WeightScale: support standalone Scale (BaggageScale CUSS1.3)
+//  @li added interface Scale
+//----------------------------------------------------------------------------
+
+#ifndef CHARACTERISTICS_IDL
+#define CHARACTERISTICS_IDL
+
+#pragma prefix "cuss.iata.org"
+
+#include "codes.idl"
+#include "types.idl"
+
+/** Definition of the Virtual Component Characteristics 
+ *
+ *  @note: Some attributes may not be applicable depending on the corresponding real component. 
+ *         Non-applicable values are either represented as:
+ *         -1                      (for attributes of type long or string) or 
+ *         nonApplicableValue      (for attributes of enumerated types).
+ */
+
+module Characteristics
+{
+
+    /** Common Characteristic definition
+        Manufacturer specifications for system management purposes but not restricted to it.
+    */
+    interface Manufacturer
+    {
+
+        /** Component identification for use by system manager.
+            This identification gives a more precise definition of the component, e.g. ATB-PRINTER-BIN1
+        */        
+        readonly attribute string realComponentIdentification;
+        
+        /** Describes whether the firmware can be updated or not */
+        readonly attribute boolean downloadableFirmware;
+
+        /** Version of firmware/software */
+        readonly attribute string firmwareVersion;
+
+        /** Name of manufacturer */
+        readonly attribute string manufacturerName;
+
+        /** Model number of hardware component */
+        readonly attribute string modelNumber;
+
+        /** Serial number of hardware component */
+        readonly attribute string serialNumber;
+    };
+
+    /** Common Characteristic definition */
+    interface MediaType
+    {
+        /** Definition of media types */       
+        enum MediaTypeDef
+        {
+          nonApplicableMediaType, /**< Non applicable characteristic value */
+
+          MagneticStripe,         /**< Documents with a magnetic stripe */
+          Chip,                   /**< Documents with a chip like RF-Baggage tags */
+          Printed,                /**< Any printed document (OCR/BarCode/Plain paper) */
+          JIS                     /**< JIS cards */
+        };                
+
+        /** Attribute containing one media type */        
+        readonly attribute MediaTypeDef type;
+    };                    
+
+    /** Definition of the list of media types */
+    typedef sequence <MediaType> MediaTypeListDef;
+    
+    /** Common Characteristic definition */
+        interface MediaTypeList
+    {
+        /** List of media types */        
+        readonly attribute MediaTypeListDef mtList;
+    };
+    
+    /** Common Characteristic definition */
+    interface Location
+    {
+
+        /** Supported image types  */
+        enum ImageType
+        {
+          nonApplicableImageType, /**< Non applicable characteristic value */
+
+          notAvailable,           /**< no image available */ 
+          BMP,                    /**< Microsoft bitmap file */ 
+          JPEG,                   /**< JPEG file */
+          PNG,                    /**< Portable network graphics file */
+          Flash                   /**< Macromedia flash file */ 
+        };                
+
+        /** URL to location image */        
+        readonly attribute string Map;
+        
+        /** The type of the image as specified above */        
+        readonly attribute ImageType mapType;
+
+        /** URL to usage image/animation */        
+        readonly attribute string howTo;
+
+        /** The type of the image/animation as specified above */        
+        readonly attribute ImageType howToType;
+
+        /** Definition of where to find components */
+        enum LocationType
+        {
+            nonApplicableLocationType, /**< Non applicable characteristic value */
+
+            inKiosk,                   /**< device is located in the kiosk */
+            inArea                     /**< device is located outside the kiosk */
+        };
+
+        /** Where to find the component */        
+        readonly attribute LocationType componentLocation;
+    };
+
+    /** Common Characteristic definition */
+    interface ComponentFonts
+    {
+        /** CUSS supported barcodes */        
+        enum BarcodeStandard
+        {
+          nonApplicableBarcodeStandard, /**< Non applicable characteristic value */
+
+          Code39,                       /**< Barcode definition */
+          Code128,                      /**< Barcode definition */
+          Code2of5                      /**< Barcode definition */
+        };
+
+        /** specifies which of the above standards was used */        
+        readonly attribute BarcodeStandard usedStandard;
+
+        /** Specification of a single font */        
+        struct FontSpec
+        {
+          string         fontName;          /**< Name of the font */
+          sequence<long> fontSizes;         /**< List of available font sizes, not set if font is a vector font */
+          boolean        vectorFont;        /**< Font attribute */
+          boolean        bold;              /**< Font attribute */
+          boolean        italic;            /**< Font attribute */
+          boolean        underlined;        /**< Font attribute */
+          boolean        strikeThrough;     /**< Font attribute */
+          boolean        reverse;           /**< Font attribute */
+          boolean        superScript;       /**< Font attribute */
+          boolean        subScript;         /**< Font attribute */
+          long           colorDepth;        /**< Font attribute */
+          long           spacing;           /**< Font attribute */
+          long           characterLength;   /**< Font attribute (0 = variable length, n = fixed length) */
+        };
+
+        /** FontList declaration */        
+        typedef sequence<FontSpec> FontList;
+
+        /** Fonts available from this component */        
+        readonly attribute FontList Fonts;
+    };
+
+    /** Common Characteristic definition */
+    interface Bin
+    {
+
+        /** Describes the maximum number of documents a bin can hold */
+        readonly attribute long BinSize;
+
+        /** Shows the high threshold of the bin if corresponding sensor is installed
+            Refers to the MEDIA_HIGH event in <i>codes.idl</i>
+        */
+        readonly attribute long AllmostFullLevel;
+
+        /** Shows low threshold of the bin if corresponding sensor is installed
+            Refers to the MEDIA_LOW event in <i>codes.idl</i>
+        */
+        readonly attribute long AllmostEmptyLevel;
+
+        /** Shows the current number of documents in the bin.
+         *  This value is adjusted by the platform automatically 
+         *  after documents have been printed.
+         */        
+        readonly attribute long currentNoOfDocuments;
+    };
+
+    /** Common Characteristic definition */
+    interface IOMode
+    {
+        /** MediaInput/MediaOutput supported modes */        
+        enum InputOutputMode
+        {
+          nonApplicableInputOutputMode, /**< Non applicable characteristic value */
+
+          CheckIn,                      /**< Check-in mode for ATB printers */
+          Revalidation                  /**< Revalidation mode for ATB printer */
+        };
+        
+        /** The currently used mode for reading/writing. */                    
+        readonly attribute InputOutputMode mode;
+
+        /**
+         *  Set the input/output mode for ATB printers.
+         *
+         *  @param  appRef  A valid application reference
+         *  @param  mode    The input/output mode to be used (check-in or Revalidation)
+         *  
+         */
+        returncodes::rc setIOMode(in types::reference appRef, in InputOutputMode mode);
+    };
+    
+    /** Capture characteristics */
+    interface Capture : Bin, Manufacturer { };
+
+    /** DataInput characteristics 
+     *
+     *  @note  In CUSS 1.0, supportedDataTypes attribute is missing.
+     *         The following data types are assumed :
+     *         string         as clockDataType for Clock device 
+     *         const long     as switchDataType for sensor devices 
+     *
+     */
+    interface DataInput : Manufacturer 
+    { 
+        /** time difference in hours relative to GMT 
+         *
+         * @note   This applies only to Clock device
+         *
+         */        
+        readonly attribute long timeZone; 
+    };
+
+    /** DataOutput characteristics */
+    interface DataOutput : Manufacturer { };
+
+    /** Dispenser characteristics */
+    interface Dispenser : Bin, Location, Manufacturer
+    {
+       /** Dispenser types */
+       enum DispenserType
+       {
+           nonApplicableDispenserType, /**< Non applicable characteristic value */
+
+           real_,                      /**< User can't access media without an <i>offer-command</i> */
+           virtual_                    /**< User can access media all the time */
+       };
+
+       /** Specifies the kind of the dispenser */
+       readonly attribute DispenserType kind;
+    };
+
+    /** Feeder characteristics */
+    interface Feeder : Bin, Manufacturer { };
+
+    /** Description of data types used by the MediaInput characteristics */    
+    enum DataType
+    {
+        nonApplicableDataType, /**< Non applicable characteristic value */
+            
+        AEA,                   /**< CUSS - AEA data type*/
+        MSG,                   /**< CUSS - MSG data type*/
+        SVG                    /**< CUSS - SVG data type*/
+    };
+
+    /** Definition of the list of data types */    
+    typedef sequence <DataType> DataTypeList;
+    
+    /** MediaInput characteristics */
+    interface MediaInput : IOMode, MediaTypeList, ComponentFonts, Location, Manufacturer
+    {
+        /** Describes the type of media reader */
+        enum ReaderType
+        {
+            nonApplicableReaderType, /**< Non applicable characteristic value */
+
+            Motorized,               /**< Motorized reader like standard card readers */
+            DIP,                     /**< Manual insertion or removal of documents */
+            Swipe,                   /**< Document has to be swiped through reader manually */
+            Contactless,             /**< Document is read via an antenna (radio frequency) */
+            FlatbedScan,             /**< Standard scanner technology or camera */
+            PenScan                  /**< Standard barcode reader technology */
+        };
+
+        /** The kind of reader which is handled by this component */        
+        readonly attribute ReaderType typeOfReader;
+
+        /** The list of data types supported by this component */        
+        readonly attribute DataTypeList supportedDataTypes;
+
+        /** Describes the type of data stream that is supported by this component. 
+   *
+   *  @note   This attribute is not used in CUSS 1.0
+   *   
+         */                      
+        readonly attribute DataType setupDataType;
+
+        /** The number of tracks that can be read by the components.
+            \li 1 indicates only track 1 is readable
+            \li 2 indicates track 1 and track 2 are readable
+            \li 3 indicates tracks 1 to 3 are readable, and so on
+        */
+        readonly attribute long numberOfTracks;
+    };
+
+    /** MediaOutput characteristics */
+    interface MediaOutput : IOMode, MediaTypeList, ComponentFonts, Location, Manufacturer
+    {
+        /** Media types */
+        enum MediaType
+        {
+          nonApplicableMediaType, /**< Non applicable characteristic value */
+
+          Ticket,                 /**< TAT- or ATB ticket */ 
+          BoardingPass,           /**< Boarding pass */
+          GeneralPurposeDoc,      /**< General purpose document */ 
+          BaggageTag,             /**< Baggage tag */ 
+          InsertedDoc,            /**< Document inserted by the user */
+          Card,                   /**< Any type of card */
+          BoardingPassFirst,      /**< ATB1 or ATB2 boarding passes for first Class */
+          BoardingPassBusiness,   /**< ATB1 or ATB2 boarding passes for business class*/
+          BoardingPassEconomy     /**< ATB1 or ATB2 boarding passes for economy class*/
+        };                
+
+        /** Attribute containing the media type */        
+        readonly attribute MediaType type;
+
+        /** The list of data types supported by this component */        
+        readonly attribute DataTypeList supportedDataTypes;
+
+        /** Size of the internal data buffer */
+        readonly attribute long bufferSize;
+
+        /** The number of tracks that can be written by the components.
+            \li 1 indicates only track 1 is writable
+            \li 2 indicates track 1 and track 2 are writable
+            \li 3 indicates tracks 1 to 3 are writable, and so on
+        */
+        readonly attribute long numberOfTracks;
+
+        /** The minimum length of a document measured in MilliMeters */
+        readonly attribute long minDocumentLength;
+
+        /** The maximum length of a document measured in MilliMeters */
+        readonly attribute long maxDocumentLength;
+
+        /** Printing technology specification 
+         * 
+         *  @note   attribute for mediaTransferType is missing in CUSS 1.0 IDL.
+         *          Instead, its value (DirectThermal or ThermalTransfer ) 
+         *          should be inserted somewhere inside the string representing 
+         *          Manufacturer::ModelNumber attribute. This was agreed upon
+         *          in order to keep CUSS 1.0 IDLs backward-compatible to 0.2.1.
+         *
+         */
+        enum MediaTransferType
+        {
+          nonApplicableMediaTransferType, /**< Non applicable characteristic value */
+
+          DirectThermal,                  /**< Thermal printing device */
+          ThermalTransfer                 /**< Ribbon printing device */
+        };
+
+
+        /** The maximum printing size in X direction measured in MilliMeters */
+        readonly attribute long maxPrintSizeX;
+
+        /** The maximum printing size in Y direction measured in MilliMeters */
+        readonly attribute long maxPrintSizeY;
+
+        /** Printing orientations */        
+        enum PrintOrientationDef
+        {
+          nonApplicablePrintOrientation, /**< Non applicable characteristic value */
+
+          Portrait,                      /**< printing orientation */
+          Landscape                      /**< printing orientation */
+        };
+        
+        /** The current print orientation. */                  
+        readonly attribute PrintOrientationDef printOrientation;
+
+        /**
+         *  Sets the printing orientation to be used by this component.
+         *
+         *  @param  appRef      A valid application reference
+         *  @param  orientation The printing orientation (Portrait or Landscape)
+         *  
+         */
+        returncodes::rc setPrintOrientation(in types::reference appRef, in PrintOrientationDef orientation);
+    };
+
+    /** Storage characteristics */
+    interface Storage : Manufacturer
+    {   
+
+        /** Specifies the total size available for an application on a disk */        
+        readonly attribute long size;
+
+        /** Specifies the path to writeable/readable location 
+            (all path specifications end with a separator, e.g. slash or backslash)
+        */        
+        readonly attribute string path;
+    };
+
+    /** Display characteristics */    
+    interface Display : Location, Manufacturer
+    {
+      /** Resolution list definition */      
+      typedef sequence<long> ResolutionList;
+
+      /** List of supported screen resolutions 
+          \li  800 indicates a resolution of  800 by  600
+          \li 1024 indicates a resolution of 1024 by  768
+          \li 1280 indicates a resolution of 1280 by 1024
+          \li 1600 indicates a resolution of 1600 by 1200
+          
+          @attention Currently only one screen resolution should be used if the 
+                     touch screen overlay is not automatically re-calibrated
+      */      
+      readonly attribute ResolutionList displayResolution;
+      
+      /** Currently used screen resolution. */      
+      readonly attribute long currentResolution;
+
+      /**
+       *  Sets a new resolution for the display.
+       *
+       *  @param  appRef     A valid application reference
+       *  @param  resolution The screen resolution to be used by the application
+       *
+       */
+      returncodes::rc setScreenResolution(in types::reference appRef, in long resolution);
+
+      /** Physical screen size measured in MilliMeter */      
+      readonly attribute long screenDiagonal;
+    };
+    
+    /** UserInput characteristics */
+    interface UserInput : Location, Manufacturer { };
+
+    /** UserOutput characteristics */
+    interface UserOutput : Location, Manufacturer { };
+    
+    /** Network characteristics 
+        Standard attributes only for this component.
+    */
+    interface Network : Manufacturer { };
+    /** Application characteristics */
+    interface Application : Manufacturer 
+    { 
+        /** Kiosk Application identification */        
+        readonly attribute types::akID identification;
+
+        /** Definition of the different address types */        
+        enum ContactAddressType
+        {
+            nonApplicableContactAddress, /**< Non applicable characteristic value */
+            
+            None,                        /**< No address available */
+            Pager,                       /**< Page address */
+            EMail,                       /**< EMail address */
+            Phone,                       /**< Phone address */
+            Postal,                      /**< Postal address */
+            Fax,                         /**< Fax address */
+            Network,                     /**< Network address (Remote network support application) */
+            URL,                         /**< Uniform Resource Locator (Internet support application) */
+            IOR                          /**< Interoperable Object Reference (CORBA support application) */
+        };
+        
+        /** Definition for a single contact field */        
+        struct Contact
+        {
+          string             name;    /**< Name of the person to contact */
+          string             company; /**< Name of the company to contact */
+          string             note;    /**< Unspecific note on person or company */          
+          string             address; /**< Address to be used */
+          ContactAddressType type;    /**< Specifies the type of the address */
+        };
+
+        /** Definition for the contact list */        
+        typedef sequence <Contact> ContactList;
+        
+        /** The list of all available contacts */        
+        readonly attribute ContactList allContacts;
+        
+        /** Specifies the first of IP-Port range that can be used by this application */        
+        readonly attribute long firstIPPort;
+
+        /** Specifies the last of IP-Port range that can be used by this application */
+        readonly attribute long lastIPPort;
+    };
+
+    /** Scale characteristics */
+
+    interface Scale : Location, Manufacturer
+    {
+        /** the maximum weight of the baggage (in grams) */
+        readonly attribute long maxWeight;
+    };
+    
+    /** Conveyor characteristics */
+    interface Conveyor : Location, Manufacturer
+    {
+        /** Conveyor types */
+        enum ConveyorType
+        {
+            nonApplicableConveyorType,  /**< Non applicable characteristic value */
+
+            Scale,                      /**< Conveyor has a scale only */
+            BCR,                        /**< Conveyor has a barcode reader only */
+            Scale_BCR,                  /**< Conveyor has a scale and a barcode reader */
+            Scale_ParkPosition,         /**< Conveyor has a scale and a park position for bags */
+            BCR_ParkPosition,           /**< Conveyor has a barcode reader and a park position for bags */
+            Scale_BCR_ParkPosition      /**< Conveyor has a scale, a barcode reader and a park position for bags */
+        };
+
+        /** the maximum weight of the baggage */
+        readonly attribute long maxWeight;
+
+        /** Specifies the kind of the conveyor */
+        readonly attribute ConveyorType typeOfConveyor;
+
+        /** the maximum width of baggage */
+        readonly attribute long maxWidth;
+
+        /** the maximum height of baggage */
+        readonly attribute long maxHeigth;
+
+        /** the maximum length of baggage */
+        readonly attribute long maxLength;
+
+        /** the guarenteed number of bags that can be stored at least in the parking position */
+        readonly attribute long guarenteedNoOfBags;
+
+        /** the actual number of bags in the parking position */
+        readonly attribute long currentNoOfBagsParked;
+    };
+};
+
+#endif // CHARACTERISTICS 
+ 
diff --git a/SelfServiceCommon/Massai/idl/Cuss/codes.idl b/SelfServiceCommon/Massai/idl/Cuss/codes.idl
new file mode 100644
index 00000000..847e5b75
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Cuss/codes.idl
@@ -0,0 +1,299 @@
+//---------------------------------------------------------------------------
+//
+//  File:      codes.idl
+//
+//  Purpose:   Definition of CUSS codes
+//
+//  Date:      02.03.2009
+//
+//  Version:   1.3
+//
+//  Author:    CUSS Management Group
+//
+//  Copyright(c) 2003,2009 International Air Transport Association, All Rights Reserved
+//
+//  Note:      This IDL file is backward-compatible with that of CUSS 0.2.1 and CUSS 1.0
+//             Please refer to the CUSS 1.2 Technical Specification for more information
+//
+//  Changed:   Added baggage handling status codes (Nicolas Bruns, 29.06.2004)
+//
+//  @date 24.01.2013
+//  @li V1.3
+//  @li Mantis 0025566: WeightScale: support standalone Scale (BaggageScale CUSS1.3)
+//  @li added CUSS1.3 dataStatus and statusCodes
+//---------------------------------------------------------------------------
+
+#ifndef CODES_IDL
+#define CODES_IDL
+
+#pragma prefix "cuss.iata.org"
+
+/** Directive related return codes */
+
+module returncodes
+{
+    typedef long rc; /**< Type definition for interface return codes */
+    
+    const long RC_OK                             =  0;  /**< Directive accepted */
+    const long RC_REFERENCE                      = -1;  /**< Invalid application reference */
+    const long RC_STATE                          = -2;  /**< Application is not in the correct state to invoke this directive */
+    const long RC_DENIED                         = -3;  /**< Access denied (application is not allowed to use that component) */
+    const long RC_PARAMETER                      = -4;  /**< Error in parameters (e.g. wrong event passed) */
+    const long RC_ANY_PARAMETER                  = -5;  /**< Error in CORBA::any type */
+    const long RC_LISTENER                       = -6;  /**< No listener set */
+    const long RC_SHARE                          = -7;  /**< Request in wrong share mode (component may be blocked by any application) */
+    const long RC_UNAUTHORIZED                   = -8;  /**< Unauthorized command within data stream (SVG or AEA) */
+    const long RC_ERROR                          = -9;  /**< Any error that is not covered by errors defined above */
+    const long RC_NOT_SUPPORTED                  = -10; /**< Directive is not supported (i.e. not implemented) */
+};
+
+/** Data related states */
+
+module datastatus
+{
+    const long DS_OK                             = 0; /**< Data is OK */
+    const long DS_CORRUPTED                      = 1; /**< Data is corrupted */
+    const long DS_INCOMPLETE                     = 2; /**< Data is incomplete */
+    const long DS_ZEROLENGTH                     = 3; /**< Data is of length zero */
+
+    const long DS_DOCUMENT_AUTHENTICATION_FAILED = 4; /**< Authentication of document data failed */
+    const long DS_INVALID                        = 5; /**< Document read but a security feature is missing */
+    const long DS_MISMATCH                       = 6; /**< Document read but data inconsistent with security feature */
+
+    const long DS_TYPES_FOID_ISO                 = 100;   /** ISO track data with FOID Data truncation */
+    const long DS_TYPES_PAYMENT_ISO              = 200;   /** ISO track data without truncation */
+    const long DS_TYPES_DISCRETIONARY_ISO        = 300;   /** ISO track data with DISCRETIONARY Data truncation */
+
+    const long DS_TYPES_FOID_JIS2                = 14100; /** JIS-2 track data with FOID Data truncation */
+    const long DS_TYPES_PAYMENT_JIS2             = 14200; /** JIS-2 track data without truncation */
+    const long DS_TYPES_DISCRETIONARY_JIS2       = 14300; /** JIS-2 track data with DISCRETIONARY Data truncation */
+
+    const long DS_TYPES_ISO                      = 0;     /** ISO encoded data */
+    const long DS_TYPES_VING                     = 1000;  /** VING encoded data */
+    const long DS_TYPES_TESSA                    = 2000;  /** TESSA encoded data */
+    const long DS_TYPES_SAFLOK                   = 3000;  /** SAFLOK encoded data */
+    const long DS_TYPES_TIMELOX                  = 4000;  /** TIMELOC encoded data */
+    const long DS_TYPES_KABA_ILCO                = 5000;  /** KABA iLco encoded data */
+    const long DS_TYPES_KABA_ILCO_FOLIO          = 6000;  /** KABA iLco (folio) encoded data */
+
+    const long DS_TYPES_IMAGE_IR                 = 7000;  /* Infrared image */
+    const long DS_TYPES_IMAGE_VIS                = 8000;  /* Visible image */
+    const long DS_TYPES_IMAGE_UV                 = 9000;  /* Ultraviolet image */
+    const long DS_TYPES_IMAGE_PHOTO              = 10000; /* Photo image */
+    const long DS_TYPES_IMAGE_COAX               = 11000; /* Coaxial image */
+    const long DS_TYPES_CODELINE                 = 12000; /* Codeline data */
+    const long DS_TYPES_BARCODE                  = 13000; /* Barcode data */
+    const long DS_TYPES_MIWA                     = 14000; /* Miwa data */
+    const long DS_TYPES_JIS2                     = 14000; /* JIS2 data */
+
+    const long DS_TYPES_SCAN_PDF417              = 15000; /* PDF417 2D barcode */
+    const long DS_TYPES_SCAN_AZTEC               = 15100; /* Aztec 2D barcode */
+    const long DS_TYPES_SCAN_DMATRIX             = 15200; /* Datamatrix 2D barcode */
+    const long DS_TYPES_SCAN_QR                  = 15300; /* QR Code 2D barcode */
+    const long DS_TYPES_SCAN_CODE39              = 15400; /* Code39     1D barcode */
+    const long DS_TYPES_SCAN_CODE128             = 15500; /* Code128    1D barcode */
+    const long DS_TYPES_SCAN_CODE2OF5            = 15600; /* Code2of5   1D barcode */
+
+    const long DS_TYPES_ISO7816                  = 16000; /* communication protocols for PICC/RFID/NFC devices */
+
+    const long DS_TYPES_PRINT_2S_PAGE            = 16100; /* 2-Sided Single-page printing */
+    const long DS_TYPES_PRINT_2S_MULTI           = 16200; /* 2-Sided Multi-page printing */
+    const long DS_TYPES_PRINT_PDF                = 16300; /* Adobe PDF print format */
+
+    const long DS_TYPES_MIFARE                   = 17000; /* communication protocols for PICC/RFID/NFC devices */
+    const long DS_TYPES_SUICA                    = 17010; /* communication protocols for PICC/RFID/NFC devices */
+
+    const long DS_TYPES_ISO15961                 = 18000; /* IATA RFID baggage tag devices */
+    const long DS_TYPES_RP1745                   = 18010; /* IATA Baggage Service Messages Format */
+    const long DS_TYPES_WEIGHT                   = 18020; /* Baggage Weight from Scale or Conveyor */
+
+    const long DS_TYPES_EPASSPORT_DG1            = 20100; /* e-Passport format */
+    const long DS_TYPES_EPASSPORT_DG2            = 20200; /* e-Passport format */
+    const long DS_TYPES_EPASSPORT_DG3            = 20300; /* e-Passport format */
+    const long DS_TYPES_EPASSPORT_DG4            = 20400; /* e-Passport format */
+    const long DS_TYPES_EPASSPORT_DG5            = 20500; /* e-Passport format */
+    const long DS_TYPES_EPASSPORT_DG6            = 20600; /* e-Passport format */
+    const long DS_TYPES_EPASSPORT_DG7            = 20700; /* e-Passport format */
+    const long DS_TYPES_EPASSPORT_DG8            = 20800; /* e-Passport format */
+    const long DS_TYPES_EPASSPORT_DG9            = 20900; /* e-Passport format */
+    const long DS_TYPES_EPASSPORT_DG10           = 21000; /* e-Passport format */
+    const long DS_TYPES_EPASSPORT_DG11           = 21100; /* e-Passport format */
+    const long DS_TYPES_EPASSPORT_DG12           = 21200; /* e-Passport format */
+    const long DS_TYPES_EPASSPORT_DG13           = 21300; /* e-Passport format */
+    const long DS_TYPES_EPASSPORT_DG14           = 21400; /* e-Passport format */
+    const long DS_TYPES_EPASSPORT_DG15           = 21500; /* e-Passport format */
+    const long DS_TYPES_EPASSPORT_DG16           = 21600; /* e-Passport format */
+    const long DS_TYPES_EPASSPORT_DG17           = 21700; /* e-Passport format */
+    const long DS_TYPES_EPASSPORT_DG18           = 21800; /* e-Passport format */
+    const long DS_TYPES_EPASSPORT_DG19           = 21900; /* e-Passport format */
+    const long DS_TYPES_EPASSPORT_DG20           = 22000; /* e-Passport format */
+};
+
+/**
+ *  Event codes for all components and applications.
+ *  These codes are used to indicate the states or state changes for all components
+ */
+
+module eventcodes
+{
+    // virtual component state transition codes
+    
+    const long EC_OK                             = 0;  /**< Used in the returned event for calls to suspendAll, resumeAll or stopAll directives */
+    const long EVENTHANDLING_READY               = 1; /**< Used for soft conditions and Ok only */
+    const long UNAVAILABLE_RELEASED_PLATFORM     = 2; /**< Released by any authorized platform component */
+    const long EVENTHANDLING_UNAVAILABLE         = 3; /**< Caused by a hard condition */
+    const long UNAVAILABLE_RELEASED_APPLICATION  = 4; /**< Component released by the application */
+    const long READY_RELEASED_APPLICATION        = 5; /**< Component released by the application */
+    const long READY_RELEASED_PLATFORM           = 6; /**< Released by any authorized platform component */
+    const long RELEASED_READY                    = 7; /**< State change caused by a call to <i>acquire</i> */
+    const long RELEASED_UNAVAILABLE              = 8; /**< State change caused by a call to <i>acquire</i> */
+
+    // application state transition codes
+
+    const long INITIALIZE_DISABLED               = 101; /**< State transition DISABLE */
+    const long AVAILABLE_DISABLED                = 102; /**< State transition DISABLE */
+    const long ACTIVE_DISABLED                   = 103; /**< State transition DISABLE */
+    const long UNAVAILABLE_AVAILABLE             = 104; /**< State transition WAIT */
+    const long AVAILABLE_ACTIVE                  = 105; /**< State transition ACTIVATE*/
+    const long ACTIVE_AVAILABLE                  = 106; /**< State transition WAIT */
+    const long INITIALIZE_STOPPED_STOP           = 107; /**< State transition STOP */
+    const long AVAILABLE_STOPPED_STOP            = 108; /**< State transition STOP */
+    const long ACTIVE_STOPPED_STOP               = 109; /**< State transition STOP */
+    const long SUSPENDED_STOPPED_STOP            = 110; /**< State transition STOP */
+    const long DISABLED_STOPPED_STOP             = 111; /**< State transition STOP */
+    const long SUSPENDED_AVAILABLE               = 112; /**< State transition RESUME*/
+    const long AVAILABLE_SUSPENDED               = 113; /**< State transition SUSPEND */
+    const long INITIALIZE_STOPPED_RESTART        = 114; /**< State transition RESTART */
+    const long AVAILABLE_STOPPED_RESTART         = 115; /**< State transition RESTART */
+    const long ACTIVE_STOPPED_RESTART            = 116; /**< State transition RESTART */
+    const long DISABLED_STOPPED_RESTART          = 117; /**< Not used in CUSS 1.0. */
+    const long SUSPENDED_STOPPED_RESTART         = 118; /**< State transition RESTART */
+    const long STOPPED_INITIALIZE                = 119; /**< State transition LOAD */
+    const long DISABLED_INITIALIZE               = 120; /**< State transition LOAD */
+    const long UNAVAILABLE_STOPPED_RESTART       = 121; /**< State transition RESTART */
+    const long UNAVAILABLE_DISABLED              = 122; /**< State transition DISABLE */
+    const long UNAVAILABLE_SUSPENDED             = 123; /**< State transition SUSPEND */
+    const long INITIALIZE_SUSPENDED              = 124; /**< Not used in CUSS 1.0 */
+    const long SUSPENDED_DISABLED                = 125; /**< Not used in CUSS 1.0 */
+    const long SUSPENDED_INITIALIZE              = 126; /**< Not used in CUSS 1.0 */
+    const long SUSPENDED_UNAVAILABLE             = 127; /**< State transition RESUME */
+    const long UNAVAILABLE_STOPPED_STOP          = 128; /**< State transition STOP */
+    const long INITIALIZE_UNAVAILABLE            = 129; /**< State transition CHECK */
+    const long AVAILABLE_UNAVAILABLE             = 130; /**< State transition CHECK */
+    const long DISABLED_SUSPENDED                = 131; /**< Not used in CUSS 1.0 */
+
+    // Application/component state codes
+
+    const long RELEASED                          = 201; /**< State RELEASED (peripheral) */
+    const long UNAVAILABLE                       = 202; /**< State UNAVAILABLE (peripheral & application) */
+    const long READY                             = 203; /**< State READY (peripheral) */
+    const long STOPPED                           = 204; /**< State STOPPED (application) */
+    const long SUSPENDED                         = 205; /**< State SUSPENDED (application) */
+    const long DISABLED                          = 206; /**< State DISABLED (application) */
+    const long INITIALIZE                        = 207; /**< State INITIALIZE (application) */
+    const long AVAILABLE                         = 208; /**< State AVAILABLE (application) */
+    const long ACTIVE                            = 209; /**< State ACTIVE (application) */
+    const long BUSY                              = 210; /**< Transient state BUSY (peripheral) */
+
+
+    // Additional codes for CUSS 1.2
+
+    const long ACTIVE_ACTIVE                     = 132; /**< State transition ACTIVE (persistent) */
+    const long STATE_EXPLANATION                 = 1000;/**< Tell CLA why application is in current state */
+    const long ACTIVE_TRANSFER                   = 1001;/**< Request CLA transver ACTIVE to new application */
+    const long TRANSACTION_EXPLANATION           = 1002;/**< Tell CLA what happened in most recent transaction*/
+
+};
+
+/**
+ *  Status codes for all virtual device components.
+ *  These codes are used to describe the states for all virtual components
+ */
+
+module statuscodes
+{
+    const long OK                                =   0; /**< public (private for solicited events) */
+    const long TIMEOUT                           =   1; /**< private (directive related) */
+    const long WRONG_STATE                       =   2; /**< private + platform */
+    const long CANCELLED                         =   3; /**< private */
+    const long SOFTWARE_ERROR                    =   4; /**< private + platform */
+    const long ALMOST_OUT_OF_TIME                =   5; /**< NOT used in CUSS 1.0 */
+    const long OUT_OF_SEQUENCE                   =   6; /**< private */
+
+    const long MEDIA_JAMMED                      = 101; /**< public */
+    const long MEDIA_MISPLACED                   = 102; /**< private + platform (platform only for userless classes) */
+    const long MEDIA_PRESENT                     = 103; /**< private */
+    const long MEDIA_ABSENT                      = 104; /**< private */
+    const long MEDIA_HIGH                        = 105; /**< public */
+    const long MEDIA_FULL                        = 106; /**< public */
+    const long MEDIA_LOW                         = 107; /**< public */
+    const long MEDIA_EMPTY                       = 108; /**< public */
+    const long MEDIA_DAMAGED                     = 109; /**< public */
+    const long MEDIA_INCOMPLETELY_INSERTED       = 110; /**< private */
+
+    // definitions for baggage belt
+    const long BAGGAGE_FULL                      = 120; /**< public */
+    const long BAGGAGE_UNDETECTED                = 121; /**< private + platform */
+    const long BAGGAGE_PRESENT                   = 122; /**< private */
+    const long BAGGAGE_ABSENT                    = 123; /**< private */
+    const long BAGGAGE_OVERSIZED                 = 124; /**< private + platform */
+    const long BAGGAGE_ILLICIT_WEIGHT_CHANGE     = 125; /**< private */
+    const long BAGGAGE_READY_FOR_TAKE_IN         = 126; /**< public */
+    const long BAGGAGE_TOO_MANY_BAGS             = 127; /**< private + platform */
+    const long BAGGAGE_DELIVER                   = 128; /**< private */
+    const long BAGGAGE_UNEXPECTED_BAG            = 129; /**< private + platform */
+    const long BAGGAGE_TOO_HIGH                  = 130; /**< private + platform */
+    const long BAGGAGE_TOO_LONG                  = 131; /**< private + platform */
+    const long BAGGAGE_TOO_FLAT                  = 132; /**< private + platform */
+    const long BAGGAGE_TOO_SHORT                 = 133; /**< private + platform */
+    const long BAGGAGE_PARKED                    = 134; /**< private */
+    const long BAGGAGE_INVALID_DATA              = 135; /**< private + platform */
+    const long BAGGAGE_TRANSPORT_FAILED          = 136; /**< private + platform */
+    const long BAGGAGE_WEIGHT_OUT_OF_RANGE       = 137; /**< private + platform */
+    const long BAGGAGE_JAMMED                = 138; /**< private + platform  */
+    const long BAGGAGE_EMERGENCY_STOP        = 139; /**< private + platform  */
+    const long BAGGAGE_RESTLESS              = 140; /**< private + platform  */
+    const long BAGGAGE_INTRUSION             = 141; /**< private + platform  */
+    const long BAGGAGE_INTRUSION_FRONT       = 142; /**< private + platform  */
+    const long BAGGAGE_INTRUSION_BACK        = 143; /**< private + platform  */
+    const long BAGGAGE_TRANSPORT_BUSY        = 144; /**< private + platform  */
+
+    const long FORMAT_ERROR                      = 201; /**< private + platform (platform only for output classes) */
+    const long LENGTH_ERROR                      = 202; /**< private + platform (platform only for output classes) */
+    const long DATA_MISSING                      = 203; /**< private + platform (platform only for output classes) */
+    const long PHYSICAL_ERROR                    = 204; /**< NOT used in CUSS 1.0 */
+    const long DATA_PRESENT                      = 205; /**< private */
+
+    const long CONSUMABLES                       = 301; /**< public */
+    const long HARDWARE_ERROR                    = 302; /**< public */
+    const long CRITICAL_SOFTWARE_ERROR           = 303; /**< public */
+    const long NOT_REACHABLE                     = 304; /**< public */
+    const long NOT_RESPONDING                    = 305; /**< public */
+    const long THRESHOLD_ERROR                   = 306; /**< public */
+    const long THRESHOLD_USAGE                   = 307; /**< public */
+    const long CONFIGURATION_ERROR               = 308; /**< public */
+    const long SESSION_TIMEOUT                   = 309; /**< private + platform (application related) */
+    const long KILL_TIMEOUT                      = 310; /**< private + platform (application related) */
+
+    const long CUSS_MANAGER_REQUEST              = 801; /**< private + platform */
+    const long SP_SYSTEM_MANAGER_REQUEST         = 802; /**< private + platform */
+    const long AL_SYSTEM_MANAGER_REQUEST         = 803; /**< private + platform */
+    const long CL_APPLICATION_REQUEST            = 804; /**< private + platform */
+    const long AL_APPLICATION_REQUEST            = 805; /**< private + platform */
+
+    // base definition for application generated events (technical)                                                    
+    const long APPLICATION_TECHNICAL_FIRST       = 400; /**< private */
+    const long APPLICATION_TECHNICAL_LAST        = 499; /**< private */
+
+    // base definition for application generated events (security)                                                    
+    const long APPLICATION_SECURITY_FIRST        = 500; /**< private */
+    const long APPLICATION_SECURITY_LAST         = 599; /**< private */
+
+    // base definition for application generated events (business)                                                   
+    const long APPLICATION_BUSINESS_FIRST        = 900; /**< private */
+    const long APPLICATION_BUSINESS_LAST         = 999; /**< private */
+};
+
+#endif // CODES_IDL
+
+ 
diff --git a/SelfServiceCommon/Massai/idl/Cuss/comps.idl b/SelfServiceCommon/Massai/idl/Cuss/comps.idl
new file mode 100644
index 00000000..c1356724
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Cuss/comps.idl
@@ -0,0 +1,741 @@
+//---------------------------------------------------------------------------
+//
+//  File:      comps.idl
+//
+//  Purpose:   Interfaces to CUSS components
+//
+//  Date:      02.03.2009
+//
+//  Version:   1.3
+//
+//  Author:    CUSS Management Group
+//
+//  Copyright(c) 2003,2009 International Air Transport Association, All Rights Reserved
+//
+//  Note:      This IDL file is backward-compatible with that of CUSS 0.2.1 and CUSS 1.0
+//             Please refer to the CUSS 1.2 Technical Specification for more information
+//
+//  Changed:   Added baggage handling support (Nicolas Bruns, 29.06.2004)
+//
+//  @date 24.01.2013
+//  @li V1.3
+//  @li Mantis 0025566: WeightScale: support standalone Scale (BaggageScale CUSS1.3)
+//  @li added interface BaggageScale
+//----------------------------------------------------------------------------
+
+
+/***************************************************************
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!! for c++ comps.tao140.idl is used!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!! merge changes to comps.idl to comps.tao140.idl, too !!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+****************************************************************/
+
+
+#ifndef COMPS_IDL
+#define COMPS_IDL
+
+#include "codes.idl"
+#include "types.idl"
+#include "characteristics.idl"
+
+#pragma prefix "cuss.iata.org"
+
+/** 
+ *  Definition of the interfaces to CUSS Components 
+ *
+ * @note  If your version of the IDL compiler treats Component as a CORBA IDL identifier,
+ *        you will need to escape it by prepending an underscore (_) to it , that is
+ *        replace all occurrences of Component with _Component
+ */
+ 
+module Components
+{
+    /**
+     *  All components are derived from this interface
+     *
+     */     
+    interface Component { };
+
+    /**
+     *  All interfaces for peripherals are derived from this interface
+     */     
+    interface CUSSCntl : Component 
+    {
+
+      /**
+       *  Returns the state/status of the virtual component.
+       *
+       *  @param  to      Timeout value
+       *  @param  appRef  A valid application reference (token) 
+       *  @param  e       Return value
+       *  
+       */     
+      returncodes::rc query (in  types::timeout to,
+                             in  types::reference appRef,
+                             out types::Event e);
+    };
+
+    /**
+     *  Interfaces for virtual components that map to peripheral devices
+     */     
+    interface Peripheral : CUSSCntl
+    {
+
+      /**
+       *  Make the virtual component available for the application.
+       *  The application can subscribe a specific listener associated to the acquired component.
+       *
+       *  @param  to      Timeout value
+       *  @param  appRef  A valid application reference (token) 
+       *  @param  ef      Specifies which events to subscribe to (event filter)
+       *  @param  el      Specifies the event listener to be set for this component
+       *  @param  elud    User data that is submitted with each event sent to the listener
+       *  @param  e       Return value
+       *  
+       *  @note   As implementation of event filtering is not required in CUSS 1.0, 
+       *          event listener passed to acquire will be used as the receiver 
+       *          for all events related to this component. 
+       *
+       */
+      returncodes::rc acquire (in  types::timeout to,          
+                               in  types::reference appRef,    
+                               in  types::evtAcquireFilter ef,  
+                               in  types::evtListener el,      
+                               in  types::correlation elud,                   
+                               out types::Event e);            
+
+      /**
+       *  Makes the virtual component unavailable to the application and unsubscribes events 
+       *  relative to the component.
+       *
+       *  @param  to      Timeout value
+       *  @param  appRef  A valid application reference (token)
+       *  @param  e       Return value
+       *  
+       */
+      returncodes::rc release (in  types::timeout to,
+                               in  types::reference appRef,
+                               out types::Event e);
+
+      /**
+       *  Set up the virtual component and its profile for the application.
+       *
+       *  @param  to      Timeout value
+       *  @param  appRef  A valid application reference (token) 
+       *  @param  ds      datastream for setting the component (e.g. PECTABS)
+       *  @param  e       Return value
+       *  
+       */
+      returncodes::rc setup (in  types::timeout to,
+                             in  types::reference appRef,
+                             in  types::datastream ds,
+                             out types::Event e);
+
+      /**
+       *  Allows to cancel all pending (previously called in asynchronous mode) 
+       *  directives on this specific component.
+       *
+       *  @param  appRef  A valid application reference (token)
+       *  @param  e       Return value
+       *  
+       */     
+      returncodes::rc cancel (in  types::reference appRef,
+                              out types::Event e);
+
+      /**
+       *  Test the virtual and real component as exhaustive as possible.
+       *  If the component is a physical device the device driver should be accessed but
+       *  the physical device should not be exercised.
+       *
+       *  @param  appRef            A valid application reference (token)
+       *  @param  e                 Return value
+       *  
+       */
+      returncodes::rc test (in  types::timeout to,
+                            in  types::reference appRef,
+                            out types::Event e);
+    };
+
+    /**
+     *  Interface for virtual components that provide data to applications
+     */     
+    interface Input
+    {
+
+      /**
+       *  Make the data from the virtual component available to the application.
+       *  
+       *  @param  to      Timeout value
+       *  @param  appRef  A valid application reference (token)
+       *  @param  e       Return value
+       *  
+       */
+      returncodes::rc receive (in  types::timeout to,
+                               in  types::reference appRef,
+                               out types::Event e);
+    };
+
+    /**
+     *  Interface for virtual components that are able to receive data from applications 
+     */    
+    interface Output
+    {
+
+      /**
+       *  Send data from the application to the virtual component.
+       *  
+       *  @param  to      Timeout value
+       *  @param  appRef  A valid application reference (token)
+       *  @param  e       Return value
+       *  
+       */
+      returncodes::rc send (in  types::timeout to,
+                            in  types::reference appRef,
+                            in  types::datastream ds,
+                            out types::Event e);
+    };
+
+    /**
+     *  Interface for virtual components that interact with customers/users
+     */     
+    interface User
+    {
+
+      /**
+       *  Make the virtual component available for the user.
+       *  (e.g. enables a CardReader device for card insertion)
+       *
+       *  @param  to      Timeout value
+       *  @param  appRef  A valid application reference (token)
+       *  @param  e       Return value
+       *  
+       */
+      returncodes::rc enable (in  types::timeout to,
+                              in  types::reference appRef,
+                              out types::Event e);
+
+      /**
+       *  Makes the virtual component unavailable for the user.
+       *  (e.g. disables a CardReader device from card insertion)
+       *
+       *  @param  to      Timeout value
+       *  @param  appRef  A valid application reference (token)
+       *  @param  e       Return value
+       *  
+       */
+      returncodes::rc disable (in  types::timeout to,
+                               in  types::reference appRef,
+                               out types::Event e);
+    };
+
+    /**
+     *  Interface for peripherals that don't interact with users/customers
+     */     
+    interface Userless { };
+
+    /**
+     *  Interface for virtual components that use a physical media
+     *  (e.g. card, coupon, or a paper document)
+     */     
+    interface Media { };
+
+    /**
+     *  Interface for virtual components that don't use a physical media
+     *  (e.g. card, coupon, or a paper document)
+     */     
+    interface Medialess { };
+
+    /**
+     *  Interface for virtual components that transfer data
+     */     
+    interface Data { };
+
+    /**
+     *  Interface for virtual components that don't transfer data
+     */     
+    interface Dataless { };
+
+    /**
+     *  Interface for virtual components that are able to retain media
+     */
+    interface Capture : Peripheral, Userless, Media, Dataless, Characteristics::Capture
+    {
+
+      /**
+       *  Captures the document in the virtual component that is associated to a secured bin.
+       *  
+       *  @param  to      Timeout value
+       *  @param  appRef  A valid application reference (token)
+       *  @param  e       Return value
+       *  
+       */
+      returncodes::rc retain (in  types::timeout to,
+                              in  types::reference appRef,
+                              out types::Event e);
+    };
+
+    /**
+     *  Interface for virtual components that receive media from a Peripheral component 
+     *  and offer it to the user or to another Peripheral component 
+     *  (e.g. ejecting an ATB coupon from the printer to the ESCROW)
+     */
+    interface Dispenser : Peripheral, User, Media, Dataless, Characteristics::Dispenser
+    {
+
+      /**
+       *  Offer the document from the virtual component to the user or to another component.
+       *
+       *  @param  to      Timeout value
+       *  @param  appRef  A valid application reference (token)
+       *  @param  e       Return value
+       *  
+       */
+      returncodes::rc offer (in  types::timeout to,
+                             in  types::reference appRef,
+                             out types::Event e);
+    };
+
+    /**
+     *  Interface for virtual components that are holding media (e.g. ATB stocks)
+     *  and supply it to another Peripheral component
+     */
+    interface Feeder : Peripheral, Userless, Media, Dataless, Characteristics::Feeder 
+    { 
+
+      /**
+       *  Offer the document from a feeder to another virtual component.
+       *
+       *  @param  to      Timeout value
+       *  @param  appRef  A valid application reference (token)
+       *  @param  e       Return value
+       *  
+       */
+      returncodes::rc offer (in  types::timeout to,
+                             in  types::reference appRef,
+                             out types::Event e);
+    };
+
+    /**
+     *  Interface for virtual components used for inbound data transfer (e.g. digital input)
+     */
+    interface DataInput : Peripheral, Userless, Medialess, Data, Input, Characteristics::DataInput { };
+
+    /**
+     *  Interface for virtual components used for outbound data transfer (e.g. network output)
+     */
+    interface DataOutput : Peripheral, Userless, Medialess, Data, Output, Characteristics::DataOutput { };
+    
+    /**
+     *  Interface for virtual components used for inbound user data transfer (e.g. sound device)
+     *
+     *  @note    For the touch screen overlay, which is a native device implemented as UserInput,
+     *           Only acquire, release and query directives should be implemented.
+     *           All other inherited methods are not applicable and should return RC_NOT_SUPPORTED
+     *
+     */    
+    interface UserInput : Peripheral, User, Medialess, Data, Input, Characteristics::UserInput { };
+
+    /**
+     *  Interface for virtual components used for outbound user data transfer (e.g. screen)
+     */
+    interface UserOutput : Peripheral, User, Medialess, Data, Output, Characteristics::UserOutput { };
+    
+    /**
+     *  Interface for virtual components used for reading from media (e.g. mag card reader)
+     */
+    interface MediaInput : Peripheral, User, Media, Data, Input, Characteristics::MediaInput { };
+
+    /**
+     *  Interface for virtual components used for writing to media (e.g. receipt printer)
+     */
+    interface MediaOutput : Peripheral, User, Media, Data, Output, Characteristics::MediaOutput { };
+    
+    /**
+     *  Interface for virtual components used for reading/writing from/to storage (e.g. hard disk)
+     *
+     *  @note    As Storage is a native device, 
+     *           only acquire, release and query directives should be implemented.
+     *           All other inherited methods are not applicable and should return RC_NOT_SUPPORTED
+     *
+     */
+    interface Storage : Peripheral, Userless, Media, Characteristics::Storage { };
+
+    /**
+     *  Interface for virtual components handling a display (eg. kiosk computer screen)
+     *
+     *  @note    As Display is a native device, 
+     *           only acquire, release and query directives should be implemented.
+     *           All other inherited methods are not applicable and should return RC_NOT_SUPPORTED
+     *
+     */
+    interface Display : Peripheral, User, Medialess, Characteristics::Display { };
+
+    /**
+     *  Interface for virtual components handling network access
+     *
+     *  @note    As Network is a native device, 
+     *           only acquire, release and query directives should be implemented.
+     *           All other inherited methods are not applicable and should return RC_NOT_SUPPORTED
+     *
+     */
+    interface Network : Peripheral, Userless, Medialess, Characteristics::Network { };
+
+    /**
+     *  Base definition for virtual components allowing baggage check-in
+     */
+
+    interface BaggageScale : UserInput, Characteristics::Scale { };
+
+
+    /**
+      * This interface is used to query the state and/or characteristics
+      * of a kiosk application that is configured on the platform. 
+      * 
+      */       
+    interface Application : CUSSCntl, Characteristics::Application { };
+
+    /**
+     *  This interface is inherited by the ApplicationManager and the SystemProviderInterface
+     */
+    interface ManagementInterface : Component
+    {
+
+      /**
+       *  This is the first directive to be issued by the application 
+       *  to get basic information on the specific CUSS Platform implementation
+       *  If the application is known by the platform (via configuration), 
+       *  the application reference (token) is returned with this call.
+       *  
+       *  @param  appid     Application identifier which must be configured within the platform 
+       *                    (for minimal security)
+       *  @param  el        Return values 
+       *  
+       */
+      returncodes::rc level (in  types::akID appid,
+                             out types::EnvironmentLevel el);
+
+      /**
+       *  This is the second directive to be issued by an application 
+       *  to get the list of all implemented CUSS components.
+       *  
+       *  @param  appRef  A valid application reference (token)
+       *  @param  ec      List of virtual components which contains the CORBA references (IORs)
+       *  
+       */
+      returncodes::rc components (in  types::reference appRef,
+                                  out types::EnvironmentComponents ec);
+
+      /**
+       *  Allows applications to wait for an event to occur.
+       *  To wait for an event, the application must have subscribed to it via the acquire or 
+       *  registerEvent directives. The waitEvent-directive will be completed at event occurrence
+       *  (any or all in the list) or when the timeout expires.
+       *
+       *  @param  to      Timeout value (positive and negative values have the same effect for this directive)
+       *
+       *  @param  appRef  A valid application reference (token)
+       *  @param  ef      Specifies the event(s) to wait for
+       *  @param  e       Return value
+       *  
+       *  @note   In CUSS 1.0, implementing event filtering is not mandatory.
+       */
+      returncodes::rc waitEvent (in  types::timeout to,
+                                 in  types::reference appRef,
+                                 in  types::evtFilter ef,
+                                 out types::Event e);
+
+      /**
+       *  Generate an event to a system manager.
+       *
+       *  @param  appRef  A valid application reference (token)
+       *  @param  ie      Event to be generated
+       *  @param  oe      Return value
+       *  
+       */
+      returncodes::rc generateEvent(in  types::reference appRef,
+                                    in  types::Event ie,
+                                    out types::Event oe);        
+
+      /**
+       *  Returns a description of an event.
+       *
+       *  @param  appRef  A valid application reference (token)
+       *  @param  ef      Specifies the event(s) to query
+       *  @param  ed      Returned event description(s)
+       *  
+       *  @note   In CUSS 1.0, the implementation of queryEvent is not mandatory.
+       *          In this case, this function should return RC_NOT_SUPPORTED.   
+       */
+      returncodes::rc queryEvent (in  types::reference appRef,   
+                                  in  types::evtFilter ef,
+                                  out types::evtDescription ed); 
+
+      /**
+       *  Subscribe to or discards from receiving any related event notification. The use
+       *  of this directive has an additive effect, which means that a call will not supersede
+       *  a previous call but, instead, subscribe for previous event(s) plus the one(s) in the 
+       *  current call. All subscriptions done with this directive will be received, within the 
+       *  application, via a single listener.
+       *
+       *  @param  appRef  A valid application reference (token)
+       *  @param  act     Either subscribe or discard event(s)
+       *  @param  ef      Specifies the event(s) to register i.e. event filter
+       *  @param  el      Specifies the event listener to be notified
+       *  @param  elud    User data that is submitted to the listener on each invocation
+       *  @param  ed      Return value
+       *  
+       *  @note   As implementation of event filtering is not required in CUSS 1.0, 
+       *          event listener passed to registerEvent directive will be used as the 
+       *          receiver for all application manager events. To receive component events,
+       *          application must register their listener(s) via the acquire directive.
+       */
+      returncodes::rc registerEvent(in  types::reference appRef,
+                                    in  types::action act,
+                                    in  types::evtFilter ef,
+                                    in  types::evtListener el,
+                                    in  types::correlation elud,                   
+                                    out types::Event e);
+
+    };
+
+    /**
+     *  The definition for the Application Manager Interface.
+     *  An application uses this interface for interaction with the platform.
+     *  To access the platform use: <i>corbaloc:<kiosk-IP address>:20000/ApplicationManager</i>
+     */
+    interface ApplicationManager : ManagementInterface
+    {
+      /**
+       *  The application now wants to (re-)initialize. This is a blocking call.
+       *  After this directive returns the application is allowed to initialize.
+       *  This handling ensures that initialization is serialized for all applications. 
+       */
+      returncodes::rc initrequest (in  types::reference appRef,
+                                   out types::Event e);        
+                                                               
+      /**
+       *  This directive is used by the application to request a state change from 
+       *  CUSS Application Manager, which will change the application state if request is approved.
+       *
+       *  @param  appRef  A valid application reference (token)
+       *  @param  ie      Input of application state transition code 
+       *  @param  oe      Return value
+       *  
+       */
+      returncodes::rc notify (in  types::reference appRef,
+                              in  types::akID   id,
+                              in  types::evtCode ec,
+                              out types::Event   e);         
+    };
+
+    /**
+     *  The definition for the System Manager Interface.
+     *  A System Manager Application uses this interface for interaction with the platform
+     *  To access the platform use: <i>corbaloc:<kiosk-IP address>:20001/ServiceProviderInterface</i>
+     *
+     *  @note   In CUSS 1.0, the ServiceProviderInterface is available for both 
+     *          Service Provider System Manager and Application Provider System Manager
+     */
+    interface ServiceProviderInterface : ManagementInterface 
+    {
+
+      /**
+       *  Ask CUSS application manager to load an application 
+       *  (realize Load state transition in application state diagram). 
+       *
+       *  @param  to       Timeout value
+       *  @param  appRef   A valid application reference (token)
+       *  @param  whichApp The identifier of the application to be loaded
+       *  @param  e        Return value
+       *  
+       */
+      returncodes::rc load (in  types::timeout to,
+                            in  types::reference appRef,
+                            in  types::akID whichApp,
+                            out types::Event e);
+
+      /**
+       *  Suspend an application. 
+       *
+       *  @param  appRef   A valid application reference (token)
+       *  @param  whichApp The identification of the application to be suspended
+       *  @param  e        Return value
+       *  
+       */
+      returncodes::rc suspend (in  types::reference appRef,
+                               in  types::akID whichApp,
+                               out types::Event e);
+
+      /**
+       *  Suspend all applications. 
+       *
+       *  @param  appRef   A valid application reference (token)
+       *  @param  e        Return value
+       *  
+       */
+      returncodes::rc suspendAll (in types::reference appRef,
+                                 out types::Event e);         
+
+      /**
+       *  Resume a suspended application to its previous state. 
+       *
+       *  @param  appRef   A valid application reference (token)
+       *  @param  whichApp The identifier of the application to be resumed
+       *  @param  e        Return value
+       *  
+       */
+      returncodes::rc resume (in  types::reference appRef,
+                              in  types::akID whichApp,
+                              out types::Event e);           
+
+      /**
+       *  Resume all suspended applications to their previous state. 
+       *
+       *  @param  appRef   A valid application reference (token)
+       *  @param  e        Return value
+       *  
+       */
+      returncodes::rc resumeAll (in  types::reference appRef,
+                                 out types::Event e);
+      
+      /**
+       *  Stops (unloads) an application. 
+       *
+       *  @param  appRef   A valid application reference (token)
+       *  @param  whichApp The identifier of the application to be stopped
+       *  @param  e        Return value
+       *  
+       */
+      returncodes::rc stop (in  types::reference appRef,
+                            in  types::akID whichApp,
+                            out types::Event e);
+                            
+      /**
+       *  Stops (unloads) all applications. 
+       *
+       *  @param  appRef   A valid application reference (token)
+       *  @param  e        Return value
+       *  
+       */
+      returncodes::rc stopAll (in  types::reference appRef,
+                               out types::Event e);
+    };
+
+    /**
+     *  Interface for virtual components which are able to transport baggage 
+     */
+
+    interface Conveyor : Peripheral, User, Medialess, Data, Input, Characteristics::Conveyor
+    {
+        /**
+         *  Moves current piece of baggage to the parking position.
+         *
+         *  @param  to      Timeout value
+         *  @param  appRef  A valid active application reference
+         *  @param  e       Return value
+         *  
+         *  \b Applies \b to: \li All acquired and virtual components of class Conveyor
+         *  
+         *  \b Available:     \li Airline applications in active state
+         *                    \li SP system manager
+         *  
+         *  \b Access:        \li Exclusive
+         *                    \li Local/Remote
+         *                    \li Synchronous/Asynchronous
+         */
+
+        returncodes::rc accept (in  types::timeout to,
+                                in  types::reference appRef,
+                                out types::Event e);
+
+        /**
+         *  Moves current piece of baggage back to the user.
+         *
+         *  @param  to      Timeout value
+         *  @param  appRef  A valid active application reference
+         *  @param  e       Return value
+         *  
+         *  \b Applies \b to: \li All acquired and virtual components of class Conveyor
+         *  
+         *  \b Available:     \li Airline applications in active state
+         *                    \li SP system manager
+         *  
+         *  \b Access:        \li Exclusive
+         *                    \li Local/Remote
+         *                    \li Synchronous/Asynchronous
+         */
+
+        returncodes::rc reject (in  types::timeout to,
+                                in  types::reference appRef,
+                                out types::Event e);
+
+
+        /**
+         *  Moves baggage from the parking position to the airport's baggage system.
+         *
+         *  @param  to      Timeout value
+         *  @param  appRef  A valid active application reference
+         *  @param  e       Return value
+         *  
+         *  \b Applies \b to: \li All acquired and virtual components of class Conveyor
+         *  
+         *  \b Available:     \li Airline applications in active state
+         *                    \li SP system manager
+         *  
+         *  \b Access:        \li Exclusive
+         *                    \li Local/Remote
+         *                    \li Synchronous/Asynchronous
+         */
+
+        returncodes::rc forwardParked (in  types::timeout to,
+                                       in  types::reference appRef,
+                                       out types::Event e);
+
+
+        /**
+         *  Moves all baggage from the parking position back to the user.
+         *
+         *  @param  to      Timeout value
+         *  @param  appRef  A valid active application reference
+         *  @param  e       Return value
+         *  
+         *  \b Applies \b to: \li All acquired and virtual components of class Conveyor
+         *  
+         *  \b Available:     \li Airline applications in active state
+         *                    \li SP system manager
+         *  
+         *  \b Access:        \li Exclusive
+         *                    \li Local/Remote
+         *                    \li Synchronous/Asynchronous
+         */
+
+        returncodes::rc returnParked (in  types::timeout to,
+                                      in  types::reference appRef,
+                                      out types::Event e);  
+
+        /**
+         *  Allows the user to take back his baggage.
+         *
+         *  @param  to      Timeout value
+         *  @param  appRef  A valid active application reference
+         *  @param  e       Return value
+         *  
+         *  \b Applies \b to: \li All acquired and virtual components of class Conveyor
+         *  
+         *  \b Available:     \li Airline applications in active state
+         *                    \li SP system manager
+         *  
+         *  \b Access:        \li Exclusive
+         *                    \li Local/Remote
+         *                    \li Synchronous/Asynchronous
+         */
+
+        returncodes::rc waitForRemovedBaggage (in  types::timeout to,
+                                               in  types::reference appRef,
+                                               out types::Event e);                                       
+
+    };
+};
+#endif  // COMPS_IDL 
diff --git a/SelfServiceCommon/Massai/idl/Cuss/comps.sed b/SelfServiceCommon/Massai/idl/Cuss/comps.sed
new file mode 100644
index 00000000..22550ed9
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Cuss/comps.sed
@@ -0,0 +1,2 @@
+s/TAO140//g
+s/.tao140//g
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/idl/Cuss/comps.tao140.idl b/SelfServiceCommon/Massai/idl/Cuss/comps.tao140.idl
new file mode 100644
index 00000000..9839d47a
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Cuss/comps.tao140.idl
@@ -0,0 +1,731 @@
+//---------------------------------------------------------------------------
+//
+//  File:      comps.idl
+//
+//  Purpose:   Interfaces to CUSS components
+//
+//  Date:      02.03.2009
+//
+//  Version:   1.3
+//
+//  Author:    CUSS Management Group
+//
+//  Copyright(c) 2003,2009 International Air Transport Association, All Rights Reserved
+//
+//  Note:      This IDL file is backward-compatible with that of CUSS 0.2.1 and CUSS 1.0
+//             Please refer to the CUSS 1.2 Technical Specification for more information
+//
+//  Changed:   Added baggage handling support (Nicolas Bruns, 29.06.2004)
+//
+//  @date 24.01.2013
+//  @li V1.3
+//  @li Mantis 0025566: WeightScale: support standalone Scale (BaggageScale CUSS1.3)
+//  @li added interface BaggageScale
+//----------------------------------------------------------------------------
+
+#ifndef COMPS_IDL
+#define COMPS_IDL
+
+#include "codes.idl"
+#include "types.idl"
+#include "characteristics.idl"
+
+#pragma prefix "cuss.iata.org"
+
+/** 
+ *  Definition of the interfaces to CUSS Components 
+ *
+ * @note  If your version of the IDL compiler treats Component as a CORBA IDL identifier,
+ *        you will need to escape it by prepending an underscore (_) to it , that is
+ *        replace all occurrences of Component with _Component
+ */
+ 
+module Components
+{
+    /**
+     *  All components are derived from this interface
+     *
+     */     
+    interface TAO140Component { };
+
+    /**
+     *  All interfaces for peripherals are derived from this interface
+     */     
+    interface CUSSCntl : TAO140Component
+    {
+
+      /**
+       *  Returns the state/status of the virtual component.
+       *
+       *  @param  to      Timeout value
+       *  @param  appRef  A valid application reference (token) 
+       *  @param  e       Return value
+       *  
+       */     
+      returncodes::rc query (in  types::timeout to,
+                             in  types::reference appRef,
+                             out types::Event e);
+    };
+
+    /**
+     *  Interfaces for virtual components that map to peripheral devices
+     */     
+    interface Peripheral : CUSSCntl
+    {
+
+      /**
+       *  Make the virtual component available for the application.
+       *  The application can subscribe a specific listener associated to the acquired component.
+       *
+       *  @param  to      Timeout value
+       *  @param  appRef  A valid application reference (token) 
+       *  @param  ef      Specifies which events to subscribe to (event filter)
+       *  @param  el      Specifies the event listener to be set for this component
+       *  @param  elud    User data that is submitted with each event sent to the listener
+       *  @param  e       Return value
+       *  
+       *  @note   As implementation of event filtering is not required in CUSS 1.0, 
+       *          event listener passed to acquire will be used as the receiver 
+       *          for all events related to this component. 
+       *
+       */
+      returncodes::rc acquire (in  types::timeout to,          
+                               in  types::reference appRef,    
+                               in  types::evtAcquireFilter ef,  
+                               in  types::evtListener el,      
+                               in  types::correlation elud,                   
+                               out types::Event e);            
+
+      /**
+       *  Makes the virtual component unavailable to the application and unsubscribes events 
+       *  relative to the component.
+       *
+       *  @param  to      Timeout value
+       *  @param  appRef  A valid application reference (token)
+       *  @param  e       Return value
+       *  
+       */
+      returncodes::rc release (in  types::timeout to,
+                               in  types::reference appRef,
+                               out types::Event e);
+
+      /**
+       *  Set up the virtual component and its profile for the application.
+       *
+       *  @param  to      Timeout value
+       *  @param  appRef  A valid application reference (token) 
+       *  @param  ds      datastream for setting the component (e.g. PECTABS)
+       *  @param  e       Return value
+       *  
+       */
+      returncodes::rc setup (in  types::timeout to,
+                             in  types::reference appRef,
+                             in  types::datastream ds,
+                             out types::Event e);
+
+      /**
+       *  Allows to cancel all pending (previously called in asynchronous mode) 
+       *  directives on this specific component.
+       *
+       *  @param  appRef  A valid application reference (token)
+       *  @param  e       Return value
+       *  
+       */     
+      returncodes::rc cancel (in  types::reference appRef,
+                              out types::Event e);
+
+      /**
+       *  Test the virtual and real component as exhaustive as possible.
+       *  If the component is a physical device the device driver should be accessed but
+       *  the physical device should not be exercised.
+       *
+       *  @param  appRef            A valid application reference (token)
+       *  @param  e                 Return value
+       *  
+       */
+      returncodes::rc test (in  types::timeout to,
+                            in  types::reference appRef,
+                            out types::Event e);
+    };
+
+    /**
+     *  Interface for virtual components that provide data to applications
+     */     
+    interface Input
+    {
+
+      /**
+       *  Make the data from the virtual component available to the application.
+       *  
+       *  @param  to      Timeout value
+       *  @param  appRef  A valid application reference (token)
+       *  @param  e       Return value
+       *  
+       */
+      returncodes::rc receive (in  types::timeout to,
+                               in  types::reference appRef,
+                               out types::Event e);
+    };
+
+    /**
+     *  Interface for virtual components that are able to receive data from applications 
+     */    
+    interface Output
+    {
+
+      /**
+       *  Send data from the application to the virtual component.
+       *  
+       *  @param  to      Timeout value
+       *  @param  appRef  A valid application reference (token)
+       *  @param  e       Return value
+       *  
+       */
+      returncodes::rc send (in  types::timeout to,
+                            in  types::reference appRef,
+                            in  types::datastream ds,
+                            out types::Event e);
+    };
+
+    /**
+     *  Interface for virtual components that interact with customers/users
+     */     
+    interface User
+    {
+
+      /**
+       *  Make the virtual component available for the user.
+       *  (e.g. enables a CardReader device for card insertion)
+       *
+       *  @param  to      Timeout value
+       *  @param  appRef  A valid application reference (token)
+       *  @param  e       Return value
+       *  
+       */
+      returncodes::rc enable (in  types::timeout to,
+                              in  types::reference appRef,
+                              out types::Event e);
+
+      /**
+       *  Makes the virtual component unavailable for the user.
+       *  (e.g. disables a CardReader device from card insertion)
+       *
+       *  @param  to      Timeout value
+       *  @param  appRef  A valid application reference (token)
+       *  @param  e       Return value
+       *  
+       */
+      returncodes::rc disable (in  types::timeout to,
+                               in  types::reference appRef,
+                               out types::Event e);
+    };
+
+    /**
+     *  Interface for peripherals that don't interact with users/customers
+     */     
+    interface Userless { };
+
+    /**
+     *  Interface for virtual components that use a physical media
+     *  (e.g. card, coupon, or a paper document)
+     */     
+    interface Media { };
+
+    /**
+     *  Interface for virtual components that don't use a physical media
+     *  (e.g. card, coupon, or a paper document)
+     */     
+    interface Medialess { };
+
+    /**
+     *  Interface for virtual components that transfer data
+     */     
+    interface Data { };
+
+    /**
+     *  Interface for virtual components that don't transfer data
+     */     
+    interface Dataless { };
+
+    /**
+     *  Interface for virtual components that are able to retain media
+     */
+    interface Capture : Peripheral, Userless, Media, Dataless, Characteristics::Capture
+    {
+
+      /**
+       *  Captures the document in the virtual component that is associated to a secured bin.
+       *  
+       *  @param  to      Timeout value
+       *  @param  appRef  A valid application reference (token)
+       *  @param  e       Return value
+       *  
+       */
+      returncodes::rc retain (in  types::timeout to,
+                              in  types::reference appRef,
+                              out types::Event e);
+    };
+
+    /**
+     *  Interface for virtual components that receive media from a Peripheral component 
+     *  and offer it to the user or to another Peripheral component 
+     *  (e.g. ejecting an ATB coupon from the printer to the ESCROW)
+     */
+    interface Dispenser : Peripheral, User, Media, Dataless, Characteristics::Dispenser
+    {
+
+      /**
+       *  Offer the document from the virtual component to the user or to another component.
+       *
+       *  @param  to      Timeout value
+       *  @param  appRef  A valid application reference (token)
+       *  @param  e       Return value
+       *  
+       */
+      returncodes::rc offer (in  types::timeout to,
+                             in  types::reference appRef,
+                             out types::Event e);
+    };
+
+    /**
+     *  Interface for virtual components that are holding media (e.g. ATB stocks)
+     *  and supply it to another Peripheral component
+     */
+    interface Feeder : Peripheral, Userless, Media, Dataless, Characteristics::Feeder 
+    { 
+
+      /**
+       *  Offer the document from a feeder to another virtual component.
+       *
+       *  @param  to      Timeout value
+       *  @param  appRef  A valid application reference (token)
+       *  @param  e       Return value
+       *  
+       */
+      returncodes::rc offer (in  types::timeout to,
+                             in  types::reference appRef,
+                             out types::Event e);
+    };
+
+    /**
+     *  Interface for virtual components used for inbound data transfer (e.g. digital input)
+     */
+    interface DataInput : Peripheral, Userless, Medialess, Data, Input, Characteristics::DataInput { };
+
+    /**
+     *  Interface for virtual components used for outbound data transfer (e.g. network output)
+     */
+    interface DataOutput : Peripheral, Userless, Medialess, Data, Output, Characteristics::DataOutput { };
+    
+    /**
+     *  Interface for virtual components used for inbound user data transfer (e.g. sound device)
+     *
+     *  @note    For the touch screen overlay, which is a native device implemented as UserInput,
+     *           Only acquire, release and query directives should be implemented.
+     *           All other inherited methods are not applicable and should return RC_NOT_SUPPORTED
+     *
+     */    
+    interface UserInput : Peripheral, User, Medialess, Data, Input, Characteristics::UserInput { };
+
+    /**
+     *  Interface for virtual components used for outbound user data transfer (e.g. screen)
+     */
+    interface UserOutput : Peripheral, User, Medialess, Data, Output, Characteristics::UserOutput { };
+    
+    /**
+     *  Interface for virtual components used for reading from media (e.g. mag card reader)
+     */
+    interface MediaInput : Peripheral, User, Media, Data, Input, Characteristics::MediaInput { };
+
+    /**
+     *  Interface for virtual components used for writing to media (e.g. receipt printer)
+     */
+    interface MediaOutput : Peripheral, User, Media, Data, Output, Characteristics::MediaOutput { };
+    
+    /**
+     *  Interface for virtual components used for reading/writing from/to storage (e.g. hard disk)
+     *
+     *  @note    As Storage is a native device, 
+     *           only acquire, release and query directives should be implemented.
+     *           All other inherited methods are not applicable and should return RC_NOT_SUPPORTED
+     *
+     */
+    interface Storage : Peripheral, Userless, Media, Characteristics::Storage { };
+
+    /**
+     *  Interface for virtual components handling a display (eg. kiosk computer screen)
+     *
+     *  @note    As Display is a native device, 
+     *           only acquire, release and query directives should be implemented.
+     *           All other inherited methods are not applicable and should return RC_NOT_SUPPORTED
+     *
+     */
+    interface Display : Peripheral, User, Medialess, Characteristics::Display { };
+
+    /**
+     *  Interface for virtual components handling network access
+     *
+     *  @note    As Network is a native device, 
+     *           only acquire, release and query directives should be implemented.
+     *           All other inherited methods are not applicable and should return RC_NOT_SUPPORTED
+     *
+     */
+    interface Network : Peripheral, Userless, Medialess, Characteristics::Network { };
+
+    /**
+     *  Base definition for virtual components allowing baggage check-in
+     */
+
+    interface BaggageScale : UserInput, Characteristics::Scale { };
+
+
+    /**
+      * This interface is used to query the state and/or characteristics
+      * of a kiosk application that is configured on the platform. 
+      * 
+      */       
+    interface Application : CUSSCntl, Characteristics::Application { };
+
+    /**
+     *  This interface is inherited by the ApplicationManager and the SystemProviderInterface
+     */
+    interface ManagementInterface : TAO140Component
+    {
+
+      /**
+       *  This is the first directive to be issued by the application 
+       *  to get basic information on the specific CUSS Platform implementation
+       *  If the application is known by the platform (via configuration), 
+       *  the application reference (token) is returned with this call.
+       *  
+       *  @param  appid     Application identifier which must be configured within the platform 
+       *                    (for minimal security)
+       *  @param  el        Return values 
+       *  
+       */
+      returncodes::rc level (in  types::akID appid,
+                             out types::EnvironmentLevel el);
+
+      /**
+       *  This is the second directive to be issued by an application 
+       *  to get the list of all implemented CUSS components.
+       *  
+       *  @param  appRef  A valid application reference (token)
+       *  @param  ec      List of virtual components which contains the CORBA references (IORs)
+       *  
+       */
+      returncodes::rc components (in  types::reference appRef,
+                                  out types::EnvironmentComponents ec);
+
+      /**
+       *  Allows applications to wait for an event to occur.
+       *  To wait for an event, the application must have subscribed to it via the acquire or 
+       *  registerEvent directives. The waitEvent-directive will be completed at event occurrence
+       *  (any or all in the list) or when the timeout expires.
+       *
+       *  @param  to      Timeout value (positive and negative values have the same effect for this directive)
+       *
+       *  @param  appRef  A valid application reference (token)
+       *  @param  ef      Specifies the event(s) to wait for
+       *  @param  e       Return value
+       *  
+       *  @note   In CUSS 1.0, implementing event filtering is not mandatory.
+       */
+      returncodes::rc waitEvent (in  types::timeout to,
+                                 in  types::reference appRef,
+                                 in  types::evtFilter ef,
+                                 out types::Event e);
+
+      /**
+       *  Generate an event to a system manager.
+       *
+       *  @param  appRef  A valid application reference (token)
+       *  @param  ie      Event to be generated
+       *  @param  oe      Return value
+       *  
+       */
+      returncodes::rc generateEvent(in  types::reference appRef,
+                                    in  types::Event ie,
+                                    out types::Event oe);        
+
+      /**
+       *  Returns a description of an event.
+       *
+       *  @param  appRef  A valid application reference (token)
+       *  @param  ef      Specifies the event(s) to query
+       *  @param  ed      Returned event description(s)
+       *  
+       *  @note   In CUSS 1.0, the implementation of queryEvent is not mandatory.
+       *          In this case, this function should return RC_NOT_SUPPORTED.   
+       */
+      returncodes::rc queryEvent (in  types::reference appRef,   
+                                  in  types::evtFilter ef,
+                                  out types::evtDescription ed); 
+
+      /**
+       *  Subscribe to or discards from receiving any related event notification. The use
+       *  of this directive has an additive effect, which means that a call will not supersede
+       *  a previous call but, instead, subscribe for previous event(s) plus the one(s) in the 
+       *  current call. All subscriptions done with this directive will be received, within the 
+       *  application, via a single listener.
+       *
+       *  @param  appRef  A valid application reference (token)
+       *  @param  act     Either subscribe or discard event(s)
+       *  @param  ef      Specifies the event(s) to register i.e. event filter
+       *  @param  el      Specifies the event listener to be notified
+       *  @param  elud    User data that is submitted to the listener on each invocation
+       *  @param  ed      Return value
+       *  
+       *  @note   As implementation of event filtering is not required in CUSS 1.0, 
+       *          event listener passed to registerEvent directive will be used as the 
+       *          receiver for all application manager events. To receive component events,
+       *          application must register their listener(s) via the acquire directive.
+       */
+      returncodes::rc registerEvent(in  types::reference appRef,
+                                    in  types::action act,
+                                    in  types::evtFilter ef,
+                                    in  types::evtListener el,
+                                    in  types::correlation elud,                   
+                                    out types::Event e);
+
+    };
+
+    /**
+     *  The definition for the Application Manager Interface.
+     *  An application uses this interface for interaction with the platform.
+     *  To access the platform use: <i>corbaloc:<kiosk-IP address>:20000/ApplicationManager</i>
+     */
+    interface ApplicationManager : ManagementInterface
+    {
+      /**
+       *  The application now wants to (re-)initialize. This is a blocking call.
+       *  After this directive returns the application is allowed to initialize.
+       *  This handling ensures that initialization is serialized for all applications. 
+       */
+      returncodes::rc initrequest (in  types::reference appRef,
+                                   out types::Event e);        
+                                                               
+      /**
+       *  This directive is used by the application to request a state change from 
+       *  CUSS Application Manager, which will change the application state if request is approved.
+       *
+       *  @param  appRef  A valid application reference (token)
+       *  @param  ie      Input of application state transition code 
+       *  @param  oe      Return value
+       *  
+       */
+      returncodes::rc notify (in  types::reference appRef,
+                              in  types::akID   id,
+                              in  types::evtCode ec,
+                              out types::Event   e);         
+    };
+
+    /**
+     *  The definition for the System Manager Interface.
+     *  A System Manager Application uses this interface for interaction with the platform
+     *  To access the platform use: <i>corbaloc:<kiosk-IP address>:20001/ServiceProviderInterface</i>
+     *
+     *  @note   In CUSS 1.0, the ServiceProviderInterface is available for both 
+     *          Service Provider System Manager and Application Provider System Manager
+     */
+    interface ServiceProviderInterface : ManagementInterface 
+    {
+
+      /**
+       *  Ask CUSS application manager to load an application 
+       *  (realize Load state transition in application state diagram). 
+       *
+       *  @param  to       Timeout value
+       *  @param  appRef   A valid application reference (token)
+       *  @param  whichApp The identifier of the application to be loaded
+       *  @param  e        Return value
+       *  
+       */
+      returncodes::rc load (in  types::timeout to,
+                            in  types::reference appRef,
+                            in  types::akID whichApp,
+                            out types::Event e);
+
+      /**
+       *  Suspend an application. 
+       *
+       *  @param  appRef   A valid application reference (token)
+       *  @param  whichApp The identification of the application to be suspended
+       *  @param  e        Return value
+       *  
+       */
+      returncodes::rc suspend (in  types::reference appRef,
+                               in  types::akID whichApp,
+                               out types::Event e);
+
+      /**
+       *  Suspend all applications. 
+       *
+       *  @param  appRef   A valid application reference (token)
+       *  @param  e        Return value
+       *  
+       */
+      returncodes::rc suspendAll (in types::reference appRef,
+                                 out types::Event e);         
+
+      /**
+       *  Resume a suspended application to its previous state. 
+       *
+       *  @param  appRef   A valid application reference (token)
+       *  @param  whichApp The identifier of the application to be resumed
+       *  @param  e        Return value
+       *  
+       */
+      returncodes::rc resume (in  types::reference appRef,
+                              in  types::akID whichApp,
+                              out types::Event e);           
+
+      /**
+       *  Resume all suspended applications to their previous state. 
+       *
+       *  @param  appRef   A valid application reference (token)
+       *  @param  e        Return value
+       *  
+       */
+      returncodes::rc resumeAll (in  types::reference appRef,
+                                 out types::Event e);
+      
+      /**
+       *  Stops (unloads) an application. 
+       *
+       *  @param  appRef   A valid application reference (token)
+       *  @param  whichApp The identifier of the application to be stopped
+       *  @param  e        Return value
+       *  
+       */
+      returncodes::rc stop (in  types::reference appRef,
+                            in  types::akID whichApp,
+                            out types::Event e);
+                            
+      /**
+       *  Stops (unloads) all applications. 
+       *
+       *  @param  appRef   A valid application reference (token)
+       *  @param  e        Return value
+       *  
+       */
+      returncodes::rc stopAll (in  types::reference appRef,
+                               out types::Event e);
+    };
+
+    /**
+     *  Interface for virtual components which are able to transport baggage 
+     */
+
+    interface Conveyor : Peripheral, User, Medialess, Data, Input, Characteristics::Conveyor
+    {
+        /**
+         *  Moves current piece of baggage to the parking position.
+         *
+         *  @param  to      Timeout value
+         *  @param  appRef  A valid active application reference
+         *  @param  e       Return value
+         *  
+         *  \b Applies \b to: \li All acquired and virtual components of class Conveyor
+         *  
+         *  \b Available:     \li Airline applications in active state
+         *                    \li SP system manager
+         *  
+         *  \b Access:        \li Exclusive
+         *                    \li Local/Remote
+         *                    \li Synchronous/Asynchronous
+         */
+
+        returncodes::rc accept (in  types::timeout to,
+                                in  types::reference appRef,
+                                out types::Event e);
+
+        /**
+         *  Moves current piece of baggage back to the user.
+         *
+         *  @param  to      Timeout value
+         *  @param  appRef  A valid active application reference
+         *  @param  e       Return value
+         *  
+         *  \b Applies \b to: \li All acquired and virtual components of class Conveyor
+         *  
+         *  \b Available:     \li Airline applications in active state
+         *                    \li SP system manager
+         *  
+         *  \b Access:        \li Exclusive
+         *                    \li Local/Remote
+         *                    \li Synchronous/Asynchronous
+         */
+
+        returncodes::rc reject (in  types::timeout to,
+                                in  types::reference appRef,
+                                out types::Event e);
+
+
+        /**
+         *  Moves baggage from the parking position to the airport's baggage system.
+         *
+         *  @param  to      Timeout value
+         *  @param  appRef  A valid active application reference
+         *  @param  e       Return value
+         *  
+         *  \b Applies \b to: \li All acquired and virtual components of class Conveyor
+         *  
+         *  \b Available:     \li Airline applications in active state
+         *                    \li SP system manager
+         *  
+         *  \b Access:        \li Exclusive
+         *                    \li Local/Remote
+         *                    \li Synchronous/Asynchronous
+         */
+
+        returncodes::rc forwardParked (in  types::timeout to,
+                                       in  types::reference appRef,
+                                       out types::Event e);
+
+
+        /**
+         *  Moves all baggage from the parking position back to the user.
+         *
+         *  @param  to      Timeout value
+         *  @param  appRef  A valid active application reference
+         *  @param  e       Return value
+         *  
+         *  \b Applies \b to: \li All acquired and virtual components of class Conveyor
+         *  
+         *  \b Available:     \li Airline applications in active state
+         *                    \li SP system manager
+         *  
+         *  \b Access:        \li Exclusive
+         *                    \li Local/Remote
+         *                    \li Synchronous/Asynchronous
+         */
+
+        returncodes::rc returnParked (in  types::timeout to,
+                                      in  types::reference appRef,
+                                      out types::Event e);  
+
+        /**
+         *  Allows the user to take back his baggage.
+         *
+         *  @param  to      Timeout value
+         *  @param  appRef  A valid active application reference
+         *  @param  e       Return value
+         *  
+         *  \b Applies \b to: \li All acquired and virtual components of class Conveyor
+         *  
+         *  \b Available:     \li Airline applications in active state
+         *                    \li SP system manager
+         *  
+         *  \b Access:        \li Exclusive
+         *                    \li Local/Remote
+         *                    \li Synchronous/Asynchronous
+         */
+
+        returncodes::rc waitForRemovedBaggage (in  types::timeout to,
+                                               in  types::reference appRef,
+                                               out types::Event e);                                       
+
+    };
+};
+#endif  // COMPS_IDL 
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/idl/Cuss/doxyfile b/SelfServiceCommon/Massai/idl/Cuss/doxyfile
new file mode 100644
index 00000000..1473281d
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Cuss/doxyfile
@@ -0,0 +1,226 @@
+# Doxyfile 1.3.8
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+PROJECT_NAME           = "CUSS V1.0 IDL (Materna Enhancements)"
+PROJECT_NUMBER         = 
+OUTPUT_DIRECTORY       = F:/massai.all/docs.MASSAI/Massai.FRAME/idl.cuss.v1.0
+CREATE_SUBDIRS         = NO
+OUTPUT_LANGUAGE        = English
+USE_WINDOWS_ENCODING   = YES
+BRIEF_MEMBER_DESC      = YES
+REPEAT_BRIEF           = YES
+ABBREVIATE_BRIEF       = "The $name class" \
+                         "The $name widget" \
+                         "The $name file" \
+                         is \
+                         provides \
+                         specifies \
+                         contains \
+                         represents \
+                         a \
+                         an \
+                         the
+ALWAYS_DETAILED_SEC    = NO
+INLINE_INHERITED_MEMB  = NO
+FULL_PATH_NAMES        = NO
+STRIP_FROM_PATH        = 
+STRIP_FROM_INC_PATH    = 
+SHORT_NAMES            = NO
+JAVADOC_AUTOBRIEF      = YES
+MULTILINE_CPP_IS_BRIEF = NO
+DETAILS_AT_TOP         = NO
+INHERIT_DOCS           = YES
+DISTRIBUTE_GROUP_DOC   = NO
+TAB_SIZE               = 8
+ALIASES                = 
+OPTIMIZE_OUTPUT_FOR_C  = NO
+OPTIMIZE_OUTPUT_JAVA   = NO
+SUBGROUPING            = YES
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+EXTRACT_ALL            = NO
+EXTRACT_PRIVATE        = NO
+EXTRACT_STATIC         = NO
+EXTRACT_LOCAL_CLASSES  = YES
+EXTRACT_LOCAL_METHODS  = NO
+HIDE_UNDOC_MEMBERS     = YES
+HIDE_UNDOC_CLASSES     = YES
+HIDE_FRIEND_COMPOUNDS  = NO
+HIDE_IN_BODY_DOCS      = NO
+INTERNAL_DOCS          = NO
+CASE_SENSE_NAMES       = YES
+HIDE_SCOPE_NAMES       = NO
+SHOW_INCLUDE_FILES     = YES
+INLINE_INFO            = YES
+SORT_MEMBER_DOCS       = YES
+SORT_BRIEF_DOCS        = NO
+SORT_BY_SCOPE_NAME     = NO
+GENERATE_TODOLIST      = YES
+GENERATE_TESTLIST      = YES
+GENERATE_BUGLIST       = YES
+GENERATE_DEPRECATEDLIST= YES
+ENABLED_SECTIONS       = 
+MAX_INITIALIZER_LINES  = 30
+SHOW_USED_FILES        = YES
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+QUIET                  = NO
+WARNINGS               = YES
+WARN_IF_UNDOCUMENTED   = YES
+WARN_IF_DOC_ERROR      = YES
+WARN_FORMAT            = "$file($line) : $text"
+WARN_LOGFILE           = 
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+INPUT                  = F:/massai.all/MassaiDev/All/idl/cuss/types.idl \
+                         F:/massai.all/MassaiDev/All/idl/cuss/characteristics.idl \
+                         F:/massai.all/MassaiDev/All/idl/cuss/codes.idl \
+                         F:/massai.all/MassaiDev/All/idl/cuss/comps.idl
+FILE_PATTERNS          = 
+RECURSIVE              = NO
+EXCLUDE                = 
+EXCLUDE_SYMLINKS       = NO
+EXCLUDE_PATTERNS       = 
+EXAMPLE_PATH           = examples
+EXAMPLE_PATTERNS       = 
+EXAMPLE_RECURSIVE      = NO
+IMAGE_PATH             = 
+INPUT_FILTER           = 
+FILTER_PATTERNS        = 
+FILTER_SOURCE_FILES    = NO
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+SOURCE_BROWSER         = NO
+INLINE_SOURCES         = NO
+STRIP_CODE_COMMENTS    = YES
+REFERENCED_BY_RELATION = NO
+REFERENCES_RELATION    = NO
+VERBATIM_HEADERS       = NO
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+ALPHABETICAL_INDEX     = YES
+COLS_IN_ALPHA_INDEX    = 3
+IGNORE_PREFIX          = 
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+GENERATE_HTML          = YES
+HTML_OUTPUT            = html
+HTML_FILE_EXTENSION    = .html
+HTML_HEADER            = doxyheader.html
+HTML_FOOTER            = doxyfooter.html
+HTML_STYLESHEET        = massai.css
+HTML_ALIGN_MEMBERS     = YES
+GENERATE_HTMLHELP      = YES
+CHM_FILE               = 
+HHC_LOCATION           = 
+GENERATE_CHI           = YES
+BINARY_TOC             = YES
+TOC_EXPAND             = YES
+DISABLE_INDEX          = NO
+ENUM_VALUES_PER_LINE   = 4
+GENERATE_TREEVIEW      = NO
+TREEVIEW_WIDTH         = 250
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+GENERATE_LATEX         = NO
+LATEX_OUTPUT           = latex
+LATEX_CMD_NAME         = latex
+MAKEINDEX_CMD_NAME     = makeindex
+COMPACT_LATEX          = NO
+PAPER_TYPE             = a4
+EXTRA_PACKAGES         = 
+LATEX_HEADER           = 
+PDF_HYPERLINKS         = YES
+USE_PDFLATEX           = YES
+LATEX_BATCHMODE        = NO
+LATEX_HIDE_INDICES     = NO
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+GENERATE_RTF           = NO
+RTF_OUTPUT             = rtf
+COMPACT_RTF            = NO
+RTF_HYPERLINKS         = YES
+RTF_STYLESHEET_FILE    = 
+RTF_EXTENSIONS_FILE    = 
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+GENERATE_MAN           = NO
+MAN_OUTPUT             = man
+MAN_EXTENSION          = .3
+MAN_LINKS              = NO
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+GENERATE_XML           = NO
+XML_OUTPUT             = xml
+XML_SCHEMA             = 
+XML_DTD                = 
+XML_PROGRAMLISTING     = YES
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+GENERATE_AUTOGEN_DEF   = NO
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+GENERATE_PERLMOD       = NO
+PERLMOD_LATEX          = NO
+PERLMOD_PRETTY         = YES
+PERLMOD_MAKEVAR_PREFIX = 
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor   
+#---------------------------------------------------------------------------
+ENABLE_PREPROCESSING   = YES
+MACRO_EXPANSION        = NO
+EXPAND_ONLY_PREDEF     = NO
+SEARCH_INCLUDES        = YES
+INCLUDE_PATH           = 
+INCLUDE_FILE_PATTERNS  = 
+PREDEFINED             = 
+EXPAND_AS_DEFINED      = 
+SKIP_FUNCTION_MACROS   = YES
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references   
+#---------------------------------------------------------------------------
+TAGFILES               = 
+GENERATE_TAGFILE       = 
+ALLEXTERNALS           = NO
+EXTERNAL_GROUPS        = YES
+PERL_PATH              = /usr/bin/perl
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool   
+#---------------------------------------------------------------------------
+CLASS_DIAGRAMS         = YES
+HIDE_UNDOC_RELATIONS   = YES
+HAVE_DOT               = NO
+CLASS_GRAPH            = YES
+COLLABORATION_GRAPH    = YES
+UML_LOOK               = NO
+TEMPLATE_RELATIONS     = YES
+INCLUDE_GRAPH          = YES
+INCLUDED_BY_GRAPH      = YES
+CALL_GRAPH             = NO
+GRAPHICAL_HIERARCHY    = YES
+DOT_IMAGE_FORMAT       = png
+DOT_PATH               = 
+DOTFILE_DIRS           = 
+MAX_DOT_GRAPH_WIDTH    = 1024
+MAX_DOT_GRAPH_HEIGHT   = 1024
+MAX_DOT_GRAPH_DEPTH    = 1000
+GENERATE_LEGEND        = YES
+DOT_CLEANUP            = YES
+#---------------------------------------------------------------------------
+# Configuration::additions related to the search engine   
+#---------------------------------------------------------------------------
+SEARCHENGINE           = NO
diff --git a/SelfServiceCommon/Massai/idl/Cuss/doxyfooter.html b/SelfServiceCommon/Massai/idl/Cuss/doxyfooter.html
new file mode 100644
index 00000000..b7e720c5
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Cuss/doxyfooter.html
@@ -0,0 +1,15 @@
+<body text="#000000" bgcolor="#ffffff" link="#000080" vlink="#000077" alink="#800000">
+
+<hr>
+
+<table border="0" width="100%">
+<tr>
+<td width=40>
+   <img src="../materna.gif" alt="Materna Information & Communications" border=0>
+</td>
+<td align=right valign = top> Comments to: &nbsp
+<a href="mailto:andreas.gehling@materna.de">Andreas Gehling</A>
+</td>
+</tr>
+</table>
+</body>
diff --git a/SelfServiceCommon/Massai/idl/Cuss/doxyheader.html b/SelfServiceCommon/Massai/idl/Cuss/doxyheader.html
new file mode 100644
index 00000000..47bd94cb
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Cuss/doxyheader.html
@@ -0,0 +1,33 @@
+<head>
+   <title>Massai Documentation</title>
+</head>
+
+<body text="#000080" background="#eeeeff" link="#000080" vlink="#000077" alink="#800000">
+
+<link href="massai.css" rel="stylesheet" type="text/css">
+
+<table border="0" width="100%">
+<tr>
+  <td align=right bgcolor="#17479e" width=100% height=80> <a href="http://www.cuss-solutions.com"> <p valign= middle> <font size="+2" color="#ffffff">
+  <b>Massai</a>.FRAME Documentation&nbsp</b></p>
+  </font>
+  </td>
+</tr>
+
+<tr>
+  <table border="0" width="100%">
+
+    <td bgcolor="#f58220" width=50%  height=20> </td>
+    <td bgcolor="#eaeaea" width=1% > </td>
+    <td bgcolor="#f9b883" width=15%> </td>
+    <td bgcolor="#eaeaea" width=1%> </td>
+    <td bgcolor="#fce0c8" width=15%> </td>
+    <td bgcolor="#eaeaea" width=1%> </td>
+    <td bgcolor="#ffffff" width=16%> </td>
+
+  </table>
+
+</tr>
+</table>
+<hr>
+</body>
diff --git a/SelfServiceCommon/Massai/idl/Cuss/mainpage.dox b/SelfServiceCommon/Massai/idl/Cuss/mainpage.dox
new file mode 100644
index 00000000..73772910
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Cuss/mainpage.dox
@@ -0,0 +1,161 @@
+//---------------------------------------------------------------------------
+//
+//  file:      mainpage.dox
+//
+//  purpose:   Documentation include for DOXYGEN
+//
+//  date:      30.08.2002
+//
+//  version:   0.2.1.BaggageHandlingSupport
+//
+//  authors:   Andreas Gehling (AGe), Materna Information & Communications
+//
+//----------------------------------------------------------------------------
+
+/*! \mainpage
+ *  
+ *  This chapter describes the interfaces between the CUSS platform and
+ *  the CUSS applications running on a CUSS kiosk.
+ *
+ *  \section _Version02 Note on Version 0.2
+ *
+ *  This version of the CUSS interfaces is freezed and is considered to be
+ *  released as the \e Version \e 1.0 after a combined technical document for the 
+ *  CUSS standard is released by IATA.
+ *
+ *  \section _Version021 Note on Version 0.2.1
+ *
+ *  A few necessary changes were done in the \e characteristics \e IDL to be more consistent
+ *  with the defintion of all other interfaces and to keep the implementation of the platform easier.
+ *  There were some attributes that had \b read/write access. These attributes were changed to 
+ *  \b readonly access. The write access for these attributes is now provided with the appropriate
+ *  function calls that can be found in the definitions for these characteristics.
+ *
+ *  For the attributes \b Characteristics::MediaInput::DataType \b setupDataType and 
+ *  \b Characteristics::Bin::long \b currentNoOfDocuments no access functions were added because changing 
+ *  this attributes by an application does not make sense at all. MediaInput components define the data 
+ *  type they provide by themselves, eg an ATB printer does not provide its datastream as SVG.
+ *
+ *  These changes were done with the agreement of the technical group.
+ *
+ *  \section _Version021BH Note on Version 0.2.1.BaggageHandlingSupport
+ *
+ *  To support fully automated baggage handling changes were made to the CUSS interfaces as described in
+ *  the change history. Therefore two new virtual components have been defined.
+ *  \li \b BaggageSystem decribes the the baggage system at the airport and can be queried for availability.
+ *  \li \b Conveyor describes a conveyor belt at a CKI-Counter which can be controlled by an application.
+ *  For both components the appropriate characteristics and statuscodes have been defined.
+ *
+ *  @note
+ *  The changes to the IDL are completely compatible to the previous version of the IDL.
+ *
+ *  @attention
+ *  These changes have not yet been discussed with the technical group.
+ *
+ *  \section _SeeAlso Document Reference List
+ *
+ *  \li Chapter 1 Platform Definition of the CUSS specification   (T0110C36.DOC)
+ *  \li Chapter 2 Concept Presentation of the CUSS specification  (T0220C04.DOC)
+ *  \li Chapter 3 Component List of the CUSS specification        (T0230C03.DOC)
+ *  \li Appendix A Questions & Answers                            (T02A0C06.DOC)
+ *  \li Appendix C Component Diagrams, Events, and States         (T02C0C04.DOC)
+ *  \li Minutes of Meeting in Montreal/Canada                     (001114MT.DOC)
+ *  \li Minutes of Meeting in Montreal/Canada                     (010213MT.DOC)
+ *  \li Minutes of Meeting in Geneva/Switzerland                  (010522MT.DOC)
+ *  \li Minutes of Meeting in Montreal/Canada                     (010828MT.DOC)
+ *  \li Minutes of Meeting in Vienna/Austria                      (011015MT.DOC)
+ *
+ *  \latexonly
+ *  \newpage
+ *  \endlatexonly
+ *
+ *  \section _ChangeHistory Change history
+ *  \date 20.09.2000 \li No changes - first complete documentation
+ *
+ *  \date 13.11.0000 \li Included application state change codes.
+ *                   \li Changed the \e #include <...> statements to \e #include "...".
+ *
+ *  \date 24.11.0000 \li Added missing \e in parameter to \e notify() call.
+ *                   \li Added missing state codes for components for use with the \e query() call.
+ *
+ *  \date 20.11.2000 \li Added corrections from the CUSS/MG5 meeting in Montreal
+ *                   \li Added \e APPLICATION_LIST constant as requested by CUSS/MG5
+ *                   \li Added \e APPLICATION_SELECTED constant as requested by CUSS/MG5
+ *                   \li Added \e launchDataType definition as requested by CUSS/MG5
+ *                   \li Changed \e EnvironmentComponent structure
+ *                   \li Moved \e suspend()/resume() to the \e ServiceProviderInterface
+ *
+ *  \date 06.03.2001 \li Added corrections from the CUSS/MG6 meeting in Montreal
+ *                   \li Added \e location structure which defines the kiosk location in textual form
+ *                   \li Added the \e location structure to the \e environmentLevel structure and to the \e event structure
+ *                   \li Added/Changed application state change- and status codes for virtual device components
+ *                   \li Changed the \e appID defintion to \e akID which now defines the kiosk ID, too.
+ *                   \li Removed \e APPLICATION_LIST constant as requested by CUSS/MG6
+ *                   \li Removed \e APPLICATION_SELECTED constant as requested by CUSS/MG6
+ *                   \li Removed \e launchDataType definition as requested by CUSS/MG6
+ *                   \li Removed the application reference from the event listener because that parameter was completely useless here
+ *                   \li Removed \e mediaType field from the \e msgDataType defintion
+ *
+ *  \date 29.08.2001 \li Added reviewed characteristics from the technical meeting in Montreal
+ *                   \li Moved \e StorageInput and \e StorageOutput components to one component named \e Storage
+ *                   \li Added new component \e Display
+ *                   \li Added new component \e Network
+ *                   \li Added new component \e Application
+ *                   \li Added new status code \e DATA_PRESENT
+ *
+ *  \date 04.11.0001 \li Added \e vetcorFont characteristic to support vector fonts
+ *
+ *  \date 16.10.2001 \li Added \e offer() for the Feeder component
+ *                   \li Added state description constants in const.idl
+ *                   \li Added \e realComponentIdentification added to the Manufacturer interface
+ *                   \li All components derive from the appropriate characteristics
+ *                   \li Removed characteristic definitions from types.idl
+ *
+ *  \date 22.10.2001 \li Added event code \e BUSY to indicate transitional state while component is working
+ *
+ *  \date 10.12.2001 \li Characteristics::Bin::long currentNoOfDocuments changed to \b readonly
+ *                   \li Characteristics::IOMode::InputOutputMode mode changed to \b readonly
+ *                   \li Characteristics::MediaInput::DataType setupDataType changed to \b readonly
+ *                   \li Characteristics::MediaOutput::PrintOrientationDef printOrientation changed to \b readonly
+ *
+ *  \date 13.12.2001 \li Removed \b Characteristics::Bin::setNoOfDocuments() method 
+ *                   \li Fixed misspelling of \b Characteristics::display::setScreenResolution() method
+ *
+ *  \date 30.08.2002 \li Added new virtual component \b Components::Conveyor
+ *                   \li Added new virtual component \b Characteristics::Conveyor
+ *                   \li Added new virtual component \b Components::BaggageSystem
+ *                   \li Added new virtual component \b Characteristics::BaggageSystem
+ *                   \li Added new statuscode \b BAGGAGE_JAMMED   
+ *                   \li Added new statuscode \b BAGGAGE_MISPLACED
+ *                   \li Added new statuscode \b BAGGAGE_PRESENT  
+ *                   \li Added new statuscode \b BAGGAGE_ABSENT   
+ *                   \li Added new statuscode \b BAGGAGE_OVERSIZED
+ *                   \li Added new barcode characteristic \b ComponentFonts::BarcodeStandard::Code2of5_Interleaved
+ *                   \li Added new barcode characteristic \b ComponentFonts::BarcodeStandard::EAN
+ *                   \li Added new barcode characteristic \b ComponentFonts::BarcodeStandard::UPC
+ *                   \li Added new barcode characteristic \b ComponentFonts::BarcodeStandard::Code2of5_Industrial
+ *                   \li Added new barcode characteristic \b ComponentFonts::BarcodeStandard::Code2of5_IndustrialB
+ *                   \li Added new barcode characteristic \b ComponentFonts::BarcodeStandard::Codabar 
+ *                   \li Added new barcode characteristic \b ComponentFonts::BarcodeStandard::Code93             
+ *                   \li Added new barcode characteristic \b ComponentFonts::BarcodeStandard::EAN128             
+ *                   \li Added new barcode characteristic \b ComponentFonts::BarcodeStandard::Pharmacode          
+ *
+ *  \section _Note Implementation Note
+ *
+ *  During transmission, characters may be converted to other appropriate forms as
+ *  required by a particular language binding. Such conversions may change the
+ *  representation of a character but maintain the characters meaning. For example, a
+ *  character may be converted to and from the appropriate representation in international
+ *  character sets.
+ *  We agreed to use the ISO 8859-1 (Latin1) character set for the CUSS standard,
+ *  so we cannot use \e char, because of a possible conversion of the characters. Instead
+ *  we use \e octet. Implemetations which supports wide character sets are restricted to
+ *  UNICODE (ISO/IEC 10646-1 second edition) UTF-8 encoding and therefor also have to use \e octet,
+ *  because as with character data, an CORBA implementation is free to use any code set
+ *  internally for encoding wide characters, though, again, conversion to another form may
+ *  be required for transmission.
+ *
+ *  \latexonly
+ *  \newpage
+ *  \endlatexonly
+ */
diff --git a/SelfServiceCommon/Massai/idl/Cuss/makefile.mak b/SelfServiceCommon/Massai/idl/Cuss/makefile.mak
new file mode 100644
index 00000000..ba2fc14d
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Cuss/makefile.mak
@@ -0,0 +1,31 @@
+######################################################################
+#
+# /vob/SelfServicePlatform/Massai/idl/CUSS/makefile.mak
+#
+######################################################################
+
+!include $(BUILDROOT)\Build\cpp\makefile.common.mak
+
+MY_IDLFLAGS = $(TAO_DEFINES) -DUSE_TAO_ORB_IDL 
+
+MY_GEN_CPPS = \
+    $(_GEN)\characteristics.cpp \
+    $(_GEN)\codes.cpp \
+    $(_GEN)\comps.tao140.cpp \
+    $(_GEN)\types.cpp
+
+special-all: all $(_GEN)\comps.cpp
+
+!include $(BUILDROOT)\Build\cpp\makefile.rules.mak
+
+$(_GEN)\comps.cpp: $(_GEN)\comps.tao140.cpp
+    @echo SPECIAL CONVERSION FOR TAO 1.4.0...
+    $(SED) -f comps.sed $(_GEN)\comps.tao140.cpp        > $(_GEN)\comps.cpp
+    $(SED) -f comps.sed $(_GEN)\comps.tao140.h          > $(_GEN)\comps.h
+    $(SED) -f comps.sed $(_GEN)\comps.tao140c.i         > $(_GEN)\compsc.i
+    - $(SED) -f comps.sed $(_GEN)\comps.tao140s.i         > $(_GEN)\compss.i
+    - $(SED) -f comps.sed $(_GEN)\comps.tao140s_t.i       > $(_GEN)\compss_t.i
+    $(SED) -f comps.sed $(_GEN)\comps.tao140_skel.cpp   > $(_GEN)\comps_skel.cpp
+    $(SED) -f comps.sed $(_GEN)\comps.tao140_skel.h     > $(_GEN)\comps_skel.h
+    - $(SED) -f comps.sed $(_GEN)\comps.tao140_skel_t.cpp > $(_GEN)\comps_skel_t.cpp
+    - $(SED) -f comps.sed $(_GEN)\comps.tao140_skel_t.h   > $(_GEN)\comps_skel_t.h
diff --git a/SelfServiceCommon/Massai/idl/Cuss/massai.css b/SelfServiceCommon/Massai/idl/Cuss/massai.css
new file mode 100644
index 00000000..a5a5bc98
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Cuss/massai.css
@@ -0,0 +1,216 @@
+H1 {
+  text-align: center;
+  font-family: Geneva, Arial, Helvetica, sans-serif;
+}
+H2 {
+  font-family: Geneva, Arial, Helvetica, sans-serif;
+}
+CAPTION { font-weight: bold }
+DIV.qindex {
+  width: 100%;
+  background-color: #eeeeff;
+  border: 1px solid #B0B0B0;
+  text-align: center;
+  margin: 2px;
+  padding: 2px;
+  line-height: 120%;
+}
+A.qindex {
+       text-decoration: none;
+       font-weight: bold;
+       color: #1A419D;
+       padding: 2px;
+}
+A.qindex:visited {
+       text-decoration: none;
+       font-weight: bold;
+       color: #1A419D
+       padding: 2px;
+}
+A.qindex:hover {
+  text-decoration: none;
+  background-color: #ddddff;
+  padding: 2px;
+}
+A.qindexHL {
+  text-decoration: none;
+  font-weight: bold;
+  background-color: #6666cc;
+  color: #ffffff;
+  padding: 2px 6px;
+  border: 1px double #9295C2;
+}
+A.qindexHL:hover {
+  text-decoration: none;
+  background-color: #6666cc;
+  color: #ffffff;
+  padding: 2px 6px;
+}
+A.qindexHL:visited { text-decoration: none; background-color: #6666cc; color: #ffffff }
+A.el { text-decoration: none; font-weight: bold }
+A.elRef { font-weight: bold }
+A.code { text-decoration: none; font-weight: normal; color: #1A419D}
+A.codeRef { font-weight: normal; color: #1A419D}
+A:hover { text-decoration: none; background-color: #f2f2ff }
+DL.el { margin-left: -1cm }
+PRE.fragment {
+  border: 1px solid #CCCCCC;
+  background-color: #f5f5f5;
+  margin-top: 4px;
+  margin-bottom: 4px;
+  margin-left: 2px;
+  margin-right: 8px;
+  padding-left: 6px;
+  padding-right: 6px;
+  padding-top: 4px;
+  padding-bottom: 4px;
+}
+DIV.fragment {
+  border: 1px solid #CCCCCC;
+  background-color: #f5f5f5;
+  padding: 6px;
+}
+DIV.ah { background-color: black; font-weight: bold; color: #ffffff; margin-bottom: 3px; margin-top: 3px }
+TD.md { background-color: #F4F4FB; font-weight: bold; }
+TD.mdname1 { background-color: #F4F4FB; font-weight: bold; color: #602020; }
+TD.mdname { background-color: #F4F4FB; font-weight: bold; color: #602020; width: 600px; }
+DIV.groupHeader {
+       margin-left: 16px;
+       margin-top: 12px;
+       margin-bottom: 6px;
+       font-weight: bold;
+  font-family: Geneva, Arial, Helvetica, sans-serif;
+}
+DIV.groupText { margin-left: 16px; font-style: italic; font-size: 14px }
+BODY {
+  background-color: #eeeeff;
+  color: #000064;
+  margin-right: 20px;
+  margin-left: 20px;
+}
+TD.indexkey {
+  background-color: #eeeeff;
+  font-weight: bold;
+  padding-right  : 10px;
+  padding-top    : 2px;
+  padding-left   : 10px;
+  padding-bottom : 2px;
+  margin-left    : 0px;
+  margin-right   : 0px;
+  margin-top     : 2px;
+  margin-bottom  : 2px;
+  border: 1px solid #CCCCCC;
+}
+TD.indexvalue {
+  background-color: #eeeeff;
+  font-style: italic;
+  padding-right  : 10px;
+  padding-top    : 2px;
+  padding-left   : 10px;
+  padding-bottom : 2px;
+  margin-left    : 0px;
+  margin-right   : 0px;
+  margin-top     : 2px;
+  margin-bottom  : 2px;
+  border: 1px solid #CCCCCC;
+}
+TR.memlist {
+   background-color: #f0f0f0;
+}
+P.formulaDsp { text-align: center; }
+IMG.formulaDsp { }
+IMG.formulaInl { vertical-align: middle; }
+SPAN.keyword       { color: #008000 }
+SPAN.keywordtype   { color: #604020 }
+SPAN.keywordflow   { color: #e08000 }
+SPAN.comment       { color: #800000 }
+SPAN.preprocessor  { color: #806020 }
+SPAN.stringliteral { color: #002080 }
+SPAN.charliteral   { color: #008080 }
+.mdTable {
+  border: 1px solid #868686;
+  background-color: #F4F4FB;
+}
+.mdRow {
+  padding: 8px 10px;
+}
+.mdescLeft {
+       padding: 0px 8px 4px 8px;
+  font-size: 14px;
+  font-style: italic;
+  background-color: #FAFAFA;
+  border-top: 1px none #E0E0E0;
+  border-right: 1px none #E0E0E0;
+  border-bottom: 1px none #E0E0E0;
+  border-left: 1px none #E0E0E0;
+  margin: 0px;
+}
+.mdescRight {
+       padding: 0px 8px 4px 8px;
+  font-size: 14px;
+  font-style: italic;
+  background-color: #FAFAFA;
+  border-top: 1px none #E0E0E0;
+  border-right: 1px none #E0E0E0;
+  border-bottom: 1px none #E0E0E0;
+  border-left: 1px none #E0E0E0;
+  margin: 0px;
+}
+.memItemLeft {
+  padding: 1px 0px 0px 8px;
+  margin: 4px;
+  border-top-width: 1px;
+  border-right-width: 1px;
+  border-bottom-width: 1px;
+  border-left-width: 1px;
+  border-top-style: solid;
+  border-top-color: #E0E0E0;
+  border-right-color: #E0E0E0;
+  border-bottom-color: #E0E0E0;
+  border-left-color: #E0E0E0;
+  border-right-style: none;
+  border-bottom-style: none;
+  border-left-style: none;
+  background-color: #FAFAFA;
+  font-family: Geneva, Arial, Helvetica, sans-serif;
+  font-size: 12px;
+}
+.memItemRight {
+  padding: 1px 8px 0px 8px;
+  margin: 4px;
+  border-top-width: 1px;
+  border-right-width: 1px;
+  border-bottom-width: 1px;
+  border-left-width: 1px;
+  border-top-style: solid;
+  border-top-color: #E0E0E0;
+  border-right-color: #E0E0E0;
+  border-bottom-color: #E0E0E0;
+  border-left-color: #E0E0E0;
+  border-right-style: none;
+  border-bottom-style: none;
+  border-left-style: none;
+  background-color: #FAFAFA;
+  font-family: Geneva, Arial, Helvetica, sans-serif;
+  font-size: 13px;
+}
+.search     { color: #003399;
+              font-weight: bold;
+}
+FORM.search {
+              margin-bottom: 0px;
+              margin-top: 0px;
+}
+INPUT.search { font-size: 75%;
+               color: #000080;
+               font-weight: normal;
+               background-color: #eeeeff;
+}
+TD.tiny      { font-size: 75%;
+}
+a {
+  color: #252E78;
+}
+a:visited {
+  color: #3D2185;
+}
diff --git a/SelfServiceCommon/Massai/idl/Cuss/materna.GIF b/SelfServiceCommon/Massai/idl/Cuss/materna.GIF
new file mode 100644
index 0000000000000000000000000000000000000000..130f19a6839e28f38db8465a4dc3999728c3f083
GIT binary patch
literal 3794
zcmchY>swQIzQuq0lCVPpY!X7k&DjaJfPe`If*`XK?$Js>3ITPDfIx*hQK$vMo)8iU
z5HQ7vXwwp?C|2P_EhD4S1_Y|3MZlJNr4h%1*47j{rR``r_MbT47oS((^{f}`S<gyI
zOOB4&c?N`o?^b}-YF%DgnV6lQoqsVjF*`6mGyh`wHB18&#=h}t)6mT9e7SL`R6kIl
z>64cCNJ>q-O#Q(4tg&xG-!rZ;4aF3gM0v)bOg%5t$d&4GiKaj^kXPN8S>7WpHDNIt
zAgb;gn&}yss5TCj>jz3TeL<N<o>b43Xf&qr%<?{IX^*796q9G<O7wV)1`}0-pz`sF
z*`9$JQ{RNKXIyW3EgUM<3=~xN<(2ou<e5a7#vrL46KOzD^~~&xiJAGl^1jT{9%+Fo
zNNVIs^v0eEy=h!y9IDn2#AF&pub+de0k3>$e0F?deqd+@aLfA!W~6zh`S}+wUMw#!
zuguRc&&<rv&b|QukH`BBh5ob)`4fL;LOQIdfVxhjt#8mZHZ|*8S`QiCZ&OP|B7(<B
z<cWe1E#k%Ft>*GN)^ye*!c#|yqdcLwNq*A8W9za#`*{?D8+ne?Nb4uU*Q=Q(%dLOa
zA2}B&Z;*7{A_muFH{b3^hH{2@8|pY8hk=}+{?pp{&)hUI;e&xXxuBnPyu8Ms1^kcA
z;<|K2CCl%5+tp$hpL%l&)^q_6rS2W%%zeQCHi-!%7aTv|NaFZ2qE6mzNT#|f-B%~M
zi>VKW)edF~zU_P5!`9H8+I8^NA3o<7C4AJury}vg;5VNc{1^>8FDZU7Xgb?T%r%S5
zAAfVbf2*6(`J1~v-7Cs>IubATKfGMI^xc3u|G7SZS&{|e*1E6|=S0+E&q$=Zvf++N
zQJog1ZHS*DAcf8e(6{N?84R+;A4rw`Qw8HKyfeGago0@NL>$`AK0m#4*qxJO8MN?5
zw3wHNlQ4~ZqSiPjI~D$8--s98K}_g@`N=37@KY7nAqvoXLfcXyp?YkY8G}Z0YqeSw
z_#CJ<ud|LE@jO5g*i@*y;7fr>8SaREntIr*rUe_ZjkEv(Ql_y?GBxb|*U}oob$}$j
z-z(|%r-xZ5S^nJ%b7Z*5K1EPKmyNu?ealWvAdqMn_`htVFR$v0s{%nypl&7Y<I2g2
zAf7!DqbZ<ac<Th{+Q<(a18DI^isr`tZ;xD`IHr{;)72b<Mn~ztHVJY+t5J>7PJvp8
zmvkvDmG<V3Koxq*FTs^B%)I~tcya*fQAPIcn_oPLQfD(;x=$wv8Y{Do{_%Xe*`KU@
zraM0PX`>EN{M1_*v4<_G%jQ*Bpvd<EfP09`?q@fnXtTvSAaHAz(6`rK6jR5F%yVrV
z?g#1kc#&bGt8u{qJI0$;;ySfm@tl5#nXjUcePn$b9XsEwzWn27!lQ59@3zDA>z<NP
z`UCfB08stv5`MxJ+n(f%GOt>fHDFNZ;CZEaghFTU)2={Gn6SO}olxZ#KJ_M%sPvwH
za%y|TzbzlJX^cywDeE4PX-<?9UMe0+=To5PElIUHNr#Md+u9~u1vcv6NrIW)L)QIN
zBj_ixqs>>bY@_N!9=}62jBybeaH90Ksn&J!`nsKl54uN&(iBHDI$wQuZKM>7t!1Wg
z6eAF26Hu|Edj%+M))q269*f*O#&&Zf%6O3ceeIKu)m7Knh~mAfJB^ilC<}GUu-~8b
zcDDXAlG^*x@87q(sK<ci>K^hlO;+pgV35<c{%QR}Ym9x(t^%60+;imFPv@-4t-MHu
zXFJ20K0U%hJ=QXoc-~o)ZhT^_bY*$=FNp>gjOAbbrQNt=vj1<FY()_M_L7GA&8KRb
zV<0OZdBYikow&6v+?ND8{z${Hr|2BZ4uNE)cF7qEG)@vwC<Ni&Jy_g!2~`n}?wBk5
zBzY~$+OY7D=uLDg()gpUB~8?C`B*4uP6^)RaN5xvU?go`9np$SyOk~;-n-#tFmkY!
z7@mg|RL(IQ>n)~Q;3rvS`E@#M^LeKoReRk?gDhM2v)bEe)0b3`E@6wBU$GIsAf~xq
z_^8oyRtOKSwkAc{MH}Y$RIkh95fU3xDhu+s?>d}bI2j%=ENN0tiq9A#1tw)iY6J0=
zL&Bg}Sg>e?+i?%LY*RoSyV(d;B`xnmL3F;lK25$w_YdV4HC5#5Y^LUe$_xQv1Q~aU
z!kqoUo%ukzaby0R@0-JpwK$61^3#!-ATC5PwbA4^id~RPlGpl)=SlP|gIo7M1Jj(f
zZljEmMVz~TSB7@6jnPeegK!E@o91@9U{mmMFpTzWDPly~Y5r$}#I<pwJs&}ueN{q_
zyWXSN-Q3T0WeL=raF@Q3Dh!HCq{hV-pT*B5%f0bKKmksY_K?KHTPH}xuIok8+sE(y
zd@}mW)0^pC8kgt!VXrRS07Z$hmn<X}ORNGFLgDRAeTBKoe7^IfxqWsF0xJ|1E&8$Q
z2Zk+#BR_<zN8pCsE{AOHYEWjs5do9%A_8cFx!Oe|xh_<YPVWUOmyU8guH+alBWq_r
zRBSxrt#XMMK`yF5UpMYFKC=b+A`FULWjp2+eH%UyVs^-plgU2B;4k<H0=hx{erp6G
z2L+*bCW@VuTGlq_9ctZ(>xoZve!awrSf_qv!^Q`5o)>Y+ARCLaJlNEW(>VZQv|nyn
z&zGP_6?;}wEAw(omM>3J)-XE$O9y6!`OzCMD!;z`p!ik#6?+SC#Z|Ea*+sU;5Vd^g
zIrqd#0=-8Wc2SARx54U@j<2pqsgh(}3x&fxbJ0q@+ZCJR*1-`{p1vmR=1#@1Eq7$W
zqD2O4$*9L{+P%X>K`q3F&Bxfz!>(&{;u^SRZgJ70@8{zQ4Q1whZO6w^SByJ;>8(do
zlNakmnYDhtxw~^x{R8SJ3j?=$T;G}S^&bKQ@T<5>Wyv6Vd_~5Oc_-dGZwQV$&#g`T
z`F1y{48gnp4O3qFp@$2`(>)K+0aAtcN(~O<47zXF-0{3P4P-n$yeEu5YGVZNsmVAV
zQSQik5~2aryWb^b*;aKdkbk`(-=GNYb%2$xm-D5-Yo~&q=&{f#UL0|g^DqImkbm~>
z4c%N}Rtwc%Dy`Eo3vsM??=BOv;sgJfnQw^4g53&!f`PY{b3v8}iOvO9za(y}qrqvu
z@73D%BH;gq?4Gm7TL%>)52<KWR?`JB&fajK-&p6k%`R%$gJ7dkC~ZBn*(2BUu5GG`
zktNi<@df{0$}o9mpAp%1lJ(EW_YdRIkftj1>*T+#ay3de>!@dGSiH|@!og#@BmeaT
zOZC@W&`nFnZpBG2PVIB=x?Wxa%huf_Ppv;SKmPX8HQcAS&2(4n=ERTcl-(=dF(7Fs
zK7}!FMMDR8dF6lOPJHj^?9Rtu?L*4$FhecJoo6O~8F-gClUu7hSyt#<$oTmw6SHll
znpt{vK*t9DsDxEmx+1x`yCy<?pozkRTW?*z(=I!{`DI9kVuhdtTCKDi6~wTTM}A#9
zdYKja_vD7uJA&sA*=5!<9?p`xPe)k++k|zu3g9`ltvYUp<+m?O|5y_2{;BEjYp{^B
z8RMg#I@8DcZYq5avLo%Pj2guu*4#tFt%-5?QAv_UUbn%pwz}j$kJc4Eox=gWiS{(G
zGwww9^orR_G%?qY=G8y>`uA&`{JO~DxgWe0FvL|k*`Vh}X1&5ukg?xNMbZ7i<|600
zQz_>NcQGfW!5UoRUI}cZ%M|2f12KeJ{xt|us#@!vGQMHw8r(aq$eu;Nj!A{RA|t(_
z;?ud6nmTg7WU9jRtMb<kNXOj_0kt}t^pr(pX~2TP?sItM?e?U%>adGhEbE26imcQ+
z0}>MM_*DcJlkqNd8X>1Q#GJ&wT<e&wtRHKD-&sa?9evHDiaQ&My8`}pXGi^{`Z(NB
zF{kx5D#|&P@v?Wrm3y_S(u3D_A0i8m`OyL&>mnnaTk*yo-`FNwpp^gKfQ)IX+-BxB
zbw@XykT;#IY^oAN@rsBB5{Wb*Z90xWvBe;SSvGJX085j>d?Cy+R7NC0>#kvt1v#tZ
zd`JOe63QlEz>EyFh?oSN!lGanzzC!;g@CP~I2h3FJoGlU!VoJV2JlQ3Vydg#GlURT
zhCD0=95ed#Y9uooqvG7}vJhB^Xp@k_a7avoPUz5c8PZ9>vjm)JZRr#On%R#|K)z-_
z6i|HaYbYw14^wLVG1O|%pE3l?4#|X3->^5IfL0|e3JNlyrF{@TANg$zW)wqw3y5c<
z#gCvUgtBzLnV3Sj39woMw?^h@NsyqV1Q^zSo`}f}uzCx&iipUz$Oj@3vCM}i3`A5A
z9j9=V6t<b(O#xCvMkpXc%>1>4V1Az$Md_adpl>sva0J8>e3rru$k6*@H2g927oK-a
zIhJDaky|e#!TX>Ze~8<b117=pPD&Uah1uk6m1nFHk(&{JCB@$cS&jg?lCsGf;Rj@x
z)kAD?J{N=hHUcNRq8n^mTIEPQjzX`OP$??e1=ibXK6Z}~*{U!ZfJpTIqnsQo@?;8P
z3z5*t@HC-cng!{!!S_YTE)O(#x;@*1l($hhilj^%ymd0CW~})nPr$N6hy{Q}$a)Ry
zoCH_i+}5dU?2T?b$2FsQX6gZRGme4S$2piC>BQk~S7bqiI0!+S&FAocC}Pzro(hU4
zkeDSjbrB`)v<RC|H1R>Qoqy>mg#-|cucLY?lJkT}0g?MY+i<!|;4XwIHsBEfQ?6qa
e0^s=edr7StL(319#A9Jk_JJPx@t(FnJ^v2`(vp?{

literal 0
HcmV?d00001

diff --git a/SelfServiceCommon/Massai/idl/Cuss/types.idl b/SelfServiceCommon/Massai/idl/Cuss/types.idl
new file mode 100644
index 00000000..fc808360
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Cuss/types.idl
@@ -0,0 +1,506 @@
+//------------------------------------------------------------------------
+//
+//  File:      types.idl
+//
+//  Purpose:   Type definitions for CUSS idls
+//
+//  Date:      02.03.2009
+//
+//  Version:   1.2
+//
+//  Author:    CUSS Management Group
+//
+//  Copyright(c) 2003,2009 International Air Transport Association, All Rights Reserved
+//
+//  Note:      This IDL file is backward-compatible with that of CUSS 0.2.1 and CUSS 1.0
+//             Please refer to the CUSS 1.2 Technical Specification for more information
+//
+//----------------------------------------------------------------------------
+
+#ifndef TYPES_IDL
+#define TYPES_IDL
+
+#ifdef USE_TAO_ORB_IDL
+   #ifdef _TAO_2_0_
+      #include "tao\orb.idl"
+   #endif
+#endif
+
+#pragma prefix "cuss.iata.org"
+
+/** 
+ *  Definition of the Data Types 
+ * 
+ *  @note  If your version of the IDL compiler treats eventType as a CORBA IDL identifier,
+ *         you will need to escape it by prepending an underscore (_) to it, that is
+ *         replace all occurrences of eventType with _eventType
+ */
+
+module types
+{
+    typedef string name;                /**< Definition for names */
+    typedef sequence<name> namelist;    /**< Definition for name lists */
+    typedef sequence<long> indexList;   /**< Definition for a list of indexes */
+    typedef string reference;           /**< Used as the application reference (token) */
+    typedef string ior;                 /**< CORBA Object reference like IOR:..... */
+    typedef sequence<ior> iorlist;      /**< List of IORs */
+    typedef sequence<octet> bytestream; /**< Definition for data streams */
+    typedef any correlation;            /**< Used as a user defined private identification */
+    
+    /** The time out data type. 
+     * A value > 0 specifies a synchronous call with timeout in MilliSeconds.
+     * A value < 0 specifies an asynchronous call with timeout in MilliSeconds 
+     */     
+    typedef long timeout;            
+                                      
+    const timeout BLOCK_  = 0;       /**< Wait forever on synchronous calls */
+
+    /**
+     *  Application and Kiosk Identification
+     */      
+    struct akID
+    {
+      name companyCode;     /**< eg 3L- or 2L-code for airlines */
+      name applicationName; /**< Name of the application */
+      
+      name vendorCode;      /**< Vendor specific code (used for SM-Interface) */
+      name kioskName;       /**< Name of the the kiosk (used for SM-Interface) */
+    };
+
+    /**
+     * Kiosk location identification 
+     */
+    struct location
+    {
+      name airportCode;   /**< 3L code for the airport or city or any  location */
+      name terminal;      /**< Terminal name, if applicable */
+      name area;          /**< Area name, if applicable */
+      name address;       /**< Free form address, if applicable */
+    };
+
+    /**
+     * Predefinition for GPS
+     */
+    enum orientation
+    {
+        north_, 
+        south_,
+        east_,
+        west_,
+        undefined_
+    };
+    
+    /**
+     * Base definition for GPS coordinates
+     */      
+    struct coordinate
+    {
+        orientation  direction;   /**< north, south, east, west or undefined */
+        long         degrees;     /**< Subdivision in degrees */
+        long         minutes;     /**< Subdivision in minutes */
+        long         seconds;     /**< Subdivision in seconds */
+        long         hundreths;   /**< Subdivision in hundredths of a second */
+    };
+    
+    /**
+     * CUSS uses GPS coordinates to inform about the exact kiosk location
+     */      
+    struct gps
+    {
+        coordinate longitude;  /**< Value for longitude coordinate */
+        coordinate latitude;   /**< Value for latitude coordinate */
+        long       altitude;   /**< Height in meters from sea level */
+    };
+    
+    /**
+     * Structure returned with the <i>level-directive</i>
+     */      
+    struct EnvironmentLevel
+    {
+        timeout   sessionTimeout; 
+        /**< session timeout (in milliseconds) for active applications */
+        
+        timeout   killTimeout;    
+        /**< Time (in milliseconds) left before an application is killed */
+
+        akID      kioskID;       /**< Identification of the kiosk */
+        location  kioskLocation; /**< Location of the kiosk (text form) */
+        gps       gpsLocation;   /**< GPS coordinates of the kiosk */
+
+        name      cussVersion;             
+        /**< contains a comma-separated string for all CUSS versions supported */
+        
+        name      cussInterfaceVersionMin; /**< This field may be left blank */
+        name      cussInterfaceVersionMax; /**< This field may be left blank */
+
+        name      jvmName;    /**< Name of the JAVA virtual machine supported */
+        name      jvmVersion; /**< Version of the JAVA virtual machine supported */
+
+        name      browserName;    /**< Name of the installed internet browser */
+        name      browserVersion; /**< Version of the installed internet browser */
+
+        name      osName;     /**< Name of the installed operating system */
+        name      osVersion;  /**< Version of the installed operating system */
+
+        /** Token reference that is passed to applications. 
+         *  This reference is used as a password for all further directives to the platform */
+         
+        reference applicationToken; 
+    };
+
+    /** 
+     * Base environment component definition
+     */         
+    struct EnvironmentComponent
+    {
+        name       virtualComponentName;  /**< refer to section 3.2.2  */
+        ior        virtualComponentRef;   
+        /**< CORBA reference to the virtual component (IOR) */
+
+        name       realComponentName;     
+       /**< This must be unique per peripheral, used for comparison only */
+              
+        indexList  linkedComponents;      
+        /**< This list of indexes indicates, at which position in the component list
+             the linked components can be found (Index counting starts at 0). */
+                                                    
+    };
+
+    /**
+     * The platform returns a list of all virtual components with this data type
+     */      
+    typedef sequence<EnvironmentComponent> EnvironmentComponents;
+
+    /**
+     *  Data-status codes are used to describe the validity of the data records which are 
+     *  transmitted by an event. The data status codes are defined in file <i>codes.idl</i>
+     */      
+    typedef long dataStatus;
+
+    /**
+     * Predefinition used for the CUSS data type definition
+     */
+    struct dataRecord
+    {
+        dataStatus  status;  /**< Status of the data in this data record */ 
+        bytestream  message; /**< The data itself */ 
+    };
+
+    /**
+     *  The CUSS data type definition.
+     *  This data type is used by card readers, passport readers and other devices.
+     */
+    struct msgDataType
+    {
+        sequence<dataRecord>  records;   /**< A list of data records */
+    };
+
+    /**
+     * Type definition for AEA data which is used by ATB2 and BagTag printers 
+     */
+    typedef bytestream aeaDataType; 
+
+    /**
+     * Type definition for SVG data which is used by a General Purpose Printers (GPP)
+     */
+    typedef bytestream svgDataType;
+
+    /**
+     * Type definition for NULL/NIL data.
+     * Indicates that no data is sent by an event
+     */
+    typedef octet nilDataType;
+
+    /**
+     * Definition for the <i>registerEvent</i> directive
+     */
+    enum action 
+    { 
+      subscribe_,   /**< Used to subscribe/register an event */ 
+      discard_      /**< Used to discard/deregister an event */ 
+    };
+
+    /**
+     * The category of the event that has been sent
+     */
+    enum evtCategory
+    {
+      alarm_,  /**< Manual intervention is required (hard condition) */ 
+      alert_,  /**< Manual intervention is not needed (soft condition)*/ 
+      normal_  /**< Normal event (no error/warning condition) */ 
+    };
+    
+    /**
+     * The type of the event that has been sent. 
+     * In CUSS 1.0, if an event is both private and platform, choose platform as the event type
+     */
+    enum evtType
+    {
+      invalid_, /**< Invalid event (may be used in the returned event of a directive call */ 
+      private_, /**< Private event (received only by the applicable application) */ 
+      public_,  /**< Public event  (received only by all listening applications)*/ 
+      platform_ /**< Platform event (received only by the applicable application and SP SM) */ 
+    };
+
+    /**
+     * The mode of the event that has been sent
+     */
+    enum evtMode
+    {
+      solicited_,   /**< Event is related to a previous directive call */ 
+      unsolicited_  /**< Event is NOT related to any previous directive call */ 
+    };
+
+    /**
+     * This definition is used to specify which events should be received by 
+     * the instance that acquires a component or registers for event(s)
+     *
+     */
+    enum evtFilterType
+    {
+      all_,       /**<  Receive all events */ 
+      any_,       /**<  Receive any event (used for <i>eventWait</i> only) */ 
+      nil_,       /**<  Receive no event */ 
+      code_,      /**<  Receive event related to specific event code(s) */ 
+      type_,      /**<  Receive related to specific event type(s) */ 
+      component_  /**<  Receive related to specific component(s) */ 
+    };
+
+    typedef long evtCode;         /**< Event codes as defined in <i>codes.idl</i> */ 
+    typedef long evtStatusCode;   /**< Status codes as defined in <i>codes.idl</i> */ 
+    
+    /** 
+     *  This definition is more obvious than just the CORBA::any type.
+     *  A datastream may consist of: <i>aeaDataType, svgDataType, nilDataType, msgDataType</i>
+     *  (Datastreams must always be complete and NOT segmented).
+     *  
+     *  In CUSS 1.0, datastream may also consist of:
+     *  string,        used for clock data type, format is (yyyymmddhhmmss) or
+     *  const long,    used for switch data type, value is one the following:
+     *  (OFF= 0, ON=1, OPEN=2, CLOSED=3, YES = 4, NO=5, UNKNOWN=6)
+     */     
+    typedef any  datastream;      
+
+    /**
+     * Predefinition for <i>evtAcquireFilter</i> data type
+     */
+    union evtCodeFilterUnion switch(evtFilterType)
+    {
+      case all_       :                         
+      case any_       : any filterALLorANY;     
+      case component_ : iorlist filterCOMPONENT;
+    };
+
+    /**
+     * Predefinition for <i>evtAcquireFilter</i> data type
+     */
+    struct evtCodeFilterElem
+    {
+      evtCode             eventCode;    /**< The event code for event filtering */
+      evtStatusCode       statusCode;   /**< The status code for event filtering */
+      evtCodeFilterUnion  eventFilter;  /**< Component filter for the event/status code */
+    };
+
+    /**
+     * Predefinition for <i>evtAcquireFilter</i> data type
+     */
+    typedef sequence<evtCodeFilterElem> evtCodeFilter;
+
+    /**
+     * Predefinition for <i>evtAcquireFilter</i> data type
+     */
+    union evtTypeFilterUnion switch(evtFilterType)
+    {
+      case all_       :                           
+      case any_       : any filterALLorANY;       
+      case component_ : iorlist filterCOMPONENT;  
+    };
+
+    /**
+     * Predefinition for <i>evtAcquireFilter</i> data type
+     */
+    struct evtTypeFilterElem
+    {
+        evtType eventType;               /**< The event type for event filtering */
+        evtTypeFilterUnion eventFilter;  /**< Component filter for the event type */
+    };
+
+    /**
+     * Predefinition for <i>evtAcquireFilter</i> data type
+     */
+    typedef sequence<evtTypeFilterElem> evtTypeFilter;
+
+    /**
+     * Predefinition for <i>evtAcquireFilter</i> data type
+     */
+    union evtComponentFilterUnion switch(evtFilterType)
+    {
+      case all_  :                                
+      case any_  : any filterALLorANY;            
+      case code_ : sequence<evtCode> filterCODE;  
+      case type_ : sequence<evtType> filterTYPE;  
+    };
+
+    /**
+     * Predefinition for <i>evtAcquireFilter</i> data type
+     */
+    struct evtComponentFilterElem
+    {
+        ior   componentName;                  /**< The component name for event filtering*/
+        evtComponentFilterUnion eventFilter;  /**< Event filter for the component name */
+    };
+
+    /**
+     * Predefinition for <i>evtAcquireFilter</i> data type
+     */
+    typedef sequence<evtComponentFilterElem> evtComponentFilter;
+
+    /**
+     * This data type is passed to the <i>registerEvent</i> directive to specify
+     *  which events are received from the platform
+     *
+     * @note:   In CUSS 1.0, implementing event filtering is not mandatory.
+     *
+     */
+    union evtFilter switch(evtFilterType)
+    {
+      case all_       :
+      case any_       : any filterALLorANY;                 
+      case code_      : evtCodeFilter filterCODE;           
+      case type_      : evtTypeFilter filterTYPE;           
+      case component_ : evtComponentFilter filterCOMPONENT; 
+    };
+
+    /**
+     *  This data type is passed to the <i>component acquire</i> directive to specify
+     *  which events are received from this virtual component
+     *
+     * @note:   In CUSS 1.0, implementing event filtering is not mandatory.
+     *
+     */
+    union evtAcquireFilter switch(evtFilterType)
+    {
+      case all_  :                               
+      case nil_  : any filterALLorNIL;           
+      case code_ : sequence<evtCode> filterCODE;  
+      case type_ : sequence<evtType> filterTYPE; 
+    };
+
+    /**
+     * Predefinition for <i>evtDescription</i> data type
+     */
+    struct evtDescr
+    {
+        evtCode           eventCode;         /**< Description is related to this event code */
+        evtStatusCode     statusCode;        /**< Description is related to this status code */
+        sequence<evtType> eventTypes;        /**< Description is related to this event type */
+        name              eventDescription;  /**< The textual description of the specified event */
+    };
+
+    /**
+     * Predefinition for <i>evtDescription</i> data type
+     */
+    struct evtDescrANY_CODE_TYPE
+    {
+        evtDescr  eventDescr;     /**< The event description */
+        namelist  componentList;  /**< The event description for these components */
+    };
+
+    /**
+     * Predefinition for <i>evtDescription</i> data type
+     */
+    struct evtDescrCOMPONENT
+    {
+        name                componentName; /**< The event description for this component */
+        sequence<evtDescr>  eventDescr;    /**< The event descriptions */
+    };
+
+    /**
+     * This definition is used to query information about event(s)
+     */
+    union evtDescription switch(evtFilterType)
+    {
+      case any_       :                                               
+      case code_      :                                               
+      case type_      : evtDescrANY_CODE_TYPE eventDescrANY_CODE_TYPE;
+      case component_ : evtDescrCOMPONENT eventDescrCOMPONENT;        
+    };                                                                  
+                                                                        
+#ifndef _TIME_BASE_IDL_
+
+    /**
+     *  Definition of TimeT borrowed from the CORBA Time Service.
+     *  TimeT represents a simple time value, witch is 64 bits in size, 
+     *  and holds the number of 100 nanoseconds that have passed since the base time.
+     *  For absolute time calculations, the base is <i>15 October 1582 00:00 </i>.
+     *
+     *  Note: If your IDL compiler does not yet support the <i>long long</i> data type, 
+     *        please compile this module with the preprocessor definition <i>NOLONGLONG</i>.
+     *        
+     */
+     
+#ifdef NOLONGLONG
+
+    struct ulonglong 
+    {
+        unsigned long low;
+        unsigned long high;
+    };
+
+    typedef ulonglong TimeT;
+
+#else
+
+    typedef unsigned long long  TimeT;
+
+#endif // NOLONGLONG
+#endif // _TIME_BASE_IDL_
+
+    /**
+     *  Event definition.
+     *  This definition is used for all events and return values that are used within the platform
+     */ 
+    struct Event
+    {
+        TimeT           timeStamp;        /**< Time stamp in UTC format */
+        akID            kioskID;          /**< Identification of the kiosk application */
+        location        kioskLocation;    /**< Location of the kiosk (text form) */
+        gps             gpsLocation;      /**< GPS coordinates of the kiosk */
+
+        name            componentRef;        
+        /**< reference of the component if it is the event source */
+        
+        name            functionName;        
+        /**< name of the function/directive which has been executed 
+             (this field will be empty for unsolicited events) */
+
+        evtCode         eventCode;           
+        /**< Application or component state transition or the current application
+             or component state if no transition applies */
+        
+        evtMode         eventMode;        /**< solicited, unsolicited */
+        evtType         eventType;        /**< invalid, private, public, platform */
+        evtCategory     eventCategory;    /**< alarm, alert, normal */
+        evtStatusCode   statusCode;       /**< component status or function call status */
+
+        correlation     elud;             /**< user defined private identification */
+        datastream      eventData;        /**< data passed with the event */
+    };
+
+    /**
+     *  Event listener definition.
+     *  This interface is passed on acquiring virtual components or with the
+     *  <i>registerEvent</i> directive
+     */      
+    interface evtListener
+    {
+        /**
+         *  This function is called whenever an event is sent to the application.
+         *
+         *  @param  e    The event that is passed to the application
+         */     
+        void callback(in Event e);
+    };
+};
+#endif // TYPES_IDL
+ 
diff --git a/SelfServiceCommon/Massai/idl/Massai/BarCodeScannerDev.idl b/SelfServiceCommon/Massai/idl/Massai/BarCodeScannerDev.idl
new file mode 100644
index 00000000..9518a05e
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Massai/BarCodeScannerDev.idl
@@ -0,0 +1,138 @@
+//---------------------------------------------------------------------------
+//
+//  file:     BarCodeScanner.idl
+//
+//  purpose:  basic definition for the massai BarCodeScanner device (internal)
+//
+//  date:     10.09.01
+//
+//  author:   (PtM)
+//
+//---------------------------------------------------------------------------
+
+#ifndef BarCodeScanner_IDL
+#define BarCodeScanner_IDL
+
+#ifdef USE_TAO_ORB_IDL
+   #ifdef _TAO_2_0_
+      #include "tao\orb.idl"
+   #endif
+#endif
+
+#include "mdci.idl"
+
+#pragma prefix "DeviceComponents.massai.materna.com"
+
+/** MASSAI Device Component interface to BarCodeScanner device driver.
+ *  @version 1.0
+ *  @author PtM - Materna Information & Communications
+ */
+
+module BarCodeScannerDev
+{
+
+    /** Data type for card data messages. */
+    typedef sequence<string> StringList;
+
+    struct BCSData
+    {
+      StringList  Data;       /**< Raw Data */
+    };
+
+    /** Definition of authentication types*/
+
+    enum BCSType
+    {
+      BCS_READER  /**< scanner */
+    };
+
+    /** Definition of completion types returned by the device handler in the indication status.
+     *  The completion type only belongs to the last command and is not a device status.
+     */
+
+    enum completionType
+    {
+      CMPL_COMPLETED,       /**< Command has been completed, no error */
+      CMPL_CANCELLED,       /**< Command has been cancelled */
+      CMPL_CANCEL_FAILED,   /**< Command could not be cancelled successfully */
+      CMPL_TIMEOUT,         /**< Timeout has been expired */
+      CMPL_ILLOGICAL,       /**< Command is out of sequence */
+      CMPL_READ_ERROR,      /**< Card cannot be read */
+      CMPL_WRONG_FORMAT,    /**< Wrong format in command or card data */
+      CMPL_FAILED,           /**< Execution of command has failed */
+      CMPL_MEDIA_UNKNOWN    /**< Unknown authentication paper */
+    };
+
+    /** Definition of error types returned by the device handler in the indication status.
+     *  The error type represents the current device status.
+     */
+
+    enum errorType
+    {
+      ERR_NONE,             /**< No error */
+      ERR_BUSY,             /**< Device is busy */
+      ERR_DISCONNECTED,     /**< Device is disconnected */
+      ERR_HARDWARE         /**< Hardware error */
+    };
+
+    /** Definition of media status types returned by the device handler in the indication status. */
+
+    enum mediaStatusType
+    {
+      MEDIA_ABSENT,         /**< Media present in device */
+      MEDIA_PRESENT,        /**< Media not present in device */
+      MEDIA_UNKNOWN         /**< Media unknown */
+    };
+
+    /** Defines the current device status. */
+
+    enum statusType
+    {
+      STA_IDLE,
+      STA_ERROR,
+      STA_BUSY,
+      STA_DISCONNECTED
+    };
+
+    struct status
+    {
+      statusType      deviceStatus;     /**< The current status of the device */
+      completionType  completionCode;   /**< The completion code of the last command */
+      errorType       errorStatus;      /**< The current error status of the device */
+      mediaStatusType mediaStatus;      /**< The current media status of the device */
+    };
+
+    /** Definition of command types passed to this device handler. */
+
+    enum commandType
+    {
+      CMD_CLOSE,        /**< Disables data transfer, even if data arise */
+      CMD_OPEN,         /**< Enables data transfer if any data arise */
+      CMD_RESET,        /**< Reset device */
+      CMD_READ,         /**< Read data */
+      CMD_CANCEL,        /**< Cancels the last command */
+      CMD_STATUS_QUERY  /**< Query device status */
+    };
+
+    /** Definition of indication types received from this device handler. */
+
+    enum indicationType
+    {
+      IND_DATA_ARISE,       /**< e.g. passport has been inserted by customer */
+      IND_CLOSE_DONE,       /**< disable datatransfer done */
+      IND_OPEN_DONE,        /**< enable datatransfer done */
+      IND_RESET_DONE,       /**< Reset device finished */
+      IND_READ_DONE,        /**< Read data finished */
+      IND_CANCEL_DONE,	    /**< Cancel last command done */
+      IND_STATUS_INFO,      /**< Current device status */
+      IND_POWER_SWITCH_REQUEST  /**< Request to switch Power off and on again */
+    };
+
+    /** Authentication DeviceComponent interface inherits from the generic interface. */
+
+    interface Handler : DeviceComponents::Generic
+    {
+    };
+};
+
+#endif
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/idl/Massai/ConveyorDev.idl b/SelfServiceCommon/Massai/idl/Massai/ConveyorDev.idl
new file mode 100644
index 00000000..2f728115
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Massai/ConveyorDev.idl
@@ -0,0 +1,283 @@
+/**
+ **************************************************************************
+ *
+ * @file ConveyorDev.idl
+ *
+ * Contains module conveyordev, which is the platform-internal interface
+ * definition for the massai conveyor device component.
+ *
+ * @author Jrgen Kreierhoff
+ *
+ **************************************************************************
+**/
+#ifndef CONVEYORDEV
+#define CONVEYORDEV
+
+#ifdef USE_TAO_ORB_IDL
+   #ifdef _TAO_2_0_
+      #include "tao\orb.idl"
+   #endif
+#endif
+
+#include "mdci.idl"
+
+
+
+/**
+ * The pragma statement must be defined after the last include statement,
+ * because some ORB implementations do not handle the scope correctly.
+**/
+#pragma prefix "DeviceComponents.massai.materna.com"
+
+
+
+/**
+ *
+ * MASSAI Device Component interface module to a real Conveyor device
+ * driver.
+ *
+**/
+module conveyordev
+{
+
+   /**
+    *
+    * Definition of completion types returned by the device handler in the
+    * indication status. The completion type only describes the outcome of
+    * the last command and is not a device status.
+    *
+   **/
+   enum completionType
+   {
+      CMPL_COMPLETED,               /**< Command has been completed,
+                                         no error */
+      CMPL_CANCELLED,               /**< Command has been cancelled */
+      CMPL_ABORTED                  /**< Command has been aborted, e.g.
+                                         coupon ejected by printer */
+    };
+
+   /**
+    *
+    * Definition of error types returned by the device handler in the
+    * indication status. The error type represents the current device
+    * status.
+    *
+   **/
+   enum errorType
+   {
+      ERR_NONE,                     /**< No error */
+      ERR_BUSY,                     /**< Device is busy */
+      ERR_DISCONNECTED,             /**< Device is disconnected */
+      ERR_HARDWARE,                 /**< Hardware error */
+      ERR_WEIGHT_CHANGED,           /**< Illicit weight change */
+      ERR_PIECE_TOO_LONG,           /**< Piece is too long. */
+      ERR_PIECE_TOO_HIGH,           /**< Piece is too high. */
+      ERR_PIECE_NOT_DETECTED,       /**< Piece has not been detected,
+                                         e.g. customer has removed bag
+                                         or a jam has occured. */
+      ERR_TOO_MANY_PIECES,          /**< Too many pieces have been
+                                         detected. */
+      ERR_PIECE_POSITION,           /**< A piece has been detected
+                                         at an unexpected position. */
+      ERR_PIECE_TOO_SMALL,          /**< Piece is too small. */
+      ERR_PIECE_TOO_SHORT,          /**< Piece is too small in length. */
+      ERR_PIECE_TOO_FLAT,           /**< Piece is too small in height. */
+      ERR_WRITE_FAILED,             /**< Programming RFID transponder
+                                         failed. */
+      ERR_DATA_INCOMPLETE,          /**< Not all data available. */
+      ERR_DATA_INVALID,             /**< Invalid input data submitted. */
+      ERR_TIMEOUT,                  /**< Transaction took too long. */
+      ERR_TRANSPORT_FAILED,         /**< piece transport failed. */
+      ERR_PIECE_TOO_HEAVY,          /**< Piece is too heavy. */
+      ERR_TRANSPORT_ABORTED         /**< Piece transport not started. */
+   };
+
+   /**
+    *
+    * Defines the device characteristics.
+    *
+   **/
+   struct characteristics
+   {
+
+      /**
+       *
+       * Do we have a scale?
+       *
+      **/
+      boolean           scalePresent;
+
+      /**
+       *
+       * Do we have a barcode scanner?
+       *
+      **/
+      boolean           barcodeScannerPresent;
+
+      /**
+       *
+       * Do we have a park position?
+       *
+      **/
+      boolean           parkPositionPresent;
+
+
+   };
+
+   /**
+    *
+    * Defines the current device status. An object of this kind is
+    * delivered with IND_STATUS_INFO
+    *
+   **/
+   struct status
+   {
+      /**
+       *
+       * The completion code of the last command.
+       *
+      **/
+      completionType    completionCode;
+
+      /**
+       *
+       * The current error status of the device.
+       *
+      **/
+      errorType         errorStatus;
+
+
+   };
+
+   typedef sequence<string> StringList;
+
+   /**
+    *
+    * Defines the current bag info (weight and barcode). An object of
+    * this kind is delivered with IND_PIECE_WEIGHT and IND_PIECE_BARCODE.
+    *
+   **/
+   struct bagInfo
+   {
+      /**
+       *
+       * The weight of the currently accepted piece. The weight is given
+       * in units of 1 gramm.
+       *
+      **/
+      long              baggageWeight;
+
+      /**
+       *
+       * The barcode data read from the currently accepted piece.
+       * Please be aware, that there may be several barcodes readable
+       * from the baggage.
+       * merged with the RFID data read from/to be written to the currently
+       * accepted piece.
+       * Please be aware, that there may be several RFIDs readable
+       * from the baggage.
+       *
+       * Barcode-type payload is composed of digits only.
+       * Rfid data start with @RFID:
+       *
+       * Additionally delivery notes are sent here.
+       *
+      **/
+      StringList  baggageBarcodes;
+   };
+
+   /**
+    *
+    * Definition of command types passed to this device handler.
+    *
+   **/
+   enum commandType
+   {
+      CMD_CHARACTERISTICS_QUERY,    /**< Query device characteristics. */
+      CMD_STATUS_QUERY,             /**< Query device status. */
+      CMD_CANCEL,                   /**< Cancel the last command. */
+      CMD_PIECE_ACCEPT,             /**< Accept a piece of baggage from the
+                                         customer. */
+      CMD_PIECE_FORWARD,            /**< Forward a piece with all
+                                         attributes good. */
+      CMD_PIECE_RETURN,             /**< Return a piece of baggage to the
+                                         customer. */
+      CMD_PARKED_FORWARD,           /**< Forward the parked piece(s) to
+                                         the baggage transport. */
+      CMD_PARKED_RETURN,            /**< Return the parked piece(s)
+                                         of baggage to the customer. */
+      CMD_PIECE_REMOVE,             /**< Let the customer remove the
+                                         baggage. */
+      CMD_PIECE_JAM_CLEARED,        /**< Assume the baggage piece trouble
+                                         has been cleared. */
+      CMD_PIECE_RFID_WRITE,         /**< Program RFID transponder. */
+      CMD_DELIVERY_NOTE_SET,        /**< Setup the info to be delivered
+                                         with the baggage. */
+      CMD_PIECE_MONITOR_START,      /**< Start sending weight changes. */
+      CMD_PIECE_MONITOR_STOP,       /**< Stop sending weight changes. */
+      CMD_RETURN                    /**< Return all unconditionally, even
+                                         if in fail state. */
+   };
+
+   /**
+    *
+    * Definition of indication types received from this device handler.
+    *
+   **/
+   enum indicationType
+   {
+      IND_CHARACTERISTICS_INFO,     /**< Device characteristics. */
+      IND_STATUS_INFO,              /**< Current device status. */
+      IND_PIECE_ACCEPT_DONE,        /**< Finished CMD_PIECE_ACCEPT. */
+      IND_PIECE_WEIGHT,             /**< Weight of piece. */
+      IND_PIECE_BARCODE,            /**< Barcode(s) of the piece. */
+      IND_PIECE_FORWARD_DONE,       /**< Finished the CMD_PIECE_FORWARD
+                                         command. */
+      IND_PIECE_RETURN_DONE,        /**< Finished the CMD_PIECE_RETURN
+                                         command. */
+      IND_PARKED_FORWARD_DONE,      /**< Finished the CMD_PARKED_FORWARD
+                                         command. */
+      IND_PARKED_RETURN_DONE,       /**< Finished the CMD_PARKED_RETURN
+                                         command. */
+      IND_PIECE_DELIVER,            /**< Piece(s) is/are about to be
+                                         delivered. */
+      IND_PIECE_REMOVE_DONE,        /**< Finished the CMD_PIECE_REMOVE. */
+      IND_PIECE_JAM_CLEARED_DONE,   /**< Finished the CMD_PIECE_JAM_CLEARED
+                                         command . */
+      IND_PIECE_ACCEPT_WAIT,        /**< Waiting for customer to place a
+                                         piece of baggage. */
+      IND_PIECE_PARKED,             /**< Piece is in park position. */
+      IND_PIECE_ACCEPT_WORKING,     /**< Prepare weighing the piece. */
+      IND_PIECE_RFID,               /**< RFID(s) of the piece. */
+      IND_PIECE_RFID_WRITE_DONE,    /**< Finished the CMD_PIECE_RFID_WRITE
+                                         command. */
+      IND_DELIVERY_NOTE_SET_DONE,   /**< The delivery note is set. */
+      IND_PIECE_CONVEYED,           /**< The piece is on the way. */
+      IND_PIECE_MONITOR_START_DONE, /**< Started sending weight changes. */
+      IND_PIECE_MONITOR_STOP_DONE,  /**< Stopped sending weight changes. */
+      IND_PARKED_FORWARD_WORKING,   /**< Delivery failed retrying. */
+      IND_RETURN_DONE               /**< Finished unconditional return. */
+   };
+
+   /**
+    *
+    * Conveyor DeviceComponent interface inherits the interface handler
+    * from the generic interface.
+    *
+   **/
+   interface Handler : DeviceComponents::Generic
+   {
+   };
+
+};
+
+
+
+#endif // CONVEYORDEV
+/**
+ **************************************************************************
+ *
+ * End of file.
+ *
+ **************************************************************************
+**/
diff --git a/SelfServiceCommon/Massai/idl/Massai/DeviceTest.idl b/SelfServiceCommon/Massai/idl/Massai/DeviceTest.idl
new file mode 100644
index 00000000..7f4e26e4
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Massai/DeviceTest.idl
@@ -0,0 +1,233 @@
+/**
+ **************************************************************************
+ *
+ * @file DeviceTest.idl
+ *
+ * Contains module devicetest, which is the platform-internal interface
+ * definition to test the massai device components.
+ *
+ * @version 1.0
+ *
+ * @author Jrgen Kreierhoff
+ *
+ **************************************************************************
+**/
+#ifndef DEVICETEST
+#define DEVICETEST
+
+#ifdef USE_TAO_ORB_IDL
+   #ifdef _TAO_2_0_
+      #include "tao\orb.idl"
+   #endif
+#endif
+
+#pragma prefix "massai.materna.com"
+
+/**
+ *
+ * MASSAI Device Component interface module to a real device driver.
+ *
+**/
+module DeviceTest
+{
+
+
+   enum RC
+    {
+        RC_OK,                  /**< Command processed successfully */
+        RC_ERROR                /**< Command cannot be processed */
+    };
+
+
+    /**
+    *
+    * The possible "type" values in statusItem. Can be used to display
+    * fancy clips.
+    *
+   **/
+   enum statusItemType
+   {
+      TYPE_UNKNOWN,             /* Should not be used */
+      TYPE_CONVEYORBELT,        /* No value, can be controlled */
+      TYPE_SCALE,               /* Value is a barcode string */
+      TYPE_SCANNER,             /* Value is a weight string */
+      TYPE_PHOTOSENSOR,         /* Value is "occupied" or "free" */
+      TYPE_OTHER                /* E.g. Main-Belt, SPS */
+   };
+
+
+   enum workingType
+   {
+      STATUS_NONE,              /* Device not supposed to report status */
+      STATUS_GOOD,
+      STATUS_FAILED,
+      STATUS_INITIALIZING
+   };
+
+
+   /**
+    *
+    * Defines the current status of one item of the device.
+    * Delivered with the indication() method.
+    *
+   **/
+   typedef sequence<string> stringseq;
+   struct statusItem
+   {
+
+      statusItemType            type;
+
+      string                    name;           /* Item name */
+
+      workingType               working;        /* If unknown,
+                                                   always set to true */
+
+      string                    value;          /* Optional */
+
+      stringseq          		commands;       /* The set of commands */
+      
+   };
+
+
+   /**
+    *
+    * Defines the current status of the device.
+    * Delivered with the indication() method.
+    *
+   **/
+   typedef sequence<statusItem> statusItemseq;
+   struct statusData
+   {
+
+		statusItemseq      items;
+
+   };
+
+
+   /**
+    *
+    * Device test callback interface.
+    *
+   **/
+   interface indicationListener
+   {
+
+      /**
+       *
+       * Passes a status indicationn to the listening instance.
+       *
+       * @param Data:           The status items being passed
+       *
+       * @return a return code as specified in this module
+       *
+      **/
+      RC indication( in statusData Data );
+
+   };
+
+
+   /**
+    *
+    * Defines the command to one item of the device.
+    * Delivered with the testNow() method.
+    *
+   **/
+   struct commandItem
+   {
+
+      string                    name;           /* Item name */
+
+      string                    command;        /* Command for this item */
+
+   };
+
+
+   /**
+    *
+    * Defines a command to the device.
+    * Delivered with the testNow() method.
+    *
+   **/
+   typedef sequence<commandItem> comandItemseq;
+   struct commandData
+   {
+
+      comandItemseq     items;
+
+   };
+
+
+   /**
+    *
+    * Device test interface.
+    *
+   **/
+   interface Handler
+   {
+
+      /**
+       *
+       * Set an indication listener to this device.
+       *
+       * @param Listener:       The listener to set.
+       *
+       * @return a return code as specified in this module
+       *
+      **/
+      RC setListener( in indicationListener Listener );
+
+      /**
+       *
+       * Remove an indication listener from this device.
+       *
+       * @param Listener:       The listener to remove.
+       *
+       * @return a return code as specified in this module
+       *
+      **/
+      RC rmvListener( in indicationListener Listener );
+
+      /**
+       *
+       * Begin a device test period.
+       *
+       * @return a return code as specified in this module
+       *
+      **/
+      RC testBegin();
+
+      /**
+       *
+       * End the device test period.
+       *
+       * @return a return code as specified in this module
+       *
+      **/
+      RC testEnd();
+
+      /**
+       *
+       * Issue a device test command.
+       *
+       * @param Data:           The command item(s) to execute.
+       *
+       * @return a return code as specified in this module
+       *
+      **/
+      RC testNow( in commandData Data );
+
+   };
+
+
+};
+
+
+
+#endif // DEVICETEST
+/**
+ **************************************************************************
+ *
+ * End of file.
+ *
+ **************************************************************************
+**/
diff --git a/SelfServiceCommon/Massai/idl/Massai/PassportReaderDev.idl b/SelfServiceCommon/Massai/idl/Massai/PassportReaderDev.idl
new file mode 100644
index 00000000..df1e2bfe
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Massai/PassportReaderDev.idl
@@ -0,0 +1,154 @@
+//---------------------------------------------------------------------------
+//
+//  file:     AuthDev.idl
+//
+//  purpose:  basic definition for the massai Authenticator device (internal)
+//
+//  date:     10.09.01
+//
+//  author:   (PtM)
+//
+//---------------------------------------------------------------------------
+
+#ifndef AUTHDEV_IDL
+#define AUTHDEV_IDL
+
+#ifdef USE_TAO_ORB_IDL
+   #ifdef _TAO_2_0_
+      #include "tao\orb.idl"
+   #endif
+#endif
+
+#include "mdci.idl"
+
+#pragma prefix "DeviceComponents.massai.materna.com"
+
+/** MASSAI Device Component interface to Authenticator device driver.
+ *  @version 1.0
+ *  @author PtM - Materna Information & Communications
+ */
+
+module PassportReaderDev
+{
+
+    /** Data type for card data messages. */
+    typedef sequence<string> StringList;
+
+    struct PPRData
+    {
+      string            Name;
+      string            Number;
+      string            Type;
+      string            GivenNames;
+      string            Barcode;
+      string            Birth;
+      string            Citizen;
+      string            Country;
+      string            DocType;
+      string            Expiry;
+      string            Optinal;
+      string            sex;
+      string            securityMsg;
+      octet	            DocClass;
+      boolean           EUDoc;
+      StringList        ICAOLine;       /**< Raw ICAO Data */
+    };
+
+    /** Definition of authentication types*/
+
+    enum PPRType
+    {
+      AU_PASSPORT,   /**< Passport */
+      AU_ID_Card     /**< Id-Card */
+    };
+
+    /** Definition of completion types returned by the device handler in the indication status.
+     *  The completion type only belongs to the last command and is not a device status.
+     */
+
+    enum completionType
+    {
+      CMPL_COMPLETED,       /**< Command has been completed, no error */
+      CMPL_CANCELLED,       /**< Command has been cancelled */
+      CMPL_CANCEL_FAILED,   /**< Command could not be cancelled successfully */
+      CMPL_TIMEOUT,         /**< Timeout has been expired */
+      CMPL_ILLOGICAL,       /**< Command is out of sequence */
+      CMPL_READ_ERROR,      /**< Card cannot be read */
+      CMPL_WRONG_FORMAT,    /**< Wrong format in command or card data */
+      CMPL_FAILED,           /**< Execution of command has failed */
+      CMPL_MEDIA_UNKNOWN    /**< Unknown authentication paper */
+    };
+
+    /** Definition of error types returned by the device handler in the indication status.
+     *  The error type represents the current device status.
+     */
+
+    enum errorType
+    {
+      ERR_NONE,             /**< No error */
+      ERR_BUSY,             /**< Device is busy */
+      ERR_DISCONNECTED,     /**< Device is disconnected */
+      ERR_HARDWARE         /**< Hardware error */
+    };
+
+    /** Definition of media status types returned by the device handler in the indication status. */
+
+    enum mediaStatusType
+    {
+      MEDIA_ABSENT,         /**< Media present in device */
+      MEDIA_PRESENT,        /**< Media not present in device */
+      MEDIA_UNKNOWN         /**< Media unknown */
+    };
+
+    /** Defines the current device status. */
+
+    enum statusType
+    {
+      STA_IDLE,
+      STA_ERROR,
+      STA_BUSY,
+      STA_DISCONNECTED
+    };
+
+    struct status
+    {
+      statusType      deviceStatus;     /**< The current status of the device */
+      completionType  completionCode;   /**< The completion code of the last command */
+      errorType       errorStatus;      /**< The current error status of the device */
+      mediaStatusType mediaStatus;      /**< The current media status of the device */
+    };
+
+    /** Definition of command types passed to this device handler. */
+
+    enum commandType
+    {
+      CMD_CLOSE,        /**< Disables data transfer, even if data arise */
+      CMD_OPEN,         /**< Enables data transfer if any data arise */
+      CMD_RESET,        /**< Reset device */
+      CMD_READ,         /**< Read data */
+      CMD_CANCEL,        /**< Cancels the last command */
+      CMD_STATUS_QUERY  /**< Query device status */
+    };
+
+    /** Definition of indication types received from this device handler. */
+
+    enum indicationType
+    {
+      IND_DATA_ARISE,       /**< e.g. passport has been inserted by customer */
+      IND_CLOSE_DONE,       /**< disable datatransfer done */
+      IND_OPEN_DONE,        /**< enable datatransfer done */
+      IND_RESET_DONE,       /**< Reset device finished */
+      IND_READ_DONE,        /**< Read data finished */
+      IND_CANCEL_DONE,	    /**< Cancel last command done */
+      IND_STATUS_INFO,      /**< Current device status */
+      IND_POWER_SWITCH_REQUEST  /**< Request to switch Power off and on again */
+    };
+
+    /** Authentication DeviceComponent interface inherits from the generic interface. */
+
+    interface Handler : DeviceComponents::Generic
+    {
+    };
+};
+
+#endif
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/idl/Massai/ScaleDev.idl b/SelfServiceCommon/Massai/idl/Massai/ScaleDev.idl
new file mode 100644
index 00000000..bfb524c5
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Massai/ScaleDev.idl
@@ -0,0 +1,116 @@
+/**
+ * @file ScaleDev.idl
+ * 
+ * Contains module scaledev, which is the platform-internal interface
+ * definition for the massai scale device component.
+ * 
+ * @version 1.1
+ * 
+ * @author Nicolas Bruns, Thomas Stegemann
+ * 
+ * @section change Change history
+ * 
+ * @date 24.01.2013
+ * @li V1.1
+ * @li Mantis 0025566: WeightScale: support standalone Scale (BaggageScale CUSS1.3)
+ * @li added baggageStatus
+ */
+
+#ifndef SCALEDEV
+#define SCALEDEV
+
+#include "mdci.idl"
+
+/**
+ * The pragma statement must be defined after the last include statement,
+ * because some ORB implementations do not handle the scope correctly.
+**/
+#pragma prefix "DeviceComponents.massai.materna.com"
+
+/**
+ * MASSAI Device Component interface module to a real Scale device
+ * driver.
+**/
+module scaledev
+{
+   /**
+    * Definition of error types returned by the device handler in the
+    * indication status. The error type represents the current device
+    * status.
+   **/
+   enum errorType
+   {
+      ERR_NONE,                 /**< No error */
+      ERR_DISCONNECTED,         /**< Device is disconnected */
+      ERR_HARDWARE              /**< Hardware error */
+   };
+  
+   /**
+    * Defines the current device status. An object of this kind is
+    * delivered with IND_STATUS_INFO
+   **/
+   struct status
+   {     
+      /**
+       * The current error status of the device.
+      **/
+      errorType         errorStatus;
+   };
+
+   /**
+    * Defines the current status of the baggage.
+   **/
+   enum baggageStatus
+   {
+       BAG_ABSENT,                 /**< No baggage on the scale. The weight is stable. */
+       BAG_RESTLESS,               /**< The item on the scale is moving and the scale is attempting to read a stable weight */ 
+       BAG_PRESENT,                /**< An item is on the scale. The weight is stable. */
+       BAG_WEIGHT_OUT_OF_RANGE     /**< An item is on the scale. The weight is beyond the range of the scale. */
+   };
+   
+   /**
+    * Defines the current weight info. An object of this kind is
+    * delivered with IND_PIECE_WEIGHT
+   **/
+   struct weightInfo
+   {
+      /**
+       * The weight of the currently accepted piece. The weight is given
+       * in units of 1 gramm.
+      **/
+      long              pieceWeight;
+      
+      /**
+       * status of the baggage
+      **/
+      baggageStatus     baggageStatus;
+   };
+
+   /**
+    * Definition of command types passed to this device handler.
+   **/
+   enum commandType
+   {
+      CMD_STATUS_QUERY,       /**< Query device status. */
+      CMD_ENABLE,             /**< Start sending weight indications on weight change. */
+      CMD_DISABLE             /**< Stop sending weight indications on weight change. */
+   };
+
+   /**
+    * Definition of indication types received from this device handler.
+   **/
+   enum indicationType
+   {
+      IND_STATUS_INFO,                 /**< Current device status. */
+      IND_PIECE_WEIGHT                 /**< Weight of piece. */     
+   };
+
+   /**
+    * Scale DeviceComponent interface inherits the interface handler
+    * from the generic interface.
+   **/
+   interface Handler : DeviceComponents::Generic
+   {};
+};
+
+#endif
diff --git a/SelfServiceCommon/Massai/idl/Massai/atb2dev.idl b/SelfServiceCommon/Massai/idl/Massai/atb2dev.idl
new file mode 100644
index 00000000..7577785e
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Massai/atb2dev.idl
@@ -0,0 +1,169 @@
+//---------------------------------------------------------------------------
+//
+//  file:     atb2dev.idl
+//
+//  purpose:  basic definition for the massai ATB device component (internal)
+//
+//  date:     10.09.01
+//
+//  author:   (AGe/CMe/JKr)
+//
+//---------------------------------------------------------------------------
+
+#ifndef ATB2DEV_IDL
+#define ATB2DEV_IDL
+
+#ifdef USE_TAO_ORB_IDL
+   #ifdef _TAO_2_0_
+      #include "tao\orb.idl"
+   #endif
+#endif
+
+#include "mdci.idl"
+
+/** The pragma statement must be defined after the last include statement,
+ *  because some ORB implementations do not handle the scope correctly.
+ */
+#pragma prefix "DeviceComponents.massai.materna.com"
+
+/** MASSAI Device Component interface to a real ATB device driver.
+ *  @version 1.0
+ *  @author Carsten Metzler - Materna Information & Communications
+ */
+
+module atb2dev
+{
+
+    /** Definition of completion types returned by the device handler in the
+     *  indication status. The completion type reports the outcome of the last
+     *  command only. It is NOT a device status.
+     */
+
+    enum completionType
+    {
+      CMPL_COMPLETED,           /**< Command has been completed, no error. */
+      CMPL_CANCELLED,           /**< Command has been cancelled. */
+      CMPL_CANCEL_FAILED,       /**< Command could not be cancelled. */
+      CMPL_TIMEOUT,             /**< Timeout has expired. */
+      CMPL_ILLOGICAL,           /**< Command is out of sequence. */
+      CMPL_WRONG_FORMAT,        /**< Wrong format in command or coupon data. */
+      CMPL_MEDIA_OUT,           /**< Media out. */
+      CMPL_MEDIA_UNKNOWN,       /**< Media type is unknown. */
+      CMPL_ABORTED,             /**< Command has been aborted, e.g. coupon
+                                     has been ejected by the printer. */
+      CMPL_FAILED               /**< Execution of command has failed. */
+    };
+
+    /** Definition of error types returned by the device handler in the
+     *  indication status. The error type represents the current device status.
+     */
+
+    enum errorType
+    {
+      ERR_NONE,                 /**< No error. */
+      ERR_BUSY,                 /**< Device is busy. */
+      ERR_DISCONNECTED,         /**< Device is disconnected. */
+      ERR_HARDWARE,             /**< Hardware error. */
+      ERR_MEDIA_JAMMED,         /**< Media jam. */
+      ERR_RIBBON_OUT,           /**< Ribbon out. */
+      ERR_OFFLINE               /**< Device has been switched offline. */
+    };
+
+    /** Definition of media status types returned by the device handler in
+      * the indication status.
+      */
+
+    enum mediaStatusType
+    {
+      MEDIA_ABSENT,             /**< Media present in device. */
+      MEDIA_PRESENT             /**< Media not present in device. */
+    };
+
+    /** Defines the current status of a media stock. */
+
+    struct stockType
+    {
+      long            couponsProduced;      /**< Number of coupons beeing printed from this stock. */
+      mediaStatusType couponStatus;         /**< The current media status type of this stock. */
+    };
+
+    /** */
+
+    typedef sequence<stockType> stockList;
+
+    /** Defines the current device status. */
+
+    struct status
+    {
+      completionType  completionCode;       /**< The completion code of the last command. */
+      errorType       errorStatus;          /**< The current error status of the device. */
+      mediaStatusType printerMediaStatus;   /**< The current media status of the printer device. */
+      mediaStatusType escrowMediaStatus;    /**< The current media status of the escrow device. */
+      stockList       stockStatus;          /**< The current stock states. */
+      long            voidedCoupons;        /**> The current status of the voided bin. */
+    };
+
+    /** */
+
+    typedef sequence<string> nameList;
+
+    /** Defines the current device status. */
+
+    struct contexts
+    {
+      nameList        names;                /**< The current contexts names. */
+    };
+
+    /** Definition of command types passed to this device handler. */
+
+    enum commandType
+    {
+      CMD_CANCEL,               /**< Cancel last command. */
+      CMD_CONTEXT_SWITCH,       /**< Switch to (or create) ATB context.
+                                     Command data is the context name.
+                                     If no name is given, switch to global
+                                     context.*/
+      CMD_EJECT,                /**< Eject coupon. */
+      CMD_ESCROW_OPEN,          /**< Offer coupon with escrow to customer. */
+      CMD_ESCROW_RETRACT,       /**< Swallow coupon. */
+      CMD_PRINT,                /**< Send data to the printer. */
+      CMD_RESET,                /**< Reset device. */
+      CMD_SHUTTER_CLOSE,        /**< Close shutter. */
+      CMD_SHUTTER_OPEN,         /**< Open shutter. */
+      CMD_STATUS_QUERY,         /**< Query device status. */
+      CMD_STOCK_REFILLED,       /**< Assume a stock has been refilled. */
+      CMD_CONTEXT_DELETE,       /**< Delete one (or all) ATB context.
+                                     Command data is the context name.
+                                     If no name is given, delete all. */
+      CMD_CONTEXT_QUERY         /**< Report the ATB context list. */
+    };
+
+    /** Definition of indication types received from this device handler. */
+
+    enum indicationType
+    {
+      IND_CONTEXT_SWITCH_DONE,  /**< Context switch finished. */
+      IND_COUPON_INSERTED,      /**< Coupon has been inserted by customer. */
+      IND_COUPON_REMOVED,       /**< Coupon has been removed by customer. */
+      IND_EJECT_DONE,           /**< Eject coupon finished. */
+      IND_ESCROW_OPEN,          /**< Offer coupon finished. */
+      IND_ESCROW_RETRACT_DONE,  /**< Swallow coupon finished. */
+      IND_PRINT_DONE,           /**< Send data to printer finished. */
+      IND_RESET_DONE,           /**< Reset device finished. */
+      IND_SHUTTER_CLOSE_DONE,   /**< Close shutter finished. */
+      IND_SHUTTER_OPEN_DONE,    /**< Open shutter finished. */
+      IND_STATUS_INFO,          /**< Current device status. */
+      IND_STOCK_REFILLED_DONE,  /**< Assumed stock refilled. */
+      IND_POWER_SWITCH_REQUEST, /**< Request to switch power off and on again. */
+      IND_CONTEXT_DELETE_DONE,  /**< Context delete finished. */
+      IND_CONTEXT_INFO          /**< Currently available contexts. */
+    };
+
+    /** ATB DeviceComponent interface inherits from the generic interface. */
+
+    interface Handler : DeviceComponents::Generic
+    {
+    };
+};
+
+#endif // ATB2DEV_IDL
diff --git a/SelfServiceCommon/Massai/idl/Massai/display.idl b/SelfServiceCommon/Massai/idl/Massai/display.idl
new file mode 100644
index 00000000..1600ef94
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Massai/display.idl
@@ -0,0 +1,102 @@
+//---------------------------------------------------------------------------
+//
+//  file:     display.idl
+//
+//  purpose:  basic definition for the SHOCKWAVE display driver (internal)
+//
+//  date:     28.04.00
+//
+//  author:   (AGe)
+//
+//---------------------------------------------------------------------------
+
+#ifndef DISPLAY_IDL
+#define DISPLAY_IDL
+
+#pragma prefix "massai.materna.com"
+
+/** Definitions for the Display Shockwave XTRA.
+  * @author Andreas Gehling
+  * @version 1.0
+  * \date 25.09.2001 \li No changes - first complete documentation
+  */
+
+module mDisplay
+{
+    typedef sequence<octet> datastream;
+
+    /** Defintion of the indication to the application */
+
+    struct dspReturnTyp
+    {
+        string       sid;        /**< Display identifiers string */
+        long         languageId; /**< Current language used */
+        long         error;      /**< Error value from that screen */
+        long         lValue;     /**< A long data value from that screen */
+        string       sButton;    /**< The pressed button id as string */
+        string       strValue;   /**< A string value from that screen */
+    };
+
+    /** Defintion for the Shockwave parameters */
+
+    struct displayTyp
+    {
+        string   sid;            /**< Display identifiers string */
+        long     languageId;     /**< Current language used */
+        long     timeout;        /**< Timeout value for screen */
+
+        string   instructionId;  /**< Displayed instruction (optional) */
+        string   buttons;        /**< Buttons to display (list) */
+
+        string   strValue;       /**< Any string type to display (list) */
+    };
+
+    /** Listener interface for reporting indications from the XTRA to then application */
+
+    interface IndicationListener
+    {
+        /** This function is called when the user touches the screen
+            @param dr - Data from XTRA to application
+        */
+
+        void indication(in dspReturnTyp dr);
+    };
+
+    /** Interface implemented by the Shockwave XTRA */
+
+    interface Screen
+    {
+        /** Sets the indication listener which is called upon valid user input
+            @param il - Reference to the idication listener
+        */
+
+        void  setIndicationListener (in IndicationListener il);
+
+        /** Requests the next display/screen to be shown
+            @param dt - Parameters for the Shockwave applet
+        */
+
+        void  nextDisplay (in displayTyp dt);
+
+        /** Requests the next display/screen to be shown
+            @param ds - Parameters for the Shockwave applet as a zipped datastream from maps
+        */
+
+        void  nextDisplayDS (in datastream ds);
+
+        /** Requests the next display/screen to be shown
+            @param xml - Parameters for the Shockwave applet as a serialized xml document
+        */
+
+        void  nextDisplayXML (in string xml);
+
+        /** Requests the Shockwave applet to terminate */
+
+        void  done ();
+    };
+
+};
+
+#endif // DISPLAY_IDL
+
+
diff --git a/SelfServiceCommon/Massai/idl/Massai/doordev.idl b/SelfServiceCommon/Massai/idl/Massai/doordev.idl
new file mode 100644
index 00000000..9b73f684
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Massai/doordev.idl
@@ -0,0 +1,240 @@
+/**
+ **************************************************************************
+ *
+ * @file doordev.idl
+ *
+ * Contains module doordev, which is the platform-internal interface
+ * definition to test the common use gate's door device component.
+ *
+ * @version 1.4
+ *
+ * @author Sven Bornemann
+ *
+ **************************************************************************
+**/
+#ifndef DOORDEV_IDL
+#define DOORDEV_IDL
+
+#include "mdci.idl"
+
+#pragma prefix "massai.materna.com"
+
+/**
+ * Common Use Gate's Door Device Component
+ * (used e.g. for "Speed Boarding" or "Secure Access" gates)
+ */
+module doordev
+{
+
+    /** Possible return codes **/
+    enum RC
+    {
+        RC_OK,                          /**< Command processed successfully */
+        RC_ERROR                        /**< Command cannot be processed */
+    };
+
+    /** Definition of command types passed to this device handler */
+    enum commandType
+    {
+        CMD_CAPABILITIES_QUERY,         /**< Query door capabilities */
+        CMD_STATUS_QUERY,               /**< Query current door status */
+        CMD_DOOR_OPEN,                  /**< Opens the door */
+        CMD_DOOR_CLOSE,                 /**< Closes the door */
+        CMD_DOOR_LOCK,                  /**< Lock the door */
+        CMD_PANIC_OPEN,                 /**< Opens the door for panic situations */
+        CMD_PAX_PASS,                   /**< Passes one passager (opens door
+                                             and closes automatically after pax passed;
+                                             Depends on hardware, if supported) */
+        CMD_SET_LEDS,                   /**< LED control command, command.commandData contains setLedCommandList in that case */
+        CMD_SET_VALUE,                  /**< set device specific values */
+        CMD_GET_VALUE,                  /**< read device specific values */
+        CMD_BUZZER                      /**< trigger a signal of a specified length, command.commandData contains buzzerData*/
+    };
+
+    /** Definition of indication types received from door device */
+    enum indicationType
+    {
+        IND_CAPABILITIES_INFO,          /**< Door capabilities indication */
+        IND_STATUS_INFO,                /**< Door status indication */
+        IND_DOOR_OPEN_DONE,             /**< Door opened indication, see statusType for status */
+        IND_DOOR_CLOSE_DONE,            /**< Door closed indication, see statusType for status */
+        IND_DOOR_LOCK_DONE,             /**< Door locked indication, see statusType for status */
+        IND_PANIC_OPEN_DONE,            /**< Panic opened indication */
+        IND_PAX_PASS_DONE,              /**< Pax passed indicatiom, see statusType for status */
+        IND_SET_LEDS_DONE,
+        IND_SET_VALUE_DONE,             /**< Value set indication */
+        IND_GET_VALUE_DONE,             /**< Value get indication */
+        IND_BUTTON_INFO,                /**< button state changed, indication.indicationData contains buttonList with button states*/
+        IND_PAX_STATE                   /**< Pax was detected or leaved the gate, indication.indicationData contains paxStateList with pax states*/
+        // To be continued...
+    };
+
+    /**< Status of an indication */
+    enum statusType
+    {
+        STAT_OK,                        /**< Command successfully executed */
+        STAT_ERROR,                     /**< Generic error occurred during command execution */
+        STAT_ERROR_TIMEOUT,             /**< Timeout occurred during command execution */
+        STAT_NOT_PASSED                 /**< Passenger did no pass gate after CMD_PAX_PASS */
+    };
+
+    enum GATE_STAT
+    {
+        STAT_GT_OK,                  /* Gate is OK */
+        STAT_GT_ERROR,               /* Gate is in errored state */
+        STAT_GT_FRAUD,               /* Fraud detected */
+        STAT_GT_PANIC_OPEN,          /* Gate is in panic open/firealarm mode */
+        STAT_GT_DOOR_BLOCKED         /* Door is blocked*/
+    };
+    
+    enum DOOR_STAT
+    {
+        DOOR_UNKNOWN,             /* door state is unknown */
+        DOOR_OPEN,                /* door is open */
+        DOOR_CLOSE                /* door is closed */
+    };
+    
+    enum ERROR_TYPE
+    {
+        ERROR_NONE,               /* no error */
+        ERROR_DISCONNECTED,       /* disconnected */
+        ERROR_HW,                 /* general hardware failure */
+        ERROR_OOS,                /* out of service */
+        ERROR_PWR                 /* power failure */
+    };
+    
+    enum FRAUD_TYPE
+    {
+        FRAUD_NONE,                     /* no fraud pending */
+        FRAUD_UNKNOWN,                  /* no fraud information is available */
+        FRAUD_INTRUSION_ZONE_1,         /* The Zone 1 (Entry sensors) sensors have been obscured too long during the validation process */
+        FRAUD_INTRUSION_ZONE_2,         /* The Zone 1 (Entry sensors) sensors have been obscured too long during the validation process */
+        FRAUD_INTRUSION_BLOCKED_AISLE,  /* A person entered the blocked side */
+        FRAUD_INTRUSION_LONG_TRANSIT,   /* A person took too much time to end the transit */
+        FRAUD_TAIL_GATING,              /* Tail gating has been detected */
+        FRAUD_WRONG_WAY                 /* Wrong Way has been detected */
+    };
+    
+    enum BUTTON_TYPE
+    {
+        BUTTON_NONE,
+        BUTTON_RESET,
+        BUTTON_FIREALARM,
+        BUTTON_ND2,
+        BUTTON_ND3
+    };
+    
+    /**< List of pressed buttons */
+    typedef sequence<BUTTON_TYPE> buttonList;
+
+    /**< hardware status of the gate */
+    struct hwStatusType
+    {
+        GATE_STAT      gate_state;
+        ERROR_TYPE     error;
+        DOOR_STAT      door_state;
+        FRAUD_TYPE     fraud;
+    };
+    
+    /**< Door device capabilities */
+    enum capabilityType
+    {
+        CAP_DOOR_CONTROL,               /**< Door open/close can explicitly being controlled  */
+        CAP_PAX_PASS,                   /**< Door opens/closes automtically when an pax passes */
+        CAP_DOOR_LOCK,                  /**< Door can be locked */
+        CAP_PASS_TIMEOUT,               /**< A value "PASS_TIMEOUT" may be read/set */
+        CAP_AUDIBLE_ALARM_LENGTH,       /**< A value "AUDIBLE_ALARM_LENGTH" may be read/set */
+        CAP_BLOCKED_DETECT_TIMEOUT,     /**< A value "BLOCKED_DETECT_TIMEOUT" may be read/set */
+        CAP_NEPLITE_HARDWARE_VERSION    /**< A value "NEPLITE_HARDWARE_VERSION" may be read/set */
+        //CAP_PASS_COMPLETE_TIMEOUT     /**< A value "PASS_COMPLETE_TIMEOUT" may be read/set */
+        // To be continued...
+    };
+
+    /**< Door LED states */
+    enum ledState
+    {
+        STATE_OFF,            /**< Switch off LED  */
+        STATE_ON,             /**< Switch on LED  */
+        STATE_GREEN,          /**< Switch on LED - green */
+        STATE_RED,            /**< Switch on LED - red */
+        STATE_GREEN_FLASH,    /**< Switch on LED - green flashing*/
+        STATE_RED_FLASH       /**< Switch on LED - red flashing*/
+    };
+
+    /**< Pax status information */
+    enum PAXSTATE_TYPE
+    {
+        PAXSTATE_NONE,                /**< no pax is detected in the gate*/
+        PAXSTATE_UNKNOWN,             /**< pax information is not available*/
+        PAXSTATE_SIDEA,               /**< pax is detected at side a*/
+        PAXSTATE_SIDEB,               /**< pax is detected at side b*/
+        PAXSTATE_MIDDLE,              /**< pax is detected in the middle of the gate*/
+        PAXSTATE_PRESENT              /**< pax is detected anywhere in the gate*/
+    };
+ 
+    /**< List of detected paxes */
+    typedef sequence<PAXSTATE_TYPE> paxStateList;
+
+    /**< List of capabilityType */
+    typedef sequence<capabilityType> capabilityList;
+
+    /**< Command to door device */
+    struct setLedCommand
+    {
+        long            led;      /**< 0 based LED index (front 0...back n) */
+        ledState        state;    /**< LED state  */
+    };
+
+    /**< List of setLedCommand, used as commandData in case of type == CMD_SET_LEDS */
+    typedef sequence<setLedCommand> setLedCommandList;
+
+    /**< Used as parameter/result for CMD_SET_VALUE,CMD_GET_VALUE Commands to door device */
+    struct valueData
+    {
+        string          name;     /**< value name */
+        string          data;     /**< value  */
+    };
+
+    /**< Used as parameter for the CMD_BUZZER Command to door device */
+    struct buzzerData
+    {
+        long            length;       /**< length of the signal in ms */
+        long            volume;       /**< volume 0-255 (device dependent, not used with Gunnebo Gate) */
+        long            tone;         /**< frequency or tone type (device dependent, not used with Gunnebo Gate) */
+        long            repetition;   /**< repeat signal n times (device dependent, not used with Gunnebo Gate) */
+    };
+    
+    /**< Command to door device */
+    struct command
+    {
+        long            requestID;      /**< A unique request identifier */
+        commandType     type;           /**< One of the above defined command types */
+        any             commandData;    /**< Optional data required for the command */
+    };
+
+    /**< Indication from door device */
+    struct indication
+    {
+        long            requestID;      /**< A unique indication identifier */
+        indicationType  type;           /**< One of the above defined indication types */
+        statusType      status;         /**< One of the above defined status types */
+        hwStatusType    hw_status;      /**< Full information about the hardware state */
+        any             indicationData; /**< Optional data of the indication,
+                                             e.g. capabilityList of IND_CAPABILITIES_INFO */
+    };
+
+   /**< Door device interface */
+   interface Handler : DeviceComponents::Generic
+   {
+   };
+
+};
+
+#endif // DOORDEV_IDL
+/**
+ **************************************************************************
+ *
+ * End of file.
+ *
+ **************************************************************************
+**/
diff --git a/SelfServiceCommon/Massai/idl/Massai/gmdev.idl b/SelfServiceCommon/Massai/idl/Massai/gmdev.idl
new file mode 100644
index 00000000..8f268b61
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Massai/gmdev.idl
@@ -0,0 +1,62 @@
+/**
+ **************************************************************************
+ *
+ * @file gmdev.idl
+ *
+ * Contains module gmdev, which is the platform-internal interface
+ * definition for generic massai multi device components.
+ *
+ * @version 1.0
+ *
+ * @author Nicolas Bruns
+ *
+ **************************************************************************
+**/
+#ifndef GMDEV
+#define GMDEV
+
+#include "mdci.idl"
+
+/**
+ * The pragma statement must be defined after the last include statement,
+ * because some ORB implementations do not handle the scope correctly.
+**/
+#pragma prefix "DeviceComponents.massai.materna.com"
+
+
+
+/**
+ *
+ * Generic MASSAI Device Component interface module for multi reader devices
+ *
+**/
+module multidevices
+{
+  /**
+   *  The component type definition. TODO: to be completed!!!
+   */
+  enum compType
+  {
+    ALL,        /**< All components */
+    OCR,        /**< Optical character recognition */
+    BCR,        /**< Barcode reader */
+    PPR,        /**< Passport reader */
+    MCR,        /**< Magneticcard reader */
+    ATBR,       /**< ATB reader */
+    IMG,        /**< Image scanner */
+    RFID,       /**< Radio frequency identification */
+    FPR,        /**< Finger print reader */
+    HAR,        /**< Hand reader */
+    WSL,        /**< Weight scale */
+    ISC,        /**< Iris scanner */
+    RSC,        /**< Retina scanner */
+    CCR,        /**< Chip card reader */
+    DISPENSER,  /**< Dispenser */
+    CAPTURE,    /**< Capture */
+    IDCR,       /**< ID Card Reader */
+    DLR					/**< Driver license Reader */
+  };
+
+};
+
+#endif // GMDEV
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/idl/Massai/gmrdev.idl b/SelfServiceCommon/Massai/idl/Massai/gmrdev.idl
new file mode 100644
index 00000000..b8d02387
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Massai/gmrdev.idl
@@ -0,0 +1,316 @@
+/**
+ **************************************************************************
+ *
+ * @file gmrdev.idl
+ *
+ * Contains module gmrdev, which is the platform-internal interface
+ * definition for generic massai multi reader device components.
+ *
+ * @version 1.1
+ *
+ * @author Nicolas Bruns
+ *
+ **************************************************************************
+**/
+#ifndef GMRDEV
+#define GMRDEV
+
+#ifdef USE_TAO_ORB_IDL
+   #ifdef _TAO_2_0_
+      #include "tao\orb.idl"
+   #endif
+#endif
+
+#include "gmdev.idl"
+
+
+
+/**
+ * The pragma statement must be defined after the last include statement,
+ * because some ORB implementations do not handle the scope correctly.
+**/
+#pragma prefix "multidevices.DeviceComponents.massai.materna.com"
+
+
+
+/**
+ *
+ * Generic MASSAI Device Component interface module for multi reader devices
+ *
+**/
+module gmrdev
+{
+  
+  /**
+   *  Data for component depending commands
+   */
+  struct multiCompCmdData
+  {
+    multidevices::compType  comp; /**< a component type */
+    any                     data; /**< command data */
+  };
+
+
+  enum dataType 
+  {
+    DT_UNKNOWN,
+    DT_CODE39,
+    DT_TELEPEN,
+    DT_ISBT,
+    DT_CODE128,
+    DT_UPCE0,
+    DT_EAN13,
+    DT_UPCA,
+    DT_COUPONCODE,
+    DT_EAN8,
+    DT_CODABAR,
+    DT_CODE93,
+    DT_CODE11,
+    DT_INT25,
+    DT_CODE16K,
+    DT_TLCODE39,
+    DT_MICROPDF,
+    DT_PDF417,           /* PDF417 2D barcode */
+    DT_MSI,
+    DT_CODABLOCK,
+    DT_PLESSEY,
+    DT_QR,               /* QR Code 2D barcode */
+    DT_IATA25,
+    DT_STRT25,
+    DT_CODE49,
+    DT_MAXICODE,
+    DT_BPO,
+    DT_CHINAPOST,
+    DT_CODE32,
+    DT_PLANET,
+    DT_MATRIX25,
+    DT_CANPOST,
+    DT_AUSPOST,
+    DT_POSTNET,
+    DT_KORPOST,
+    DT_JAPOST,
+    DT_DUTCHPOST,
+    DT_TRIOPTIC,
+    DT_UPCE1,
+    DT_DATAMATRIX,        /* Datamatrix 2D barcode */
+    DT_RSS,
+    DT_COMPOSITE,
+    DT_OCR,
+    DT_POSICODE,
+    DT_AZTEC,             /* Aztec 2D barcode */
+    DT_MESA,   
+    DT_BMP_IR,            /* Infrared image */
+    DT_BMP_VIS,           /* Visible image */
+    DT_BMP_UV,            /* Ultraviolet image */
+    DT_BMP_PHOTO,         /* Photo image */
+    DT_BMP_COAX,          /* Coaxial image */
+    DT_JPG_IR,            /* Infrared image */
+    DT_JPG_VIS,           /* Visible image */
+    DT_JPG_UV,            /* Ultraviolet image */
+    DT_JPG_PHOTO,         /* Photo image */
+    DT_JPG_COAX,          /* Coaxial image */
+    DT_CODELINE,          /* Codeline data */
+    DT_BARCODE,           /* Barcode data */
+    DT_JIS2,              /* JIS2 data */
+    DT_ISO7816,           /* communication protocols for PICC/RFID/NFC devices */
+    DT_MIFARE,            /* communication protocols for PICC/RFID/NFC devices */
+    DT_EPASSPORT_DG1,     /* e-Passport format */
+    DT_EPASSPORT_DG2,     /* e-Passport format */
+    DT_EPASSPORT_DG3,     /* e-Passport format */
+    DT_EPASSPORT_DG4,     /* e-Passport format */
+    DT_EPASSPORT_DG5,     /* e-Passport format */
+    DT_EPASSPORT_DG6,     /* e-Passport format */
+    DT_EPASSPORT_DG7,     /* e-Passport format */
+    DT_EPASSPORT_DG8,     /* e-Passport format */
+    DT_EPASSPORT_DG9,     /* e-Passport format */
+    DT_EPASSPORT_DG10,    /* e-Passport format */
+    DT_EPASSPORT_DG11,    /* e-Passport format */
+    DT_EPASSPORT_DG12,    /* e-Passport format */
+    DT_EPASSPORT_DG13,    /* e-Passport format */
+    DT_EPASSPORT_DG14,    /* e-Passport format */
+    DT_EPASSPORT_DG15,    /* e-Passport format */
+    DT_EPASSPORT_DG16,    /* e-Passport format */
+    DT_EPASSPORT_DG17,    /* e-Passport format */
+    DT_EPASSPORT_DG18,    /* e-Passport format */
+    DT_EPASSPORT_DG19,    /* e-Passport format */
+    DT_EPASSPORT_DG20,    /* e-Passport format */
+    DT_VALIDATION_STATUS, /* support dataStatus SECURITY_FAILED, ALTERED, MISMATCH */
+    DT_FOID_ISO,           /* ISO track data with FOID Data truncation */
+    DT_PAYMENT_ISO,        /* ISO track data without truncation */
+    DT_DISCRETIONARY_ISO,  /* ISO track data with DISCRETIONARY Data truncation */
+    DT_FOID_JIS2,          /* JIS-2 track data with FOID Data truncation */
+    DT_PAYMENT_JIS2,       /* JIS-2 track data without truncation */
+    DT_DISCRETIONARY_JIS2  /* JIS-2 track data with DISCRETIONARY Data truncation */   
+  };
+
+  /**
+   *  The data status
+   */
+  enum dataStatus
+  {
+    OK,
+    ZERO_LENGTH,
+    CORRUPTED,
+    SECURITY_FAILED,
+    ALTERED,
+    MISMATCH
+  };
+
+  typedef sequence<multidevices::compType> compTypeList;
+  typedef sequence<dataType> dataTypeList;
+  typedef sequence<octet> octetList;
+
+  /**
+   *  The device functionality
+   */
+  struct devFunctionality
+  {
+    compTypeList types; /**< a sequence of components */
+  };
+
+  /**
+   *  The components data types
+   */
+  struct compDataType
+  {
+    multidevices::compType type;       /**< A component type */
+    dataTypeList types;           /**< a sequence of data types */
+  };
+
+  typedef sequence<compDataType> compDataTypeList_;
+
+  /**
+   *  The data types of a list of components
+   */
+  struct compDataTypeList
+  {
+    compDataTypeList_ dataTypes; /**< a sequence of data types */
+  };
+  
+
+
+  /**
+   *  The data type definition for tracks.
+   */
+  struct dataTrack
+  {
+    dataStatus      ds;         /**< a data status */
+    dataType        dt;         /**< a data type */
+    octetList       data;       /**< a data stream */
+  };
+
+  typedef sequence<dataTrack> dataTrackList;
+
+  /**
+   *  The data type definition for reader messages.
+   */
+  struct readerDataType
+  {
+    multidevices::compType  type;       /**< A component type */
+    dataTrackList           tracks;     /**< A list of data scanner tracks */
+  };
+
+
+
+  /**
+   *
+   * Definition of completion types returned by the device handler in the
+   * indication status. The completion type only describes the outcome of
+   * the last command and is not a device status.
+   *
+  **/
+  enum completionType
+  {
+    CMPL_COMPLETED,           /**< Command has been completed, no error */
+    CMPL_CANCELLED,           /**< Command has been cancelled */
+    CMPL_CANCEL_FAILED,       /**< Command could not be cancelled successfully */
+    CMPL_ILLOGICAL,           /**< Command is out of sequence */
+    CMPL_WRONG_FORMAT,        /**< Wrong format in command data */
+    CMPL_FAILED               /**< Execution of command has failed */
+  };
+
+  /** Definition of error types returned by the device handler in the indication status.
+   *  The error type represents the current device status.
+   */
+  enum errorType
+  {
+    ERR_NONE,             /**< No error */
+    ERR_BUSY,             /**< Device is busy */
+    ERR_DISCONNECTED,     /**< Device is disconnected */
+    ERR_HARDWARE,         /**< Hardware error */
+    ERR_CONFIGURATION,    /**< Configuration error */
+    ERR_MEDIA_JAMMED      /**< Media jammed */
+  };
+
+  /** Definition of media status types returned by the device handler in the indication status. */
+  enum mediaStatusType
+  {
+    MEDIA_ABSENT,         /**< Media present in device */
+    MEDIA_PRESENT,        /**< Media not present in device */
+    MEDIA_UNKNOWN,        /**< Media unknown */
+    MEDIA_MISPLACED       /**< Media misplaced */
+  };
+
+  /** Defines the current component status. */
+  struct compStatus
+  {
+    multidevices::compType  componentType;    /**< The component type */
+    completionType          completionCode;   /**< The completion code of the last command (component) */
+    errorType               errorStatus;      /**< The current error status of the component */
+    mediaStatusType         mediaStatus;      /**< The current media status of the component */
+  };
+
+  typedef sequence<compStatus> compStatusList;
+
+  /** Defines the current reader status. */
+  struct status
+  {
+    compStatusList statusMessage; /**< sequence of component status */
+  };
+
+  /** Definition of command types passed to this device handler. */
+
+  enum commandType
+  {
+    CMD_CANCEL,                 /**< Cancel last command (component) */
+    CMD_CONTEXT_SWITCH,         /**< Switch context (device) */
+    CMD_SETUP,                  /**< Setup a reader component */
+    CMD_RESET,                  /**< Reset device */
+    CMD_ENABLE,                 /**< Enable a reader component */
+    CMD_DISABLE,                /**< Disable a reader component */
+    CMD_STATUS_QUERY,           /**< Query a component status */
+    CMD_TEST,                   /**< Test device driver */
+    CMD_COMPS_QUERY,            /**< Query device types */
+    CMD_EJECT,                  /**< Eject media (dispenser) */
+    CMD_RETRACT,                /**< Retract media (capture) */
+    CMD_QUERY_DATA_TYPE,        /**< Query supported data type of a component */
+    CMD_SELECT_DATA_TYPE        /**< Set supported data types */
+  };
+
+  /** Definition of indication types received from this device handler. */
+
+  enum indicationType
+  {
+    IND_CONTEXT_SWITCH_DONE,    /**< Context switch finished (component/device) */
+    IND_DATA,                   /**< Data is available (component) */
+    IND_RESET_DONE,             /**< Reset device finished (component/device) */
+    IND_ENABLE_DONE,            /**< Enable component finished*/
+    IND_DISABLE_DONE,           /**< Disable component finished */
+    IND_STATUS_INFO,            /**< Current component/device status */
+    IND_COMPS_INFO,             /**< Device functionality */
+    IND_SETUP_DONE,             /**< Setup component has finished */
+    IND_POWER_SWITCH_REQUEST,   /**< Request to switch Power off and on again (device) */
+    IND_EJECT_DONE,             /**< Eject media has finished */
+    IND_RETRACT_DONE,           /**< Retract media has finished */
+    IND_TEST_DONE,              /**< Test has finished */
+    IND_QUERY_DATA_TYPE_DONE,   /**< Return the supported data type */
+    IND_SELECT_DATA_TYPE_DONE   /**< data type selected */
+  };
+
+  /** scanner dev interface inherits from the generic interface. */
+  interface Handler : DeviceComponents::Generic
+  {
+  };
+};
+
+#endif // GMRDEV
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/idl/Massai/gppdev.idl b/SelfServiceCommon/Massai/idl/Massai/gppdev.idl
new file mode 100644
index 00000000..ef967815
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Massai/gppdev.idl
@@ -0,0 +1,161 @@
+//---------------------------------------------------------------------------
+//
+//  file:     gppdev.idl
+//
+//  purpose:  basic definition for the massai general purpose printer (internal)
+//
+//  date:     09.11.00
+//
+//  author:   (CMe)
+//
+//---------------------------------------------------------------------------
+
+#ifndef GPPDEV_IDL
+#define GPPDEV_IDL
+
+#include "mdci.idl"
+
+#pragma prefix "DeviceComponents.massai.materna.com"
+
+/**
+ *  MASSAI general purpose printer
+ *
+ *  @author <b><a href="mailto:carsten.metzler@materna.de">Carsten Metzler (CMe), Materna Information & Communications</a></b>
+ *
+ *  @version 0.1
+ * <P>
+ *  Real component interface defintion for a general purpose printer.
+ */
+
+module gppdev
+{
+
+    /** Media types */
+    enum mediaType
+    {
+	  AnyType,
+      Ticket,                 /**< TAT- or ATB ticket */ 
+      BoardingPass,           /**< Boarding pass */
+      GeneralPurposeDoc,      /**< General purpose document */ 
+      BaggageTag,             /**< Baggage tag */ 
+      BoardingPassFirst,      /**< ATB1 or ATB2 boarding passes for first Class */
+      BoardingPassBusiness,   /**< ATB1 or ATB2 boarding passes for business class*/
+      BoardingPassEconomy     /**< ATB1 or ATB2 boarding passes for economy class*/
+    };
+
+    /** Definition of completion types returned by the device handler in the indication status.
+     *  The completion type only belongs to the last command and is not a device status.
+     */
+
+    enum completionType
+    {
+      CMPL_COMPLETED,           /**< Command has been completed, no error */
+      CMPL_CANCELLED,           /**< Command has been cancelled */
+      CMPL_CANCEL_FAILED,       /**< Command could not be cancelled successfully */
+      CMPL_TIMEOUT,             /**< Timeout has been expired */
+      CMPL_ILLOGICAL,           /**< Command is out of sequence */
+      CMPL_ABORTED,             /**< Command has been aborted, e.g. coupon has been ejected by printer */
+      CMPL_FAILED               /**< Execution of command has failed */
+    };
+
+    
+    /** Definition of error types returned by the device handler in the indication status.
+     *  The error type represents the current device status.
+     */
+
+    enum errorType
+    {
+      ERR_NONE,                 /**< No error */
+      ERR_BUSY,                 /**< Device is busy */
+      ERR_DISCONNECTED,         /**< Device is disconnected */
+      ERR_HARDWARE,             /**< Hardware error */
+      ERR_MEDIA_JAMMED,         /**< Media Jam*/
+      ERR_RIBBON_OUT,           /**< Ribbon out */
+      ERR_OFFLINE,              /**< Device has been switched offline */
+      ERR_PAPER_OUT,            /**< Paper out */
+      ERR_WRONG_FORMAT,         /**< Wrong format in command or coupon data */
+      ERR_OPEN                  /**< Device is open for service purpose */
+    };
+
+
+    /** Definition of media status types returned by the device handler in the indication status. */
+
+    enum mediaStatusType
+    {
+      MEDIA_LOW,  /**< Media status is low (optional) */
+      MEDIA_ABSENT,             /**< Media present in device */
+      MEDIA_PRESENT             /**< Media not present in device */
+    };
+
+
+    /** Defines the current status of a media stock. */
+
+    struct stockType
+    {
+      long            couponsProduced;      /**< Number of coupons beeing printed from this stock */
+      mediaStatusType couponStatus;         /**< The current media status type of this stock */
+    };
+    
+    typedef sequence<stockType> stockList;
+    
+    struct statusOfMultipleStockPrinter
+    {
+      mediaType type;
+      completionType  completionCode;       /**< The completion code of the last command */
+      errorType       errorStatus;          /**< The current error status of the device */
+      mediaStatusType printerMediaStatus;   /**< The current media status of the printer device */
+      stockList       stockStatus;          /**< The current stock states */
+    };
+
+    enum commandType
+    {
+      CMD_CANCEL,           /**< Cancel last command */
+      CMD_PRINT,            /**< Send coupon data to the printer */
+      CMD_SETUP,            /**< Send setup data to the printer */
+      CMD_STATUS_QUERY,     /**< Query device status */
+      CMD_CONTEXT_SWITCH,   /**< Switch GPP context */
+      CMD_RESET,            /**< Reset device */
+      CMD_STOCK_REFILLED    /**< Assume a stock has been refilled */
+    };
+
+    enum printOrientation
+    {
+      orientationUndefined,   /**< Non applicable characteristic value */
+      orientationPortrait,    /**< printing orientation */
+      orientationLandscape    /**< printing orientation */
+    };
+    struct extendendPrintData
+    {
+      printOrientation orientation;
+      any data; /**< the command data, e.g. an AEA data stream */
+    };
+    struct gppCommandData
+    {
+      mediaType type;
+      any data; /**< the command data, e.g. extendendPrintData */
+    };
+
+
+    /** Definition of indication types received from this device handler. */
+
+    enum indicationType
+    {
+      IND_PRINT_DONE,           /**< Send coupon data to printer finished */
+      IND_SETUP_DONE,           /**< Send setup data to printer finished */
+      IND_STATUS_INFO,          /**< Current device status */
+      IND_CONTEXT_SWITCH_DONE,  /**< Context switch finished */
+      IND_RESET_DONE,           /**< Reset device finished */
+      IND_STOCK_REFILLED_DONE,  /**< Assumed stock refilled */
+      IND_RESTART,              /**< Printer request for a restart (power down/up) */
+      IND_DOCUMENT_REMOVED,     /**< Coupon has been removed by customer */
+      IND_POWER_SWITCH_REQUEST  /**< Request to switch Power off and on again (device) */
+    };
+
+    // derive all device components from the basic interface
+
+    interface Handler : DeviceComponents::Generic
+    {
+    };
+};
+
+#endif // GPPDEV_IDL
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/idl/Massai/icntc.idl b/SelfServiceCommon/Massai/idl/Massai/icntc.idl
new file mode 100644
index 00000000..a00bc9bf
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Massai/icntc.idl
@@ -0,0 +1,87 @@
+//---------------------------------------------------------------------------
+//
+//  file:     icntc.idl
+//
+//  purpose:  interface to the ICN tunnel client
+//
+//  date:     21.05.2003
+//
+//  author:   (BrN)
+//
+//---------------------------------------------------------------------------
+
+#ifndef ICNTC_IDL
+#define ICNTC_IDL
+
+#pragma prefix "materna.com"
+
+/** Interface defintions between the kiosk proxy and the ICN tunnel client */
+
+module icnTunnelClient
+{
+    
+    
+    /** Completion codes for the open command */
+    
+        enum completionCode
+        {
+            OK,         	/**<  */
+            ALREADY_CONNECTED,  /**<  */
+            NO_CONNECTION,   	/**<  */
+            ALREADY_CLOSED	/**<  */
+    };
+    
+    
+    
+    /** Interface that is implemented by the proxy on the kiosk */
+
+    interface KioskProxyListener
+    {
+        /** Used to inform the proxy about the closing of the tunnel to the specified ABLS 
+            @param ipABLS - The ip of the ABLS
+        */
+
+        void tunnelClosed (in string ipABLS);
+
+    };
+
+    
+
+    /** Interface that is implemented by the ICN tunnel client */
+
+    interface ICNTunnelClient
+    {
+        
+        /** Register a listener from the kiosk proxy.
+            @param li - The listener interface to register
+        */
+
+        long setListener (in KioskProxyListener li, in string appID);
+
+        /** Unregister a listener from the kiosk proxy.
+            @param li - The listener interface to unregister
+        */
+
+        long rmvListener (in KioskProxyListener li, in string appID);
+
+        /** The kiosk proxy uses this call to check whether there is a tunnel opened
+            to the specified ABLS
+            
+            @param ipABLS - The ip of the ABLS
+            @return	true if open; false otherwise
+        */
+
+        boolean isOpen (in string ipABLS, in string appID);
+
+        /** Opens a new tunnel to the specified ABLS
+        
+            @param ipABLS - The ip of the ABLS
+        */
+
+        long open (in string ipABLS, in string appID);
+        
+        long close (in string ipABLS, in string appID);
+    };
+};
+
+#endif // ICNTC_IDL
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/idl/Massai/magcarddev.idl b/SelfServiceCommon/Massai/idl/Massai/magcarddev.idl
new file mode 100644
index 00000000..b31dc2b5
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Massai/magcarddev.idl
@@ -0,0 +1,158 @@
+//---------------------------------------------------------------------------
+//
+//  file:     magcarddev.idl
+//
+//  purpose:  basic definition for the massai Magnetic Card Reader device (internal)
+//
+//  date:     10.09.01
+//
+//  author:   (CMe)
+//
+//---------------------------------------------------------------------------
+
+#ifndef MAGCARDDEV_IDL
+#define MAGCARDDEV_IDL
+
+#ifdef USE_TAO_ORB_IDL
+   #ifdef _TAO_2_0_
+      #include "tao\orb.idl"
+   #endif
+#endif
+
+#include "mdci.idl"
+
+#pragma prefix "DeviceComponents.massai.materna.com"
+
+/** MASSAI Device Component interface to a real magnetic card reader device driver.
+ *  @version 1.0
+ *  @author Carsten Metzler - Materna Information & Communications
+ */
+
+module magcarddev
+{
+    /** Defines the structure of track data. */
+    typedef sequence<octet> octestList;
+    
+    struct track
+    {
+      long            dataLength;   /**< The data length */
+      octestList      trackData;    /**< The data of the track */
+    };
+
+    const long TRACK1 = 1;  /**< Set in cardData.tracksAvailable when track 1 is available */
+    const long TRACK2 = 2;  /**< Set in cardData.tracksAvailable when track 2 is available */
+    const long TRACK3 = 4;  /**< Set in cardData.tracksAvailable when track 3 is available */
+
+    /** Data type for card data messages. */
+    
+    struct cardData
+    {
+      long    tracksAvailable;  /**< The number of available tracks */
+      track   track1;       /**< Data of track 1 */
+      track   track2;       /**< Data of track 2 */
+      track   track3;       /**< Data of track 3 */
+    };
+
+    /** Defines, which tracks should be read. */
+    
+    struct tracksToRead
+    {
+      octet   tracks;   /**< The bits of this byte indicate which tracks should be read */
+    };
+
+    /** Definition of card types */
+    
+    enum cardType
+    {
+      MAG_STRIPE,   /**< Card with mag stripe */
+      NO_MAG_STRIPE /**< Card without mag stripe */
+    };
+
+    /** Definition of completion types returned by the device handler in the indication status.
+     *  The completion type only belongs to the last command and is not a device status.
+     */
+     
+    enum completionType
+    {
+      CMPL_COMPLETED,       /**< Command has been completed, no error */
+      CMPL_CANCELLED,       /**< Command has been cancelled */
+      CMPL_CANCEL_FAILED,   /**< Command could not be cancelled successfully */
+      CMPL_TIMEOUT,     /**< Timeout has been expired */
+      CMPL_ILLOGICAL,       /**< Command is out of sequence */      
+      CMPL_READ_ERROR,      /**< Card cannot be read */
+      CMPL_WRONG_FORMAT,    /**< Wrong format in command or card data */
+      CMPL_FAILED       /**< Execution of command has failed */
+    };              
+
+    /** Definition of error types returned by the device handler in the indication status.
+     *  The error type represents the current device status.
+     */
+     
+    enum errorType
+    {
+      ERR_NONE,         /**< No error */
+      ERR_BUSY,         /**< Device is busy */      
+      ERR_DISCONNECTED,     /**< Device is disconnected */
+      ERR_HARDWARE,     /**< Hardware error */
+      ERR_MEDIA_JAMMED      /**< Media Jam*/
+    };
+
+    /** Definition of media status types returned by the device handler in the indication status. */
+    
+    enum mediaStatusType
+    {
+      MEDIA_ABSENT,     /**< Media present in device */
+      MEDIA_PRESENT,        /**< Media not present in device */
+      MEDIA_UNKNOWN     /**< Media unknown */
+    };
+
+    /** Defines the current device status. */
+    
+    struct status
+    {
+      completionType  completionCode;   /**< The completion code of the last command */
+      errorType       errorStatus;  /**< The current error status of the device */
+      mediaStatusType mediaStatus;  /**< The current media status of the device */
+    };
+
+    /** Definition of command types passed to this device handler. */
+    
+    enum commandType
+    {
+      CMD_CANCEL,       /**< Cancel last command */
+      CMD_CLOSE,        /**< Close shutter */
+      CMD_EJECT,        /**< Offer card to customer */
+      CMD_OPEN,         /**< Open shutter */
+      CMD_RESET,        /**< Reset device */
+      CMD_RETRACT,      /**< Swallow card */
+      CMD_READ,         /**< Read card */
+      CMD_STATUS_QUERY,     /**< Query device status */
+      CMD_WRITE,         /**< Write data on card */
+      CMD_PING		/**< Test Listener */  
+    };
+
+    /** Definition of indication types received from this device handler. */
+    
+    enum indicationType
+    {
+      IND_CARD_INSERTED,    /**< Card has been inserted by customer */
+      IND_CARD_TAKEN,       /**< Card has been taken by customer */
+      IND_CLOSE_DONE,       /**< Close shutter finished */
+      IND_EJECT,        /**< Offer card finished */
+      IND_OPEN_DONE,        /**< Open shutter finished */
+      IND_RESET_DONE,       /**< Reset device finished */
+      IND_RETRACT_DONE,     /**< Swallow card finished */
+      IND_READ_DONE,        /**< Read card finished */
+      IND_STATUS_INFO,      /**< Current device status */
+      IND_WRITE_DONE,       /**< Write data finished */
+      IND_POWER_SWITCH_REQUEST  /**< Request to switch Power off and on again */
+    };
+
+    /** MagCard DeviceComponent interface inherits from the generic interface. */
+
+    interface Handler : DeviceComponents::Generic
+    {
+    };
+};
+
+#endif // MAGCARDDEV_IDL
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/idl/Massai/makefile.mak b/SelfServiceCommon/Massai/idl/Massai/makefile.mak
index 915ccc3a..06686d7f 100644
--- a/SelfServiceCommon/Massai/idl/Massai/makefile.mak
+++ b/SelfServiceCommon/Massai/idl/Massai/makefile.mak
@@ -20,6 +20,22 @@ MY_GEN_CPPS = \
     $(_GEN)\BillingService.cpp \
     $(_GEN)\MailService.cpp \
     $(_GEN)\StatisticsService.cpp \
-    $(_GEN)\SecureLoggingService.cpp
+    $(_GEN)\SecureLoggingService.cpp \
+    $(_GEN)\atb2dev.cpp \
+    $(_GEN)\BarCodeScannerDev.cpp \
+    $(_GEN)\ConveyorDev.cpp \
+    $(_GEN)\DeviceTest.cpp \
+    $(_GEN)\display.cpp \
+    $(_GEN)\gmdev.cpp \
+    $(_GEN)\gmrdev.cpp \
+    $(_GEN)\gppdev.cpp \
+    $(_GEN)\icntc.cpp \
+    $(_GEN)\magcarddev.cpp \
+    $(_GEN)\PassportReaderDev.cpp \
+    $(_GEN)\platform.cpp \
+    $(_GEN)\ScaleDev.cpp \
+    $(_GEN)\screendev.cpp \
+    $(_GEN)\seldev.cpp \
+    $(_GEN)\doordev.cpp
 
 !include $(BUILDROOT)\Build\cpp\makefile.rules.mak
diff --git a/SelfServiceCommon/Massai/idl/Massai/platform.idl b/SelfServiceCommon/Massai/idl/Massai/platform.idl
new file mode 100644
index 00000000..26d94efb
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Massai/platform.idl
@@ -0,0 +1,288 @@
+//---------------------------------------------------------------------------
+//
+//  file:     platform.idl
+//
+//  purpose:  basic definition for the massai platform (internal)
+//
+//  date:     10.09.01
+//
+//  author:   (CMe)
+//
+//---------------------------------------------------------------------------
+
+#ifndef PLATFORM_IDL
+#define PLATFORM_IDL
+
+#ifdef USE_TAO_ORB_IDL
+   #ifdef _TAO_2_0_
+      #include "tao\orb.idl"
+   #endif
+#endif
+
+#pragma prefix "massai.materna.com"
+
+/** This module provides interfaces for the platform internal communication between
+ *  the platform management and the device components.
+ *  @version 1.2
+ *  @author Carsten Metzler - Materna Information & Communications
+ */
+
+module PlatformManagement
+{
+    /** Data type for text lists. */
+
+    typedef sequence<string> list;
+
+    /** Returncodes returned by the servant. */
+
+    enum code
+    {
+        RC_OK,            /**< Function has been executed correctly */
+        RC_UNKNOWN,         /**< Unknown, if function has been executed correctly */
+        RC_ERROR            /**< Function could not be executed */
+    };
+
+    /** Token status returned by the platform management. */
+
+    enum tokenStatus
+    {
+        TOKEN_SSM,        /**< token of the service provider's system manager */
+        TOKEN_ASM,        /**< token of an application's system manager */
+        TOKEN_APP,        /**< token of an installed application */
+        TOKEN_APP_ACTIVE,    /**< token of the currently ACTIVE application */
+        TOKEN_APP_INIT,        /**< token of the currently INITILAIZE application */
+        TOKEN_APP_IDLE,        /**< token of a currently AVAILABLE or UNAVAILABLE application */
+        TOKEN_INVALID        /**< invalid token */
+    };
+
+
+    typedef sequence<long> longList;
+    /** Base environment component definition (like in CUSS 'types.idl'). */
+
+    struct mEnvironmentComponent
+    {
+        string virtualComponentName;        /**< Virtual component name */
+        string virtualComponentRef;        /**< CORBA reference to the virtual component (IOR) */
+        string realComponentName;        /**< Real component name (e.g. ATB_PRNT_BP, ATB_PRNT_TK) */
+        string realDeviceName;            /**< Real device name (e.g. Atb2DeviceWithEscrow) */
+        longList linkedComponents;        /**< This list of indexes indicates,
+                                                     at which position in the component list
+                                                     the linked components can be found.
+                                                     (Index counting starts with 0) */
+    };
+
+    typedef sequence<mEnvironmentComponent> mEnvironmentComponents;
+
+    enum PowerStatus
+    {
+       POWER_ON,
+       POWER_OFF,
+       POWER_UNKNOWN
+    };
+    
+    struct BinLevel
+    {
+      long good;
+      long warning;
+      long error;
+    };
+
+    interface ComponentServiceListener
+    {
+      void changeLevel(in string bin, in long level);
+    };
+
+    interface ComponentServiceIF
+    {
+        boolean supportPowerSwitch();
+        PowerStatus getPowerStatus();
+        code switchPowerOff();
+        code switchPowerOn();
+        
+        list getBins();                                  // get list of bin of the component
+        BinLevel getBinSettings(in string bin);          // get settings for a bin 
+        code setBinLevel(in string bin, in long level);  // set current no of documents for a bin   
+        long getBinLevel(in string bin);                 // get current no of documents for a bin  
+        string getType(in string bin);                   // get type for a bin        
+        
+        code setListener(in ComponentServiceListener listener);
+        code rmvListener(in ComponentServiceListener listener);
+    };
+
+    /** Component interface for the platform management. Via this interface the platform
+     *  communicates with the device components internally.
+     */
+
+    interface ComponentIF: ComponentServiceIF
+    {
+        /** Prepares a device for a specific application context.
+         *  @param contextName - The name of the application context
+         *  @return RC_OK if the context switch was successfull, RC_ERROR if not.
+         */
+
+        code prepareDevice ( in string contextName );
+
+        /** Tries to bring the device in a proper state to be used by
+         *  the next application.
+         *  @return RC_OK is the reset was successfull, RC_ERROR if not.
+         */
+
+        code resetDevices ();
+
+        /** Tells the device component, that an error (e.g. paper jam) has been recovered.
+         *  @return RC_OK.
+         */
+
+        code errorRecovered ();
+
+        /** Releases components acquired by an application that has been disabled by the
+         *  application manager.
+         *  @param whichApp - The application reference of the disabled application
+         *  @return RC_OK.
+         */
+
+        code releaseComponents ( in string whichApp );
+
+        /** Tells the device component to terminate.
+         *  @return RC_OK.
+         */
+
+        code terminate ();
+    };
+
+    enum DataStatusExtension
+    {
+      DSE_STANDARD,                   /* use cuss1.0 datastatus only, send ds_corrupted for security failed */
+      DSE_STANDARD_DATA_MISSING,      /* use cuss1.0 datastatus only, send data_missing for security failed */
+      DSE_EXTENDED_SECURITY_FEATURE   /* use extended datastatus according to addendum a.1.19 */
+    };
+
+    enum PaymentCardExtension
+    {
+      PCE_PAYMENT,            /* default media type for card reader components is DS_TYPES_PAYMENT_ISO, DS_TYPES_PAYMENT_JIS2 */
+      PCE_FOID                /* default media type for card reader components is DS_TYPES_FOID_ISO, DS_TYPES_FOID_JIS2 */
+    };
+
+
+    /** Characteristics of the application
+     *
+     */
+
+    struct mApplicationProperties
+    {
+      DataStatusExtension dataStatusSupport;  /* cuss datastatus supported by application */
+      PaymentCardExtension paymentCardExtension; /* default media type for card reader components for the application */
+    };
+
+
+    /** Platform interface for the device components. Via this interface the device
+     *  components communicate with the platform manager internally.
+     */
+
+    interface PlatformIF
+    {
+        /** Checks the status of the token passed by the application.
+         *  @param token - The application token
+         *  @return the token status of the application token.
+         */
+
+        tokenStatus checkToken ( in string token );
+
+        /** Get the characteristics of the application.
+         *  @param token - The application token
+         *  @return the application characteristics
+         */
+
+        mApplicationProperties getProperties( in string token );
+
+        /** Get the characteristics of the active application.
+         *  @return the application characteristics
+         */
+
+        mApplicationProperties getActiveProperties();
+
+        /** Gets the currently active token.
+         *  @return the currently active token.
+         */
+
+        string getActiveToken ();
+
+        /** Logs an ATB response for billing purposes.
+         *  @param response - The ATB response
+         *  @return RC_OK.
+         */
+
+        code logATBResponse ( in string response );
+
+        /** Logs an BTP response for billing purposes.
+         *  @param response - The BTP response
+         *  @return RC_OK.
+         */
+
+        code logBTPResponse ( in string response );
+
+        /** Logs an GPP response for billing purposes.
+         *  @param response - The GPP response
+         *  @return RC_OK.
+         */
+
+        code logGPPResponse ( in string response );
+
+        /** Dispatches a platform event.
+         *  @param event - The plaform event
+         *  @return RC_OK if no error occurs, RC_ERROR if the event has the wrong format.
+         */
+
+        code sendPlatformEvent ( in any event );
+
+        /** Dispatches a private event.
+         *  @param event - The private event
+         *  @param appRef - The token of the receiver of the private event
+         *  @return RC_OK if no error occurs, RC_ERROR if the event cannot be sent.
+         */
+
+        code sendPrivateEvent ( in any event, in string appRef );
+
+        /** Dispatches a public event.
+         *  @param event - The public event
+         *  @param appRefsAlreadySent - A list of application references those have
+         *                already received the event via their component listeners
+         *  @return RC_OK if no error occurs, RC_ERROR if the event cannot be sent.
+         */
+
+        code sendPublicEvent ( in any event, in list appRefsAlreadySent );
+
+        /** Gets the CUSS platform level.
+         *  @param level - The return value
+         *  @return RC_OK.
+         */
+
+        code getLevel ( out any level );
+
+        /** Makes the reference of this device component interface and the list of virtual components
+         *  available for the platform manager.
+         *  @param realDeviceName - The name of the device component
+         *  @param comp - The reference of the device component interface
+         *  @param compList - The list of virtual components belonging to the device component
+         *  @return RC_OK.
+         **/
+
+        code bindDevice ( in string realDeviceName, in ComponentIF comp, in mEnvironmentComponents compList );
+
+        /** Deletes a device component from the list of the current available device components.
+         *  @param realDeviceName - The name of the device component
+         *  @return RC_OK if no error occurs, RC_UNKNOWN if the device is unknown by the platform.
+         **/
+
+        code unbindDevice ( in string realDeviceName );
+        
+
+        /** gets the component by name
+         *  @param realDeviceName - The name of the device component
+         *  @return ComponentServiceIF
+         **/
+        ComponentServiceIF getComponentService(in string realDeviceName);
+    };
+};
+
+#endif //PLATFORM_IDL
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/idl/Massai/platformgui.idl b/SelfServiceCommon/Massai/idl/Massai/platformgui.idl
new file mode 100644
index 00000000..0abca24d
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Massai/platformgui.idl
@@ -0,0 +1,34 @@
+// purpose:  communication between platform and platform gui (cla/service app)
+// M_INTERFACE_VERSION="1.0.0.0" 
+#ifndef PLATFORMGUI_IDL
+#define PLATFORMGUI_IDL
+
+#ifdef USE_TAO_ORB_IDL
+   #ifdef _TAO_2_0_
+      #include "tao\orb.idl"
+   #endif
+#endif
+
+#pragma prefix "massai.materna.com"
+
+module PlatformGUI
+{
+  interface GUI
+  {
+    // show screen
+    void requestDisplay(in string request);
+    // check if gui is ready
+    boolean isGUIReady();     
+  };
+
+  interface Controller
+  {           
+    void event(in string response);      
+    
+    // register GUI
+    void setGUI(in GUI gui);
+    void rmvGUI(in GUI gui);
+  };
+};
+
+#endif
diff --git a/SelfServiceCommon/Massai/idl/Massai/screendev.idl b/SelfServiceCommon/Massai/idl/Massai/screendev.idl
new file mode 100644
index 00000000..9689fbdb
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Massai/screendev.idl
@@ -0,0 +1,66 @@
+//---------------------------------------------------------------------------
+//
+//  file:     screendev.idl
+//
+//  purpose:  basic definition for the massai screen device component (internal)
+//
+//  date:     10.06.02
+//
+//  author:   (CMe)
+//
+//---------------------------------------------------------------------------
+
+#ifndef SCREENDEV_IDL
+#define SCREENDEV_IDL
+
+#include "mdci.idl"
+
+/** The pragma statement must be defined after the last include statement,
+ *  because some ORB implementations do not handle the scope correctly.
+ */
+#pragma prefix "DeviceComponents.massai.materna.com"
+
+/** MASSAI Device Component interface to a real screen device driver.
+ *  @version 1.0
+ *  @author Carsten Metzler - Materna Information & Communications
+ */
+ 
+module screendev
+{
+    /** Definition of screen resolutions. */
+     
+    enum resolutions
+    {
+      RES_800x600,
+      RES_1024x768,
+      RES_1280x1024,
+      RES_1600x1200,
+      RES_DEFAULT
+    };
+    
+    /** Data type for screen messages. */
+    
+    typedef resolutions screenData;    
+
+    /** Definition of command types passed to this device handler. */
+    
+    enum commandType
+    {
+      CMD_SET_RESOLUTION       /**< Set a screen resolution */
+    };
+
+    /** Screen device interface inherits from the generic interface. */
+    
+    interface Handler : DeviceComponents::Generic
+    {
+      /** returns the current screenm resolution */
+      
+      resolutions currentResolution();
+      
+      /** assigns a new desktop */
+      
+      long assignDesktop(in string dtName);
+    };
+};
+
+#endif // SCREENDEV_IDL
diff --git a/SelfServiceCommon/Massai/idl/Massai/seldev.idl b/SelfServiceCommon/Massai/idl/Massai/seldev.idl
new file mode 100644
index 00000000..ad9f1283
--- /dev/null
+++ b/SelfServiceCommon/Massai/idl/Massai/seldev.idl
@@ -0,0 +1,216 @@
+//---------------------------------------------------------------------------
+//
+//  file:     seldev.idl
+//
+//  purpose:  basic definition for the massai SEL device component (internal)
+//
+//  date:     27.07.00
+//
+//  author:   (AGe)
+//
+//---------------------------------------------------------------------------
+
+#ifndef SELDEV_IDL
+#define SELDEV_IDL
+
+#ifdef USE_TAO_ORB_IDL
+   #ifdef _TAO_2_0_
+      #include "tao\orb.idl"
+   #endif
+#endif
+
+#include "mdci.idl"
+
+#pragma prefix "DeviceComponents.massai.materna.com"
+
+module seldev
+{
+    enum statusType
+    {
+      STA_OK,
+      STA_ERROR,
+      STA_CANCELED
+    };
+
+    enum commandType
+    {
+      CMD_CANCEL,
+      CMD_READY_IND_ON,
+      CMD_READY_IND_OFF,
+      CMD_LOGO_ON,
+      CMD_LOGO_OFF,
+
+      CMD_CARD_LAMP_ON,
+      CMD_CARD_LAMP_OFF,
+      CMD_PINPAD_LAMP_ON,
+      CMD_PINPAD_LAMP_OFF,
+      CMD_ATBIN_LAMP_ON,
+      CMD_ATBIN_LAMP_OFF,
+      CMD_ATBOUT_LAMP_ON,
+      CMD_ATBOUT_LAMP_OFF,
+      CMD_BAGTAG_LAMP_ON,
+      CMD_BAGTAG_LAMP_OFF,
+      CMD_GPP_LAMP_ON,
+      CMD_GPP_LAMP_OFF,
+      CMD_PASSPORT_LAMP_ON,
+      CMD_PASSPORT_LAMP_OFF,
+      CMD_TAT_LAMP_ON,
+      CMD_TAT_LAMP_OFF,
+      CMD_AUX1_ON,
+      CMD_AUX1_OFF,
+      CMD_AUX2_ON,
+      CMD_AUX2_OFF,
+      CMD_AUX3_ON,
+      CMD_AUX3_OFF,
+      CMD_MONITOR_ON,
+      CMD_MONITOR_OFF,
+      CMD_POWER_OFF,
+      CMD_CANCEL_POWER_OFF,
+
+      CMD_ATB_POWER_ON,
+      CMD_ATB_POWER_OFF,
+      CMD_BAGTAG_POWER_ON,
+      CMD_BAGTAG_POWER_OFF,
+      CMD_CREADER_POWER_ON,
+      CMD_CREADER_POWER_OFF,
+      CMD_OPTION45_POWER_ON,
+      CMD_OPTION45_POWER_OFF,
+      CMD_DMODUL_POWER_ON,
+      CMD_DMODUL_POWER_OFF,
+      CMD_OPTION_POWER_ON,
+      CMD_OPTION_POWER_OFF,
+      CMD_TFT_POWER_ON,
+      CMD_TFT_POWER_OFF,
+      CMD_TOUCH_POWER_ON,
+      CMD_TOUCH_POWER_OFF,
+
+      CMD_CAL_BIN1_LOW,
+      CMD_CAL_BIN1_HIGH,
+      CMD_CAL_BIN2_LOW,
+      CMD_CAL_BIN2_HIGH,
+      CMD_CAL_BIN3_LOW,
+      CMD_CAL_BIN3_HIGH,
+      CMD_SET_WARN_LEVEL,
+      CMD_SET_BTP_WARN_LEVEL,
+      CMD_GET_WARN_LEVEL,
+      CMD_GET_BIN_STATE,
+      CMD_STATUS_QUERY,			/**< Query device status */
+      CMD_GET_DOOR_STATES,
+      
+      CMD_LAMP_PAPER_ERROR_ON,
+      CMD_LAMP_PAPER_ERROR_OFF,
+      CMD_LAMP_PAPER_OK_ON,
+      CMD_LAMP_PAPER_OK_OFF
+    };
+
+    enum indicationType
+    {
+      IND_USER_ABSENT,            // prox sensor indicates movement of object
+      IND_USER_PRESENT,           // prox sensor indicates movement of object
+
+      IND_SOP,                    // SEL indicates SOP button pressed
+
+      IND_POWER_RESERVE,          // UPS has switched to reserve mode
+      IND_POWER_FAIL,             // UPS is low on power
+      IND_POWER_OK,               // UPS has returned to normal mode
+
+      IND_DOOR1_OPEN,             // Door switch 1 has been opened
+      IND_DOOR1_CLOSED,           // Door switch 1 has been closed
+      IND_DOOR2_OPEN,             // Door switch 2 has been opened
+      IND_DOOR2_CLOSED,           // Door switch 2 has been closed
+      IND_DOOR3_OPEN,             // Door switch 3 has been opened
+      IND_DOOR3_CLOSED,           // Door switch 3 has been closed
+
+      IND_CANCEL_DONE,            // response indications
+      IND_READY_IND_ON_DONE,
+      IND_READY_IND_OFF_DONE,
+      IND_LOGO_ON_DONE,
+      IND_LOGO_OFF_DONE,
+      IND_CARD_LAMP_ON_DONE,
+      IND_CARD_LAMP_OFF_DONE,
+      IND_PINPAD_LAMP_ON_DONE,
+      IND_PINPAD_LAMP_OFF_DONE,
+      IND_ATBIN_LAMP_ON_DONE,
+      IND_ATBIN_LAMP_OFF_DONE,
+      IND_ATBOUT_LAMP_ON_DONE,
+      IND_ATBOUT_LAMP_OFF_DONE,
+      IND_BAGTAG_LAMP_ON_DONE,
+      IND_BAGTAG_LAMP_OFF_DONE,
+      IND_GPP_LAMP_ON_DONE,
+      IND_GPP_LAMP_OFF_DONE,
+      IND_PASSPORT_LAMP_ON_DONE,
+      IND_PASSPORT_LAMP_OFF_DONE,
+      IND_TAT_LAMP_ON_DONE,
+      IND_TAT_LAMP_OFF_DONE,
+      IND_AUX1_ON_DONE,
+      IND_AUX1_OFF_DONE,
+      IND_AUX2_ON_DONE,
+      IND_AUX2_OFF_DONE,
+      IND_AUX3_ON_DONE,
+      IND_AUX3_OFF_DONE,
+      IND_MONITOR_ON_DONE,
+      IND_MONITOR_OFF_DONE,
+      IND_POWER_OFF_DONE,
+      IND_CANCEL_POWER_OFF_DONE,
+
+      IND_ATB_POWER_ON_DONE,
+      IND_ATB_POWER_OFF_DONE,
+      IND_BAGTAG_POWER_ON_DONE,
+      IND_BAGTAG_POWER_OFF_DONE,
+      IND_CREADER_POWER_ON_DONE,
+      IND_CREADER_POWER_OFF_DONE,
+      IND_OPTION45_POWER_ON_DONE,
+      IND_OPTION45_POWER_OFF_DONE,
+      IND_DMODUL_POWER_ON_DONE,
+      IND_DMODUL_POWER_OFF_DONE,
+      IND_OPTION_POWER_ON_DONE,
+      IND_OPTION_POWER_OFF_DONE,
+      IND_TFT_POWER_ON_DONE,
+      IND_TFT_POWER_OFF_DONE,
+      IND_TOUCH_POWER_ON_DONE,
+      IND_TOUCH_POWER_OFF_DONE,
+
+      IND_CAL_BIN1_LOW_DONE,
+      IND_CAL_BIN1_HIGH_DONE,
+      IND_CAL_BIN2_LOW_DONE,
+      IND_CAL_BIN2_HIGH_DONE,
+      IND_CAL_BIN3_LOW_DONE,
+      IND_CAL_BIN3_HIGH_DONE,
+      IND_WEIGHT_CHANGED,
+      IND_BAGTAG_PAPER_LOW,
+      IND_BAGTAG_PAPER_OK,
+      IND_SET_WARN_LEVEL_DONE,
+      IND_GET_WARN_LEVEL_DONE,
+      IND_GET_BIN_STATE_DONE,
+      IND_SET_BTP_WARN_LEVEL_DONE,
+      IND_STATUS_INFO,			/**< Current device status */
+      IND_GET_DOOR_STATES_DONE,
+      /* supported by ier918 sel, but not by massai platform yet
+      IND_TEMPERATURE_HIGH,  
+      IND_TEMPERATURE_OK,    
+      */
+      IND_PRINTER_DISPENSER_PAPER_PRESENT,  // supported by sel, needed in printer, let the printer read this directly?
+      IND_PRINTER_DISPENSER_PAPER_ABSENT,
+
+      IND_LAMP_PAPER_ERROR_ON_DONE,
+      IND_LAMP_PAPER_ERROR_OFF_DONE,
+      IND_LAMP_PAPER_OK_ON_DONE,
+      IND_LAMP_PAPER_OK_OFF_DONE
+      
+    };
+
+    typedef unsigned short Bins[4];
+
+    struct ATB_BIN
+    {
+      Bins        bin;   /**< data for/from the ATB bin 0 - BagTag 1-3 ATB bin*/
+    };
+
+    // derive all device components from the basic interface
+
+    interface Handler : DeviceComponents::Generic
+    {
+    };
+};
+
+#endif // SELDEV_IDL 
\ No newline at end of file
-- 
2.41.0.windows.1

