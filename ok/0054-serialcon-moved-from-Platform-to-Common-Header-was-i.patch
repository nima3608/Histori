From 300be9c96c1c8e07254c88114daa3dcdaff4bd8b Mon Sep 17 00:00:00 2001
From: tstegema <tstegema@90b65887-3827-0410-9a23-83215b262276>
Date: Wed, 27 Oct 2010 16:37:21 +0000
Subject: [PATCH 0054/1077] serialcon moved from Platform to Common (Header was
 in Common, Implementation in Platform) duplicate sources removed

git-svn-id: svn://localhost/SelfServiceCommon/trunk@59 90b65887-3827-0410-9a23-83215b262276
---
 .../{inc => generic}/asso/assoTrace.h         |    0
 .../Interfaces/{inc => generic}/assoTrace.h   |    0
 .../Interfaces/generic/hashMap.hpp            |    9 +
 .../generic/tools}/hashMap.hpp                |    7 +-
 SelfServiceCommon/Interfaces/inc/FILECUR.hpp  |    9 +
 .../Interfaces/inc/{logging => Tools}/log.h   |    0
 SelfServiceCommon/Interfaces/inc/cfgUART.hpp  |    9 +
 SelfServiceCommon/Interfaces/inc/cxAPIi.h     |    9 +
 .../inc => Interfaces/inc/cxComm}/cxAPIi.h    |    0
 .../Interfaces/inc/durationControl.hpp        |    9 +
 SelfServiceCommon/Interfaces/inc/log.h        |   18 +-
 .../Interfaces/inc/serialCon/cfgUART.hpp      |  104 ++
 .../inc/serialCon/durationControl.hpp         |  108 ++
 .../Interfaces/inc/systools/FILECUR.HPP       |  102 ++
 .../Interfaces/src/assoTrace.cpp              |   58 +
 .../Massai/cpp/Asso/makefile.mak              |    3 +-
 .../Massai/cpp/Asso/src/AssoCStr.cpp          |  535 ++++++++
 .../Massai/cpp/BillingService/makefile.mak    |    4 +-
 .../Massai/cpp/Graphic/makefile.mak           |    6 +-
 .../Massai/cpp/LogService/makefile.mak        |   12 +-
 .../Massai/cpp/LogService/src/Asso.cpp        |  494 -------
 .../Massai/cpp/SerialCon/make.dep             |   59 +
 .../Massai/cpp/SerialCon/makefile.mak         |   28 +
 .../Massai/cpp/SerialCon/src/MassaiDevice.cpp |  306 +++++
 .../Massai/cpp/SerialCon/src/cfgUART.cpp      |  280 ++++
 .../cpp/SerialCon/src/durationControl.cpp     |  107 ++
 .../Massai/cpp/SerialCon/src/mIEtxAckAsy.cpp  |  426 ++++++
 .../Massai/cpp/SerialCon/src/matAsyncW32.c    | 1212 +++++++++++++++++
 .../Massai/cpp/StatisticsService/makefile.mak |    1 -
 .../Massai/cpp/StatisticsService/src/log.cpp  |   92 --
 .../Massai/cpp/Systools/makefile.mak          |    5 +-
 .../Massai/cpp/Systools/src/NT_FILE.cpp       |  189 +++
 .../Massai/cpp/Systools/src/mEventSemW32.cpp  |    6 +
 .../Massai/cpp/Tools/makefile.mak             |    4 +-
 .../cpp/{BillingService => Tools}/src/log.cpp |    0
 .../Massai/cpp/mSysTools/makefile.mak         |    2 -
 .../Services/cpp/CardScanner/src/dump.cpp     |  372 -----
 .../cpp/CardScanner/src/textconst.cpp         |  154 ---
 .../cpp/CxComm/StdApps/inc/argScan.hpp        |  330 -----
 .../Services/cpp/CxComm/StdApps/inc/cxAPI.h   |  247 ----
 .../Services/cpp/CxComm/StdApps/inc/cxAPI.hpp |  160 ---
 .../cpp/CxComm/StdApps/inc/matThread.hpp      |  312 -----
 .../Services/cpp/CxComm/StdApps/makefile.mak  |   14 +-
 .../cpp/CxComm/StdApps/src/matThreadW32.cpp   |  580 --------
 .../Services/cpp/CxComm/dll/inc/cxAPI.h       |  247 ----
 .../Services/cpp/CxComm/dll/inc/cxAPIi.h      |   58 -
 .../Services/cpp/CxComm/dll/inc/eventSem.hpp  |  125 --
 .../Services/cpp/CxComm/dll/inc/fmtQueue.hpp  |  617 ---------
 .../Services/cpp/CxComm/dll/inc/hashMap.hpp   |  243 ----
 .../Services/cpp/CxComm/dll/inc/matThread.hpp |  312 -----
 .../Services/cpp/CxComm/dll/makefile.mak      |    7 +-
 .../cpp/CxComm/dll/src/matThreadW32.cpp       |  580 --------
 .../Services/cpp/TrcServ/inc/argScan.hpp      |  330 -----
 .../Services/cpp/TrcServ/inc/cxAPI.h          |  247 ----
 .../Services/cpp/TrcServ/inc/fmtQueue.hpp     |  617 ---------
 55 files changed, 3608 insertions(+), 6157 deletions(-)
 rename SelfServiceCommon/Interfaces/{inc => generic}/asso/assoTrace.h (100%)
 rename SelfServiceCommon/Interfaces/{inc => generic}/assoTrace.h (100%)
 create mode 100644 SelfServiceCommon/Interfaces/generic/hashMap.hpp
 rename SelfServiceCommon/{Massai/cpp/LogService/inc => Interfaces/generic/tools}/hashMap.hpp (92%)
 create mode 100644 SelfServiceCommon/Interfaces/inc/FILECUR.hpp
 rename SelfServiceCommon/Interfaces/inc/{logging => Tools}/log.h (100%)
 create mode 100644 SelfServiceCommon/Interfaces/inc/cfgUART.hpp
 create mode 100644 SelfServiceCommon/Interfaces/inc/cxAPIi.h
 rename SelfServiceCommon/{Services/cpp/CxComm/StdApps/inc => Interfaces/inc/cxComm}/cxAPIi.h (100%)
 create mode 100644 SelfServiceCommon/Interfaces/inc/durationControl.hpp
 create mode 100644 SelfServiceCommon/Interfaces/inc/serialCon/cfgUART.hpp
 create mode 100644 SelfServiceCommon/Interfaces/inc/serialCon/durationControl.hpp
 create mode 100644 SelfServiceCommon/Interfaces/inc/systools/FILECUR.HPP
 create mode 100644 SelfServiceCommon/Interfaces/src/assoTrace.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Asso/src/AssoCStr.cpp
 delete mode 100644 SelfServiceCommon/Massai/cpp/LogService/src/Asso.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/SerialCon/make.dep
 create mode 100644 SelfServiceCommon/Massai/cpp/SerialCon/makefile.mak
 create mode 100644 SelfServiceCommon/Massai/cpp/SerialCon/src/MassaiDevice.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/SerialCon/src/cfgUART.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/SerialCon/src/durationControl.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/SerialCon/src/mIEtxAckAsy.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/SerialCon/src/matAsyncW32.c
 delete mode 100644 SelfServiceCommon/Massai/cpp/StatisticsService/src/log.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/Systools/src/NT_FILE.cpp
 rename SelfServiceCommon/Massai/cpp/{BillingService => Tools}/src/log.cpp (100%)
 delete mode 100644 SelfServiceCommon/Services/cpp/CardScanner/src/dump.cpp
 delete mode 100644 SelfServiceCommon/Services/cpp/CardScanner/src/textconst.cpp
 delete mode 100644 SelfServiceCommon/Services/cpp/CxComm/StdApps/inc/argScan.hpp
 delete mode 100644 SelfServiceCommon/Services/cpp/CxComm/StdApps/inc/cxAPI.h
 delete mode 100644 SelfServiceCommon/Services/cpp/CxComm/StdApps/inc/cxAPI.hpp
 delete mode 100644 SelfServiceCommon/Services/cpp/CxComm/StdApps/inc/matThread.hpp
 delete mode 100644 SelfServiceCommon/Services/cpp/CxComm/StdApps/src/matThreadW32.cpp
 delete mode 100644 SelfServiceCommon/Services/cpp/CxComm/dll/inc/cxAPI.h
 delete mode 100644 SelfServiceCommon/Services/cpp/CxComm/dll/inc/cxAPIi.h
 delete mode 100644 SelfServiceCommon/Services/cpp/CxComm/dll/inc/eventSem.hpp
 delete mode 100644 SelfServiceCommon/Services/cpp/CxComm/dll/inc/fmtQueue.hpp
 delete mode 100644 SelfServiceCommon/Services/cpp/CxComm/dll/inc/hashMap.hpp
 delete mode 100644 SelfServiceCommon/Services/cpp/CxComm/dll/inc/matThread.hpp
 delete mode 100644 SelfServiceCommon/Services/cpp/CxComm/dll/src/matThreadW32.cpp
 delete mode 100644 SelfServiceCommon/Services/cpp/TrcServ/inc/argScan.hpp
 delete mode 100644 SelfServiceCommon/Services/cpp/TrcServ/inc/cxAPI.h
 delete mode 100644 SelfServiceCommon/Services/cpp/TrcServ/inc/fmtQueue.hpp

diff --git a/SelfServiceCommon/Interfaces/inc/asso/assoTrace.h b/SelfServiceCommon/Interfaces/generic/asso/assoTrace.h
similarity index 100%
rename from SelfServiceCommon/Interfaces/inc/asso/assoTrace.h
rename to SelfServiceCommon/Interfaces/generic/asso/assoTrace.h
diff --git a/SelfServiceCommon/Interfaces/inc/assoTrace.h b/SelfServiceCommon/Interfaces/generic/assoTrace.h
similarity index 100%
rename from SelfServiceCommon/Interfaces/inc/assoTrace.h
rename to SelfServiceCommon/Interfaces/generic/assoTrace.h
diff --git a/SelfServiceCommon/Interfaces/generic/hashMap.hpp b/SelfServiceCommon/Interfaces/generic/hashMap.hpp
new file mode 100644
index 00000000..82704e8a
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/generic/hashMap.hpp
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER)
+#error "hashMap.hpp" is deprecated, use "tools/hashMap.hpp" instead.
+#else
+// #pragma message ("Warning: \"hashMap.hpp\" is deprecated, use \"tools/hashMap.hpp\" instead.")
+#include "tools/hashMap.hpp"
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/LogService/inc/hashMap.hpp b/SelfServiceCommon/Interfaces/generic/tools/hashMap.hpp
similarity index 92%
rename from SelfServiceCommon/Massai/cpp/LogService/inc/hashMap.hpp
rename to SelfServiceCommon/Interfaces/generic/tools/hashMap.hpp
index b62d0e0d..44bd9c49 100644
--- a/SelfServiceCommon/Massai/cpp/LogService/inc/hashMap.hpp
+++ b/SelfServiceCommon/Interfaces/generic/tools/hashMap.hpp
@@ -13,11 +13,8 @@
 **/
 #ifndef HASHMAP_HPP
 #define HASHMAP_HPP
-#if defined(SHOW_INCLUDE_FILES)
-#pragma message("including: " __FILE__)
-#endif
 
-#include "mutex.hpp"
+#include "mMutexSem.hpp"
 
 
 /**
@@ -54,7 +51,7 @@ class hashMap
    K              M_NoKey;
 
    //! Access protection
-   mutexSemaphore M_Mutex;
+   Materna::MSSD::mutexSemaphore M_Mutex;
 
    /**
     *
diff --git a/SelfServiceCommon/Interfaces/inc/FILECUR.hpp b/SelfServiceCommon/Interfaces/inc/FILECUR.hpp
new file mode 100644
index 00000000..7bc2a84c
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/FILECUR.hpp
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER)
+#error "FILECUR.hpp" is deprecated, use "systools/FILECUR.hpp" instead.
+#else
+// #pragma message ("Warning: \"FILECUR.hpp\" is deprecated, use \"systools/FILECUR.hpp\" instead.")
+#include "systools/FILECUR.hpp"
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/logging/log.h b/SelfServiceCommon/Interfaces/inc/Tools/log.h
similarity index 100%
rename from SelfServiceCommon/Interfaces/inc/logging/log.h
rename to SelfServiceCommon/Interfaces/inc/Tools/log.h
diff --git a/SelfServiceCommon/Interfaces/inc/cfgUART.hpp b/SelfServiceCommon/Interfaces/inc/cfgUART.hpp
new file mode 100644
index 00000000..fb8ede43
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/cfgUART.hpp
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER)
+#error "cfgUART.hpp" is deprecated, use "serialCon/cfgUART.hpp" instead.
+#else
+// #pragma message ("Warning: \"cfgUART.hpp\" is deprecated, use \"serialCon/cfgUART.hpp\" instead.")
+#include "serialCon/cfgUART.hpp"
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/cxAPIi.h b/SelfServiceCommon/Interfaces/inc/cxAPIi.h
new file mode 100644
index 00000000..88afc0bf
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/cxAPIi.h
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER)
+#error "cxAPIi.h" is deprecated, use "cxComm/cxAPIi.h" instead.
+#else
+// #pragma message ("Warning: \"cxAPIi.h\" is deprecated, use \"cxComm/cxAPIi.h\" instead.")
+#include "cxComm/cxAPIi.h"
+#endif
diff --git a/SelfServiceCommon/Services/cpp/CxComm/StdApps/inc/cxAPIi.h b/SelfServiceCommon/Interfaces/inc/cxComm/cxAPIi.h
similarity index 100%
rename from SelfServiceCommon/Services/cpp/CxComm/StdApps/inc/cxAPIi.h
rename to SelfServiceCommon/Interfaces/inc/cxComm/cxAPIi.h
diff --git a/SelfServiceCommon/Interfaces/inc/durationControl.hpp b/SelfServiceCommon/Interfaces/inc/durationControl.hpp
new file mode 100644
index 00000000..8738168d
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/durationControl.hpp
@@ -0,0 +1,9 @@
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER)
+#error "durationControl.hpp" is deprecated, use "serialCon/durationControl.hpp" instead.
+#else
+// #pragma message ("Warning: \"durationControl.hpp\" is deprecated, use \"serialCon/durationControl.hpp\" instead.")
+#include "serialCon/durationControl.hpp"
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/log.h b/SelfServiceCommon/Interfaces/inc/log.h
index 5ee498e7..9cbd66fa 100644
--- a/SelfServiceCommon/Interfaces/inc/log.h
+++ b/SelfServiceCommon/Interfaces/inc/log.h
@@ -1,9 +1,9 @@
-#if defined(SHOW_INCLUDE_FILES) 
-#pragma message("including: " __FILE__) 
-#endif 
-#if defined(IGNORE_DEPRECATED_MASSAI_HEADER) 
-#error "log.h" is deprecated, use "logging/log.h" instead. 
-#else 
-// #pragma message ("Warning: \"log.h\" is deprecated, use \"logging/log.h\" instead.") 
-#include "logging/log.h" 
-#endif 
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#if defined(IGNORE_DEPRECATED_MASSAI_HEADER)
+#error "log.h" is deprecated, use "tools/log.h" instead.
+#else
+// #pragma message ("Warning: \"log.h\" is deprecated, use \"tools/log.h\" instead.")
+#include "tools/log.h"
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/serialCon/cfgUART.hpp b/SelfServiceCommon/Interfaces/inc/serialCon/cfgUART.hpp
new file mode 100644
index 00000000..f0b7cbef
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/serialCon/cfgUART.hpp
@@ -0,0 +1,104 @@
+/**
+ **************************************************************************
+ *
+ * @file cfgUART.hpp
+ *
+ * Contains class cfgUART interface.
+ *
+ * @author Juergen Kreierhoff
+ *
+ * Copyright (c) 2006 MATERNA Information & Communications.
+ *
+ **************************************************************************
+**/
+#ifndef CFGUART_HPP
+#define CFGUART_HPP
+
+
+
+/**
+ *
+ * UART parameter configuration class.
+ *
+**/
+class cfgUART
+{
+
+   //! Implementation class.
+   class impl;
+
+   //! Implementation handle.
+   impl *       M_Impl;
+
+public:
+
+   /**
+    *
+    * Constructor.
+    *
+    * @param ConnDevice:        Names the connected device.
+    *
+    * @param CfgClient:         The configuration client identification
+    *                           to use.
+    *
+    * @param CfgPortItem:       The configuration item.
+    *
+   **/
+   cfgUART
+   (
+      char const * ConnDevice,
+      char const * CfgClient,
+      char const * CfgPortItem
+   );
+
+   /**
+    *
+    * Destructor.
+    *
+   **/
+   ~cfgUART();
+
+   /**
+    *
+    * Has the configuration changed?
+    *
+   **/
+   bool changed();
+
+   /**
+    *
+    * Return the configured port name.
+    *
+   **/
+   char const * getPort() const;
+
+   /**
+    *
+    * Return a Win32-save port name, i.e. a name prefixed with "\\.\".
+    *
+   **/
+   char const * getPortExtended() const;
+
+private:
+
+   //! Default constructor - intentionally not implemented.
+   cfgUART();
+
+   //! Copy constructor - intentionally not implemented.
+   cfgUART( cfgUART const & );
+
+   //! Assignment - intentionally not implemented.
+   cfgUART & operator=( cfgUART const & );
+
+};
+
+
+
+#endif // #ifndef CFGUART_HPP
+/**
+ **************************************************************************
+ *
+ * End of file
+ *
+ **************************************************************************
+**/
diff --git a/SelfServiceCommon/Interfaces/inc/serialCon/durationControl.hpp b/SelfServiceCommon/Interfaces/inc/serialCon/durationControl.hpp
new file mode 100644
index 00000000..c58df7ce
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/serialCon/durationControl.hpp
@@ -0,0 +1,108 @@
+/**
+ **************************************************************************
+ *
+ * @file durationControl.hpp
+ *
+ * Call duration control tool.
+ *
+ * @author Juergen Kreierhoff
+ *
+ * Copyright (c) 2008 MATERNA Information & Communications.
+ *
+ **************************************************************************
+**/
+#ifndef DURATIONCONTROL_HPP
+#define DURATIONCONTROL_HPP
+
+
+#include "matThread.hpp"
+#include "mEventSem.hpp"
+#include "mMutexSem.hpp"
+
+
+
+/**
+ *
+ * Function call duration control class.
+ *
+**/
+class durationControl :
+   public matThread
+{
+
+   //! Is the object still active?
+   bool                              M_Active;
+
+   //! The max time to wait.
+   unsigned const                    M_DurationMS;
+
+   //! Protect against recursion.
+   Materna::MSSD::mutexSemaphore     M_Mutex;
+
+   //! Duration has ended.
+   Materna::MSSD::eventSemaphore     M_SemRet;
+
+   //! Begin control.
+   Materna::MSSD::eventSemaphore     M_SemBegin;
+
+   //! End control
+   Materna::MSSD::eventSemaphore     M_SemEnd;
+
+   /**
+    *
+    * Timeout function, to be implemented by the user class.
+    *
+   **/
+   virtual void durationControlTimeout() = 0;
+
+   /**
+    *
+    * Thread function.
+    *
+   **/
+   void function();
+
+public:
+
+   /**
+    *
+    * Constructor.
+    *
+    * @param DurationMS:        The time in milliseconds to wait
+    *                           until durationControlTimeout() is called.
+    *
+   **/
+   durationControl( unsigned DurationMS );
+
+   /**
+    *
+    * Destructor.
+    *
+   **/
+   virtual ~durationControl() throw();
+
+   /**
+    *
+    * Begin duration time, start the timer.
+    *
+   **/
+   void durationControlBegin();
+
+   /**
+    *
+    * End duration time, stop the timer.
+    *
+   **/
+   void durationControlEnd();
+
+};
+
+
+#endif // #ifndef DURATIONCONTROL_HPP
+/**
+ **************************************************************************
+ *
+ * End of file
+ *
+ **************************************************************************
+**/
diff --git a/SelfServiceCommon/Interfaces/inc/systools/FILECUR.HPP b/SelfServiceCommon/Interfaces/inc/systools/FILECUR.HPP
new file mode 100644
index 00000000..63742c89
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/systools/FILECUR.HPP
@@ -0,0 +1,102 @@
+
+// -------------------------------------------------------------------
+//
+// FILECUR.HPP
+//
+// This file defines a cursor class for getting the file names of 
+// a given directory with wild cards
+//
+// DEC. 1997, Maz
+//
+// -------------------------------------------------------------------
+#ifndef FILECUR_HPP
+#define FILECUR_HPP
+
+
+//
+// forward declaration 
+//
+class _fileCursor;
+
+class fileCursor
+{
+  _fileCursor *handle;
+  
+
+  // hide the copy constructor and assignment operator
+  
+  fileCursor& operator=(const fileCursor&) { return *this;};
+  fileCursor(const fileCursor&) {};
+  
+public:
+
+enum FILETYPE
+{
+  ALLFILES,
+  NORMAL,
+  DIRECTORY
+};
+
+  
+  // Constructor
+  // szFilename is the filename with wild cards
+  // if no absolute path is given the current path is used
+  // 
+  // lFileType allows to search only for a specific type of files
+  //
+  
+  fileCursor(const char* szFilename,FILETYPE lFileType = NORMAL);
+  ~fileCursor();
+
+  // eof() returns 0 if the Cursor is valid
+  //       returns 1 if no more files has been found, the Cursor is
+  //                 not valid.
+  //
+  
+  long eof();
+  
+
+  // const char* operator
+  // the returned value is only valid if eof() returns true
+  // If the Cursor ist no more valid, a pointer to "" will be returned
+  //
+  operator const char*();
+  
+  const char* szValue();  // same as const char* operator, but as member-function
+  
+  const char* sz83Value(); // delivers the Filename in 8.3-Notation
+  
+  // prefix increment operator
+  // sets the Cursor to the next entry
+  // after this function call the eof() flag has to be checked.
+  // If the Cursor ist no more valid, a pointer to "" will be returned
+  //
+  const char* operator++();
+  
+  // postfix increment operator
+  // sets the Cursor to the next entry
+  // after this function call the eof() flag has to be checked.
+  // If the Cursor ist no more valid, a pointer to "" will be returned
+  //
+  // NOTE: This function returns a static pointer, be aware of
+  //       calling this operator two times without copying the value
+  //
+  const char* operator++(int);
+
+
+  // isDir() returns 1 if the file referenced b the Cursor is a Directory
+  //                 0 if the file is not a Directory
+  //
+  long isDir();
+
+  // Test Functions
+  
+  long isReadOnly();  
+  long isHidden();
+  long isSystem();
+  long isArchive();
+  
+};
+
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/src/assoTrace.cpp b/SelfServiceCommon/Interfaces/src/assoTrace.cpp
new file mode 100644
index 00000000..39f75387
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/src/assoTrace.cpp
@@ -0,0 +1,58 @@
+/**
+ **************************************************************************
+ *
+ * @file assoTrace.cpp
+ *
+ * Implements the functions declared in "assoTrace.h".
+ *
+ * @author ts
+ *
+ * Copyright (c) 2001, MATERNA Information & Communications
+ *
+ **************************************************************************
+**/
+
+
+#include "assoTrace.h"
+#include "tracedef.h"
+#include "asso.h"
+#include "assodump.hpp"
+#include <strstrea.h>
+#include <string.h>
+
+#define TRACEBUF 2000
+
+/**
+ **************************************************************************
+ *
+ * trace the content of an aMap
+ *
+ **************************************************************************
+**/
+void assoTrace(long lLevel,char *pszFile, long lLine, const aMap& Dump)
+{
+  ostrstream out;
+  char *pBuf;
+  dumpMap(&out, Dump);
+  out.put((char)0);
+  pBuf= out.str();
+  int length;
+  char* pTmp;
+  for(pTmp= pBuf,length= strlen(pBuf);length > TRACEBUF;pTmp+= TRACEBUF,length-= TRACEBUF)
+  {
+    char c= pTmp[TRACEBUF];
+    pTmp[TRACEBUF]= 0;
+    trace(lLevel, pszFile, lLine, "\n%s", pTmp);
+    pTmp[TRACEBUF]= c;
+  }
+  trace(lLevel, pszFile, lLine, "\n%s", pTmp);
+  delete[] pBuf;
+}
+
+/**
+ **************************************************************************
+ *
+ * End of file
+ *
+ **************************************************************************
+**/
diff --git a/SelfServiceCommon/Massai/cpp/Asso/makefile.mak b/SelfServiceCommon/Massai/cpp/Asso/makefile.mak
index 5e596adc..4bd1e6df 100644
--- a/SelfServiceCommon/Massai/cpp/Asso/makefile.mak
+++ b/SelfServiceCommon/Massai/cpp/Asso/makefile.mak
@@ -15,7 +15,8 @@ MY_LIB1 =               $(LIB_ASSO)
 MY_LIB1_OBJS =          $(_OBJ)\local_def.obj \
                         $(_OBJ)\AssoDump.obj \
                         $(_OBJ)\AssoFlat.obj \
-                        $(_OBJ)\matAsso.obj
+                        $(_OBJ)\matAsso.obj \
+                        $(_OBJ)\assoCStr.obj
 
 ######################################################################
 
diff --git a/SelfServiceCommon/Massai/cpp/Asso/src/AssoCStr.cpp b/SelfServiceCommon/Massai/cpp/Asso/src/AssoCStr.cpp
new file mode 100644
index 00000000..e2b7538f
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Asso/src/AssoCStr.cpp
@@ -0,0 +1,535 @@
+/**
+ **************************************************************************
+ * 
+ * @file AssoCStr.cpp
+ * 
+ * Contains the implementation for function prototypes in AssoCStr.hpp.
+ * 
+ * @author JK
+ * 
+ * Copyright (c) 2000-2002 MATERNA Information & Communications
+ * 
+ **************************************************************************
+**/
+
+
+#include "AssoCStr.hpp"
+
+#include <stdlib.h>
+#include <limits.h>
+
+
+
+/**
+ *
+ * Size-type used here.
+ *
+**/
+typedef unsigned long asize;
+
+
+
+/**
+ **************************************************************************
+ * 
+ * Write a single char to a buffer.
+ * 
+ * @param DstPtr    Start of buffer, adjusted on return to next start.
+ * 
+ * @param DstSiz    Length of buffer, adjusted on return to new length.
+ *
+ * @param Src       The char to write.
+ * 
+ **************************************************************************
+**/
+static inline void toBuffer_C
+(
+   char * &      DstPtr,
+   asize &        DstSiz,
+   char          Src
+)
+{
+   if( DstSiz )
+   {
+      --DstSiz;
+      if( DstPtr )
+         *DstPtr++ = Src;
+   }
+}
+
+
+
+/**
+ **************************************************************************
+ * 
+ * Write a C-string to a buffer.
+ * 
+ * @param DstPtr    Start of buffer, adjusted on return to next start.
+ * 
+ * @param DstSiz    Length of buffer, adjusted on return to new length.
+ *
+ * @param Src       The string (zero-terminated) to write.
+ * 
+ **************************************************************************
+**/
+static void toBuffer
+(
+   char * &      DstPtr,
+   asize &        DstSiz,
+   char const *  Src
+)
+{
+   if( Src )
+   {
+      while( *Src && DstSiz )
+         toBuffer_C( DstPtr, DstSiz, *Src++ );
+   }
+}
+
+
+
+/**
+ **************************************************************************
+ * 
+ * Write a C-string to a buffer (flagged with []).
+ * 
+ * @param DstPtr    Start of buffer, adjusted on return to next start.
+ * 
+ * @param DstSiz    Length of buffer, adjusted on return to new length.
+ *
+ * @param Src       The string (zero-terminated) to write.
+ * 
+ * @param CutString String objects are cut before this offset (0 = no cut).
+ * 
+ **************************************************************************
+**/
+static void toBuffer_F
+(
+   char * &      DstPtr,
+   asize &        DstSiz,
+   char const *  Src,
+   unsigned long CutString
+)
+{
+   if( Src )
+   {
+      toBuffer_C( DstPtr, DstSiz, '[' );
+      while( *Src && DstSiz && --CutString )
+      {
+         char X = *Src++;
+         switch( X )
+         {
+         case ']':
+         case '\\':
+         case '[':
+            toBuffer_C( DstPtr, DstSiz, '\\' );
+         default:
+            toBuffer_C( DstPtr, DstSiz, X );
+         }
+      }
+      toBuffer_C( DstPtr, DstSiz, ']' );
+      if( CutString == 0 )
+         toBuffer_C( DstPtr, DstSiz, '+' );
+   }
+}
+
+
+
+/**
+ **************************************************************************
+ * 
+ * Write a long variable to a buffer.
+ * 
+ * @param DstPtr    Start of buffer, adjusted on return to next start.
+ * 
+ * @param DstSiz    Length of buffer, adjusted on return to new length.
+ *
+ * @param Src       The variable to write.
+ * 
+ **************************************************************************
+**/
+static void toBuffer
+(
+   char * & DstPtr,
+   asize &   DstSiz,
+   long     Src
+)
+{
+   char Temp[40];
+   itoa( Src, Temp, 10 );
+   toBuffer( DstPtr, DstSiz, Temp );
+}
+
+
+
+/**
+ **************************************************************************
+ * 
+ * Write a new-line to a buffer.
+ * 
+ * @param DstPtr    Start of buffer, adjusted on return to next start.
+ * 
+ * @param DstSiz    Length of buffer, adjusted on return to new length.
+ * 
+ **************************************************************************
+**/
+static void toBufferNL
+(
+   char * & DstPtr,
+   asize &   DstSiz
+)
+{
+   toBuffer( DstPtr, DstSiz, "\n" );
+}
+
+
+
+/**
+ **************************************************************************
+ * 
+ * Write an aMap variable to a buffer.
+ * 
+ * @param DstPtr    Start of buffer, adjusted on return to next start.
+ * 
+ * @param DstSiz    Length of buffer, adjusted on return to new length.
+ * 
+ * @param Src       The aMap to be copied.
+ * 
+ * @param Lvl       The current tab level.
+ * 
+ * @param Tab       String to be used for mapObject separation.
+ * 
+ * @param Indent    String to be used as an indentation.
+ * 
+ * @param CutString String objects are cut before this offset (0 = no cut).
+ * 
+ **************************************************************************
+**/
+static void toBuffer
+(
+   char * &        DstPtr,
+   asize &          DstSiz,
+   aMap const &    Src,
+   int             Lvl,
+   aMap const &    Format,
+   char const *    Tab,
+   char const *    Indent,
+   unsigned long   CutString
+)
+{
+   const aObject *pKey = 0;
+   while( ( pKey = Src.getNextKey( pKey )) != 0 )
+   {
+      //
+      // Write indentation
+      //
+      toBuffer( DstPtr, DstSiz, Indent );
+      for( int i=0; i< Lvl; i++ )
+         toBuffer( DstPtr, DstSiz, Tab );
+
+      aObject Value = Src.get(*pKey);
+      char const * FormatPair = Format
+                                 .get( *pKey ).mapObject()
+                                 .get( Value ).strObject();
+      if( FormatPair )
+      {
+         //
+         // Format match -> write translation
+         //
+         toBuffer( DstPtr, DstSiz, FormatPair );
+         toBufferNL( DstPtr, DstSiz );
+      }
+      else
+      {
+         //
+         // No format match -> write key
+         //
+         switch( pKey->getTag() )
+         {
+         case OBJ_NIL:
+         case OBJ_DEL:
+            break;
+         case OBJ_NUM:
+            toBuffer( DstPtr, DstSiz, pKey->numObject() );
+            break;
+         case OBJ_STR:
+            toBuffer_F( DstPtr, DstSiz, pKey->strObject(), CutString );
+            break;
+         case OBJ_MAP:
+            break;
+         }
+         //
+         // Write value
+         //
+         switch( Src.get(*pKey).getTag() )
+         {
+         case OBJ_NIL:
+         case OBJ_DEL:
+            break;
+         case OBJ_NUM:
+            toBuffer( DstPtr, DstSiz, " = " );
+            toBuffer( DstPtr, DstSiz, Src.get(*pKey).numObject() );
+            toBufferNL( DstPtr, DstSiz );
+            break;
+         case OBJ_STR:
+            toBuffer( DstPtr, DstSiz, " = " );
+            toBuffer_F( DstPtr, DstSiz, Src.get(*pKey).strObject(), CutString );
+            toBufferNL( DstPtr, DstSiz );
+            break;
+         case OBJ_MAP:
+            toBuffer( DstPtr, DstSiz, " =" );
+            toBufferNL( DstPtr, DstSiz );
+            toBuffer
+            (
+               DstPtr, DstSiz,
+               Src.get(*pKey).mapObject(), Lvl + 1,
+               Format,
+               Tab, Indent, CutString
+            );
+            break;
+         }
+      }
+   }
+}
+
+
+
+/**
+ **************************************************************************
+ * 
+ * Write an aMap variable to a buffer.
+ * 
+ * @param DstPtr    Start of buffer, adjusted on return to next start.
+ * 
+ * @param DstSiz    Length of buffer, adjusted on return to new length.
+ * 
+ * @param Src       The aMap to be copied.
+ * 
+ * @param Lvl       The current tab level.
+ * 
+ * @param Tab       String to be used for mapObject separation.
+ * 
+ * @param Indent    String to be used as an indentation.
+ * 
+ * @param CutString String objects are cut before this offset (0 = no cut).
+ * 
+ **************************************************************************
+**/
+static void toBuffer
+(
+   char * &        DstPtr,
+   asize &          DstSiz,
+   aMap const &    Src,
+   int             Lvl,
+   char const *    Tab,
+   char const *    Indent,
+   unsigned long   CutString
+)
+{
+   const aObject *pKey = 0;
+   while( ( pKey = Src.getNextKey( pKey )) != 0 )
+   {
+      //
+      // Write indentation
+      //
+      toBuffer( DstPtr, DstSiz, Indent );
+      for( int i=0; i< Lvl; i++ )
+         toBuffer( DstPtr, DstSiz, Tab );
+      
+      //
+      // Write key
+      //
+      switch( pKey->getTag() )
+      {
+      case OBJ_NIL:
+      case OBJ_DEL:
+         break;
+      case OBJ_NUM:
+         toBuffer( DstPtr, DstSiz, pKey->numObject() );
+         break;
+      case OBJ_STR:
+         toBuffer_F( DstPtr, DstSiz, pKey->strObject(), CutString );
+         break;
+      case OBJ_MAP:
+         break;
+      }
+      //
+      // Write value
+      //
+      switch (Src.get(*pKey).getTag())
+      {
+      case OBJ_NIL:
+      case OBJ_DEL:
+         break;
+      case OBJ_NUM:
+         toBuffer( DstPtr, DstSiz, " = " );
+         toBuffer( DstPtr, DstSiz, Src.get(*pKey).numObject() );
+         toBufferNL( DstPtr, DstSiz );
+         break;
+      case OBJ_STR:
+         toBuffer( DstPtr, DstSiz, " = " );
+         toBuffer_F( DstPtr, DstSiz, Src.get(*pKey).strObject(), CutString );
+         toBufferNL( DstPtr, DstSiz );
+         break;
+      case OBJ_MAP:
+         toBuffer( DstPtr, DstSiz, " =" );
+         toBufferNL( DstPtr, DstSiz );
+         toBuffer
+         (
+            DstPtr, DstSiz,
+            Src.get(*pKey).mapObject(), Lvl + 1, Tab, Indent, CutString
+         );
+         break;
+      }
+   }
+}
+
+
+
+/**
+ **************************************************************************
+ * 
+ * Public function - see AssoCStr.hpp
+ * 
+ **************************************************************************
+**/
+asize assoCStr
+(
+   char *           DstBegin,
+   char const *     DstEnd,
+   aObject const &  Src,
+   aMap const &     Format,
+   char const *     Tab,
+   char const *     Indent,
+   unsigned long    CutString
+)
+{
+   asize DstSiz = DstEnd - DstBegin;
+   char * Dst = DstBegin;
+   switch( Src.getTag() )
+   {
+   case OBJ_NIL:
+   case OBJ_DEL:
+      break;
+   case OBJ_NUM:
+      toBuffer( Dst, DstSiz, Src.numObject() );
+      break;
+   case OBJ_STR:
+      toBuffer_F( Dst, DstSiz, Src.strObject(), CutString );
+      break;
+   case OBJ_MAP:
+      toBuffer
+      (
+         Dst, DstSiz,
+         Src.mapObject(), 1,
+         Format,
+         Tab, Indent, CutString
+      );
+      break;
+   }
+   if( Dst == DstEnd )
+   {
+      *(Dst-1) = 0;
+   }
+   else
+      *Dst = 0;
+   return Dst - DstBegin;
+}
+
+
+
+/**
+ **************************************************************************
+ * 
+ * Public function - see AssoCStr.hpp
+ * 
+ **************************************************************************
+**/
+asize assoCStr
+(
+   char *          DstBegin,
+   char const *    DstEnd,
+   aObject const & Src,
+   char const *    Tab,
+   char const *    Indent,
+   unsigned long   CutString
+)
+{
+   asize DstSiz = DstEnd - DstBegin;
+   char * Dst = DstBegin;
+   switch( Src.getTag() )
+   {
+   case OBJ_NIL:
+   case OBJ_DEL:
+      break;
+   case OBJ_NUM:
+      toBuffer( Dst, DstSiz, Src.numObject() );
+      break;
+   case OBJ_STR:
+      toBuffer_F( Dst, DstSiz, Src.strObject(), CutString );
+      break;
+   case OBJ_MAP:
+      toBuffer
+      (
+         Dst, DstSiz,
+         Src.mapObject(), 1,
+         Tab, Indent, CutString
+      );
+      break;
+   }
+   if( Dst == DstEnd )
+   {
+      *(Dst-1) = 0;
+   }
+   else
+      *Dst = 0;
+   return Dst - DstBegin;
+}
+
+
+
+/**
+ **************************************************************************
+ *
+ * Public function - see AssoCStr.hpp
+ * 
+ **************************************************************************
+**/
+asize assoCStrSize
+(
+   aObject const & Src,
+   char const *    Tab,
+   char const *    Indent,
+   unsigned long   CutString
+)
+{
+   char * N = 0;
+   asize DstSiz = INT_MAX;
+   switch( Src.getTag() )
+   {
+   case OBJ_NIL:
+   case OBJ_DEL:
+      break;
+   case OBJ_NUM:
+      toBuffer( N, DstSiz, Src.numObject() );
+      break;
+   case OBJ_STR:
+      toBuffer_F( N, DstSiz, Src.strObject(), CutString );
+      break;
+   case OBJ_MAP:
+      toBuffer( N, DstSiz, Src.mapObject(), 1, Tab, Indent, CutString );
+      break;
+   }
+   return INT_MAX - DstSiz + 1;
+}
+
+
+
+/**
+ **************************************************************************
+ * 
+ * End of file
+ * 
+ **************************************************************************
+**/
+
diff --git a/SelfServiceCommon/Massai/cpp/BillingService/makefile.mak b/SelfServiceCommon/Massai/cpp/BillingService/makefile.mak
index 15eddf8d..f7317cf4 100644
--- a/SelfServiceCommon/Massai/cpp/BillingService/makefile.mak
+++ b/SelfServiceCommon/Massai/cpp/BillingService/makefile.mak
@@ -34,7 +34,6 @@ MY_BIN1_OBJS = \
     $(_OBJ)\BillingService.obj \
     $(_OBJ)\BillingService_skel.obj \
     $(_OBJ)\File.obj \
-    $(_OBJ)\log.obj \
     $(_OBJ)\main.obj \
     $(_OBJ)\path.obj \
     $(_OBJ)\PrinterRsp.obj \
@@ -49,7 +48,8 @@ MY_BIN1_USER_LIBS = \
     $(LIB_MCORBA) \
     $(LIB_MCFGCLNT) \
     $(LIB_TRACE) \
-    $(LIB_SYSTOOLS)
+    $(LIB_SYSTOOLS) \
+    $(LIB_TOOLS)
 
 MY_BIN1_LINKLIBS = \
     $(SYS_ACETAO)
diff --git a/SelfServiceCommon/Massai/cpp/Graphic/makefile.mak b/SelfServiceCommon/Massai/cpp/Graphic/makefile.mak
index b29b0aee..045f5c00 100644
--- a/SelfServiceCommon/Massai/cpp/Graphic/makefile.mak
+++ b/SelfServiceCommon/Massai/cpp/Graphic/makefile.mak
@@ -24,7 +24,7 @@ MY_LIB1_OBJS =          $(_OBJ)\local_def.obj \
 
 MY_BIN1 =               $(_BIN)\TestBarcode128.exe
 
-MY_BIN1_USER_LIBS =     $(LIB_GRAPHIC) $(LIB_TOOLS) $(LIB_TEXT)
+MY_BIN1_USER_LIBS =     $(LIB_GRAPHIC) $(LIB_TEXT) $(LIB_TOOLS)
 
 MY_BIN1_OBJS =          $(_OBJ)\TestBarcode128.obj
 
@@ -32,7 +32,7 @@ MY_BIN1_OBJS =          $(_OBJ)\TestBarcode128.obj
 
 MY_BIN2 =               $(_BIN)\TestBarcode39.exe
 
-MY_BIN2_USER_LIBS =     $(LIB_GRAPHIC) $(LIB_TOOLS) $(LIB_TEXT)
+MY_BIN2_USER_LIBS =     $(LIB_GRAPHIC) $(LIB_TEXT) $(LIB_TOOLS)
 
 MY_BIN2_OBJS =          $(_OBJ)\TestBarcode39.obj
 
@@ -40,7 +40,7 @@ MY_BIN2_OBJS =          $(_OBJ)\TestBarcode39.obj
 
 MY_BIN3 =               $(_BIN)\TestBarcodeIndustrial2of5.exe
 
-MY_BIN3_USER_LIBS =     $(LIB_GRAPHIC) $(LIB_TOOLS) $(LIB_TEXT)
+MY_BIN3_USER_LIBS =     $(LIB_GRAPHIC) $(LIB_TEXT) $(LIB_TOOLS)
 
 MY_BIN3_OBJS =          $(_OBJ)\TestBarcodeIndustrial2of5.obj
 
diff --git a/SelfServiceCommon/Massai/cpp/LogService/makefile.mak b/SelfServiceCommon/Massai/cpp/LogService/makefile.mak
index c520dede..f67f2c68 100644
--- a/SelfServiceCommon/Massai/cpp/LogService/makefile.mak
+++ b/SelfServiceCommon/Massai/cpp/LogService/makefile.mak
@@ -83,7 +83,6 @@ MY_DLL2_RES = \
 
 MY_DLL2_OBJS = \
     $(STATLOG_OBJS) \
-    $(_OBJ)\asso.obj \
     $(_OBJ)\cfgTextListGCL.obj \
     $(_OBJ)\configSNMP.obj \
     $(_OBJ)\configStatistics.obj \
@@ -110,7 +109,8 @@ MY_DLL2_LDFLAGS = \
 MY_DLL2_USER_LIBS = \
     $(STDUSERLIBS) \
     $(LIB_ALERTS) \
-    $(LIB_MGMTAPI)
+    $(LIB_MGMTAPI) \
+    $(LIB_ASSO)
 
 MY_DLL2_LINKLIBS = \
     $(STDLINKLIBS) \
@@ -129,7 +129,6 @@ MY_BIN1_RES = \
 
 MY_BIN1_OBJS = \
     $(STATLOG_OBJS) \
-    $(_OBJ)\asso.obj \
     $(_OBJ)\cfgTextListGCL.obj \
     $(_OBJ)\configSNMP.obj \
     $(_OBJ)\configStatistics.obj\
@@ -150,7 +149,8 @@ MY_BIN1_OBJS = \
 
 MY_BIN1_USER_LIBS = \
     $(STDUSERLIBS) \
-    $(LIB_ALERTS)
+    $(LIB_ALERTS) \
+    $(LIB_ASSO)
 
 MY_BIN1_LINKLIBS = \
     $(STDLINKLIBS)
@@ -289,7 +289,6 @@ MY_BIN8 = \
     $(_BIN)\SnmpCfgCreate.exe
 
 MY_BIN8_OBJS = \
-    $(_OBJ)\asso.obj \
     $(_OBJ)\cfgTextListGCL.obj \
     $(_OBJ)\configSNMP.obj \
     $(_OBJ)\dataID.obj \
@@ -298,7 +297,8 @@ MY_BIN8_OBJS = \
 
 MY_BIN8_USER_LIBS = \
     $(STDUSERLIBS) \
-    $(LIB_ALERTS)
+    $(LIB_ALERTS) \
+    $(LIB_ASSO)
 
 MY_BIN8_LINKLIBS = \
     $(STDLINKLIBS)
diff --git a/SelfServiceCommon/Massai/cpp/LogService/src/Asso.cpp b/SelfServiceCommon/Massai/cpp/LogService/src/Asso.cpp
deleted file mode 100644
index 7ac1b517..00000000
--- a/SelfServiceCommon/Massai/cpp/LogService/src/Asso.cpp
+++ /dev/null
@@ -1,494 +0,0 @@
-/*
- * ASSO.CPP
- *
- * associative array class
- *
- * history:
- * KW 8/97: initial coding
- * 090597rb use refcnt
- * 150997rb getFirstKey/getLastKey correct: none objects (DEL/NIL)
- *          have no key!!
- * 220997rb mapObject returns always a correct object
- * 161297rb aObject((char*)0) creates an deleted object
- * 130198rb OBJ_DEL behaviour corrected
- * 050298rb aObject is able to handle binaery memory
- * 120298rb remove getFirstKey method
- * 110398rb fix self assignment problem e.g. a = a.get( "hello" );
- * 020999rbts fix clear key problem e.g. a.set( "hello", aObject() ); - same behaviour as a.set( "hello", (char *)0 );
- * 210700rbts fix memory leak for copy constructor of aMap
- * 250700rbts use -D_MULTI_THREAD definition to use critical sections within all public member functions
- * 260700rb   add UNLOCK for each required function return
- *
- * next changes:
- *
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "asso.h"
-
-#define MIN_SIZE        (13)
-enum { FALSE, TRUE };
-
-#ifdef  _MULTI_THREAD
-
-#include "mutex.hpp"
-
-static mutexSemaphore asso_mx;
-
-
-#define LOCK()      asso_mx.request()
-#define UNLOCK()    asso_mx.release()
-
-#else
-#define LOCK()
-#define UNLOCK()
-
-#endif
-
-
-
-class _aMap;
-
-struct oBuf
-{
-  long  lSize;
-  char *pData;
-  oBuf( const char *s, long len )
-  {
-    if(len)
-    {
-      lSize = len;
-      pData = new char[lSize+1];
-      memcpy(pData, s, len);
-      pData[len] = 0;     // trailing zero!!
-    }
-    else
-    {
-      lSize = 0; pData = 0;
-    }
-  }
-  ~oBuf() { delete pData; }
-};
-
-union ObjV
-{
-  long    v_num;
-  oBuf   *v_str;
-  _aMap  *v_map;
-};
-
-//
-// the _aBuf class gives/hides access to information
-//
-class _aMap
-{
-public:
-  struct pair {
-    aObject    key;
-    aObject    val;
-  };
-
-  pair    *sTab;
-  short    limit,       // table size
-           used,
-           fence,
-           bgrow;
-
-  _aMap( const long n )
-  {
-    fence = (short)n;
-    if( fence < 3 ) fence = 3;
-    used = bgrow = 0;
-    limit =(short)((fence * 10)/7);
-    sTab = new pair[limit];
-  }
-
-  _aMap( const _aMap& src )
-  {
-    fence = src.fence; bgrow = 0;
-    used  = src.used;
-    limit = src.limit;
-    sTab = new pair[limit];
-    for(long i=0; i<limit; i++)
-    { // copy contents
-      sTab[i].key = src.sTab[i].key;
-      sTab[i].val = src.sTab[i].val;
-    }
-  }
-
-  ~_aMap() { delete [] sTab; }
-
-};
-
-class _aObject
-{
-  public:
-  int   refcnt;
-  ObjT  tag;
-  ObjV  val;
-  _aObject()           { tag = OBJ_NIL; refcnt = 1;}
-  ~_aObject()
-  {
-    switch( tag )
-    {
-      case OBJ_STR: delete    val.v_str;  break;
-      case OBJ_MAP: delete    val.v_map; break;
-    }
-  }
-};
-
-aMap::aMap(): aObject()
-{
-  LOCK();
-  handle->tag= OBJ_MAP;
-  handle->val.v_map = new _aMap(MIN_SIZE);
-  UNLOCK();
-}
-
-aMap::aMap(long n): aObject()
-{
-  LOCK();
-  handle->tag= OBJ_MAP;
-  handle->val.v_map = new _aMap(n);
-  UNLOCK();
-}
-
-// copy constructor
-aMap::aMap( const aMap &src ) /* : aObject() */
-{
-  LOCK();
-  delete handle;
-  handle = src.handle;
-  handle->refcnt++;
-  UNLOCK();
-}
-
-aMap::~aMap()
-{ // do nothing - reference freed by aObject destructor!!
-}
-
-static long hash( const char *s, long cnt )
-{
-  char *p = (char *) s;
-  long sum = 0;
-  while( cnt-- )
-    sum = ((sum<<5)-sum)^(unsigned char) *p++;
-  return sum;
-}
-
-static inline long equalObj( const aObject& a, const aObject& b)
-{
-  ObjT atag = a.getTag();
-  if( atag != b.getTag() ) return FALSE;
-  switch( atag )
-  {
-    case OBJ_NUM: return a.numObject() == b.numObject();
-    case OBJ_STR: return !strcmp(a.strObject(), b.strObject());
-    case OBJ_MAP: return &a.mapObject() == &b.mapObject();
-  }
-  return FALSE;
-}
-
-static long hashindex( _aMap& tab, const aObject& key)
-{
-  long n;
-  switch( key.getTag() )
-  {
-    case OBJ_NUM:       n = key.numObject(); break;
-    case OBJ_STR:       n = hash(key.strObject(), key.count()); break;
-    case OBJ_MAP:       n = (long)&key.mapObject(); break;
-    default:            n = 0; break;
-  }
-  if( n < 0 ) n = -n;
-  return n % tab.limit;
-}
-
-_aMap::pair& getEntry( _aMap& tab, long index, const aObject& key )
-{
-  long lOldIndex = index;
-  long lLastDel = index;
-  ObjT ttag;
-
-  while( (ttag = tab.sTab[index].val.getTag()) != OBJ_NIL )
-  { // collision or hit
-    if(equalObj(tab.sTab[index].key, key))
-      return tab.sTab[index];
-
-    if(ttag == OBJ_DEL)
-      lLastDel = index;
-
-    index = (index+1) % tab.limit;
-
-    if (index == lOldIndex)  // endless loop detected return last DEL-object
-    {
-      index = lLastDel;
-      break;
-    }
-  }
-  tab.sTab[index].key = key;
-  return tab.sTab[index];
-}
-
-aObject::aObject()
-{
-  LOCK();
-  handle = new _aObject();
-  UNLOCK();
-}
-
-aObject::aObject( const long val )
-{
-  LOCK();
-  handle = new _aObject();
-  *this = val;
-  UNLOCK();
-}
-
-aObject::aObject( const char *val )
-{
-  LOCK();
-  handle = new _aObject();
-  *this = val;
-  UNLOCK();
-}
-
-aObject::aObject( const char *val, long len )
-{
-  LOCK();
-  handle = new _aObject();
-  if( len )
-  {
-    handle->tag = OBJ_STR;
-    handle->val.v_str = new oBuf(val, len);
-  }
-  UNLOCK();
-}
-
-aObject::aObject(const aObject& obj)
-{
-  LOCK();
-  handle = obj.handle;
-  handle->refcnt++;
-  UNLOCK();
-}
-
-ObjT aObject::getTag() const
-{
-  return handle->tag;
-}
-
-// returns FALS if object contains data
-long aObject::isEmpty()   const
-{
-  return (handle->tag < OBJ_NUM);
-}
-
-long aObject::count() const
-{
-  switch( handle->tag )
-  {
-    case OBJ_STR: return handle->val.v_str->lSize;
-    case OBJ_NUM: return sizeof(long);
-    case OBJ_MAP: return handle->val.v_map->used;
-  }
-  return 0;
-}
-
-const char *aObject::strObject() const
-{
-   return (handle->tag == OBJ_STR)? handle->val.v_str->pData: NULL;
-}
-
-long        aObject::numObject() const
-{
-  return (handle->tag == OBJ_NUM)? handle->val.v_num: -1;
-}
-
-// 220897rb return empty object if no OBJ_MAP tag
-aMap&       aObject::mapObject() const
-{
-  LOCK();
-  if(handle->tag == OBJ_MAP)
-  {
-    UNLOCK();
-    return (aMap&) *this;
-  }
-  static aMap dum;
-  dum.clr();
-  UNLOCK();
-  return dum;
-}
-
-aObject::~aObject()
-{  // release memory if allocated
-  LOCK();
-  if( !(--(handle->refcnt)))
-  {
-    delete handle;
-    handle = 0;
-  }
-  UNLOCK();
-}
-
-// clear whole contents
-long aObject::clr()
-{
-  LOCK();
-  ObjT tag = handle->tag;
-  if( !(--(handle->refcnt)))
-    delete handle;
-  handle = new _aObject();
-  if( tag == OBJ_MAP )
-  {
-    handle->tag= OBJ_MAP;
-    handle->val.v_map = new _aMap(MIN_SIZE);
-  }
-  UNLOCK();
-  return 0;
-}
-
-aObject& aObject::operator=(const aObject& obj)
-{
-  LOCK();
-  if( this != &obj )
-  {  // release memory if allocated
-    obj.handle->refcnt++; // lock
-    if( !(--(handle->refcnt)))
-      delete handle;
-    obj.handle->refcnt--; // unlock
-    handle = obj.handle;
-    handle->refcnt++;
-  }
-  UNLOCK();
-  return *this;
-}
-
-aObject& aObject::operator=(const char *str)
-{  // release memory if allocated
-  LOCK();
-  if( !(--(handle->refcnt)))
-    delete handle;
-  handle = new _aObject();
-  if( str )
-  {
-    handle->tag = OBJ_STR;
-    handle->val.v_str = new oBuf(str, strlen(str) + 1);
-  }
-  else
-  { // 161297rb mark as deleted
-    handle->tag = OBJ_DEL;
-  }
-  UNLOCK();
-  return *this;
-}
-
-aObject& aObject::operator=(long n)
-{  // release memory if allocated
-  LOCK();
-  if( !(--(handle->refcnt)))
-    delete handle;
-  handle = new _aObject();
-  handle->tag = OBJ_NUM;
-  handle->val.v_num = n;
-  UNLOCK();
-  return *this;
-}
-
-aMap& aMap::set( const aObject& key, const aObject& val)
-{
-  LOCK();
-  int reorg = 0;
-  aObject cpval = val;           // temporary copy
-  if( handle->refcnt > 1)
-  { // make a copy
-    _aMap *pHlp = handle->val.v_map;
-
-    handle->refcnt--;   // release ref
-    handle = new _aObject();
-    handle->tag= OBJ_MAP;
-    handle->val.v_map = new _aMap(*pHlp);
-  }
-
-  _aMap& d = *handle->val.v_map;
-  _aMap::pair& o= getEntry(*handle->val.v_map, hashindex(*handle->val.v_map, key), key);
-  if( o.val.getTag() <= OBJ_DEL )
-  { // entry not found
-    if( val.getTag() > OBJ_DEL)
-    { // new entry
-      if(++d.used == d.fence )
-        reorg = 1;      // grow
-    }
-  }
-  else
-  { // entry found
-    if(val.getTag() <= OBJ_DEL)
-    { // entry deleted
-      o.key = (char *)0;
-      cpval = (char *)0;
-      if(--d.used < d.limit/4 && d.bgrow)
-        reorg = 2;      // shrink
-    }
-  }
-  o.val = cpval;
-  if( reorg )
-  {
-    if( reorg == 1 )
-    { // grow
-      handle->val.v_map = new _aMap(d.limit << 1);
-      handle->val.v_map->bgrow = TRUE;
-    }
-    else
-    { // shrink
-      handle->val.v_map = new _aMap(d.limit >> 1);
-    }
-    for( long i=0; i<d.limit; i++ )
-      if(d.sTab[i].val.getTag() >= OBJ_NUM )
-        set(d.sTab[i].key, d.sTab[i].val);
-    delete &d;  // to be checked!!!
-  }
-  UNLOCK();
-
-  return(*this);
-}
-
-aMap& aMap::add( const aObject& key, const aObject& val)
-{
-    return(set(key,val));
-}
-
-const aObject& aMap::get( const aObject& key) const
-{
-  LOCK();
-  const aObject& e = getEntry(*handle->val.v_map, hashindex(*handle->val.v_map, key), key).val;
-  UNLOCK();
-  return e;
-}
-
-const aObject   *aMap::getNextKey (const aObject *pKey) const
-{
-  LOCK();
-  long index = 0;
-  _aMap& d = *handle->val.v_map;
-  if(pKey)
-  {
-/* search pKey */
-    index = hashindex(d, *pKey);
-    while( &d.sTab[index].key != pKey )
-      index = (index+1) % d.limit;
-/* step on */
-    index++;
-  }
-  for( long i=index; i<d.limit; i++ )
-    if(d.sTab[i].val.getTag() >= OBJ_NUM )
-    {
-      UNLOCK();
-      return &d.sTab[i].key;
-    }
-  UNLOCK();
-  return 0;
-}
-/*
-** *** end of file ***
-*/
diff --git a/SelfServiceCommon/Massai/cpp/SerialCon/make.dep b/SelfServiceCommon/Massai/cpp/SerialCon/make.dep
new file mode 100644
index 00000000..036db01e
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/SerialCon/make.dep
@@ -0,0 +1,59 @@
+# Do not edit this file! It is automatically generated. Changes will be lost.
+
+out/MassaiDevice.obj: \
+	src/MassaiDevice.cpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/generic/pImplPtr.h \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/generic/pImplPtr.h \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/TraceClt.h \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/TraceClt.h \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/cfgclnt/nConfig.hpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/cfgclnt/nConfigText.hpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/mArgScan.hpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/mArgScan.hpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/massai.hpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/massai.hpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServicePlatform/Interfaces/inc/DevicesCommon/MassaiDevice.hpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServicePlatform/Interfaces/inc/DevicesCommon/devicesDotStrDotStr.hpp
+
+out/cfgUART.obj: \
+	src/cfgUART.cpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/generic/pImplPtr.h \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/generic/pImplPtr.h \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/cfgUART.hpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/cfgUART.hpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/cfgclnt/nConfig.hpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/cfgclnt/nConfigCache.hpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/cfgclnt/nConfigText.hpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServicePlatform/Interfaces/inc/DevicesCommon/tRexLookupComport.hpp
+
+out/durationControl.obj: \
+	src/durationControl.cpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/durationControl.hpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/durationControl.hpp
+
+out/mIEtxAckAsy.obj: \
+	src/mIEtxAckAsy.cpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/generic/fsm/mFMTQueue.hpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/ASCII.h \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/ASCII.h \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/TraceClt.h \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/TraceClt.h \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/mEventSem.hpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/mEventSem.hpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/mMutexSem.hpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/mMutexSem.hpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/matAsync.h \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/matAsync.h \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/matThread.hpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/matThread.hpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServicePlatform/Interfaces/inc/ATB/atbMessage.hpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServicePlatform/Interfaces/inc/ATB/mIEtxAck.hpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServicePlatform/Interfaces/inc/DevicesCommon/mPEtxAck.hpp \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServicePlatform/Interfaces/inc/DevicesCommon/mPTrace.hpp
+
+out/matAsyncW32.obj: \
+	src/matAsyncW32.c \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/cfgclnt/mHRTimer.h \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/matAsync.h \
+	C:/dev/Massai/SelfServiceAPP_CLA/trunk/SelfServiceCommon/Interfaces/inc/matAsync.h
+
diff --git a/SelfServiceCommon/Massai/cpp/SerialCon/makefile.mak b/SelfServiceCommon/Massai/cpp/SerialCon/makefile.mak
new file mode 100644
index 00000000..b639a9ae
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/SerialCon/makefile.mak
@@ -0,0 +1,28 @@
+######################################################################
+#
+# /vob/SelfServicePlatform/Massai/cpp/SerialCon/makefile.mak
+#
+######################################################################
+
+!include $(BUILDROOT)\Build\cpp\makefile.common.mak
+
+MY_CFLAGS = \
+    -Gi -GR -G5 \
+    -DUSE_TRACE_CLIENT \
+    $(INC_INTERFACES)
+
+######################################################################
+
+MY_LIB1 = \
+    $(LIB_SERIALCON)
+
+MY_LIB1_OBJS = \
+    $(_OBJ)\MassaiDevice.obj \
+    $(_OBJ)\matAsyncW32.obj \
+    $(_OBJ)\mIEtxAckAsy.obj \
+    $(_OBJ)\cfgUART.obj \
+    $(_OBJ)\durationControl.obj
+
+######################################################################
+
+!include $(BUILDROOT)\Build\cpp\makefile.rules.mak
diff --git a/SelfServiceCommon/Massai/cpp/SerialCon/src/MassaiDevice.cpp b/SelfServiceCommon/Massai/cpp/SerialCon/src/MassaiDevice.cpp
new file mode 100644
index 00000000..519062cb
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/SerialCon/src/MassaiDevice.cpp
@@ -0,0 +1,306 @@
+/**
+ **************************************************************************
+ *
+ * @file MassaiDevice.cpp
+ *
+ * Massai device tools.
+ *
+ * @author Juergen Kreierhoff
+ *
+ * Copyright (c) 2002-2005 MATERNA Information & Communications
+ *
+ **************************************************************************
+**/
+
+#if defined(_MSC_VER)
+// Exception specification ignored
+#pragma warning (disable : 4290)
+#endif /* _MSC_VER */
+
+
+
+#include "MassaiDevice.hpp"
+
+#include "traceClt.h"
+
+#ifdef USE_MASSAICFG
+#include "massai.hpp"
+#else
+#include "nConfigText.hpp"
+#endif
+
+#include "devicesDotStrDotStr.hpp"
+
+
+
+namespace
+{
+
+
+
+   class portConfigExplanation
+   {
+      std::string M_Str;
+
+   public:
+
+      explicit portConfigExplanation( char const * Configurable ) :
+         M_Str()
+      {
+         M_Str =
+            "Asynchroneous serial port for device communication."
+            " SYNTAX: port";
+         std::string XEnd = "";
+         std::string XX = ". EXAMPLE: com1";
+         if( Configurable )
+         {
+            unsigned Off = 0;
+            while( Configurable[Off] )
+            {
+               switch( Configurable[Off] )
+               {
+               case 'B':
+                  M_Str += "[:speed";
+                  XX += ":9600";
+                  break;
+               case 'P':
+                  M_Str += "[parity";
+                  XX += "n";
+                  break;
+               case 'D':
+                  M_Str += "[databits";
+                  XX += "8";
+                  break;
+               case 'S':
+                  M_Str += "[stopbits";
+                  XX += "1";
+                  break;
+               default:
+                  M_Str += "[?";
+                  XX += "?";
+               }
+               ++Off;
+               XEnd += "]";
+            }
+         }
+         M_Str += XEnd;
+         M_Str += XX;
+      }
+
+      portConfigExplanation();
+
+      virtual ~portConfigExplanation()
+      {
+      }
+
+      char const * c_str() const
+      {
+         return M_Str.c_str();
+      }
+   };
+
+
+
+#ifndef USE_MASSAICFG
+
+   class textItem :
+      public portConfigExplanation,
+      public devicesDotStrDotStr,
+      public nConfig::gcText
+   {
+
+      void create( char const * & R, char const * & X, char const * & D )
+      {
+         R = "rwl";
+         X = portConfigExplanation::c_str();
+         D = "COM1";
+      }
+
+   public:
+
+      textItem
+      (
+         char const * DevName,
+         char const * ItmName,
+         char const * Configurable
+      ) :
+         portConfigExplanation( Configurable ),
+         devicesDotStrDotStr( DevName, ItmName ),
+         nConfig::gcText( devicesDotStrDotStr::c_str(), DevName )
+      {
+      }
+
+      textItem();
+
+   };
+
+#endif
+
+
+}
+
+
+
+/**
+ *
+ * (see MassaiDevice.hpp)
+ *
+ */
+void Materna::MassaiDevice::warning
+(
+   char const * Msg,
+   char const * Detail
+)
+{
+   std::string Str( Msg );
+   if( Detail )
+   {
+      Str += " (";
+      Str += Detail;
+      Str += ")";
+   }
+   writeTraceText( MajorWarning_HERE, Str.c_str() );
+   std::cerr << Str.c_str() << std::endl;
+}
+
+
+
+/**
+ *
+ * (see MassaiDevice.hpp)
+ *
+ */
+Materna::MassaiDevice::params::params
+(
+   int argc, char ** argv,
+   char const * DefName
+) :
+   argScan( argc, argv ),
+   M_Sub( DefName )
+{
+   char const * Sub = argument( 1 );
+   if( Sub )
+   {
+      M_Sub = Sub;
+   }
+}
+
+
+
+/**
+ *
+ * (see MassaiDevice.hpp)
+ *
+ */
+char const * Materna::MassaiDevice::params::comport
+(
+   char const * Item,
+   char const * Configurable
+)
+{
+   if( !M_Sub.c_str() )
+      return 0;
+   char const * Val = option( Item );
+   if( Val )
+      return Val;
+   else
+#ifdef USE_MASSAICFG
+   {
+      static char Buffer[128];
+      mConfig Cfg
+      (
+         "DEVICES",
+         const_cast<char *>( M_Sub.c_str() ),
+         const_cast<char *>( Item )
+      );
+      Buffer[0] = 0;
+      Cfg.asString( Buffer, sizeof(Buffer) );
+      if( Buffer[0] )
+         return Buffer;
+      else
+         return 0;
+   }
+#else
+   {
+      static std::string S_String;
+      textItem Text( M_Sub.c_str(), Item, Configurable );
+      S_String = Text.get();
+      return S_String.c_str();
+   }
+#endif
+}
+
+
+
+/**
+ *
+ * (see MassaiDevice.hpp)
+ *
+ */
+Materna::MassaiDevice::parseAsyncConfig::parseAsyncConfig
+(
+   char const * Src
+)
+{
+   strcpy( M_Port, "\\\\.\\COM1" );
+   strcpy( M_Speed, "9600" );
+   M_Parity[0] = 'N';
+   M_Parity[1] = 0;
+   M_Databits[0] = '8';
+   M_Databits[1] = 0;
+   M_Stopbits[0] = '1';
+   M_Stopbits[1] = 0;
+   if( Src )
+   {
+      char * DstPtr;
+      int    DstLen;
+      //
+      // Get port name (e.g. "\\.\COM1")
+      //
+      DstPtr = M_Port + 4;
+      DstLen = sizeof(M_Port) - 4 - 1;
+      while( *Src && ( *Src != ':') && DstLen-- )
+         *DstPtr++ = *Src++;
+      *DstPtr = 0;
+      if( *Src == ':' )
+         ++Src;
+      //
+      // Get speed
+      //
+      if( *Src )
+      {
+         DstPtr = M_Speed;
+         DstLen = sizeof(M_Speed) -1;
+         while( ( *Src >= '0' ) && ( *Src <= '9' ) && DstLen-- )
+            *DstPtr++ = *Src++;
+         *DstPtr = 0;
+      }
+      //
+      // Get parity
+      //
+      if( *Src )
+         M_Parity[0] = static_cast<char>(*Src++ & 0x5F);
+      //
+      // Get databits
+      //
+      if( *Src )
+         M_Databits[0] = *Src++;
+      //
+      // Get stopbits
+      //
+      if( *Src )
+         M_Stopbits[0] = *Src;
+   }
+}
+
+
+
+
+/**
+ **************************************************************************
+ *
+ * End of file
+ *
+ **************************************************************************
+**/
+
diff --git a/SelfServiceCommon/Massai/cpp/SerialCon/src/cfgUART.cpp b/SelfServiceCommon/Massai/cpp/SerialCon/src/cfgUART.cpp
new file mode 100644
index 00000000..cf15c1d8
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/SerialCon/src/cfgUART.cpp
@@ -0,0 +1,280 @@
+/**
+ **************************************************************************
+ *
+ * @file cfgUART.cpp
+ *
+ * Contains implementation of class cfgUART.
+ *
+ * @author Juergen Kreierhoff
+ *
+ * Copyright (c) 2006-2008 MATERNA Information & Communications
+ *
+ **************************************************************************
+**/
+#include "cfgUART.hpp"
+
+#include "nConfigCache.hpp"
+#include "nConfigText.hpp"
+#include "tRexLookupComport.hpp"
+
+
+/**
+ *
+ * Implementation handle class.
+ *
+**/
+class cfgUART::impl :
+   public nConfig::cache<std::string,nConfig::gclText>
+{
+
+   //! Has the configuration changed since last asking?
+   bool         M_Changed;
+
+   //! The explanation for the port configuration.
+   std::string  M_Explanation;
+
+   //! The returned port name.
+   std::string M_Returned;
+
+   /**
+    *
+    * This method is called e.g. at configuratiuon change.
+    *
+   **/
+   std::string uncached()
+   {
+      M_Changed = true;
+      return get();
+   }
+
+protected:
+
+   /**
+    *
+    * This method is called, when the configuration subsystem needs to
+    * create a new configuration item.
+    *
+   **/
+   void create
+   (
+      char const * & Rights,
+      char const * & Explanation,
+      char const * & Default
+   )
+   {
+      Rights = "rwl";
+      Explanation = M_Explanation.c_str();
+      Default = "";
+   }
+
+public:
+
+   /**
+    *
+    * Constructor.
+    *
+    * @param ConnDevice:        Names the connected device.
+    *
+    * @param CfgClient:         The client name to use for configuration.
+    *
+    * @param CfgPortItem:       The item name of the configuration.
+    *
+   **/
+   impl
+   (
+      char const * ConnDevice,
+      char const * CfgClient,
+      char const * CfgPortItem
+   ) :
+      nConfig::cache<std::string,nConfig::gclText>
+         (
+            CfgPortItem,
+            CfgClient
+         ),
+      M_Changed( true ),
+      M_Explanation(),
+      M_Returned()
+   {
+      M_Explanation = "Specify the serial port for the ";
+      M_Explanation += ConnDevice;
+      M_Explanation += " link."
+         "\nYou can name the port directly (e.g. \"COM1\")."
+         "\nYou can also specify a unique substring of the device key"
+         " (e.g. VID_0403+PID_6001). Please use the LookupComport tool"
+         " for a suitable choice. The configuration entry the is to be"
+         " prefixed with \"-DEV:\" (e.g. \"-DEV:VID_0403+PID_6001\"). ";
+   }
+
+   /**
+    *
+    * Has the configuration changed?
+    *
+   **/
+   bool changed()
+   {
+      if( M_Changed )
+      {
+         M_Changed = false;
+         return true;
+      }
+      else
+      {
+         return false;
+      }
+   }
+
+   /**
+    *
+    * Return the configured port name.
+    *
+   **/
+   char const * getPort()
+   {
+      return cached().c_str();
+   }
+
+   /**
+    *
+    * Return the configured port name.
+    *
+   **/
+   char const * getPortExtended()
+   {
+      std::string PortCfg = cached();
+      std::string PortRaw;
+      if (
+         ( PortCfg.size() > 5 ) &&
+         ( PortCfg[0] == '-' ) &&
+         ( PortCfg[1] == 'D' ) &&
+         ( PortCfg[2] == 'E' ) &&
+         ( PortCfg[3] == 'V' ) &&
+         ( PortCfg[4] == ':' )
+         )
+      {
+         // Device specification configured, use the remainder
+         // of the configured string as a lookup key.
+         std::string const Key = PortCfg.substr( 5 );
+         comports Result;
+         tRexLookupComport( Result, Key );
+         if( Result.size() == 1 )
+         {
+            PortRaw = Result.begin()->c_str();
+         }
+      }
+      else
+      {
+         PortRaw = PortCfg;
+      }
+      if (
+         ( PortRaw.size() > 4 ) &&
+         ( ( 0x20 | PortRaw[0] ) == 'c' ) &&
+         ( ( 0x20 | PortRaw[1] ) == 'o' ) &&
+         ( ( 0x20 | PortRaw[2] ) == 'm' )
+         )
+      {
+         // Double-digit comports need a \\.\ prefix
+         M_Returned = "\\\\.\\";
+      }
+      else
+      {
+         M_Returned = "";
+      }
+      M_Returned += PortRaw;
+      return M_Returned.c_str();
+   }
+
+private:
+
+   //! Default constructor - intentionally not implemented.
+   impl();
+
+   //! Copy constructor - intentionally not implemented.
+   impl( impl const & );
+
+   //! Assignment - intentionally not implemented.
+   impl & operator=( impl const & );
+
+};
+
+
+
+/*
+ *
+ * Method implementation, see "cfgUART.hpp".
+ *
+ */
+cfgUART::cfgUART
+(
+   char const * ConnDevice,
+   char const * CfgClient,
+   char const * CfgPortItem
+) :
+   M_Impl( new cfgUART::impl( ConnDevice, CfgClient, CfgPortItem ) )
+{
+}
+
+
+
+/*
+ *
+ * Method implementation, see "cfgUART.hpp".
+ *
+ */
+cfgUART::~cfgUART
+(
+)
+{
+   try
+   {
+      delete M_Impl;
+   }
+   catch( ... )
+   {
+   }
+}
+
+
+
+/*
+ *
+ * Method implementation, see "cfgUART.hpp".
+ *
+ */
+bool cfgUART::changed()
+{
+   return M_Impl->changed();
+}
+
+
+
+/*
+ *
+ * Method implementation, see "cfgUART.hpp".
+ *
+ */
+char const * cfgUART::getPort() const
+{
+   return M_Impl->getPort();
+}
+
+
+
+/*
+ *
+ * Method implementation, see "cfgUART.hpp".
+ *
+ */
+char const * cfgUART::getPortExtended() const
+{
+   return M_Impl->getPortExtended();
+}
+
+
+
+/**
+ **************************************************************************
+ *
+ * End of file
+ *
+ **************************************************************************
+**/
diff --git a/SelfServiceCommon/Massai/cpp/SerialCon/src/durationControl.cpp b/SelfServiceCommon/Massai/cpp/SerialCon/src/durationControl.cpp
new file mode 100644
index 00000000..c6121b1e
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/SerialCon/src/durationControl.cpp
@@ -0,0 +1,107 @@
+/**
+ **************************************************************************
+ *
+ * @file durationControl.cpp
+ *
+ * Call duration control tool.
+ *
+ * @author Juergen Kreierhoff
+ *
+ * Copyright (c) 2008 MATERNA Information & Communications.
+ *
+ **************************************************************************
+**/
+
+
+
+#include "durationControl.hpp"
+
+
+
+/*
+ * Class method - see "durationControl.hpp".
+ */
+void durationControl::function()
+{
+   M_SemBegin.wait();
+   while( M_Active )
+   {
+      M_SemBegin.reset();
+      if( M_SemEnd.wait( M_DurationMS ) )
+      {
+         durationControlTimeout();
+      }
+      M_SemEnd.reset();
+      M_SemRet.post();
+      M_SemBegin.wait();
+   }
+}
+
+
+
+/*
+ * Class method - see "durationControl.hpp".
+ */
+durationControl::durationControl( unsigned DurationMS ) :
+   matThread(),
+   M_Active( true ),
+   M_DurationMS( DurationMS ),
+   M_Mutex(),
+   M_SemRet(),
+   M_SemBegin(),
+   M_SemEnd()
+{
+   start();
+}
+
+
+
+/*
+ * Class method - see "durationControl.hpp".
+ */
+durationControl::~durationControl() throw()
+{
+   try
+   {
+      M_Active = false;
+      M_SemBegin.post();
+      waitTerminated();
+   }
+   catch( ... )
+   {
+   }
+}
+
+
+
+/*
+ * Class method - see "durationControl.hpp".
+ */
+void durationControl::durationControlBegin()
+{
+   M_Mutex.request();
+   M_SemBegin.post();
+}
+
+
+
+/*
+ * Class method - see "durationControl.hpp".
+ */
+void durationControl::durationControlEnd()
+{
+   M_SemEnd.post();
+   M_SemRet.wait();
+   M_SemRet.reset();
+   M_Mutex.release();
+}
+
+
+
+/*
+ **************************************************************************
+ *
+ * End of file.
+ *
+ **************************************************************************
+*/
diff --git a/SelfServiceCommon/Massai/cpp/SerialCon/src/mIEtxAckAsy.cpp b/SelfServiceCommon/Massai/cpp/SerialCon/src/mIEtxAckAsy.cpp
new file mode 100644
index 00000000..2cfff035
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/SerialCon/src/mIEtxAckAsy.cpp
@@ -0,0 +1,426 @@
+/**
+ **************************************************************************
+ *
+ * @file mIEtxAckAsy.cpp
+ *
+ * Implementation of ETX-ACK protocol over async interface.
+ *
+ * @author Juergen Kreierhoff
+ *
+ * Copyright (c) 2001-2004 MATERNA Information & Communications
+ *
+ **************************************************************************
+**/
+
+#if defined(_MSC_VER)
+// Exception specification ignored
+#pragma warning (disable : 4290)
+#endif /* _MSC_VER */
+
+
+
+#include "mIEtxAck.hpp"
+
+#include "mPEtxack.hpp"
+
+#ifdef USE_TRACE_CLIENT
+#include "mPTrace.hpp"
+#endif
+
+#include "matAsync.h"
+#include "matThread.hpp"
+
+
+
+//! Protocol type
+typedef mPEtxAck<matAsync,atbMessage>      xProtocol;
+
+#ifdef USE_TRACE_CLIENT
+//! Returncode type
+typedef mPEtxAck<matAsync,atbMessage>::RC  xRC;
+#endif
+
+
+
+
+/**
+ *
+ * Handle class.
+ *
+**/
+class mIEtxAck_Handle : public matThread
+{
+
+   //! The COM-port handler.
+   matAsync                      M_Asy;
+
+   //! The protocol handler.
+   xProtocol                     M_Proto;
+
+#ifdef USE_TRACE_CLIENT
+   //! The protocol trace handler.
+   mPTrace<xProtocol,xRC,atbMessage>  M_Trace;
+#endif
+
+   //! Thread function will loop while true.
+   bool                          M_More;
+
+   //! Determines, if we use LH protocol
+   bool                          M_LH;
+
+   /**
+    *
+    * Thread function.
+    *
+   **/
+   void function()
+   {
+      unsigned char RxB = 0;
+      // Read the first byte from the COM-port
+      MATRC RR = M_Asy.read( RxB );
+      while( M_More )
+      {
+         switch( RR )
+         {
+         case MATRC_OK:
+            // Feed it to the protocol handler.
+            M_Proto.event( static_cast<signed char>( RxB ) );
+            break;
+         case MATRC_NO_DATA:
+            // Nothinng to do.
+            break;
+         default:
+            // Try again later (probably useless as well ).
+            // Sleep a while, because the read() could have returned
+            // really fast and we do not want to hog the CPU.
+            matThreadSleep( 1000 );
+         }
+         // Read the next byte from the COM-port
+         RR = M_Asy.read( RxB );
+
+      }
+   }
+
+public:
+
+   /**
+    *
+    * Constructor.
+    *
+   **/
+   explicit mIEtxAck_Handle( unsigned Blocksize ) :
+      matThread(),
+      M_Asy(),
+      M_Proto( M_Asy, Blocksize ),
+#ifdef USE_TRACE_CLIENT
+      M_Trace( "mIEtxAckAsy", M_Proto ),
+#endif
+      M_More( true ),
+      M_LH( false )
+   {
+   }
+
+   /**
+    *
+    * Destructor
+    *
+   **/
+   ~mIEtxAck_Handle()
+   {
+      M_More = false;
+   }
+
+   /**
+    *
+    * Get a COM-port handler reference.
+    *
+   **/
+   matAsync & asy()
+      throw()
+   {
+      return M_Asy;
+   }
+
+   /**
+    *
+    * Get a protocol-handler reference.
+    *
+   **/
+#ifdef USE_TRACE_CLIENT
+   mPTrace<xProtocol,xRC,atbMessage> & proto()
+      throw()
+   {
+      return M_Trace;
+   }
+#else
+   xProtocol & proto()
+      throw()
+   {
+      return M_Proto;
+   }
+#endif
+
+   /**
+    *
+    * Set LH protocol status.
+    *
+   **/
+   void setChkNone()
+      throw()
+   {
+      M_Proto.setChkNone();
+   }
+
+   /**
+    *
+    * Set LH protocol status.
+    *
+   **/
+   void setLH()
+      throw()
+   {
+      M_LH = true;
+      M_Proto.setNoRxAck();
+   }
+
+   /**
+    *
+    * Get LH protocol status.
+    *
+   **/
+   bool getLH()
+      throw()
+   {
+      return M_LH;
+   }
+
+private:
+
+   /**
+    *
+    * Default constructor - intentionally not implemented.
+    *
+   **/
+   mIEtxAck_Handle();
+
+   /**
+    *
+    * Copy constructor - intentionally not implemented.
+    *
+   **/
+   mIEtxAck_Handle( mIEtxAck_Handle const & );
+
+   /**
+    *
+    * Assignment - intentionally not implemented.
+    *
+   **/
+   mIEtxAck_Handle & operator=( mIEtxAck_Handle const & );
+
+};
+
+
+
+/**
+ *
+ * (see mIEtxAck.hpp)
+ *
+**/
+mIEtxAck::mIEtxAck() :
+   Handle( new mIEtxAck_Handle( 2048 ) )
+{
+}
+
+
+
+/**
+ *
+ * (see mIEtxAck.hpp)
+ *
+**/
+mIEtxAck::mIEtxAck( unsigned Blocksize ) :
+   Handle( new mIEtxAck_Handle( Blocksize ) )
+{
+}
+
+
+
+/**
+ *
+ * (see mIEtxAck.hpp)
+ *
+**/
+mIEtxAck::~mIEtxAck()
+{
+   delete Handle;
+}
+
+
+
+/**
+ *
+ * (see mIEtxAck.hpp)
+ *
+**/
+mIEtxAck::RC mIEtxAck::write( atbMessage const & Src )
+   throw()
+{
+   if( Handle )
+   {
+      if( Handle->getLH() )
+      {
+         atbMessage SrcLH;
+         SrcLH.push_back( 's' );
+         SrcLH.push_back( ASCII_ESC );
+         SrcLH.push_back( ASCII_VT );
+         SrcLH.push_back( ' ' );
+         SrcLH.push_back( ' ' );
+         SrcLH.push_back( ASCII_SI );
+         SrcLH.insert( SrcLH.end(), Src.begin(), Src.end() );
+         SrcLH.push_back( ASCII_ESC );
+         SrcLH.push_back( ASCII_DC2 );
+         if( Handle->proto().write( SrcLH ) == xProtocol::RC_OK )
+            return RC_OK;
+      }
+      else
+      {
+         if( Handle->proto().write( Src ) == xProtocol::RC_OK )
+            return RC_OK;
+      }
+   }
+   return RC_ERROR;
+}
+
+
+/**
+ *
+ * (see mIEtxAck.hpp)
+ *
+**/
+mIEtxAck::RC mIEtxAck::writeNonfinal( atbMessage const & Src )
+   throw()
+{
+   if( Handle )
+   {
+      if( Handle->proto().writeNonfinal( Src ) == xProtocol::RC_OK )
+         return RC_OK;
+   }
+   return RC_ERROR;
+}
+
+
+/**
+ *
+ * (see mIEtxAck.hpp)
+ *
+**/
+mIEtxAck::RC mIEtxAck::read( atbMessage & Dst )
+   throw()
+{
+   if( Handle )
+   {
+      if( Handle->getLH() )
+      {
+         atbMessage DstLH;
+         if( Handle->proto().read( DstLH ) == xProtocol::RC_OK )
+         {
+            if
+            (
+               ( DstLH.size() > 6 ) &&
+               ( *DstLH.begin() == ASCII_ESC ) &&
+               ( *( DstLH.begin() + 1 ) == ASCII_VT )
+            )
+            {
+               Dst.assign( DstLH.begin() + 6, DstLH.end() );
+               return RC_OK;
+            }
+         }
+      }
+      else
+      {
+         if( Handle->proto().read( Dst ) == xProtocol::RC_OK )
+            return RC_OK;
+      }
+   }
+   return RC_ERROR;
+}
+
+
+
+/**
+ *
+ * (see mIEtxAck.hpp)
+ *
+**/
+mIEtxAck::RC mIEtxAck::open()
+   throw()
+{
+   if( Handle )
+   {
+      if( Handle->asy().open() == MATRC_OK )
+      {
+         Handle->start( THREADPRTY_HIGH );
+         return RC_OK;
+      }
+   }
+   return RC_ERROR;
+}
+
+
+
+/**
+ *
+ * (see mIEtxAck.hpp)
+ *
+**/
+void mIEtxAck::get( char const * Key, char * Buf, long Len )
+   throw()
+{
+   if( Handle )
+   {
+      Handle->asy().get( Key, Buf, Len );
+   }
+}
+
+
+/**
+ *
+ * (see mIEtxAck.hpp)
+ *
+**/
+void mIEtxAck::set( char const * Key, char const * Value )
+   throw()
+{
+   if( Handle )
+   {
+      if( !strcmp( Key, MATKEY_PROTOCOL_TYPE ) )
+      {
+         if( !Value )
+         {
+            return;
+         }
+         if( !strcmp( Value, "LH" ) )
+         {
+            Handle->setLH();
+            return;
+         }
+         if( !strcmp( Value, "CHKNONE" ) )
+         {
+            Handle->setChkNone();
+            return;
+         }
+         return;
+      }
+      Handle->asy().set( Key, Value );
+   }
+}
+
+
+
+/**
+ **************************************************************************
+ *
+ * End of file
+ *
+ **************************************************************************
+**/
diff --git a/SelfServiceCommon/Massai/cpp/SerialCon/src/matAsyncW32.c b/SelfServiceCommon/Massai/cpp/SerialCon/src/matAsyncW32.c
new file mode 100644
index 00000000..b3d502be
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/SerialCon/src/matAsyncW32.c
@@ -0,0 +1,1212 @@
+/**
+ **************************************************************************
+ *
+ * @file matAsyncW32.c
+ *
+ * Contains Win32-specific async interface implementation as specified in
+ * matAsync.h.
+ *
+ * @author Juergen Kreierhoff
+ *
+ * Copyright (c) 1998-2010 MATERNA Information & Communications.
+ *
+ **************************************************************************
+**/
+
+
+
+#include "matAsync.h"
+
+#ifdef USE_MHRTIMER
+#include "mHRTimer.h"
+#define HRTIMER_DIGITS 4
+#endif
+
+#include <windows.h>
+#include <stdio.h>
+
+
+
+#define TRACE1(X)        if( H->FTrace )\
+                         {\
+                            ts( H );\
+                            fprintf( H->FTrace, " | " X "\n" );\
+                            fflush( H->FTrace );\
+                         }
+#define TRACE2(X1,X2 )   if( H->FTrace )\
+                         {\
+                            ts( H );\
+                            fprintf( H->FTrace, " | " X1 "\n", X2 );\
+                            fflush( H->FTrace );\
+                         }
+#define TRACE3(X1,X2,X3) if( H->FTrace )\
+                         {\
+                            ts( H );\
+                            fprintf( H->FTrace, " | " X1 "\n", X2, X3 );\
+                            fflush( H->FTrace );\
+                         }
+#define TRACEDUMP(D,P,N) if( H->FTrace )\
+                         {\
+                            ts( H );\
+                            traceDump( H->FTrace, D, P, N );\
+                            fflush( H->FTrace );\
+                         }
+
+
+
+static void traceDump
+            (
+               FILE * F,
+               const char * szDir,
+               unsigned char const * pD, unsigned long nD
+            )
+{
+   unsigned long i;
+   fprintf( F, " | %s", szDir );
+   for( i=0; i < nD; i++ )
+      fprintf( F, " %02X", *pD++ );
+   fprintf( F, "\n" );
+}
+
+
+
+/**
+ *
+ * Module-private "handle" structure. Every public function except
+ * matAsyncCreate() has a pointer to this structure as the first
+ * parameter. The function matAsyncCreate() returns a pointer to
+ * an allocated handle object.
+ *
+**/
+struct matAsyncPrivate
+{
+   /*
+    * Configuration strings, can be set with matAsyncSet()
+    */
+   char              szPort[12];          /* COM-port name, e.g. "COM1" */
+   char              szBitrate[8];        /* Bitrate, e.g. "9600" */
+   char              szDTR[4];            /* DTR state, e.g. "1" */
+   char              szRTS[4];            /* RTS state, e.g. "1" */
+   char              szParity[4];         /* Parity, e.g. "E" */
+   char              szDatabits[4];       /* Databits, e.g. "8" */
+   char              szStopbits[4];       /* Stopbits, e.g. "1" */
+   char              szRxTime[8];         /* Rx timeout */
+   char              szRxBlockTime[8];    /* Rx block timeout */
+   char              szTxTime[8];         /* Tx timeout */
+   /*
+    * Keep the last error string
+    */
+   char              szLastError[64];
+   /*
+    * File handle for low-level traces.
+    */
+   FILE *            FTrace;
+   /*
+    * COM-port handle.
+    */
+   HANDLE            CommH;
+   /*
+    * Mutex semaphores preventing the deletion of resources while
+    * other functions are still running.
+    */
+   HANDLE            ReadMutex;           /* Protects matAsyncRead() */
+   HANDLE            ReadStateMutex;      /* Protects matAsyncReadStatus() */
+   HANDLE            WriteMutex;          /* Protcts matAsyncWrite() */
+   /*
+    * OVERLAP structures, allows simultaneous call of blocking functions
+    * from different threads of execution.
+    */
+   OVERLAPPED        OverlapRx;           /* ... for matAsyncRead() */
+   OVERLAPPED        OverlapSt;           /* ... for matAsyncReadStatus() */
+   OVERLAPPED        OverlapTx;           /* ... for matAsyncWrite() */
+   /*
+    * Counts number of matAsyncRead() with NO_DATA returned
+    */
+   int               RxNodataCount;
+   /*
+    * Remember last reported CTS status.
+    */
+   char              LastRepCTS;
+   /*
+    * Remember last reported DSR status.
+    */
+   char              LastRepDSR;
+   /*
+    * Keeps mask for read_state.
+    */
+   unsigned long     StateInMask;
+#ifdef USE_MHRTIMER
+   /*
+    * High resolution timer for traces
+    */
+   mHRTimer_Handle   HandleHRT;
+#endif
+};
+
+
+
+/**
+ *
+ * Write a timestamp
+ *
+**/
+static void ts( struct matAsyncPrivate const * Prv )
+{
+#ifdef USE_MHRTIMER
+   char TS[MHRTIMER_STRING_SIZE(HRTIMER_DIGITS)];
+   mHRTimer_TimestampString( Prv->HandleHRT, TS );
+   fwrite
+   (
+      TS,
+      sizeof(char),
+      MHRTIMER_STRING_LEN(HRTIMER_DIGITS),
+      Prv->FTrace
+   );
+#else
+   SYSTEMTIME T;
+   GetLocalTime( &T );
+   fprintf
+   (
+      Prv->FTrace, "%02d:%02d:%02d.%03d",
+      T.wHour, T.wMinute, T.wSecond, T.wMilliseconds
+   );
+#endif
+}
+
+
+
+
+/**
+ *
+ * Fill the buffer szLastError with the given error.
+ *
+**/
+static void fillError
+(
+   struct matAsyncPrivate * H,
+   const char * Txt,
+   DWORD LastError
+)
+{
+   switch( LastError )
+   {
+   case ERROR_INVALID_FUNCTION:             /* 1 */
+      sprintf( H->szLastError, "%s INVALID_FUNCTION", Txt );
+      break;
+   case ERROR_FILE_NOT_FOUND:               /* 2 */
+      sprintf( H->szLastError, "%s FILE_NOT_FOUND", Txt );
+      break;
+   case ERROR_PATH_NOT_FOUND:               /* 3 */
+      sprintf( H->szLastError, "%s PATH_NOT_FOUND", Txt );
+      break;
+   case ERROR_ACCESS_DENIED:                /* 5 */
+      sprintf( H->szLastError, "%s ACCESS_DENIED", Txt );
+      break;
+   case ERROR_INVALID_HANDLE:               /* 6 */
+      sprintf( H->szLastError, "%s INVALID_HANDLE", Txt );
+      break;
+   case ERROR_INVALID_PARAMETER:            /* 87 */
+      sprintf( H->szLastError, "%s INVALID_PARAMETER", Txt );
+      break;
+   case ERROR_OPERATION_ABORTED:            /* 995 */
+      {
+         DWORD CommError = 0;
+         if( ClearCommError( H->CommH, &CommError, NULL ) )
+         {
+            switch( CommError )
+            {
+            case CE_BREAK:
+               sprintf( H->szLastError, "%s BREAK detected", Txt );
+               break;
+            default:
+               sprintf( H->szLastError, "%s OPERATION_ABORTED %luX",
+                        Txt, CommError );
+            }
+         }
+         else
+         {
+            sprintf
+            (
+               H->szLastError,
+               "%s OPERATION_ABORTED %luX clr err %lu",
+               Txt,
+               CommError,
+               GetLastError()
+            );
+         }
+      }
+      break;
+   case ERROR_IO_INCOMPLETE:                /* 996 */
+      sprintf( H->szLastError, "%s IO_INCOMPLETE", Txt );
+      break;
+   case ERROR_IO_PENDING:                   /* 997 */
+      sprintf( H->szLastError, "%s IO_PENDING", Txt );
+      break;
+   default:
+      sprintf( H->szLastError, "%s WinError:%lu", Txt, LastError );
+   }
+   TRACE2( "Error: %s", H->szLastError )
+}
+
+
+
+/**
+ *
+ * Fill the buffer szLastError with the error returned by
+ * GetLastError().
+ *
+**/
+static void fillLastError
+(
+   struct matAsyncPrivate * H,
+   const char * Txt
+)
+{
+   fillError( H, Txt, GetLastError() );
+}
+
+
+
+/**
+ *
+ * Copy a source string to a space-limited destination. Unlike with
+ * strncpy always a terminating "\0" is attached.
+ *
+**/
+static MATRC safeStrcpy( char * pDst, unsigned nDst, char const * pSrc )
+{
+   if( !pSrc ) return MATRC_PARAMETER_ERROR;
+   if( !pDst ) return MATRC_PARAMETER_ERROR;
+   if( nDst )
+   {
+      /* Copy the string */
+      while( *pSrc && nDst-- ) *pDst++ = *pSrc++;
+      if( nDst )
+      {
+         /* Still space available */
+         *pDst = 0;
+         return MATRC_OK;
+      }
+      else
+      {
+         /* No more space available */
+         *(pDst-1) = 0;
+      }
+   }
+   return MATRC_PARAMETER_STRING_TOO_LONG;
+}
+
+
+
+/**
+ *
+ * Set modem line DTR.
+ *
+**/
+static MATRC setupLnDTR( mtHdl H )
+{
+   if( !H->CommH )
+      return MATRC_OK;
+   else
+   {
+      DCB D;
+      if( !GetCommState( H->CommH, &D ) )
+      {
+         fillLastError( H, "GetCommState" );
+         return MATRC_ERROR;
+      }
+      switch( H->szDTR[0] )
+      {
+      case '0':
+         D.fDtrControl = DTR_CONTROL_DISABLE;
+         break;
+      default:
+         D.fDtrControl = DTR_CONTROL_ENABLE;
+         break;
+      case 'H':
+         D.fDtrControl = DTR_CONTROL_HANDSHAKE;
+         break;
+      }
+      if( !SetCommState( H->CommH, &D ) )
+      {
+         fillLastError( H, "SetCommState" );
+         return MATRC_ERROR;
+      }
+      return MATRC_OK;
+   }
+}
+
+
+
+/**
+ *
+ * Set the modem line RTS.
+ *
+**/
+static MATRC setupLnRTS( mtHdl H )
+{
+   if( !H->CommH )
+      return MATRC_OK;
+   else
+   {
+      DCB D;
+      if( !GetCommState( H->CommH, &D ) )
+      {
+         fillLastError( H, "GetCommState" );
+         return MATRC_ERROR;
+      }
+      switch( H->szRTS[0] )
+      {
+      default:
+         D.fRtsControl = RTS_CONTROL_HANDSHAKE;
+         break;
+      case '0':
+         D.fRtsControl = RTS_CONTROL_DISABLE;
+         break;
+      case '1':
+         D.fRtsControl = RTS_CONTROL_ENABLE;
+         break;
+      }
+      if( !SetCommState( H->CommH, &D ) )
+      {
+         fillLastError( H, "SetCommState" );
+         return MATRC_ERROR;
+      }
+      return MATRC_OK;
+   }
+}
+
+
+
+/**
+ *
+ * Set timeout values.
+ *
+**/
+static MATRC setupTimes( mtHdl H )
+{
+   if( !H->CommH )
+      return MATRC_OK;
+   else
+   {
+      COMMTIMEOUTS CommTimeOuts;
+      DWORD Bitrate;
+      if( H->szBitrate[0] )
+         Bitrate = (DWORD)atol( H->szBitrate );
+      else
+         Bitrate = 0;
+      /*
+       * Rx total timeout
+       */
+      CommTimeOuts.ReadTotalTimeoutMultiplier = 0;
+      if( strcmp( H->szRxTime, MATKEY_IMMEDIATE ) )
+      {
+         if( H->szRxTime[0] )
+         {
+            CommTimeOuts.ReadTotalTimeoutConstant
+               = (DWORD)atol( H->szRxTime );
+         }
+         else
+         {
+            CommTimeOuts.ReadTotalTimeoutConstant = 0;
+         }
+         /*
+          * Rx interval timeout
+          */
+         if( H->szRxBlockTime[0] )
+         {
+            CommTimeOuts.ReadIntervalTimeout
+               = (DWORD)atol( H->szRxBlockTime );
+         }
+         else
+         {
+            /*
+             * By default use something reasonable
+             */
+            if( Bitrate )
+               CommTimeOuts.ReadIntervalTimeout =
+                  (
+                     (DWORD)
+                     1000 *             /* 1 second */
+                     10 *               /* bits per byte */
+                     8 /                /* allow 8 bytes idle time */
+                     Bitrate            /* configured bits per second */
+                  ) + 1;                /* prevent 0 after division */
+            else
+               CommTimeOuts.ReadIntervalTimeout = MAXDWORD;
+         }
+      }
+      else
+      {
+         CommTimeOuts.ReadTotalTimeoutConstant = 0;
+         CommTimeOuts.ReadIntervalTimeout = MAXDWORD;
+      }
+      /*
+       * Tx interval timeout
+       */
+      if( H->szTxTime[0] )
+      {
+         CommTimeOuts.WriteTotalTimeoutConstant
+            = (DWORD)atol( H->szTxTime );
+      }
+      else
+      {
+         CommTimeOuts.WriteTotalTimeoutConstant = 0;
+      }
+      CommTimeOuts.WriteTotalTimeoutMultiplier = 0;
+      SetCommTimeouts( H->CommH, &CommTimeOuts ) ;
+      return MATRC_OK;
+   }
+}
+
+
+
+/**
+ *
+ * Initialize OVERLAPPED structure.
+ *
+**/
+static void initOverlap( OVERLAPPED * O )
+{
+   O->Internal = 0;
+   O->InternalHigh = 0;
+   O->Offset = 0;
+   O->OffsetHigh = 0;
+   O->hEvent = CreateEvent
+               (
+                  NULL,    /* no security */
+                  TRUE,    /* explicit reset needed. */
+                  FALSE,   /* initial event state */
+                  NULL     /* no name */
+               );
+}
+
+
+
+/**
+ *
+ * Public function.
+ *
+**/
+mtHdl matAsyncCreate( void )
+{
+   mtHdl H = (mtHdl)malloc( sizeof(struct matAsyncPrivate) );
+   if( H )
+   {
+      H->szPort[0] = 0;
+      H->szBitrate[0] = 0;
+      H->szDTR[0] = 0;
+      H->szRTS[0] = 0;
+      H->szParity[0] = 0;
+      H->szDatabits[0] = 0;
+      H->szStopbits[0] = 0;
+      H->szRxTime[0] = 0;
+        H->szRxBlockTime[0] = 0;
+      H->szTxTime[0] = 0;
+      H->szLastError[0] = 0;
+      H->FTrace = NULL;
+      H->CommH = 0;
+      H->ReadMutex = CreateMutex( NULL, FALSE, NULL );
+      if( H->ReadMutex == NULL )
+         fillLastError( H, "CreateMutex Read" );
+      H->ReadStateMutex = CreateMutex( NULL, FALSE, NULL );
+      if( H->ReadStateMutex == NULL )
+         fillLastError( H, "CreateMutex ReadState" );
+      H->WriteMutex = CreateMutex( NULL, FALSE, NULL );
+      if( H->WriteMutex == NULL )
+         fillLastError( H, "CreateMutex Write" );
+      H->OverlapRx.hEvent = NULL;
+      H->OverlapSt.hEvent = NULL;
+      H->OverlapTx.hEvent = NULL;
+      H->RxNodataCount = 0;
+      H->LastRepCTS = 0;
+      H->LastRepDSR = 0;
+      H->StateInMask = 0;
+#ifdef USE_MHRTIMER
+      H->HandleHRT = mHRTimer_Create( HRTIMER_DIGITS );
+#endif
+   }
+   return H;
+}
+
+
+
+/**
+ *
+ * Public function.
+ *
+**/
+void matAsyncDelete( mtHdl H )
+{
+   if( H->CommH )
+      matAsyncClose( H );
+   WaitForSingleObject( H->ReadMutex, INFINITE );
+   WaitForSingleObject( H->ReadStateMutex, INFINITE );
+   WaitForSingleObject( H->WriteMutex, INFINITE );
+   if( H->FTrace )
+      fclose( H->FTrace );
+   free( H );
+}
+
+
+
+/**
+ *
+ * Public function.
+ *
+**/
+MATRC matAsyncOpen( mtHdl H )
+{
+   MATRC Ret;
+   DWORD Bitrate;
+   TRACE1( "open" )
+   if( H->szBitrate[0] )
+      Bitrate = (DWORD)atol( H->szBitrate );
+   else
+      Bitrate = 0;
+   initOverlap( &H->OverlapRx );
+   if( H->OverlapRx.hEvent == NULL )
+      fillLastError( H, "CreateEvent RX" );
+   initOverlap( &H->OverlapSt );
+   if( H->OverlapSt.hEvent == NULL )
+      fillLastError( H, "CreateEvent ST" );
+   initOverlap( &H->OverlapTx );
+   if( H->OverlapTx.hEvent == NULL )
+      fillLastError( H, "CreateEvent TX" );
+   H->CommH = CreateFile
+   (
+      H->szPort[0] ? H->szPort : "COM1",  /* Name */
+      GENERIC_READ + GENERIC_WRITE,       /* Access */
+      0L,                                  /* Share mode */
+      0,                                  /* Security attr */
+      (DWORD)OPEN_EXISTING,               /* CreDist */
+      FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
+      0                                   /* Template */
+   );
+   if( H->CommH == INVALID_HANDLE_VALUE )
+   {
+      fillLastError( H, "CreateFile" );
+      return MATRC_ERROR;
+   }
+   /*
+    * SetupComm
+    */
+   if( !SetupComm( H->CommH, 0x10000, 0x10000 ) )
+   {
+      fillLastError( H, "SetupComm" );
+      return MATRC_ERROR;
+   }
+   /*
+    * PurgeComm
+    */
+   if
+   (
+      !PurgeComm
+      (
+         H->CommH,
+         (DWORD)
+         PURGE_TXABORT |
+         PURGE_RXABORT |
+         PURGE_TXCLEAR |
+         PURGE_RXCLEAR
+      )
+   )
+   {
+      fillLastError( H, "PurgeComm" );
+      return MATRC_ERROR;
+   }
+   /*
+    * SetCommState
+    */
+   {
+      DCB D;
+      if( !GetCommState( H->CommH, &D ) )
+      {
+         fillLastError( H, "GetCommState" );
+         return MATRC_ERROR;
+      }
+      /*
+       * Bitrate
+       */
+      if( Bitrate )
+      {
+         D.BaudRate = Bitrate;
+      }
+      /*
+       * Etc
+       */
+      D.fOutxCtsFlow = FALSE;
+      D.fOutxDsrFlow = FALSE;
+      D.XonLim = 1024;
+      D.XoffLim = 1024;
+      /*
+       * Databits
+       */
+      if( H->szDatabits[0] )
+      {
+         D.ByteSize = (BYTE)(H->szDatabits[0] & 0x0F);
+      }
+      else
+      {
+         D.ByteSize = 8;
+      }
+      /*
+       * Parity
+       */
+      switch( H->szParity[0] )
+      {
+      default:
+         D.Parity = NOPARITY;
+         break;
+      case 'E':
+         D.Parity = EVENPARITY;
+         break;
+      case 'O':
+         D.Parity = ODDPARITY;
+         break;
+      }
+      /*
+       * Stopbits
+       */
+      switch( H->szStopbits[0] )
+      {
+      default:
+         D.StopBits = ONESTOPBIT;
+         break;
+      case '5':
+         D.StopBits = ONE5STOPBITS;
+         break;
+      case '2':
+         D.StopBits = TWOSTOPBITS;
+         break;
+      }
+      if( !SetCommState( H->CommH, &D ) )
+      {
+         fillLastError( H, "SetCommState" );
+         return MATRC_ERROR;
+      }
+   }
+   /*
+    * Other parameters
+    */
+   Ret = setupTimes( H );
+   if( Ret != MATRC_OK )
+      return Ret;
+   Ret = setupLnDTR( H );
+   if( Ret != MATRC_OK )
+      return Ret;
+   Ret = setupLnRTS( H );
+   if( Ret != MATRC_OK )
+      return Ret;
+   return MATRC_OK;
+}
+
+
+
+/**
+ *
+ * Public function.
+ *
+**/
+MATRC matAsyncClose ( mtHdl H )
+{
+   TRACE1( "close" )
+   CloseHandle( H->OverlapRx.hEvent );
+   CloseHandle( H->OverlapSt.hEvent );
+   CloseHandle( H->OverlapTx.hEvent );
+   CloseHandle( H->CommH );
+   return MATRC_OK;
+}
+
+
+
+/**
+ *
+ * Public function.
+ *
+**/
+MATRC matAsyncGet( mtHdl H, MTCONST char * Key, char * Val, long nVal )
+{
+   if( !strcmp( Key, MATKEY_ERROR_LAST ) )
+   {
+      TRACE3( "get %s = %s", Key, H->szLastError )
+      return safeStrcpy( Val, (unsigned)nVal, H->szLastError );
+   }
+   if( !strcmp( Key, MATKEY_DSR ) )
+   {
+      DWORD Sta;
+      if( GetCommModemStatus( H->CommH, &Sta ) )
+      {
+         if( Sta & MS_DSR_ON )
+         {
+            if( !H->LastRepDSR || ( H->LastRepDSR != '1' ) )
+            {
+               H->LastRepDSR = '1';
+               TRACE3( "get %s = %s", Key, "1" )
+            }
+            return safeStrcpy( Val, (unsigned)nVal, "1" );
+         }
+         else
+         {
+            if( !H->LastRepDSR || ( H->LastRepDSR != '0' ) )
+            {
+               H->LastRepDSR = '0';
+               TRACE3( "get %s = %s", Key, "0" )
+            }
+            return safeStrcpy( Val, (unsigned)nVal, "0" );
+         }
+      }
+      else
+      {
+         fillLastError( H, "GetModemStatus" );
+         return MATRC_ERROR;
+      }
+   }
+   if( !strcmp( Key, MATKEY_CTS ) )
+   {
+      DWORD Sta;
+      if( GetCommModemStatus( H->CommH, &Sta ) )
+      {
+         if( Sta & MS_CTS_ON )
+         {
+            if( !H->LastRepCTS || ( H->LastRepCTS != '1' ) )
+            {
+               H->LastRepCTS = '1';
+               TRACE3( "get %s = %s", Key, "1" )
+            }
+            return safeStrcpy( Val, (unsigned)nVal, "1" );
+         }
+         else
+         {
+            if( !H->LastRepCTS || ( H->LastRepCTS != '0' ) )
+            {
+               H->LastRepCTS = '0';
+               TRACE3( "get %s = %s", Key, "0" )
+            }
+            return safeStrcpy( Val, (unsigned)nVal, "0" );
+         }
+      }
+      else
+      {
+         fillLastError( H, "GetModemStatus" );
+         return MATRC_ERROR;
+      }
+   }
+   TRACE2( "get %s - ignored", Key )
+   return MATRC_IGNORED;
+}
+
+
+
+/**
+ *
+ * Public function.
+ *
+**/
+MATRC matAsyncSet( mtHdl H, MTCONST char * Key, MTCONST char * Val )
+{
+   if( !strcmp( Key, MATKEY_TRACE ) )
+   {
+      if( H->FTrace )
+      {
+         ts( H );
+         fprintf( H->FTrace, " - %s\n", Val );
+         fflush( H->FTrace );
+         return MATRC_OK;
+      }
+      else
+         return MATRC_IGNORED;
+   }
+   if( !strcmp( Key, MATKEY_ASYNC_TRACEFILE ) )
+   {
+      if( !Val ) return MATRC_PARAMETER_ERROR;
+      if( !Val[0] ) return MATRC_PARAMETER_STRING_TOO_SHORT;
+      H->FTrace = fopen( Val, "w" );
+      if( H->FTrace )
+         return MATRC_OK;
+      else
+         return MATRC_ERROR;
+   }
+   TRACE3( "set %s = %s", Key, Val )
+   if( !strcmp( Key, MATKEY_PORT ) )
+      return safeStrcpy( H->szPort, sizeof(H->szPort), Val );
+   if( !strcmp( Key, MATKEY_BITRATE ) )
+      return safeStrcpy( H->szBitrate, sizeof(H->szBitrate), Val );
+   if( !strcmp( Key, MATKEY_DTR ) )
+   {
+      MATRC R = safeStrcpy( H->szDTR, sizeof(H->szDTR), Val );
+      if( R == MATRC_OK )
+         R = setupLnDTR( H );
+      return R;
+   }
+   if( !strcmp( Key, MATKEY_RTS ) )
+   {
+      MATRC R = safeStrcpy( H->szRTS, sizeof(H->szRTS), Val );
+      if( R == MATRC_OK )
+         R = setupLnRTS( H );
+      return R;
+   }
+   if( !strcmp( Key, MATKEY_PARITY ) )
+      return safeStrcpy( H->szParity, sizeof(H->szParity), Val );
+   if( !strcmp( Key, MATKEY_DATABITS ) )
+      return safeStrcpy( H->szDatabits, sizeof(H->szDatabits), Val );
+   if( !strcmp( Key, MATKEY_STOPBITS ) )
+      return safeStrcpy( H->szStopbits, sizeof(H->szStopbits), Val );
+   if( !strcmp( Key, MATKEY_RX_TIME ) )
+   {
+      MATRC R = safeStrcpy( H->szRxTime, sizeof(H->szRxTime), Val );
+      if( R == MATRC_OK )
+         R = setupTimes( H );
+      return R;
+   }
+   if( !strcmp( Key, MATKEY_RX_BLOCK_TIME ) )
+   {
+      MATRC R = safeStrcpy
+                (
+                   H->szRxBlockTime, sizeof(H->szRxBlockTime),
+                   Val
+                );
+      if( R == MATRC_OK )
+         R = setupTimes( H );
+      return R;
+   }
+   if( !strcmp( Key, MATKEY_TX_TIME ) )
+   {
+      MATRC R = safeStrcpy( H->szTxTime, sizeof(H->szTxTime), Val );
+      if( R == MATRC_OK )
+         R = setupTimes( H );
+      return R;
+   }
+   return MATRC_IGNORED;
+}
+
+
+
+/**
+ *
+ * Public function.
+ *
+**/
+MATRC matAsyncRead( mtHdl H, mtDta * pDst, mtLen * pMaxNumberRead )
+{
+   DWORD NumberRead;
+   DWORD const MaxNumberRead = *pMaxNumberRead;
+   MATRC Return = MATRC_NO_DATA;
+   WaitForSingleObject( H->ReadMutex, INFINITE );
+   if
+   (
+      ReadFile( H->CommH, pDst, MaxNumberRead, &NumberRead, &H->OverlapRx )
+   )
+   {
+      /* Immediately returned with some result */
+      if( NumberRead == 0 )
+      {
+         /* No data received */
+         if( !H->RxNodataCount++ )
+         {
+            TRACE1( "RX:" )
+         }
+         /* Return is already MATRC_NO_DATA; */
+      }
+      else
+      {
+         /* Some data received */
+         if( H->RxNodataCount )
+         {
+            if( H->RxNodataCount > 1 )
+            {
+               TRACE2( "(%d times no data)", H->RxNodataCount )
+            }
+            H->RxNodataCount = 0;
+         }
+         TRACEDUMP( "RX:", pDst, NumberRead )
+         *pMaxNumberRead = (mtLen)NumberRead;
+         Return = MATRC_OK;
+      }
+   }
+   else
+   {
+      /* Noting received - yet ... */
+      DWORD const LE = GetLastError();
+      if( LE == ERROR_IO_PENDING )
+      {
+         /* Still receiving ... */
+         if
+         (
+            WaitForSingleObject( H->OverlapRx.hEvent, INFINITE )
+            == WAIT_OBJECT_0
+         )
+         {
+            /* Finished with receive */
+            DWORD OvNumberRead = *pMaxNumberRead;
+            if
+            (
+               GetOverlappedResult( H->CommH,
+                                    &H->OverlapRx,
+                                    &OvNumberRead, FALSE) == 0
+            )
+            {
+               fillLastError( H, "ReadFile OVL result" );
+               Return = MATRC_ERROR;
+            }
+            else
+            {
+               /* Receive success */
+               if( OvNumberRead == 0 )
+               {
+                  /* No data received */
+                  if( !H->RxNodataCount++ )
+                  {
+                     TRACE1( "RX:" )
+                  }
+                  Return = MATRC_NO_DATA;
+               }
+               else
+               {
+                  /* Some data received */
+                  if( H->RxNodataCount )
+                  {
+                     if( H->RxNodataCount > 1 )
+                     {
+                        TRACE2( "(%d times no data)", H->RxNodataCount )
+                     }
+                     H->RxNodataCount = 0;
+                  }
+                  TRACEDUMP( "RX:", pDst, OvNumberRead )
+                  *pMaxNumberRead = (mtLen)OvNumberRead;
+                  Return = MATRC_OK;
+               }
+            }
+         }
+         else
+         {
+            fillLastError( H, "ReadFile Pending failed" );
+            Return = MATRC_ERROR;
+         }
+      }
+      else
+      {
+         fillError( H, "ReadFile", LE );
+         Return = MATRC_ERROR;
+      }
+   }
+   ReleaseMutex( H->ReadMutex );
+   return Return;
+}
+
+
+
+/**
+ *
+ * Public function.
+ *
+**/
+MATRC matAsyncRead1( mtHdl H, mtDta * Dst )
+{
+   mtLen L = 1;
+   return matAsyncRead( H, Dst, &L );
+}
+
+
+
+/**
+ *
+ * Public function.
+ *
+**/
+MATRC matAsyncReadStatus( mtHdl H, mtSta * pStateIn )
+{
+   mtSta const StateIn = *pStateIn;
+   MATRC Return = MATRC_OK;
+   WaitForSingleObject( H->ReadStateMutex, INFINITE );
+   TRACE1( "ST ..." )
+   if( !(StateIn & MASYNC_LINESTATE_INITIALIZED ) )
+   {
+      TRACE1( "ST (init) ..." )
+      H->StateInMask
+         = 0
+         | ( (StateIn & MASYNC_LINESTATE_CTS) ? EV_CTS  : 0 )
+         | ( (StateIn & MASYNC_LINESTATE_DSR) ? EV_DSR  : 0 )
+         | ( (StateIn & MASYNC_LINESTATE_CD)  ? EV_RLSD : 0 )
+         | ( (StateIn & MASYNC_LINESTATE_RI)  ? EV_RING : 0 )
+         ;
+      if( !SetCommMask( H->CommH, H->StateInMask ) )
+      {
+         DWORD const LE = GetLastError();
+         fillError( H, "SetCommMask", LE );
+         Return = MATRC_ERROR;
+      }
+      else
+         *pStateIn |= MASYNC_LINESTATE_INITIALIZED;
+   }
+   else
+   {
+      if( !WaitCommEvent( H->CommH, &H->StateInMask, &H->OverlapSt ) )
+      {
+         DWORD const LE = GetLastError();
+         if( LE == ERROR_IO_PENDING )
+         {
+            if
+            (
+               WaitForSingleObject( H->OverlapSt.hEvent, INFINITE )
+               == WAIT_OBJECT_0
+            )
+            {
+               DWORD Dummy;
+               if
+               (
+                  GetOverlappedResult( H->CommH,
+                  &H->OverlapSt,
+                  &Dummy, TRUE) == 0
+               )
+               {
+                  fillLastError( H, "WaitCommEvent OVL result" );
+                  Return = MATRC_ERROR;
+               }
+            }
+            else
+            {
+               fillLastError( H, "WaitCommEvent Pending failed" );
+               Return = MATRC_ERROR;
+            }
+         }
+         else
+         {
+            fillError( H, "WaitCommEvent", LE );
+            Return = MATRC_ERROR;
+         }
+      }
+   }
+   if( Return == MATRC_OK )
+   {
+      DWORD Sta = 0;
+      GetCommModemStatus( H->CommH, &Sta );
+      TRACE3( "ST: %04lX (ov) Sta=%04lX", H->StateInMask, Sta );
+      if( Sta & MS_CTS_ON )
+         *pStateIn |= MASYNC_LINESTATE_CTS;
+      else
+         *pStateIn &= ~MASYNC_LINESTATE_CTS;
+      if( Sta & MS_DSR_ON )
+         *pStateIn |= MASYNC_LINESTATE_DSR;
+      else
+         *pStateIn &= ~MASYNC_LINESTATE_DSR;
+      if( Sta & MS_RING_ON )
+         *pStateIn |= MASYNC_LINESTATE_RI;
+      else
+         *pStateIn &= (mtSta)(~((mtSta)MASYNC_LINESTATE_RI));
+      if( Sta & MS_RLSD_ON )
+         *pStateIn |= MASYNC_LINESTATE_CD;
+      else
+         *pStateIn &= ~MASYNC_LINESTATE_CD;
+   }
+   ReleaseMutex( H->ReadStateMutex );
+   return Return;
+}
+
+
+
+/**
+ *
+ * Public function.
+ *
+**/
+MATRC matAsyncWrite( mtHdl H, MTCONST mtDta * pSrc, mtLen *pnSrc )
+{
+   DWORD NumberWritten;
+   DWORD const NumberToWrite = *pnSrc;
+   MATRC Return = MATRC_NO_DATA;
+   WaitForSingleObject( H->WriteMutex, INFINITE );
+   if
+   (
+      WriteFile
+      (
+         H->CommH, pSrc, NumberToWrite, &NumberWritten, &H->OverlapTx
+      )
+   )
+   {
+      TRACEDUMP( "TX:", pSrc, NumberWritten )
+      if( NumberWritten == NumberToWrite )
+      {
+         Return = MATRC_OK;
+      }
+      else
+      {
+         *pnSrc = (mtLen)NumberWritten;
+         /* Return is already MATRC_NO_DATA; */
+      }
+   }
+   else
+   {
+      DWORD const LE = GetLastError();
+      if( LE == ERROR_IO_PENDING )
+      {
+         if
+         (
+            WaitForSingleObject( H->OverlapTx.hEvent, INFINITE )
+            == WAIT_OBJECT_0
+         )
+         {
+            DWORD nSrc = *pnSrc;
+            if
+            (
+               GetOverlappedResult( H->CommH,
+                                    &H->OverlapTx,
+                                    &nSrc, FALSE) == 0
+            )
+            {
+               fillLastError( H, "WriteFile OVL result" );
+               Return = MATRC_ERROR;
+            }
+            else
+            {
+               TRACEDUMP( "TX:", pSrc, nSrc )
+               if( nSrc == NumberToWrite )
+               {
+                  Return = MATRC_OK;
+               }
+               else
+               {
+                 *pnSrc = (mtLen)nSrc;
+                 /* Return is already MATRC_NO_DATA; */
+               }
+            }
+         }
+         else
+         {
+            fillLastError( H, "WriteFile Pending failed" );
+            Return = MATRC_ERROR;
+         }
+      }
+      else
+      {
+         fillError( H, "WriteFile", LE );
+         Return = MATRC_ERROR;
+      }
+   }
+   ReleaseMutex( H->WriteMutex );
+   return Return;
+}
+
+
+
+/**
+ *
+ * Public function.
+ *
+**/
+MATRC matAsyncWrite1( mtHdl H, mtDta Src )
+{
+   mtLen L = 1;
+   return matAsyncWrite( H, &Src, &L );
+}
+
+
+
+/**
+ **************************************************************************
+ *
+ * End of file
+ *
+ **************************************************************************
+**/
+
diff --git a/SelfServiceCommon/Massai/cpp/StatisticsService/makefile.mak b/SelfServiceCommon/Massai/cpp/StatisticsService/makefile.mak
index 249fdcb1..c92bb0e1 100644
--- a/SelfServiceCommon/Massai/cpp/StatisticsService/makefile.mak
+++ b/SelfServiceCommon/Massai/cpp/StatisticsService/makefile.mak
@@ -27,7 +27,6 @@ MY_BIN1 = \
 
 MY_BIN1_OBJS = \
     $(_OBJ)\File.obj \
-    $(_OBJ)\log.obj \
     $(_OBJ)\main.obj \
     $(_OBJ)\path.obj \
     $(_OBJ)\server.obj \
diff --git a/SelfServiceCommon/Massai/cpp/StatisticsService/src/log.cpp b/SelfServiceCommon/Massai/cpp/StatisticsService/src/log.cpp
deleted file mode 100644
index d4edbfc4..00000000
--- a/SelfServiceCommon/Massai/cpp/StatisticsService/src/log.cpp
+++ /dev/null
@@ -1,92 +0,0 @@
-//---------------------------------------------------------------------------
-//
-//  file:       log.cpp
-//
-//  purpose:    print logging events to stdout
-//
-//  date:       11.07.2001
-//
-//  author:     Materna Information & Communications (TS)
-//
-//---------------------------------------------------------------------------
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdarg.h>
-#include <string.h>
-#include <time.h>
-#include <sys/types.h>
-#include <sys/timeb.h>
-
-#include "log.h"
-
-#define MAX_PROT_BUF 1024
-
-
-//---------------------------------------------------------------------------
-//
-//  function:   void prot(char *pszFormat, ...)
-//
-//  purpose:    logging function
-//
-//  date:       04.05.2001, 11:19
-//
-//  author:     Materna Information & Communications (AGe)
-//
-//---------------------------------------------------------------------------
-
-void prot(char *pszFormat, ...)
-{
-long     ulLen;
-// ts 11.07.2001 print logging events to stdout
-// char     *pTmp;
-char     pTmp[MAX_PROT_BUF];
-va_list       arg_ptr;
-time_t        ltime;
-struct  tm   *today;
-struct _timeb tstruct;
-
-    time(&ltime);
-    _ftime(&tstruct);
-
-    today = localtime(&ltime);
-
-    // ts 11.07.2001 print logging events to stdout
-    // if((pTmp = (char*) malloc(MAX_PROT_BUF)) == NULL)
-    //  return;
-
-    /* write traces with date and time */
-
-    memset(pTmp,0,MAX_PROT_BUF);
-
-    ulLen = 0;
-
-    ulLen += sprintf(pTmp + ulLen,"%02d%02d %02d%02d:%02d.%02d :  ",
-                                  today->tm_mday,
-                                  today->tm_mon + 1,
-                                  today->tm_hour,
-                                  today->tm_min,
-                                  today->tm_sec,
-                                  tstruct.millitm /10);
-
-    /* get pointer to first argument */
-
-    va_start(arg_ptr,pszFormat);
-
-    /* print into buffer */
-
-    ulLen += vsprintf(pTmp + ulLen,pszFormat,arg_ptr);
-
-    va_end(arg_ptr);
-
-    // vv ts 11.07.2001 print logging events to stdout
-    // if(hwndList)
-    //  SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM) pTmp) ;
-    printf("%s", pTmp);
-
-    // ts 11.07.2001 print logging events to stdout
-    // free(pTmp);
-
-    return;
-}
-
diff --git a/SelfServiceCommon/Massai/cpp/Systools/makefile.mak b/SelfServiceCommon/Massai/cpp/Systools/makefile.mak
index 06d4b255..9368c59c 100644
--- a/SelfServiceCommon/Massai/cpp/Systools/makefile.mak
+++ b/SelfServiceCommon/Massai/cpp/Systools/makefile.mak
@@ -27,7 +27,10 @@ MY_LIB1_OBJS =          $(_OBJ)\local_def.obj \
                         $(_OBJ)\nt_evsem.obj \
                         $(_OBJ)\nt_thrdc.obj \
                         $(_OBJ)\software_error.obj \
-                        $(_OBJ)\threadException.obj   \
+                        $(_OBJ)\threadException.obj \
+                        $(_OBJ)\nt_file.obj
+
+MY_LIB1_LIBS =          $(SYS_ADVAPI32)
 
 ######################################################################
 
diff --git a/SelfServiceCommon/Massai/cpp/Systools/src/NT_FILE.cpp b/SelfServiceCommon/Massai/cpp/Systools/src/NT_FILE.cpp
new file mode 100644
index 00000000..5fac91f7
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/Systools/src/NT_FILE.cpp
@@ -0,0 +1,189 @@
+#include <windows.h>
+#include <string>
+#include "filecur.hpp"
+
+class _fileCursor
+{
+ std::string     szName;
+ HANDLE          hFile;
+ WIN32_FIND_DATA data;
+ int             fFirst;
+ long            fValid;
+ long            lFType;
+
+ long checkAttr(long lAttr)
+ {
+   if (fValid)
+   {
+     if (data.dwFileAttributes & lAttr)
+       return 1;
+     else
+       return 0;
+   }
+   else
+    return 0;
+ }
+
+
+  void _getNext()
+  {
+    int rc = 1;
+
+    if(fFirst)
+    {
+     fFirst = 0;
+     int TriesToFindFirst = 5;
+     while( TriesToFindFirst )
+     {
+        hFile = FindFirstFile(szName.c_str(),&data);
+        if (hFile == INVALID_HANDLE_VALUE)
+        {
+          int LE = GetLastError();
+          if( LE == ERROR_FILE_NOT_FOUND )
+          {
+             // not found - retry not necessary
+             TriesToFindFirst = 0;
+             rc = 0;
+          }
+          else
+          {
+             // probably ERROR_NOT_ENOUGH_MEMORY - retry ?
+             --TriesToFindFirst;
+          }
+        }
+        else
+        {
+          // success - retry not necessary
+          TriesToFindFirst = 0;
+        }
+     }
+    }
+    else
+    {
+     if (hFile != INVALID_HANDLE_VALUE)
+     {
+       if (!FindNextFile(hFile,&data))
+         rc = 0;
+     }
+     else
+      rc = 0;
+    }
+
+    fValid = rc;
+  }
+
+
+public:
+
+ _fileCursor(const char *szFile, long lFileType)
+ {
+    szName = szFile;
+    lFType = lFileType;
+    fFirst = 1;
+    fValid = 1;
+    getNext();
+ }
+
+ ~_fileCursor()
+ {
+    if (!fFirst && (hFile != INVALID_HANDLE_VALUE))
+      FindClose(hFile);
+ }
+
+ long eof() { return !fValid;}
+
+ const char* szValue()
+ {
+   if (fValid)
+     return data.cFileName;
+   else
+     return "";
+ }
+
+ const char* sz83Value()
+ {
+   if (fValid)
+     return data.cAlternateFileName;
+   else
+     return "";
+ }
+
+  long isDir()      { return checkAttr(FILE_ATTRIBUTE_DIRECTORY);}
+  long isReadOnly() { return checkAttr(FILE_ATTRIBUTE_READONLY);}
+  long isHidden()   { return checkAttr(FILE_ATTRIBUTE_HIDDEN);}
+  long isSystem()   { return checkAttr(FILE_ATTRIBUTE_SYSTEM);}
+  long isArchive()  { return checkAttr(FILE_ATTRIBUTE_ARCHIVE);}
+
+  void getNext()
+  {
+    long fFound = 0;
+
+    while(!eof() && !fFound)
+    {
+      _getNext();
+
+      switch(lFType)
+      {
+       default:
+       case fileCursor::ALLFILES:
+                    fFound = 1;
+                    break;
+
+       case fileCursor::NORMAL:
+                    fFound = !isDir();
+                    break;
+
+       case fileCursor::DIRECTORY:
+                    fFound = isDir();
+                    break;
+
+      }
+    }
+  }
+
+
+};
+
+
+
+
+fileCursor::fileCursor(const char* szFilename,FILETYPE lFiletype)
+{
+ handle = new _fileCursor(szFilename,lFiletype);
+}
+
+fileCursor::~fileCursor()
+{
+  delete handle;
+}
+
+long fileCursor::eof() { return handle->eof();}
+fileCursor::operator const char*() { return szValue();}
+
+const char* fileCursor::szValue() { return handle->szValue();}
+
+const char* fileCursor::sz83Value() { return handle->sz83Value();}
+
+const char* fileCursor::operator++()
+{
+  handle->getNext();
+  return *this;
+}
+
+const char* fileCursor::operator++(int)
+{
+ static std::string buf;
+
+ buf = *this;
+ handle->getNext();
+ return buf.c_str();
+}
+
+long fileCursor::isDir()       { return handle->isDir(); }
+long fileCursor::isReadOnly()  { return handle->isReadOnly(); }
+long fileCursor::isHidden()    { return handle->isHidden(); }
+long fileCursor::isSystem()    { return handle->isSystem(); }
+long fileCursor::isArchive()   { return handle->isArchive(); }
+
+
+
diff --git a/SelfServiceCommon/Massai/cpp/Systools/src/mEventSemW32.cpp b/SelfServiceCommon/Massai/cpp/Systools/src/mEventSemW32.cpp
index f50239c0..af6af91c 100644
--- a/SelfServiceCommon/Massai/cpp/Systools/src/mEventSemW32.cpp
+++ b/SelfServiceCommon/Massai/cpp/Systools/src/mEventSemW32.cpp
@@ -13,6 +13,12 @@
  **************************************************************************
 **/
 
+#if defined(_MSC_VER)
+// Exception specification ignored
+#pragma warning (disable : 4290)
+#endif /* _MSC_VER */
+
+
 #include "mEventsem.hpp"
 
 #include "windows.h"
diff --git a/SelfServiceCommon/Massai/cpp/Tools/makefile.mak b/SelfServiceCommon/Massai/cpp/Tools/makefile.mak
index 2e382c8a..4b35928d 100644
--- a/SelfServiceCommon/Massai/cpp/Tools/makefile.mak
+++ b/SelfServiceCommon/Massai/cpp/Tools/makefile.mak
@@ -20,8 +20,8 @@ MY_LIB1_OBJS =          $(_OBJ)\mHRTimerW32.obj \
                         $(_OBJ)\dateProperties.obj \
                         $(_OBJ)\bitarray.obj \
                         $(_OBJ)\localtrace.obj \
-                        $(_OBJ)\stringbuffer.obj
-
+                        $(_OBJ)\stringbuffer.obj \
+                        $(_OBJ)\log.obj
 
 ######################################################################
 
diff --git a/SelfServiceCommon/Massai/cpp/BillingService/src/log.cpp b/SelfServiceCommon/Massai/cpp/Tools/src/log.cpp
similarity index 100%
rename from SelfServiceCommon/Massai/cpp/BillingService/src/log.cpp
rename to SelfServiceCommon/Massai/cpp/Tools/src/log.cpp
diff --git a/SelfServiceCommon/Massai/cpp/mSysTools/makefile.mak b/SelfServiceCommon/Massai/cpp/mSysTools/makefile.mak
index 011d3c1c..f06e879d 100644
--- a/SelfServiceCommon/Massai/cpp/mSysTools/makefile.mak
+++ b/SelfServiceCommon/Massai/cpp/mSysTools/makefile.mak
@@ -12,8 +12,6 @@ MY_LIB1 =               $(LIB_MSYSTOOLS)
 
 MY_LIB1_USER_LIBS =     $(LIB_ASSO) $(LIB_GRAPHIC) $(LIB_TEXT) $(LIB_SYSTOOLS)  $(LIB_TOOLS)
 
-MY_LIB1_LIBS =          $(SYS_ADVAPI32)
-
 ######################################################################
 
 !include $(BUILDROOT)\Build\cpp\makefile.rules.mak
diff --git a/SelfServiceCommon/Services/cpp/CardScanner/src/dump.cpp b/SelfServiceCommon/Services/cpp/CardScanner/src/dump.cpp
deleted file mode 100644
index 423f3a08..00000000
--- a/SelfServiceCommon/Services/cpp/CardScanner/src/dump.cpp
+++ /dev/null
@@ -1,372 +0,0 @@
-/**
- **************************************************************************
- *
- * @file dump.cpp
- *
- * helper functions for dumping the content of a gmrdev related Anys
- *
- * @author MaK
- *
- * Copyright (c) 2004 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-
-#if _ORBACUS_
-#include "orbIncDefs.h"
-#endif
-#include "gmrdev.h"
-
-#include <iostream>
-using namespace std;
-
-#include "dump.h"
-#include "trace.h"
-#include "textconst.h"
-
-#include "tao/Typecode.h"
-
-/**
- ******************************************************************************
- * function: void dumpCompList(std::ostream* pO, const CORBA::Any& a)
- *
- * purpose: dump the list of components to an output stream
- *
- * @@MaK 28.12.2004 12:35
- ******************************************************************************
-**/
-
-void dumpCompList(std::ostream* pO, const CORBA::Any& a)
-{
-  if(a.type() == 0)
-  {
-    *pO << "<>" << std::endl;
-    return;
-  }
-
-  const char * Name = a.type()->name();
-  if(Name)
-  {
-    *pO << "<" << Name << ">" << endl;
-    gmrdev::devFunctionality* pComps;
-    a >>= pComps;
-    if(pComps)
-    {
-      long len = pComps->types.length();
-      *pO << len << " components: {";
-      for(int i = 0; i < len; ++i)
-      {
-        *pO << compText(pComps->types[i]);
-        if(i < len - 1)
-          *pO << ", ";
-      }
-      *pO << "}" << std::endl;
-    } else
-      *pO << "(wrong type)" << std::endl;
-  }
-  else
-  {
-    *pO << "<?>" << std::endl;
-  }
-}
-
-/**
- ******************************************************************************
- * function: void dumpCompList(const CORBA::Any& a)
- *
- * purpose: dump the list of components to the trace file
- *
- * @@MaK 28.12.2004 12:35
- ******************************************************************************
-**/
-
-void dumpCompList(const CORBA::Any& a)
-{
-  if(a.type() == 0)
-  {
-    TRACE(TRC_FATAL, "invalid component list");
-    return;
-  }
-
-  const char * Name = a.type()->name();
-  if(Name)
-  {
-    TRACE(TRC_VERBOSE, "<%s>", Name);
-    gmrdev::devFunctionality* pComps;
-    a >>= pComps;
-    if(pComps)
-    {
-      char szTemp[1024];
-      long len = pComps->types.length();
-      int n = sprintf(szTemp, " components: {");
-      for(int i = 0; i < len; ++i)
-      {
-        n += sprintf(szTemp + n, "%s", compText(pComps->types[i]));
-        if(i < len - 1)
-          n += sprintf(szTemp + n, ", ");
-      }
-      n += sprintf(szTemp + n, "}");
-      TRACE(TRC_VERBOSE, "%s", szTemp);
-    } else
-      TRACE(TRC_FATAL, "<%s> - wrong type!", Name);
-  }
-  else
-  {
-    TRACE(TRC_FATAL, "invalid component list type");
-  }
-}
-
-/**
- *
- * Dump gmrdev::readerDataType to the tracefile.
- *
-**/
-void dumpGMRData(const CORBA::Any& a)
-{
-  if(a.type() == 0)
-  {
-    return;
-  }
-
-  const char * Name = a.type()->name();
-  if(Name)
-  {
-    T_TOPIC(TOP_DATA, "<%s>", Name);
-    gmrdev::readerDataType* pRDT;
-    a >>= pRDT;
-    if(pRDT)
-    {
-      TRACE(TRC_NORMAL, "readerData: component %s", compText(pRDT->type));
-      for(unsigned int i = 0; i < pRDT->tracks.length(); ++i)
-      {
-        if(pRDT->tracks[i].ds != gmrdev::OK)
-          TRACE(TRC_NORMAL, "track %d is %s", i, dataStatusText(pRDT->tracks[i].ds));
-        else
-        {
-          unsigned char * pBuf = new unsigned char[pRDT->tracks[i].data.length() + 1];
-          for(unsigned int j = 0; j < pRDT->tracks[i].data.length(); ++j)
-            pBuf[j] = pRDT->tracks[i].data[j];
-          pBuf[j] = 0;
-          TRACE(TRC_NORMAL, "track %d %s [%s]", i, dataStatusText(pRDT->tracks[i].ds), pBuf);
-          delete pBuf;
-        }
-      }
-      return;
-    }
-
-    DeviceComponents::aeaData * pAEA;
-    a >>= pAEA;
-    if(pAEA)
-    {
-      std::string s;
-      for(int i = 0; i < pAEA->length(); ++i)
-        s.append(1, (*pAEA)[i]);
-      TRACE(TRC_NORMAL, "aeaData [%s]", s.c_str());
-      return;
-    }
-
-    T_TOPIC(TOP_DATA, "(wrong type)");
-  }
-  else
-  {
-    T_TOPIC(TOP_DATA, "<?>");
-  }
-}
-
-/**
- *
- * Dump gmrdev::readerDataType to an ostream
- *
-**/
-void dumpGMRData(std::ostream* pO, const CORBA::Any& a)
-{
-  if(a.type() == 0)
-  {
-    *pO << "data: <>" << std::endl;
-    return;
-  }
-
-  const char * Name = a.type()->name();
-  if(Name)
-  {
-    *pO << "<" << Name << "> ";
-    gmrdev::readerDataType* pRDT;
-    a >>= pRDT;
-    if(pRDT)
-    {
-      *pO << "component " << compText(pRDT->type) << std::endl;
-      for(unsigned int i = 0; i < pRDT->tracks.length(); ++i)
-      {
-        if(pRDT->tracks[i].ds != gmrdev::OK)
-          *pO << "track " << i << " is " << dataStatusText(pRDT->tracks[i].ds) << std::endl;
-        else
-        {
-          unsigned char * pBuf = new unsigned char[pRDT->tracks[i].data.length() + 1];
-          for(unsigned int j = 0; j < pRDT->tracks[i].data.length(); ++j)
-            pBuf[j] = pRDT->tracks[i].data[j];
-          pBuf[j] = 0;
-          *pO << "track " << i << " " << dataStatusText(pRDT->tracks[i].ds) << " [" << pBuf << "]" << std::endl;
-          delete pBuf;
-        }
-      }
-      return;
-    }
-
-    DeviceComponents::aeaData * pAEA;
-    a >>= pAEA;
-    if(pAEA)
-    {
-      *pO << "[";
-      for(int i = 0; i < pAEA->length(); ++i)
-        *pO << (*pAEA)[i];
-      *pO << "]";
-      return;
-    }
-
-    *pO << "(wrong type)" << std::endl;
-  }
-  else
-  {
-    *pO << "<?>" << std::endl;
-  }
-}
-
-/**
- *
- * Dump gmrdev::aeaDataType to the tracefile
- *
-**/
-void dumpSetupData(const CORBA::Any& a)
-{
-  if(a.type() == 0)
-  {
-    return;
-  }
-
-  const char * Name = a.type()->name();
-  if(Name)
-  {
-    DeviceComponents::aeaData * pAEA;
-    a >>= pAEA;
-    if(pAEA)
-    {
-      std::string s;
-      for(int i = 0; i < pAEA->length(); ++i)
-        s.append(1, (*pAEA)[i]);
-      TRACE(TRC_NORMAL, "aeaData [%s]", s.c_str());
-    } else
-      TRACE(TRC_FATAL, "<%s> - wrong type!", Name);
-  }
-  else
-  {
-    T_TOPIC(TOP_DATA, "<?>");
-  }
-}
-
-/**
- *
- * Dump gmrdev::aeaDataType to an output stream.
- *
-**/
-void dumpSetupData(std::ostream* pO, const CORBA::Any& a)
-{
-  if(a.type() == 0)
-  {
-    *pO << "data: <>" << std::endl;
-    return;
-  }
-
-  const char * Name = a.type()->name();
-  if(Name)
-  {
-    *pO << "<" << Name << "> ";
-    DeviceComponents::aeaData * pAEA;
-    a >>= pAEA;
-    if(pAEA)
-    {
-      *pO << "[";
-      for(int i = 0; i < pAEA->length(); ++i)
-        *pO << (*pAEA)[i];
-      *pO << "]";
-    } else
-      *pO << "(wrong type)" << std::endl;
-  }
-  else
-  {
-    *pO << "<?>" << std::endl;
-  }
-}
-
-/**
- *
- * Dump DeviceComponents::RC to an ostream.
- *
-**/
-ostream& operator << (ostream& o, const DeviceComponents::RC& rc)
-{
-  o << RCText(rc);
-  return o;
-}
-
-/**
- *
- * Dump magcarddefrelated Anys to an ostream.
- *
-**/
-ostream& operator << (ostream& o, const CORBA::Any& A)
-{
-/*  if(A.type()->equivalent(gmrdev::_tc_cardData))
-  {
-    dumpCardData(&o, A);
-  } else*/ if(A.type()->equivalent(gmrdev::_tc_indicationType))
-  {
-    gmrdev::indicationType it;
-    A >>= it;
-    o << "<" << indicationText(it) << ">";
-  } else if(A.type()->equivalent(gmrdev::_tc_commandType))
-  {
-    gmrdev::commandType ct;
-    A >>= ct;
-    o << "<" << commandText(ct) << ">";
-  } else if(A.type()->equivalent(gmrdev::_tc_mediaStatusType))
-  {
-    gmrdev::mediaStatusType mst;
-    A >>= mst;
-    o << "<" << mediaStatusText(mst) << ">";
-  } else if(A.type()->equivalent(gmrdev::_tc_errorType))
-  {
-    gmrdev::errorType et;
-    A >>= et;
-    o << "<" << errorTypeText(et) << ">";
-  } else if(A.type()->equivalent(gmrdev::_tc_completionType))
-  {
-    gmrdev::completionType ct;
-    A >>= ct;
-    o << "<" << completionTypeText(ct) << ">";
-  } else if(A.type()->equivalent(gmrdev::_tc_status))
-  {
-    gmrdev::status* pS;
-    A >>= pS;
-    if(pS)
-    {
-      o << std::endl;
-      for(unsigned int i = 0; i < pS->statusMessage.length(); ++i)
-      {
-        o << "<" << compText(pS->statusMessage[i].componentType) << ">,<"
-                 << completionTypeText(pS->statusMessage[i].completionCode) << ">,<"
-                 << errorTypeText(pS->statusMessage[i].errorStatus) << ">,<"
-                 << mediaStatusText(pS->statusMessage[i].mediaStatus) << ">" << std::endl;
-      }
-    }
-  } else if(A.type()->equivalent(DeviceComponents::_tc_RC))
-  {
-    DeviceComponents::RC rc;
-    A >>= rc;
-    o << "<" << RCText(rc) << ">";
-  } else
-  {
-    o << "<unknown type>";
-  }
-  return o;
-}
-
diff --git a/SelfServiceCommon/Services/cpp/CardScanner/src/textconst.cpp b/SelfServiceCommon/Services/cpp/CardScanner/src/textconst.cpp
deleted file mode 100644
index 78661d63..00000000
--- a/SelfServiceCommon/Services/cpp/CardScanner/src/textconst.cpp
+++ /dev/null
@@ -1,154 +0,0 @@
-/**
- **************************************************************************
- *
- * @file textconst.cpp
- *
- * helper functions for converting constants into text (for tracing..)
- *
- * @author MaK
- *
- * Copyright (c) 2004 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-
-#if _ORBACUS_
-#include "orbIncDefs.h"
-#endif
-#include "gmrdev.h"
-
-#include "textconst.h"
-
-/**
- *
- * convert gmrdev::xxxType to a string
- *
-**/
-#define RETURNTEXT(x) case gmrdev::##x: return #x ; break
-#define RETURNTEXTMD(x) case multidevices::##x: return #x ; break
-
-const char* mediaStatusText(gmrdev::mediaStatusType mst)
-{
-  switch(mst)
-  {
-  RETURNTEXT(MEDIA_PRESENT);
-  RETURNTEXT(MEDIA_ABSENT);
-  RETURNTEXT(MEDIA_UNKNOWN);
-  }
-  return "unknown status";
-}
-
-const char* errorTypeText(gmrdev::errorType et)
-{
-  switch(et)
-  {
-  RETURNTEXT(ERR_NONE);
-  RETURNTEXT(ERR_BUSY);
-  RETURNTEXT(ERR_DISCONNECTED);
-  RETURNTEXT(ERR_HARDWARE);
-  RETURNTEXT(ERR_CONFIGURATION);
-  RETURNTEXT(ERR_MEDIA_JAMMED);
-  }
-  return "unknown status";
-}
-
-const char* completionTypeText(gmrdev::completionType ct)
-{
-  switch(ct)
-  {
-  RETURNTEXT(CMPL_COMPLETED);
-  RETURNTEXT(CMPL_CANCELLED);
-  RETURNTEXT(CMPL_CANCEL_FAILED);
-  RETURNTEXT(CMPL_ILLOGICAL);
-  RETURNTEXT(CMPL_WRONG_FORMAT);
-  RETURNTEXT(CMPL_FAILED);
-  }
-  return "unknown completionType";
-}
-
-const char* indicationText(gmrdev::indicationType it)
-{
-  switch(it)
-  {
-  RETURNTEXT(IND_CONTEXT_SWITCH_DONE);
-  RETURNTEXT(IND_DATA);
-  RETURNTEXT(IND_RESET_DONE);
-  RETURNTEXT(IND_ENABLE_DONE);
-  RETURNTEXT(IND_DISABLE_DONE);
-  RETURNTEXT(IND_STATUS_INFO);
-  RETURNTEXT(IND_COMPS_INFO);
-  RETURNTEXT(IND_SETUP_DONE);
-  RETURNTEXT(IND_POWER_SWITCH_REQUEST);
-  RETURNTEXT(IND_EJECT_DONE);
-  RETURNTEXT(IND_RETRACT_DONE);
-  RETURNTEXT(IND_TEST_DONE);
-  }
-  return "unknown indication";
-}
-
-const char* commandText(gmrdev::commandType ct)
-{
-  switch(ct)
-  {
-  RETURNTEXT(CMD_CANCEL);
-  RETURNTEXT(CMD_CONTEXT_SWITCH);
-  RETURNTEXT(CMD_SETUP);
-  RETURNTEXT(CMD_RESET);
-  RETURNTEXT(CMD_ENABLE);
-  RETURNTEXT(CMD_DISABLE);
-  RETURNTEXT(CMD_STATUS_QUERY);
-  RETURNTEXT(CMD_TEST);
-  RETURNTEXT(CMD_COMPS_QUERY);
-  RETURNTEXT(CMD_EJECT);
-  RETURNTEXT(CMD_RETRACT);
-  }
-  return "unknown command";
-}
-
-const char* RCText(DeviceComponents::RC rc)
-{
-  switch(rc)
-  {
-  case DeviceComponents::RC_ACCEPTED:       return "RC_ACCEPTED"; break;
-  case DeviceComponents::RC_OK:             return "RC_OK"; break;
-  case DeviceComponents::RC_ERROR:          return "RC_ERROR"; break;
-  case DeviceComponents::RC_STATE:          return "RC_STATE"; break;
-  case DeviceComponents::RC_LISTENER:       return "RC_LISTENER"; break;
-  case DeviceComponents::RC_NOT_SUPPORTED:  return "RC_NOT_SUPPORTED"; break;
-  }
-  return "unknown returncode";
-}
-
-const char* compText(multidevices::compType ct)
-{
-  switch(ct)
-  {
-  RETURNTEXTMD(OCR);
-  RETURNTEXTMD(BCR);
-  RETURNTEXTMD(PPR);
-  RETURNTEXTMD(MCR);
-  RETURNTEXTMD(ATBR);
-  RETURNTEXTMD(IMG);
-  RETURNTEXTMD(RFID);
-  RETURNTEXTMD(FPR);
-  RETURNTEXTMD(HAR);
-  RETURNTEXTMD(WSL);
-  RETURNTEXTMD(ISC);
-  RETURNTEXTMD(RSC);
-  RETURNTEXTMD(CCR);
-  RETURNTEXTMD(DISPENSER);
-  RETURNTEXTMD(CAPTURE);
-  }
-  return "unknown component";
-}
-
-const char* dataStatusText(gmrdev::dataStatus ds)
-{
-  switch(ds)
-  {
-  RETURNTEXT(OK);
-  RETURNTEXT(ZERO_LENGTH);
-  RETURNTEXT(CORRUPTED);
-  }
-  return "unknown dataStatus";
-}
\ No newline at end of file
diff --git a/SelfServiceCommon/Services/cpp/CxComm/StdApps/inc/argScan.hpp b/SelfServiceCommon/Services/cpp/CxComm/StdApps/inc/argScan.hpp
deleted file mode 100644
index cac922a3..00000000
--- a/SelfServiceCommon/Services/cpp/CxComm/StdApps/inc/argScan.hpp
+++ /dev/null
@@ -1,330 +0,0 @@
-/**
- **************************************************************************
- *
- * @file argScan.hpp
- *
- * Contains inline class argScan
- *
- * @note please include either <fstream> or <ftream.h> as well.
- *
- * @author JK
- *
- * Copyright (c) 1998-2000 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef ARGSCAN_HPP
-#define ARGSCAN_HPP
-#if defined(SHOW_INCLUDE_FILES)
-#pragma message("including: " __FILE__)
-#endif
-
-#include <stdlib.h>
-
-/**
- *
- * Commandline argument scanner class.
- *
-**/
-class argScan
-{
-
-   //! Copy of main-argc
-   int          M_ArgC;
-
-   //! Copy of main-argv
-   char **      M_ArgV;
-
-   //! Name of file with additional parameters (0, if none)
-   char const * M_Filename;
-
-public:
-
-   /**
-    *
-    * Constructor
-    *
-    * @param argc Please provide argc from main().
-    *
-    * @param argv Please provide argv from main().
-    *
-   **/
-   argScan( int argc, char ** argv )
-      : M_ArgC( argc ), M_ArgV( argv ), M_Filename( 0 )
-   {
-   }
-
-   /**
-    *
-    * Standard constructor - intentionally not implemented.
-    *
-   **/
-   argScan();
-
-   /**
-    *
-    * Copy constructor - intentionally not implemented.
-    *
-   **/
-   argScan( argScan const & );
-
-   /**
-    *
-    * Assignment operator - intentionally not implemented.
-    *
-   **/
-   argScan & operator=( argScan const & );
-
-   /**
-    *
-    * Give the name of a file with additional parameters.
-    * The file is supposed to contain one parameter per line.
-    *
-    * @param File path and name
-    *
-   **/
-   void file( char const * pszM_Filename )
-   {
-      M_Filename = pszM_Filename;
-   }
-
-   /**
-    *
-    * Retrieve a string argument by argument index. Every parameter, which
-    * is not an option (see option() method), is an argument. The command
-    * itself is retrieved with the index 0. The first non-option argument
-    * would be returned with the index 1. If the index exceeds the number
-    * of arguments, the 0 pointer is returned.
-    * If a parameter file (see file() method) is given, every non-empty
-    * line of the parameter file is returned as an argument. Index counting
-    * for a parameter file starts after the last index for commandline
-    * arguments.
-    *
-    * @param Index Argument index.
-    *
-    * @return Argument string.
-    *
-   **/
-   char const * argument( int Index ) const
-   {
-      int M_ArgCount = 0;           // Counts the non-special arguments
-      int AllCount = 0;             // Counts all commandline arguments
-      //
-      // Check the commandline parameters
-      //
-      while( AllCount < M_ArgC )
-      {
-         char *pArg = M_ArgV[AllCount];
-         if( (*pArg == '-') || (*pArg == '/') )
-         {
-            //
-            // Skip special arguments
-            //
-            ++AllCount;
-         }
-         else
-         {
-            //
-            // These we are interested in
-            //
-            if( M_ArgCount == Index )
-            {
-               //
-               // This has the index wanted
-               //
-               return pArg;
-            }
-            ++M_ArgCount;
-            ++AllCount;
-         }
-      }
-      //
-      // Check for an input file
-      //
-      if( M_Filename )
-      {
-         ifstream I( M_Filename );
-         static char Buffer[256];
-         for(;;)
-         {
-            // read a line
-            I.getline( Buffer, sizeof(Buffer) - 1 );
-            if( I )
-            {
-               if( Buffer[0] )
-               {
-                  // We have got a non-empty line (empty lines ignored)
-                  if( M_ArgCount == Index )
-                  {
-                     // Line index matches
-                     Buffer[sizeof(Buffer) - 1] = 0;
-                     return Buffer;
-                  }
-                  ++M_ArgCount;
-               }
-            }
-            else
-               // At end-of-file -> no success
-               return 0;
-         }
-      }
-      return 0;
-   }
-
-   /**
-    *
-    * Retrieve an integer argument by argument index. For indexes and
-    * parameterfiles see argument() method.
-    * If the index exceeds the number of arguments, the default value
-    * is returned.
-    *
-    * @param Index Argument index.
-    *
-    * @param Default The value to be returned in case of failure.
-    *
-    * @return Argument value.
-    *
-   **/
-   int argumentInteger( int Index, int Default = 0 ) const
-   {
-      char const * String = argument( Index );
-      if( String )
-         Default = atoi( String );
-      return Default;
-   }
-
-   /**
-    *
-    * Retrieve a string option by option key. An option is supposed to look
-    * like "-<key>[:<value>]" or "/<key>[:<value>]" i.e. the "/", "-" and
-    * ":" characters are treated specially.
-    * The key string should be given in upper-case only, commandline
-    * parameter evaluation then is not case-sensitive.
-    * If an option key not found, the 0 pointer is returned.
-    *
-    * @param Key Option key (without leading "-" or "/").
-    *
-    * @return Option string (all after the ":") or
-    *         0, if option not found or
-    *         the "" string (length 0), if no option value is specified.
-    *
-   **/
-   char const *option( char const * Key ) const
-   {
-      int cnt = 1;
-      while( cnt < M_ArgC )
-      {
-         char const *pArg = M_ArgV[cnt];
-         if( (*pArg == '-') || (*pArg == '/') )
-         {
-            ++pArg;
-            char const *pP = Key;
-            int Equal = 1;
-            while( *pP && Equal )
-            {
-               char X = *pArg;
-               if( ( X >= 'a' ) && ( X <= 'z' ) ) X &= ~0x20;
-               if( X != *pP )
-                  Equal = 0;
-               ++pP;
-               ++pArg;
-            }
-            if( Equal )
-            {
-               while( *pArg && ( *pArg != ':' ) ) ++pArg;
-               if( *pArg ) ++pArg;
-               return pArg;
-            }
-         }
-         ++cnt;
-      }
-      return 0;
-   }
-
-   /**
-    *
-    * Retrieve an integer option by option key.
-    * Works like the option() method and argumentInteger() method combined.
-    *
-    * @param Key Option key (without leading "-" or "/").
-    *
-    * @param Default The value to be returned in case of failure.
-    *
-    * @return Option value.
-    *
-   **/
-   int optionInteger( char const * Key, int Default = 0 ) const
-   {
-      char const * String = option( Key);
-      if( String )
-         Default = atoi( String );
-      return Default;
-   }
-
-   /**
-    *
-    * Retrieve a hexadecimal integer option by option key.
-    * Works like optionInteger(), but expects the parameter in hexadecimal
-    * notation (e.g. "affe" or "0E")
-    *
-    * @param Key Option key (without leading "-" or "/").
-    *
-    * @param Default The value to be returned in case of failure.
-    *
-    * @return Option value.
-    *
-   **/
-   int optionInteger16( char const * Key, int Default = 0 ) const
-   {
-      char const * String = option( Key );
-      if( String )
-      {
-         Default = 0;
-         while( *String )
-         {
-            int C = (int)*String++;
-            if( C >= 'A' )
-               C = (C & 0x0F) + 9;
-            else
-               C = C & 0x0F;
-            Default = Default * 0x10 + C;
-         }
-      }
-      return Default;
-   }
-
-   /**
-    *
-    * Checks the existence of commandline parameters.
-    *
-    * @return 1 if commandline contains no parameters, 0 else.
-    *
-   **/
-   int none() const
-   {
-      return M_ArgC == 1;
-   }
-
-   /**
-    *
-    * Checks the existence of commandline help patterns.
-    *
-    * @return 1, if help desired, 0 if not.
-    *
-   **/
-   int help() const
-   {
-      return option( "HELP" ) || option( "?" );
-   }
-
-};
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
-
diff --git a/SelfServiceCommon/Services/cpp/CxComm/StdApps/inc/cxAPI.h b/SelfServiceCommon/Services/cpp/CxComm/StdApps/inc/cxAPI.h
deleted file mode 100644
index ae63a574..00000000
--- a/SelfServiceCommon/Services/cpp/CxComm/StdApps/inc/cxAPI.h
+++ /dev/null
@@ -1,247 +0,0 @@
-/**
- **************************************************************************
- *
- * @file cxAPI.h
- *
- * Contains interface definitions to the cxAPI library.
- *
- * @note Define the environment variable CXAPI_TRACE to obtain event
- *       logging to stdout.
- *
- * @author JK
- *
- * Copyright (c) 1998-2000 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef CXAPI_H
-#define CXAPI_H
-#if defined(SHOW_INCLUDE_FILES)
-#pragma message("including: " __FILE__)
-#endif
-
-#ifdef __cplusplus
-#define CX_CONSTSTR const char *
-extern "C"
-{
-#else
-#define CX_CONSTSTR char *
-#endif
-
-/**
- *
- * Create a communication point.
- *
- * @param       pOwnHandle      Address of the handle variable for the new
- *                              communication point.
- *
- * @param       pszOwnName      The name for this communication point.
- *
- * @return      0 = success, otherwise failure.
- *
-**/
-long _stdcall   cxCreateHandle
-                (
-                   long *      pOwnHandle,
-                   CX_CONSTSTR pszOwnName
-                );
-
-/**
- *
- * Delete a communication point.
- *
- * @param       OwnHandle       Communication point handle.
- *
- * @return      0 = success, otherwise failure.
- *
-**/
-long _stdcall   cxDeleteHandle
-                (
-                   long        OwnHandle
-                );
-
-/**
- *
- * Retrieve a handle for an existing partner communication point.
- *
- * @param       pHandle       Address of the handle variable for the
- *                            partner communication point.
- *
- * @param       pszName       The name of the partner communication point.
- *
- * @return      0 = success, otherwise failure.
- *
-**/
-long _stdcall   cxGetHandle
-                (
-                   long *      pHandle,
-                   CX_CONSTSTR pszName
-                );
-
-/**
- *
- * Retrieve the name for a handle.
- *
- * @param       Handle          The handle to search the name for.
- *
- * @param       BufferAddress   Pointer to the buffer for the name.
- *
- * @param       BufferLength    Size of the buffer for the name.
- *
- * @return      0 = success, otherwise failure.
- *
-**/
-long _stdcall   cxGetName
-                (
-                   long        Handle,
-                   char *      BufferAddress,
-                   long        BufferLength
-                );
-
-/**
- *
- * Retrieve a handle for an existing partner communication point. If there
- * is none, wait. The function returns also, when cxDeleteHandle for
- * OwnHandle is called.
- *
- * @param       Ownhandle     The own handle, previously obtained by a call
- *                            to cxCreateHandle.
- *
- * @param       pHandle       Address of the handle variable for the
- *                            partner communication point.
- *
- * @param       pszName       The name of the partner communication point.
- *
- * @return      0 = success, otherwise failure.
- *
-**/
-long _stdcall   cxGetWaitHandle
-                (
-                   long        OwnHandle,
-                   long *      pHandle,
-                   CX_CONSTSTR pszName
-                );
-
-/**
- *
- * Write a data block to the communication partner.
- *
- * @param       OwnHandle       The origin of the data block.
- *
- * @param       PartnerHandle   The destination of the data block.
- *
- * @param       BufferAddress   Pointer to the data block to write.
- *
- * @param       BufferLength    Pointer to an integer carrying the length
- *                              of the data block. On return gives the
- *                              actually written data.
- *
- * @return      0 = success, otherwise failure.
- *
-**/
-long _stdcall   cxWrite
-                (
-                   long        OwnHandle,
-                   long        PartnerHandle,
-                   CX_CONSTSTR BufferAddress,
-                   long *      BufferLength
-                );
-
-/**
- *
- * Read a data block from a communication partner. This function blocks the
- * calling thread until data is available, unless the BufferLength variable
- * is 0. The function returns also, when cxDeleteHandle for OwnHandle is
- * called.
- *
- * @param       OwnHandle       The destination descriptor.
- *
- * @param       PartnerHandle   Pointer to an integer to put the originator
- *                              in.
- *
- * @param       BufferAddress   Pointer to the memory buffer to copy the
- *                              data block to.
- *
- * @param       BufferLength    Length of the memory buffer. On return
- *                              gives the actually length of the data blk.
- *
- * @return      0 = success, otherwise failure.
- *
-**/
-long _stdcall   cxRead
-                (
-                   long        OwnHandle,
-                   long *      PartnerHandle,
-                   char *      BufferAddress,
-                   long *      BufferLength
-                );
-
-/**
- *
- * Give an explanation for the return code.
- *
- * @param       RC              The return code of a cxAPI function.
- *
- * @return                      Pointer to a static zero-terminated string
- *                              describing the returncode.
- *
-**/
-char * _stdcall cxErrorText
-                (
-                   long RC
-                );
-
-/**
- *
- * Create a proxy for a remote communication point.
- *
- * @param       pHandle        Address of the handle variable for the new
- *                             communication point.
- *
- * @param       pszLocalname   The local name for this communication point.
- *
- * @param       pszRemotename  The name on the remote host
- *                             (maybe equal to pszLocalname)
- *
- * @param       pszHost        The host to create the proxy for.
- *
- * @return      0 = success, otherwise failure.
- *
-**/
-long _stdcall   cxCreateProxyHandle
-                (
-                   long *      pHandle,
-                   CX_CONSTSTR pszLocalname,
-                   CX_CONSTSTR pszRemotename,
-                   CX_CONSTSTR pszHost
-                );
-
-#ifdef __cplusplus
-}
-#endif
-
-/*
-   Returncodes
-*/
-#define CXRC_OK                    0
-#define CXRC_ERROR                 1
-#define CXRC_WRONG_PARAMETER       2
-#define CXRC_NAME_ALREADY_EXISTS   3
-#define CXRC_NOT_FOUND             4
-#define CXRC_BUFFER_TOO_SMALL      5
-#define CXRC_MORE_DATA             6
-#define CXRC_PARTNER_LOST          7
-#define CXRC_CANCELLED             8
-#define CXRC_WRONG_PARTNER         9
-#define CXRC_WRONG_HANDLE          10
-#define CXRC_TRY_AGAIN             11
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
-
diff --git a/SelfServiceCommon/Services/cpp/CxComm/StdApps/inc/cxAPI.hpp b/SelfServiceCommon/Services/cpp/CxComm/StdApps/inc/cxAPI.hpp
deleted file mode 100644
index e4d62738..00000000
--- a/SelfServiceCommon/Services/cpp/CxComm/StdApps/inc/cxAPI.hpp
+++ /dev/null
@@ -1,160 +0,0 @@
-/**
- **************************************************************************
- *
- * @file cxAPI.hpp
- *
- * C++ Interface for the CXAPI library. This is based upon the the "C"
- * interface defined in "cxAPI.h".
- *
- * @author JK
- *
- * Copyright (c) 1999-2001 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef CXAPI_HPP
-#define CXAPI_HPP
-#if defined(SHOW_INCLUDE_FILES)
-#pragma message("including: " __FILE__)
-#endif
-
-#include "cxapi.h"
-
-#define CXMODE_WAIT 1
-
-class cxAPI
-{
-
-   /**
-    *
-    * Communication handle
-    *
-   **/
-   long M_Handle;
-
-   /**
-    *
-    * Return code of handle creation, can be used for debugging.
-    *
-   **/
-   long M_CreateRC;
-
-   /**
-    *
-    * Standard constructor - intentionally not implemented.
-    *
-   **/
-   cxAPI();
-
-   /**
-    *
-    * Copy constructor - intentionally not implemented.
-    *
-   **/
-   cxAPI( const cxAPI & );
-
-public:
-
-   /**
-    *
-    * Constructor
-    *
-    * Creates a CX communication object for the name given.
-    *
-    * @param OwnName The own name to use.
-    *
-   **/
-   explicit cxAPI( const char * OwnName ) :
-      M_Handle( 0 ),
-      M_CreateRC( cxCreateHandle( & M_Handle, OwnName ) )
-   {
-   }
-
-   /**
-    *
-    * Destructor
-    *
-    * Deletes the CX communication object.
-    *
-   **/
-   ~cxAPI()
-   {
-      cxDeleteHandle( M_Handle );
-      M_Handle = 0;
-   }
-
-   /**
-    *
-    * Obtains a handle for a target communication object. Input parameters
-    * are the name of the target object and eventually an operation mode.
-    * If the mode CXMODE_WAIT is given the function does not return, until
-    * the target is ready or this object is destroyed.
-    *
-   **/
-   long getHandle( long & TgtHandle, const char * TgtName, int Mode = 0 )
-   {
-      if( Mode == CXMODE_WAIT )
-         return cxGetWaitHandle( M_Handle, &TgtHandle, TgtName );
-      else
-         return cxGetHandle( &TgtHandle, TgtName );
-   }
-
-   /**
-    *
-    * Obtains the target name for a handle given. Input parameters are
-    * the destination buffer and the destination buffer size.
-    *
-   **/
-   long getName( char * pBuffer, long nBuffer, long TgtHandle )
-   {
-      return cxGetName( TgtHandle, pBuffer, nBuffer );
-   }
-
-   /**
-    *
-    * Writes a message to the destination object. Input parameters are
-    * a handle to the destination object, the address of the source buffer
-    * and a reference to the length of the source buffer.
-    *
-   **/
-   long write( long DstHandle, const char * pSrc, long & nSrc )
-   {
-      return cxWrite( M_Handle, DstHandle, pSrc, &nSrc );
-   }
-
-   /**
-    *
-    * Reads a message from a source object. Input parameters are address
-    * of the destination buffer, and a reference to the length of the
-    * buffer.
-    *
-   **/
-   long read( char * pDst, long & nDst )
-   {
-      long SrcHandle;
-      return cxRead( M_Handle, &SrcHandle, pDst, &nDst );
-   }
-
-   /**
-    *
-    * Reads a message from a source object. Input parameters are address
-    * of the destination buffer, a reference to the length of the
-    * buffer and a reference to a handle for the source object.
-    *
-   **/
-   long read( long & SrcHandle, char * pDst, long & nDst )
-   {
-      return cxRead( M_Handle, &SrcHandle, pDst, &nDst );
-   }
-
-};
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
-
diff --git a/SelfServiceCommon/Services/cpp/CxComm/StdApps/inc/matThread.hpp b/SelfServiceCommon/Services/cpp/CxComm/StdApps/inc/matThread.hpp
deleted file mode 100644
index 98821900..00000000
--- a/SelfServiceCommon/Services/cpp/CxComm/StdApps/inc/matThread.hpp
+++ /dev/null
@@ -1,312 +0,0 @@
-/**
- **************************************************************************
- *
- * @file matThread.hpp
- *
- * Contains interface definitions for OS-Independent thread functions.
- *
- * @author JK
- *
- * Copyright (c) 2000 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef MATTHREAD_HPP
-#define MATTHREAD_HPP
-#if defined(SHOW_INCLUDE_FILES)
-#pragma message("including: " __FILE__)
-#endif
-
-
-
-/**
- *
- * Returncodes
- *
-**/
-typedef enum
-{
-   //! Successful completion
-   THREADRC_OK,
-
-   //! Hard error
-   THREADRC_ERROR,
-
-   //! Timeout occured
-   THREADRC_TIMEOUT
-
-} matThreadRC;
-
-
-
-/**
- *
- * Thread priorities
- *
-**/
-typedef enum
-{
-   //! Above normal
-   THREADPRTY_HIGH = 2,
-
-   //! Normal
-   THREADPRTY_NORMAL,
-
-   //! Below normal
-   THREADPRTY_LOW
-
-} matThreadPrty;
-
-
-
-/**
- *
- * For debugging purposes a trace function can be given during object
- * construction (trace constructor). This function then is called upon
- * certain events.
- *
- * @param Level A value between 1 and 9 to give a hint about the
- *              problem severity. 1 means normal operation, 9 means
- *              fatal error. An implementation might want to ignore
- *              all events below a certain threshold.
- *
- * @param Text  A zero-terminated string describing the event.
- *
-**/
-
-typedef void (* matThreadTrace)
-                (
-                   long         Level,
-                   char const * Text
-                );
-
-
-
-/**
- **************************************************************************
- *
- * The matThread class can be used to control thread execution.
- * It can as well serve as a shared memory for inter-thread communication.
- * To use matThread, an application must derive from matThread with
- * a class of its own and then implement the virtual function() method.
- * A real execution is started, when the application calls the start()
- * method. Then the function() is called in the new separate thread.
- * The thread execution is terminated, when the function() returns.
- *
- * @note The application can as well force the thread execution to
- * @note terminate by calling the stop() method or simply by destroying the
- * @note matThread-derived object. Doing so however always induces the risk
- * @note of resource (memory) leaks.
- *
- **************************************************************************
-**/
-class matThread
-{
-
-   /**
-    *
-    * The implementation might want to make use of additional class data.
-    * Thus it defines a private handle class.
-    *
-   **/
-   friend class matThread_Handle;
-
-   /**
-    *
-    * The M_Handle refers to private elements of the matThread implementation.
-    *
-   **/
-   matThread_Handle * M_Handle;
-
-   /**
-    *
-    * Must be overloaded with the clients thread function.
-    *
-   **/
-   virtual void function() = 0;
-
-public:
-
-   /**
-    *
-    * Standard constructor
-    *
-    *  @param Stack The minimum size (in bytes) for the thread stack.
-   **/
-   matThread( long Stack = 0 );
-
-   /**
-    *
-    * Trace constructor
-    *
-    * @param Trace The function to be called for trace events.
-    *
-    * @param Stack The minimum size (in bytes) for the thread stack.
-    *
-   **/
-   matThread( matThreadTrace Trace, long Stack = 0 );
-
-   /**
-    *
-    * Copy constructor - intentionally not implemented.
-    *
-   **/
-   matThread( matThread const & );
-
-   /**
-    *
-    * Destructor.
-    *
-    * Terminates the thread execution, if running. Frees all allocated
-    * resources.
-    *
-   **/
-   virtual ~matThread();
-
-   /**
-    *
-    * Assignment operator - intentionally not implemented.
-    *
-   **/
-   matThread & operator=( matThread const & );
-
-   /**
-    *
-    * Public method.
-    *
-    * Starts a new thread, should be called only once or after stop().
-    *
-    * @param Prty The initial priority for the new thread.
-    *
-    * @return THREADRC_OK or TRHEADRC_ERROR.
-    *
-   **/
-   matThreadRC start( matThreadPrty Prty = THREADPRTY_NORMAL );
-
-   /**
-    *
-    * Public method
-    *
-    * Stops an existing thread, should be called only after start().
-    *
-    * @return THREADRC_OK or TRHEADRC_ERROR.
-    *
-   **/
-   matThreadRC stop();
-
-   /**
-    *
-    * Public method
-    *
-    * Wait for a thread to terminate.
-    *
-    * @return THREADRC_OK if thread has terminated,
-    *         TRHEADRC_ERROR if thread not yet started.
-    *
-   **/
-   matThreadRC waitTerminated();
-
-   /**
-    *
-    * Public method
-    *
-    * Wait a specified time for a thread to terminate.
-    *
-    * @param Time The maximum time to wait in milliseconds.
-    *
-    * @return THREADRC_OK if thread has terminated,
-    *         THREADRC_TIMEOUT if thread still running,
-    *         TRHEADRC_ERROR if thread not yet started.
-    *
-   **/
-   matThreadRC waitTerminated( long Time );
-
-};
-
-
-
-/**
- *
- * Thread function.
- *
- * @param  ThreadFParameter.
- *
-**/
-typedef void ( *matThreadF )( void * ThreadFParameter );
-
-/**
- *
- * Public function
- *
- * Start a thread with the function given.
- *
- * @param ThreadF The function to be called with the new thread.
- *
- * @param ThreadFParameter The function parameter.
- *
- * @param Stack The stacksize to be reserved (option).
- *
- * @param Trace The function to be called for trace events.
- *
- * @return THREADRC_OK or THREADRC_ERROR.
- *
-**/
-matThreadRC matThreadFStart
-     (
-        matThreadF     ThreadF,
-        void *         ThreadFParameter,
-        long           Stack = 0,
-        matThreadTrace Trace = 0
-     );
-
-
-
-/**
- *
- * Public function
- *
- * Returns the current threads id
- *
- * @return         The thread id
- *
-**/
-long matThreadId();
-
-
-
-/**
- *
- * Public function
- *
- * Change the current threads priority
- *
- * @param  Prty    The desired priority.
- *
- * @return THREADRC_OK or THREADRC_ERROR.
- *
-**/
-matThreadRC matThreadSetPrty( matThreadPrty Prty );
-
-
-
-/**
- *
- * Public function
- *
- * Suspends execution of the current thread for the time given.
- *
- * @param  Time    The time in milliseconds
- *
-**/
-void matThreadSleep( long Time );
-
-
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
diff --git a/SelfServiceCommon/Services/cpp/CxComm/StdApps/makefile.mak b/SelfServiceCommon/Services/cpp/CxComm/StdApps/makefile.mak
index c4598d6c..ce031e34 100644
--- a/SelfServiceCommon/Services/cpp/CxComm/StdApps/makefile.mak
+++ b/SelfServiceCommon/Services/cpp/CxComm/StdApps/makefile.mak
@@ -6,17 +6,19 @@
 
 !include $(BUILDROOT)\Build\cpp\makefile.common.mak
 
+MY_CFLAGS= $(INC_COMMON_INTER)
+
 ######################################################################
 
 MY_BIN1 = \
     $(_BIN)\CxProxy.exe
 
 MY_BIN1_USER_LIBS = \
-    $(LIB_CXAPI)
+    $(LIB_CXAPI) \
+    $(LIB_SYSTOOLS)
 
 MY_BIN1_OBJS = \
-    $(_OBJ)\CxProxy.obj \
-    $(_OBJ)\matThreadW32.obj
+    $(_OBJ)\CxProxy.obj
 
 MY_BIN1_RES = \
     $(_OBJ)\CxProxy.res
@@ -56,11 +58,11 @@ MY_BIN4 = \
     $(_BIN)\CxTestS.exe
 
 MY_BIN4_USER_LIBS = \
-    $(LIB_CXAPI)
+    $(LIB_CXAPI) \
+    $(LIB_SYSTOOLS)
 
 MY_BIN4_OBJS = \
-    $(_OBJ)\CxTestS.obj \
-    $(_OBJ)\matThreadW32.obj
+    $(_OBJ)\CxTestS.obj
 
 MY_BIN4_RES = \
     $(_OBJ)\CxTestS.res
diff --git a/SelfServiceCommon/Services/cpp/CxComm/StdApps/src/matThreadW32.cpp b/SelfServiceCommon/Services/cpp/CxComm/StdApps/src/matThreadW32.cpp
deleted file mode 100644
index cd55c7b5..00000000
--- a/SelfServiceCommon/Services/cpp/CxComm/StdApps/src/matThreadW32.cpp
+++ /dev/null
@@ -1,580 +0,0 @@
-/**
- **************************************************************************
- *
- * @file matThreadW32.cpp
- *
- * Implements the functions defined in matThread.hpp for Win32
- * environment.
- *
- * @author JK
- *
- * Copyright (c) 2000 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-
-#include "matThread.hpp"
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <process.h>
-
-#include <windows.h>
-#include <winbase.h>
-
-
-
-#define TRACE_LEVEL_ERROR  1       // Major error
-#define TRACE_LEVEL_NORMAL 7       // Secondary runtime
-
-#define NT_MIN_STACK 65536
-
-
-
-static char * makeChild( char * Buf, char const * Src )
-{
-   sprintf( Buf, "child[%d]: %s", matThreadId(), Src );
-   return Buf;
-}
-
-
-
-static char * makeParent( char * Buf, char const * Src )
-{
-   sprintf( Buf, "parent[%d]: %s", matThreadId(), Src );
-   return Buf;
-}
-
-
-
-static matThreadRC win2rc( DWORD WErr )
-{
-   switch( WErr )
-   {
-   case ERROR_SUCCESS: return THREADRC_OK;
-   case WAIT_TIMEOUT:  return THREADRC_TIMEOUT;
-   default:            return THREADRC_ERROR;
-   }
-}
-
-
-
-/**
- **************************************************************************
- *
- * Handle class
- *
- **************************************************************************
-**/
-class matThread_Handle
-{
-
-   //! CLient trace function
-   matThreadTrace MH_Trace;
-
-   //! Refers the parent thread class
-   matThread *    MH_pPublic;
-
-public:
-
-   //! Win32 thread handle
-   HANDLE         MH_Handle;
-
-   //! Stack allocated for thread
-   long           MH_Stacksize;
-
-   //! Thread status
-   int            MH_Terminated;
-
-   //! Semaphore to control the start sequence
-   HANDLE         MH_StartSema;
-
-   /**
-    *
-    * Trace normal events
-    *
-   **/
-   void        traceNormal( char const * Text )
-               {
-                  if( MH_Trace )
-                  {
-                     char Buffer[256];
-                     MH_Trace( TRACE_LEVEL_NORMAL, makeParent( Buffer, Text ) );
-                  }
-               }
-
-   /**
-    *
-    * Trace error events
-    *
-   **/
-   void        traceError( char const * Text )
-               {
-                  if( MH_Trace )
-                  {
-                     char Buffer[256];
-                     MH_Trace( TRACE_LEVEL_ERROR, makeParent( Buffer, Text ) );
-                  }
-               }
-
-   /**
-    *
-    * Trace Win32 errors
-    *
-   **/
-   matThreadRC traceLastError( char const * Text )
-               {
-                  DWORD LE = GetLastError();
-                  if( MH_Trace )
-                  {
-                     char Buffer[256];
-                     char TBuffer[256];
-                     sprintf( TBuffer, "%s error %d", Text, LE );
-                     MH_Trace( TRACE_LEVEL_ERROR, makeParent( Buffer, TBuffer ) );
-                  }
-                  return win2rc( LE );
-               }
-
-   /**
-    *
-    * Thread function
-    *
-   **/
-   void        function()
-               {
-                  if( MH_Trace )
-                  {
-                     char Buffer[256];
-                     MH_Trace( TRACE_LEVEL_NORMAL, makeChild( Buffer, "call" ) );
-                               MH_pPublic->function();
-                     MH_Trace( TRACE_LEVEL_NORMAL, makeChild( Buffer, "return" ) );
-                  }
-                  else
-                     MH_pPublic->function();
-               }
-
-   /**
-    *
-    * Constructor
-    *
-    * @param IFObject Refers the parent thread class
-    *
-    * @param Stack    The thread stack
-    *
-    * @param Trace    The trace function to use (may be 0)
-    *
-   **/
-   matThread_Handle
-   (
-      matThread *              IFObject,
-      long                     Stack,
-      matThreadTrace           Trace
-    ) :
-      MH_Trace( Trace ),
-      MH_pPublic( IFObject ),
-      MH_Handle( 0 ),
-      MH_Stacksize( ( Stack > NT_MIN_STACK ) ? Stack : NT_MIN_STACK ),
-      MH_Terminated( 1 ),
-      MH_StartSema( CreateEvent( 0, TRUE, FALSE, 0 ) )
-   {
-      if( Trace )
-      {
-         char Buffer[256];
-         Trace( TRACE_LEVEL_NORMAL, makeParent( Buffer, "created" ) );
-      }
-   }
-
-   /**
-    *
-    * Standard constructor - intentionally not implemented.
-    *
-   **/
-   matThread_Handle();
-
-   /**
-    *
-    * Destructor
-    *
-   **/
-   ~matThread_Handle()
-   {
-      if( MH_Trace )
-      {
-         char Buffer[256];
-         MH_Trace( TRACE_LEVEL_NORMAL, makeParent( Buffer, "deleted" ) );
-      }
-   }
-
-};
-
-
-
-/**
- **************************************************************************
- *
- * Controls child thread execution.
- *
- * @param pV "void" pointer to handle class
- *
- **************************************************************************
-**/
-#ifdef __IBMCPP__
-static void _Optlink privateEnterThreadC( void * pV )
-#else
-static void __cdecl privateEnterThreadC( void * pV )
-#endif
-{
-   matThread_Handle *pPara = (matThread_Handle *)pV;
-   SetEvent( pPara->MH_StartSema );
-   pPara->MH_Terminated = 0;
-   pPara->function();
-   pPara->MH_Terminated = 1;
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThread::matThread( long stacksize ) :
-   M_Handle( 0 )
-{
-   M_Handle = new matThread_Handle( this, stacksize, 0 );
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThread::matThread( matThreadTrace Trace, long stacksize ) :
-   M_Handle( 0 )
-{
-   M_Handle = new matThread_Handle( this, stacksize, Trace );
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThread::~matThread()
-{
-   M_Handle->traceNormal( "~matThread ..." );
-   if( M_Handle->MH_Handle )
-   {
-      if( !M_Handle->MH_Terminated )
-      {
-        M_Handle->traceNormal( "~matThread - terminate" );
-        TerminateThread( M_Handle->MH_Handle, 13 );
-      }
-      CloseHandle( M_Handle->MH_Handle );
-   }
-
-   //@@MaK CloseHandle( M_Handle->MH_StartSema );
-   M_Handle->traceNormal( "~matThread." );
-   delete M_Handle;
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThreadRC matThread::start( matThreadPrty Prty )
-{
-   if( M_Handle->MH_Handle )
-   {
-      if( !M_Handle->MH_Terminated )
-      {
-         //
-         // Thread currently running - do not start twice
-         //
-         M_Handle->traceError( "start - ignored" );
-         return THREADRC_ERROR;
-      }
-      CloseHandle( M_Handle->MH_Handle );
-      M_Handle->MH_Handle = 0;
-   }
-
-#ifdef __IBMCPP__
-   HANDLE NewHandle = (HANDLE)_beginthread
-                      (
-                         privateEnterThreadC,
-                         NULL,
-                         M_Handle->MH_Stacksize,
-                         M_Handle
-                      );
-#else
-   HANDLE NewHandle = (HANDLE)_beginthread
-                      (
-                         privateEnterThreadC,
-                         M_Handle->MH_Stacksize,
-                         M_Handle
-                      );
-#endif
-   if( NewHandle == 0 )
-   {
-      return M_Handle->traceLastError( "start - CreateThread" );
-   }
-#if 0 //@@MaK
-   if
-   (
-      !DuplicateHandle
-      (
-         GetCurrentProcess(), NewHandle,
-         GetCurrentProcess(), &M_Handle->MH_Handle,
-         0, FALSE, DUPLICATE_SAME_ACCESS
-      )
-   )
-   {
-      return M_Handle->traceLastError( "start - DuplicateHandle" );
-   }
-#else
-   M_Handle->MH_Handle = NewHandle;
-#endif
-
-   M_Handle->traceNormal( "start - waiting" );
-   WaitForSingleObject( M_Handle->MH_StartSema, INFINITE );
-
-   //@@MaK
-   CloseHandle( M_Handle->MH_StartSema );
-
-   Sleep( 1 );
-   M_Handle->traceNormal( "start" );
-   switch( Prty )
-   {
-   default:
-      return THREADRC_OK;
-   case THREADPRTY_HIGH:
-      if
-      (
-         SetThreadPriority
-         (
-            M_Handle->MH_Handle,
-            THREAD_PRIORITY_ABOVE_NORMAL
-         )
-      ) return THREADRC_OK;
-      else return M_Handle->traceLastError( "start - SetThreadPriority" );
-   case THREADPRTY_LOW:
-      if
-      (
-         SetThreadPriority
-         (
-            M_Handle->MH_Handle,
-            THREAD_PRIORITY_BELOW_NORMAL
-         )
-      ) return THREADRC_OK;
-      else return M_Handle->traceLastError( "start - SetThreadPriority" );
-   }
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThreadRC matThread::stop()
-{
-   if( M_Handle->MH_Handle == 0 )
-   {
-      //
-      // Thread currently not running - cannot stop it
-      //
-      M_Handle->traceError( "stop - error" );
-      return THREADRC_ERROR;
-   }
-   M_Handle->traceNormal( "stop" );
-   TerminateThread( M_Handle->MH_Handle, 12 );
-   CloseHandle( M_Handle->MH_Handle );
-   M_Handle->MH_Handle = 0;
-   M_Handle->MH_Terminated = 1;
-   return THREADRC_OK;
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThreadRC matThread::waitTerminated()
-{
-   return waitTerminated( INFINITE );
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThreadRC matThread::waitTerminated( long Time )
-{
-   M_Handle->traceNormal( "waitTerminated ..." );
-   int RC = WaitForSingleObject( M_Handle->MH_Handle, Time );
-   switch( RC )
-   {
-   default:
-      M_Handle->traceNormal( "waitTerminated - error." );
-      return THREADRC_ERROR;
-   case WAIT_TIMEOUT:
-      M_Handle->traceNormal( "waitTerminated - timeout." );
-      return THREADRC_TIMEOUT;
-   case ERROR_SUCCESS:
-      M_Handle->traceNormal( "waitTerminated." );
-      return THREADRC_OK;
-   }
-}
-
-
-
-/**
- *
- * Handle parameters to the thread function
- *
-**/
-struct privatePara
-{
-
-   //! Client function pointer
-   matThreadF     pFunc;
-
-   //! Client function parameters
-   void *         FuncPara;
-
-   //! Client trace function
-   matThreadTrace Trace;
-
-};
-
-
-
-/**
- **************************************************************************
- *
- * Thread function
- *
- * @param pV "void" pointer to handle structure
- *
- **************************************************************************
-**/
-#ifdef __IBMCPP__
-static void _Optlink privateEnterThreadF( void * pV )
-#else
-static void __cdecl privateEnterThreadF( void * pV )
-#endif
-{
-   privatePara * pP = (privatePara *)pV;
-   if( pP->Trace )
-   {
-      char Buf[64];
-      sprintf( Buf, "[%d] ...", GetCurrentThreadId() );
-      pP->Trace( TRACE_LEVEL_NORMAL, Buf );
-   }
-   pP->pFunc( pP->FuncPara );
-   if( pP->Trace )
-   {
-      char Buf[64];
-      sprintf( Buf, "[%d].", GetCurrentThreadId() );
-      pP->Trace( TRACE_LEVEL_NORMAL, Buf );
-   }
-   delete pV;
-}
-
-
-
-/**
- *
- * Interface function implementation
- *
-**/
-matThreadRC matThreadFStart
-(
-   matThreadF     ThreadF,
-   void *         ThreadFParameter,
-   long           Stack,
-   matThreadTrace Trace
-)
-{
-   HANDLE H;
-   privatePara * pP = new privatePara;
-   pP->pFunc = ThreadF;
-   pP->FuncPara = ThreadFParameter;
-   pP->Trace = Trace;
-#ifdef __IBMCPP__
-   H = (HANDLE)_beginthread
-       (
-          privateEnterThreadF,
-          NULL,
-          (Stack > NT_MIN_STACK) ? Stack : NT_MIN_STACK,
-          pP
-       );
-#else
-   H = (HANDLE)_beginthread
-       (
-          privateEnterThreadF,
-          (Stack > NT_MIN_STACK) ? Stack : NT_MIN_STACK,
-          pP
-       );
-#endif
-   if( H == (HANDLE)-1 )
-   {
-      if( Trace ) Trace( TRACE_LEVEL_ERROR, "matThreadFStart failed" );
-      return win2rc( GetLastError() );
-   }
-   else
-   {
-      if( Trace )
-      {
-         char Buf[64];
-         sprintf( Buf, "matThreadFStart" );
-         Trace( TRACE_LEVEL_NORMAL, Buf );
-      }
-      return THREADRC_OK;
-   }
-}
-
-
-
-/**
- *
- * Interface function implementation
- *
-**/
-long matThreadId()
-{
-   return GetCurrentThreadId();
-}
-
-
-
-/**
- *
- * Interface function implementation
- *
-**/
-void matThreadSleep( long milliSeconds )
-{
-   Sleep( milliSeconds );
-}
-
-
-
-//-------------------------------------------------------------------------
-//
-// End of file
-//
-//-------------------------------------------------------------------------
diff --git a/SelfServiceCommon/Services/cpp/CxComm/dll/inc/cxAPI.h b/SelfServiceCommon/Services/cpp/CxComm/dll/inc/cxAPI.h
deleted file mode 100644
index ae63a574..00000000
--- a/SelfServiceCommon/Services/cpp/CxComm/dll/inc/cxAPI.h
+++ /dev/null
@@ -1,247 +0,0 @@
-/**
- **************************************************************************
- *
- * @file cxAPI.h
- *
- * Contains interface definitions to the cxAPI library.
- *
- * @note Define the environment variable CXAPI_TRACE to obtain event
- *       logging to stdout.
- *
- * @author JK
- *
- * Copyright (c) 1998-2000 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef CXAPI_H
-#define CXAPI_H
-#if defined(SHOW_INCLUDE_FILES)
-#pragma message("including: " __FILE__)
-#endif
-
-#ifdef __cplusplus
-#define CX_CONSTSTR const char *
-extern "C"
-{
-#else
-#define CX_CONSTSTR char *
-#endif
-
-/**
- *
- * Create a communication point.
- *
- * @param       pOwnHandle      Address of the handle variable for the new
- *                              communication point.
- *
- * @param       pszOwnName      The name for this communication point.
- *
- * @return      0 = success, otherwise failure.
- *
-**/
-long _stdcall   cxCreateHandle
-                (
-                   long *      pOwnHandle,
-                   CX_CONSTSTR pszOwnName
-                );
-
-/**
- *
- * Delete a communication point.
- *
- * @param       OwnHandle       Communication point handle.
- *
- * @return      0 = success, otherwise failure.
- *
-**/
-long _stdcall   cxDeleteHandle
-                (
-                   long        OwnHandle
-                );
-
-/**
- *
- * Retrieve a handle for an existing partner communication point.
- *
- * @param       pHandle       Address of the handle variable for the
- *                            partner communication point.
- *
- * @param       pszName       The name of the partner communication point.
- *
- * @return      0 = success, otherwise failure.
- *
-**/
-long _stdcall   cxGetHandle
-                (
-                   long *      pHandle,
-                   CX_CONSTSTR pszName
-                );
-
-/**
- *
- * Retrieve the name for a handle.
- *
- * @param       Handle          The handle to search the name for.
- *
- * @param       BufferAddress   Pointer to the buffer for the name.
- *
- * @param       BufferLength    Size of the buffer for the name.
- *
- * @return      0 = success, otherwise failure.
- *
-**/
-long _stdcall   cxGetName
-                (
-                   long        Handle,
-                   char *      BufferAddress,
-                   long        BufferLength
-                );
-
-/**
- *
- * Retrieve a handle for an existing partner communication point. If there
- * is none, wait. The function returns also, when cxDeleteHandle for
- * OwnHandle is called.
- *
- * @param       Ownhandle     The own handle, previously obtained by a call
- *                            to cxCreateHandle.
- *
- * @param       pHandle       Address of the handle variable for the
- *                            partner communication point.
- *
- * @param       pszName       The name of the partner communication point.
- *
- * @return      0 = success, otherwise failure.
- *
-**/
-long _stdcall   cxGetWaitHandle
-                (
-                   long        OwnHandle,
-                   long *      pHandle,
-                   CX_CONSTSTR pszName
-                );
-
-/**
- *
- * Write a data block to the communication partner.
- *
- * @param       OwnHandle       The origin of the data block.
- *
- * @param       PartnerHandle   The destination of the data block.
- *
- * @param       BufferAddress   Pointer to the data block to write.
- *
- * @param       BufferLength    Pointer to an integer carrying the length
- *                              of the data block. On return gives the
- *                              actually written data.
- *
- * @return      0 = success, otherwise failure.
- *
-**/
-long _stdcall   cxWrite
-                (
-                   long        OwnHandle,
-                   long        PartnerHandle,
-                   CX_CONSTSTR BufferAddress,
-                   long *      BufferLength
-                );
-
-/**
- *
- * Read a data block from a communication partner. This function blocks the
- * calling thread until data is available, unless the BufferLength variable
- * is 0. The function returns also, when cxDeleteHandle for OwnHandle is
- * called.
- *
- * @param       OwnHandle       The destination descriptor.
- *
- * @param       PartnerHandle   Pointer to an integer to put the originator
- *                              in.
- *
- * @param       BufferAddress   Pointer to the memory buffer to copy the
- *                              data block to.
- *
- * @param       BufferLength    Length of the memory buffer. On return
- *                              gives the actually length of the data blk.
- *
- * @return      0 = success, otherwise failure.
- *
-**/
-long _stdcall   cxRead
-                (
-                   long        OwnHandle,
-                   long *      PartnerHandle,
-                   char *      BufferAddress,
-                   long *      BufferLength
-                );
-
-/**
- *
- * Give an explanation for the return code.
- *
- * @param       RC              The return code of a cxAPI function.
- *
- * @return                      Pointer to a static zero-terminated string
- *                              describing the returncode.
- *
-**/
-char * _stdcall cxErrorText
-                (
-                   long RC
-                );
-
-/**
- *
- * Create a proxy for a remote communication point.
- *
- * @param       pHandle        Address of the handle variable for the new
- *                             communication point.
- *
- * @param       pszLocalname   The local name for this communication point.
- *
- * @param       pszRemotename  The name on the remote host
- *                             (maybe equal to pszLocalname)
- *
- * @param       pszHost        The host to create the proxy for.
- *
- * @return      0 = success, otherwise failure.
- *
-**/
-long _stdcall   cxCreateProxyHandle
-                (
-                   long *      pHandle,
-                   CX_CONSTSTR pszLocalname,
-                   CX_CONSTSTR pszRemotename,
-                   CX_CONSTSTR pszHost
-                );
-
-#ifdef __cplusplus
-}
-#endif
-
-/*
-   Returncodes
-*/
-#define CXRC_OK                    0
-#define CXRC_ERROR                 1
-#define CXRC_WRONG_PARAMETER       2
-#define CXRC_NAME_ALREADY_EXISTS   3
-#define CXRC_NOT_FOUND             4
-#define CXRC_BUFFER_TOO_SMALL      5
-#define CXRC_MORE_DATA             6
-#define CXRC_PARTNER_LOST          7
-#define CXRC_CANCELLED             8
-#define CXRC_WRONG_PARTNER         9
-#define CXRC_WRONG_HANDLE          10
-#define CXRC_TRY_AGAIN             11
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
-
diff --git a/SelfServiceCommon/Services/cpp/CxComm/dll/inc/cxAPIi.h b/SelfServiceCommon/Services/cpp/CxComm/dll/inc/cxAPIi.h
deleted file mode 100644
index 01835838..00000000
--- a/SelfServiceCommon/Services/cpp/CxComm/dll/inc/cxAPIi.h
+++ /dev/null
@@ -1,58 +0,0 @@
-
-/*
-===========================================================================
-
-   File:    CXAPII.H
-
-===========================================================================
-*/
-#if defined(SHOW_INCLUDE_FILES)
-#pragma message("including: " __FILE__)
-#endif
-
-
-#include "cxapi.h"
-
-
-//define DllExport __declspec( dllexport )
-#define DllExport
-
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif
-
-
-/*
----------------------------------------------------------------------------
-   State request
-
-   Parameter:   Handle:         The handle to search the state for
-
-                BufferAddress:  Pointer to the buffer for the state
-
-                BufferLength:   Size of the buffer for the state
-
-   Returns:     0:              Success
-                otherwise:      Failure
----------------------------------------------------------------------------
-*/
-long _stdcall   cxGetState
-                (
-                   long     Handle,
-                   char *   BufferAddress,
-                   long     BufferLength
-                );
-
-#ifdef __cplusplus
-}
-#endif
-
-
-/*
-===========================================================================
-                             end of file
-===========================================================================
-*/
-
diff --git a/SelfServiceCommon/Services/cpp/CxComm/dll/inc/eventSem.hpp b/SelfServiceCommon/Services/cpp/CxComm/dll/inc/eventSem.hpp
deleted file mode 100644
index 9d70ff81..00000000
--- a/SelfServiceCommon/Services/cpp/CxComm/dll/inc/eventSem.hpp
+++ /dev/null
@@ -1,125 +0,0 @@
-/**
- **************************************************************************
- *
- * @file eventSem.hpp
- *
- * Interface definitions for event semaphore class.
- *
- * @author JK
- *
- * Copyright (c) 1997-2000 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef EVENTSEM_HPP
-#define EVENTSEM_HPP
-#if defined(SHOW_INCLUDE_FILES)
-#pragma message("including: " __FILE__)
-#endif
-
-
-/**
- *
- * Event semaphore class.
- *
-**/
-class eventSemaphore
-{
-
-   //! Handle
-   unsigned long hES;
-
-   //! Index
-   unsigned long iID;
-
-public:
-
-   /**
-    *
-    * Standard constructor
-    *
-   **/
-   eventSemaphore();
-
-   /**
-    *
-    * named constructor.
-    *
-    * @param szName The name for the named event
-    *
-   **/
-   eventSemaphore(const char* const szName);
-
-   /**
-    *
-    * Copy constructor - intentionally not implemented
-    *
-   **/
-   eventSemaphore( eventSemaphore const & );
-
-   /**
-    *
-    * Destructor
-    *
-   **/
-   ~eventSemaphore();
-
-   /**
-    *
-    * Assignment - intentionally not implemented
-    *
-   **/
-   eventSemaphore & operator=( eventSemaphore const & );
-
-   /**
-    *
-    * Resets the semaphore, after this the wait() will be blocked.
-    *
-   **/
-   void reset();
-
-   /**
-    *
-    * Posts the semaphore, after this any wait() will return.
-    *
-   **/
-   void post();
-
-   /**
-    *
-    * Waits (infinitely) for the semaphore to be posted.
-    *
-   **/
-   void wait();
-
-   /**
-    *
-    * Waits for the semaphore to be posted or for timeout.
-    *
-    * @param Time The maximum time to wait in milliseconds
-    *
-    * @return   0 if the semaphore is posted, different values, if timeout
-    *
-   **/
-   int  wait( long Time );
-
-   /**
-    *
-    * Checks the semaphore, do not wait.
-    *
-    * @return 0 if the semaphore is posted, 1 if the semaphore is reset.
-    *
-   **/
-   int check();
-
-};
-
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
diff --git a/SelfServiceCommon/Services/cpp/CxComm/dll/inc/fmtQueue.hpp b/SelfServiceCommon/Services/cpp/CxComm/dll/inc/fmtQueue.hpp
deleted file mode 100644
index ebac5a0d..00000000
--- a/SelfServiceCommon/Services/cpp/CxComm/dll/inc/fmtQueue.hpp
+++ /dev/null
@@ -1,617 +0,0 @@
-/**
- **************************************************************************
- *
- * @file fmtQueue.hpp
- *
- * Contains the template class fmtQueue.
- *
- * @author JK
- *
- * Copyright (c) 1997-2001 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef FMTQUEUE_HPP
-#define FMTQUEUE_HPP
-#if defined(SHOW_INCLUDE_FILES)
-#pragma message("including: " __FILE__)
-#endif
-
-
-
-#include "mutex.hpp"
-#include "eventSem.hpp"
-
-
-
-/**
- *
- * Returncodes
- *
- */
-typedef enum
-{
-   //! Successful completion
-   FMTQ_OK,
-
-   //! Hard error
-   FMTQ_ERROR,
-
-   //! Queue full
-   FMTQ_FULL,
-
-   //! Timeout occured
-   FMTQ_TIMEOUT,
-
-   //! Queue empty
-   FMTQ_EMPTY
-
-} fmtQueueRC;
-
-
-
-/**
- *
- * Fixed-size multi-thread queue. Suitable for applications, which need a
- * fast queue to support inter-thread communication.
- * The queue has a length attribute, which describes the current number of
- * queue elements. Another attribute is the size, which describes the
- * maximum number of queue elements. No fancy stuff like e.g. dynamic size
- * adaptation takes place. Basic operations on the queue are a non-blocking
- * write() and a blocking read().
- *
- * @param fmtQueueElement The template argument defines the type of the
- *                        queue elements to be queued.
- *
- * @note Operations on queue elements include standard construction, copy
- *       construction and assignment. The fmtQueueElement should provide
- *       the correct implementation for these.
- *
-**/
-template<class fmtQueueElement>
-class fmtQueue
-{
-   /**
-    *
-    * Pointer to the queue element buffer.
-    *
-    */
-   fmtQueueElement * M_BufPtr;
-
-   /**
-    *
-    * Size of the queue element buffer.
-    *
-    */
-   unsigned long     M_BufSiz;
-
-   /**
-    *
-    * Buffer offset for write operations.
-    *
-    */
-   unsigned long     M_OffWrite;
-
-   /**
-    *
-    * Buffer offset for read operations.
-    *
-    */
-   unsigned long     M_OffRead;
-
-   /**
-    *
-    * Current queue length.
-    *
-    */
-   unsigned long     M_Length;
-
-   /**
-    *
-    * The number of currently reading threads.
-    *
-    */
-   long              M_Reading;
-
-   /**
-    *
-    * Protect queue agains simultaneous access.
-    *
-    */
-   mutexSemaphore    M_Mutex;
-
-   /**
-    *
-    * Signal queue events to a reader.
-    *
-    */
-   eventSemaphore    M_Event;
-
-   /**
-    *
-    * Private method, allocate resources.
-    *
-   **/
-   void qAlloc( unsigned long Size = 0 )
-   {
-      M_Mutex.request();
-      if( Size )
-      {
-         M_BufPtr = new fmtQueueElement[Size];
-      }
-      else
-      {
-         M_BufPtr = 0;
-      }
-      M_BufSiz = Size;
-      M_OffWrite = M_OffRead = 0;
-      M_Length = 0;
-      M_Reading = 0;
-      M_Mutex.release();
-   }
-
-   /**
-    *
-    * Private method, free resources.
-    *
-   **/
-   void qFree()
-   {
-      M_Mutex.request();
-      //
-      // Prevent new calls to write() and read() in the mutex-gap below.
-      //
-      M_Length = M_BufSiz = 0;
-      //
-      // Give pending read() a chance to finish.
-      // Use D_Reading to limit tries, even if reader is already dead.
-      //
-      long D_Reading = M_Reading;
-      while( M_Reading && D_Reading )
-      {
-         --D_Reading;
-         M_Mutex.release();
-         M_Event.post();
-         eventSemaphore().wait( 10 );
-         M_Mutex.request();
-      }
-      //
-      // No more read() pending - it is safe now to return.
-      //
-      if( M_BufPtr ) delete[] M_BufPtr;
-      M_Mutex.release();
-   }
-
-   /**
-    *
-    * Private method, increment a buffer offset
-    *
-   **/
-   void offInc( unsigned long & Off )
-   {
-      if( ( Off + 1 ) < M_BufSiz )
-         ++Off;
-      else
-         Off = 0;
-   }
-
-   /**
-    *
-    * Private method, decrement a buffer offset
-    *
-   **/
-   void offDec( unsigned long & Off )
-   {
-      if( Off )
-         --Off;
-      else
-         Off = M_BufSiz - 1;
-   }
-
-public:
-
-   /**
-    *
-    * Standard constructor. Does provide for a queue size of 0 only.
-    * To use the queue at all, the size method should be called later for
-    * a proper queue size.
-    *
-   **/
-   fmtQueue() :
-      M_Mutex(),
-      M_Event()
-   {
-      qAlloc();
-   }
-
-   /**
-    *
-    * Constructor. Makes a queue with the size given.
-    *
-    * @param Size Initial size of the queue.
-    *
-   **/
-   fmtQueue( unsigned long Size ) :
-      M_Mutex(),
-      M_Event()
-   {
-      qAlloc( Size );
-   }
-
-   /**
-    *
-    * Copy constructor - intentionally not implemented.
-    *
-   **/
-   fmtQueue( const fmtQueue<fmtQueueElement> & );
-
-   /**
-    *
-    * Destructor
-    *
-   **/
-   ~fmtQueue()
-   {
-      qFree();
-   }
-
-   /**
-    *
-    * Assignment operator - intentionally not implemented.
-    *
-   **/
-   fmtQueue<fmtQueueElement> & operator=
-   (
-      const fmtQueue<fmtQueueElement> &
-   );
-
-   /**
-    *
-    * Resets queue. Already queued items will be lost.
-    *
-   **/
-   void clear()
-   {
-      M_Mutex.request();
-      M_OffWrite = M_OffRead = 0;
-      M_Length = 0;
-      M_Mutex.release();
-   }
-
-   /**
-    *
-    * Resizes and resets queue. Already queued items will be lost.
-    *
-    * @param Size New size of the queue.
-    *
-    * @return New size of queue.
-    *
-   **/
-   unsigned long size( unsigned long Size )
-   {
-      qFree();
-      qAlloc( Size );
-      return Size;
-   }
-
-   /**
-    *
-    * Read an item from the queue. The function will suspend the
-    * execution thread, until an item is available.
-    *
-    * @param Destination Refers the destination to place the element read.
-    *
-    * @return FMTQ_OK or FMTQ_ERROR.
-    *
-   **/
-   fmtQueueRC read( fmtQueueElement& Destination )
-   {
-      //
-      // Protect access, check buffer size
-      //
-      M_Mutex.request();
-      if( !M_BufSiz )
-      {
-         //
-         // Error condition
-         //
-         M_Mutex.release();
-         return FMTQ_ERROR;
-      }
-      //
-      // Increment reading threads count
-      //
-      ++M_Reading;
-      while( M_Length == 0 )
-      {
-         //
-         // Queue empty - release access, wait for insert
-         //
-         M_Event.reset();
-         M_Mutex.release();
-         M_Event.wait();
-         //
-         // Some event - procect access and continue.
-         //
-         M_Mutex.request();
-         if( !M_BufSiz )
-         {
-            //
-            // Error condition
-            //
-            --M_Reading;
-            M_Mutex.release();
-            return FMTQ_ERROR;
-         }
-      }
-      //
-      // Read item from queue
-      //
-      Destination = M_BufPtr[M_OffRead];
-      offInc( M_OffRead );
-      //
-      // Counter update
-      //
-      --M_Length;
-      //
-      // Release access, return OK
-      //
-      --M_Reading;
-      M_Mutex.release();
-      return FMTQ_OK;
-   }
-
-   /**
-    *
-    * Read an item from the queue. The function will suspend the
-    * execution thread, until an item is available or until a timeout
-    * has occured.
-    *
-    * @param Destination Refers the destination to place the element read.
-    *
-    * @param Time Time in milliseconds for read
-    *
-    * @return FMTQ_OK, FMTQ_ERROR or FMTQ_TIMEOUT.
-    *
-   **/
-   fmtQueueRC read( fmtQueueElement& Destination, long Time )
-   {
-      //
-      // Protect access, check buffer size
-      //
-      M_Mutex.request();
-      if( !M_BufSiz )
-      {
-         //
-         // Error condition
-         //
-         M_Mutex.release();
-         return FMTQ_ERROR;
-      }
-      //
-      // Increment reading threads count
-      //
-      ++M_Reading;
-      while( M_Length == 0 )
-      {
-         //
-         // Queue empty - release access, wait for insert
-         //
-         M_Event.reset();
-         M_Mutex.release();
-         if( M_Event.wait( Time ) )
-         {
-            //
-            // Event timeout - leave Destination unchanged
-            //
-            --M_Reading;
-            return FMTQ_TIMEOUT;
-         }
-         //
-         // Some event - procect access and continue.
-         //
-         M_Mutex.request();
-         if( !M_BufSiz )
-         {
-            //
-            // Error condition
-            //
-            --M_Reading;
-            M_Mutex.release();
-            return FMTQ_ERROR;
-         }
-      }
-      //
-      // Read item from queue
-      //
-      Destination = M_BufPtr[M_OffRead];
-      offInc( M_OffRead );
-      //
-      // Counter update
-      //
-      --M_Length;
-      //
-      // Release access, return OK
-      //
-      --M_Reading;
-      M_Mutex.release();
-      return FMTQ_OK;
-   }
-
-   /**
-    *
-    * Write an item to the queue. Write will fail, it the queue is already
-    * full.
-    *
-    * @param Source The item to write
-    *
-    * @return FMTQ_OK or FMTQ_FULL.
-    *
-   **/
-   fmtQueueRC write( fmtQueueElement const & Source )
-   {
-      //
-      // Protect access
-      //
-      M_Mutex.request();
-      if( M_Length < M_BufSiz )
-      {
-         //
-         // Queue not yet full - write item to queue
-         //
-         M_BufPtr[M_OffWrite] = Source;
-         offInc( M_OffWrite );
-         //
-         // Counter update
-         //
-         ++M_Length;
-         //
-         // Release access, post sema, return OK
-         //
-         M_Mutex.release();
-         M_Event.post();
-         return FMTQ_OK;
-      }
-      else
-      {
-         //
-         // Queue full - release access, return ERROR
-         M_Mutex.release();
-         return FMTQ_FULL;
-      }
-   }
-
-   /**
-    *
-    * Write an item to the front of the queue. The next read operation
-    * will return this item. The write will fail, if the queue is already
-    * full.
-    *
-    * @param Source The item to write
-    *
-    * @return FMTQ_OK or FMTQ_FULL.
-    *
-   **/
-   fmtQueueRC writeFront( fmtQueueElement const & Source )
-   {
-      //
-      // Protect access
-      //
-      M_Mutex.request();
-      if( M_Length < M_BufSiz )
-      {
-         //
-         // Queue not yet full - write item to queue
-         //
-         offDec( M_OffRead );
-         M_BufPtr[M_OffRead] = Source;
-         //
-         // Counter update
-         //
-         ++M_Length;
-         //
-         // Release access, post sema, return OK
-         //
-         M_Mutex.release();
-         M_Event.post();
-         return FMTQ_OK;
-      }
-      else
-      {
-         //
-         // Queue full - release access, return ERROR
-         M_Mutex.release();
-         return FMTQ_FULL;
-      }
-   }
-
-   /**
-    *
-    * Query queue length. This is advised prior to blocking read(),
-    * if you do not want to be blocked.
-    *
-    * @return Length of the queue.
-    *
-   **/
-   unsigned long length() const
-   {
-      return M_Length;
-   }
-
-   /**
-    *
-    * Peek into the queue. The function will return immediately.
-    * peek( 0 ) will yield the next item to be read, peek( 1 ) the 2nd but
-    * next, etc. The queue contents will not be modified. The returncode
-    * will indicate, if the index-d place is not used (FMTQ_EMPTY) or
-    * beyond the size of queue (FMTQ_ERROR). A queue of size 0 will always
-    * return FMTQ_ERROR.
-    *
-    * @note With several threads reading it might be advisable to use the
-    *       lock() / unlock() methods around peek().
-    *
-    * @param pDestination A pointer, which after successful return will
-    *        address the target element.
-    *
-    * @return FMTQ_OK, FMTQ_EMPTY or FMTQ_ERROR.
-    *
-   **/
-   fmtQueueRC peek
-   (
-      fmtQueueElement * & pDestination,
-      unsigned long       Index = 0
-   ) const
-   {
-      if( Index >= M_Length  )
-      {
-         if( Index >= M_BufSiz )
-            return FMTQ_ERROR;
-         else
-            return FMTQ_EMPTY;
-      }
-      else
-      {
-         unsigned long Offset = M_OffRead + Index;
-         if( Offset >= M_BufSiz )
-            Offset -= M_BufSiz;
-         pDestination = &M_BufPtr[Offset];
-         return FMTQ_OK;
-      }
-   }
-
-   /**
-    *
-    * Lock the queue against modifications. The execution of size(), read()
-    * and write() methods is blocked.
-    *
-   **/
-   void lock()
-   {
-      M_Mutex.request();
-   }
-
-   /**
-    *
-    * Undo a previous lock().
-    *
-    * @note Do not use unlock() without a previous lock()!
-    *
-   **/
-   void unlock()
-   {
-      M_Mutex.release();
-   }
-
-
-};
-
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
-
diff --git a/SelfServiceCommon/Services/cpp/CxComm/dll/inc/hashMap.hpp b/SelfServiceCommon/Services/cpp/CxComm/dll/inc/hashMap.hpp
deleted file mode 100644
index b62d0e0d..00000000
--- a/SelfServiceCommon/Services/cpp/CxComm/dll/inc/hashMap.hpp
+++ /dev/null
@@ -1,243 +0,0 @@
-/**
- **************************************************************************
- *
- * @file hashMap.hpp
- *
- * Contains template class hashMap.
- *
- * @author JK
- *
- * Copyright (c) 2000-2001 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef HASHMAP_HPP
-#define HASHMAP_HPP
-#if defined(SHOW_INCLUDE_FILES)
-#pragma message("including: " __FILE__)
-#endif
-
-#include "mutex.hpp"
-
-
-/**
- **************************************************************************
- *
- * Implements thread-safe hashing. Template arguments:
- *
- * - V Value type
- *
- * - K Key type
- *
- **************************************************************************
-**/
-template <class V, class K>
-class hashMap
-{
-
-   //! The vector of hash values
-   V *            M_Values;
-
-   //! The vector of hash keys
-   K *            M_Keys;
-
-   //! The size of the vectors
-   unsigned       M_HashSize;
-
-   //! The current number of entries
-   unsigned       M_HashEntries;
-
-   //! The value retruned for not found
-   V              M_NoValue;
-
-   //! Represents the no-entry entry
-   K              M_NoKey;
-
-   //! Access protection
-   mutexSemaphore M_Mutex;
-
-   /**
-    *
-    * Find the vector index for a key given.
-    *
-    * @param 1. The key.
-    *
-    * @param 2. Refers the varible to place the index found.
-    *
-    * @return 1 if success, 0 if not
-    *
-   **/
-   int indexForKey( K Key, unsigned & Ind ) const
-   {
-      // Apply the hash function:
-      // - Assume the key can be converted to an unsigned
-      // - Calc modulo hashsize
-      unsigned UKey = (unsigned)Key;
-      Ind = UKey % M_HashSize;
-      // Scan to the actual key
-      while( M_Keys[Ind] != M_NoKey )
-      {
-         if( M_Keys[Ind] == Key )
-         {
-            // That is our index
-            return 1;
-         }
-         Ind = ( Ind + 1 ) % M_HashSize;
-      }
-      // Not found
-      return 0;
-   }
-
-public:
-
-   /**
-    *
-    * Standard constructor - intentionally not implemented.
-    *
-   **/
-   hashMap();
-
-   /**
-    *
-    * Constructor
-    *
-    * @param 1. The hash size
-    *
-    * @param 2. This is value is to be returned when no value is found.
-    *
-    * @param 3. This key does not occur.
-    *
-   **/
-   hashMap( unsigned HashSize, V NoValue, K NoKey )
-      : M_Values( new V[ HashSize ] ),
-        M_Keys( new K[ HashSize ] ),
-        M_HashSize( HashSize ),
-        M_HashEntries( 0 ),
-        M_NoValue( NoValue ),
-        M_NoKey( NoKey ),
-        M_Mutex()
-   {
-      for( unsigned i=0; i<HashSize; ++i ) M_Keys[i] = M_NoKey;
-   }
-
-   /**
-    *
-    * Copy constructor - intentionally not implemented.
-    *
-   **/
-   hashMap( hashMap<V,K> const & );
-
-   /**
-    *
-    * Destructor
-    *
-   **/
-   ~hashMap()
-   {
-      delete[] M_Keys;
-      delete[] M_Values;
-   }
-
-   /**
-    *
-    * Assignment operator - intentionally not implemented.
-    *
-   **/
-   hashMap<V,K> const & operator=( hashMap<V,K> const & );
-
-   /**
-    *
-    * Clear a key from the map.
-    *
-    * @param 1. The key to be cleared.
-    *
-   **/
-   void clr( const K & Key )
-   {
-      M_Mutex.request();
-      unsigned Ind;
-      if( indexForKey( Key, Ind ) )
-      {
-         //
-         // Release slot
-         //
-         M_Keys[Ind] = M_NoKey;
-         --M_HashEntries;
-      }
-      M_Mutex.release();
-   }
-
-   /**
-    *
-    * Retrieve a value for a key.
-    *
-    * @param 1. The input key.
-    *
-    * @return The value.
-    *
-   **/
-   V const & get( K const & Key )
-   {
-      M_Mutex.request();
-      unsigned Ind;
-      V const * pR;
-      if( indexForKey( Key, Ind ) )
-      {
-         pR = &M_Values[Ind];
-      }
-      else
-      {
-         pR = &M_NoValue;
-      }
-      M_Mutex.release();
-      return *pR;
-   }
-
-   /**
-    *
-    * Set the value for a key.
-    *
-    * @param 1. The key to set.
-    *
-    * @param 2. The value for the key.
-    *
-    * @return The value, if sucessful.
-   **/
-   V const & set( K const & Key, V const & Value )
-   {
-      M_Mutex.request();
-      if( M_HashEntries < M_HashSize )
-      {
-         unsigned Ind;
-         if( !indexForKey( Key, Ind ) )
-         {
-            //
-            // Empty slot
-            //
-            M_Keys[Ind] = Key;
-            ++M_HashEntries;
-         }
-         M_Values[Ind] = Value;
-         M_Mutex.release();
-         return M_Values[Ind];
-      }
-      else
-      {
-         //
-         // All slots in use
-         //
-         M_Mutex.release();
-         return M_NoValue;
-      }
-   }
-
-};
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
diff --git a/SelfServiceCommon/Services/cpp/CxComm/dll/inc/matThread.hpp b/SelfServiceCommon/Services/cpp/CxComm/dll/inc/matThread.hpp
deleted file mode 100644
index 98821900..00000000
--- a/SelfServiceCommon/Services/cpp/CxComm/dll/inc/matThread.hpp
+++ /dev/null
@@ -1,312 +0,0 @@
-/**
- **************************************************************************
- *
- * @file matThread.hpp
- *
- * Contains interface definitions for OS-Independent thread functions.
- *
- * @author JK
- *
- * Copyright (c) 2000 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef MATTHREAD_HPP
-#define MATTHREAD_HPP
-#if defined(SHOW_INCLUDE_FILES)
-#pragma message("including: " __FILE__)
-#endif
-
-
-
-/**
- *
- * Returncodes
- *
-**/
-typedef enum
-{
-   //! Successful completion
-   THREADRC_OK,
-
-   //! Hard error
-   THREADRC_ERROR,
-
-   //! Timeout occured
-   THREADRC_TIMEOUT
-
-} matThreadRC;
-
-
-
-/**
- *
- * Thread priorities
- *
-**/
-typedef enum
-{
-   //! Above normal
-   THREADPRTY_HIGH = 2,
-
-   //! Normal
-   THREADPRTY_NORMAL,
-
-   //! Below normal
-   THREADPRTY_LOW
-
-} matThreadPrty;
-
-
-
-/**
- *
- * For debugging purposes a trace function can be given during object
- * construction (trace constructor). This function then is called upon
- * certain events.
- *
- * @param Level A value between 1 and 9 to give a hint about the
- *              problem severity. 1 means normal operation, 9 means
- *              fatal error. An implementation might want to ignore
- *              all events below a certain threshold.
- *
- * @param Text  A zero-terminated string describing the event.
- *
-**/
-
-typedef void (* matThreadTrace)
-                (
-                   long         Level,
-                   char const * Text
-                );
-
-
-
-/**
- **************************************************************************
- *
- * The matThread class can be used to control thread execution.
- * It can as well serve as a shared memory for inter-thread communication.
- * To use matThread, an application must derive from matThread with
- * a class of its own and then implement the virtual function() method.
- * A real execution is started, when the application calls the start()
- * method. Then the function() is called in the new separate thread.
- * The thread execution is terminated, when the function() returns.
- *
- * @note The application can as well force the thread execution to
- * @note terminate by calling the stop() method or simply by destroying the
- * @note matThread-derived object. Doing so however always induces the risk
- * @note of resource (memory) leaks.
- *
- **************************************************************************
-**/
-class matThread
-{
-
-   /**
-    *
-    * The implementation might want to make use of additional class data.
-    * Thus it defines a private handle class.
-    *
-   **/
-   friend class matThread_Handle;
-
-   /**
-    *
-    * The M_Handle refers to private elements of the matThread implementation.
-    *
-   **/
-   matThread_Handle * M_Handle;
-
-   /**
-    *
-    * Must be overloaded with the clients thread function.
-    *
-   **/
-   virtual void function() = 0;
-
-public:
-
-   /**
-    *
-    * Standard constructor
-    *
-    *  @param Stack The minimum size (in bytes) for the thread stack.
-   **/
-   matThread( long Stack = 0 );
-
-   /**
-    *
-    * Trace constructor
-    *
-    * @param Trace The function to be called for trace events.
-    *
-    * @param Stack The minimum size (in bytes) for the thread stack.
-    *
-   **/
-   matThread( matThreadTrace Trace, long Stack = 0 );
-
-   /**
-    *
-    * Copy constructor - intentionally not implemented.
-    *
-   **/
-   matThread( matThread const & );
-
-   /**
-    *
-    * Destructor.
-    *
-    * Terminates the thread execution, if running. Frees all allocated
-    * resources.
-    *
-   **/
-   virtual ~matThread();
-
-   /**
-    *
-    * Assignment operator - intentionally not implemented.
-    *
-   **/
-   matThread & operator=( matThread const & );
-
-   /**
-    *
-    * Public method.
-    *
-    * Starts a new thread, should be called only once or after stop().
-    *
-    * @param Prty The initial priority for the new thread.
-    *
-    * @return THREADRC_OK or TRHEADRC_ERROR.
-    *
-   **/
-   matThreadRC start( matThreadPrty Prty = THREADPRTY_NORMAL );
-
-   /**
-    *
-    * Public method
-    *
-    * Stops an existing thread, should be called only after start().
-    *
-    * @return THREADRC_OK or TRHEADRC_ERROR.
-    *
-   **/
-   matThreadRC stop();
-
-   /**
-    *
-    * Public method
-    *
-    * Wait for a thread to terminate.
-    *
-    * @return THREADRC_OK if thread has terminated,
-    *         TRHEADRC_ERROR if thread not yet started.
-    *
-   **/
-   matThreadRC waitTerminated();
-
-   /**
-    *
-    * Public method
-    *
-    * Wait a specified time for a thread to terminate.
-    *
-    * @param Time The maximum time to wait in milliseconds.
-    *
-    * @return THREADRC_OK if thread has terminated,
-    *         THREADRC_TIMEOUT if thread still running,
-    *         TRHEADRC_ERROR if thread not yet started.
-    *
-   **/
-   matThreadRC waitTerminated( long Time );
-
-};
-
-
-
-/**
- *
- * Thread function.
- *
- * @param  ThreadFParameter.
- *
-**/
-typedef void ( *matThreadF )( void * ThreadFParameter );
-
-/**
- *
- * Public function
- *
- * Start a thread with the function given.
- *
- * @param ThreadF The function to be called with the new thread.
- *
- * @param ThreadFParameter The function parameter.
- *
- * @param Stack The stacksize to be reserved (option).
- *
- * @param Trace The function to be called for trace events.
- *
- * @return THREADRC_OK or THREADRC_ERROR.
- *
-**/
-matThreadRC matThreadFStart
-     (
-        matThreadF     ThreadF,
-        void *         ThreadFParameter,
-        long           Stack = 0,
-        matThreadTrace Trace = 0
-     );
-
-
-
-/**
- *
- * Public function
- *
- * Returns the current threads id
- *
- * @return         The thread id
- *
-**/
-long matThreadId();
-
-
-
-/**
- *
- * Public function
- *
- * Change the current threads priority
- *
- * @param  Prty    The desired priority.
- *
- * @return THREADRC_OK or THREADRC_ERROR.
- *
-**/
-matThreadRC matThreadSetPrty( matThreadPrty Prty );
-
-
-
-/**
- *
- * Public function
- *
- * Suspends execution of the current thread for the time given.
- *
- * @param  Time    The time in milliseconds
- *
-**/
-void matThreadSleep( long Time );
-
-
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
diff --git a/SelfServiceCommon/Services/cpp/CxComm/dll/makefile.mak b/SelfServiceCommon/Services/cpp/CxComm/dll/makefile.mak
index 2ecb40ad..0b93bc2c 100644
--- a/SelfServiceCommon/Services/cpp/CxComm/dll/makefile.mak
+++ b/SelfServiceCommon/Services/cpp/CxComm/dll/makefile.mak
@@ -7,7 +7,8 @@
 !include $(BUILDROOT)\Build\cpp\makefile.common.mak
 
 MY_CFLAGS = \
-    -GR
+    -GR \
+    $(INC_INTERFACES)
 
 MY_LDFLAGS = \
     -LINK50COMPAT \
@@ -35,12 +36,14 @@ MY_DLL1_OBJS = \
     $(_OBJ)\cxAPIver.obj \
     $(_OBJ)\cxShHdl.obj \
     $(_OBJ)\matProcW32.obj \
-    $(_OBJ)\matThreadW32.obj \
     $(_OBJ)\NT_EvSem.obj \
     $(_OBJ)\NT_MxSem.obj \
     $(_OBJ)\osTime.obj \
     $(_OBJ)\tcpComm.obj
 
+MY_DLL1_USER_LIBS = \
+    $(LIB_SYSTOOLS)
+
 MY_DLL1_LINKLIBS = \
     $(SYS_ADVAPI32) \
     $(SYS_USER32) \
diff --git a/SelfServiceCommon/Services/cpp/CxComm/dll/src/matThreadW32.cpp b/SelfServiceCommon/Services/cpp/CxComm/dll/src/matThreadW32.cpp
deleted file mode 100644
index cd55c7b5..00000000
--- a/SelfServiceCommon/Services/cpp/CxComm/dll/src/matThreadW32.cpp
+++ /dev/null
@@ -1,580 +0,0 @@
-/**
- **************************************************************************
- *
- * @file matThreadW32.cpp
- *
- * Implements the functions defined in matThread.hpp for Win32
- * environment.
- *
- * @author JK
- *
- * Copyright (c) 2000 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-
-#include "matThread.hpp"
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <process.h>
-
-#include <windows.h>
-#include <winbase.h>
-
-
-
-#define TRACE_LEVEL_ERROR  1       // Major error
-#define TRACE_LEVEL_NORMAL 7       // Secondary runtime
-
-#define NT_MIN_STACK 65536
-
-
-
-static char * makeChild( char * Buf, char const * Src )
-{
-   sprintf( Buf, "child[%d]: %s", matThreadId(), Src );
-   return Buf;
-}
-
-
-
-static char * makeParent( char * Buf, char const * Src )
-{
-   sprintf( Buf, "parent[%d]: %s", matThreadId(), Src );
-   return Buf;
-}
-
-
-
-static matThreadRC win2rc( DWORD WErr )
-{
-   switch( WErr )
-   {
-   case ERROR_SUCCESS: return THREADRC_OK;
-   case WAIT_TIMEOUT:  return THREADRC_TIMEOUT;
-   default:            return THREADRC_ERROR;
-   }
-}
-
-
-
-/**
- **************************************************************************
- *
- * Handle class
- *
- **************************************************************************
-**/
-class matThread_Handle
-{
-
-   //! CLient trace function
-   matThreadTrace MH_Trace;
-
-   //! Refers the parent thread class
-   matThread *    MH_pPublic;
-
-public:
-
-   //! Win32 thread handle
-   HANDLE         MH_Handle;
-
-   //! Stack allocated for thread
-   long           MH_Stacksize;
-
-   //! Thread status
-   int            MH_Terminated;
-
-   //! Semaphore to control the start sequence
-   HANDLE         MH_StartSema;
-
-   /**
-    *
-    * Trace normal events
-    *
-   **/
-   void        traceNormal( char const * Text )
-               {
-                  if( MH_Trace )
-                  {
-                     char Buffer[256];
-                     MH_Trace( TRACE_LEVEL_NORMAL, makeParent( Buffer, Text ) );
-                  }
-               }
-
-   /**
-    *
-    * Trace error events
-    *
-   **/
-   void        traceError( char const * Text )
-               {
-                  if( MH_Trace )
-                  {
-                     char Buffer[256];
-                     MH_Trace( TRACE_LEVEL_ERROR, makeParent( Buffer, Text ) );
-                  }
-               }
-
-   /**
-    *
-    * Trace Win32 errors
-    *
-   **/
-   matThreadRC traceLastError( char const * Text )
-               {
-                  DWORD LE = GetLastError();
-                  if( MH_Trace )
-                  {
-                     char Buffer[256];
-                     char TBuffer[256];
-                     sprintf( TBuffer, "%s error %d", Text, LE );
-                     MH_Trace( TRACE_LEVEL_ERROR, makeParent( Buffer, TBuffer ) );
-                  }
-                  return win2rc( LE );
-               }
-
-   /**
-    *
-    * Thread function
-    *
-   **/
-   void        function()
-               {
-                  if( MH_Trace )
-                  {
-                     char Buffer[256];
-                     MH_Trace( TRACE_LEVEL_NORMAL, makeChild( Buffer, "call" ) );
-                               MH_pPublic->function();
-                     MH_Trace( TRACE_LEVEL_NORMAL, makeChild( Buffer, "return" ) );
-                  }
-                  else
-                     MH_pPublic->function();
-               }
-
-   /**
-    *
-    * Constructor
-    *
-    * @param IFObject Refers the parent thread class
-    *
-    * @param Stack    The thread stack
-    *
-    * @param Trace    The trace function to use (may be 0)
-    *
-   **/
-   matThread_Handle
-   (
-      matThread *              IFObject,
-      long                     Stack,
-      matThreadTrace           Trace
-    ) :
-      MH_Trace( Trace ),
-      MH_pPublic( IFObject ),
-      MH_Handle( 0 ),
-      MH_Stacksize( ( Stack > NT_MIN_STACK ) ? Stack : NT_MIN_STACK ),
-      MH_Terminated( 1 ),
-      MH_StartSema( CreateEvent( 0, TRUE, FALSE, 0 ) )
-   {
-      if( Trace )
-      {
-         char Buffer[256];
-         Trace( TRACE_LEVEL_NORMAL, makeParent( Buffer, "created" ) );
-      }
-   }
-
-   /**
-    *
-    * Standard constructor - intentionally not implemented.
-    *
-   **/
-   matThread_Handle();
-
-   /**
-    *
-    * Destructor
-    *
-   **/
-   ~matThread_Handle()
-   {
-      if( MH_Trace )
-      {
-         char Buffer[256];
-         MH_Trace( TRACE_LEVEL_NORMAL, makeParent( Buffer, "deleted" ) );
-      }
-   }
-
-};
-
-
-
-/**
- **************************************************************************
- *
- * Controls child thread execution.
- *
- * @param pV "void" pointer to handle class
- *
- **************************************************************************
-**/
-#ifdef __IBMCPP__
-static void _Optlink privateEnterThreadC( void * pV )
-#else
-static void __cdecl privateEnterThreadC( void * pV )
-#endif
-{
-   matThread_Handle *pPara = (matThread_Handle *)pV;
-   SetEvent( pPara->MH_StartSema );
-   pPara->MH_Terminated = 0;
-   pPara->function();
-   pPara->MH_Terminated = 1;
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThread::matThread( long stacksize ) :
-   M_Handle( 0 )
-{
-   M_Handle = new matThread_Handle( this, stacksize, 0 );
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThread::matThread( matThreadTrace Trace, long stacksize ) :
-   M_Handle( 0 )
-{
-   M_Handle = new matThread_Handle( this, stacksize, Trace );
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThread::~matThread()
-{
-   M_Handle->traceNormal( "~matThread ..." );
-   if( M_Handle->MH_Handle )
-   {
-      if( !M_Handle->MH_Terminated )
-      {
-        M_Handle->traceNormal( "~matThread - terminate" );
-        TerminateThread( M_Handle->MH_Handle, 13 );
-      }
-      CloseHandle( M_Handle->MH_Handle );
-   }
-
-   //@@MaK CloseHandle( M_Handle->MH_StartSema );
-   M_Handle->traceNormal( "~matThread." );
-   delete M_Handle;
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThreadRC matThread::start( matThreadPrty Prty )
-{
-   if( M_Handle->MH_Handle )
-   {
-      if( !M_Handle->MH_Terminated )
-      {
-         //
-         // Thread currently running - do not start twice
-         //
-         M_Handle->traceError( "start - ignored" );
-         return THREADRC_ERROR;
-      }
-      CloseHandle( M_Handle->MH_Handle );
-      M_Handle->MH_Handle = 0;
-   }
-
-#ifdef __IBMCPP__
-   HANDLE NewHandle = (HANDLE)_beginthread
-                      (
-                         privateEnterThreadC,
-                         NULL,
-                         M_Handle->MH_Stacksize,
-                         M_Handle
-                      );
-#else
-   HANDLE NewHandle = (HANDLE)_beginthread
-                      (
-                         privateEnterThreadC,
-                         M_Handle->MH_Stacksize,
-                         M_Handle
-                      );
-#endif
-   if( NewHandle == 0 )
-   {
-      return M_Handle->traceLastError( "start - CreateThread" );
-   }
-#if 0 //@@MaK
-   if
-   (
-      !DuplicateHandle
-      (
-         GetCurrentProcess(), NewHandle,
-         GetCurrentProcess(), &M_Handle->MH_Handle,
-         0, FALSE, DUPLICATE_SAME_ACCESS
-      )
-   )
-   {
-      return M_Handle->traceLastError( "start - DuplicateHandle" );
-   }
-#else
-   M_Handle->MH_Handle = NewHandle;
-#endif
-
-   M_Handle->traceNormal( "start - waiting" );
-   WaitForSingleObject( M_Handle->MH_StartSema, INFINITE );
-
-   //@@MaK
-   CloseHandle( M_Handle->MH_StartSema );
-
-   Sleep( 1 );
-   M_Handle->traceNormal( "start" );
-   switch( Prty )
-   {
-   default:
-      return THREADRC_OK;
-   case THREADPRTY_HIGH:
-      if
-      (
-         SetThreadPriority
-         (
-            M_Handle->MH_Handle,
-            THREAD_PRIORITY_ABOVE_NORMAL
-         )
-      ) return THREADRC_OK;
-      else return M_Handle->traceLastError( "start - SetThreadPriority" );
-   case THREADPRTY_LOW:
-      if
-      (
-         SetThreadPriority
-         (
-            M_Handle->MH_Handle,
-            THREAD_PRIORITY_BELOW_NORMAL
-         )
-      ) return THREADRC_OK;
-      else return M_Handle->traceLastError( "start - SetThreadPriority" );
-   }
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThreadRC matThread::stop()
-{
-   if( M_Handle->MH_Handle == 0 )
-   {
-      //
-      // Thread currently not running - cannot stop it
-      //
-      M_Handle->traceError( "stop - error" );
-      return THREADRC_ERROR;
-   }
-   M_Handle->traceNormal( "stop" );
-   TerminateThread( M_Handle->MH_Handle, 12 );
-   CloseHandle( M_Handle->MH_Handle );
-   M_Handle->MH_Handle = 0;
-   M_Handle->MH_Terminated = 1;
-   return THREADRC_OK;
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThreadRC matThread::waitTerminated()
-{
-   return waitTerminated( INFINITE );
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThreadRC matThread::waitTerminated( long Time )
-{
-   M_Handle->traceNormal( "waitTerminated ..." );
-   int RC = WaitForSingleObject( M_Handle->MH_Handle, Time );
-   switch( RC )
-   {
-   default:
-      M_Handle->traceNormal( "waitTerminated - error." );
-      return THREADRC_ERROR;
-   case WAIT_TIMEOUT:
-      M_Handle->traceNormal( "waitTerminated - timeout." );
-      return THREADRC_TIMEOUT;
-   case ERROR_SUCCESS:
-      M_Handle->traceNormal( "waitTerminated." );
-      return THREADRC_OK;
-   }
-}
-
-
-
-/**
- *
- * Handle parameters to the thread function
- *
-**/
-struct privatePara
-{
-
-   //! Client function pointer
-   matThreadF     pFunc;
-
-   //! Client function parameters
-   void *         FuncPara;
-
-   //! Client trace function
-   matThreadTrace Trace;
-
-};
-
-
-
-/**
- **************************************************************************
- *
- * Thread function
- *
- * @param pV "void" pointer to handle structure
- *
- **************************************************************************
-**/
-#ifdef __IBMCPP__
-static void _Optlink privateEnterThreadF( void * pV )
-#else
-static void __cdecl privateEnterThreadF( void * pV )
-#endif
-{
-   privatePara * pP = (privatePara *)pV;
-   if( pP->Trace )
-   {
-      char Buf[64];
-      sprintf( Buf, "[%d] ...", GetCurrentThreadId() );
-      pP->Trace( TRACE_LEVEL_NORMAL, Buf );
-   }
-   pP->pFunc( pP->FuncPara );
-   if( pP->Trace )
-   {
-      char Buf[64];
-      sprintf( Buf, "[%d].", GetCurrentThreadId() );
-      pP->Trace( TRACE_LEVEL_NORMAL, Buf );
-   }
-   delete pV;
-}
-
-
-
-/**
- *
- * Interface function implementation
- *
-**/
-matThreadRC matThreadFStart
-(
-   matThreadF     ThreadF,
-   void *         ThreadFParameter,
-   long           Stack,
-   matThreadTrace Trace
-)
-{
-   HANDLE H;
-   privatePara * pP = new privatePara;
-   pP->pFunc = ThreadF;
-   pP->FuncPara = ThreadFParameter;
-   pP->Trace = Trace;
-#ifdef __IBMCPP__
-   H = (HANDLE)_beginthread
-       (
-          privateEnterThreadF,
-          NULL,
-          (Stack > NT_MIN_STACK) ? Stack : NT_MIN_STACK,
-          pP
-       );
-#else
-   H = (HANDLE)_beginthread
-       (
-          privateEnterThreadF,
-          (Stack > NT_MIN_STACK) ? Stack : NT_MIN_STACK,
-          pP
-       );
-#endif
-   if( H == (HANDLE)-1 )
-   {
-      if( Trace ) Trace( TRACE_LEVEL_ERROR, "matThreadFStart failed" );
-      return win2rc( GetLastError() );
-   }
-   else
-   {
-      if( Trace )
-      {
-         char Buf[64];
-         sprintf( Buf, "matThreadFStart" );
-         Trace( TRACE_LEVEL_NORMAL, Buf );
-      }
-      return THREADRC_OK;
-   }
-}
-
-
-
-/**
- *
- * Interface function implementation
- *
-**/
-long matThreadId()
-{
-   return GetCurrentThreadId();
-}
-
-
-
-/**
- *
- * Interface function implementation
- *
-**/
-void matThreadSleep( long milliSeconds )
-{
-   Sleep( milliSeconds );
-}
-
-
-
-//-------------------------------------------------------------------------
-//
-// End of file
-//
-//-------------------------------------------------------------------------
diff --git a/SelfServiceCommon/Services/cpp/TrcServ/inc/argScan.hpp b/SelfServiceCommon/Services/cpp/TrcServ/inc/argScan.hpp
deleted file mode 100644
index cac922a3..00000000
--- a/SelfServiceCommon/Services/cpp/TrcServ/inc/argScan.hpp
+++ /dev/null
@@ -1,330 +0,0 @@
-/**
- **************************************************************************
- *
- * @file argScan.hpp
- *
- * Contains inline class argScan
- *
- * @note please include either <fstream> or <ftream.h> as well.
- *
- * @author JK
- *
- * Copyright (c) 1998-2000 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef ARGSCAN_HPP
-#define ARGSCAN_HPP
-#if defined(SHOW_INCLUDE_FILES)
-#pragma message("including: " __FILE__)
-#endif
-
-#include <stdlib.h>
-
-/**
- *
- * Commandline argument scanner class.
- *
-**/
-class argScan
-{
-
-   //! Copy of main-argc
-   int          M_ArgC;
-
-   //! Copy of main-argv
-   char **      M_ArgV;
-
-   //! Name of file with additional parameters (0, if none)
-   char const * M_Filename;
-
-public:
-
-   /**
-    *
-    * Constructor
-    *
-    * @param argc Please provide argc from main().
-    *
-    * @param argv Please provide argv from main().
-    *
-   **/
-   argScan( int argc, char ** argv )
-      : M_ArgC( argc ), M_ArgV( argv ), M_Filename( 0 )
-   {
-   }
-
-   /**
-    *
-    * Standard constructor - intentionally not implemented.
-    *
-   **/
-   argScan();
-
-   /**
-    *
-    * Copy constructor - intentionally not implemented.
-    *
-   **/
-   argScan( argScan const & );
-
-   /**
-    *
-    * Assignment operator - intentionally not implemented.
-    *
-   **/
-   argScan & operator=( argScan const & );
-
-   /**
-    *
-    * Give the name of a file with additional parameters.
-    * The file is supposed to contain one parameter per line.
-    *
-    * @param File path and name
-    *
-   **/
-   void file( char const * pszM_Filename )
-   {
-      M_Filename = pszM_Filename;
-   }
-
-   /**
-    *
-    * Retrieve a string argument by argument index. Every parameter, which
-    * is not an option (see option() method), is an argument. The command
-    * itself is retrieved with the index 0. The first non-option argument
-    * would be returned with the index 1. If the index exceeds the number
-    * of arguments, the 0 pointer is returned.
-    * If a parameter file (see file() method) is given, every non-empty
-    * line of the parameter file is returned as an argument. Index counting
-    * for a parameter file starts after the last index for commandline
-    * arguments.
-    *
-    * @param Index Argument index.
-    *
-    * @return Argument string.
-    *
-   **/
-   char const * argument( int Index ) const
-   {
-      int M_ArgCount = 0;           // Counts the non-special arguments
-      int AllCount = 0;             // Counts all commandline arguments
-      //
-      // Check the commandline parameters
-      //
-      while( AllCount < M_ArgC )
-      {
-         char *pArg = M_ArgV[AllCount];
-         if( (*pArg == '-') || (*pArg == '/') )
-         {
-            //
-            // Skip special arguments
-            //
-            ++AllCount;
-         }
-         else
-         {
-            //
-            // These we are interested in
-            //
-            if( M_ArgCount == Index )
-            {
-               //
-               // This has the index wanted
-               //
-               return pArg;
-            }
-            ++M_ArgCount;
-            ++AllCount;
-         }
-      }
-      //
-      // Check for an input file
-      //
-      if( M_Filename )
-      {
-         ifstream I( M_Filename );
-         static char Buffer[256];
-         for(;;)
-         {
-            // read a line
-            I.getline( Buffer, sizeof(Buffer) - 1 );
-            if( I )
-            {
-               if( Buffer[0] )
-               {
-                  // We have got a non-empty line (empty lines ignored)
-                  if( M_ArgCount == Index )
-                  {
-                     // Line index matches
-                     Buffer[sizeof(Buffer) - 1] = 0;
-                     return Buffer;
-                  }
-                  ++M_ArgCount;
-               }
-            }
-            else
-               // At end-of-file -> no success
-               return 0;
-         }
-      }
-      return 0;
-   }
-
-   /**
-    *
-    * Retrieve an integer argument by argument index. For indexes and
-    * parameterfiles see argument() method.
-    * If the index exceeds the number of arguments, the default value
-    * is returned.
-    *
-    * @param Index Argument index.
-    *
-    * @param Default The value to be returned in case of failure.
-    *
-    * @return Argument value.
-    *
-   **/
-   int argumentInteger( int Index, int Default = 0 ) const
-   {
-      char const * String = argument( Index );
-      if( String )
-         Default = atoi( String );
-      return Default;
-   }
-
-   /**
-    *
-    * Retrieve a string option by option key. An option is supposed to look
-    * like "-<key>[:<value>]" or "/<key>[:<value>]" i.e. the "/", "-" and
-    * ":" characters are treated specially.
-    * The key string should be given in upper-case only, commandline
-    * parameter evaluation then is not case-sensitive.
-    * If an option key not found, the 0 pointer is returned.
-    *
-    * @param Key Option key (without leading "-" or "/").
-    *
-    * @return Option string (all after the ":") or
-    *         0, if option not found or
-    *         the "" string (length 0), if no option value is specified.
-    *
-   **/
-   char const *option( char const * Key ) const
-   {
-      int cnt = 1;
-      while( cnt < M_ArgC )
-      {
-         char const *pArg = M_ArgV[cnt];
-         if( (*pArg == '-') || (*pArg == '/') )
-         {
-            ++pArg;
-            char const *pP = Key;
-            int Equal = 1;
-            while( *pP && Equal )
-            {
-               char X = *pArg;
-               if( ( X >= 'a' ) && ( X <= 'z' ) ) X &= ~0x20;
-               if( X != *pP )
-                  Equal = 0;
-               ++pP;
-               ++pArg;
-            }
-            if( Equal )
-            {
-               while( *pArg && ( *pArg != ':' ) ) ++pArg;
-               if( *pArg ) ++pArg;
-               return pArg;
-            }
-         }
-         ++cnt;
-      }
-      return 0;
-   }
-
-   /**
-    *
-    * Retrieve an integer option by option key.
-    * Works like the option() method and argumentInteger() method combined.
-    *
-    * @param Key Option key (without leading "-" or "/").
-    *
-    * @param Default The value to be returned in case of failure.
-    *
-    * @return Option value.
-    *
-   **/
-   int optionInteger( char const * Key, int Default = 0 ) const
-   {
-      char const * String = option( Key);
-      if( String )
-         Default = atoi( String );
-      return Default;
-   }
-
-   /**
-    *
-    * Retrieve a hexadecimal integer option by option key.
-    * Works like optionInteger(), but expects the parameter in hexadecimal
-    * notation (e.g. "affe" or "0E")
-    *
-    * @param Key Option key (without leading "-" or "/").
-    *
-    * @param Default The value to be returned in case of failure.
-    *
-    * @return Option value.
-    *
-   **/
-   int optionInteger16( char const * Key, int Default = 0 ) const
-   {
-      char const * String = option( Key );
-      if( String )
-      {
-         Default = 0;
-         while( *String )
-         {
-            int C = (int)*String++;
-            if( C >= 'A' )
-               C = (C & 0x0F) + 9;
-            else
-               C = C & 0x0F;
-            Default = Default * 0x10 + C;
-         }
-      }
-      return Default;
-   }
-
-   /**
-    *
-    * Checks the existence of commandline parameters.
-    *
-    * @return 1 if commandline contains no parameters, 0 else.
-    *
-   **/
-   int none() const
-   {
-      return M_ArgC == 1;
-   }
-
-   /**
-    *
-    * Checks the existence of commandline help patterns.
-    *
-    * @return 1, if help desired, 0 if not.
-    *
-   **/
-   int help() const
-   {
-      return option( "HELP" ) || option( "?" );
-   }
-
-};
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
-
diff --git a/SelfServiceCommon/Services/cpp/TrcServ/inc/cxAPI.h b/SelfServiceCommon/Services/cpp/TrcServ/inc/cxAPI.h
deleted file mode 100644
index ae63a574..00000000
--- a/SelfServiceCommon/Services/cpp/TrcServ/inc/cxAPI.h
+++ /dev/null
@@ -1,247 +0,0 @@
-/**
- **************************************************************************
- *
- * @file cxAPI.h
- *
- * Contains interface definitions to the cxAPI library.
- *
- * @note Define the environment variable CXAPI_TRACE to obtain event
- *       logging to stdout.
- *
- * @author JK
- *
- * Copyright (c) 1998-2000 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef CXAPI_H
-#define CXAPI_H
-#if defined(SHOW_INCLUDE_FILES)
-#pragma message("including: " __FILE__)
-#endif
-
-#ifdef __cplusplus
-#define CX_CONSTSTR const char *
-extern "C"
-{
-#else
-#define CX_CONSTSTR char *
-#endif
-
-/**
- *
- * Create a communication point.
- *
- * @param       pOwnHandle      Address of the handle variable for the new
- *                              communication point.
- *
- * @param       pszOwnName      The name for this communication point.
- *
- * @return      0 = success, otherwise failure.
- *
-**/
-long _stdcall   cxCreateHandle
-                (
-                   long *      pOwnHandle,
-                   CX_CONSTSTR pszOwnName
-                );
-
-/**
- *
- * Delete a communication point.
- *
- * @param       OwnHandle       Communication point handle.
- *
- * @return      0 = success, otherwise failure.
- *
-**/
-long _stdcall   cxDeleteHandle
-                (
-                   long        OwnHandle
-                );
-
-/**
- *
- * Retrieve a handle for an existing partner communication point.
- *
- * @param       pHandle       Address of the handle variable for the
- *                            partner communication point.
- *
- * @param       pszName       The name of the partner communication point.
- *
- * @return      0 = success, otherwise failure.
- *
-**/
-long _stdcall   cxGetHandle
-                (
-                   long *      pHandle,
-                   CX_CONSTSTR pszName
-                );
-
-/**
- *
- * Retrieve the name for a handle.
- *
- * @param       Handle          The handle to search the name for.
- *
- * @param       BufferAddress   Pointer to the buffer for the name.
- *
- * @param       BufferLength    Size of the buffer for the name.
- *
- * @return      0 = success, otherwise failure.
- *
-**/
-long _stdcall   cxGetName
-                (
-                   long        Handle,
-                   char *      BufferAddress,
-                   long        BufferLength
-                );
-
-/**
- *
- * Retrieve a handle for an existing partner communication point. If there
- * is none, wait. The function returns also, when cxDeleteHandle for
- * OwnHandle is called.
- *
- * @param       Ownhandle     The own handle, previously obtained by a call
- *                            to cxCreateHandle.
- *
- * @param       pHandle       Address of the handle variable for the
- *                            partner communication point.
- *
- * @param       pszName       The name of the partner communication point.
- *
- * @return      0 = success, otherwise failure.
- *
-**/
-long _stdcall   cxGetWaitHandle
-                (
-                   long        OwnHandle,
-                   long *      pHandle,
-                   CX_CONSTSTR pszName
-                );
-
-/**
- *
- * Write a data block to the communication partner.
- *
- * @param       OwnHandle       The origin of the data block.
- *
- * @param       PartnerHandle   The destination of the data block.
- *
- * @param       BufferAddress   Pointer to the data block to write.
- *
- * @param       BufferLength    Pointer to an integer carrying the length
- *                              of the data block. On return gives the
- *                              actually written data.
- *
- * @return      0 = success, otherwise failure.
- *
-**/
-long _stdcall   cxWrite
-                (
-                   long        OwnHandle,
-                   long        PartnerHandle,
-                   CX_CONSTSTR BufferAddress,
-                   long *      BufferLength
-                );
-
-/**
- *
- * Read a data block from a communication partner. This function blocks the
- * calling thread until data is available, unless the BufferLength variable
- * is 0. The function returns also, when cxDeleteHandle for OwnHandle is
- * called.
- *
- * @param       OwnHandle       The destination descriptor.
- *
- * @param       PartnerHandle   Pointer to an integer to put the originator
- *                              in.
- *
- * @param       BufferAddress   Pointer to the memory buffer to copy the
- *                              data block to.
- *
- * @param       BufferLength    Length of the memory buffer. On return
- *                              gives the actually length of the data blk.
- *
- * @return      0 = success, otherwise failure.
- *
-**/
-long _stdcall   cxRead
-                (
-                   long        OwnHandle,
-                   long *      PartnerHandle,
-                   char *      BufferAddress,
-                   long *      BufferLength
-                );
-
-/**
- *
- * Give an explanation for the return code.
- *
- * @param       RC              The return code of a cxAPI function.
- *
- * @return                      Pointer to a static zero-terminated string
- *                              describing the returncode.
- *
-**/
-char * _stdcall cxErrorText
-                (
-                   long RC
-                );
-
-/**
- *
- * Create a proxy for a remote communication point.
- *
- * @param       pHandle        Address of the handle variable for the new
- *                             communication point.
- *
- * @param       pszLocalname   The local name for this communication point.
- *
- * @param       pszRemotename  The name on the remote host
- *                             (maybe equal to pszLocalname)
- *
- * @param       pszHost        The host to create the proxy for.
- *
- * @return      0 = success, otherwise failure.
- *
-**/
-long _stdcall   cxCreateProxyHandle
-                (
-                   long *      pHandle,
-                   CX_CONSTSTR pszLocalname,
-                   CX_CONSTSTR pszRemotename,
-                   CX_CONSTSTR pszHost
-                );
-
-#ifdef __cplusplus
-}
-#endif
-
-/*
-   Returncodes
-*/
-#define CXRC_OK                    0
-#define CXRC_ERROR                 1
-#define CXRC_WRONG_PARAMETER       2
-#define CXRC_NAME_ALREADY_EXISTS   3
-#define CXRC_NOT_FOUND             4
-#define CXRC_BUFFER_TOO_SMALL      5
-#define CXRC_MORE_DATA             6
-#define CXRC_PARTNER_LOST          7
-#define CXRC_CANCELLED             8
-#define CXRC_WRONG_PARTNER         9
-#define CXRC_WRONG_HANDLE          10
-#define CXRC_TRY_AGAIN             11
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
-
diff --git a/SelfServiceCommon/Services/cpp/TrcServ/inc/fmtQueue.hpp b/SelfServiceCommon/Services/cpp/TrcServ/inc/fmtQueue.hpp
deleted file mode 100644
index ebac5a0d..00000000
--- a/SelfServiceCommon/Services/cpp/TrcServ/inc/fmtQueue.hpp
+++ /dev/null
@@ -1,617 +0,0 @@
-/**
- **************************************************************************
- *
- * @file fmtQueue.hpp
- *
- * Contains the template class fmtQueue.
- *
- * @author JK
- *
- * Copyright (c) 1997-2001 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef FMTQUEUE_HPP
-#define FMTQUEUE_HPP
-#if defined(SHOW_INCLUDE_FILES)
-#pragma message("including: " __FILE__)
-#endif
-
-
-
-#include "mutex.hpp"
-#include "eventSem.hpp"
-
-
-
-/**
- *
- * Returncodes
- *
- */
-typedef enum
-{
-   //! Successful completion
-   FMTQ_OK,
-
-   //! Hard error
-   FMTQ_ERROR,
-
-   //! Queue full
-   FMTQ_FULL,
-
-   //! Timeout occured
-   FMTQ_TIMEOUT,
-
-   //! Queue empty
-   FMTQ_EMPTY
-
-} fmtQueueRC;
-
-
-
-/**
- *
- * Fixed-size multi-thread queue. Suitable for applications, which need a
- * fast queue to support inter-thread communication.
- * The queue has a length attribute, which describes the current number of
- * queue elements. Another attribute is the size, which describes the
- * maximum number of queue elements. No fancy stuff like e.g. dynamic size
- * adaptation takes place. Basic operations on the queue are a non-blocking
- * write() and a blocking read().
- *
- * @param fmtQueueElement The template argument defines the type of the
- *                        queue elements to be queued.
- *
- * @note Operations on queue elements include standard construction, copy
- *       construction and assignment. The fmtQueueElement should provide
- *       the correct implementation for these.
- *
-**/
-template<class fmtQueueElement>
-class fmtQueue
-{
-   /**
-    *
-    * Pointer to the queue element buffer.
-    *
-    */
-   fmtQueueElement * M_BufPtr;
-
-   /**
-    *
-    * Size of the queue element buffer.
-    *
-    */
-   unsigned long     M_BufSiz;
-
-   /**
-    *
-    * Buffer offset for write operations.
-    *
-    */
-   unsigned long     M_OffWrite;
-
-   /**
-    *
-    * Buffer offset for read operations.
-    *
-    */
-   unsigned long     M_OffRead;
-
-   /**
-    *
-    * Current queue length.
-    *
-    */
-   unsigned long     M_Length;
-
-   /**
-    *
-    * The number of currently reading threads.
-    *
-    */
-   long              M_Reading;
-
-   /**
-    *
-    * Protect queue agains simultaneous access.
-    *
-    */
-   mutexSemaphore    M_Mutex;
-
-   /**
-    *
-    * Signal queue events to a reader.
-    *
-    */
-   eventSemaphore    M_Event;
-
-   /**
-    *
-    * Private method, allocate resources.
-    *
-   **/
-   void qAlloc( unsigned long Size = 0 )
-   {
-      M_Mutex.request();
-      if( Size )
-      {
-         M_BufPtr = new fmtQueueElement[Size];
-      }
-      else
-      {
-         M_BufPtr = 0;
-      }
-      M_BufSiz = Size;
-      M_OffWrite = M_OffRead = 0;
-      M_Length = 0;
-      M_Reading = 0;
-      M_Mutex.release();
-   }
-
-   /**
-    *
-    * Private method, free resources.
-    *
-   **/
-   void qFree()
-   {
-      M_Mutex.request();
-      //
-      // Prevent new calls to write() and read() in the mutex-gap below.
-      //
-      M_Length = M_BufSiz = 0;
-      //
-      // Give pending read() a chance to finish.
-      // Use D_Reading to limit tries, even if reader is already dead.
-      //
-      long D_Reading = M_Reading;
-      while( M_Reading && D_Reading )
-      {
-         --D_Reading;
-         M_Mutex.release();
-         M_Event.post();
-         eventSemaphore().wait( 10 );
-         M_Mutex.request();
-      }
-      //
-      // No more read() pending - it is safe now to return.
-      //
-      if( M_BufPtr ) delete[] M_BufPtr;
-      M_Mutex.release();
-   }
-
-   /**
-    *
-    * Private method, increment a buffer offset
-    *
-   **/
-   void offInc( unsigned long & Off )
-   {
-      if( ( Off + 1 ) < M_BufSiz )
-         ++Off;
-      else
-         Off = 0;
-   }
-
-   /**
-    *
-    * Private method, decrement a buffer offset
-    *
-   **/
-   void offDec( unsigned long & Off )
-   {
-      if( Off )
-         --Off;
-      else
-         Off = M_BufSiz - 1;
-   }
-
-public:
-
-   /**
-    *
-    * Standard constructor. Does provide for a queue size of 0 only.
-    * To use the queue at all, the size method should be called later for
-    * a proper queue size.
-    *
-   **/
-   fmtQueue() :
-      M_Mutex(),
-      M_Event()
-   {
-      qAlloc();
-   }
-
-   /**
-    *
-    * Constructor. Makes a queue with the size given.
-    *
-    * @param Size Initial size of the queue.
-    *
-   **/
-   fmtQueue( unsigned long Size ) :
-      M_Mutex(),
-      M_Event()
-   {
-      qAlloc( Size );
-   }
-
-   /**
-    *
-    * Copy constructor - intentionally not implemented.
-    *
-   **/
-   fmtQueue( const fmtQueue<fmtQueueElement> & );
-
-   /**
-    *
-    * Destructor
-    *
-   **/
-   ~fmtQueue()
-   {
-      qFree();
-   }
-
-   /**
-    *
-    * Assignment operator - intentionally not implemented.
-    *
-   **/
-   fmtQueue<fmtQueueElement> & operator=
-   (
-      const fmtQueue<fmtQueueElement> &
-   );
-
-   /**
-    *
-    * Resets queue. Already queued items will be lost.
-    *
-   **/
-   void clear()
-   {
-      M_Mutex.request();
-      M_OffWrite = M_OffRead = 0;
-      M_Length = 0;
-      M_Mutex.release();
-   }
-
-   /**
-    *
-    * Resizes and resets queue. Already queued items will be lost.
-    *
-    * @param Size New size of the queue.
-    *
-    * @return New size of queue.
-    *
-   **/
-   unsigned long size( unsigned long Size )
-   {
-      qFree();
-      qAlloc( Size );
-      return Size;
-   }
-
-   /**
-    *
-    * Read an item from the queue. The function will suspend the
-    * execution thread, until an item is available.
-    *
-    * @param Destination Refers the destination to place the element read.
-    *
-    * @return FMTQ_OK or FMTQ_ERROR.
-    *
-   **/
-   fmtQueueRC read( fmtQueueElement& Destination )
-   {
-      //
-      // Protect access, check buffer size
-      //
-      M_Mutex.request();
-      if( !M_BufSiz )
-      {
-         //
-         // Error condition
-         //
-         M_Mutex.release();
-         return FMTQ_ERROR;
-      }
-      //
-      // Increment reading threads count
-      //
-      ++M_Reading;
-      while( M_Length == 0 )
-      {
-         //
-         // Queue empty - release access, wait for insert
-         //
-         M_Event.reset();
-         M_Mutex.release();
-         M_Event.wait();
-         //
-         // Some event - procect access and continue.
-         //
-         M_Mutex.request();
-         if( !M_BufSiz )
-         {
-            //
-            // Error condition
-            //
-            --M_Reading;
-            M_Mutex.release();
-            return FMTQ_ERROR;
-         }
-      }
-      //
-      // Read item from queue
-      //
-      Destination = M_BufPtr[M_OffRead];
-      offInc( M_OffRead );
-      //
-      // Counter update
-      //
-      --M_Length;
-      //
-      // Release access, return OK
-      //
-      --M_Reading;
-      M_Mutex.release();
-      return FMTQ_OK;
-   }
-
-   /**
-    *
-    * Read an item from the queue. The function will suspend the
-    * execution thread, until an item is available or until a timeout
-    * has occured.
-    *
-    * @param Destination Refers the destination to place the element read.
-    *
-    * @param Time Time in milliseconds for read
-    *
-    * @return FMTQ_OK, FMTQ_ERROR or FMTQ_TIMEOUT.
-    *
-   **/
-   fmtQueueRC read( fmtQueueElement& Destination, long Time )
-   {
-      //
-      // Protect access, check buffer size
-      //
-      M_Mutex.request();
-      if( !M_BufSiz )
-      {
-         //
-         // Error condition
-         //
-         M_Mutex.release();
-         return FMTQ_ERROR;
-      }
-      //
-      // Increment reading threads count
-      //
-      ++M_Reading;
-      while( M_Length == 0 )
-      {
-         //
-         // Queue empty - release access, wait for insert
-         //
-         M_Event.reset();
-         M_Mutex.release();
-         if( M_Event.wait( Time ) )
-         {
-            //
-            // Event timeout - leave Destination unchanged
-            //
-            --M_Reading;
-            return FMTQ_TIMEOUT;
-         }
-         //
-         // Some event - procect access and continue.
-         //
-         M_Mutex.request();
-         if( !M_BufSiz )
-         {
-            //
-            // Error condition
-            //
-            --M_Reading;
-            M_Mutex.release();
-            return FMTQ_ERROR;
-         }
-      }
-      //
-      // Read item from queue
-      //
-      Destination = M_BufPtr[M_OffRead];
-      offInc( M_OffRead );
-      //
-      // Counter update
-      //
-      --M_Length;
-      //
-      // Release access, return OK
-      //
-      --M_Reading;
-      M_Mutex.release();
-      return FMTQ_OK;
-   }
-
-   /**
-    *
-    * Write an item to the queue. Write will fail, it the queue is already
-    * full.
-    *
-    * @param Source The item to write
-    *
-    * @return FMTQ_OK or FMTQ_FULL.
-    *
-   **/
-   fmtQueueRC write( fmtQueueElement const & Source )
-   {
-      //
-      // Protect access
-      //
-      M_Mutex.request();
-      if( M_Length < M_BufSiz )
-      {
-         //
-         // Queue not yet full - write item to queue
-         //
-         M_BufPtr[M_OffWrite] = Source;
-         offInc( M_OffWrite );
-         //
-         // Counter update
-         //
-         ++M_Length;
-         //
-         // Release access, post sema, return OK
-         //
-         M_Mutex.release();
-         M_Event.post();
-         return FMTQ_OK;
-      }
-      else
-      {
-         //
-         // Queue full - release access, return ERROR
-         M_Mutex.release();
-         return FMTQ_FULL;
-      }
-   }
-
-   /**
-    *
-    * Write an item to the front of the queue. The next read operation
-    * will return this item. The write will fail, if the queue is already
-    * full.
-    *
-    * @param Source The item to write
-    *
-    * @return FMTQ_OK or FMTQ_FULL.
-    *
-   **/
-   fmtQueueRC writeFront( fmtQueueElement const & Source )
-   {
-      //
-      // Protect access
-      //
-      M_Mutex.request();
-      if( M_Length < M_BufSiz )
-      {
-         //
-         // Queue not yet full - write item to queue
-         //
-         offDec( M_OffRead );
-         M_BufPtr[M_OffRead] = Source;
-         //
-         // Counter update
-         //
-         ++M_Length;
-         //
-         // Release access, post sema, return OK
-         //
-         M_Mutex.release();
-         M_Event.post();
-         return FMTQ_OK;
-      }
-      else
-      {
-         //
-         // Queue full - release access, return ERROR
-         M_Mutex.release();
-         return FMTQ_FULL;
-      }
-   }
-
-   /**
-    *
-    * Query queue length. This is advised prior to blocking read(),
-    * if you do not want to be blocked.
-    *
-    * @return Length of the queue.
-    *
-   **/
-   unsigned long length() const
-   {
-      return M_Length;
-   }
-
-   /**
-    *
-    * Peek into the queue. The function will return immediately.
-    * peek( 0 ) will yield the next item to be read, peek( 1 ) the 2nd but
-    * next, etc. The queue contents will not be modified. The returncode
-    * will indicate, if the index-d place is not used (FMTQ_EMPTY) or
-    * beyond the size of queue (FMTQ_ERROR). A queue of size 0 will always
-    * return FMTQ_ERROR.
-    *
-    * @note With several threads reading it might be advisable to use the
-    *       lock() / unlock() methods around peek().
-    *
-    * @param pDestination A pointer, which after successful return will
-    *        address the target element.
-    *
-    * @return FMTQ_OK, FMTQ_EMPTY or FMTQ_ERROR.
-    *
-   **/
-   fmtQueueRC peek
-   (
-      fmtQueueElement * & pDestination,
-      unsigned long       Index = 0
-   ) const
-   {
-      if( Index >= M_Length  )
-      {
-         if( Index >= M_BufSiz )
-            return FMTQ_ERROR;
-         else
-            return FMTQ_EMPTY;
-      }
-      else
-      {
-         unsigned long Offset = M_OffRead + Index;
-         if( Offset >= M_BufSiz )
-            Offset -= M_BufSiz;
-         pDestination = &M_BufPtr[Offset];
-         return FMTQ_OK;
-      }
-   }
-
-   /**
-    *
-    * Lock the queue against modifications. The execution of size(), read()
-    * and write() methods is blocked.
-    *
-   **/
-   void lock()
-   {
-      M_Mutex.request();
-   }
-
-   /**
-    *
-    * Undo a previous lock().
-    *
-    * @note Do not use unlock() without a previous lock()!
-    *
-   **/
-   void unlock()
-   {
-      M_Mutex.release();
-   }
-
-
-};
-
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
-
-- 
2.41.0.windows.1

