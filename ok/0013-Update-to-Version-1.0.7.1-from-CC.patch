From b7908497b8b9cdf82e6bf0f51ca425c2b488c497 Mon Sep 17 00:00:00 2001
From: mpatzer <mpatzer@90b65887-3827-0410-9a23-83215b262276>
Date: Thu, 22 Feb 2007 12:46:45 +0000
Subject: [PATCH 0013/1077] Update to Version 1.0.7.1 from CC

git-svn-id: svn://localhost/SelfServiceCommon/trunk@13 90b65887-3827-0410-9a23-83215b262276
---
 .../cpp/CfgTools/inc/CfgTextListExtend_def.h  |   32 +
 Massai/cpp/CfgTools/res/CfgTextListExtend.rc  |   49 +
 Massai/cpp/CfgTools/src/CfgTextListExtend.cpp |  104 ++
 .../LogServiceEx/compConfiguration_MUC.txt    |   88 +
 .../LogServiceEx/compConfiguration_VIE.txt    |  126 ++
 .../compConfiguration_VIE_AUA(NOBAG).txt      |  126 ++
 .../compConfiguration_VIE_AUA_(BAG).txt       |  126 ++
 ...mpConfiguration_VIE_AUA_BER_KLM(NOBAG).txt |  126 ++
 .../compConfiguration_VIE_AUA_DLH_(BAG).txt   |  126 ++
 .../compConfiguration_VIE_AUA_DLH_(NOBAG).txt |  126 ++
 ...compConfiguration_VIE_AUA_DLH_IB_(BAG).txt |  126 ++
 ...mpConfiguration_VIE_AUA_DLH_IB_(NOBAG).txt |  126 ++
 ...iguration_VIE_AUA_DLH_KLM_IB_BER_(BAG).txt |  126 ++
 ...uration_VIE_AUA_DLH_KLM_IB_BER_(NOBAG).txt |  126 ++
 ...ompConfiguration_VIE_AUA_IB_KLM(NOBAG).txt |  126 ++
 Massai/cpp/LogServiceEx/inc/execTime.hpp      |   71 +
 Massai/cpp/MassaiDLL/dll/inc/COMPRESS.H       |   59 +
 Massai/cpp/MassaiDLL/dll/inc/TRACE.HPP        |   53 +
 Massai/cpp/MassaiDLL/dll/inc/globbase.hpp     |   71 +
 Massai/cpp/MassaiDLL/dll/inc/local_def.h      |   27 +
 Massai/cpp/MassaiDLL/dll/inc/mConfig.h        |   42 +
 Massai/cpp/MassaiDLL/dll/inc/mhandler.hpp     |  215 +++
 Massai/cpp/MassaiDLL/dll/inc/mvsprintf.h      |   25 +
 Massai/cpp/MassaiDLL/dll/res/FileVersion.rc   |  108 ++
 Massai/cpp/MassaiDLL/dll/src/NT_MXSEM.cpp     |   67 +
 Massai/cpp/MassaiDLL/dll/src/base_os.cpp      | 1177 ++++++++++++++
 Massai/cpp/MassaiDLL/dll/src/compress.cpp     |  496 ++++++
 Massai/cpp/MassaiDLL/dll/src/mConfig.cpp      | 1385 ++++++++++++++++
 Massai/cpp/MassaiDLL/dll/src/mDate.cpp        |  520 ++++++
 Massai/cpp/MassaiDLL/dll/src/mList.cpp        |  339 ++++
 Massai/cpp/MassaiDLL/dll/src/mThread.cpp      |  260 +++
 Massai/cpp/MassaiDLL/dll/src/mThreadEx.cpp    |  459 ++++++
 Massai/cpp/MassaiDLL/dll/src/mTime.cpp        |   43 +
 Massai/cpp/MassaiDLL/dll/src/mTimer.cpp       |  203 +++
 Massai/cpp/MassaiDLL/dll/src/mTraceEx.cpp     |  635 ++++++++
 Massai/cpp/MassaiDLL/dll/src/massai.cpp       | 1428 +++++++++++++++++
 Massai/cpp/MassaiDLL/dll/src/mbasicrefs.cpp   |   78 +
 Massai/cpp/MassaiDLL/dll/src/mhandler.cpp     |  329 ++++
 Massai/cpp/MassaiDLL/dll/src/mvsprintf.cpp    |  679 ++++++++
 Massai/cpp/MassaiDLL/dll/src/trace.cpp        | 1072 +++++++++++++
 Massai/cpp/MassaiDLL/static/inc/COMPRESS.H    |   59 +
 Massai/cpp/MassaiDLL/static/inc/TRACE.HPP     |   53 +
 Massai/cpp/MassaiDLL/static/inc/globbase.hpp  |   71 +
 Massai/cpp/MassaiDLL/static/inc/local_def.h   |   27 +
 Massai/cpp/MassaiDLL/static/inc/mConfig.h     |   42 +
 Massai/cpp/MassaiDLL/static/inc/mhandler.hpp  |  215 +++
 Massai/cpp/MassaiDLL/static/inc/mvsprintf.h   |   25 +
 .../cpp/MassaiDLL/static/res/FileVersion.rc   |  108 ++
 Massai/cpp/MassaiDLL/static/src/NT_MXSEM.cpp  |   67 +
 Massai/cpp/MassaiDLL/static/src/base_os.cpp   | 1177 ++++++++++++++
 Massai/cpp/MassaiDLL/static/src/compress.cpp  |  496 ++++++
 Massai/cpp/MassaiDLL/static/src/mConfig.cpp   | 1385 ++++++++++++++++
 Massai/cpp/MassaiDLL/static/src/mDate.cpp     |  520 ++++++
 Massai/cpp/MassaiDLL/static/src/mList.cpp     |  339 ++++
 Massai/cpp/MassaiDLL/static/src/mThread.cpp   |  260 +++
 Massai/cpp/MassaiDLL/static/src/mThreadEx.cpp |  459 ++++++
 Massai/cpp/MassaiDLL/static/src/mTime.cpp     |   43 +
 Massai/cpp/MassaiDLL/static/src/mTimer.cpp    |  203 +++
 Massai/cpp/MassaiDLL/static/src/mTraceEx.cpp  |  635 ++++++++
 Massai/cpp/MassaiDLL/static/src/massai.cpp    | 1428 +++++++++++++++++
 .../cpp/MassaiDLL/static/src/mbasicrefs.cpp   |   78 +
 Massai/cpp/MassaiDLL/static/src/mhandler.cpp  |  329 ++++
 Massai/cpp/MassaiDLL/static/src/mvsprintf.cpp |  679 ++++++++
 Massai/cpp/MassaiDLL/static/src/trace.cpp     | 1072 +++++++++++++
 64 files changed, 21270 insertions(+)
 create mode 100644 Massai/cpp/CfgTools/inc/CfgTextListExtend_def.h
 create mode 100644 Massai/cpp/CfgTools/res/CfgTextListExtend.rc
 create mode 100644 Massai/cpp/CfgTools/src/CfgTextListExtend.cpp
 create mode 100644 Massai/cpp/LogServiceEx/compConfiguration_MUC.txt
 create mode 100644 Massai/cpp/LogServiceEx/compConfiguration_VIE.txt
 create mode 100644 Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA(NOBAG).txt
 create mode 100644 Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_(BAG).txt
 create mode 100644 Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_BER_KLM(NOBAG).txt
 create mode 100644 Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_DLH_(BAG).txt
 create mode 100644 Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_DLH_(NOBAG).txt
 create mode 100644 Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_DLH_IB_(BAG).txt
 create mode 100644 Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_DLH_IB_(NOBAG).txt
 create mode 100644 Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_DLH_KLM_IB_BER_(BAG).txt
 create mode 100644 Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_DLH_KLM_IB_BER_(NOBAG).txt
 create mode 100644 Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_IB_KLM(NOBAG).txt
 create mode 100644 Massai/cpp/LogServiceEx/inc/execTime.hpp
 create mode 100644 Massai/cpp/MassaiDLL/dll/inc/COMPRESS.H
 create mode 100644 Massai/cpp/MassaiDLL/dll/inc/TRACE.HPP
 create mode 100644 Massai/cpp/MassaiDLL/dll/inc/globbase.hpp
 create mode 100644 Massai/cpp/MassaiDLL/dll/inc/local_def.h
 create mode 100644 Massai/cpp/MassaiDLL/dll/inc/mConfig.h
 create mode 100644 Massai/cpp/MassaiDLL/dll/inc/mhandler.hpp
 create mode 100644 Massai/cpp/MassaiDLL/dll/inc/mvsprintf.h
 create mode 100644 Massai/cpp/MassaiDLL/dll/res/FileVersion.rc
 create mode 100644 Massai/cpp/MassaiDLL/dll/src/NT_MXSEM.cpp
 create mode 100644 Massai/cpp/MassaiDLL/dll/src/base_os.cpp
 create mode 100644 Massai/cpp/MassaiDLL/dll/src/compress.cpp
 create mode 100644 Massai/cpp/MassaiDLL/dll/src/mConfig.cpp
 create mode 100644 Massai/cpp/MassaiDLL/dll/src/mDate.cpp
 create mode 100644 Massai/cpp/MassaiDLL/dll/src/mList.cpp
 create mode 100644 Massai/cpp/MassaiDLL/dll/src/mThread.cpp
 create mode 100644 Massai/cpp/MassaiDLL/dll/src/mThreadEx.cpp
 create mode 100644 Massai/cpp/MassaiDLL/dll/src/mTime.cpp
 create mode 100644 Massai/cpp/MassaiDLL/dll/src/mTimer.cpp
 create mode 100644 Massai/cpp/MassaiDLL/dll/src/mTraceEx.cpp
 create mode 100644 Massai/cpp/MassaiDLL/dll/src/massai.cpp
 create mode 100644 Massai/cpp/MassaiDLL/dll/src/mbasicrefs.cpp
 create mode 100644 Massai/cpp/MassaiDLL/dll/src/mhandler.cpp
 create mode 100644 Massai/cpp/MassaiDLL/dll/src/mvsprintf.cpp
 create mode 100644 Massai/cpp/MassaiDLL/dll/src/trace.cpp
 create mode 100644 Massai/cpp/MassaiDLL/static/inc/COMPRESS.H
 create mode 100644 Massai/cpp/MassaiDLL/static/inc/TRACE.HPP
 create mode 100644 Massai/cpp/MassaiDLL/static/inc/globbase.hpp
 create mode 100644 Massai/cpp/MassaiDLL/static/inc/local_def.h
 create mode 100644 Massai/cpp/MassaiDLL/static/inc/mConfig.h
 create mode 100644 Massai/cpp/MassaiDLL/static/inc/mhandler.hpp
 create mode 100644 Massai/cpp/MassaiDLL/static/inc/mvsprintf.h
 create mode 100644 Massai/cpp/MassaiDLL/static/res/FileVersion.rc
 create mode 100644 Massai/cpp/MassaiDLL/static/src/NT_MXSEM.cpp
 create mode 100644 Massai/cpp/MassaiDLL/static/src/base_os.cpp
 create mode 100644 Massai/cpp/MassaiDLL/static/src/compress.cpp
 create mode 100644 Massai/cpp/MassaiDLL/static/src/mConfig.cpp
 create mode 100644 Massai/cpp/MassaiDLL/static/src/mDate.cpp
 create mode 100644 Massai/cpp/MassaiDLL/static/src/mList.cpp
 create mode 100644 Massai/cpp/MassaiDLL/static/src/mThread.cpp
 create mode 100644 Massai/cpp/MassaiDLL/static/src/mThreadEx.cpp
 create mode 100644 Massai/cpp/MassaiDLL/static/src/mTime.cpp
 create mode 100644 Massai/cpp/MassaiDLL/static/src/mTimer.cpp
 create mode 100644 Massai/cpp/MassaiDLL/static/src/mTraceEx.cpp
 create mode 100644 Massai/cpp/MassaiDLL/static/src/massai.cpp
 create mode 100644 Massai/cpp/MassaiDLL/static/src/mbasicrefs.cpp
 create mode 100644 Massai/cpp/MassaiDLL/static/src/mhandler.cpp
 create mode 100644 Massai/cpp/MassaiDLL/static/src/mvsprintf.cpp
 create mode 100644 Massai/cpp/MassaiDLL/static/src/trace.cpp

diff --git a/Massai/cpp/CfgTools/inc/CfgTextListExtend_def.h b/Massai/cpp/CfgTools/inc/CfgTextListExtend_def.h
new file mode 100644
index 00000000..2fbf6423
--- /dev/null
+++ b/Massai/cpp/CfgTools/inc/CfgTextListExtend_def.h
@@ -0,0 +1,32 @@
+//-------------------------------------------------------------------------
+//
+// Characteristics for CfgTextListExtend.exe
+//
+//-------------------------------------------------------------------------
+
+
+//-------------------------------------------------------------------------
+//
+// Versions
+//
+//
+// 06.02.2007  EgF 
+#define FILE_VER_BIN 1,0,0,0
+#define FILE_VER_DTS "1.0.0.0\0"
+//
+//-------------------------------------------------------------------------
+
+
+#define FILEDESCRIPTION  "FileDescription"  ,"CfgTextListExtend\0"
+#define INTERNALNAME     "InternalName"     ,"CfgTextListExtend\0"
+#define LEGALTRADEMARKS  "LegalTrademarks"  ,"\0"
+#define ORIGINALFILENAME "OriginalFilename" ,"CfgTextListExtend.exe\0"
+#define FILE_VER_STR     "FileVersion"      ,FILE_VER_DTS
+
+
+//-------------------------------------------------------------------------
+//
+// End of file
+//
+//-------------------------------------------------------------------------
+
diff --git a/Massai/cpp/CfgTools/res/CfgTextListExtend.rc b/Massai/cpp/CfgTools/res/CfgTextListExtend.rc
new file mode 100644
index 00000000..a377c3ac
--- /dev/null
+++ b/Massai/cpp/CfgTools/res/CfgTextListExtend.rc
@@ -0,0 +1,49 @@
+//
+// CfgTextListExtend.rc
+//
+#include "Global_def.h"
+#include "CfgTextListExtend_def.h"
+
+#include "winver.h"
+
+
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION FILE_VER_BIN
+ PRODUCTVERSION PRODUCT_VER_BIN
+ FILEFLAGSMASK 0x3fL
+#ifdef _DEBUG
+ FILEFLAGS 0x1L
+#else
+ FILEFLAGS 0x0L
+#endif
+ FILEOS 0x40004L
+ FILETYPE 0x2L
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040704b0"
+        BEGIN
+            VALUE COMPANY
+            VALUE FILEDESCRIPTION
+            VALUE FILE_VER_STR
+            VALUE INTERNALNAME
+            VALUE COPYRIGHT
+            VALUE LEGALTRADEMARKS
+            VALUE ORIGINALFILENAME
+            VALUE PRODUCT
+            VALUE PRODUCT_VER_STR
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x407, 1200
+    END
+END
+
+
+
+//
+// End of file
+//
diff --git a/Massai/cpp/CfgTools/src/CfgTextListExtend.cpp b/Massai/cpp/CfgTools/src/CfgTextListExtend.cpp
new file mode 100644
index 00000000..d419bf93
--- /dev/null
+++ b/Massai/cpp/CfgTools/src/CfgTextListExtend.cpp
@@ -0,0 +1,104 @@
+#pragma warning(disable:4786)
+
+#include <iostream>
+#include <fstream>
+#include <string>
+#include <list>
+#include <algorithm>
+
+#include "nConfigTextList.hpp"
+
+
+class cfgTextList : public nConfig::gcTextList
+{
+
+public:
+
+
+   cfgTextList( char const * Item, char const * Client ) :
+      nConfig::gcTextList( Item, Client )
+   {
+   }
+   
+   
+   void AppendTextList( std::string const & fileName )
+   {
+     typedef std::list<std::string> myList;
+     myList List = get();
+     myList::const_iterator I = List.begin();
+     
+     std::ifstream i( fileName.c_str() ); 
+     
+     if( !i.is_open() )
+     {
+       std::cout << "file not found: " << fileName.c_str() << std::endl;
+       return;
+     }
+     
+     char szLine[2048];
+     while( i.good() && !i.eof() )
+     {
+       i.getline( szLine, sizeof(szLine) );
+       std::string line( szLine );
+       unsigned const nonWhiteSpace = line.find_first_not_of( " " );
+       if( nonWhiteSpace != line.npos )
+       {
+         if( line.compare( nonWhiteSpace, 2, "//" ) )
+         {
+           I = std::find( List.begin(), List.end(), line.substr( nonWhiteSpace, line.size() - nonWhiteSpace ) );
+           if( I == List.end() )
+             List.insert( List.end(), line.substr( nonWhiteSpace, line.size() - nonWhiteSpace ) );
+         }
+       }
+     }       
+     
+     try
+     {
+       set( List );
+       std::cout << "Configuration entry set successfully." << std::endl;
+     }
+     catch( ... )
+     {
+       try
+       {
+         setInitial( List );
+         std::cout << "Configuration entry initial-set successfully." << std::endl;
+       }
+       catch( ... )
+       {
+         std::cout << "Setting configuration entry failed!" << std::endl;
+       }
+     }
+   };
+
+private:
+   cfgTextList();
+
+};
+
+
+
+void usage()
+{
+   std::cout << "Usage: cfgTextListExtend <cfg path> <filename>" << std::endl;
+   std::cout << "e.g. cfgTextListExtend ENVIRONMENT.APPLICATIONS.Installed_Applications IB_APP.txt" << std::endl;
+   std::cout << "Appends the values listed in the given file to the TextList" << std::endl;
+   exit(1);
+}
+
+
+
+int main( char argc, char** argv )
+{
+   if( argc != 3 )
+   {
+      usage();
+   }
+   else
+   {
+     cfgTextList cfg( argv[1], "TEST" );
+     cfg.AppendTextList( std::string(argv[2]) );
+   }
+   
+   return 0;
+}
diff --git a/Massai/cpp/LogServiceEx/compConfiguration_MUC.txt b/Massai/cpp/LogServiceEx/compConfiguration_MUC.txt
new file mode 100644
index 00000000..60ac79c7
--- /dev/null
+++ b/Massai/cpp/LogServiceEx/compConfiguration_MUC.txt
@@ -0,0 +1,88 @@
+CRD_READER;OK=1000;ERROR=1001 | 1002 | 1003 | 1004 | 1005
+CRD_DISPENSER;OK=1020;ERROR=1021 | 1022 | 1023 | 1024 | 1025
+CRD_CAPTURE;OK=1030;ERROR=1031 | 1032 | 1033 | 1034 | 1035 | 1036
+CRD_POWER;OK=1000 | 100717;ERROR=100716
+CRD_COMP;OK=CRD_READER.OK & CRD_DISPENSER.OK & CRD_CAPTURE.OK & CRD_POWER.OK
+
+ATB_READER;OK=2000;ERROR=2001 | 2002 | 2003 | 2004 | 2005
+ATB_WRITER;OK=2010;ERROR=2011 | 2012 | 2013 | 2014 | 2015
+ATB_DISPENSER;OK=2020 | 2028;ERROR=2021 | 2022 | 2023 | 2024 | 2025
+ATB_ESCR_CAPTURE;OK=2060 | 2066;ERROR=2061 | 2062 | 2063 | 2064 | 2065 | 2066
+ATB_FEEDER_BP;OK=2200 | 2201 | 2202 | 2203 | 2207;ERROR=2208 | 2204
+// ATB_FEEDER_BP_FIRST;OK=2210 | 2211 | 2212 | 2213 | 2217;ERROR=2218 | 2214
+// ATB_FEEDER_BP_BUSINESS;OK=2220 | 2221 | 2222 | 2223 | 2227;ERROR=2228 | 2224
+// ATB_FEEDER_BP_ECONOMY;OK=2230 | 2231 | 2232 | 2233 | 2237;ERROR=2238 | 2234
+// ATB_FEEDER_TK;OK=2240 | 2241 | 2242 | 2243 | 2247;ERROR=2248 | 2244
+// ATB_FEEDER_GP;OK=2250 | 2251 | 2252 | 2253 | 2257;ERROR=2258 | 2254
+// ATB_PAPER;OK=ATB_FEEDER_BP.OK | ATB_FEEDER_BP_FIRST.OK | ATB_FEEDER_BP_BUSINESS.OK | ATB_FEEDER_BP_ECONOMY.OK | ATB_FEEDER_TK.OK | ATB_FEEDER_GP.OK | ATB_WRITER.OK
+ATB_PAPER;OK=ATB_FEEDER_BP.OK
+ATBHW;OK=100500;ERROR=100501 | 100502 | 100503 | 100504 | 100505 | 100506 | 100531 | 100532
+ATBHW_ESCROW;OK=100400;ERROR=100401 | 100402 | 100403 | 100404 | 100420 | 100421 | 100422
+ATB_POWER;OK=2000 | 100713;ERROR=100712
+ATB_COMP;OK=ATB_READER.OK & ATB_WRITER.OK & ATB_DISPENSER.OK & ATB_PAPER.OK & ATBHW.OK & ATBHW_ESCROW.OK & ATB_POWER.OK & ATB_ESCR_CAPTURE.OK
+
+BTP_WRITER;OK=3000;ERROR=3001 | 3002 | 3003 | 3004 | 3005 | 3006 | 3012 | 3013
+BTP_PAPER;OK=3000 | 3100 | 3101 | 3102;ERROR=3103
+BTPHW;OK=100600;ERROR=100601 | 100602 | 100603 | 100604 | 100605 | 100606
+BTP_POWER;OK=3000 | 100715;ERROR=100714
+BTP_COMP;OK=BTP_WRITER.OK & BTP_PAPER.OK & BTPHW.OK & BTP_POWER.OK
+
+CON;OK=9000;ERROR=9002 | 9003 | 9004 | 9005 | 9006 | 9011
+CONHW;OK=100015 | 9000;ERROR=100001 | 100002 | 100013 | 100014
+CONHW_SCN;OK=100100 | 9000;ERROR=100101 | 100102 | 100103
+CONHW_SPS;OK=100200 | 9000;ERROR=100201 | 100202 | 100203
+CONHW_SCL;OK=100300 | 9000;ERROR=100301 | 100302 | 100303
+CON_COMP;OK=CON.OK & CONHW.OK & CONHW_SCN.OK & CONHW_SPS.OK & CONHW_SCL.OK
+
+MPR_READER;OK=8000;ERROR=8001 | 8002 | 8003 | 8004 | 8005 | 8006 | 8012
+MPR_COMP;OK=MPR_READER.OK
+
+SEL;OK=100718;ERROR=100719 | 100711
+DOOR;CLOSED=100702;OPEN=100701
+
+// <<< component configuration: please uncomment the one component configuration in use
+
+// Baggage handling without MPR
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & BTP_COMP.OK & CON_COMP.OK
+
+// Baggage Handling
+COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & BTP_COMP.OK & CON_COMP.OK & MPR_COMP.OK
+
+// Without Baggage Handling without MPR
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK
+
+// Without Baggage Handling
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & MPR_COMP.OK
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+KIOSK_SEL;OK=DOOR.CLOSED & SEL.OK;SERVICE=DOOR.OPEN & SEL.OK
+KIOSK_SVCAPP;INACTIVE=11001 | 11003 | 11004 | 11005 | 11006 | 11007 | 11008 | 11009 | 11010;ACTIVE=11002 | 11011
+KIOSK;OPERATION=KIOSK_SEL.OK & KIOSK_SVCAPP.INACTIVE;UNDER_SERVICE=KIOSK_SEL.SERVICE | KIOSK_SVCAPP.ACTIVE
+
+CLA;AVAILABLE=10001 | 10002 | 10003 | 10004 | 10005;UNAVAILABLE=10000 | 10006 | 10007 | 10008 | 10011
+
+SVC;AVAILABLE=11001 | 11002 | 11003 | 11004 | 11005;UNAVAILABLE=11000 | 11006 | 11007 | 11008 | 11010
+
+
+
+// <<< Application section: please uncomment the installed applications
+
+AL_DLH;AVAILABLE=12001 | 12002 | 12003 | 12004 | 12005;UNAVAILABLE=12000 | 12006 | 12007 | 12008 | 12010 | 12011 | 12012
+APP_DLH;AVAILABLE=AL_DLH.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK
+APP_DLH_BAG;AVAILABLE=APP_DLH.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+AL_UA;AVAILABLE=18001 | 18002 | 18003 | 18004 | 18005;UNAVAILABLE=18000 | 18006 | 18007 | 18008 | 18010 | 18011 | 18012
+APP_UA;AVAILABLE=AL_UA.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK
+APP_UA_BAG;AVAILABLE=APP_UA.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+
+// <<< System section: please uncomment the one kiosk configuration in use
+
+// AUA + DLH (Baggage Handling)
+SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_UA_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_UA.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;UA_OK=APP_UA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
diff --git a/Massai/cpp/LogServiceEx/compConfiguration_VIE.txt b/Massai/cpp/LogServiceEx/compConfiguration_VIE.txt
new file mode 100644
index 00000000..c68bebc8
--- /dev/null
+++ b/Massai/cpp/LogServiceEx/compConfiguration_VIE.txt
@@ -0,0 +1,126 @@
+CRD_READER;OK=1000;ERROR=1001 | 1002 | 1003 | 1004 | 1005
+CRD_DISPENSER;OK=1020;ERROR=1021 | 1022 | 1023 | 1024 | 1025
+CRD_CAPTURE;OK=1030;ERROR=1031 | 1032 | 1033 | 1034 | 1035 | 1036
+CRD_POWER;OK=1000 | 100717;ERROR=100716
+CRD_COMP;OK=CRD_READER.OK & CRD_DISPENSER.OK & CRD_CAPTURE.OK & CRD_POWER.OK
+
+ATB_READER;OK=2000;ERROR=2001 | 2002 | 2003 | 2004 | 2005
+ATB_WRITER;OK=2010;ERROR=2011 | 2012 | 2013 | 2014 | 2015
+ATB_DISPENSER;OK=2020 | 2028;ERROR=2021 | 2022 | 2023 | 2024 | 2025
+ATB_ESCR_CAPTURE;OK=2060 | 2066;ERROR=2061 | 2062 | 2063 | 2064 | 2065 | 2066
+ATB_FEEDER_BP;OK=2200 | 2201 | 2202 | 2203 | 2207;ERROR=2208 | 2204
+// ATB_FEEDER_BP_FIRST;OK=2210 | 2211 | 2212 | 2213 | 2217;ERROR=2218 | 2214
+// ATB_FEEDER_BP_BUSINESS;OK=2220 | 2221 | 2222 | 2223 | 2227;ERROR=2228 | 2224
+// ATB_FEEDER_BP_ECONOMY;OK=2230 | 2231 | 2232 | 2233 | 2237;ERROR=2238 | 2234
+// ATB_FEEDER_TK;OK=2240 | 2241 | 2242 | 2243 | 2247;ERROR=2248 | 2244
+// ATB_FEEDER_GP;OK=2250 | 2251 | 2252 | 2253 | 2257;ERROR=2258 | 2254
+// ATB_PAPER;OK=ATB_FEEDER_BP.OK | ATB_FEEDER_BP_FIRST.OK | ATB_FEEDER_BP_BUSINESS.OK | ATB_FEEDER_BP_ECONOMY.OK | ATB_FEEDER_TK.OK | ATB_FEEDER_GP.OK | ATB_WRITER.OK
+ATB_PAPER;OK=ATB_FEEDER_BP.OK
+ATBHW;OK=100500;ERROR=100501 | 100502 | 100503 | 100504 | 100505 | 100506 | 100531 | 100532
+ATBHW_ESCROW;OK=100400;ERROR=100401 | 100402 | 100403 | 100404 | 100420 | 100421 | 100422
+ATB_POWER;OK=2000 | 100713;ERROR=100712
+ATB_COMP;OK=ATB_READER.OK & ATB_WRITER.OK & ATB_DISPENSER.OK & ATB_PAPER.OK & ATBHW.OK & ATBHW_ESCROW.OK & ATB_POWER.OK & ATB_ESCR_CAPTURE.OK
+
+BTP_WRITER;OK=3000;ERROR=3001 | 3002 | 3003 | 3004 | 3005 | 3006 | 3012 | 3013
+BTP_PAPER;OK=3000 | 3100 | 3101 | 3102;ERROR=3103
+BTPHW;OK=100600;ERROR=100601 | 100602 | 100603 | 100604 | 100605 | 100606
+BTP_POWER;OK=3000 | 100715;ERROR=100714
+BTP_COMP;OK=BTP_WRITER.OK & BTP_PAPER.OK & BTPHW.OK & BTP_POWER.OK
+
+CON;OK=9000;ERROR=9002 | 9003 | 9004 | 9005 | 9006 | 9011
+CONHW;OK=100015 | 9000;ERROR=100001 | 100002 | 100013 | 100014
+CONHW_SCN;OK=100100 | 9000;ERROR=100101 | 100102 | 100103
+CONHW_SPS;OK=100200 | 9000;ERROR=100201 | 100202 | 100203
+CONHW_SCL;OK=100300 | 9000;ERROR=100301 | 100302 | 100303
+CON_COMP;OK=CON.OK & CONHW.OK & CONHW_SCN.OK & CONHW_SPS.OK & CONHW_SCL.OK
+
+// MPR_READER;OK=8000;ERROR=8001 | 8002 | 8003 | 8004 | 8005 | 8006 | 8012
+// MPR_COMP;OK=MPR_READER.OK
+
+SEL;OK=100718;ERROR=100719 | 100711
+DOOR;CLOSED=100702;OPEN=100701
+
+// <<< component configuration: please uncomment the one component configuration in use
+
+// Baggage handling without MPR
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & BTP_COMP.OK & CON_COMP.OK
+
+// Baggage Handling
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & BTP_COMP.OK & CON_COMP.OK & MPR_COMP.OK
+
+// Without Baggage Handling without MPR
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK
+
+// Without Baggage Handling
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & MPR_COMP.OK
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+KIOSK_SEL;OK=DOOR.CLOSED & SEL.OK;SERVICE=DOOR.OPEN & SEL.OK
+KIOSK_SVCAPP;INACTIVE=11001 | 11003 | 11004 | 11005 | 11006 | 11007 | 11008 | 11009 | 11010;ACTIVE=11002 | 11011
+KIOSK;OPERATION=KIOSK_SEL.OK & KIOSK_SVCAPP.INACTIVE;UNDER_SERVICE=KIOSK_SEL.SERVICE | KIOSK_SVCAPP.ACTIVE
+
+CLA;AVAILABLE=10001 | 10002 | 10003 | 10004 | 10005;UNAVAILABLE=10000 | 10006 | 10007 | 10008 | 10011
+
+SVC;AVAILABLE=11001 | 11002 | 11003 | 11004 | 11005;UNAVAILABLE=11000 | 11006 | 11007 | 11008 | 11010
+
+
+
+// <<< Application section: please uncomment the installed applications
+
+// AL_DLH;AVAILABLE=12001 | 12002 | 12003 | 12004 | 12005;UNAVAILABLE=12000 | 12006 | 12007 | 12008 | 12010 | 12011 | 12012
+// APP_DLH;AVAILABLE=AL_DLH.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_DLH_BAG;AVAILABLE=APP_DLH.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// AL_AUA;AVAILABLE=14001 | 14002 | 14003 | 14004 | 14005;UNAVAILABLE=14000 | 14006 | 14007 | 14008 | 14010 | 14011 | 14012
+// APP_AUA;AVAILABLE=AL_AUA.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_AUA_BAG;AVAILABLE=APP_AUA.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// AL_KLM;AVAILABLE=16001 | 16002 | 16003 | 16004 | 16005;UNAVAILABLE=16000 | 16006 | 16007 | 16008 | 16010 | 16011 | 16012
+// APP_KLM;AVAILABLE=AL_AUA.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_KLM_BAG;AVAILABLE=APP_AUA.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// AL_BER;AVAILABLE=19001 | 19002 | 19003 | 19004 | 19005;UNAVAILABLE=19000 | 19006 | 19007 | 19008 | 19010 | 19011 | 19012
+// APP_BER;AVAILABLE=AL_BER.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_BER_BAG;AVAILABLE=APP_BER.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// AL_IB;AVAILABLE=21001 | 21002 | 21003 | 21004 | 21005;UNAVAILABLE=21000 | 21006 | 21007 | 21008 | 21010 | 21011 | 21012
+// APP_IB;AVAILABLE=AL_IB.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_IB_BAG;AVAILABLE=APP_IB.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+
+// <<< System section: please uncomment the one kiosk configuration in use
+
+// AUA + DLH (Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB (Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE & APP_IB_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA (Baggage Handling)
+// SYSTEM;ALL_OK=APP_AUA_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_AUA.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB + BER + KLM(Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE & APP_IB_BAG.AVAILABLE & APP_BER_BAG.AVAILABLE & APP_KLM_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB + BER + KLM
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + IB + KLM
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + BER + KLM
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
diff --git a/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA(NOBAG).txt b/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA(NOBAG).txt
new file mode 100644
index 00000000..287dc857
--- /dev/null
+++ b/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA(NOBAG).txt
@@ -0,0 +1,126 @@
+CRD_READER;OK=1000;ERROR=1001 | 1002 | 1003 | 1004 | 1005
+CRD_DISPENSER;OK=1020;ERROR=1021 | 1022 | 1023 | 1024 | 1025
+CRD_CAPTURE;OK=1030;ERROR=1031 | 1032 | 1033 | 1034 | 1035 | 1036
+CRD_POWER;OK=1000 | 100717;ERROR=100716
+CRD_COMP;OK=CRD_READER.OK & CRD_DISPENSER.OK & CRD_CAPTURE.OK & CRD_POWER.OK
+
+ATB_READER;OK=2000;ERROR=2001 | 2002 | 2003 | 2004 | 2005
+ATB_WRITER;OK=2010;ERROR=2011 | 2012 | 2013 | 2014 | 2015
+ATB_DISPENSER;OK=2020 | 2028;ERROR=2021 | 2022 | 2023 | 2024 | 2025
+ATB_ESCR_CAPTURE;OK=2060 | 2066;ERROR=2061 | 2062 | 2063 | 2064 | 2065 | 2066
+ATB_FEEDER_BP;OK=2200 | 2201 | 2202 | 2203 | 2207;ERROR=2208 | 2204
+// ATB_FEEDER_BP_FIRST;OK=2210 | 2211 | 2212 | 2213 | 2217;ERROR=2218 | 2214
+// ATB_FEEDER_BP_BUSINESS;OK=2220 | 2221 | 2222 | 2223 | 2227;ERROR=2228 | 2224
+// ATB_FEEDER_BP_ECONOMY;OK=2230 | 2231 | 2232 | 2233 | 2237;ERROR=2238 | 2234
+// ATB_FEEDER_TK;OK=2240 | 2241 | 2242 | 2243 | 2247;ERROR=2248 | 2244
+// ATB_FEEDER_GP;OK=2250 | 2251 | 2252 | 2253 | 2257;ERROR=2258 | 2254
+// ATB_PAPER;OK=ATB_FEEDER_BP.OK | ATB_FEEDER_BP_FIRST.OK | ATB_FEEDER_BP_BUSINESS.OK | ATB_FEEDER_BP_ECONOMY.OK | ATB_FEEDER_TK.OK | ATB_FEEDER_GP.OK | ATB_WRITER.OK
+ATB_PAPER;OK=ATB_FEEDER_BP.OK
+ATBHW;OK=100500;ERROR=100501 | 100502 | 100503 | 100504 | 100505 | 100506 | 100531 | 100532
+ATBHW_ESCROW;OK=100400;ERROR=100401 | 100402 | 100403 | 100404 | 100420 | 100421 | 100422
+ATB_POWER;OK=2000 | 100713;ERROR=100712
+ATB_COMP;OK=ATB_READER.OK & ATB_WRITER.OK & ATB_DISPENSER.OK & ATB_PAPER.OK & ATBHW.OK & ATBHW_ESCROW.OK & ATB_POWER.OK & ATB_ESCR_CAPTURE.OK
+
+// BTP_WRITER;OK=3000;ERROR=3001 | 3002 | 3003 | 3004 | 3005 | 3006 | 3012 | 3013
+// BTP_PAPER;OK=3000 | 3100 | 3101 | 3102;ERROR=3103
+// BTPHW;OK=100600;ERROR=100601 | 100602 | 100603 | 100604 | 100605 | 100606
+// BTP_POWER;OK=3000 | 100715;ERROR=100714
+// BTP_COMP;OK=BTP_WRITER.OK & BTP_PAPER.OK & BTPHW.OK & BTP_POWER.OK
+
+// CON;OK=9000;ERROR=9002 | 9003 | 9004 | 9005 | 9006 | 9011
+// CONHW;OK=100015 | 9000;ERROR=100001 | 100002 | 100013 | 100014
+// CONHW_SCN;OK=100100 | 9000;ERROR=100101 | 100102 | 100103
+// CONHW_SPS;OK=100200 | 9000;ERROR=100201 | 100202 | 100203
+// CONHW_SCL;OK=100300 | 9000;ERROR=100301 | 100302 | 100303
+// CON_COMP;OK=CON.OK & CONHW.OK & CONHW_SCN.OK & CONHW_SPS.OK & CONHW_SCL.OK
+
+// MPR_READER;OK=8000;ERROR=8001 | 8002 | 8003 | 8004 | 8005 | 8006 | 8012
+// MPR_COMP;OK=MPR_READER.OK
+
+SEL;OK=100718;ERROR=100719 | 100711
+DOOR;CLOSED=100702;OPEN=100701
+
+// <<< component configuration: please uncomment the one component configuration in use
+
+// Baggage handling without MPR
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & BTP_COMP.OK & CON_COMP.OK
+
+// Baggage Handling
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & BTP_COMP.OK & CON_COMP.OK & MPR_COMP.OK
+
+// Without Baggage Handling without MPR
+COMPS;OK=CRD_COMP.OK & ATB_COMP.OK
+
+// Without Baggage Handling
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & MPR_COMP.OK
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+KIOSK_SEL;OK=DOOR.CLOSED & SEL.OK;SERVICE=DOOR.OPEN & SEL.OK
+KIOSK_SVCAPP;INACTIVE=11001 | 11003 | 11004 | 11005 | 11006 | 11007 | 11008 | 11009 | 11010;ACTIVE=11002 | 11011
+KIOSK;OPERATION=KIOSK_SEL.OK & KIOSK_SVCAPP.INACTIVE;UNDER_SERVICE=KIOSK_SEL.SERVICE | KIOSK_SVCAPP.ACTIVE
+
+CLA;AVAILABLE=10001 | 10002 | 10003 | 10004 | 10005;UNAVAILABLE=10000 | 10006 | 10007 | 10008 | 10011
+
+SVC;AVAILABLE=11001 | 11002 | 11003 | 11004 | 11005;UNAVAILABLE=11000 | 11006 | 11007 | 11008 | 11010
+
+
+
+// <<< Application section: please uncomment the installed applications
+
+// AL_DLH;AVAILABLE=12001 | 12002 | 12003 | 12004 | 12005;UNAVAILABLE=12000 | 12006 | 12007 | 12008 | 12010 | 12011 | 12012
+// APP_DLH;AVAILABLE=AL_DLH.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_DLH_BAG;AVAILABLE=APP_DLH.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+AL_AUA;AVAILABLE=14001 | 14002 | 14003 | 14004 | 14005;UNAVAILABLE=14000 | 14006 | 14007 | 14008 | 14010 | 14011 | 14012
+APP_AUA;AVAILABLE=AL_AUA.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_AUA_BAG;AVAILABLE=APP_AUA.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// AL_KLM;AVAILABLE=16001 | 16002 | 16003 | 16004 | 16005;UNAVAILABLE=16000 | 16006 | 16007 | 16008 | 16010 | 16011 | 16012
+// APP_KLM;AVAILABLE=AL_AUA.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_KLM_BAG;AVAILABLE=APP_AUA.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// AL_BER;AVAILABLE=19001 | 19002 | 19003 | 19004 | 19005;UNAVAILABLE=19000 | 19006 | 19007 | 19008 | 19010 | 19011 | 19012
+// APP_BER;AVAILABLE=AL_BER.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_BER_BAG;AVAILABLE=APP_BER.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// AL_IB;AVAILABLE=21001 | 21002 | 21003 | 21004 | 21005;UNAVAILABLE=21000 | 21006 | 21007 | 21008 | 21010 | 21011 | 21012
+// APP_IB;AVAILABLE=AL_IB.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_IB_BAG;AVAILABLE=APP_IB.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+
+// <<< System section: please uncomment the one kiosk configuration in use
+
+// AUA + DLH (Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB (Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE & APP_IB_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA (Baggage Handling)
+// SYSTEM;ALL_OK=APP_AUA_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_AUA.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA
+SYSTEM;ALL_OK=APP_AUA.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB + BER + KLM(Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE & APP_IB_BAG.AVAILABLE & APP_BER_BAG.AVAILABLE & APP_KLM_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB + BER + KLM
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + IB + KLM
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + BER + KLM
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
diff --git a/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_(BAG).txt b/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_(BAG).txt
new file mode 100644
index 00000000..216b6dee
--- /dev/null
+++ b/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_(BAG).txt
@@ -0,0 +1,126 @@
+CRD_READER;OK=1000;ERROR=1001 | 1002 | 1003 | 1004 | 1005
+CRD_DISPENSER;OK=1020;ERROR=1021 | 1022 | 1023 | 1024 | 1025
+CRD_CAPTURE;OK=1030;ERROR=1031 | 1032 | 1033 | 1034 | 1035 | 1036
+CRD_POWER;OK=1000 | 100717;ERROR=100716
+CRD_COMP;OK=CRD_READER.OK & CRD_DISPENSER.OK & CRD_CAPTURE.OK & CRD_POWER.OK
+
+ATB_READER;OK=2000;ERROR=2001 | 2002 | 2003 | 2004 | 2005
+ATB_WRITER;OK=2010;ERROR=2011 | 2012 | 2013 | 2014 | 2015
+ATB_DISPENSER;OK=2020 | 2028;ERROR=2021 | 2022 | 2023 | 2024 | 2025
+ATB_ESCR_CAPTURE;OK=2060 | 2066;ERROR=2061 | 2062 | 2063 | 2064 | 2065 | 2066
+ATB_FEEDER_BP;OK=2200 | 2201 | 2202 | 2203 | 2207;ERROR=2208 | 2204
+// ATB_FEEDER_BP_FIRST;OK=2210 | 2211 | 2212 | 2213 | 2217;ERROR=2218 | 2214
+// ATB_FEEDER_BP_BUSINESS;OK=2220 | 2221 | 2222 | 2223 | 2227;ERROR=2228 | 2224
+// ATB_FEEDER_BP_ECONOMY;OK=2230 | 2231 | 2232 | 2233 | 2237;ERROR=2238 | 2234
+// ATB_FEEDER_TK;OK=2240 | 2241 | 2242 | 2243 | 2247;ERROR=2248 | 2244
+// ATB_FEEDER_GP;OK=2250 | 2251 | 2252 | 2253 | 2257;ERROR=2258 | 2254
+// ATB_PAPER;OK=ATB_FEEDER_BP.OK | ATB_FEEDER_BP_FIRST.OK | ATB_FEEDER_BP_BUSINESS.OK | ATB_FEEDER_BP_ECONOMY.OK | ATB_FEEDER_TK.OK | ATB_FEEDER_GP.OK | ATB_WRITER.OK
+ATB_PAPER;OK=ATB_FEEDER_BP.OK
+ATBHW;OK=100500;ERROR=100501 | 100502 | 100503 | 100504 | 100505 | 100506 | 100531 | 100532
+ATBHW_ESCROW;OK=100400;ERROR=100401 | 100402 | 100403 | 100404 | 100420 | 100421 | 100422
+ATB_POWER;OK=2000 | 100713;ERROR=100712
+ATB_COMP;OK=ATB_READER.OK & ATB_WRITER.OK & ATB_DISPENSER.OK & ATB_PAPER.OK & ATBHW.OK & ATBHW_ESCROW.OK & ATB_POWER.OK & ATB_ESCR_CAPTURE.OK
+
+BTP_WRITER;OK=3000;ERROR=3001 | 3002 | 3003 | 3004 | 3005 | 3006 | 3012 | 3013
+BTP_PAPER;OK=3000 | 3100 | 3101 | 3102;ERROR=3103
+BTPHW;OK=100600;ERROR=100601 | 100602 | 100603 | 100604 | 100605 | 100606
+BTP_POWER;OK=3000 | 100715;ERROR=100714
+BTP_COMP;OK=BTP_WRITER.OK & BTP_PAPER.OK & BTPHW.OK & BTP_POWER.OK
+
+CON;OK=9000;ERROR=9002 | 9003 | 9004 | 9005 | 9006 | 9011
+CONHW;OK=100015 | 9000;ERROR=100001 | 100002 | 100013 | 100014
+CONHW_SCN;OK=100100 | 9000;ERROR=100101 | 100102 | 100103
+CONHW_SPS;OK=100200 | 9000;ERROR=100201 | 100202 | 100203
+CONHW_SCL;OK=100300 | 9000;ERROR=100301 | 100302 | 100303
+CON_COMP;OK=CON.OK & CONHW.OK & CONHW_SCN.OK & CONHW_SPS.OK & CONHW_SCL.OK
+
+// MPR_READER;OK=8000;ERROR=8001 | 8002 | 8003 | 8004 | 8005 | 8006 | 8012
+// MPR_COMP;OK=MPR_READER.OK
+
+SEL;OK=100718;ERROR=100719 | 100711
+DOOR;CLOSED=100702;OPEN=100701
+
+// <<< component configuration: please uncomment the one component configuration in use
+
+// Baggage handling without MPR
+COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & BTP_COMP.OK & CON_COMP.OK
+
+// Baggage Handling
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & BTP_COMP.OK & CON_COMP.OK & MPR_COMP.OK
+
+// Without Baggage Handling without MPR
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK
+
+// Without Baggage Handling
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & MPR_COMP.OK
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+KIOSK_SEL;OK=DOOR.CLOSED & SEL.OK;SERVICE=DOOR.OPEN & SEL.OK
+KIOSK_SVCAPP;INACTIVE=11001 | 11003 | 11004 | 11005 | 11006 | 11007 | 11008 | 11009 | 11010;ACTIVE=11002 | 11011
+KIOSK;OPERATION=KIOSK_SEL.OK & KIOSK_SVCAPP.INACTIVE;UNDER_SERVICE=KIOSK_SEL.SERVICE | KIOSK_SVCAPP.ACTIVE
+
+CLA;AVAILABLE=10001 | 10002 | 10003 | 10004 | 10005;UNAVAILABLE=10000 | 10006 | 10007 | 10008 | 10011
+
+SVC;AVAILABLE=11001 | 11002 | 11003 | 11004 | 11005;UNAVAILABLE=11000 | 11006 | 11007 | 11008 | 11010
+
+
+
+// <<< Application section: please uncomment the installed applications
+
+// AL_DLH;AVAILABLE=12001 | 12002 | 12003 | 12004 | 12005;UNAVAILABLE=12000 | 12006 | 12007 | 12008 | 12010 | 12011 | 12012
+// APP_DLH;AVAILABLE=AL_DLH.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_DLH_BAG;AVAILABLE=APP_DLH.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+AL_AUA;AVAILABLE=14001 | 14002 | 14003 | 14004 | 14005;UNAVAILABLE=14000 | 14006 | 14007 | 14008 | 14010 | 14011 | 14012
+APP_AUA;AVAILABLE=AL_AUA.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+APP_AUA_BAG;AVAILABLE=APP_AUA.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// AL_KLM;AVAILABLE=16001 | 16002 | 16003 | 16004 | 16005;UNAVAILABLE=16000 | 16006 | 16007 | 16008 | 16010 | 16011 | 16012
+// APP_KLM;AVAILABLE=AL_AUA.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_KLM_BAG;AVAILABLE=APP_AUA.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// AL_BER;AVAILABLE=19001 | 19002 | 19003 | 19004 | 19005;UNAVAILABLE=19000 | 19006 | 19007 | 19008 | 19010 | 19011 | 19012
+// APP_BER;AVAILABLE=AL_BER.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_BER_BAG;AVAILABLE=APP_BER.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// AL_IB;AVAILABLE=21001 | 21002 | 21003 | 21004 | 21005;UNAVAILABLE=21000 | 21006 | 21007 | 21008 | 21010 | 21011 | 21012
+// APP_IB;AVAILABLE=AL_IB.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_IB_BAG;AVAILABLE=APP_IB.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+
+// <<< System section: please uncomment the one kiosk configuration in use
+
+// AUA + DLH (Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB (Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE & APP_IB_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA (Baggage Handling)
+SYSTEM;ALL_OK=APP_AUA_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_AUA.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB + BER + KLM(Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE & APP_IB_BAG.AVAILABLE & APP_BER_BAG.AVAILABLE & APP_KLM_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB + BER + KLM
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + IB + KLM
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + BER + KLM
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
diff --git a/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_BER_KLM(NOBAG).txt b/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_BER_KLM(NOBAG).txt
new file mode 100644
index 00000000..fd014db7
--- /dev/null
+++ b/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_BER_KLM(NOBAG).txt
@@ -0,0 +1,126 @@
+CRD_READER;OK=1000;ERROR=1001 | 1002 | 1003 | 1004 | 1005
+CRD_DISPENSER;OK=1020;ERROR=1021 | 1022 | 1023 | 1024 | 1025
+CRD_CAPTURE;OK=1030;ERROR=1031 | 1032 | 1033 | 1034 | 1035 | 1036
+CRD_POWER;OK=1000 | 100717;ERROR=100716
+CRD_COMP;OK=CRD_READER.OK & CRD_DISPENSER.OK & CRD_CAPTURE.OK & CRD_POWER.OK
+
+ATB_READER;OK=2000;ERROR=2001 | 2002 | 2003 | 2004 | 2005
+ATB_WRITER;OK=2010;ERROR=2011 | 2012 | 2013 | 2014 | 2015
+ATB_DISPENSER;OK=2020 | 2028;ERROR=2021 | 2022 | 2023 | 2024 | 2025
+ATB_ESCR_CAPTURE;OK=2060 | 2066;ERROR=2061 | 2062 | 2063 | 2064 | 2065 | 2066
+ATB_FEEDER_BP;OK=2200 | 2201 | 2202 | 2203 | 2207;ERROR=2208 | 2204
+// ATB_FEEDER_BP_FIRST;OK=2210 | 2211 | 2212 | 2213 | 2217;ERROR=2218 | 2214
+// ATB_FEEDER_BP_BUSINESS;OK=2220 | 2221 | 2222 | 2223 | 2227;ERROR=2228 | 2224
+// ATB_FEEDER_BP_ECONOMY;OK=2230 | 2231 | 2232 | 2233 | 2237;ERROR=2238 | 2234
+// ATB_FEEDER_TK;OK=2240 | 2241 | 2242 | 2243 | 2247;ERROR=2248 | 2244
+// ATB_FEEDER_GP;OK=2250 | 2251 | 2252 | 2253 | 2257;ERROR=2258 | 2254
+// ATB_PAPER;OK=ATB_FEEDER_BP.OK | ATB_FEEDER_BP_FIRST.OK | ATB_FEEDER_BP_BUSINESS.OK | ATB_FEEDER_BP_ECONOMY.OK | ATB_FEEDER_TK.OK | ATB_FEEDER_GP.OK | ATB_WRITER.OK
+ATB_PAPER;OK=ATB_FEEDER_BP.OK
+ATBHW;OK=100500;ERROR=100501 | 100502 | 100503 | 100504 | 100505 | 100506 | 100531 | 100532
+ATBHW_ESCROW;OK=100400;ERROR=100401 | 100402 | 100403 | 100404 | 100420 | 100421 | 100422
+ATB_POWER;OK=2000 | 100713;ERROR=100712
+ATB_COMP;OK=ATB_READER.OK & ATB_WRITER.OK & ATB_DISPENSER.OK & ATB_PAPER.OK & ATBHW.OK & ATBHW_ESCROW.OK & ATB_POWER.OK & ATB_ESCR_CAPTURE.OK
+
+// BTP_WRITER;OK=3000;ERROR=3001 | 3002 | 3003 | 3004 | 3005 | 3006 | 3012 | 3013
+// BTP_PAPER;OK=3000 | 3100 | 3101 | 3102;ERROR=3103
+// BTPHW;OK=100600;ERROR=100601 | 100602 | 100603 | 100604 | 100605 | 100606
+// BTP_POWER;OK=3000 | 100715;ERROR=100714
+// BTP_COMP;OK=BTP_WRITER.OK & BTP_PAPER.OK & BTPHW.OK & BTP_POWER.OK
+
+// CON;OK=9000;ERROR=9002 | 9003 | 9004 | 9005 | 9006 | 9011
+// CONHW;OK=100015 | 9000;ERROR=100001 | 100002 | 100013 | 100014
+// CONHW_SCN;OK=100100 | 9000;ERROR=100101 | 100102 | 100103
+// CONHW_SPS;OK=100200 | 9000;ERROR=100201 | 100202 | 100203
+// CONHW_SCL;OK=100300 | 9000;ERROR=100301 | 100302 | 100303
+// CON_COMP;OK=CON.OK & CONHW.OK & CONHW_SCN.OK & CONHW_SPS.OK & CONHW_SCL.OK
+
+// MPR_READER;OK=8000;ERROR=8001 | 8002 | 8003 | 8004 | 8005 | 8006 | 8012
+// MPR_COMP;OK=MPR_READER.OK
+
+SEL;OK=100718;ERROR=100719 | 100711
+DOOR;CLOSED=100702;OPEN=100701
+
+// <<< component configuration: please uncomment the one component configuration in use
+
+// Baggage handling without MPR
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & BTP_COMP.OK & CON_COMP.OK
+
+// Baggage Handling
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & BTP_COMP.OK & CON_COMP.OK & MPR_COMP.OK
+
+// Without Baggage Handling without MPR
+COMPS;OK=CRD_COMP.OK & ATB_COMP.OK
+
+// Without Baggage Handling
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & MPR_COMP.OK
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+KIOSK_SEL;OK=DOOR.CLOSED & SEL.OK;SERVICE=DOOR.OPEN & SEL.OK
+KIOSK_SVCAPP;INACTIVE=11001 | 11003 | 11004 | 11005 | 11006 | 11007 | 11008 | 11009 | 11010;ACTIVE=11002 | 11011
+KIOSK;OPERATION=KIOSK_SEL.OK & KIOSK_SVCAPP.INACTIVE;UNDER_SERVICE=KIOSK_SEL.SERVICE | KIOSK_SVCAPP.ACTIVE
+
+CLA;AVAILABLE=10001 | 10002 | 10003 | 10004 | 10005;UNAVAILABLE=10000 | 10006 | 10007 | 10008 | 10011
+
+SVC;AVAILABLE=11001 | 11002 | 11003 | 11004 | 11005;UNAVAILABLE=11000 | 11006 | 11007 | 11008 | 11010
+
+
+
+// <<< Application section: please uncomment the installed applications
+
+// AL_DLH;AVAILABLE=12001 | 12002 | 12003 | 12004 | 12005;UNAVAILABLE=12000 | 12006 | 12007 | 12008 | 12010 | 12011 | 12012
+// APP_DLH;AVAILABLE=AL_DLH.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_DLH_BAG;AVAILABLE=APP_DLH.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+AL_AUA;AVAILABLE=14001 | 14002 | 14003 | 14004 | 14005;UNAVAILABLE=14000 | 14006 | 14007 | 14008 | 14010 | 14011 | 14012
+APP_AUA;AVAILABLE=AL_AUA.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_AUA_BAG;AVAILABLE=APP_AUA.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+AL_KLM;AVAILABLE=16001 | 16002 | 16003 | 16004 | 16005;UNAVAILABLE=16000 | 16006 | 16007 | 16008 | 16010 | 16011 | 16012
+APP_KLM;AVAILABLE=AL_AUA.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_KLM_BAG;AVAILABLE=APP_AUA.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+AL_BER;AVAILABLE=19001 | 19002 | 19003 | 19004 | 19005;UNAVAILABLE=19000 | 19006 | 19007 | 19008 | 19010 | 19011 | 19012
+APP_BER;AVAILABLE=AL_BER.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_BER_BAG;AVAILABLE=APP_BER.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// AL_IB;AVAILABLE=21001 | 21002 | 21003 | 21004 | 21005;UNAVAILABLE=21000 | 21006 | 21007 | 21008 | 21010 | 21011 | 21012
+// APP_IB;AVAILABLE=AL_IB.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_IB_BAG;AVAILABLE=APP_IB.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+
+// <<< System section: please uncomment the one kiosk configuration in use
+
+// AUA + DLH (Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB (Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE & APP_IB_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA (Baggage Handling)
+// SYSTEM;ALL_OK=APP_AUA_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_AUA.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB + BER + KLM(Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE & APP_IB_BAG.AVAILABLE & APP_BER_BAG.AVAILABLE & APP_KLM_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB + BER + KLM
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + IB + KLM
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + BER + KLM
+SYSTEM;ALL_OK=APP_AUA.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
diff --git a/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_DLH_(BAG).txt b/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_DLH_(BAG).txt
new file mode 100644
index 00000000..2cfe6dae
--- /dev/null
+++ b/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_DLH_(BAG).txt
@@ -0,0 +1,126 @@
+CRD_READER;OK=1000;ERROR=1001 | 1002 | 1003 | 1004 | 1005
+CRD_DISPENSER;OK=1020;ERROR=1021 | 1022 | 1023 | 1024 | 1025
+CRD_CAPTURE;OK=1030;ERROR=1031 | 1032 | 1033 | 1034 | 1035 | 1036
+CRD_POWER;OK=1000 | 100717;ERROR=100716
+CRD_COMP;OK=CRD_READER.OK & CRD_DISPENSER.OK & CRD_CAPTURE.OK & CRD_POWER.OK
+
+ATB_READER;OK=2000;ERROR=2001 | 2002 | 2003 | 2004 | 2005
+ATB_WRITER;OK=2010;ERROR=2011 | 2012 | 2013 | 2014 | 2015
+ATB_DISPENSER;OK=2020 | 2028;ERROR=2021 | 2022 | 2023 | 2024 | 2025
+ATB_ESCR_CAPTURE;OK=2060 | 2066;ERROR=2061 | 2062 | 2063 | 2064 | 2065 | 2066
+ATB_FEEDER_BP;OK=2200 | 2201 | 2202 | 2203 | 2207;ERROR=2208 | 2204
+// ATB_FEEDER_BP_FIRST;OK=2210 | 2211 | 2212 | 2213 | 2217;ERROR=2218 | 2214
+// ATB_FEEDER_BP_BUSINESS;OK=2220 | 2221 | 2222 | 2223 | 2227;ERROR=2228 | 2224
+// ATB_FEEDER_BP_ECONOMY;OK=2230 | 2231 | 2232 | 2233 | 2237;ERROR=2238 | 2234
+// ATB_FEEDER_TK;OK=2240 | 2241 | 2242 | 2243 | 2247;ERROR=2248 | 2244
+// ATB_FEEDER_GP;OK=2250 | 2251 | 2252 | 2253 | 2257;ERROR=2258 | 2254
+// ATB_PAPER;OK=ATB_FEEDER_BP.OK | ATB_FEEDER_BP_FIRST.OK | ATB_FEEDER_BP_BUSINESS.OK | ATB_FEEDER_BP_ECONOMY.OK | ATB_FEEDER_TK.OK | ATB_FEEDER_GP.OK | ATB_WRITER.OK
+ATB_PAPER;OK=ATB_FEEDER_BP.OK
+ATBHW;OK=100500;ERROR=100501 | 100502 | 100503 | 100504 | 100505 | 100506 | 100531 | 100532
+ATBHW_ESCROW;OK=100400;ERROR=100401 | 100402 | 100403 | 100404 | 100420 | 100421 | 100422
+ATB_POWER;OK=2000 | 100713;ERROR=100712
+ATB_COMP;OK=ATB_READER.OK & ATB_WRITER.OK & ATB_DISPENSER.OK & ATB_PAPER.OK & ATBHW.OK & ATBHW_ESCROW.OK & ATB_POWER.OK & ATB_ESCR_CAPTURE.OK
+
+BTP_WRITER;OK=3000;ERROR=3001 | 3002 | 3003 | 3004 | 3005 | 3006 | 3012 | 3013
+BTP_PAPER;OK=3000 | 3100 | 3101 | 3102;ERROR=3103
+BTPHW;OK=100600;ERROR=100601 | 100602 | 100603 | 100604 | 100605 | 100606
+BTP_POWER;OK=3000 | 100715;ERROR=100714
+BTP_COMP;OK=BTP_WRITER.OK & BTP_PAPER.OK & BTPHW.OK & BTP_POWER.OK
+
+CON;OK=9000;ERROR=9002 | 9003 | 9004 | 9005 | 9006 | 9011
+CONHW;OK=100015 | 9000;ERROR=100001 | 100002 | 100013 | 100014
+CONHW_SCN;OK=100100 | 9000;ERROR=100101 | 100102 | 100103
+CONHW_SPS;OK=100200 | 9000;ERROR=100201 | 100202 | 100203
+CONHW_SCL;OK=100300 | 9000;ERROR=100301 | 100302 | 100303
+CON_COMP;OK=CON.OK & CONHW.OK & CONHW_SCN.OK & CONHW_SPS.OK & CONHW_SCL.OK
+
+// MPR_READER;OK=8000;ERROR=8001 | 8002 | 8003 | 8004 | 8005 | 8006 | 8012
+// MPR_COMP;OK=MPR_READER.OK
+
+SEL;OK=100718;ERROR=100719 | 100711
+DOOR;CLOSED=100702;OPEN=100701
+
+// <<< component configuration: please uncomment the one component configuration in use
+
+// Baggage handling without MPR
+COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & BTP_COMP.OK & CON_COMP.OK
+
+// Baggage Handling
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & BTP_COMP.OK & CON_COMP.OK & MPR_COMP.OK
+
+// Without Baggage Handling without MPR
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK
+
+// Without Baggage Handling
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & MPR_COMP.OK
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+KIOSK_SEL;OK=DOOR.CLOSED & SEL.OK;SERVICE=DOOR.OPEN & SEL.OK
+KIOSK_SVCAPP;INACTIVE=11001 | 11003 | 11004 | 11005 | 11006 | 11007 | 11008 | 11009 | 11010;ACTIVE=11002 | 11011
+KIOSK;OPERATION=KIOSK_SEL.OK & KIOSK_SVCAPP.INACTIVE;UNDER_SERVICE=KIOSK_SEL.SERVICE | KIOSK_SVCAPP.ACTIVE
+
+CLA;AVAILABLE=10001 | 10002 | 10003 | 10004 | 10005;UNAVAILABLE=10000 | 10006 | 10007 | 10008 | 10011
+
+SVC;AVAILABLE=11001 | 11002 | 11003 | 11004 | 11005;UNAVAILABLE=11000 | 11006 | 11007 | 11008 | 11010
+
+
+
+// <<< Application section: please uncomment the installed applications
+
+AL_DLH;AVAILABLE=12001 | 12002 | 12003 | 12004 | 12005;UNAVAILABLE=12000 | 12006 | 12007 | 12008 | 12010 | 12011 | 12012
+APP_DLH;AVAILABLE=AL_DLH.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+APP_DLH_BAG;AVAILABLE=APP_DLH.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+AL_AUA;AVAILABLE=14001 | 14002 | 14003 | 14004 | 14005;UNAVAILABLE=14000 | 14006 | 14007 | 14008 | 14010 | 14011 | 14012
+APP_AUA;AVAILABLE=AL_AUA.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+APP_AUA_BAG;AVAILABLE=APP_AUA.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// AL_KLM;AVAILABLE=16001 | 16002 | 16003 | 16004 | 16005;UNAVAILABLE=16000 | 16006 | 16007 | 16008 | 16010 | 16011 | 16012
+// APP_KLM;AVAILABLE=AL_AUA.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_KLM_BAG;AVAILABLE=APP_AUA.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// AL_BER;AVAILABLE=19001 | 19002 | 19003 | 19004 | 19005;UNAVAILABLE=19000 | 19006 | 19007 | 19008 | 19010 | 19011 | 19012
+// APP_BER;AVAILABLE=AL_BER.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_BER_BAG;AVAILABLE=APP_BER.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// AL_IB;AVAILABLE=21001 | 21002 | 21003 | 21004 | 21005;UNAVAILABLE=21000 | 21006 | 21007 | 21008 | 21010 | 21011 | 21012
+// APP_IB;AVAILABLE=AL_IB.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_IB_BAG;AVAILABLE=APP_IB.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+
+// <<< System section: please uncomment the one kiosk configuration in use
+
+// AUA + DLH (Baggage Handling)
+SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB (Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE & APP_IB_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA (Baggage Handling)
+// SYSTEM;ALL_OK=APP_AUA_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_AUA.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB + BER + KLM(Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE & APP_IB_BAG.AVAILABLE & APP_BER_BAG.AVAILABLE & APP_KLM_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB + BER + KLM
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + IB + KLM
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + BER + KLM
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
diff --git a/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_DLH_(NOBAG).txt b/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_DLH_(NOBAG).txt
new file mode 100644
index 00000000..16a27630
--- /dev/null
+++ b/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_DLH_(NOBAG).txt
@@ -0,0 +1,126 @@
+CRD_READER;OK=1000;ERROR=1001 | 1002 | 1003 | 1004 | 1005
+CRD_DISPENSER;OK=1020;ERROR=1021 | 1022 | 1023 | 1024 | 1025
+CRD_CAPTURE;OK=1030;ERROR=1031 | 1032 | 1033 | 1034 | 1035 | 1036
+CRD_POWER;OK=1000 | 100717;ERROR=100716
+CRD_COMP;OK=CRD_READER.OK & CRD_DISPENSER.OK & CRD_CAPTURE.OK & CRD_POWER.OK
+
+ATB_READER;OK=2000;ERROR=2001 | 2002 | 2003 | 2004 | 2005
+ATB_WRITER;OK=2010;ERROR=2011 | 2012 | 2013 | 2014 | 2015
+ATB_DISPENSER;OK=2020 | 2028;ERROR=2021 | 2022 | 2023 | 2024 | 2025
+ATB_ESCR_CAPTURE;OK=2060 | 2066;ERROR=2061 | 2062 | 2063 | 2064 | 2065 | 2066
+ATB_FEEDER_BP;OK=2200 | 2201 | 2202 | 2203 | 2207;ERROR=2208 | 2204
+// ATB_FEEDER_BP_FIRST;OK=2210 | 2211 | 2212 | 2213 | 2217;ERROR=2218 | 2214
+// ATB_FEEDER_BP_BUSINESS;OK=2220 | 2221 | 2222 | 2223 | 2227;ERROR=2228 | 2224
+// ATB_FEEDER_BP_ECONOMY;OK=2230 | 2231 | 2232 | 2233 | 2237;ERROR=2238 | 2234
+// ATB_FEEDER_TK;OK=2240 | 2241 | 2242 | 2243 | 2247;ERROR=2248 | 2244
+// ATB_FEEDER_GP;OK=2250 | 2251 | 2252 | 2253 | 2257;ERROR=2258 | 2254
+// ATB_PAPER;OK=ATB_FEEDER_BP.OK | ATB_FEEDER_BP_FIRST.OK | ATB_FEEDER_BP_BUSINESS.OK | ATB_FEEDER_BP_ECONOMY.OK | ATB_FEEDER_TK.OK | ATB_FEEDER_GP.OK | ATB_WRITER.OK
+ATB_PAPER;OK=ATB_FEEDER_BP.OK
+ATBHW;OK=100500;ERROR=100501 | 100502 | 100503 | 100504 | 100505 | 100506 | 100531 | 100532
+ATBHW_ESCROW;OK=100400;ERROR=100401 | 100402 | 100403 | 100404 | 100420 | 100421 | 100422
+ATB_POWER;OK=2000 | 100713;ERROR=100712
+ATB_COMP;OK=ATB_READER.OK & ATB_WRITER.OK & ATB_DISPENSER.OK & ATB_PAPER.OK & ATBHW.OK & ATBHW_ESCROW.OK & ATB_POWER.OK & ATB_ESCR_CAPTURE.OK
+
+// BTP_WRITER;OK=3000;ERROR=3001 | 3002 | 3003 | 3004 | 3005 | 3006 | 3012 | 3013
+// BTP_PAPER;OK=3000 | 3100 | 3101 | 3102;ERROR=3103
+// BTPHW;OK=100600;ERROR=100601 | 100602 | 100603 | 100604 | 100605 | 100606
+// BTP_POWER;OK=3000 | 100715;ERROR=100714
+// BTP_COMP;OK=BTP_WRITER.OK & BTP_PAPER.OK & BTPHW.OK & BTP_POWER.OK
+
+// CON;OK=9000;ERROR=9002 | 9003 | 9004 | 9005 | 9006 | 9011
+// CONHW;OK=100015 | 9000;ERROR=100001 | 100002 | 100013 | 100014
+// CONHW_SCN;OK=100100 | 9000;ERROR=100101 | 100102 | 100103
+// CONHW_SPS;OK=100200 | 9000;ERROR=100201 | 100202 | 100203
+// CONHW_SCL;OK=100300 | 9000;ERROR=100301 | 100302 | 100303
+// CON_COMP;OK=CON.OK & CONHW.OK & CONHW_SCN.OK & CONHW_SPS.OK & CONHW_SCL.OK
+
+// MPR_READER;OK=8000;ERROR=8001 | 8002 | 8003 | 8004 | 8005 | 8006 | 8012
+// MPR_COMP;OK=MPR_READER.OK
+
+SEL;OK=100718;ERROR=100719 | 100711
+DOOR;CLOSED=100702;OPEN=100701
+
+// <<< component configuration: please uncomment the one component configuration in use
+
+// Baggage handling without MPR
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & BTP_COMP.OK & CON_COMP.OK
+
+// Baggage Handling
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & BTP_COMP.OK & CON_COMP.OK & MPR_COMP.OK
+
+// Without Baggage Handling without MPR
+COMPS;OK=CRD_COMP.OK & ATB_COMP.OK
+
+// Without Baggage Handling
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & MPR_COMP.OK
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+KIOSK_SEL;OK=DOOR.CLOSED & SEL.OK;SERVICE=DOOR.OPEN & SEL.OK
+KIOSK_SVCAPP;INACTIVE=11001 | 11003 | 11004 | 11005 | 11006 | 11007 | 11008 | 11009 | 11010;ACTIVE=11002 | 11011
+KIOSK;OPERATION=KIOSK_SEL.OK & KIOSK_SVCAPP.INACTIVE;UNDER_SERVICE=KIOSK_SEL.SERVICE | KIOSK_SVCAPP.ACTIVE
+
+CLA;AVAILABLE=10001 | 10002 | 10003 | 10004 | 10005;UNAVAILABLE=10000 | 10006 | 10007 | 10008 | 10011
+
+SVC;AVAILABLE=11001 | 11002 | 11003 | 11004 | 11005;UNAVAILABLE=11000 | 11006 | 11007 | 11008 | 11010
+
+
+
+// <<< Application section: please uncomment the installed applications
+
+AL_DLH;AVAILABLE=12001 | 12002 | 12003 | 12004 | 12005;UNAVAILABLE=12000 | 12006 | 12007 | 12008 | 12010 | 12011 | 12012
+APP_DLH;AVAILABLE=AL_DLH.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_DLH_BAG;AVAILABLE=APP_DLH.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+AL_AUA;AVAILABLE=14001 | 14002 | 14003 | 14004 | 14005;UNAVAILABLE=14000 | 14006 | 14007 | 14008 | 14010 | 14011 | 14012
+APP_AUA;AVAILABLE=AL_AUA.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_AUA_BAG;AVAILABLE=APP_AUA.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// AL_KLM;AVAILABLE=16001 | 16002 | 16003 | 16004 | 16005;UNAVAILABLE=16000 | 16006 | 16007 | 16008 | 16010 | 16011 | 16012
+// APP_KLM;AVAILABLE=AL_AUA.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_KLM_BAG;AVAILABLE=APP_AUA.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// AL_BER;AVAILABLE=19001 | 19002 | 19003 | 19004 | 19005;UNAVAILABLE=19000 | 19006 | 19007 | 19008 | 19010 | 19011 | 19012
+// APP_BER;AVAILABLE=AL_BER.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_BER_BAG;AVAILABLE=APP_BER.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// AL_IB;AVAILABLE=21001 | 21002 | 21003 | 21004 | 21005;UNAVAILABLE=21000 | 21006 | 21007 | 21008 | 21010 | 21011 | 21012
+// APP_IB;AVAILABLE=AL_IB.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_IB_BAG;AVAILABLE=APP_IB.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+
+// <<< System section: please uncomment the one kiosk configuration in use
+
+// AUA + DLH (Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH
+SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB (Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE & APP_IB_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA (Baggage Handling)
+// SYSTEM;ALL_OK=APP_AUA_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_AUA.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB + BER + KLM(Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE & APP_IB_BAG.AVAILABLE & APP_BER_BAG.AVAILABLE & APP_KLM_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB + BER + KLM
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + IB + KLM
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + BER + KLM
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
diff --git a/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_DLH_IB_(BAG).txt b/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_DLH_IB_(BAG).txt
new file mode 100644
index 00000000..f3fcec6f
--- /dev/null
+++ b/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_DLH_IB_(BAG).txt
@@ -0,0 +1,126 @@
+CRD_READER;OK=1000;ERROR=1001 | 1002 | 1003 | 1004 | 1005
+CRD_DISPENSER;OK=1020;ERROR=1021 | 1022 | 1023 | 1024 | 1025
+CRD_CAPTURE;OK=1030;ERROR=1031 | 1032 | 1033 | 1034 | 1035 | 1036
+CRD_POWER;OK=1000 | 100717;ERROR=100716
+CRD_COMP;OK=CRD_READER.OK & CRD_DISPENSER.OK & CRD_CAPTURE.OK & CRD_POWER.OK
+
+ATB_READER;OK=2000;ERROR=2001 | 2002 | 2003 | 2004 | 2005
+ATB_WRITER;OK=2010;ERROR=2011 | 2012 | 2013 | 2014 | 2015
+ATB_DISPENSER;OK=2020 | 2028;ERROR=2021 | 2022 | 2023 | 2024 | 2025
+ATB_ESCR_CAPTURE;OK=2060 | 2066;ERROR=2061 | 2062 | 2063 | 2064 | 2065 | 2066
+ATB_FEEDER_BP;OK=2200 | 2201 | 2202 | 2203 | 2207;ERROR=2208 | 2204
+// ATB_FEEDER_BP_FIRST;OK=2210 | 2211 | 2212 | 2213 | 2217;ERROR=2218 | 2214
+// ATB_FEEDER_BP_BUSINESS;OK=2220 | 2221 | 2222 | 2223 | 2227;ERROR=2228 | 2224
+// ATB_FEEDER_BP_ECONOMY;OK=2230 | 2231 | 2232 | 2233 | 2237;ERROR=2238 | 2234
+// ATB_FEEDER_TK;OK=2240 | 2241 | 2242 | 2243 | 2247;ERROR=2248 | 2244
+// ATB_FEEDER_GP;OK=2250 | 2251 | 2252 | 2253 | 2257;ERROR=2258 | 2254
+// ATB_PAPER;OK=ATB_FEEDER_BP.OK | ATB_FEEDER_BP_FIRST.OK | ATB_FEEDER_BP_BUSINESS.OK | ATB_FEEDER_BP_ECONOMY.OK | ATB_FEEDER_TK.OK | ATB_FEEDER_GP.OK | ATB_WRITER.OK
+ATB_PAPER;OK=ATB_FEEDER_BP.OK
+ATBHW;OK=100500;ERROR=100501 | 100502 | 100503 | 100504 | 100505 | 100506 | 100531 | 100532
+ATBHW_ESCROW;OK=100400;ERROR=100401 | 100402 | 100403 | 100404 | 100420 | 100421 | 100422
+ATB_POWER;OK=2000 | 100713;ERROR=100712
+ATB_COMP;OK=ATB_READER.OK & ATB_WRITER.OK & ATB_DISPENSER.OK & ATB_PAPER.OK & ATBHW.OK & ATBHW_ESCROW.OK & ATB_POWER.OK & ATB_ESCR_CAPTURE.OK
+
+BTP_WRITER;OK=3000;ERROR=3001 | 3002 | 3003 | 3004 | 3005 | 3006 | 3012 | 3013
+BTP_PAPER;OK=3000 | 3100 | 3101 | 3102;ERROR=3103
+BTPHW;OK=100600;ERROR=100601 | 100602 | 100603 | 100604 | 100605 | 100606
+BTP_POWER;OK=3000 | 100715;ERROR=100714
+BTP_COMP;OK=BTP_WRITER.OK & BTP_PAPER.OK & BTPHW.OK & BTP_POWER.OK
+
+CON;OK=9000;ERROR=9002 | 9003 | 9004 | 9005 | 9006 | 9011
+CONHW;OK=100015 | 9000;ERROR=100001 | 100002 | 100013 | 100014
+CONHW_SCN;OK=100100 | 9000;ERROR=100101 | 100102 | 100103
+CONHW_SPS;OK=100200 | 9000;ERROR=100201 | 100202 | 100203
+CONHW_SCL;OK=100300 | 9000;ERROR=100301 | 100302 | 100303
+CON_COMP;OK=CON.OK & CONHW.OK & CONHW_SCN.OK & CONHW_SPS.OK & CONHW_SCL.OK
+
+// MPR_READER;OK=8000;ERROR=8001 | 8002 | 8003 | 8004 | 8005 | 8006 | 8012
+// MPR_COMP;OK=MPR_READER.OK
+
+SEL;OK=100718;ERROR=100719 | 100711
+DOOR;CLOSED=100702;OPEN=100701
+
+// <<< component configuration: please uncomment the one component configuration in use
+
+// Baggage handling without MPR
+COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & BTP_COMP.OK & CON_COMP.OK
+
+// Baggage Handling
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & BTP_COMP.OK & CON_COMP.OK & MPR_COMP.OK
+
+// Without Baggage Handling without MPR
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK
+
+// Without Baggage Handling
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & MPR_COMP.OK
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+KIOSK_SEL;OK=DOOR.CLOSED & SEL.OK;SERVICE=DOOR.OPEN & SEL.OK
+KIOSK_SVCAPP;INACTIVE=11001 | 11003 | 11004 | 11005 | 11006 | 11007 | 11008 | 11009 | 11010;ACTIVE=11002 | 11011
+KIOSK;OPERATION=KIOSK_SEL.OK & KIOSK_SVCAPP.INACTIVE;UNDER_SERVICE=KIOSK_SEL.SERVICE | KIOSK_SVCAPP.ACTIVE
+
+CLA;AVAILABLE=10001 | 10002 | 10003 | 10004 | 10005;UNAVAILABLE=10000 | 10006 | 10007 | 10008 | 10011
+
+SVC;AVAILABLE=11001 | 11002 | 11003 | 11004 | 11005;UNAVAILABLE=11000 | 11006 | 11007 | 11008 | 11010
+
+
+
+// <<< Application section: please uncomment the installed applications
+
+AL_DLH;AVAILABLE=12001 | 12002 | 12003 | 12004 | 12005;UNAVAILABLE=12000 | 12006 | 12007 | 12008 | 12010 | 12011 | 12012
+APP_DLH;AVAILABLE=AL_DLH.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+APP_DLH_BAG;AVAILABLE=APP_DLH.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+AL_AUA;AVAILABLE=14001 | 14002 | 14003 | 14004 | 14005;UNAVAILABLE=14000 | 14006 | 14007 | 14008 | 14010 | 14011 | 14012
+APP_AUA;AVAILABLE=AL_AUA.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+APP_AUA_BAG;AVAILABLE=APP_AUA.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// AL_KLM;AVAILABLE=16001 | 16002 | 16003 | 16004 | 16005;UNAVAILABLE=16000 | 16006 | 16007 | 16008 | 16010 | 16011 | 16012
+// APP_KLM;AVAILABLE=AL_AUA.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_KLM_BAG;AVAILABLE=APP_AUA.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// AL_BER;AVAILABLE=19001 | 19002 | 19003 | 19004 | 19005;UNAVAILABLE=19000 | 19006 | 19007 | 19008 | 19010 | 19011 | 19012
+// APP_BER;AVAILABLE=AL_BER.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_BER_BAG;AVAILABLE=APP_BER.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+AL_IB;AVAILABLE=21001 | 21002 | 21003 | 21004 | 21005;UNAVAILABLE=21000 | 21006 | 21007 | 21008 | 21010 | 21011 | 21012
+APP_IB;AVAILABLE=AL_IB.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+APP_IB_BAG;AVAILABLE=APP_IB.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+
+// <<< System section: please uncomment the one kiosk configuration in use
+
+// AUA + DLH (Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB (Baggage Handling)
+SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE & APP_IB_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA (Baggage Handling)
+// SYSTEM;ALL_OK=APP_AUA_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_AUA.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB + BER + KLM(Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE & APP_IB_BAG.AVAILABLE & APP_BER_BAG.AVAILABLE & APP_KLM_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB + BER + KLM
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + IB + KLM
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + BER + KLM
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
diff --git a/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_DLH_IB_(NOBAG).txt b/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_DLH_IB_(NOBAG).txt
new file mode 100644
index 00000000..02d6ff81
--- /dev/null
+++ b/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_DLH_IB_(NOBAG).txt
@@ -0,0 +1,126 @@
+CRD_READER;OK=1000;ERROR=1001 | 1002 | 1003 | 1004 | 1005
+CRD_DISPENSER;OK=1020;ERROR=1021 | 1022 | 1023 | 1024 | 1025
+CRD_CAPTURE;OK=1030;ERROR=1031 | 1032 | 1033 | 1034 | 1035 | 1036
+CRD_POWER;OK=1000 | 100717;ERROR=100716
+CRD_COMP;OK=CRD_READER.OK & CRD_DISPENSER.OK & CRD_CAPTURE.OK & CRD_POWER.OK
+
+ATB_READER;OK=2000;ERROR=2001 | 2002 | 2003 | 2004 | 2005
+ATB_WRITER;OK=2010;ERROR=2011 | 2012 | 2013 | 2014 | 2015
+ATB_DISPENSER;OK=2020 | 2028;ERROR=2021 | 2022 | 2023 | 2024 | 2025
+ATB_ESCR_CAPTURE;OK=2060 | 2066;ERROR=2061 | 2062 | 2063 | 2064 | 2065 | 2066
+ATB_FEEDER_BP;OK=2200 | 2201 | 2202 | 2203 | 2207;ERROR=2208 | 2204
+// ATB_FEEDER_BP_FIRST;OK=2210 | 2211 | 2212 | 2213 | 2217;ERROR=2218 | 2214
+// ATB_FEEDER_BP_BUSINESS;OK=2220 | 2221 | 2222 | 2223 | 2227;ERROR=2228 | 2224
+// ATB_FEEDER_BP_ECONOMY;OK=2230 | 2231 | 2232 | 2233 | 2237;ERROR=2238 | 2234
+// ATB_FEEDER_TK;OK=2240 | 2241 | 2242 | 2243 | 2247;ERROR=2248 | 2244
+// ATB_FEEDER_GP;OK=2250 | 2251 | 2252 | 2253 | 2257;ERROR=2258 | 2254
+// ATB_PAPER;OK=ATB_FEEDER_BP.OK | ATB_FEEDER_BP_FIRST.OK | ATB_FEEDER_BP_BUSINESS.OK | ATB_FEEDER_BP_ECONOMY.OK | ATB_FEEDER_TK.OK | ATB_FEEDER_GP.OK | ATB_WRITER.OK
+ATB_PAPER;OK=ATB_FEEDER_BP.OK
+ATBHW;OK=100500;ERROR=100501 | 100502 | 100503 | 100504 | 100505 | 100506 | 100531 | 100532
+ATBHW_ESCROW;OK=100400;ERROR=100401 | 100402 | 100403 | 100404 | 100420 | 100421 | 100422
+ATB_POWER;OK=2000 | 100713;ERROR=100712
+ATB_COMP;OK=ATB_READER.OK & ATB_WRITER.OK & ATB_DISPENSER.OK & ATB_PAPER.OK & ATBHW.OK & ATBHW_ESCROW.OK & ATB_POWER.OK & ATB_ESCR_CAPTURE.OK
+
+// BTP_WRITER;OK=3000;ERROR=3001 | 3002 | 3003 | 3004 | 3005 | 3006 | 3012 | 3013
+// BTP_PAPER;OK=3000 | 3100 | 3101 | 3102;ERROR=3103
+// BTPHW;OK=100600;ERROR=100601 | 100602 | 100603 | 100604 | 100605 | 100606
+// BTP_POWER;OK=3000 | 100715;ERROR=100714
+// BTP_COMP;OK=BTP_WRITER.OK & BTP_PAPER.OK & BTPHW.OK & BTP_POWER.OK
+
+// CON;OK=9000;ERROR=9002 | 9003 | 9004 | 9005 | 9006 | 9011
+// CONHW;OK=100015 | 9000;ERROR=100001 | 100002 | 100013 | 100014
+// CONHW_SCN;OK=100100 | 9000;ERROR=100101 | 100102 | 100103
+// CONHW_SPS;OK=100200 | 9000;ERROR=100201 | 100202 | 100203
+// CONHW_SCL;OK=100300 | 9000;ERROR=100301 | 100302 | 100303
+// CON_COMP;OK=CON.OK & CONHW.OK & CONHW_SCN.OK & CONHW_SPS.OK & CONHW_SCL.OK
+
+// MPR_READER;OK=8000;ERROR=8001 | 8002 | 8003 | 8004 | 8005 | 8006 | 8012
+// MPR_COMP;OK=MPR_READER.OK
+
+SEL;OK=100718;ERROR=100719 | 100711
+DOOR;CLOSED=100702;OPEN=100701
+
+// <<< component configuration: please uncomment the one component configuration in use
+
+// Baggage handling without MPR
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & BTP_COMP.OK & CON_COMP.OK
+
+// Baggage Handling
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & BTP_COMP.OK & CON_COMP.OK & MPR_COMP.OK
+
+// Without Baggage Handling without MPR
+COMPS;OK=CRD_COMP.OK & ATB_COMP.OK
+
+// Without Baggage Handling
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & MPR_COMP.OK
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+KIOSK_SEL;OK=DOOR.CLOSED & SEL.OK;SERVICE=DOOR.OPEN & SEL.OK
+KIOSK_SVCAPP;INACTIVE=11001 | 11003 | 11004 | 11005 | 11006 | 11007 | 11008 | 11009 | 11010;ACTIVE=11002 | 11011
+KIOSK;OPERATION=KIOSK_SEL.OK & KIOSK_SVCAPP.INACTIVE;UNDER_SERVICE=KIOSK_SEL.SERVICE | KIOSK_SVCAPP.ACTIVE
+
+CLA;AVAILABLE=10001 | 10002 | 10003 | 10004 | 10005;UNAVAILABLE=10000 | 10006 | 10007 | 10008 | 10011
+
+SVC;AVAILABLE=11001 | 11002 | 11003 | 11004 | 11005;UNAVAILABLE=11000 | 11006 | 11007 | 11008 | 11010
+
+
+
+// <<< Application section: please uncomment the installed applications
+
+AL_DLH;AVAILABLE=12001 | 12002 | 12003 | 12004 | 12005;UNAVAILABLE=12000 | 12006 | 12007 | 12008 | 12010 | 12011 | 12012
+APP_DLH;AVAILABLE=AL_DLH.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_DLH_BAG;AVAILABLE=APP_DLH.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+AL_AUA;AVAILABLE=14001 | 14002 | 14003 | 14004 | 14005;UNAVAILABLE=14000 | 14006 | 14007 | 14008 | 14010 | 14011 | 14012
+APP_AUA;AVAILABLE=AL_AUA.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_AUA_BAG;AVAILABLE=APP_AUA.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// AL_KLM;AVAILABLE=16001 | 16002 | 16003 | 16004 | 16005;UNAVAILABLE=16000 | 16006 | 16007 | 16008 | 16010 | 16011 | 16012
+// APP_KLM;AVAILABLE=AL_AUA.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_KLM_BAG;AVAILABLE=APP_AUA.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// AL_BER;AVAILABLE=19001 | 19002 | 19003 | 19004 | 19005;UNAVAILABLE=19000 | 19006 | 19007 | 19008 | 19010 | 19011 | 19012
+// APP_BER;AVAILABLE=AL_BER.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_BER_BAG;AVAILABLE=APP_BER.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+AL_IB;AVAILABLE=21001 | 21002 | 21003 | 21004 | 21005;UNAVAILABLE=21000 | 21006 | 21007 | 21008 | 21010 | 21011 | 21012
+APP_IB;AVAILABLE=AL_IB.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_IB_BAG;AVAILABLE=APP_IB.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+
+// <<< System section: please uncomment the one kiosk configuration in use
+
+// AUA + DLH (Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB (Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE & APP_IB_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB
+SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA (Baggage Handling)
+// SYSTEM;ALL_OK=APP_AUA_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_AUA.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB + BER + KLM(Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE & APP_IB_BAG.AVAILABLE & APP_BER_BAG.AVAILABLE & APP_KLM_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB + BER + KLM
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + IB + KLM
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + BER + KLM
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
diff --git a/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_DLH_KLM_IB_BER_(BAG).txt b/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_DLH_KLM_IB_BER_(BAG).txt
new file mode 100644
index 00000000..04eb5ced
--- /dev/null
+++ b/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_DLH_KLM_IB_BER_(BAG).txt
@@ -0,0 +1,126 @@
+CRD_READER;OK=1000;ERROR=1001 | 1002 | 1003 | 1004 | 1005
+CRD_DISPENSER;OK=1020;ERROR=1021 | 1022 | 1023 | 1024 | 1025
+CRD_CAPTURE;OK=1030;ERROR=1031 | 1032 | 1033 | 1034 | 1035 | 1036
+CRD_POWER;OK=1000 | 100717;ERROR=100716
+CRD_COMP;OK=CRD_READER.OK & CRD_DISPENSER.OK & CRD_CAPTURE.OK & CRD_POWER.OK
+
+ATB_READER;OK=2000;ERROR=2001 | 2002 | 2003 | 2004 | 2005
+ATB_WRITER;OK=2010;ERROR=2011 | 2012 | 2013 | 2014 | 2015
+ATB_DISPENSER;OK=2020 | 2028;ERROR=2021 | 2022 | 2023 | 2024 | 2025
+ATB_ESCR_CAPTURE;OK=2060 | 2066;ERROR=2061 | 2062 | 2063 | 2064 | 2065 | 2066
+ATB_FEEDER_BP;OK=2200 | 2201 | 2202 | 2203 | 2207;ERROR=2208 | 2204
+// ATB_FEEDER_BP_FIRST;OK=2210 | 2211 | 2212 | 2213 | 2217;ERROR=2218 | 2214
+// ATB_FEEDER_BP_BUSINESS;OK=2220 | 2221 | 2222 | 2223 | 2227;ERROR=2228 | 2224
+// ATB_FEEDER_BP_ECONOMY;OK=2230 | 2231 | 2232 | 2233 | 2237;ERROR=2238 | 2234
+// ATB_FEEDER_TK;OK=2240 | 2241 | 2242 | 2243 | 2247;ERROR=2248 | 2244
+// ATB_FEEDER_GP;OK=2250 | 2251 | 2252 | 2253 | 2257;ERROR=2258 | 2254
+// ATB_PAPER;OK=ATB_FEEDER_BP.OK | ATB_FEEDER_BP_FIRST.OK | ATB_FEEDER_BP_BUSINESS.OK | ATB_FEEDER_BP_ECONOMY.OK | ATB_FEEDER_TK.OK | ATB_FEEDER_GP.OK | ATB_WRITER.OK
+ATB_PAPER;OK=ATB_FEEDER_BP.OK
+ATBHW;OK=100500;ERROR=100501 | 100502 | 100503 | 100504 | 100505 | 100506 | 100531 | 100532
+ATBHW_ESCROW;OK=100400;ERROR=100401 | 100402 | 100403 | 100404 | 100420 | 100421 | 100422
+ATB_POWER;OK=2000 | 100713;ERROR=100712
+ATB_COMP;OK=ATB_READER.OK & ATB_WRITER.OK & ATB_DISPENSER.OK & ATB_PAPER.OK & ATBHW.OK & ATBHW_ESCROW.OK & ATB_POWER.OK & ATB_ESCR_CAPTURE.OK
+
+BTP_WRITER;OK=3000;ERROR=3001 | 3002 | 3003 | 3004 | 3005 | 3006 | 3012 | 3013
+BTP_PAPER;OK=3000 | 3100 | 3101 | 3102;ERROR=3103
+BTPHW;OK=100600;ERROR=100601 | 100602 | 100603 | 100604 | 100605 | 100606
+BTP_POWER;OK=3000 | 100715;ERROR=100714
+BTP_COMP;OK=BTP_WRITER.OK & BTP_PAPER.OK & BTPHW.OK & BTP_POWER.OK
+
+CON;OK=9000;ERROR=9002 | 9003 | 9004 | 9005 | 9006 | 9011
+CONHW;OK=100015 | 9000;ERROR=100001 | 100002 | 100013 | 100014
+CONHW_SCN;OK=100100 | 9000;ERROR=100101 | 100102 | 100103
+CONHW_SPS;OK=100200 | 9000;ERROR=100201 | 100202 | 100203
+CONHW_SCL;OK=100300 | 9000;ERROR=100301 | 100302 | 100303
+CON_COMP;OK=CON.OK & CONHW.OK & CONHW_SCN.OK & CONHW_SPS.OK & CONHW_SCL.OK
+
+// MPR_READER;OK=8000;ERROR=8001 | 8002 | 8003 | 8004 | 8005 | 8006 | 8012
+// MPR_COMP;OK=MPR_READER.OK
+
+SEL;OK=100718;ERROR=100719 | 100711
+DOOR;CLOSED=100702;OPEN=100701
+
+// <<< component configuration: please uncomment the one component configuration in use
+
+// Baggage handling without MPR
+COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & BTP_COMP.OK & CON_COMP.OK
+
+// Baggage Handling
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & BTP_COMP.OK & CON_COMP.OK & MPR_COMP.OK
+
+// Without Baggage Handling without MPR
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK
+
+// Without Baggage Handling
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & MPR_COMP.OK
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+KIOSK_SEL;OK=DOOR.CLOSED & SEL.OK;SERVICE=DOOR.OPEN & SEL.OK
+KIOSK_SVCAPP;INACTIVE=11001 | 11003 | 11004 | 11005 | 11006 | 11007 | 11008 | 11009 | 11010;ACTIVE=11002 | 11011
+KIOSK;OPERATION=KIOSK_SEL.OK & KIOSK_SVCAPP.INACTIVE;UNDER_SERVICE=KIOSK_SEL.SERVICE | KIOSK_SVCAPP.ACTIVE
+
+CLA;AVAILABLE=10001 | 10002 | 10003 | 10004 | 10005;UNAVAILABLE=10000 | 10006 | 10007 | 10008 | 10011
+
+SVC;AVAILABLE=11001 | 11002 | 11003 | 11004 | 11005;UNAVAILABLE=11000 | 11006 | 11007 | 11008 | 11010
+
+
+
+// <<< Application section: please uncomment the installed applications
+
+AL_DLH;AVAILABLE=12001 | 12002 | 12003 | 12004 | 12005;UNAVAILABLE=12000 | 12006 | 12007 | 12008 | 12010 | 12011 | 12012
+APP_DLH;AVAILABLE=AL_DLH.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+APP_DLH_BAG;AVAILABLE=APP_DLH.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+AL_AUA;AVAILABLE=14001 | 14002 | 14003 | 14004 | 14005;UNAVAILABLE=14000 | 14006 | 14007 | 14008 | 14010 | 14011 | 14012
+APP_AUA;AVAILABLE=AL_AUA.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+APP_AUA_BAG;AVAILABLE=APP_AUA.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+AL_KLM;AVAILABLE=16001 | 16002 | 16003 | 16004 | 16005;UNAVAILABLE=16000 | 16006 | 16007 | 16008 | 16010 | 16011 | 16012
+APP_KLM;AVAILABLE=AL_AUA.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+APP_KLM_BAG;AVAILABLE=APP_AUA.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+AL_BER;AVAILABLE=19001 | 19002 | 19003 | 19004 | 19005;UNAVAILABLE=19000 | 19006 | 19007 | 19008 | 19010 | 19011 | 19012
+APP_BER;AVAILABLE=AL_BER.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+APP_BER_BAG;AVAILABLE=APP_BER.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+AL_IB;AVAILABLE=21001 | 21002 | 21003 | 21004 | 21005;UNAVAILABLE=21000 | 21006 | 21007 | 21008 | 21010 | 21011 | 21012
+APP_IB;AVAILABLE=AL_IB.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+APP_IB_BAG;AVAILABLE=APP_IB.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+
+// <<< System section: please uncomment the one kiosk configuration in use
+
+// AUA + DLH (Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB (Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE & APP_IB_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA (Baggage Handling)
+// SYSTEM;ALL_OK=APP_AUA_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_AUA.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB + BER + KLM(Baggage Handling)
+SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE & APP_IB_BAG.AVAILABLE & APP_BER_BAG.AVAILABLE & APP_KLM_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB + BER + KLM
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + IB + KLM
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + BER + KLM
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
diff --git a/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_DLH_KLM_IB_BER_(NOBAG).txt b/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_DLH_KLM_IB_BER_(NOBAG).txt
new file mode 100644
index 00000000..ed5651cf
--- /dev/null
+++ b/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_DLH_KLM_IB_BER_(NOBAG).txt
@@ -0,0 +1,126 @@
+CRD_READER;OK=1000;ERROR=1001 | 1002 | 1003 | 1004 | 1005
+CRD_DISPENSER;OK=1020;ERROR=1021 | 1022 | 1023 | 1024 | 1025
+CRD_CAPTURE;OK=1030;ERROR=1031 | 1032 | 1033 | 1034 | 1035 | 1036
+CRD_POWER;OK=1000 | 100717;ERROR=100716
+CRD_COMP;OK=CRD_READER.OK & CRD_DISPENSER.OK & CRD_CAPTURE.OK & CRD_POWER.OK
+
+ATB_READER;OK=2000;ERROR=2001 | 2002 | 2003 | 2004 | 2005
+ATB_WRITER;OK=2010;ERROR=2011 | 2012 | 2013 | 2014 | 2015
+ATB_DISPENSER;OK=2020 | 2028;ERROR=2021 | 2022 | 2023 | 2024 | 2025
+ATB_ESCR_CAPTURE;OK=2060 | 2066;ERROR=2061 | 2062 | 2063 | 2064 | 2065 | 2066
+ATB_FEEDER_BP;OK=2200 | 2201 | 2202 | 2203 | 2207;ERROR=2208 | 2204
+// ATB_FEEDER_BP_FIRST;OK=2210 | 2211 | 2212 | 2213 | 2217;ERROR=2218 | 2214
+// ATB_FEEDER_BP_BUSINESS;OK=2220 | 2221 | 2222 | 2223 | 2227;ERROR=2228 | 2224
+// ATB_FEEDER_BP_ECONOMY;OK=2230 | 2231 | 2232 | 2233 | 2237;ERROR=2238 | 2234
+// ATB_FEEDER_TK;OK=2240 | 2241 | 2242 | 2243 | 2247;ERROR=2248 | 2244
+// ATB_FEEDER_GP;OK=2250 | 2251 | 2252 | 2253 | 2257;ERROR=2258 | 2254
+// ATB_PAPER;OK=ATB_FEEDER_BP.OK | ATB_FEEDER_BP_FIRST.OK | ATB_FEEDER_BP_BUSINESS.OK | ATB_FEEDER_BP_ECONOMY.OK | ATB_FEEDER_TK.OK | ATB_FEEDER_GP.OK | ATB_WRITER.OK
+ATB_PAPER;OK=ATB_FEEDER_BP.OK
+ATBHW;OK=100500;ERROR=100501 | 100502 | 100503 | 100504 | 100505 | 100506 | 100531 | 100532
+ATBHW_ESCROW;OK=100400;ERROR=100401 | 100402 | 100403 | 100404 | 100420 | 100421 | 100422
+ATB_POWER;OK=2000 | 100713;ERROR=100712
+ATB_COMP;OK=ATB_READER.OK & ATB_WRITER.OK & ATB_DISPENSER.OK & ATB_PAPER.OK & ATBHW.OK & ATBHW_ESCROW.OK & ATB_POWER.OK & ATB_ESCR_CAPTURE.OK
+
+// BTP_WRITER;OK=3000;ERROR=3001 | 3002 | 3003 | 3004 | 3005 | 3006 | 3012 | 3013
+// BTP_PAPER;OK=3000 | 3100 | 3101 | 3102;ERROR=3103
+// BTPHW;OK=100600;ERROR=100601 | 100602 | 100603 | 100604 | 100605 | 100606
+// BTP_POWER;OK=3000 | 100715;ERROR=100714
+// BTP_COMP;OK=BTP_WRITER.OK & BTP_PAPER.OK & BTPHW.OK & BTP_POWER.OK
+
+// CON;OK=9000;ERROR=9002 | 9003 | 9004 | 9005 | 9006 | 9011
+// CONHW;OK=100015 | 9000;ERROR=100001 | 100002 | 100013 | 100014
+// CONHW_SCN;OK=100100 | 9000;ERROR=100101 | 100102 | 100103
+// CONHW_SPS;OK=100200 | 9000;ERROR=100201 | 100202 | 100203
+// CONHW_SCL;OK=100300 | 9000;ERROR=100301 | 100302 | 100303
+// CON_COMP;OK=CON.OK & CONHW.OK & CONHW_SCN.OK & CONHW_SPS.OK & CONHW_SCL.OK
+
+// MPR_READER;OK=8000;ERROR=8001 | 8002 | 8003 | 8004 | 8005 | 8006 | 8012
+// MPR_COMP;OK=MPR_READER.OK
+
+SEL;OK=100718;ERROR=100719 | 100711
+DOOR;CLOSED=100702;OPEN=100701
+
+// <<< component configuration: please uncomment the one component configuration in use
+
+// Baggage handling without MPR
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & BTP_COMP.OK & CON_COMP.OK
+
+// Baggage Handling
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & BTP_COMP.OK & CON_COMP.OK & MPR_COMP.OK
+
+// Without Baggage Handling without MPR
+COMPS;OK=CRD_COMP.OK & ATB_COMP.OK
+
+// Without Baggage Handling
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & MPR_COMP.OK
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+KIOSK_SEL;OK=DOOR.CLOSED & SEL.OK;SERVICE=DOOR.OPEN & SEL.OK
+KIOSK_SVCAPP;INACTIVE=11001 | 11003 | 11004 | 11005 | 11006 | 11007 | 11008 | 11009 | 11010;ACTIVE=11002 | 11011
+KIOSK;OPERATION=KIOSK_SEL.OK & KIOSK_SVCAPP.INACTIVE;UNDER_SERVICE=KIOSK_SEL.SERVICE | KIOSK_SVCAPP.ACTIVE
+
+CLA;AVAILABLE=10001 | 10002 | 10003 | 10004 | 10005;UNAVAILABLE=10000 | 10006 | 10007 | 10008 | 10011
+
+SVC;AVAILABLE=11001 | 11002 | 11003 | 11004 | 11005;UNAVAILABLE=11000 | 11006 | 11007 | 11008 | 11010
+
+
+
+// <<< Application section: please uncomment the installed applications
+
+AL_DLH;AVAILABLE=12001 | 12002 | 12003 | 12004 | 12005;UNAVAILABLE=12000 | 12006 | 12007 | 12008 | 12010 | 12011 | 12012
+APP_DLH;AVAILABLE=AL_DLH.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_DLH_BAG;AVAILABLE=APP_DLH.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+AL_AUA;AVAILABLE=14001 | 14002 | 14003 | 14004 | 14005;UNAVAILABLE=14000 | 14006 | 14007 | 14008 | 14010 | 14011 | 14012
+APP_AUA;AVAILABLE=AL_AUA.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_AUA_BAG;AVAILABLE=APP_AUA.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+AL_KLM;AVAILABLE=16001 | 16002 | 16003 | 16004 | 16005;UNAVAILABLE=16000 | 16006 | 16007 | 16008 | 16010 | 16011 | 16012
+APP_KLM;AVAILABLE=AL_AUA.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_KLM_BAG;AVAILABLE=APP_AUA.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+AL_BER;AVAILABLE=19001 | 19002 | 19003 | 19004 | 19005;UNAVAILABLE=19000 | 19006 | 19007 | 19008 | 19010 | 19011 | 19012
+APP_BER;AVAILABLE=AL_BER.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_BER_BAG;AVAILABLE=APP_BER.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+AL_IB;AVAILABLE=21001 | 21002 | 21003 | 21004 | 21005;UNAVAILABLE=21000 | 21006 | 21007 | 21008 | 21010 | 21011 | 21012
+APP_IB;AVAILABLE=AL_IB.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_IB_BAG;AVAILABLE=APP_IB.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+
+// <<< System section: please uncomment the one kiosk configuration in use
+
+// AUA + DLH (Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB (Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE & APP_IB_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA (Baggage Handling)
+// SYSTEM;ALL_OK=APP_AUA_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_AUA.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB + BER + KLM(Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE & APP_IB_BAG.AVAILABLE & APP_BER_BAG.AVAILABLE & APP_KLM_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB + BER + KLM
+SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + IB + KLM
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + BER + KLM
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
diff --git a/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_IB_KLM(NOBAG).txt b/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_IB_KLM(NOBAG).txt
new file mode 100644
index 00000000..1bdfc438
--- /dev/null
+++ b/Massai/cpp/LogServiceEx/compConfiguration_VIE_AUA_IB_KLM(NOBAG).txt
@@ -0,0 +1,126 @@
+CRD_READER;OK=1000;ERROR=1001 | 1002 | 1003 | 1004 | 1005
+CRD_DISPENSER;OK=1020;ERROR=1021 | 1022 | 1023 | 1024 | 1025
+CRD_CAPTURE;OK=1030;ERROR=1031 | 1032 | 1033 | 1034 | 1035 | 1036
+CRD_POWER;OK=1000 | 100717;ERROR=100716
+CRD_COMP;OK=CRD_READER.OK & CRD_DISPENSER.OK & CRD_CAPTURE.OK & CRD_POWER.OK
+
+ATB_READER;OK=2000;ERROR=2001 | 2002 | 2003 | 2004 | 2005
+ATB_WRITER;OK=2010;ERROR=2011 | 2012 | 2013 | 2014 | 2015
+ATB_DISPENSER;OK=2020 | 2028;ERROR=2021 | 2022 | 2023 | 2024 | 2025
+ATB_ESCR_CAPTURE;OK=2060 | 2066;ERROR=2061 | 2062 | 2063 | 2064 | 2065 | 2066
+ATB_FEEDER_BP;OK=2200 | 2201 | 2202 | 2203 | 2207;ERROR=2208 | 2204
+// ATB_FEEDER_BP_FIRST;OK=2210 | 2211 | 2212 | 2213 | 2217;ERROR=2218 | 2214
+// ATB_FEEDER_BP_BUSINESS;OK=2220 | 2221 | 2222 | 2223 | 2227;ERROR=2228 | 2224
+// ATB_FEEDER_BP_ECONOMY;OK=2230 | 2231 | 2232 | 2233 | 2237;ERROR=2238 | 2234
+// ATB_FEEDER_TK;OK=2240 | 2241 | 2242 | 2243 | 2247;ERROR=2248 | 2244
+// ATB_FEEDER_GP;OK=2250 | 2251 | 2252 | 2253 | 2257;ERROR=2258 | 2254
+// ATB_PAPER;OK=ATB_FEEDER_BP.OK | ATB_FEEDER_BP_FIRST.OK | ATB_FEEDER_BP_BUSINESS.OK | ATB_FEEDER_BP_ECONOMY.OK | ATB_FEEDER_TK.OK | ATB_FEEDER_GP.OK | ATB_WRITER.OK
+ATB_PAPER;OK=ATB_FEEDER_BP.OK
+ATBHW;OK=100500;ERROR=100501 | 100502 | 100503 | 100504 | 100505 | 100506 | 100531 | 100532
+ATBHW_ESCROW;OK=100400;ERROR=100401 | 100402 | 100403 | 100404 | 100420 | 100421 | 100422
+ATB_POWER;OK=2000 | 100713;ERROR=100712
+ATB_COMP;OK=ATB_READER.OK & ATB_WRITER.OK & ATB_DISPENSER.OK & ATB_PAPER.OK & ATBHW.OK & ATBHW_ESCROW.OK & ATB_POWER.OK & ATB_ESCR_CAPTURE.OK
+
+// BTP_WRITER;OK=3000;ERROR=3001 | 3002 | 3003 | 3004 | 3005 | 3006 | 3012 | 3013
+// BTP_PAPER;OK=3000 | 3100 | 3101 | 3102;ERROR=3103
+// BTPHW;OK=100600;ERROR=100601 | 100602 | 100603 | 100604 | 100605 | 100606
+// BTP_POWER;OK=3000 | 100715;ERROR=100714
+// BTP_COMP;OK=BTP_WRITER.OK & BTP_PAPER.OK & BTPHW.OK & BTP_POWER.OK
+
+// CON;OK=9000;ERROR=9002 | 9003 | 9004 | 9005 | 9006 | 9011
+// CONHW;OK=100015 | 9000;ERROR=100001 | 100002 | 100013 | 100014
+// CONHW_SCN;OK=100100 | 9000;ERROR=100101 | 100102 | 100103
+// CONHW_SPS;OK=100200 | 9000;ERROR=100201 | 100202 | 100203
+// CONHW_SCL;OK=100300 | 9000;ERROR=100301 | 100302 | 100303
+// CON_COMP;OK=CON.OK & CONHW.OK & CONHW_SCN.OK & CONHW_SPS.OK & CONHW_SCL.OK
+
+// MPR_READER;OK=8000;ERROR=8001 | 8002 | 8003 | 8004 | 8005 | 8006 | 8012
+// MPR_COMP;OK=MPR_READER.OK
+
+SEL;OK=100718;ERROR=100719 | 100711
+DOOR;CLOSED=100702;OPEN=100701
+
+// <<< component configuration: please uncomment the one component configuration in use
+
+// Baggage handling without MPR
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & BTP_COMP.OK & CON_COMP.OK
+
+// Baggage Handling
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & BTP_COMP.OK & CON_COMP.OK & MPR_COMP.OK
+
+// Without Baggage Handling without MPR
+COMPS;OK=CRD_COMP.OK & ATB_COMP.OK
+
+// Without Baggage Handling
+// COMPS;OK=CRD_COMP.OK & ATB_COMP.OK & MPR_COMP.OK
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+KIOSK_SEL;OK=DOOR.CLOSED & SEL.OK;SERVICE=DOOR.OPEN & SEL.OK
+KIOSK_SVCAPP;INACTIVE=11001 | 11003 | 11004 | 11005 | 11006 | 11007 | 11008 | 11009 | 11010;ACTIVE=11002 | 11011
+KIOSK;OPERATION=KIOSK_SEL.OK & KIOSK_SVCAPP.INACTIVE;UNDER_SERVICE=KIOSK_SEL.SERVICE | KIOSK_SVCAPP.ACTIVE
+
+CLA;AVAILABLE=10001 | 10002 | 10003 | 10004 | 10005;UNAVAILABLE=10000 | 10006 | 10007 | 10008 | 10011
+
+SVC;AVAILABLE=11001 | 11002 | 11003 | 11004 | 11005;UNAVAILABLE=11000 | 11006 | 11007 | 11008 | 11010
+
+
+
+// <<< Application section: please uncomment the installed applications
+
+// AL_DLH;AVAILABLE=12001 | 12002 | 12003 | 12004 | 12005;UNAVAILABLE=12000 | 12006 | 12007 | 12008 | 12010 | 12011 | 12012
+// APP_DLH;AVAILABLE=AL_DLH.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_DLH_BAG;AVAILABLE=APP_DLH.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+AL_AUA;AVAILABLE=14001 | 14002 | 14003 | 14004 | 14005;UNAVAILABLE=14000 | 14006 | 14007 | 14008 | 14010 | 14011 | 14012
+APP_AUA;AVAILABLE=AL_AUA.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_AUA_BAG;AVAILABLE=APP_AUA.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+AL_KLM;AVAILABLE=16001 | 16002 | 16003 | 16004 | 16005;UNAVAILABLE=16000 | 16006 | 16007 | 16008 | 16010 | 16011 | 16012
+APP_KLM;AVAILABLE=AL_AUA.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_KLM_BAG;AVAILABLE=APP_AUA.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// AL_BER;AVAILABLE=19001 | 19002 | 19003 | 19004 | 19005;UNAVAILABLE=19000 | 19006 | 19007 | 19008 | 19010 | 19011 | 19012
+// APP_BER;AVAILABLE=AL_BER.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_BER_BAG;AVAILABLE=APP_BER.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+AL_IB;AVAILABLE=21001 | 21002 | 21003 | 21004 | 21005;UNAVAILABLE=21000 | 21006 | 21007 | 21008 | 21010 | 21011 | 21012
+APP_IB;AVAILABLE=AL_IB.AVAILABLE & CLA.AVAILABLE & CRD_COMP.OK & ATB_COMP.OK & ATB_FEEDER_BP.OK
+// APP_IB_BAG;AVAILABLE=APP_IB.AVAILABLE & BTP_COMP.OK & CON_COMP.OK
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+
+// <<< System section: please uncomment the one kiosk configuration in use
+
+// AUA + DLH (Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB (Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE & APP_IB_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA (Baggage Handling)
+// SYSTEM;ALL_OK=APP_AUA_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_AUA.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB + BER + KLM(Baggage Handling)
+// SYSTEM;ALL_OK=APP_DLH_BAG.AVAILABLE & APP_AUA_BAG.AVAILABLE & APP_IB_BAG.AVAILABLE & APP_BER_BAG.AVAILABLE & APP_KLM_BAG.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);NOBAG_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + DLH + IB + BER + KLM
+// SYSTEM;ALL_OK=APP_DLH.AVAILABLE & APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);DLH_OK=APP_DLH.AVAILABLE;AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + IB + KLM
+SYSTEM;ALL_OK=APP_AUA.AVAILABLE & APP_IB.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;IB_OK=APP_IB.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// AUA + BER + KLM
+// SYSTEM;ALL_OK=APP_AUA.AVAILABLE & APP_BER.AVAILABLE & APP_KLM.AVAILABLE;UNDER_SERVICE=KIOSK.UNDER_SERVICE(SHOW);AUA_OK=APP_AUA.AVAILABLE;BER_OK=APP_BER.AVAILABLE;KLM_OK=APP_KLM.AVAILABLE;HARDWARE_OK=COMPS.OK;ERROR
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
diff --git a/Massai/cpp/LogServiceEx/inc/execTime.hpp b/Massai/cpp/LogServiceEx/inc/execTime.hpp
new file mode 100644
index 00000000..095c09c9
--- /dev/null
+++ b/Massai/cpp/LogServiceEx/inc/execTime.hpp
@@ -0,0 +1,71 @@
+/**
+ **************************************************************************
+ *
+ * @file execTime.hpp
+ *
+ * Contains the class Materna::MSSD::execTime.
+ *
+ * @author MaK
+ *
+ * Copyright (c) 2006 MATERNA Information & Communications
+ *
+ **************************************************************************
+**/
+#ifndef EXECTIME_HPP
+#define EXECTIME_HPP
+
+#include "windows.h"
+
+//! MATERNA Information & Communications
+namespace Materna
+{
+   //! Self Service Devices
+   namespace MSSD
+   {
+      /**
+       ******************************************************************************
+       * class implementation execTime
+       ******************************************************************************
+      **/
+
+      class execTime
+      {
+        long & result;
+        ULARGE_INTEGER start, end;
+
+        void millis(ULARGE_INTEGER * uli)
+        {
+          SYSTEMTIME st;
+          FILETIME ft;
+          GetLocalTime(&st);
+          SystemTimeToFileTime(&st, &ft);
+          memcpy(uli, &ft, sizeof(ft));
+        }
+
+      public:
+        execTime(long & res)
+         : result(res)
+        {
+          memset(&start, 0, sizeof(start));
+          memset(&end, 0, sizeof(end));
+          millis(&start);
+        }
+
+        ~execTime()
+        {
+          millis(&end);
+          result = (end.QuadPart - start.QuadPart) / 10000;
+        }
+      };
+   } // namespace MSSD
+} // namespace Materna
+
+#endif // EXECTIME_HPP
+/**
+ **************************************************************************
+ *
+ * End of file
+ *
+ **************************************************************************
+**/
+
diff --git a/Massai/cpp/MassaiDLL/dll/inc/COMPRESS.H b/Massai/cpp/MassaiDLL/dll/inc/COMPRESS.H
new file mode 100644
index 00000000..8181c40f
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/dll/inc/COMPRESS.H
@@ -0,0 +1,59 @@
+/***********************************************************************
+ *                           CMVC Information
+ *                           ----------------
+ * File, Component, Release   : SSDBASE/INC/COMPRESS.H, ATSA.SSD.BASE.SSDBASE.OS2, ATSA_SSDBASE.o1
+ * Version                    : 1.1
+ * Date of last Check-In      : 96/10/22, 16:21:33
+ * Date of last Access        : 96/12/10, 16:28:20
+ **********************************************************************/
+/****************************************************************************
+
+ FILE:      compress.h
+
+ PURPOSE:   Header file
+
+ DATE:      21-Jan-1992
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+#ifndef COMPRESS_H
+#define COMPRESS_H
+
+/* exported functions ********************************************************/
+
+class COMPRESS
+{
+
+ SHORT  *psCodeValue;          /* pointer to code value array          */
+ USHORT *pwPrefixCode;         /* pointer to prefix code array         */
+ BYTE   *pbAppendChar;         /* pointer to array with appended chars */
+ BYTE    abDecodeStack[4000];  /* array to hold decoded string         */
+
+ SHORT sOutputBitCnt;
+ ULONG ulOutputBitBuf;
+ SHORT sInputBitCnt;
+ ULONG ulInputBitBuf;
+
+
+ USHORT  InitLZW       (VOID);
+ USHORT  ReleaseLZW    (VOID);
+ SHORT   FindMatch     (USHORT,USHORT);
+ USHORT  OutputCode    (FILE *,USHORT);
+ USHORT  InputCode     (FILE *);
+ CHAR   *DecodeString  (BYTE  *,USHORT);
+
+
+
+public:
+
+   USHORT packFile   (CHAR *);
+   USHORT unpackFile (CHAR *);
+
+// constructors
+   COMPRESS();
+  ~COMPRESS();
+};  
+
+#endif // COMPRESS_H
diff --git a/Massai/cpp/MassaiDLL/dll/inc/TRACE.HPP b/Massai/cpp/MassaiDLL/dll/inc/TRACE.HPP
new file mode 100644
index 00000000..c21517e1
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/dll/inc/TRACE.HPP
@@ -0,0 +1,53 @@
+/******************************************************************************
+
+ FILE:      trace.hpp
+
+ PURPOSE:   Header file.
+
+ DATE:      11/28/95 - 15:35:33
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+******************************************************************************/
+
+#ifndef TRACE_HPP
+#define TRACE_HPP
+
+#ifdef SHOW_INCLUDE_FILES
+
+#pragma message("including: " __FILE__)
+
+#endif
+
+#ifdef __cplusplus
+      extern "C" {
+#endif
+
+EXPORT VOID InitTrace          (void);
+EXPORT VOID TerminateTrace     (void);
+EXPORT BOOL TraceAttachProcess (void);
+EXPORT BOOL TraceDetachProcess (void);
+
+// trace functions using OutputDebugString()
+
+EXPORT VOID debugWrite         (BYTE   bLevel,        // trace level
+                                CHAR  *pszFile,       // src file name
+                                SHORT  sLine,         // line in src file
+                                CHAR  *pszFormat,     // format of vars
+                                ...);                 // vars...
+
+EXPORT VOID debugDump          (BYTE   bLevel,        // trace level
+                                CHAR  *pszFile,       // src file name
+                                SHORT  sLine,         // line in src file
+                                BYTE  *pDate,         // dump area
+                                USHORT usLen);        // bytes to dump
+
+#ifdef __cplusplus
+      }
+#endif
+
+#endif /* TRACE_HPP */
+
+/******************************************************************************
+ END OF FILE
+******************************************************************************/
diff --git a/Massai/cpp/MassaiDLL/dll/inc/globbase.hpp b/Massai/cpp/MassaiDLL/dll/inc/globbase.hpp
new file mode 100644
index 00000000..bfedd1d2
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/dll/inc/globbase.hpp
@@ -0,0 +1,71 @@
+/******************************************************************************
+
+ FILE:      globbase.hpp
+
+ PURPOSE:   Global exports for SSDBASE only.
+
+ DATE:      12/06/95 - 10:07:50
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+******************************************************************************/
+
+#ifndef GLOBBASE_HPP
+#define GLOBBASE_HPP
+
+//#include <winsock.h>
+
+/* exported classes ********************************************************/
+class MassaiLibraryInitTerm
+{
+public:
+
+    MassaiLibraryInitTerm();
+    ~MassaiLibraryInitTerm();
+    void ref();
+};
+/* exported constants ********************************************************/
+
+#define M_UTILSDEV_TRC         M_UTILSDEV,255,"0.0.0.0","mUtils.log"
+#define M_UTILSDEV_FILE        "mUtils.log"
+
+#define M_STARTDEVICES        "MUTILS","DEVICES"
+#define M_STARTDEVICE_ID      "Device%ld"
+
+#define M_INTERNAL_DEV        (M_MAX_DEVICES +1)
+#define M_SHUTDOWN            0xF0000001
+
+/* exported functions ********************************************************/
+
+EXPORT mTrace&    trc                ();
+EXPORT char      *remoteTrace        ();
+EXPORT char      *traceDevice        ();
+EXPORT HMTX       traceSem           ();
+EXPORT HMTX       sharedMemSem       ();
+EXPORT APIRET     SysComInit         ();
+EXPORT void       SysComTerm         ();
+EXPORT long       SysComDevices      ();
+EXPORT long       startHttp          ();
+EXPORT void       stopHttp           ();
+EXPORT long       startFTP           ();
+EXPORT void       stopFTP            ();
+EXPORT long       lswap              (long);
+EXPORT void       shutdownServices   ();
+EXPORT bool       servicesInShutDown ();
+EXPORT long       mRebootRemote      (BYTE,char *,SHORT,char *,bool);
+EXPORT void       addLog             (BYTE bLevel,char *pszFile,SHORT sLine,char *pszFunction,char *pszFormat,...);
+EXPORT long       currentProcessId   ();
+
+
+/* external definitions ******************************************************/
+
+IMPORT "C" int _CRT_init();         // runtime environment initialisation
+IMPORT "C" int _CRT_term();         // runtime environment deinitialisation
+IMPORT "C" void __ctordtorInit();   // for c++
+IMPORT "C" void __ctordtorTerm();   // for c++
+
+#endif /* GLOBBASE_HPP */
+
+/******************************************************************************
+ END OF FILE
+******************************************************************************/
diff --git a/Massai/cpp/MassaiDLL/dll/inc/local_def.h b/Massai/cpp/MassaiDLL/dll/inc/local_def.h
new file mode 100644
index 00000000..b177811b
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/dll/inc/local_def.h
@@ -0,0 +1,27 @@
+/*! \mainpage massaiDll
+ *
+ *  @version 1.0.0.4
+ *
+ *  \section change1 Change history
+ *
+ *  \date 02.11.2006 \li V1.0.0.4
+ *                   \li SteT EDB 26725: massaiDLL schreibt NULL in die TraceDatei
+ *
+ *  \date 11.10.2006 \li V1.0.0.3
+ *                   \li SteT EDB 26546: Access Violation in massaiDLL
+ *
+ *  \date 26.09.2006 \li V1.0.0.2
+ *                   \li bugfix static dll searching and reading configfile (important for none massai platform)(PtM)
+ *                   \li Start release notes (PtM)
+ */
+
+
+#define FILE_VER_BIN     1,0,0,4
+#define FILE_VER_STR     "FileVersion", "1.0.0.4\0"
+
+#define FILEDESCRIPTION  "FileDescription"  ,"Massai utility dll\0"
+#define INTERNALNAME     "InternalName"     ,"Massai DLL\0"
+#define LEGALTRADEMARKS  "LegalTrademarks"  ,"\0"
+#define ORIGINALFILENAME "OriginalFilename" ,"massai.dll\0"
+
+
diff --git a/Massai/cpp/MassaiDLL/dll/inc/mConfig.h b/Massai/cpp/MassaiDLL/dll/inc/mConfig.h
new file mode 100644
index 00000000..b16bfa15
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/dll/inc/mConfig.h
@@ -0,0 +1,42 @@
+/***********************************************************************
+ *                           CMVC Information
+ *                           ----------------
+ * File, Component, Release   : SSDBASE/INC/CFGBASE.H, ATSA.SSD.BASE.SSDBASE.OS2, ATSA_SSDBASE.o1
+ * Version                    : 1.1
+ * Date of last Check-In      : 96/10/22, 16:21:31
+ * Date of last Access        : 96/12/10, 16:28:16
+ **********************************************************************/
+/****************************************************************************
+
+ FILE:      cfgbase.h
+
+ PURPOSE:   Header file.
+
+ DATE:      11/23/95 - 15:09:31
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+        
+#ifndef MCONFIG_H
+#define MCONFIG_H
+
+/* exported functions ******************************************************/
+
+#ifdef __cplusplus
+      extern "C" {
+#endif
+
+EXPORT APIRET mUtilsReadConfig  (VOID);
+EXPORT APIRET FreeConfiguration  (VOID); 
+EXPORT APIRET QueryMUtilsPath   (CHAR *); 
+
+#ifdef __cplusplus
+      }
+#endif
+
+#endif /* CFGBASE_H */
+
+/****************************************************************************
+ END OF FILE
+****************************************************************************/
diff --git a/Massai/cpp/MassaiDLL/dll/inc/mhandler.hpp b/Massai/cpp/MassaiDLL/dll/inc/mhandler.hpp
new file mode 100644
index 00000000..c85d96b5
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/dll/inc/mhandler.hpp
@@ -0,0 +1,215 @@
+//---------------------------------------------------------------------------
+//
+//  file:       handler.h
+//
+//  purpose:    handler class definition
+//
+//  date:       28.09.99, 08:47
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+#ifndef HANDLER_H
+#define HANDLER_H
+
+//#pragma message("include: " __FILE__ )
+
+#include <iostream>
+
+#include "massai.hpp"
+#include "mThread.hpp"
+
+class mHandler;
+
+
+class mEvent
+{
+private:
+
+    ULONG     ulId;
+    ULONG     ulParam1;
+    ULONG     ulParam2;
+    mHandler *pReceiver;
+
+public:
+
+    enum ME_ID
+    {
+      ME_SYSCOM   = 1,
+      ME_SELECT   = 2,
+      ME_ACTIVATE = 3,
+      ME_TIMER    = 4,
+      ME_COMMAND  = 5
+    };
+
+    mHandler *receiver()       { return(pReceiver); }
+
+    ULONG   id()               { return(ulId);      }
+
+    ULONG   param1()           { return(ulParam1); }
+    ULONG   param2()           { return(ulParam2); }
+
+    SHORT   short11()          { return((SHORT) ulParam1 & 0x0000ffff      ); }
+    SHORT   short12()          { return((SHORT) ulParam1 & 0xffff0000 >> 16); }
+    SHORT   short21()          { return((SHORT) ulParam2 & 0x0000ffff      ); }
+    SHORT   short22()          { return((SHORT) ulParam2 & 0xffff0000 >> 16); }
+
+    USHORT  ushort11()         { return((USHORT) short11()); }
+    USHORT  ushort12()         { return((USHORT) short12()); }
+    USHORT  ushort21()         { return((USHORT) short21()); }
+    USHORT  ushort22()         { return((USHORT) short22()); }
+
+    VOID   *pointer1()         { return( (CHAR *) ulParam1 ); }
+    VOID   *pointer2()         { return( (CHAR *) ulParam2 ); }
+
+    // for COMMAND events -----------------------------------------------------
+
+    ULONG   cmd()               { return( param1() ); }
+
+    // for CONTROL events -----------------------------------------------------
+
+    ULONG   ctrlId()            { return( param1()    ); }
+    ULONG   notificationCode()  { return( id()        ); }
+    ULONG   controlData()       { return( param2()    ); }
+
+    // for CHAR events --------------------------------------------------------
+
+    USHORT  keyFlags()          { return(         ushort22() ); }
+    BYTE    scanCode()          { return((BYTE)   ushort21() ); }
+    USHORT  virtualKey()        { return((USHORT) param1()   ); }
+
+    //BOOL    isUpKey()           { return( keyFlags() & KC_KEYUP); };
+    //USHORT  character()         { return( (id() == WM_CHAR)?param1():0); };
+
+    // for TIMER events -------------------------------------------------------
+
+    USHORT timerID()             { return(ushort11()); }
+
+    // for BUTTON events ------------------------------------------------------
+
+    USHORT button()              { return( ushort11() ); }
+    USHORT buttonX()             { return( ushort21() ); }
+    USHORT buttonY()             { return( ushort22() ); }
+
+    // for CSC-ACTIVATE events ------------------------------------------------
+
+    BOOL   activated()           { return((BOOL) ushort11() ); }
+
+    // for CSC-LANGUAGE events ------------------------------------------------
+
+    ULONG  language()            { return( param1() ); }
+
+    // constructors -----------------------------------------------------------
+
+    mEvent(ME_ID id, ULONG mp1, ULONG mp2)
+    {
+      ulId      = id;
+      ulParam1  = mp1;
+      ulParam2  = mp2;
+    };
+
+    mEvent(const mHandler& hwnd, ME_ID id, ULONG mp1, ULONG mp2)
+    {
+      ulId      = id;
+      ulParam1  = mp1;
+      ulParam2  = mp2;
+    };
+
+    mEvent(mHandler* pRecv, ME_ID id, ULONG mp1, ULONG mp2)
+    {
+      ulId      = id;
+      ulParam1  = mp1;
+      ulParam2  = mp2;
+      pReceiver = pRecv;
+    };
+
+    // destructor -------------------------------------------------------------
+
+    ~mEvent() {};
+};
+
+class mHandler
+{
+private:
+
+       static mThread *pPoster;
+       static ULONG      ulCnt;
+       static ULONG      ulLanguage;
+
+       ULONG     ulId;
+       ULONG     ulMillis;
+       BOOL      fTimerStopped;
+       mHandler* pOwner;
+
+       mThread *pTimer;
+
+public:
+
+              BOOL       timerStopped        ()           { return(fTimerStopped); }
+              ULONG      millis              ()           { return(ulMillis);      }
+              VOID       setId               (ULONG ulId) { this->ulId = ulId;     }
+
+              VOID       startTimer          (ULONG ulMillis);
+              VOID       stopTimer           ();
+              VOID       setLanguage         (ULONG ulId) { ulLanguage = ulId;     }
+              ULONG      getLanguage         ()           { return(ulLanguage);    }
+
+              VOID       enableCancel        ()           { std::cout << "CANCEL = ON" << std::endl; }
+              VOID       enableOk            ()           { std::cout << "OK     = ON" << std::endl; }
+              VOID       enableContinue      ()           { std::cout << "CONT   = ON" << std::endl; }
+              VOID       enableBack          ()           { std::cout << "BACK   = ON" << std::endl; }
+              VOID       enableLang          ()           { std::cout << "LANG   = ON" << std::endl; }
+              VOID       enableHelp          ()           { std::cout << "HELP   = ON" << std::endl; }
+
+              VOID       setText             (CHAR *pStr) { std::cout << pStr << std::endl;               }
+              VOID       setText             (ULONG ulId) { std::cout << "textID = "<< ulId << std::endl; }
+
+              CHAR      *resourceText        (ULONG ulId)
+              {
+                static CHAR szTmp[50];
+
+                sprintf(szTmp,"RES-STR: %d : ",ulId);
+                return(szTmp);
+              }
+
+              mHandler*  handle              ()                            { return(this);}
+
+              ULONG      sendEvent           (mEvent event)                { return(0);   }
+              ULONG      sendEvent           (mHandler& to,  mEvent event) { return(0);   }
+              ULONG      sendEvent           (mHandler* pTo, mEvent event) { return(0);   }
+
+              BOOL       postEvent           (mEvent event);
+              BOOL       postEvent           (mHandler* pTo, mEvent event);
+
+              VOID       activate            ();
+              VOID       deactivate          ();
+
+      virtual CHAR      *name                () { return("internal handler"); };
+
+      virtual BOOL       commandHandler      (mEvent& event) { return(FALSE); };
+      virtual BOOL       controlHandler      (mEvent& event) { return(FALSE); };
+      virtual BOOL       activateHandler     (mEvent& event) { std::cout << "mHandler::ACTIVATE handler" << std::endl; return(FALSE); };
+      virtual BOOL       timerHandler        (mEvent& event) { return(FALSE); };
+      virtual BOOL       syscomHandler       (mEvent& event) { return(FALSE); };
+
+      // need these handlers ??
+
+      virtual BOOL       ctrlCommandHandler  (mEvent& event) { return(FALSE); };
+      virtual BOOL       charHandler         (mEvent& event) { return(FALSE); };
+      virtual BOOL       languageHandler     (mEvent& event) { return(FALSE); };
+      virtual BOOL       createHandler       (mEvent& event) { return(TRUE);  };
+      virtual BOOL       defaultHandler      (mEvent& event) { return(FALSE); };
+      virtual BOOL       buttonUpHandler     (mEvent& event) { return(FALSE); };
+      virtual BOOL       buttonDownHandler   (mEvent& event) { return(FALSE); };
+      virtual BOOL       buttonDoubleHandler (mEvent& event) { return(FALSE); };
+      virtual BOOL       mouseMoveHandler    (mEvent& event) { return(FALSE); };
+      virtual BOOL       touchHandler        (mEvent& event) { return(FALSE); };
+
+               mHandler(mHandler* pOwner);
+               mHandler();
+              ~mHandler();
+};
+
+
+#endif // HANDLER_H
\ No newline at end of file
diff --git a/Massai/cpp/MassaiDLL/dll/inc/mvsprintf.h b/Massai/cpp/MassaiDLL/dll/inc/mvsprintf.h
new file mode 100644
index 00000000..ac24d892
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/dll/inc/mvsprintf.h
@@ -0,0 +1,25 @@
+//---------------------------------------------------------------------------
+//
+//  file:       mvsprintf.h
+//
+//  purpose:    function prototypes
+//
+//  date:       14.03.2003, 12:44
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+#ifndef MVSPRINTF_H
+#define MVSPRINTF_H
+
+int m_vsnprintf(char *buf, size_t size, const char *fmt, va_list args);
+int m_vsprintf(char *buf, const char *fmt, va_list args);
+
+int m_snprintf(char * buf, size_t size, const char *fmt, ...);
+int m_sprintf(char * buf, const char *fmt, ...);
+
+int m_vsscanf(const char * buf, const char * fmt, va_list args);
+int m_sscanf(const char * buf, const char * fmt, ...);
+
+#endif // MVSPRINTF_H
\ No newline at end of file
diff --git a/Massai/cpp/MassaiDLL/dll/res/FileVersion.rc b/Massai/cpp/MassaiDLL/dll/res/FileVersion.rc
new file mode 100644
index 00000000..499889d1
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/dll/res/FileVersion.rc
@@ -0,0 +1,108 @@
+//Microsoft Developer Studio generated resource script.
+//
+// #include "resource.h"
+#include "Global_def.h"
+#include "local_def.h"
+
+#define APSTUDIO_READONLY_SYMBOLS
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 2 resource.
+//
+#include "afxres.h"
+
+/////////////////////////////////////////////////////////////////////////////
+#undef APSTUDIO_READONLY_SYMBOLS
+
+/////////////////////////////////////////////////////////////////////////////
+// German (Germany) resources
+
+#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_DEU)
+#ifdef _WIN32
+LANGUAGE LANG_GERMAN, SUBLANG_GERMAN
+#pragma code_page(1252)
+#endif //_WIN32
+
+#ifndef _MAC
+/////////////////////////////////////////////////////////////////////////////
+//
+// Version
+//
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION FILE_VER_BIN
+ PRODUCTVERSION PRODUCT_VER_BIN
+ FILEFLAGSMASK 0x3fL
+#ifdef _DEBUG
+ FILEFLAGS 0x1L
+#else
+ FILEFLAGS 0x0L
+#endif
+ FILEOS 0x40004L
+ FILETYPE 0x2L
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040704b0"
+        BEGIN
+            VALUE COMPANY
+			VALUE FILEDESCRIPTION
+			VALUE FILE_VER_STR
+			VALUE INTERNALNAME
+			VALUE COPYRIGHT
+			VALUE LEGALTRADEMARKS
+			VALUE ORIGINALFILENAME
+			VALUE PRODUCT
+            VALUE PRODUCT_VER_STR 
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x407, 1200
+    END
+END
+
+#endif    // !_MAC
+
+
+#ifdef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// TEXTINCLUDE
+//
+
+1 TEXTINCLUDE DISCARDABLE
+BEGIN
+    "resource.h\0"
+END
+
+2 TEXTINCLUDE DISCARDABLE
+BEGIN
+    "#include ""afxres.h""\r\n"
+    "\0"
+END
+
+3 TEXTINCLUDE DISCARDABLE
+BEGIN
+    "\r\n"
+    "\0"
+END
+
+#endif    // APSTUDIO_INVOKED
+
+#endif    // German (Germany) resources
+/////////////////////////////////////////////////////////////////////////////
+
+
+
+#ifndef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 3 resource.
+//
+
+
+/////////////////////////////////////////////////////////////////////////////
+#endif    // not APSTUDIO_INVOKED
+
diff --git a/Massai/cpp/MassaiDLL/dll/src/NT_MXSEM.cpp b/Massai/cpp/MassaiDLL/dll/src/NT_MXSEM.cpp
new file mode 100644
index 00000000..9201cf59
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/dll/src/NT_MXSEM.cpp
@@ -0,0 +1,67 @@
+// -------------------------------------------------------------------
+//
+// NT_MXSEM.CPP
+//
+// This module contains os dependent api functions
+//
+// Dr. Materna GmbH - JK - 1997
+//
+// -------------------------------------------------------------------
+
+#include "mutex.hpp"
+
+#include "windows.h"
+
+#define PRIVATE static
+
+PRIVATE int nextid = 0;
+
+mutexSemaphore::mutexSemaphore()
+{
+   iID = ++nextid;
+   hMS = (unsigned long)CreateMutex( 0, 0, 0 );
+}
+
+mutexSemaphore::mutexSemaphore(const char* const szName)
+{
+   iID = ++nextid;
+   hMS = (unsigned long)CreateMutex( 0, 0, szName);
+}
+
+
+mutexSemaphore::~mutexSemaphore()
+{
+   CloseHandle( (HANDLE)hMS );
+}
+
+/* rb141197
+** result:
+** 0 on success ( erg == WAIT_OBJECT_0)
+*/
+int mutexSemaphore::request()
+{
+   long erg = WaitForSingleObject( (HANDLE)hMS, INFINITE );
+   ++iOwn;
+   return (erg != WAIT_OBJECT_0)? 0: erg;
+}
+
+int mutexSemaphore::request(long Time)
+{
+   long erg = WaitForSingleObject( (HANDLE)hMS, Time );
+   ++iOwn;
+   return (erg != WAIT_OBJECT_0)? 0: erg;
+}
+
+
+/* rb141197
+** result:
+** 0 on success ( release returns != 0)
+*/
+int mutexSemaphore::release()
+{
+   --iOwn;
+   if(ReleaseMutex( (HANDLE)hMS ) == 0)
+     return GetLastError();
+   return (0);
+}
+
diff --git a/Massai/cpp/MassaiDLL/dll/src/base_os.cpp b/Massai/cpp/MassaiDLL/dll/src/base_os.cpp
new file mode 100644
index 00000000..bc21f801
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/dll/src/base_os.cpp
@@ -0,0 +1,1177 @@
+/******************************************************************************
+
+ FILE:      base_os.cpp
+
+ PURPOSE:   OS system definitions
+
+ DATE:      01/10/97 - 23:00:00
+
+ AUTHOR:    Dr. Materna GmbH   (MaK)
+
+******************************************************************************/
+
+#include <winsock2.h>
+#include <signal.h>
+#include <stdio.h>
+#include <process.h>
+
+#include "base_os.h"
+
+/* shared memory block *******************************************************/
+
+#define SHMEMSIZE   240L * 1024L
+#define MAX_SOCKETS 256
+
+extern HMTX socketSem(VOID);
+
+BYTE abSharedMem[SHMEMSIZE];
+int  aSockets   [MAX_SOCKETS];
+BOOL bSocketReset = TRUE;
+int  iLock = 0;
+
+#define SHOWARRAY \
+{ \
+int n; \
+ \
+    for(n = 0; n < MAX_SOCKETS; n++) \
+      printf("%04d ",aSockets[n]); \
+ \
+    printf("\n"); \
+}
+
+APIRET OS_Open               (PSZ     FileName,
+                              PHFILE  FileHandle,
+                              PULONG  ActionTaken,
+                              ULONG   FileSize,
+                              ULONG   FileAttribute,
+                              ULONG   OpenFlag,
+                              ULONG   OpenMode,
+                              PEAOP2  EABuf)
+{
+HANDLE hFile;
+
+  if(EABuf)
+    memset(EABuf,0,sizeof(EAOP2));
+
+  hFile = CreateFile((LPCTSTR)FileName,
+                     GENERIC_WRITE | GENERIC_READ,
+                     FILE_SHARE_READ | FILE_SHARE_WRITE,
+                     (LPSECURITY_ATTRIBUTES)NULL,
+                     OPEN_ALWAYS, // | CREATE_NEW,
+                     FILE_ATTRIBUTE_ARCHIVE,
+                     (HANDLE)NULL);
+
+  *ActionTaken=(ULONG)NULL;
+  *FileHandle=(HFILE)hFile;
+
+  if(hFile)
+    return(0);
+  else
+    return(GetLastError());
+}
+
+APIRET OS_Close              (HFILE   FileHandle)
+{
+  if(!CloseHandle((HANDLE)FileHandle))
+    return(GetLastError());
+  else
+    return(0);
+}
+
+APIRET OS_Write              (HFILE   FileHandle,
+                              PVOID   BufferArea,
+                              ULONG   BufferLength,
+                              PULONG  BytesWritten)
+{
+static DWORD dwBytesWritten;
+
+  if (WriteFile((HANDLE)  FileHandle,
+                (LPCVOID) BufferArea,
+                (DWORD)   BufferLength,
+                &dwBytesWritten,
+                (LPOVERLAPPED)NULL))
+  {
+    *BytesWritten = (ULONG)dwBytesWritten;
+    return(0);
+  }
+  else
+    return(GetLastError());
+}
+
+APIRET OS_Read               (HFILE   FileHandle,
+                              PVOID   BufferArea,
+                              ULONG   BufferLength,
+                              PULONG  BytesRead)
+{
+static DWORD dwBytesRead;
+
+  if(ReadFile((HANDLE) FileHandle,
+              (LPVOID) BufferArea,
+              (DWORD)  BufferLength,
+              &dwBytesRead,
+              (LPOVERLAPPED)NULL))
+  {
+    *BytesRead = (ULONG)dwBytesRead;
+
+    if(!dwBytesRead)
+      return(-1);
+    else
+      return(0);
+  }
+  else
+    return(GetLastError());
+}
+
+APIRET OS_Delete             (PSZ     FileName)
+{
+  if(DeleteFile((LPCTSTR)FileName))
+    return(0);
+  else
+    return(GetLastError());
+}
+
+APIRET OS_Move               (PSZ     OldPathName,
+                              PSZ     NewPathName)
+{
+  if(MoveFile((LPCTSTR)OldPathName,(LPCTSTR)NewPathName))
+    return(0);
+  else
+    return(GetLastError());
+}
+
+APIRET OS_MkDir              (PSZ     szName,
+                              ULONG   ulFlag)
+{
+SECURITY_ATTRIBUTES sec_attr;
+
+  sec_attr.nLength=sizeof(SECURITY_ATTRIBUTES);
+  sec_attr.lpSecurityDescriptor=NULL;
+  sec_attr.bInheritHandle=FALSE;
+
+  if(CreateDirectory((LPCTSTR)szName,&sec_attr))
+    return(0);
+  else
+    return(GetLastError());
+}
+
+APIRET OS_SetFilePtr         (HFILE   FileHandle,
+                              LONG    Distance,
+                              ULONG   MoveType,
+                              PULONG  NewPointer)
+{
+DWORD dwFileSize;
+
+  dwFileSize = SetFilePointer((HANDLE)FileHandle,
+                              Distance,
+                              (PLONG)NULL,
+                              MoveType);
+
+  if(dwFileSize==0xFFFFFFFF)
+  {
+    *NewPointer=(ULONG)NULL;
+    return(GetLastError());
+  }
+  else
+  {
+    *NewPointer=(ULONG)dwFileSize;
+
+    return(0);
+  }
+}
+
+APIRET OS_DevIOCtl           (HFILE   DevHandle,
+                              ULONG   Category,
+                              ULONG   Function,
+                              PVOID   ParmList,
+                              ULONG   ParmLengthMax,
+                              PULONG  ParmLengthInOut,
+                              PVOID   DataArea,
+                              ULONG   DataLengthMax,
+                              PULONG  DataLengthInOut)
+{
+  return 0;
+}
+
+APIRET OS_DupHandle          (HFILE   OldFileHandle,
+                              PHFILE  NewFileHandle)
+{
+// not needed ???
+// see NT.DuplicateHandle
+  return 0;
+}
+
+APIRET OS_Error              (ULONG   Flags)
+{
+  return 0;
+}
+
+APIRET OS_Exit               (ULONG   ActionCode,
+                              ULONG   ResultCode)
+{
+  switch(ActionCode)
+  {
+  case EXIT_PROCESS:
+    ExitProcess((UINT)ResultCode);
+    break;
+  case EXIT_THREAD:
+    //ExitThread((UINT)ResultCode);
+    _endthread();
+    break;
+  }
+  return 0;
+}
+
+APIRET OS_ExitList           (ULONG       FunctionOrder,
+                              PFNEXITLIST RtnAddress)
+{
+  return 0;
+}
+
+APIRET OS_GetDateTime        (PDATETIME   pDateTime)
+{
+static SYSTEMTIME systemtime;
+
+  GetLocalTime(&systemtime);
+
+  pDateTime->hours      = (UCHAR) systemtime.wHour;
+  pDateTime->minutes    = (UCHAR) systemtime.wMinute;
+  pDateTime->seconds    = (UCHAR) systemtime.wSecond;
+  pDateTime->hundredths = (UCHAR) (systemtime.wMilliseconds/10);
+  pDateTime->day        = (UCHAR) systemtime.wDay;
+  pDateTime->month      = (UCHAR) systemtime.wMonth;
+  pDateTime->year       = (USHORT)systemtime.wYear;
+  pDateTime->timezone   = (SHORT) 0;
+  pDateTime->weekday    = (UCHAR) systemtime.wDayOfWeek;
+
+  return 0;
+}
+
+APIRET OS_SetDateTime        (PDATETIME   pDateTime)
+{
+static SYSTEMTIME systemtime;
+
+  memset(&systemtime,0,sizeof(SYSTEMTIME));
+
+  systemtime.wHour              = (WORD) pDateTime->hours;
+  systemtime.wMinute            = (WORD) pDateTime->minutes;
+  systemtime.wSecond            = (WORD) pDateTime->seconds;
+  systemtime.wMilliseconds      = (WORD) pDateTime->hundredths*10;
+  systemtime.wDay               = (WORD) pDateTime->day;
+  systemtime.wMonth             = (WORD) pDateTime->month;
+  systemtime.wYear              = (WORD) pDateTime->year;
+  systemtime.wDayOfWeek         = (WORD) pDateTime->weekday;
+
+  SetLocalTime(&systemtime);
+
+  return 0;
+}
+
+APIRET OS_GetInfoBlocks      (PTIB *  ptib,
+                              PPIB *  ppib)
+{
+static pib_s pib;
+
+  pib.pib_ulpid = GetCurrentProcessId();
+
+  *ppib = &pib;
+  return 0;
+}
+
+// semaphor functions ---------------------------------------------------------
+
+APIRET OS_CreateMutexSem     (PSZ     Name,
+                              PHMTX   phmtx,
+                              ULONG   flAttr,
+                              BOOL    fState)
+{
+CHAR szName[MAX_PATH];
+CHAR *szTmp;
+
+SECURITY_ATTRIBUTES sec_attr;
+
+  sec_attr.nLength=sizeof(SECURITY_ATTRIBUTES);
+  sec_attr.lpSecurityDescriptor=NULL;
+  sec_attr.bInheritHandle=TRUE;
+
+  if(Name)
+  {
+    if((szTmp=strrchr(Name,'\\'))!=(CHAR*)NULL)
+      strcpy(szName,(szTmp +1));
+    else
+      strcpy(szName,Name);
+  }
+  else
+    memset((VOID*)szName,0,MAX_PATH);
+
+  *phmtx = (HMTX)CreateMutex((LPSECURITY_ATTRIBUTES)&sec_attr,
+                            fState,
+                            (LPCTSTR)szName);
+
+  if(*phmtx)
+    return (APIRET)0;
+  else
+    return(GetLastError());
+}
+
+APIRET OS_CloseMutexSem      (HMTX    hmtx)
+{
+APIRET rc = 0;
+
+  try
+  {
+    CloseHandle((HANDLE)hmtx);
+  }
+  catch(...)
+  {
+    rc = GetLastError();
+  }
+
+  return(rc);
+}
+
+APIRET OS_RequestMutexSem    (HMTX    hmtx,
+                              ULONG   Timeout)
+{
+DWORD dwRc;
+
+  dwRc = WaitForSingleObject((HANDLE)hmtx,(DWORD)Timeout);
+
+  switch(dwRc)
+  {
+  case WAIT_FAILED:
+    return 1;
+  case WAIT_ABANDONED:
+  case WAIT_OBJECT_0:
+    return 0;
+  case WAIT_TIMEOUT:
+    return 1;
+  default:
+    return 1;
+  }
+}
+
+APIRET OS_OpenMutexSem       (PSZ     Name,
+                              PHMTX   phmtx)
+{
+HANDLE hmtx;
+CHAR szName[MAX_PATH];
+CHAR *szTmp;
+
+  if((szTmp=strrchr(Name,'\\'))!=(CHAR*)NULL)
+    strcpy(szName,(szTmp + 1));
+  else
+    strcpy(szName,Name);
+
+  hmtx=OpenMutex(SYNCHRONIZE,
+                 TRUE,
+                 (LPCTSTR)szName);
+
+
+  if(hmtx)
+  {
+    *phmtx = hmtx;
+    return(0);
+  }
+  else
+    return((APIRET) GetLastError());
+}
+
+APIRET OS_ReleaseMutexSem    (HMTX    hmtx)
+{
+  return (APIRET)ReleaseMutex((HANDLE)hmtx);
+}
+
+APIRET MASSAI_DLLEXPORT OS_CreateEventSem     (PSZ    Name,
+                                      PHEV   pHev,
+                                      ULONG  ulFlags,
+                                      BOOL bState)
+{
+CHAR szName[MAX_PATH];
+CHAR *szTmp;
+
+  if(Name && Name[0])
+  {
+    if((szTmp=strrchr(Name,'\\'))!=(CHAR*)NULL)
+      strcpy(szName,(szTmp + 1));
+    else
+      strcpy(szName,Name);
+
+    *pHev=(HEV)CreateEvent((LPSECURITY_ATTRIBUTES)NULL,
+                           TRUE,
+                           bState,
+                           (LPCTSTR)szName);
+  }
+  else
+  {
+    *pHev=(HEV)CreateEvent((LPSECURITY_ATTRIBUTES)NULL,
+                           TRUE,
+                           bState,
+                           (LPCTSTR)Name);
+  }
+
+  if(*pHev)
+    return (APIRET)0;
+  else
+    return(GetLastError());
+}
+
+APIRET MASSAI_DLLEXPORT OS_OpenEventSem       (PSZ    Name,
+                                      PHEV   pHev)
+{
+CHAR szName[MAX_PATH];
+CHAR *szTmp;
+
+  if(Name && Name[0])
+  {
+    if((szTmp=strrchr(Name,'\\'))!=(CHAR*)NULL)
+      strcpy(szName,(szTmp + 1));
+    else
+      strcpy(szName,Name);
+
+    *pHev=(HEV)OpenEvent(EVENT_ALL_ACCESS,
+                         FALSE,
+                         (LPCTSTR)szName);
+  } else
+  {
+    *pHev=(HEV)OpenEvent(EVENT_ALL_ACCESS,
+                         FALSE,
+                         (LPCTSTR)Name);
+  }
+  if(*pHev)
+    return (APIRET)0;
+  else
+    return(GetLastError());
+}
+
+APIRET MASSAI_DLLEXPORT OS_CloseEventSem      (HEV    hev)
+{
+APIRET rc = 0;
+
+  try
+  {
+    CloseHandle((HANDLE)hev);
+  }
+  catch(...)
+  {
+    rc = GetLastError();
+  }
+
+  return(rc);
+}
+
+APIRET MASSAI_DLLEXPORT OS_ResetEventSem      (HEV    hev,
+                                      PULONG pulPostCount)
+{
+  *pulPostCount = 0;
+  return(APIRET)(ResetEvent((HANDLE)hev)!=NULL);
+}
+
+APIRET MASSAI_DLLEXPORT OS_PostEventSem       (HEV    hev)
+{
+  return(APIRET)(SetEvent((HANDLE)hev)!=NULL);
+}
+
+APIRET MASSAI_DLLEXPORT OS_WaitEventSem       (HEV    hev,
+                                      ULONG  ulTimeout)
+{
+DWORD dwRc;
+
+  dwRc = WaitForSingleObject((HANDLE)hev,(DWORD)ulTimeout);
+  switch(dwRc)
+  {
+  case WAIT_FAILED:
+    return 1;
+  case WAIT_ABANDONED:
+  case WAIT_OBJECT_0:
+    return 0;
+  case WAIT_TIMEOUT:
+    return 1;
+  default:
+    return 1;
+  }
+}
+
+APIRET MASSAI_DLLEXPORT OS_QeueryEventSem     (HEV    hev,
+                                      PULONG pulPostCount)
+{
+
+DWORD dwRc;
+
+  dwRc = WaitForSingleObject((HANDLE)hev,(DWORD)NULL);
+  switch(dwRc)
+  {
+  case WAIT_FAILED:
+    *pulPostCount = 0;
+    break;
+  case WAIT_ABANDONED:
+  case WAIT_OBJECT_0:
+    *pulPostCount = 1;
+    break;
+  case WAIT_TIMEOUT:
+    *pulPostCount = 0;
+    break;
+  default:
+    *pulPostCount = 0;
+    break;
+  }
+  return (APIRET)!*pulPostCount;
+}
+
+
+// shared memory functions ----------------------------------------------------
+#if 0
+APIRET OS_AllocSharedMem     (PPVOID  ppBaseAddress,
+                              PSZ     pszName,
+                              ULONG   cbObjectSize,
+                              ULONG   Flags)
+{
+  *ppBaseAddress = (VOID*)abSharedMem;
+  eg_sm_init((CHAR *)abSharedMem,(CHAR *)(abSharedMem + SHMEMSIZE));
+  return 0;
+}
+
+APIRET OS_FreeMem            (PVOID   baseAddress)
+{
+  // do nothing, memory block is freed when unloading ssdbase.dll
+  return 0;
+}
+
+APIRET OS_GetNamedSharedMem  (PPVOID  ppBaseAddress,
+                              PSZ     ASharedMemName,
+                              ULONG   AttributeFlags)
+{
+  *ppBaseAddress = (VOID*)abSharedMem;
+  return 0;
+}
+
+APIRET OS_SubSetMem          (PVOID   Offset,
+                              ULONG   Flags,
+                              ULONG   Size)
+{
+  return 0;
+}
+
+APIRET OS_SubUnsetMem        (PVOID   Offset)
+{
+  return 0;
+}
+
+APIRET OS_SubAllocMem        (PVOID   Offset,
+                              PPVOID  ppBlockOffset,
+                              ULONG   ulSize)
+{
+  *ppBlockOffset = eg_malloc(ulSize);
+  return 0;
+}
+
+APIRET OS_SubFreeMem         (PVOID   Offset,
+                              PVOID   pBlockOffset,
+                              ULONG   Size)
+{
+  eg_free(pBlockOffset);
+  return 0;
+}
+#endif
+
+// thread & process functions -------------------------------------------------
+
+APIRET OS_CreateThread       (PTID      ThreadID,
+                              PFNTHREAD ThreadAddr,
+                              ULONG     ThreadArg,
+                              ULONG     ThreadFlags,
+                              ULONG     StackSize)
+{
+DWORD dwCreationFlag = 0;
+
+#if 0
+
+HANDLE   hTID;
+
+// don't use windows create thread function because of
+// memory leackage
+//
+  hTID = CreateThread((LPSECURITY_ATTRIBUTES)NULL,
+                     (DWORD) StackSize,
+                     (LPTHREAD_START_ROUTINE) ThreadAddr,
+                     (LPVOID) ThreadArg,
+                     (DWORD)ThreadFlags,
+                     &dwThreadID);
+
+  // The handle returned by CreateThread is converted into
+  // TID in OS/2 notation because the handle is needed
+  // for killing the thread!
+
+  *ThreadID = (TID)hTID;
+
+  return (APIRET)(hTID == (HANDLE)-1);
+
+#else
+
+int   hTID;
+
+  hTID = _beginthread( (PFNTHREAD_ROUTINE) ThreadAddr,
+                        StackSize,
+                        (VOID *) ThreadArg);
+
+  // The handle returned by CreateThread is converted into
+  // TID in OS/2 notation because the handle is needed
+  // for killing the thread!
+
+  *ThreadID = (TID)hTID;
+
+  return (APIRET)(hTID == -1);
+
+#endif
+
+}
+
+APIRET OS_KillThread         (TID     ThreadID)
+{
+BOOL fSuccess;
+
+  if(SuspendThread((HANDLE)ThreadID) == -1)
+  {
+    return (GetLastError());
+  }
+
+  fSuccess = TerminateThread((HANDLE)ThreadID,(DWORD)NULL);
+  CloseHandle((HANDLE)ThreadID);
+  if(fSuccess)
+    return 0;
+  else
+    return (GetLastError());
+}
+
+APIRET MASSAI_DLLEXPORT OS_ResumeThread(TID ThreadID)
+{
+ULONG ulRc;
+  ulRc = ResumeThread((HANDLE)ThreadID);
+  if(ulRc == 0xffffffff)
+    return (GetLastError());
+  else
+    return 0;
+}
+
+APIRET MASSAI_DLLEXPORT OS_SuspendThread(TID ThreadID)
+{
+ULONG ulRc;
+  ulRc = SuspendThread((HANDLE)ThreadID);
+  if(ulRc == 0xffffffff)
+    return (GetLastError());
+  else
+    return 0;
+}
+
+APIRET OS_Sleep              (ULONG   TimeInterval)
+{
+  Sleep((DWORD)TimeInterval);
+  return (APIRET)NULL;
+}
+
+APIRET OS_SetPriority        (ULONG   Scope,
+                              ULONG   PriorityClass,
+                              LONG    PriorityDelta,
+                              ULONG   ID)
+{
+BOOL fSuccess;
+
+  switch(PriorityDelta)
+  {
+  case PRTYC_TIMECRITICAL:
+  case THREAD_PRIORITY_TIME_CRITICAL:
+
+       fSuccess = SetThreadPriority((HANDLE) ID, THREAD_PRIORITY_TIME_CRITICAL);
+       break;
+
+  default:
+
+       fSuccess = SetThreadPriority((HANDLE) ID, THREAD_PRIORITY_NORMAL);
+       break;
+  }
+
+  if(fSuccess)
+    return(0);
+  else
+    return(GetLastError()) ;
+}
+
+APIRET MASSAI_DLLEXPORT OS_WaitThread         (PTID  pTid,
+                                      ULONG ulTimeOut)
+{
+DWORD dwRc;
+
+  dwRc = WaitForSingleObject((HANDLE)*pTid,(DWORD)ulTimeOut);
+  switch(dwRc)
+  {
+  case WAIT_FAILED:
+    return 1;
+  case WAIT_ABANDONED:
+  case WAIT_OBJECT_0:
+    return 0;
+  case WAIT_TIMEOUT:
+    return 1;
+  default:
+    return 1;
+  }
+}
+
+APIRET OS_ExecWait(PSTARTDATA StartData,int iShow)
+{
+STARTUPINFO         si;
+PROCESS_INFORMATION pi;
+BOOL                rc;
+CHAR                szPgmName[512];
+
+    memset(&si,0,sizeof(STARTUPINFO));
+
+    si.cb = sizeof(STARTUPINFO);
+    si.dwFlags = STARTF_USESHOWWINDOW;
+
+    switch(iShow)
+    {
+    case PROCESS_SHOW:      si.wShowWindow = SW_SHOW;          break;
+    case PROCESS_MINIMIZED: si.wShowWindow = SW_SHOWMINIMIZED; break;
+    default:                si.wShowWindow = SW_HIDE;          break;
+    }
+
+    strcpy(szPgmName,StartData->PgmName);
+    strcat(szPgmName," ");
+    strcat(szPgmName,(CHAR*)StartData->PgmInputs);
+
+    rc = CreateProcess((LPCTSTR)NULL,                  //
+                       (LPTSTR)szPgmName,              //
+                       (LPSECURITY_ATTRIBUTES)NULL,    // use default
+                       (LPSECURITY_ATTRIBUTES)NULL,    // use default
+                       FALSE,                          // don`t inherit handles
+                       0,                              // creation flags
+                       (LPVOID)NULL,                   // use parents env.
+                       (LPCTSTR)NULL,                  // use parents rootdir
+                       &si,
+                       &pi);
+    if(!rc)
+      return(GetLastError());
+    else
+    {
+      // wait for the process to terminate
+
+      WaitForSingleObject(pi.hProcess,INFINITE);
+
+      CloseHandle(pi.hThread);
+      CloseHandle(pi.hProcess);
+
+      return(0);
+    }
+}
+
+
+APIRET OS_StartSession       (PSTARTDATA StartData,
+                              PULONG     SessID,
+                              PPID       PID,
+                              HANDLE    *phProcess,
+                              int        iShow)
+{
+STARTUPINFO         si;
+PROCESS_INFORMATION pi;
+BOOL                rc;
+CHAR                szPgmName[512];
+
+    memset(&si,0,sizeof(STARTUPINFO));
+
+    si.cb      = sizeof(STARTUPINFO);
+    si.dwFlags = STARTF_USESHOWWINDOW;
+
+    switch(iShow)
+    {
+    case PROCESS_SHOW:      si.wShowWindow = SW_SHOW;          break;
+    case PROCESS_MINIMIZED: si.wShowWindow = SW_SHOWMINIMIZED; break;
+    default:                si.wShowWindow = SW_HIDE;          break;
+    }
+
+    strcpy(szPgmName,StartData->PgmName);
+    strcat(szPgmName," ");
+    strcat(szPgmName,(CHAR*)StartData->PgmInputs);
+
+    rc=CreateProcess((LPCTSTR)NULL,                  //
+                     (LPTSTR)szPgmName,              //
+                     (LPSECURITY_ATTRIBUTES)NULL,    // use default
+                     (LPSECURITY_ATTRIBUTES)NULL,    // use default
+                     FALSE,                          // don`t inherit handles
+                     0,                              // creation flags
+                     (LPVOID)NULL,                   // use parents env.
+                     (LPCTSTR)NULL,                  // use parents rootdir
+                     &si,
+                     &pi);
+
+    *SessID = *PID = pi.dwProcessId;
+
+    *phProcess = pi.hProcess;
+
+    return (APIRET)((*SessID==0)||(rc==FALSE));
+}
+
+APIRET OS_StopSession (ULONG TargetOption, HANDLE hProcess)
+{
+APIRET rc;
+
+  rc = (APIRET)(TerminateProcess(hProcess,(UINT)NULL) == FALSE);
+
+  CloseHandle(hProcess);
+
+  return rc;
+}
+
+// pipe & named pipe functions ------------------------------------------------
+
+APIRET OS_CreatePipe         (PHFILE  ReadHandle,
+                              PHFILE  WriteHandle,
+                              ULONG   PipeSize)
+{
+  return 0;
+}
+
+APIRET OS_CreateNPipe        (PSZ     FileName,
+                              PHPIPE  PipeHandle,
+                              ULONG   OpenMode,
+                              ULONG   PipeMode,
+                              ULONG   OutBufSize,
+                              ULONG   InBufSize,
+                              ULONG   TimeOut)
+{
+  return 0;
+}
+
+APIRET OS_ConnectNPipe       (HPIPE   Handle)
+{
+  return 0;
+}
+
+APIRET OS_DisConnectNPipe    (HPIPE   Handle)
+{
+  return 0;
+}
+
+// miscallaneous functions ----------------------------------------------------
+
+APIRET OS_FreeModule (HMODULE hmod)
+{
+   if(FreeLibrary(hmod))
+   {
+     CloseHandle((HANDLE)hmod);
+     return(0);
+   }
+   else
+   {
+     CloseHandle((HANDLE)hmod);
+     return(GetLastError());
+   }
+}
+
+APIRET OS_LoadModule (PSZ pszName,ULONG cbName,PSZ pszModName,PHMODULE phmod)
+{
+HINSTANCE hmod;
+
+   if((hmod = LoadLibrary((LPCTSTR) pszModName)) == NULL)
+   {
+     *phmod = (HMODULE) NULL;
+     return(GetLastError());
+   }
+   else
+   {
+     *phmod = (HMODULE) hmod;
+     return(0);
+   }
+
+}
+
+APIRET MASSAI_DLLEXPORT OS_LoadString(HMODULE hmod,long resourceId,PSZ pszBuffer,int iBufferSize)
+{
+APIRET rc;
+
+    rc = LoadString((HINSTANCE)hmod,resourceId,pszBuffer,iBufferSize);
+
+    if(!rc)
+      return(GetLastError());
+    else
+      return(0);
+}
+
+APIRET OS_QueryModuleHandle  (PSZ      ModName,
+                              PHMODULE pModHandle)
+{
+  *pModHandle = GetModuleHandle((LPCTSTR)ModName);
+
+  return (APIRET)(*pModHandle==(HMODULE)0);
+}
+
+APIRET OS_QueryModuleName    (HMODULE ModHandle,
+                              ULONG   BufferLength,
+                              PCHAR   NameBuffer)
+{
+DWORD dwLength;
+
+  dwLength = GetModuleFileName(ModHandle,(LPTSTR)NameBuffer,(DWORD)BufferLength);
+  return (APIRET)(dwLength == 0);
+}
+
+APIRET OS_QueryProcAddr(HMODULE hmod,ULONG ordinal,PSZ pszName,PFN* ppfn)
+{
+FARPROC pfn = NULL;
+
+   if((pfn = GetProcAddress(hmod,(LPCSTR) ordinal)) == NULL)
+     return(GetLastError());
+   else
+   {
+     *ppfn = pfn;
+     return(0);
+   }
+}
+
+APIRET OS_ScanEnv            (PCSZ    EnvVarName,
+                              PCSZ *  ResultPointer)
+{
+static CHAR  szEnvString[4096];
+DWORD dwCnt;
+
+  dwCnt = GetEnvironmentVariable((LPCTSTR)EnvVarName,
+                                 (LPTSTR)szEnvString,
+                                 sizeof(szEnvString));
+
+  *ResultPointer = szEnvString;
+
+  if(dwCnt)
+    return 0;
+  else
+    return 1;
+}
+
+APIRET OS_Beep               (ULONG   Frequency,
+                              ULONG   Duration)
+{
+  return (!Beep((DWORD)Frequency,(DWORD)Duration));
+}
+
+
+int sock_init()
+{
+int     rc;
+int     s;
+WSADATA wsaData;
+WORD    wVersionRequested = MAKEWORD(1,1);
+
+   if((s = socket(AF_INET,SOCK_STREAM, 0)) < 0)
+   {
+     if(WSAGetLastError() == WSANOTINITIALISED)
+     {
+       rc = WSAStartup(wVersionRequested,&wsaData);
+
+       rc == 0 ? rc = 1 : rc = -1;
+     }
+   }
+   else
+   {
+     rc = 0;
+
+     closesocket(s);
+   }
+
+   return(rc);
+}
+
+int ioctl(int s, int cmd, char *pData, int lendata)
+{
+  return ioctlsocket(s,cmd,(ULONG *)pData);
+}
+
+int newSocket (int domain, int type, int protocol)
+{
+#if defined (SADDAM)
+
+int  i;
+int  ns = 0;
+int  iFirstZero;
+BOOL fFound;
+
+    //printf("wait sem...\n");
+
+    OS_RequestMutexSem(socketSem(),-1L);
+
+    //printf("wait sem done.\n");
+
+    if(bSocketReset)
+    {
+      memset(aSockets,0,sizeof(aSockets));
+      bSocketReset = FALSE;
+    }
+
+    while(!ns)
+    {
+      ns = socket(domain,type,protocol);
+
+      if(ns < 0)
+      {
+        // break while loop on error
+
+        break;
+      }
+      else
+      {
+        // socket seems to be ok !!
+
+        //printf("new socket [%d]\n",ns);
+
+        for(i = 0, iFirstZero = 0, fFound = FALSE;
+            i < MAX_SOCKETS && !fFound;
+            i++                                   )
+        {
+          if(i == 0 && !aSockets[0])
+          {
+            aSockets[0] = ns;
+
+            //SHOWARRAY;
+
+            OS_ReleaseMutexSem(socketSem());
+
+            //printf("return socket[0]: %d\n",ns);
+
+            return(ns);
+          }
+
+          if(i && !iFirstZero && !aSockets[i])
+          {
+            // save index to first zero value !!
+
+            iFirstZero = i;
+          }
+
+          // socket already in use ??
+
+          fFound = (aSockets[i] == ns);
+        }
+
+        if(!fFound && i <= MAX_SOCKETS)
+        {
+          // save this socket !!
+
+          aSockets[iFirstZero] = ns;
+        }
+        else if(fFound && i <= MAX_SOCKETS)
+        {
+          // do nothing on a currently used socket !! -> get new one.
+
+          //printf("socket [%d] already in use.\n",ns);
+
+          ns = 0;
+        }
+        else
+        {
+          // close this socket and leave
+
+          closesocket(ns);
+
+          OS_ReleaseMutexSem(socketSem());
+
+          //printf("return socket[0]: %d\n",-1);
+
+          return(-1);
+        }
+      }
+    }
+
+    //SHOWARRAY;
+
+    OS_ReleaseMutexSem(socketSem());
+
+    //printf("return socket: %d\n",ns);
+
+    return(ns);
+
+#else
+
+   return(socket(domain,type,protocol));
+
+#endif // SADDAM
+}
+
+int soclose (int socket)
+{
+#if defined (SADDAM)
+
+int  i;
+int  rc;
+BOOL fFound;
+
+    OS_RequestMutexSem(socketSem(),-1L);
+
+    for(i = rc = 0, fFound = FALSE; i < MAX_SOCKETS && !fFound; i++)
+    {
+      if(aSockets[i] == socket)
+      {
+        fFound = TRUE;
+
+        rc = closesocket(socket);
+
+        aSockets[i] = 0;
+
+        //printf("free socket[%d], index %d\n",socket,i);
+      }
+    }
+
+    OS_ReleaseMutexSem(socketSem());
+
+    return(rc);
+
+#else
+
+    return(closesocket(socket));
+
+#endif // SADDAM
+}
+
+static void signal_process(int iSignal)
+{
+   raise(SIGTERM);
+
+   Sleep(500);
+}
+
+APIRET OS_FlagProcess(ULONG ulProcess,int iSignal)
+{
+DWORD  dwCreationFlag = 0;
+DWORD  dwThreadID     = 0;
+ULONG  ulCnt          = 0;
+HANDLE hProcess       = 0;
+HANDLE hTID           = 0;
+
+    hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,ulProcess);
+
+    if(hProcess)
+    {
+      hTID = CreateRemoteThread(hProcess,
+                                (LPSECURITY_ATTRIBUTES)NULL,
+                                0x1000,
+                                (LPTHREAD_START_ROUTINE) signal_process,
+                                NULL,
+                                0,
+                                &dwThreadID);
+
+      CloseHandle(hTID);
+      CloseHandle(hProcess);
+
+      hProcess = 0;
+    }
+
+    while((hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,ulProcess)) != 0 && ++ulCnt < 10)
+    {
+      CloseHandle(hProcess);
+      Sleep(200);
+    }
+
+    if(hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,ulProcess))
+    {
+      CloseHandle(hProcess);
+      return(-1);
+    }
+
+    return(0);
+}
+
diff --git a/Massai/cpp/MassaiDLL/dll/src/compress.cpp b/Massai/cpp/MassaiDLL/dll/src/compress.cpp
new file mode 100644
index 00000000..b41b2e59
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/dll/src/compress.cpp
@@ -0,0 +1,496 @@
+/***********************************************************************
+ *                           CMVC Information
+ *                           ----------------
+ * File, Component, Release   : MASSAIDLL/SRC/COMPRESS.CPP
+ * Version                    : 1.1
+ * Date of last Check-In      : 96/10/22, 16:20:57
+ * Date of last Access        : 96/12/10, 16:29:37
+ **********************************************************************/
+/****************************************************************************
+
+ FILE:      compress.c
+
+ PURPOSE:   file compressing / decompressing (LZW)
+
+ DATE:      21-Jan-1992
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+#define INCL_BASE
+
+#include "base_os.h"
+#include <stdio.h>
+#include <string.h>
+#include <malloc.h>
+
+#include "massai.hpp"
+#include "compress.h"
+
+/* private constants ********************************************************/
+
+#define LZW_FILE       "_LZWTMP_.LZW"
+#define LZW_TOKEN      "(#)extrct->"
+
+#define BITS           12
+#define HASHING_SHIFT (BITS -8)
+#define MAX_VALUE     ((1 << BITS) -1)
+#define MAX_CODE      (MAX_VALUE -1)
+
+#if (BITS == 14)
+
+  #define TABLE_SIZE   18041
+
+#endif
+
+#if (BITS == 13)
+
+  #define TABLE_SIZE    9029
+
+#endif
+
+#if (BITS <= 12)
+
+  #define TABLE_SIZE    5021
+
+#endif
+
+
+COMPRESS::COMPRESS()
+{
+ psCodeValue  = NULL;  /* pointer to code value array          */
+ pwPrefixCode = NULL;  /* pointer to prefix code array         */
+ pbAppendChar = NULL;  /* pointer to array with appended chars */
+
+ sOutputBitCnt  = 0;
+ ulOutputBitBuf = 0L;
+ sInputBitCnt   = 0;
+ ulInputBitBuf  = 0L;
+}
+
+COMPRESS::~COMPRESS()
+{
+}
+
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE USHORT InitLZW(VOID)
+
+ COMMENTS:  Initializes LZW resources.
+
+ DATE:      21-Jan-1992
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+USHORT COMPRESS::InitLZW()
+{
+SHORT i = 0;
+
+    if((psCodeValue = (SHORT *) malloc(TABLE_SIZE * sizeof(SHORT))) == NULL)
+      return(0xffff);
+
+    if((pwPrefixCode = (USHORT *) malloc(TABLE_SIZE * sizeof(USHORT))) == NULL)
+      return(0xffff);
+
+    if((pbAppendChar = (BYTE *)malloc(TABLE_SIZE * sizeof(BYTE))) == NULL)
+      return(0xffff);
+
+    /* clear string table before starting */
+
+    for(i = 0; i < TABLE_SIZE; i++)
+      *(psCodeValue +i) = -1;
+
+    for(i = 0; i < sizeof(abDecodeStack); i++)
+      abDecodeStack[i] = 0;
+
+    sOutputBitCnt  = 0;
+    sInputBitCnt   = 0;
+    ulOutputBitBuf = 0L;
+    ulInputBitBuf  = 0L;
+
+    return(0);
+
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE USHORT ReleaseLZW(VOID)
+
+ COMMENTS:  Releases LZW resources.
+
+ DATE:      21-Jan-1992
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+USHORT COMPRESS::ReleaseLZW()
+{
+
+    if(psCodeValue)
+      free(psCodeValue);
+
+    if(pwPrefixCode)
+      free(pwPrefixCode);
+
+    if(pbAppendChar)
+      free(pbAppendChar);
+
+    psCodeValue  = NULL;
+    pwPrefixCode = NULL;
+    pbAppendChar = NULL;
+
+    return(0);
+}
+
+/****************************************************************************
+
+ FUNCTION:  PUBLIC USHORT packFile(CHAR *)
+
+ COMMENTS:  Compress a file.
+
+ DATE:      21-Jan-1992
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+USHORT COMPRESS::packFile(CHAR *pszFile)
+{
+USHORT wNextCode    = 0;
+USHORT wChar        = 0;
+USHORT wStringCode  = 0;
+USHORT wIndex       = 0;
+SHORT  rc           = 0;
+SHORT  i            = 0;
+FILE  *pDstFile     = NULL;
+FILE  *pSrcFile     = NULL;
+CHAR  *pStr         = NULL;
+CHAR   szSrcFile[CHARBUF];
+CHAR   szLZWFile[CHARBUF];
+
+   if(!pszFile || !*pszFile)                     /* nothing to do !! */
+     return(0xffff);
+
+   /* get resources */
+
+   if(InitLZW())
+     return(0xffff);
+
+   /* now build destination file name from source file name */
+
+   strcpy(szSrcFile,pszFile);
+   strcpy(szLZWFile,pszFile);
+
+   if((pStr = strrchr(szLZWFile,'\\')) == NULL)
+     strcpy(szLZWFile,LZW_FILE);
+   else
+     strcpy(pStr+1,LZW_FILE);
+
+   /* open files */
+
+   if((pSrcFile = fopen(szSrcFile,"rb")) == NULL)
+     return(0xffff);
+
+   if((pDstFile = fopen(szLZWFile,"wb")) == NULL)
+     return(0xffff);
+
+   /* mark files as packed */
+
+   fwrite(LZW_TOKEN,sizeof(BYTE),strlen(LZW_TOKEN),pDstFile);
+
+   /* next available string code */
+
+   wNextCode = 256;
+
+   /* get first code */
+
+   wStringCode = getc(pSrcFile);
+
+   while((wChar = getc(pSrcFile)) != (USHORT)EOF)
+   {
+     wIndex = FindMatch(wStringCode,wChar);
+
+     if(*(psCodeValue + wIndex) != -1)
+       wStringCode = *(psCodeValue + wIndex);
+     else
+     {
+       if(wNextCode <= MAX_CODE)
+       {
+         *(psCodeValue  + wIndex) = wNextCode++;
+         *(pwPrefixCode + wIndex) = wStringCode;
+         *(pbAppendChar + wIndex) = (BYTE)wChar;
+       }
+
+       OutputCode(pDstFile,wStringCode);
+
+       wStringCode = wChar;
+     }
+   }
+
+   /* do the rest for today */
+
+   OutputCode(pDstFile,wStringCode);
+   OutputCode(pDstFile,MAX_VALUE);
+   OutputCode(pDstFile,0);
+
+   fclose(pDstFile);
+   fclose(pSrcFile);
+
+   /* delete unpacked file and rename the packed file */
+
+   rc = unlink(szSrcFile);
+   rc = rename(szLZWFile,szSrcFile);
+
+   return(ReleaseLZW());
+}
+
+/****************************************************************************
+
+ FUNCTION:  PUBLIC USHORT unpackFile(CHAR *)
+
+ COMMENTS:  Decompress a file.
+
+ DATE:      21-Jan-1992
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+USHORT COMPRESS::unpackFile(CHAR *pszFile)
+{
+USHORT  wNextCode    = 0;
+USHORT  wNewCode     = 0;
+USHORT  wOldCode     = 0;
+USHORT  wChar        = 0;
+SHORT   rc           = 0;
+FILE   *pDstFile     = NULL;
+FILE   *pSrcFile     = NULL;
+CHAR   *pStr         = NULL;
+BYTE   *pArr         = NULL;
+CHAR   szSrcFile[CHARBUF];
+CHAR   szLZWFile[CHARBUF];
+CHAR   szTmp    [CHARBUF];
+
+    if(!pszFile || !*pszFile)                     /* nothing to do !! */
+      return(0xffff);
+
+    /* get resources */
+
+    if(InitLZW())
+      return(0xffff);
+
+    /* now build destination file name from source file name */
+
+    strcpy(szSrcFile,pszFile);
+    strcpy(szLZWFile,pszFile);
+
+    if((pStr = strrchr(szLZWFile,'\\')) == NULL)
+      strcpy(szLZWFile,LZW_FILE);
+    else
+      strcpy(pStr+1,LZW_FILE);
+
+    /* open files */
+
+    if((pSrcFile = fopen(szSrcFile,"rb")) == NULL)
+      return(0xffff);
+
+    /* check if it's a packed file */
+
+    memset(szTmp,0,sizeof(szTmp));
+
+    fread(szTmp,sizeof(BYTE),strlen(LZW_TOKEN),pSrcFile);
+
+    if(strcmp(szTmp,LZW_TOKEN))
+    {
+      fclose(pSrcFile);
+      return(0xffff);
+    }
+
+    if((pDstFile = fopen(szLZWFile,"wb")) == NULL)
+      return(0xffff);
+
+    wNextCode = 256;
+
+    wChar = wOldCode = InputCode(pSrcFile);
+
+    putc(wOldCode,pDstFile);
+
+    while((wNewCode = InputCode(pSrcFile)) != MAX_VALUE)
+    {
+      if(wNewCode >= wNextCode)
+      {
+        *abDecodeStack = (BYTE)wChar;
+
+        if((pArr = (BYTE*)DecodeString(abDecodeStack+1,wOldCode)) == NULL)
+          return(0xffff);
+      }
+      else
+        if((pArr = (BYTE*)DecodeString(abDecodeStack,wNewCode)) == NULL)
+          return(0xffff);
+
+      wChar = *pArr;
+
+      while(pArr >= abDecodeStack)
+      {
+        putc(*pArr,pDstFile);
+        pArr--;
+      }
+
+      if(wNextCode <= MAX_CODE)
+      {
+         *(pwPrefixCode + wNextCode) = wOldCode;
+         *(pbAppendChar + wNextCode) = (BYTE)wChar;
+
+         wNextCode++;
+      }
+
+      wOldCode = wNewCode;
+    }
+
+    /* close all open files */
+
+    fclose(pDstFile);
+    fclose(pSrcFile);
+
+    /* delete packed file and rename the unpacked file */
+
+    rc = unlink(szSrcFile);
+    rc = rename(szLZWFile,szSrcFile);
+
+    return(ReleaseLZW());
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE SHORT FindMatch(USHORT,USHORT)
+
+ COMMENTS:  Hashing routine.
+
+ DATE:      21-Jan-1992
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+SHORT COMPRESS::FindMatch(USHORT wHashPrefix,USHORT wHashChar)
+{
+SHORT sIndex  = 0;
+SHORT sOffset = 0;
+
+    sIndex = (wHashChar << HASHING_SHIFT ^ wHashPrefix);
+
+    if(sIndex == 0)
+      sOffset = 1;
+    else
+      sOffset = TABLE_SIZE - sIndex;
+
+    while(TRUE)
+    {
+      if(*(psCodeValue + sIndex) == -1)
+        return(sIndex);
+
+      if(*(pwPrefixCode + sIndex) == wHashPrefix &&
+         *(pbAppendChar + sIndex) == (BYTE)wHashChar )
+        return(sIndex);
+
+      sIndex -= sOffset;
+
+      if(sIndex < 0)
+        sIndex += TABLE_SIZE;
+    }
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE CHAR* DecodeString(BYTE  *,USHORT)
+
+ COMMENTS:  Decode a string from the string table.
+
+ DATE:      21-Jan-1992
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+CHAR  *COMPRESS::DecodeString(BYTE *pbBuffer,USHORT wCode)
+{
+SHORT  i = 0;
+
+    while(wCode > 255)
+    {
+      *pbBuffer++ = *(pbAppendChar + wCode);
+      wCode       = *(pwPrefixCode + wCode);
+
+      /* on fatal expansion error return NULL */
+
+      if(i++ >= sizeof(abDecodeStack))
+        return(NULL);
+    }
+
+    *pbBuffer = (BYTE)wCode;
+
+    return((CHAR *)pbBuffer);
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE USHORT InputCode(FILE *)
+
+ COMMENTS:  Intput variable length of code.
+
+ DATE:      21-Jan-1992
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+USHORT COMPRESS::InputCode(FILE *pFile)
+{
+USHORT rc = 0;
+
+    while(sInputBitCnt <= 24)
+    {
+      ulInputBitBuf |= (ULONG)getc(pFile) << (24 - sInputBitCnt);
+      sInputBitCnt  += 8;
+    }
+
+    rc              = (USHORT)(ulInputBitBuf >> (32 - BITS));
+    ulInputBitBuf <<= BITS;
+    sInputBitCnt   -= BITS;
+
+    return(rc);
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE USHORT OutputCode(FILE *,USHORT)
+
+ COMMENTS:  Output variable length of code.
+
+ DATE:      21-Jan-1992
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+USHORT COMPRESS::OutputCode(FILE *pFile,USHORT wCode)
+{
+    ulOutputBitBuf |= (ULONG) wCode << (32 - BITS -sOutputBitCnt);
+
+    sOutputBitCnt += BITS;
+
+    while(sOutputBitCnt >= 8)
+    {
+       putc((BYTE)(ulOutputBitBuf >> 24),pFile);
+       ulOutputBitBuf <<= 8;
+       sOutputBitCnt   -= 8;
+    }
+
+    return(0);
+}
+
diff --git a/Massai/cpp/MassaiDLL/dll/src/mConfig.cpp b/Massai/cpp/MassaiDLL/dll/src/mConfig.cpp
new file mode 100644
index 00000000..83ff8491
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/dll/src/mConfig.cpp
@@ -0,0 +1,1385 @@
+/****************************************************************************
+
+ FILE:      mConfig.cpp
+
+ PURPOSE:   MUTILS - configuration functions.
+
+ DATE:      01/19/96 - 14:45:41
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <io.h>
+
+#include "base_os.h"
+#include "massai.hpp"
+#include "mtrace.hpp"
+#include "mConfig.h"
+#include "globbase.hpp"
+#include "trace.hpp"
+
+
+
+static MassaiLibraryInitTerm massaiLibraryInitTerm;
+
+
+
+/* private constants *********************************************************/
+
+#define MUTILS_CFG_FILE         "\\MASSAI.CFG"
+
+#define MULTI_LINE_ITEM_SIZE     1024
+
+/* private datatypes *********************************************************/
+
+typedef struct m_cfg_item
+        {
+           struct m_cfg_item *pNext;
+           CHAR                *pszItem;
+           CHAR                *pszItemValue;
+        }
+        M_CFG_ITEM;
+
+typedef struct m_cfg_section
+        {
+           struct m_cfg_section *pNext;
+           struct m_cfg_item    *pItems;
+           CHAR                 *pszSection;
+        }
+        M_CFG_SECTION;
+
+typedef struct m_cfg_device
+        {
+           struct m_cfg_device  *pNext;
+           struct m_cfg_section *pSections;
+           CHAR                 *pszDevice;
+        }
+        M_CFG_DEVICE;
+
+/* function prototypes *******************************************************/
+
+PRIVATE VOID    cfgErr             (CHAR *pszErr);
+PRIVATE CHAR   *PureName           (CHAR *pszName);
+PRIVATE ULONG   ScanConfiguration  (FILE *pFile);
+PRIVATE ULONG   AppendDevice       (CHAR *pszDevice);
+PRIVATE ULONG   AppendSection      (CHAR *pszSection);
+PRIVATE ULONG   AppendItem         (CHAR *pszItem);
+PRIVATE ULONG   FindItem           (CHAR *pszDev,
+                                    CHAR *pszSec,
+                                    CHAR *pszItem,
+                                    CHAR *pszBuffer);
+
+/* global vars for this file  ************************************************/
+
+PRIVATE CHAR szRootPath  [CHARBUF]; // root path of SSDBASE.DLL
+PRIVATE CHAR szActualFile[CHARBUF]; // actual opened config file
+
+PRIVATE M_CFG_DEVICE  *pConfiguration = (M_CFG_DEVICE  *)NULL;
+PRIVATE M_CFG_DEVICE  *pConfigLast    = (M_CFG_DEVICE  *)NULL;
+PRIVATE M_CFG_SECTION *pSectionLast   = (M_CFG_SECTION *)NULL;
+PRIVATE M_CFG_ITEM    *pItemLast      = (M_CFG_ITEM    *)NULL;
+
+bool configRead = false;
+
+/****************************************************************************
+
+ FUNCTION:  PUBLIC VOID writeMemStatistic()
+
+ COMMENTS:  Trace memory statistics direct to file.
+
+ DATE:      10/10/96 - 09:51:20
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+PUBLIC VOID cfgErr(CHAR *pszErr)
+{
+CHAR   szFile  [CHARBUF];
+CHAR   szBuffer[CHARBUF];
+CHAR  *pStr;
+ULONG  ulAction;
+ULONG  ulWritten;
+ULONG  ulFileSize;
+HFILE  hTraceFile;
+ULONG rc;
+
+    if(rc = QueryMUtilsPath(szFile))
+      return;
+
+    if((pStr = strrchr(szFile,'\\')) != NULL)
+       *pStr = '\0';
+
+    strcat(szFile,"\\TRC\\");
+    strcat(szFile,M_UTILSDEV_FILE);
+
+    if(rc = OS_Open(szFile,
+                    &hTraceFile,
+                    &ulAction,
+                    0,
+                    FILE_NORMAL,
+                    OPEN_ACTION_OPEN_IF_EXISTS |
+                    OPEN_ACTION_CREATE_IF_NEW,
+                    OPEN_SHARE_DENYWRITE  |
+                    OPEN_ACCESS_READWRITE |
+                    OPEN_FLAGS_WRITE_THROUGH |
+                    OPEN_FLAGS_NO_CACHE      |
+                    OPEN_FLAGS_NOINHERIT,
+                    0))
+    {
+      return;
+    }
+    else
+    {
+      // append at end of file
+
+      rc = OS_SetFilePtr(hTraceFile,0L,FILE_END,&ulFileSize);
+
+      sprintf(szBuffer,"\nconfiguration error: %s\n",pszErr);
+
+      // write everything and close
+
+      rc = OS_Write(hTraceFile,szBuffer,strlen(szBuffer),&ulWritten);
+      rc = OS_Close(hTraceFile);
+    }
+
+    return;
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE ULONG FindItem (CHAR *pszDev,
+                                    CHAR *pszSec,
+                                    CHAR *pszItem,
+                                    CHAR *pszBuffer)
+
+ COMMENTS:  Searches configuration for string item.
+
+ DATE:      11/28/95 - 10:18:06
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+PRIVATE ULONG FindItem (CHAR *pszDev,CHAR *pszSec,CHAR *pszItem,CHAR *pszBuffer)
+{
+static CHAR *fn_name = "FindItem()";
+
+M_CFG_DEVICE  *pDevice;
+M_CFG_SECTION *pSection;
+M_CFG_ITEM    *pItem;
+BOOL             fDevFound;
+BOOL             fSecFound;
+BOOL             fItemFound;
+
+    if(!pConfiguration)
+    {
+      //debugWrite(HERE,"Config file not read or empty.");
+
+      /* return error if config file not read or emty */
+
+      return(ERR_CFG_NO_CONFIGURATION);
+    }
+
+    if(!pszDev || !pszSec || !pszItem || !*pszDev || !*pszSec || !*pszItem)
+    {
+      debugWrite(HERE,"Parameter error.");
+
+      /* won't work for this function */
+
+      return(ERR_CFG_PARAMETERS);
+    }
+
+    fDevFound = fSecFound = fItemFound = FALSE;
+
+    pDevice = (M_CFG_DEVICE *) pConfiguration;
+
+    while(pDevice && !fDevFound)
+    {
+      /* check device list */
+
+      fDevFound = (strcmp(pDevice->pszDevice,pszDev) == 0);
+
+      if(!fDevFound)
+        pDevice = pDevice->pNext;
+      else if(pDevice)
+      {
+        fSecFound = FALSE;
+
+        pSection = pDevice->pSections;
+
+        while(pSection && !fSecFound)
+        {
+          /* check section list */
+
+          fSecFound = (strcmp(pSection->pszSection,pszSec) == 0);
+
+          if(!fSecFound)
+            pSection = pSection->pNext;
+          else if(pSection)
+          {
+            fItemFound = FALSE;
+
+            pItem = pSection->pItems;
+
+            while(pItem && !fItemFound)
+            {
+              /* check item list */
+
+              fItemFound = (strcmp(pItem->pszItem,pszItem) == 0);
+
+              if(!fItemFound)
+                pItem = pItem->pNext;
+              else
+                strcpy(pszBuffer,pItem->pszItemValue);
+            }
+          }
+        }
+      }
+    }
+
+    if(!fItemFound)
+    {
+      /* reset buffer and return error */
+
+      *pszBuffer = '\0';
+
+      return(ERR_CFG_NOT_FOUND);
+    }
+    else
+      return(0L);
+}
+
+/****************************************************************************
+
+ FUNCTION:  PUBLIC ULONG FreeConfiguration(VOID);
+
+ COMMENTS:  Frees memory allocated for configuration.
+
+ DATE:      11/28/95 - 10:18:06
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+PUBLIC ULONG FreeConfiguration()
+{
+static CHAR *fn_name = "FreeConfiguration()";
+
+M_CFG_DEVICE  *pTmpDev  = (M_CFG_DEVICE  *)NULL;
+M_CFG_SECTION *pTmpSec  = (M_CFG_SECTION *)NULL;
+M_CFG_ITEM    *pTmpItem = (M_CFG_ITEM    *)NULL;
+
+#if defined (SSD_CODELIB) && defined (WINNT)
+
+    return(0);
+
+#endif
+
+    while(pConfiguration)
+    {
+      while(pConfiguration->pSections)
+      {
+        while(pConfiguration->pSections->pItems)
+        {
+          pTmpItem = pConfiguration->pSections->pItems;
+
+          pConfiguration->pSections->pItems =
+                                     pConfiguration->pSections->pItems->pNext;
+
+          free(pTmpItem->pszItem);
+          free(pTmpItem->pszItemValue);
+          free(pTmpItem);
+        }
+
+        pTmpSec = pConfiguration->pSections;
+
+        pConfiguration->pSections = pConfiguration->pSections->pNext;
+
+        free(pTmpSec->pszSection);
+        free(pTmpSec);
+      }
+
+      pTmpDev = pConfiguration;
+
+      pConfiguration = pConfiguration->pNext;
+
+      free(pTmpDev->pszDevice);
+      free(pTmpDev);
+    }
+
+    pConfiguration = (M_CFG_DEVICE *) NULL;
+
+    return(0L);
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE ULONG AppendDevice(CHAR *pszDevice);
+
+ COMMENTS:  Appends device items to config list.
+
+ DATE:      11/27/95 - 14:41:06
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+PRIVATE ULONG AppendDevice(CHAR *pszDevice)
+{
+CHAR           *pStr;
+CHAR           *pToken;
+M_CFG_DEVICE *pNew;
+M_CFG_DEVICE *pRun;
+
+    if(!pszDevice || !*pszDevice)
+      return((ULONG)-1);
+
+    /* extract device token */
+
+    pToken = pszDevice;
+
+    while(*pToken == '[')
+      pToken++;
+
+    if((pStr = strstr(pToken,"]]")) != NULL)
+      *pStr = '\0';
+    else
+      return((ULONG) -1L);
+
+    // check if device is already in list
+
+    for(pRun = pConfiguration; pRun && pRun->pszDevice;)
+    {
+       if(strcmp(pRun->pszDevice,pToken))
+         pRun = pRun->pNext;
+       else
+       {
+         pConfigLast = pRun;
+         return(0L);
+       }
+    }
+
+    /* allocate new item */
+    if((pNew = (M_CFG_DEVICE *) malloc(sizeof(M_CFG_DEVICE))) == NULL)
+      return((ULONG) -1L);
+
+    if((pNew->pszDevice = (CHAR *) malloc(strlen(pToken) +1)) == NULL)
+    {
+      free(pNew);
+      return((ULONG) -1L);
+    }
+
+    /* save device name */
+
+    strcpy(pNew->pszDevice,pToken);
+
+    pNew->pSections = (M_CFG_SECTION *) NULL;
+    pNew->pNext     = (M_CFG_DEVICE *)  NULL;
+
+    if(!pConfiguration)
+    {
+      /* insert as first item in list */
+
+      pConfiguration = pConfigLast = pNew;
+    }
+    else
+    {
+      /* append at end of list */
+
+      pConfigLast->pNext = pNew;
+
+      /* new item is the last one now */
+
+      pConfigLast        = pNew;
+    }
+
+    /* reset last section pointer for every new device */
+
+    pSectionLast = (M_CFG_SECTION *) NULL;
+
+    return(0L);
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE ULONG AppendSection(CHAR *pszSection);
+
+ COMMENTS:  Appends section items to config list.
+
+ DATE:      11/27/95 - 14:41:06
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+PRIVATE ULONG AppendSection(CHAR *pszSection)
+{
+CHAR            *pStr;
+CHAR            *pToken;
+M_CFG_SECTION *pNew;
+M_CFG_SECTION *pRun;
+
+    if(!pConfiguration || !pszSection || !*pszSection)
+      return((ULONG) -1);
+
+    /* extract section token */
+
+    pToken = pszSection;
+
+    if(*pToken == '[')
+      pToken++;
+    else
+      return((ULONG) -1L);
+
+    if((pStr = strchr(pToken,']')) != NULL)
+      *pStr = '\0';
+    else
+      return((ULONG) -1L);
+
+    // check if section is already in list
+
+    for(pRun = pConfigLast->pSections; pRun && pRun->pszSection;)
+    {
+       if(strcmp(pRun->pszSection,pToken))
+         pRun = pRun->pNext;
+       else
+       {
+         pSectionLast = pRun;
+         return(0L);
+       }
+    }
+
+    /* allocate new item */
+    if((pNew = (M_CFG_SECTION *) malloc(sizeof(M_CFG_SECTION))) == NULL)
+      return((ULONG) -1L);
+    if((pNew->pszSection = (CHAR *) malloc(strlen(pToken) +1)) == NULL)
+    {
+
+      free(pNew);
+      return((ULONG) -1L);
+    }
+
+    /* save section name */
+
+    strcpy(pNew->pszSection,pToken);
+
+    pNew->pItems = (M_CFG_ITEM *)    NULL;
+    pNew->pNext  = (M_CFG_SECTION *) NULL;
+
+    if(!pSectionLast)
+    {
+      /* insert as first item in list */
+
+      pConfigLast->pSections = pSectionLast = pNew;
+    }
+    else
+    {
+      /* append at end of list */
+
+      pSectionLast->pNext = pNew;
+
+      /* new item is the last one now */
+
+      pSectionLast        = pNew;
+    }
+
+    /* reset last item pointer for every new section */
+
+    pItemLast = (M_CFG_ITEM *) NULL;
+
+    return(0L);
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE ULONG AppendItem(CHAR *pszItem);
+
+ COMMENTS:  Appends items to config list.
+
+ DATE:      11/27/95 - 14:41:06
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+PRIVATE ULONG AppendItem(CHAR *pszItem)
+{
+CHAR         *pStr;
+CHAR         *pToken;
+CHAR         *pComment;
+M_CFG_ITEM *pNew;
+M_CFG_ITEM *pRun;
+
+    if(!pConfiguration || !pConfiguration->pSections || !pszItem || !*pszItem)
+      return((ULONG) -1);
+
+    /* extract item token */
+
+    pToken = pszItem;
+
+    if((pStr = strchr(pToken,'=')) != NULL)
+      *pStr = '\0';
+    else
+      return((ULONG) -1L);
+
+    /* cut of pending blanks */
+
+    while(*(pToken + strlen(pToken) -1) <= ' ')
+      *(pToken + strlen(pToken) -1) = '\0';
+
+    // check if item is already in list
+
+    for(pRun = pSectionLast->pItems; pRun && pRun->pszItem;)
+    {
+      if(strcmp(pRun->pszItem,pToken))
+        pRun = pRun->pNext;
+      else
+      {
+        debugWrite(HERE,"error in file:      %s\n"
+                         "item \"[[%s]] [%s] %s\" defined more than once.\n",
+                          szActualFile,
+                          pConfigLast->pszDevice,
+                          pSectionLast->pszSection,
+                          pToken);
+
+        OS_Beep(3000,2000);
+
+        // return error
+
+        return(1L);
+      }
+    }
+
+    /* allocate new item */
+    if((pNew = (M_CFG_ITEM *) malloc(sizeof(M_CFG_ITEM))) == NULL)
+      return((ULONG) -1L);
+    if((pNew->pszItem = (CHAR *) malloc(strlen(pToken) +1)) == NULL)
+    {
+      free(pNew);
+      return((ULONG) -1L);
+    }
+
+    /* set pStr to value */
+
+    pStr++;
+
+    /* discard comments in this line */
+
+    if((pComment = strstr(pStr,"//")) != NULL)
+      *pComment = '\0';
+
+    /* discard leading blanks */
+
+    while(*pStr && *pStr <= ' ')
+      pStr++;
+
+    /* cut of pending blanks and other rubbish */
+
+    while(*pStr && *(pStr + strlen(pStr) -1) <= ' ')
+      *(pStr + strlen(pStr) -1) = '\0';
+
+    if(!*pStr)
+    {
+      // no value ignore !!
+      free(pNew->pszItem);
+      free(pNew);
+      return(0);
+    }
+    if((pNew->pszItemValue = (CHAR *) malloc(strlen(pStr) +1)) == NULL)
+    {
+      free(pNew);
+      free(pNew->pszItem);
+      return((ULONG) -1L);
+    }
+
+    /* save item name */
+
+    strcpy(pNew->pszItem,pToken);
+    strcpy(pNew->pszItemValue,pStr);
+
+    pNew->pNext  = (M_CFG_ITEM *) NULL;
+
+    if(!pItemLast)
+    {
+      /* insert as first item in list */
+
+      pSectionLast->pItems = pItemLast = pNew;
+    }
+    else
+    {
+      /* append at end of list */
+
+      pItemLast->pNext = pNew;
+
+      /* new item is the last one now */
+
+      pItemLast        = pNew;
+    }
+
+    return(0L);
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE ULONG ScanConfiguration(FILE *)
+
+ COMMENTS:  Scans file and saves contents in memory.
+
+ DATE:      11/27/95 - 14:41:06
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+PRIVATE ULONG ScanConfiguration(FILE *pFile,ULONG ulLevel)
+{
+ULONG rc;
+ULONG  ulLen;
+FILE  *pIncFile;
+CHAR   szIncFile[CHARBUF];
+CHAR   szTmp    [CHARBUF];
+CHAR  *pszStr;
+CHAR  *pszValue;
+CHAR  *pszTmp;
+BOOL   fMultiLineEntry;
+
+    pszValue        = NULL;
+    fMultiLineEntry = FALSE;
+
+    while(fgets(szTmp,sizeof(szTmp),pFile))
+    {
+      /* cut out leading blanks */
+
+      pszStr = szTmp;
+
+      while(*pszStr && *pszStr <= ' ')
+        pszStr++;
+
+      /* check if comment */
+
+      if(*pszStr != '/' && *(pszStr+1) != '/')
+      {
+        /* not a commment !! */
+
+        strcpy(szTmp,pszStr);
+
+        if((pszStr = strstr(szTmp,"#include")) != NULL)
+        {
+          // include files allowed on level 1 only !!!
+
+          if(ulLevel == 1)
+          {
+            // include file !!
+
+            if((pszStr = strchr(pszStr,'<')) != NULL)
+            {
+              pszStr++;
+
+              if((pszTmp = strchr(pszStr,'>')) != NULL)
+                *pszTmp = '\0';
+
+              QueryMUtilsPath(szIncFile);
+
+              strcat(szIncFile,"\\");
+              strcat(szIncFile,pszStr);
+
+              if((pIncFile = fopen(szIncFile,"rb")) != NULL)
+              {
+                strcpy(szTmp,szActualFile);
+                strcpy(szActualFile,szIncFile);
+
+                /* read configuration from include file */
+
+                debugWrite(HERE,"including file:     %s",szIncFile);
+
+                rc = ScanConfiguration(pIncFile,2);
+
+                fclose(pIncFile);
+
+                strcpy(szActualFile,szTmp);
+              }
+              else
+              {
+                debugWrite(HERE,"configuration error: "
+                                 "can't open include file [%s]\n",szIncFile);
+
+                OS_Beep(3000,2000);
+
+                return(-1L);
+              }
+            }
+          }
+          else
+          {
+            debugWrite(HERE,"configuration error: "
+                             "include level to high\n\n"
+                             "line:%s\n",szTmp);
+
+            OS_Beep(3000,2000);
+
+            return(-1L);
+          }
+        }
+
+        if((pszStr = strstr(szTmp,"[[")) != NULL)
+        {
+          if(pszValue)
+          {
+            // save first
+
+            rc = AppendItem(pszValue);
+
+            free(pszValue);
+
+            pszValue = NULL;
+
+            if(rc)
+              return(rc);
+          }
+
+          if(rc = AppendDevice(pszStr))
+            return(rc);
+        }
+        else if((pszStr = strchr(szTmp,'[')) != NULL)
+        {
+          if(pszValue)
+          {
+            // save first
+
+            rc = AppendItem(pszValue);
+
+            free(pszValue);
+
+            pszValue = NULL;
+
+            if(rc)
+              return(rc);
+          }
+
+          if(rc = AppendSection(pszStr))
+            return(rc);
+        }
+        else if((pszStr = strchr(szTmp,'=')) != NULL && !fMultiLineEntry)
+        {
+/*
+          if(pszValue)
+          {
+            // save first
+
+            rc = AppendItem(pszValue);
+
+            free(pszValue);
+
+            pszValue = NULL;
+
+            if(rc)
+              return(rc);
+          }
+*/
+          // check for multiple lines
+
+          pszTmp = szTmp + strlen(szTmp) -1;
+
+          if(*pszTmp == '\n' && *(pszTmp -1) == '\r' && *(pszTmp -2) == '\\')
+          {
+            if((pszValue = (CHAR *) malloc(MULTI_LINE_ITEM_SIZE)) == NULL)
+              return(-1L);
+
+            memset(pszValue,0,MULTI_LINE_ITEM_SIZE);
+
+            // cut off backslash
+
+            *(pszTmp -2) = '\0';
+
+            // and save to separate buffer
+
+            ulLen = sprintf(pszValue,"%s\n",szTmp);
+
+            fMultiLineEntry = TRUE;
+          }
+          else
+          {
+            fMultiLineEntry = FALSE;
+
+            // single line item value
+
+            if(rc = AppendItem(szTmp))
+              return(rc);
+          }
+        }
+        else if(pszValue)
+        {
+          // check for more multiple lines
+
+          pszTmp = szTmp + strlen(szTmp) -1;
+
+          if(*pszTmp == '\n' && *(pszTmp -1) == '\r' && *(pszTmp -2) == '\\')
+          {
+            // cut off backslash
+
+            *(pszTmp -2) = '\0';
+
+            // and save to separate buffer
+
+            ulLen += sprintf(pszValue +ulLen,"%s\n",szTmp);
+
+            fMultiLineEntry = TRUE;
+          }
+          else
+          {
+            // and save to separate buffer
+
+            ulLen += sprintf(pszValue +ulLen,"%s",szTmp);
+
+            rc = AppendItem(pszValue);
+
+            free(pszValue);
+
+            pszValue = NULL;
+
+            fMultiLineEntry = FALSE;
+
+            if(rc)
+              return(rc);
+          }
+        }
+      }
+    }
+
+    return(0);
+}
+
+/****************************************************************************
+
+ FUNCTION:  PUBLIC ULONG QueryMUtilsPath(CHAR *);
+
+ COMMENTS:  Returns root path of SSDBASE.DLL.
+
+ DATE:      2-16-95, 12:41 AM
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+PUBLIC ULONG QueryMUtilsPath(CHAR *pszPath)
+{
+#if defined (SSD_CODELIB)
+
+CHAR    *pToken;
+CHAR    szTmp[2048];
+CHAR    szPath[512];
+BOOL    fFound;
+
+#else
+
+ULONG   rc;
+HMODULE hModule;
+
+#endif
+
+CHAR   *pStr;
+
+    if(!pszPath)
+      return((ULONG) -1);
+    else
+    {
+      if(*szRootPath == '\0')
+      {
+
+#if defined (SSD_CODELIB)
+
+        // simply scan path environment var
+
+        if(OS_ScanEnv("PATH",(const CHAR **) &pStr))
+          pStr = NULL;
+
+        if(pStr)
+        {
+          strcpy(szTmp,strlwr(pStr));
+
+          for(fFound = FALSE, pToken = strtok(szTmp,";"); !fFound && pToken;)
+          {
+            strcpy(szPath,pToken);
+            strcat(szPath,"\\massai.dll");
+
+            if(!access(szPath,0))
+            {
+              fFound = TRUE;
+
+              strcpy(szRootPath,pToken);
+            }
+            else
+              pToken = strtok(NULL,";");
+          }
+
+          if(!fFound)
+          {
+            strcpy(szTmp,strlwr(pStr));
+            for(fFound = FALSE, pToken = strtok(szTmp,";"); !fFound && pToken;)
+            {
+              strcpy(szPath,pToken);
+              strcat(szPath,"\\massai.cfg");
+
+              if(!access(szPath,0))
+              {
+                fFound = TRUE;
+
+                strcpy(szRootPath,pToken);
+              }
+              else
+                pToken = strtok(NULL,";");
+            }
+          }
+        }
+
+#else  // SSD_CODELIB
+
+        if(rc = OS_QueryModuleHandle((PSZ)"MASSAI",&hModule))
+          return(rc);
+
+        if(rc = OS_QueryModuleName(hModule,sizeof(szRootPath),szRootPath))
+        {
+
+#ifdef WINNT
+
+          CloseHandle((HANDLE)hModule);
+#endif
+
+          return(rc);
+        }
+
+        if((pStr = strrchr(szRootPath,'\\')) != NULL)
+          *pStr = '\0';
+
+#endif // SSD_CODELIB
+
+      }
+
+      strcpy(pszPath,szRootPath);
+      return(0);
+    }
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE CHAR *PureName(CHAR *)
+
+ COMMENTS:  Skips quotation marks in string.
+
+ DATE:      30-Jul-1991
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+PRIVATE CHAR *PureName(CHAR *s)
+{
+static CHAR  szBuf[1024];
+
+CHAR *p;
+
+   strcpy(szBuf,s);
+
+   /* query string from beginning */
+
+   while((p = strchr(szBuf,'"')) != NULL)
+     if(*(p+1))
+       strcpy(szBuf,p+1);
+     else
+       szBuf[strlen(szBuf) -1] = '\0';
+
+   return(szBuf);
+}
+
+/****************************************************************************
+
+ FUNCTION:  PUBLIC ULONG mUtilsReadConfig (VOID);
+
+ COMMENTS:  Creates configuration structure an parses configuration file.
+
+ DATE:      11/24/95 - 12:28:57
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+PUBLIC ULONG mUtilsReadConfig()
+{
+ULONG  rc          = 0x0000;
+CHAR   szConfigFile  [CHARBUF];
+CHAR  *pStr;
+FILE  *pScanFile;
+
+    if (configRead)
+      return 0;
+    configRead = true;
+
+    QueryMUtilsPath(szConfigFile);
+    /* Build Configuration File name for global configurations */
+
+    if(OS_ScanEnv("MUTILS_CFG_FILE",(const CHAR **) &pStr))
+      strcat(szConfigFile,MUTILS_CFG_FILE);
+    else
+    {
+      // make config file name from environment
+      // (only for local test purposes !!)
+
+      strcat(szConfigFile,"\\");
+      strcat(szConfigFile,pStr);
+    }
+
+    /* scan configuration file */
+
+    if((pScanFile = fopen(szConfigFile,"rb")) == NULL)
+      return((ULONG)-1L);
+    else
+    {
+      /* read configuration file */
+
+      debugWrite(HERE,"configuration file: %s\n",szConfigFile);
+
+      strcpy(szActualFile,szConfigFile);
+
+      rc = ScanConfiguration(pScanFile,1);
+
+      fclose(pScanFile);
+    }
+
+    if (rc) //error
+      configRead = false;
+
+
+    return(rc);
+}
+
+/****************************************************************************
+
+ METHOD:    mConfig::mConfig()
+
+ COMMENTS:  constructor without setting Data. SetData is required.
+
+ DATE:      01/16/96 - 18:00:45
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+mConfig::mConfig()
+{
+    ulError     = 0L;
+    szBuffer[0] = '\0';   // initialize Buffer
+
+    massaiLibraryInitTerm.ref(); // reference massaiLibraryInitTerm
+}
+
+/****************************************************************************
+
+ METHOD:    mConfig::mConfig (CHAR *pszDev,
+                                  CHAR *pszSec,
+                                  CHAR *pszItem)
+
+ COMMENTS:  constructor.
+
+ DATE:      01/16/96 - 18:00:45
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+mConfig::mConfig (CHAR *pszDev,            /* device ID - [[device]]   */
+                      CHAR *pszSec,            /* section ID - [section]   */
+                      CHAR *pszItem)           /* item ID - item = foo bar */
+{
+   ulError = readValue(pszDev,pszSec,pszItem);
+   return;
+}
+
+mConfig::mConfig (CHAR *pszCfgItem)
+{
+   ulError = readValue(pszCfgItem);
+   return;
+}
+
+/****************************************************************************
+
+ METHOD:     ULONG mConfig::readValue (CHAR *pszDev,
+                                         CHAR *pszSec,
+                                         CHAR *pszItem)
+
+ COMMENTS:  Reads new Item
+
+ DATE:      01/16/96 - 18:00:45
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+ULONG mConfig::readValue (CHAR *pszDev,     /* device ID - [[device]]   */
+                            CHAR *pszSec,     /* section ID - [section]   */
+                            CHAR *pszItem)    /* item ID - item = foo bar */
+{
+    if((ulError = CfgReadStr(pszDev,pszSec,pszItem,sizeof(szBuffer),szBuffer)) )
+    {
+       /* Item not found */
+
+       szBuffer[0] = '\0';
+       //trc().write(HERE_8,"Item not found: <%s>:<%s>:<%s>",pszDev,pszSec,pszItem);
+    }
+
+    return(ulError);
+}
+
+ULONG mConfig::readValue (CHAR *pszCfgItem)
+{
+CHAR szTmp[512];
+CHAR *pszDev;
+CHAR *pszSec;
+CHAR *pszItem;
+
+    if(pszCfgItem && *pszCfgItem)
+    {
+      strcpy(szTmp,pszCfgItem);
+
+      pszDev  = strtok(szTmp,".");
+      pszSec  = strtok(NULL,".");
+      pszItem = strtok(NULL,".");
+
+      if((ulError = CfgReadStr(pszDev,pszSec,pszItem,sizeof(szBuffer),szBuffer)))
+      {
+         /* Item not found */
+
+         szBuffer[0] = '\0';
+
+         debugWrite(HERE,"Item not found: [%s]",pszCfgItem);
+      }
+    }
+    else
+      ulError = -1;
+
+    return(ulError);
+}
+
+
+/****************************************************************************
+
+ METHOD:    ULONG mConfig::CfgReadStr (CHAR *pszDev,
+                                         CHAR *pszSec,
+                                         CHAR *pszItem,
+                                         LONG  lBufLen,
+                                         CHAR *pszRet)
+
+ COMMENTS:  Searches configuration for string item.
+
+ DATE:      11/28/95 - 10:18:06
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+ULONG mConfig::CfgReadStr (CHAR *pszDev,          /* device ID - [[device]]   */
+                              CHAR *pszSec,          /* section ID - [section]   */
+                              CHAR *pszItem,         /* item ID - item = foo bar */
+                              LONG  lBufLen,         /* length of return buffer  */
+                              CHAR *pszRet)          /* return buffer            */
+{
+ULONG  rc = 0L;
+LONG   i;
+CHAR   szTmp[1024];
+
+    if(!pszRet || !lBufLen)
+    {
+      /* won't work for this function */
+
+      return(ERR_CFG_PARAMETERS);
+    }
+
+    if(rc = FindItem(pszDev,pszSec,pszItem,szTmp))
+      return(rc);
+    else
+    {
+      /* copy string to return buffer */
+
+      for(i = 0; i < lBufLen && szTmp[i]; i++)
+        *(pszRet +i) = szTmp[i];
+
+      *(pszRet +i) = '\0';
+    }
+
+    return(0L);
+}
+
+/****************************************************************************
+
+ METHOD:    VOID mConfig::itemString (CHAR *pszDev,
+                                        CHAR *pszSec,
+                                        CHAR *pszItem,
+                                        CHAR *pszBuf, LONG lBufLen);
+
+ COMMENTS:  sets and returns item as String.
+
+ DATE:      01/16/96 - 18:25:41
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+VOID  mConfig::itemString(CHAR *pszDev, CHAR *pszSec, CHAR *pszItem,
+                            CHAR *pszBuf, LONG lBufLen)
+{
+    readValue(pszDev,pszSec,pszItem);
+    asString(pszBuf,lBufLen);
+}
+
+/****************************************************************************
+
+ METHOD:    INT  mConfig::itemInteger(CHAR *pszDev,
+                                        CHAR *pszSec,
+                                        CHAR *pszItem)
+
+ COMMENTS:  sets and returns item as Integer.
+
+ DATE:      01/16/96 - 18:25:41
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+INT mConfig::itemInteger(CHAR *pszDev, CHAR *pszSec, CHAR *pszItem)
+{
+    readValue(pszDev,pszSec,pszItem);
+    return(asInt());
+}
+
+/****************************************************************************
+
+ METHOD:    BOOL mConfig::itemBoolean(CHAR *pszDev,
+                                        CHAR *pszSec,
+                                        CHAR *pszItem)
+
+ COMMENTS:  sets and returns item as Boolean.
+
+ DATE:      01/16/96 - 18:25:41
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+BOOL mConfig::itemBoolean(CHAR *pszDev, CHAR *pszSec, CHAR *pszItem)
+{
+    readValue(pszDev,pszSec,pszItem);
+    return(asBool());
+}
+
+/****************************************************************************
+
+ METHOD:    VOID mConfig::asString (CHAR *pszBuf, LONG lBufLen);
+
+ COMMENTS:  returns item as String.
+
+ DATE:      01/16/96 - 18:25:41
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+VOID mConfig::asString (CHAR *pszBuf, LONG lBufLen)
+{
+INT i = 0;
+
+    if(pszBuf && *szBuffer)
+    {
+      /* Copy String */
+      i = 0;
+      while((pszBuf[i] = szBuffer[i++]) && (i < lBufLen));
+    }
+    else                    //No Data in Buffer
+    {
+      *pszBuf = '\0';
+      ulError = ERR_CFG_NOT_FOUND;
+    }
+}
+
+/****************************************************************************
+
+ METHOD:    INT mConfig::asInt (VOID)
+
+ COMMENTS:  returns item as Integer.
+
+ DATE:      01/16/96 - 18:25:41
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+INT mConfig::asInt(VOID)
+{
+    if(*szBuffer)
+    {
+      /* convert string to integer */
+      return(atoi(szBuffer));
+    }
+    else                    //No Data in Buffer
+    {
+      ulError = ERR_CFG_NOT_FOUND;
+      return(0);
+    }
+}
+
+/****************************************************************************
+
+ METHOD:     BOOL mConfig::asBool(VOID)
+
+ COMMENTS:  returns item as Boolean.
+
+ DATE:      01/16/96 - 18:25:41
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+BOOL mConfig::asBool(VOID)
+{
+BOOL rc = FALSE;
+
+    if(*szBuffer)
+    {
+      /* check uppercase string in Buffer for boolean value */
+
+      strupr(szBuffer);
+
+      rc =    ((strcmp(szBuffer,"TRUE")    == 0) ||
+               (strcmp(szBuffer,"YES")     == 0) ||
+               (strcmp(szBuffer,"OK")      == 0) ||
+               (strcmp(szBuffer,"ENABLED") == 0) ||
+               (strcmp(szBuffer,"ENABLE")  == 0) &&
+               (strcmp(szBuffer,"0")       != 0)   );
+    }
+    else                    //No Data in Buffer
+    {
+      ulError = ERR_CFG_NOT_FOUND;
+      rc = FALSE;           //Better Arise an Exception
+    }
+    return(rc);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   ULONG mConfig::reloadConfiguration()
+//
+//  purpose:    try to reload the configuration files
+//
+//  date:       08.08.2001, 16:32
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+ULONG mConfig::reloadConfiguration()
+{
+    return(0);
+}
diff --git a/Massai/cpp/MassaiDLL/dll/src/mDate.cpp b/Massai/cpp/MassaiDLL/dll/src/mDate.cpp
new file mode 100644
index 00000000..355a5452
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/dll/src/mDate.cpp
@@ -0,0 +1,520 @@
+#include "mDate.hpp"
+
+#include <time.h>
+
+#define self (*this)
+
+/*------------------------------------------------------------------------------
+|  These arrays give the number of days in the year that precede each month    |
+|  (in non-leap and leap years, respectively).  They should be indexed by the  |
+|  Month value minus 1 (e.g., the days preceding April in a non-leap year is   |
+|  daysToMonth[0][3]).                                                         |
+------------------------------------------------------------------------------*/
+static const int
+  daysToMonth[ 2 ] [ 13 ] =
+    {
+    { 0,  31,  59,  90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
+    { 0,  31,  60,  91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
+    };
+
+/*------------------------------------------------------------------------------
+|  These arrays give the number of days in a 4 year block that precede each    |
+|  year. Each group of 4 year may / may not start with a leap year             |
+------------------------------------------------------------------------------*/
+static const int
+  daysIn4Years[2][5] =
+  {
+  { 0, 365, 730, 1095, 1460},
+  { 0, 366, 731, 1096, 1461}
+  };
+
+
+/*------------------------------------------------------------------------------
+|  This structure simply combines separate Month, Day, and Year values for a   |
+|  given date (for communication with the various utility functions, see       |
+|  below).                                                                     |
+|                                                                              |
+------------------------------------------------------------------------------*/
+typedef struct
+  {
+  mDate::Month month;
+  int          day;
+  int          year;
+  } MDY;
+
+
+/*------------------------------------------------------------------------------
+|  reformMDY                                                                   |
+|  reformJulianDayNumber                                                       |
+|  reformDays                                                                  |
+|  julianReferenceYear                                                         |
+|  dayNumber160101                                                             |
+|  dayNumber170101                                                             |
+|                                                                              |
+|  These constants give the date at which the Gregorian reforms were           |
+|  adopted (in both MDY and Julian day number format) and the number           |
+|  of dates skipped upon adoption.                                             |
+|                                                                              |
+|  Note:  There are restrictions on the values these constants can             |
+|         have, specifically, the skipped days cannot span the end             |
+|         of the month.                                                        |
+------------------------------------------------------------------------------*/
+static const MDY
+  reformMDY = { mDate::September, 2, 1752 };
+
+static const long int
+  reformJulianDayNumber = 2361221;
+
+static const int
+  reformDays = 11;
+
+static const int
+  julianReferenceYear = -4713;
+
+static const long int
+  dayNumber16010101 = 2305824;
+
+static const long int
+  dayNumber17010101 = 2342349;
+
+/*------------------------------------------------------------------------------
+| Function prototypes for static/local utilities (see below)                   |
+------------------------------------------------------------------------------*/
+static MDY
+  julianToMDY ( unsigned long julianDate ),
+  DYToMDY     ( int aDay, int aYear );
+
+static unsigned long
+  MDYToJulian ( MDY aMDY );
+
+/*------------------------------------------------------------------------------
+| mDate::mDate                                                                 |
+|                                                                              |
+| To construct a date given year/month/day, simply invoke the protected member |
+| function initialize() with the year, month, and day (these latter two        |
+| calculated via DYToMDY(), if need be).                                       |
+|                                                                              |
+| To construct the current time, invoke the static member function today() and |
+| use the julian date from its result.                                         |
+|                                                                              |
+| The protected constructor that accepts a julian day number (long int) simply |
+| initializes the data member 'julian' to the argument value.                  |
+|                                                                              |
+| To construct a date from the container CDATE structure, simply initialize    |
+| from the month/day/year in that structure.                                   |
+------------------------------------------------------------------------------*/
+mDate :: mDate ( int  aYear,
+                 int  aDay )
+   {
+   MDY mdy = DYToMDY( aDay, aYear );
+   self.initialize( mdy.month, mdy.day, mdy.year );
+   }
+
+mDate :: mDate ( unsigned long julianDayNumber ) : julian( julianDayNumber )
+  {
+  }
+
+
+#if 0
+mDate :: mDate ( const ICnrDate &cnrDate )
+   {
+   self.initialize( (mDate::Month)cnrDate.month, cnrDate.day, cnrDate.year );
+   }
+#endif
+
+/*------------------------------------------------------------------------------
+| mDate::asICnrDate                                                            |
+|                                                                              |
+| Build result ICnrDate structure from receiver's day/month/year.              |
+------------------------------------------------------------------------------*/
+ICnrDate mDate :: asICnrDate ( ) const
+  {
+  ICnrDate
+    result = { (unsigned char)this->dayOfMonth(),
+               (unsigned char)this->monthOfYear(),
+               (unsigned short)this->year() };
+  return result;
+  }
+
+
+/*------------------------------------------------------------------------------
+| mDate::dayOfMonth                                                            |
+|                                                                              |
+| The receiver's Julian date is converted to year/month/day format using the   |
+| function julianToMDY() (see below).  The day of the mongth is then simply    |
+| returned.                                                                    |
+------------------------------------------------------------------------------*/
+int mDate :: dayOfMonth ( ) const
+   {
+   MDY mdy = julianToMDY( self.julian );
+   return mdy.day;
+   }
+
+/*------------------------------------------------------------------------------
+| mDate::dayOfYear                                                             |
+|                                                                              |
+| The receiver's Julian date is converted to year/month/day format via a call  |
+| to julianToMDY().  Then, the day within the year is calculated by adding the |
+| days prior to that month (from the daysToMonth array) to the day of the      |
+| month.                                                                       |
+------------------------------------------------------------------------------*/
+int mDate :: dayOfYear ( ) const
+   {
+   MDY mdy = julianToMDY( self.julian );
+   return daysToMonth[ mDate::isLeapYear( mdy.year ) ][ mdy.month - 1 ]
+          +
+          mdy.day;
+   }
+
+/*------------------------------------------------------------------------------
+| mDate::Month mDate :: monthOfYear                                            |
+|                                                                              |
+| Convert the receiver's Julian date to year/month/day format via a call to    |
+| julianToMDY().  Simply return the resulting month.                           |
+------------------------------------------------------------------------------*/
+mDate::Month mDate :: monthOfYear ( ) const
+   {
+   return julianToMDY( self.julian ).month;
+   }
+
+/*------------------------------------------------------------------------------
+| mDate::year                                                                  |
+|                                                                              |
+| Convert the receiver's Julian date to year/month/day format via a call to    |
+| julianToMDY().  Simply return the resulting year.                            |
+------------------------------------------------------------------------------*/
+int mDate :: year ( ) const
+   {
+   return julianToMDY( self.julian ).year;
+   }
+
+
+/*------------------------------------------------------------------------------
+| mDate::daysInMonth                                                           |
+|                                                                              |
+| We use the daysToMonth array to calculate the basic length of the month (it  |
+| is the days to the next month - the days to the argument month).  Lastly,    |
+| if the year and month are those when the Gregorian reform took effect, then  |
+| we subtract the proper number of "reform days."                              |
+------------------------------------------------------------------------------*/
+int mDate :: daysInMonth ( Month aMonth,
+                           int   aYear )
+   {
+   int leap = ( mDate :: isLeapYear( aYear ) != 0 );
+   int result =  daysToMonth[ leap ][ aMonth ]
+                 -
+                 daysToMonth[ leap ][ aMonth - 1 ];
+   if ( aYear == reformMDY.year
+        &&
+        aMonth == reformMDY.month )
+      result -= reformDays;
+   return result;
+   }
+
+/*------------------------------------------------------------------------------
+| mDate::daysInYear                                                            |
+|                                                                              |
+| Return either 365 or 366 (the latter if the year is a leap year), unless     |
+| this is the year of the Gregorian reform (in which case the length of the    |
+| year is reduced by the number of "reform days.")                             |
+------------------------------------------------------------------------------*/
+int mDate :: daysInYear ( int aYear )
+   {
+   int result = 365 + mDate :: isLeapYear( aYear );
+   if ( aYear == reformMDY.year )
+      result -= reformDays;
+   return result;
+   }
+
+/*------------------------------------------------------------------------------
+| mDate::isLeapYear                                                            |
+|                                                                              |
+| Prior the the Gregorian reform, leap years were any that were even           |
+| multiples of 4. Subsequent to that, century years not divisible by 400 are   |
+| not leap years.  Note that the input int is in "standard" form (-1 is 1      |
+| BC).  Since 1 BC *was* a leap year, we add 1 to negative years before        |
+| testing for being multiples of 4.                                            |
+------------------------------------------------------------------------------*/
+int mDate :: isLeapYear ( int aYear )
+   {
+   int result = 0;
+   int y = aYear + ( aYear < 0 );
+   if ( y % 4 == 0                // Must be divisible by 4...
+        &&
+        ( aYear < reformMDY.year  // ...and either before reform...
+          ||
+          y % 100 != 0            // ...or not a century year...
+          ||
+          y % 400 == 0 ) )        // ...or a multiple of 400...
+      result = 1;              // to be a leap year.
+   return result;
+   }
+
+/*------------------------------------------------------------------------------
+| mDate::isValid                                                               |
+|                                                                              |
+| The year/day version simply makes sure that the day is less than or equal to |
+| the number of days in the year (determined via a call to the static member   |
+| function daysInYear()).                                                      |
+|                                                                              |
+| The year/month/day simply makes sure that the month is valid (just in case)  |
+| and that the day is less than or equal to the number of days in the month    |
+| (determined via a call to the static member function daysInMonth()).  In     |
+| addition, the date cannot be one of days skipped upon adoption of the        |
+| Gregorian calendar reform.                                                   |
+|                                                                              |
+| The year 0 is always rejected.                                               |
+------------------------------------------------------------------------------*/
+int mDate :: isValid ( Month aMonth,
+                           int   aDay,
+                           int   aYear )
+   {
+   // Make sure month and year are legitimate (and day is feasible):
+   int result = ( aMonth >= January
+                      &&
+                      aMonth <= December
+                      &&
+                      aDay > 0
+                      &&
+                      aYear != 0 );
+   int days = reformMDY.day;
+       days += reformDays;
+   if ( result )
+      // OK so far, make sure day is OK, too:
+      if ( aYear == reformMDY.year
+           &&
+           aMonth == reformMDY.month )
+         // int is within month with some deleted days, make
+         // sure it isn't too big (using different calculation)
+         // and that it isn't one of the deleted days:
+         result = ( aDay <= ( mDate::daysInMonth( aMonth, aYear )
+                              +
+                              reformDays )
+                    &&
+                    ( aDay <= reformMDY.day
+                      ||
+                      aDay >  days ) );
+      else
+         // int isn't within month with deleted days, just make
+         // sure the day isn't too big:
+         result = ( aDay <= mDate::daysInMonth( aMonth, aYear ) );
+
+   return result;
+   }
+
+/*------------------------------------------------------------------------------
+| mDate::initialize                                                            |
+|                                                                              |
+| The argument is validated, and if OK, converted to a Julian day number via   |
+| a call to the function MDYToJulian().  The result of this function is        |
+| stored in the data member 'julian.'  If the date is not valid, then the      |
+| mDate is set to Julian day number 0.                                         |
+------------------------------------------------------------------------------*/
+mDate& mDate :: initialize ( Month aMonth,
+                             int   aDay,
+                             int   aYear )
+   {
+      if ( mDate::isValid( aMonth, aDay, aYear ) )
+      {
+         MDY mdy = { aMonth, aDay, aYear };
+         self.julian = MDYToJulian( mdy );
+      }
+      else
+         self.julian = 0;
+      return self;
+   }
+
+/*------------------------------------------------------------------------------
+| julianToMDY                                                                  |
+|                                                                              |
+| Converts from julian into a MDY format.                                      |
+------------------------------------------------------------------------------*/
+static MDY julianToMDY ( unsigned long julianDayNumber )
+   {
+   int reformAdjustment = 0;
+
+   // if after reform, adjust julian day to skip the missing calendar days
+   if (julianDayNumber > reformJulianDayNumber)
+   {
+      julianDayNumber += reformDays;
+      // find the number of centuries year that is not a leap year
+      // according to the reform method.
+      reformAdjustment = (julianDayNumber - dayNumber17010101) / 36524 -
+                         (julianDayNumber - dayNumber16010101) / 146097;
+   }
+   // get the number of 4 complete years since 4713 B.C. by fist
+   // adding the reform adjustment back to julianDayNumber - causing
+   // all years divisible by 4 as leap year.
+   int num4Year = (julianDayNumber + reformAdjustment) / 1461;
+
+   // find the group of 4 year where the julianDayNumber fall into
+   int years = (num4Year << 2) + julianReferenceYear;
+
+   if (years >= 0) years++; // introduce the gap between B.C. & A.D.
+
+   // recalculate the actual number of non leap century year
+   if (reformAdjustment)
+      reformAdjustment = (years - 1701) / 100 - (years - 1601) / 400;
+   // get the days in the group of 4 years, add 1 to make the day
+   // actual day instead of elapse days
+   int days = (julianDayNumber + reformAdjustment) % 1461 + 1;
+
+   // normally, the beginning of 4 year group is a leap year unless
+   // it is one of those non leap century year;
+   int leap = 1;
+   if (years > reformMDY.year &&
+       !(years % 100) &&
+       years % 400)
+      leap = 0;
+
+   // find the year in which the remaining day reside
+   int yearIn4;
+   for (yearIn4 = 1; yearIn4 < 5; yearIn4++)
+      if (daysIn4Years[leap][yearIn4] >= days)
+         break;
+   years += yearIn4 - 1;
+   days -= daysIn4Years[leap][yearIn4 - 1];
+
+   // only the first year can be leap
+   if (yearIn4 > 1)
+      leap = 0;
+
+   // adjust the years between 0 A.D. and 2 A.D. to 1.A.D. to 3 A.D.
+   if (years >= 0 && years <= 2) years++;
+
+   int month;
+   for (month = 1; month < 13; month++)
+       if (days <= daysToMonth[leap][month])
+          break;
+
+   days -= daysToMonth[leap][month - 1];
+
+   MDY result;
+      result.month = (mDate::Month) month;
+      result.day   = days;
+      result.year  = years;
+
+   return result;
+   }
+
+/*------------------------------------------------------------------------------
+| DYToMDY                                                                      |
+|                                                                              |
+| This function takes a date (as day and year) and converts it to              |
+| month/day/year format.  It initializes the result to the given year with     |
+| month January and the given day.  It then iterates till the result day is a  |
+| valid day in the result month (determined via a call to daysInMonth()),      |
+| incrementing the result month and subtracting the days in the month from the |
+| result day.                                                                  |
+|                                                                              |
+| If the resulting MDY is not valid (which would only be the case if it fell   |
+| during the days deleted upon adoption of the Gregorian calendar reform),     |
+| then the day is incremented by the number of days that were deleted and the  |
+| loop iterates again.  The loop terminates when the result day is valid.      |
+|                                                                              |
+| If the input day/year are invalid, then the day number is too big.  In this  |
+| case, the same day appears in the result MDY (which is thus also invalid).   |
+------------------------------------------------------------------------------*/
+static MDY DYToMDY ( int aDay, int aYear )
+   {
+   MDY result;
+      result.month = mDate::January,
+      result.day   = aDay,
+      result.year  = aYear;
+
+   if ( mDate :: isValid( aYear, aDay ) )
+      while ( 1 )
+         {
+         int maxDay = mDate :: daysInMonth( result.month, result.year );
+         if ( result.day > maxDay )
+            result.month = (mDate::Month) ( result.month + 1 ),
+            result.day -= maxDay;
+         else
+           break;
+         }
+
+  if ( result.year == reformMDY.year
+       &&
+       result.month == reformMDY.month
+       &&
+       result.day > reformMDY.day )
+     result.day += reformDays;
+
+   return result;
+   }
+
+/*------------------------------------------------------------------------------
+| MDYToJulian                                                                  |
+|                                                                              |
+| This function converts a calendar date (in year/month/day format) to the     |
+| corresponding Julian day number.                                             |
+|                                                                              |
+| First, if the calendar year is negative, it is incremented by 1. This is     |
+| to put the years in a continuous interval [-4712, ...], which simplifies     |
+| some of the mathematics (and is required by the "julian" algorithm used).    |
+------------------------------------------------------------------------------*/
+static unsigned long MDYToJulian ( MDY aDate )
+   {
+
+   // get the # of years from 4713 B.C. and adjust the gap between B.C. & A.D.
+   int  years = aDate.year - julianReferenceYear - (aDate.year > 0 ? 1 : 0);
+
+   // julian reference year is a leap year, so leap year is the first year
+   // of a 4 year block
+   long int julian_date = years ? (years * 365) + ((years + 3) >> 2) : 0;
+
+   // normally, if the year is divisible by 4, a leap year
+   int  leap = years & 3 ? 0 : 1;
+   // if aDate.year is after reform, then century year not divisible
+   // by 400 is not a leap year
+   if (aDate.year >  reformMDY.year &&
+       !(aDate.year % 100) &&
+       aDate.year % 400)
+      leap = 0;
+
+   // julian is measured as elapse days from 1/1/4713 B.C. so subtract 1
+   // to get elapse days
+   julian_date += daysToMonth[leap][aDate.month -1] + aDate.day - 1;
+
+   if ( julian_date > reformJulianDayNumber )
+   {
+      // after reform, new leap year calculation kicks in so check
+      // for # of elapse centuries and 4 centuries - upto last year
+      aDate.year--;
+      julian_date += (aDate.year - 1600) / 400 - (aDate.year - 1700) / 100;
+      // 11 days missing in the calendar during reform.
+      if (julian_date > reformJulianDayNumber + reformDays)
+         julian_date -= reformDays;
+      else
+         julian_date = reformJulianDayNumber;
+     }
+   return julian_date;
+   }
+
+#if 0
+mDate :: mDate ( const _CDATE &cDate )
+   {
+   self.initialize( (mDate::Month)cDate.month, cDate.day, cDate.year );
+   }
+/*------------------------------------------------------------------------------
+| mDate::asCDATE                                                               |
+|                                                                              |
+| Build result CDATE structure from receiver's day/month/year.                 |
+------------------------------------------------------------------------------*/
+_CDATE mDate :: asCDATE ( ) const
+  {
+  CDATE
+    result = { (unsigned char)this->dayOfMonth(),
+               (unsigned char)this->monthOfYear(),
+               (unsigned short)this->year() };
+  return result;
+  }
+#endif
+
+mDate mDate::today()
+   {
+      time_t t   = time(0);
+      tm     now = *localtime( &t );
+      return mDate(  now.tm_year + 1900, now.tm_yday + 1 );
+   }
+
diff --git a/Massai/cpp/MassaiDLL/dll/src/mList.cpp b/Massai/cpp/MassaiDLL/dll/src/mList.cpp
new file mode 100644
index 00000000..02ac33b7
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/dll/src/mList.cpp
@@ -0,0 +1,339 @@
+/**
+ *  @file      mListBase.cpp
+ *
+ *  @brief     Thread save list implementation
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ *
+ ************************************************************************/
+
+#include "mList.h"
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        void mListBase::append(void *item)
+ *
+ *  @brief     appends an item at the end of the list
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+void mListBase::append(void *item)
+{
+    if(item)
+    {
+      mThreadAutoMutex protect(&sem);
+
+      l.push_back(item);
+
+      c = l.end();
+    }
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        void mListBase::insert(void *item)
+ *
+ *  @brief     inserts an item at the bginning of the list
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+void mListBase::insert(void *item)
+{
+    if(item)
+    {
+      mThreadAutoMutex protect(&sem);
+
+      l.push_front(item);
+
+      c = l.begin();
+    }
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        void mListBase::remove(void *item)
+ *
+ *  @brief     removes the specified item from the list
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+void mListBase::remove(void *item)
+{
+std::list<void *>::iterator tmp;
+std::list<void *>::iterator i;
+bool fFound;
+
+    if(item)
+    {
+      mThreadAutoMutex protect(&sem);
+
+      for(i = l.begin(), fFound = false; i != l.end() && !fFound; i++)
+      {
+        tmp = i;
+
+        if((*i) == item)
+          fFound = true;
+      }
+
+      if(fFound)
+      {
+        l.erase(tmp);
+      }
+    }
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mListBase::replace(void *oldItem, void *newItem)
+ *
+ *  @brief     replaces an old item with a new one
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mListBase::replace(void *oldItem, void *newItem)
+{
+std::list<void *>::iterator tmp;
+std::list<void *>::iterator i;
+bool fFound;
+long rc = 0;
+
+    if(oldItem && newItem)
+    {
+      mThreadAutoMutex protect(&sem);
+
+      for(i = l.begin(), fFound = false; i != l.end() && !fFound; i++)
+      {
+        tmp = i;
+
+        if((*i) == oldItem)
+          fFound = true;
+      }
+
+      if(fFound)
+      {
+        l.erase(tmp);
+        l.insert(i,newItem);
+
+        // adjust cursor
+
+        c = i;
+      }
+      else
+        rc = -2;
+
+      return(rc);
+    }
+    else
+      return(-1);
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        void mListBase::deleteAll()
+ *
+ *  @brief     deletes all items from the list
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+void mListBase::deleteAll()
+{
+    mThreadAutoMutex protect(&sem);
+    l.clear();
+    c = l.begin();
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        void *mListBase::first()
+ *
+ *  @brief     returns the first item in the list
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+void *mListBase::first()
+{
+    mThreadAutoMutex protect(&sem);
+
+    if(l.size())
+    {
+      c = l.begin();
+
+      return((*c));
+    }
+    else
+      return(NULL);
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        void *mListBase::last()
+ *
+ *  @brief     returns last item in the list
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+void *mListBase::last()
+{
+    mThreadAutoMutex protect(&sem);
+
+    if(l.size())
+    {
+      c = l.end();
+      c--;
+
+      return((*c));
+    }
+    else
+      return(NULL);
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        void *mListBase::next()
+ *
+ *  @brief     returns next item following the cursor
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+void *mListBase::next()
+{
+    mThreadAutoMutex protect(&sem);
+
+    if(++c != l.end())
+      return((*c));
+    else
+      return(NULL);
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        void *mListBase::previous()
+ *
+ *  @brief     returns item before the cursor
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+void *mListBase::previous()
+{
+    mThreadAutoMutex protect(&sem);
+
+    if(--c != l.begin())
+      return((*c));
+    else
+      return(NULL);
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        void *mListBase::current()
+ *
+ *  @brief     returns the item at the current cursor position
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+void *mListBase::current()
+{
+    mThreadAutoMutex protect(&sem);
+
+    if(l.size())
+      return((*c));
+    else
+      return(NULL);
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mListBase::items()
+ *
+ *  @brief     returns the number of items in the list
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mListBase::items()
+{
+    mThreadAutoMutex protect(&sem);
+
+    return(l.size());
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        mListBase::mListBase()
+ *
+ *  @brief     class constructor
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+mListBase::mListBase()
+{
+    c = l.begin();
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        mListBase::~mListBase()
+ *
+ *  @brief     class destructor
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+mListBase::~mListBase()
+{
+    mThreadAutoMutex protect(&sem);
+
+    try { deleteAll(); } catch(...) {};
+}
\ No newline at end of file
diff --git a/Massai/cpp/MassaiDLL/dll/src/mThread.cpp b/Massai/cpp/MassaiDLL/dll/src/mThread.cpp
new file mode 100644
index 00000000..7923e97d
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/dll/src/mThread.cpp
@@ -0,0 +1,260 @@
+/****************************************************************************
+
+ FILE:      mThread.cpp
+
+ PURPOSE:   MUtils - thread class implemtation
+
+ DATE:      21/11/97
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+#include "massai.hpp"
+#include "mThread.hpp"
+
+class mCritSec
+{
+private:
+
+    static CRITICAL_SECTION *pCriticalSection;
+
+public:
+
+    mCritSec()
+    {
+      if(!pCriticalSection)
+      {
+         pCriticalSection= new CRITICAL_SECTION;
+         InitializeCriticalSection(pCriticalSection);
+      }
+
+      EnterCriticalSection(pCriticalSection);
+    }
+
+    ~mCritSec()
+    {
+      LeaveCriticalSection(pCriticalSection);
+
+      //  Deleting this causes race conditions at process shutdown.  We
+      //  let the critical section be cleaned up by the system.
+      //    DeleteCriticalSection(pCriticalSection);
+      //    delete pCriticalSection;
+      //    pCriticalSection = 0;
+    };
+
+};
+
+CRITICAL_SECTION *mCritSec::pCriticalSection = 0;
+
+//---------------------------------------------------------------------------
+//
+//  function:   static void _run (void *p)
+//
+//  purpose:    thread execution function
+//
+//  date:       18.07.2001, 09:40
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+static void _run (void *p)
+{
+mThread *pClass = (mThread *)p;
+
+    if(p)
+    {
+      while(pClass->fRun)
+      {
+        pClass->fRunning = true;
+
+        pClass->lError = pClass->function();
+
+        if(pClass->lError == -1)
+        {
+          pClass->fRunning = false;
+          return;
+        }
+        else
+          OS_Sleep(1);
+      }
+    }
+
+    pClass->fRunning = false;
+
+    return;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long mThread::setTimeCritical()
+//
+//  purpose:    change priority
+//
+//  date:       18.07.2001, 09:40
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long mThread::setTimeCritical()
+{
+  mCritSec protect;
+
+  fRun = false;
+
+  lError = OS_SetPrty(PRTYS_THREAD,PRTYC_TIMECRITICAL,0,lTid);
+
+  fRun = true;
+
+  return(lError);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long mThread::setRegular()
+//
+//  purpose:    change priority
+//
+//  date:       18.07.2001, 09:40
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long mThread::setRegular()
+{
+  mCritSec protect;
+
+  fRun = false;
+
+  lError = OS_SetPrty(PRTYS_THREAD,PRTYC_REGULAR,0,lTid);
+
+  fRun = true;
+
+  return(lError);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long mThread::run ()
+//
+//  purpose:    create and start thread
+//
+//  date:       18.07.2001, 09:40
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long mThread::run ()
+{
+  fRun = true;
+
+  lError = OS_CreateThread((unsigned long *)&lTid,PFNTHREAD(_run),long(this),0,lStackSize);
+
+  return (lError);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void mThread::stop ()
+//
+//  purpose:    pause execution
+//
+//  date:       18.07.2001, 09:41
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void mThread::stop ()
+{
+  if(!fStopped)
+  {
+    mCritSec protect;
+
+    fRun     = false;
+    fStopped = true;
+  }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void mThread::restart ()
+//
+//  purpose:    restart execution
+//
+//  date:       18.07.2001, 09:41
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void mThread::restart ()
+{
+  if(fStopped)
+  {
+    fRun     = true;
+    fStopped = false;
+  }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long mThread::killWait()
+//
+//  purpose:    kill it (gracefully)
+//
+//  date:       18.07.2001, 09:41
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long mThread::killWait()
+{
+  {
+    mCritSec protect;
+
+    fRun    = false;
+    fKilled = true;
+  }
+
+  while(fRunning) OS_Sleep(1);
+
+  lError = OS_KillThread(lTid);
+
+  return (lError);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long mThread::kill ()
+//
+//  purpose:    kill it
+//
+//  date:       18.07.2001, 09:41
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long mThread::kill ()
+{
+  {
+    mCritSec protect;
+
+    fRun    = false;
+    fKilled = true;
+  }
+
+  lError = OS_KillThread(lTid);
+
+  return (lError);
+}
+
+/****************************************************************************
+ END OF FILE
+****************************************************************************/
diff --git a/Massai/cpp/MassaiDLL/dll/src/mThreadEx.cpp b/Massai/cpp/MassaiDLL/dll/src/mThreadEx.cpp
new file mode 100644
index 00000000..88db7b29
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/dll/src/mThreadEx.cpp
@@ -0,0 +1,459 @@
+/**
+ *  @file      mThreadEx.cpp
+ *
+ *  @brief     Thread class implementation
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ *
+ ************************************************************************/
+
+#include "mThreadEx.h"
+
+static ACE_Thread_Mutex _sem;
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        static void *worker(mThread *p)
+ *
+ *  @brief     threads worker function
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+static void *worker(mThreadEx *p)
+{
+long rc = 0;
+
+    p->lId = GetCurrentThreadId();
+
+    while(ACE_Thread_Manager::instance()->testcancel(ACE_Thread::self()) == 0)
+    {
+      try
+      {
+        if(p->isSynchronized())
+        {
+          _sem.acquire();
+
+          rc = ((mSynchThread *)p)->synchronized();
+
+          _sem.release();
+        }
+        else
+          rc = p->function();
+      }
+      catch(...)
+      {
+        rc = -1;
+      }
+
+      if(rc < 0)
+      {
+        // terminate thread when return value is < 0
+
+        break;
+      }
+    }
+
+    // Destructor removes thread from Thread_Manager.
+
+    return 0;
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mThreadEx::isSynchronized()
+ *
+ *  @brief     return synchronized flag
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mThreadEx::isSynchronized()
+{
+    return(lSynchronized);
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mThreadEx::error()
+ *
+ *  @brief     retruns current error
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mThreadEx::error()
+{
+    return(lError);
+};
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mThreadEx::run()
+ *
+ *  @brief     starts execution
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mThreadEx::run()
+{
+    if(groupId)
+      return(0);
+
+    if(pThreadMgr)
+    {
+      groupId = pThreadMgr->spawn_n(lThreads,
+                                    ACE_THR_FUNC (worker),
+                                    ACE_reinterpret_cast (void *,this),
+                                    THR_NEW_LWP | THR_DETACHED);
+    }
+    else
+    {
+      lError = -1;
+    }
+
+    return(error());
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mThreadEx::stop()
+ *
+ *  @brief     suspends execution
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mThreadEx::stop()
+{
+    if(pThreadMgr)
+    {
+      lError = pThreadMgr->suspend_grp(groupId);
+    }
+    else
+    {
+      lError = -1;
+    }
+
+    return(error());
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mThreadEx::restart()
+ *
+ *  @brief     resumes execution
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mThreadEx::restart()
+{
+    if(pThreadMgr)
+    {
+      lError = pThreadMgr->resume_grp(groupId);
+    }
+    else
+    {
+      lError = -1;
+    }
+
+    return(error());
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mThreadEx::kill()
+ *
+ *  @brief     stops execution
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mThreadEx::kill()
+{
+    if(pThreadMgr)
+    {
+      lError = pThreadMgr->cancel_grp(groupId);
+    }
+    else
+    {
+      lError = -1;
+    }
+
+    return(error());
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mThreadEx::killWait()
+ *
+ *  @brief     stops execution & waits for termination
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mThreadEx::killWait()
+{
+    if(pThreadMgr)
+    {
+      lError = kill();
+      wait();
+    }
+    else
+    {
+      lError = -1;
+    }
+
+    return(error());
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mThreadEx::wait()
+ *
+ *  @brief     waits for thread termination
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mThreadEx::wait()
+{
+    if(groupId && pThreadMgr)
+    {
+      lError = pThreadMgr->wait_grp(groupId);
+    }
+    else
+    {
+      lError = -1;
+    }
+
+    return(error());
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mThreadEx::id()
+ *
+ *  @brief     returns thread identifier
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mThreadEx::id()
+{
+    if(lThreads > 1)
+      return(groupId);
+    else
+      return(lId);
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        mThreadEx::mThreadEx()
+ *
+ *  @brief     class constructor
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+mThreadEx::mThreadEx(long lCopies)
+{
+    lId           = 0;
+    lSynchronized = 0;
+    groupId       = 0;
+    lThreads      = lCopies;
+
+    pThreadMgr    = ACE_Thread_Manager::instance();
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        mThreadEx::~mThreadEx()
+ *
+ *  @brief     class destructor
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+mThreadEx::~mThreadEx()
+{
+    //try { killWait(); } catch(...) {};
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        mSynchThread::mSynchThread()
+ *
+ *  @brief     class constructor
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+mSynchThread::mSynchThread()
+{
+    // simply set this flag
+
+    lSynchronized = 1;
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        mSynchThread::~mSynchThread()
+ *
+ *  @brief     class destructor (rely on base class' destructor)
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+mSynchThread::~mSynchThread()
+{
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mThreadMutex::lock()
+ *
+ *  @brief     lock the semaphor
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mThreadMutex::lock()
+{
+    return(sem.acquire());
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mThreadMutex::trylock()
+ *
+ *  @brief     try to lock the semaphor (don't block)
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mThreadMutex::trylock()
+{
+    return(sem.tryacquire());
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mThreadMutex::unlock()
+ *
+ *  @brief     unlock the semaphor
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mThreadMutex::unlock()
+{
+    return(sem.release());
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        mThreadMutex::mThreadMutex(const char *pszName)
+ *
+ *  @brief     class constructor
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+mThreadMutex::mThreadMutex(const char *pszName)
+  : sem((const ACE_TCHAR *) pszName)
+{
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        mThreadAutoMutex::mThreadAutoMutex(mThreadMutex& s)
+ *
+ *  @brief     auto lock the semaphor
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+mThreadAutoMutex::mThreadAutoMutex(mThreadMutex *s)
+{
+    sem = s;
+    sem->lock();
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        mThreadAutoMutex::~mThreadAutoMutex()
+ *
+ *  @brief     auto unlock the semaphor
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+mThreadAutoMutex::~mThreadAutoMutex()
+{
+    sem->unlock();
+}
diff --git a/Massai/cpp/MassaiDLL/dll/src/mTime.cpp b/Massai/cpp/MassaiDLL/dll/src/mTime.cpp
new file mode 100644
index 00000000..490c18a5
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/dll/src/mTime.cpp
@@ -0,0 +1,43 @@
+//-------------------------------------------------------------------------
+//
+// mTime.cpp
+//
+// Implementation file for mTime.hpp
+//
+// Dr.Materna GmbH 1999, jk
+//
+//-------------------------------------------------------------------------
+
+#include "mTime.hpp"
+#include <iostream.h>
+
+
+
+static void dec2( char * Dst, unsigned N )
+   {
+      N %= 100;
+      Dst[0] = (N / 10) + '0';
+      Dst[1] = (N % 10) + '0';
+   }
+
+
+
+std::ostream & operator <<( std::ostream & OS, const mTime & Time )
+   {
+      char Buffer[9];
+      dec2( Buffer+0, Time.hours() );
+      Buffer[2] = ':';
+      dec2( Buffer+3, Time.minutes() );
+      Buffer[5] = ':';
+      dec2( Buffer+6, Time.seconds() );
+      Buffer[8] = 0;
+      OS << Buffer;
+      return OS;
+   }
+
+
+
+//-------------------------------------------------------------------------
+// End of file
+//-------------------------------------------------------------------------
+
diff --git a/Massai/cpp/MassaiDLL/dll/src/mTimer.cpp b/Massai/cpp/MassaiDLL/dll/src/mTimer.cpp
new file mode 100644
index 00000000..d8880d5a
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/dll/src/mTimer.cpp
@@ -0,0 +1,203 @@
+//---------------------------------------------------------------------------
+//
+//  file:       mTimer.cpp
+//
+//  purpose:    Timer implementation
+//
+//  date:       02.11.00, 10:45
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include <sys/timeb.h>
+
+#include "base_os.h"
+#include "mTimer.hpp"
+
+// function prototypes ------------------------------------------------------
+
+void LINKAGE timerThread(mTimer *timer);
+
+/*---------------------------------------------------------------------------
+
+ FUNCTION:  void _SYSTEM TimerThread()
+
+ COMMENTS:  timer thread
+
+ DATE:      03/05/96 - 17:42:11
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+---------------------------------------------------------------------------*/
+
+PRIVATE void LINKAGE timerThread(mTimer *timer)
+{
+ULONG ulCntSem;
+LONG  lMillis;
+
+    //printf("timer: waiting to start (initial)...\n");
+
+    OS_WaitEventSem(timer->hEvent,-1);
+    OS_ResetEventSem(timer->hEvent,&ulCntSem);
+
+    while(timer->lMilliSeconds >= 0)
+    {
+      lMillis = timer->lMilliSeconds;
+
+      if(lMillis > 0)
+      {
+        //printf("timer: started.\n");
+
+        while(lMillis >= 0 && timer->lMilliSeconds > 0)
+        {
+           lMillis -= 10;
+           OS_Sleep(10);
+        }
+
+        if(timer->lMilliSeconds > 0)
+        {
+          //printf("timer: elapsed.\n");
+
+          if(timer->ticker() < 0)
+          {
+            //printf("timer: handler called (one shot).\n");
+            return;
+          }
+          //else
+            //printf("timer: handler called.\n");
+        }
+        //else
+          //printf("timer: interrupted\n");
+      }
+      else
+      {
+        //printf("timer: waiting to start...\n");
+
+        OS_WaitEventSem(timer->hEvent,-1);
+        OS_ResetEventSem(timer->hEvent,&ulCntSem);
+      }
+    }
+
+    //printf("timer: thread terminated ...\n");
+
+    return;
+}
+
+/*---------------------------------------------------------------------------
+
+ METHOD:    void ~mTimer(void)
+
+ COMMENTS:  destructor of the class
+
+ DATE:      03/07/96 - 12:31:50
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+---------------------------------------------------------------------------*/
+
+mTimer::~mTimer()
+{
+    lMilliSeconds = -1;
+
+    OS_PostEventSem(hEvent);
+
+    if(hEvent)
+      OS_CloseEventSem(hEvent);
+
+    return;
+}
+
+/*---------------------------------------------------------------------------
+
+ METHOD:    void mTimer(void)
+
+ COMMENTS:  constructor of the class
+
+ DATE:      03/07/96 - 12:31:50
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+---------------------------------------------------------------------------*/
+
+mTimer::mTimer()
+{
+    hEvent = 0;
+
+    OS_CreateEventSem(NULL,&hEvent,DC_SEM_SHARED,FALSE);
+
+    lMilliSeconds = 0;
+
+    OS_CreateThread(&tidWT,(PFNTHREAD)timerThread,(long)this,0L,8192);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   mTimer::mTimer(long lMillis)
+//
+//  purpose:    class constructor
+//
+//  date:       02.11.00, 13:08
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+mTimer::mTimer(long lMillis)
+{
+    hMutex = 0;
+    hEvent = 0;
+
+    OS_CreateEventSem(NULL,&hEvent,DC_SEM_SHARED,FALSE);
+
+    lMilliSeconds = lMillis;
+
+    OS_CreateThread(&tidWT,(PFNTHREAD)timerThread,(long)this,0L,8192);
+
+    OS_PostEventSem(hEvent);
+}
+
+/*---------------------------------------------------------------------------
+
+ FUNCTION:  void mTimer::start(long lMillis)
+
+ COMMENTS:  start timer
+
+ DATE:      03/05/96 - 17:42:50
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+---------------------------------------------------------------------------*/
+
+void mTimer::start(long lMillis)
+{
+    lMilliSeconds = lMillis;
+
+    OS_PostEventSem(hEvent);
+}
+
+/*---------------------------------------------------------------------------
+
+ FUNCTION:  void mTimer::stop(void)
+
+ COMMENTS:  stop timer
+
+ DATE:      03/05/96 - 17:43:27
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+---------------------------------------------------------------------------*/
+
+void mTimer::stop(void)
+{
+    /* Clear this record */
+
+    lMilliSeconds = 0;
+
+    // just wait a little bit
+
+    OS_Sleep(10);
+}
+
+
+
diff --git a/Massai/cpp/MassaiDLL/dll/src/mTraceEx.cpp b/Massai/cpp/MassaiDLL/dll/src/mTraceEx.cpp
new file mode 100644
index 00000000..6e09aab0
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/dll/src/mTraceEx.cpp
@@ -0,0 +1,635 @@
+//---------------------------------------------------------------------------
+//
+//  file:       mTraceEx.cpp
+//
+//  purpose:    extended trace functionality for CUSS applications
+//
+//  date:       28.12.2001, 13:01
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include <io.h>
+#include <direct.h>
+
+#include "mTrace.hpp"
+#include "mConfig.h"
+#include <stdio.h>
+
+#define MAX_TRACE_BUF (1024 * 1) // 1KByte buffer for tracing
+
+APIRET addToHistory(CHAR *pszFile);
+
+#define MAX_FILE_SIZE     (1024L * 1024L * 10) //10Mb
+
+unsigned long ulMaxFileSize = MAX_FILE_SIZE;
+
+//---------------------------------------------------------------------------
+//
+//  function:   static char *byte2Hex(int x)
+//
+//  purpose:
+//
+//  date:       02.12.2002, 10:58
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+static char *byte2Hex(int x)
+{
+static char szTmp[3];
+int x1,x2;
+
+    x &= 0xff;
+
+    x1 = (x / 16);
+    x2 = (x % 16);
+
+    szTmp[0] = x1 < 10 ? '0' + (char) x1 : 'a' + (char) (x1 - 10);
+    szTmp[1] = x2 < 10 ? '0' + (char) x2 : 'a' + (char) (x2 - 10);
+
+    szTmp[2] = '\0';
+
+    return(szTmp);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   static char *byte2HEX(int x)
+//
+//  purpose:
+//
+//  date:       02.12.2002, 10:58
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+static char *byte2HEX(int x)
+{
+static char szTmp[3];
+int x1,x2;
+
+    x &= 0xff;
+
+    x1 = (x / 16);
+    x2 = (x % 16);
+
+    szTmp[0] = x1 < 10 ? '0' + (char) x1 : 'A' + (char) (x1 - 10);
+    szTmp[1] = x2 < 10 ? '0' + (char) x2 : 'A' + (char) (x2 - 10);
+
+    szTmp[2] = '\0';
+
+    return(szTmp);
+}
+
+long mTraceEx::OpenTraceFile(long lLevel)
+{
+char   *pStr;
+char    szPath[1024];
+long    rc=0;
+
+mConfig tracePath("MUTILS","TRACE","TracePath");
+
+    if(tracePath.error() != 0)
+    {
+      if(rc = QueryMUtilsPath(szPath))
+        return rc;
+
+      if((pStr = strrchr(szPath,'\\')) != NULL)
+         *pStr = '\0';
+
+      strcat(szPath,"\\trc");
+    }
+    else
+      tracePath.asString(szPath,sizeof(szPath));
+
+    mConfig traceSize("MUTILS","TRACE","MaxFileSize");
+    if (!traceSize.error())
+    {
+      ulMaxFileSize = traceSize.asInt();
+    }
+
+
+    if(access(szPath,0))
+      OS_MkDir(szPath,0L);
+
+    pTraceFile   = NULL;
+    lTraceLevel  = lLevel;
+    fFileRenamed = false;
+
+    if(strlen(szFileName)>0)
+      sprintf(szTraceFileName,"%s\\%s",szPath,szFileName);
+    else
+      sprintf(szTraceFileName,"%s\\trc%p",szPath,this);
+
+    strcpy(szTmpFileName, szTraceFileName);
+    /* Check for existence */
+    if( (_access( szTmpFileName, 0 )) != -1 )
+    {
+      /* Rename */
+      addToHistory(szTmpFileName);
+    }
+
+    pTraceFile = fopen(szTmpFileName,"wb");
+
+return rc;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   mTraceEx::mTraceEx(long lLevel,char *pszFileName)
+//
+//  purpose:    class constructor
+//
+//  date:       28.12.2001, 13:21
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+mTraceEx::mTraceEx(long lLevel,char *pszFileName)
+{
+    strcpy(szLocation,"");
+    strcpy(szId,"");
+    strcpy(szFileName, pszFileName);
+    OpenTraceFile(lLevel);
+
+    pTraceBuffer = (char*) malloc(MAX_TRACE_BUF);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   mTraceEx::~mTraceEx()
+//
+//  purpose:    class destructor
+//
+//  date:       28.12.2001, 13:22
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+mTraceEx::~mTraceEx()
+{
+    if(pTraceFile)
+    {
+      if(!fFileRenamed)
+      {
+        // move temporary trace to default location
+
+        // move(); only move if owner explicit wants to.
+      }
+    }
+
+    if(pTraceFile)
+      fflush(pTraceFile);
+
+    if(pTraceFile)
+      fclose(pTraceFile);
+
+    if(pTraceBuffer) free(pTraceBuffer);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void mTraceEx::createDir(char *pszPath)
+//
+//  purpose:    creates a directory from the given path
+//
+//  date:       28.12.2001, 14:05
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void mTraceEx::createDir(char *pszPath)
+{
+char  szPath[1024];
+char *pEnd = szPath;
+char del= 0;
+
+    if(!pszPath)
+      return;
+
+    strcpy(szPath,pszPath);
+
+    do
+    {
+      while(*pEnd != 0 && *pEnd != '/' && *pEnd != '\\')
+        ++pEnd;
+      del= *pEnd;
+      *pEnd= 0;
+
+      _mkdir(szPath);
+
+      *pEnd= del;
+      ++pEnd;
+    } while(del != 0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void mTraceEx::printDatetime(char *buf)
+//
+//  purpose:    write current date/timeto buf
+//
+//  date:       16.08.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+long mTraceEx::printDatetime(char* buf)
+{
+  DATETIME  Date;
+  long result= 0;
+  OS_GetDateTime(&Date);
+
+  result= sprintf(buf, "%02d%02d %02d%02d:%02d.%02d ",
+                       Date.day,
+                       Date.month,
+                       Date.hours,
+                       Date.minutes,
+                       Date.seconds,
+                       Date.hundredths);
+
+  return result;
+}
+//---------------------------------------------------------------------------
+//
+//  function:   void mTraceEx::printFileLine(char *buf, char *pszFile,long lLine)
+//
+//  purpose:    write file name, line to buf
+//
+//  date:       16.08.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+long mTraceEx::printFileLine(char* buf, char *pszFile,long lLine)
+{
+  char szFile[CHARBUF];
+  long result= 0;
+  char *pStr= 0;
+
+  strncpy(szFile,pszFile, sizeof(szFile));
+  szFile[sizeof(szFile) - 1]= 0;
+
+  // cut path from file name
+
+  if((pStr = strrchr(szFile,'\\')) != NULL)
+    strcpy(szFile,pStr +1);
+
+  // cut file name extension
+
+  if((pStr = strrchr(szFile,'.')) != NULL)
+    *pStr = '\0';
+
+  result += sprintf(buf,"%-16s(%4d): ",szFile,lLine);
+  return result;
+}
+
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   void mTraceEx::writeTrace(char* pData)
+//
+//  purpose:    write pData to the trace file
+//
+//  date:       16.08.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+void mTraceEx::writeTrace(char* pData, long len)
+{
+  fpos_t    pos;
+
+  if (fseek(pTraceFile,0,SEEK_END) == 0)
+  {
+    if( fgetpos( pTraceFile, &pos ) == 0 )
+    {
+      if(pos > ulMaxFileSize)
+      {
+        move(szLocation, szId);
+      }
+    }
+  }
+
+  OutputDebugString((char *)pData);
+  fwrite((void *)pData,sizeof(char),len,pTraceFile);
+  fflush(pTraceFile);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   void mTraceEx::move(char *pszLocation, char *pszId)
+//
+//  purpose:
+//
+//  date:       28.12.2001, 13:22
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void mTraceEx::move(char *pszLocation, char *pszId)
+{
+DATETIME Date;
+char     szPath   [512];
+char     szDefPath[512];
+char     szTmp    [1024];
+char    *pStr;
+long     rc;
+mConfig  tracePath("MUTILS","TRACE","TracePath");
+
+    accessTrace.request();
+    try
+    {
+      if (pszLocation)
+        strcpy(szLocation, pszLocation);
+
+      if (pszId)
+        strcpy(szId, pszId);
+
+      if(tracePath.error() != 0)
+      {
+        if(rc = QueryMUtilsPath(szDefPath))
+        {
+          accessTrace.release();
+          return;
+        }
+
+        if((pStr = strrchr(szDefPath,'\\')) != NULL)
+           *pStr = '\0';
+
+        strcat(szDefPath,"\\trc");
+      }
+      else
+        tracePath.asString(szDefPath,sizeof(szDefPath));
+
+      OS_GetDateTime(&Date);
+
+      if(!pszLocation || !pszId)
+      {
+        // save to default path
+
+        sprintf(szPath,"%s\\%02d%02d\\",szDefPath,Date.day,Date.month);
+      }
+      else if(pszLocation && !pszId)
+      {
+        // save to default//location
+
+        sprintf(szPath,"%s\\%s\\%02d%02d\\",szDefPath,pszLocation,Date.day,Date.month);
+      }
+      else if(!pszLocation && pszId)
+      {
+        // save to default//id
+
+        sprintf(szPath,"%s\\%s\\%02d%02d\\",szDefPath,pszId,Date.day,Date.month);
+      }
+      else
+      {
+        // save to default//location/id
+
+        sprintf(szPath,"%s\\%s\\%s\\%02d%02d\\",szDefPath,pszLocation,pszId,Date.day,Date.month);
+      }
+
+      createDir(szPath);
+
+      if((pStr = strstr(strlwr(szTraceFileName),".trc")) != NULL)
+        *pStr = '\0';
+
+      //if((pStr = strrchr(szTraceFileName,'\\')) != NULL)
+      if((pStr = strrchr(szFileName,'\\')) != NULL)
+        sprintf(szTmp,"%s%s.%02d%02d%02d.trc",szPath,pStr +1,
+                                                 Date.hours,Date.minutes,Date.seconds);
+      else
+        //sprintf(szTmp,"%s\\%s.%02d%02d%02d.trc",szPath,szTraceFileName,
+        sprintf(szTmp,"%s\\%s.%02d%02d%02d.trc",szPath,szFileName,
+                                                 Date.hours,Date.minutes,Date.seconds);
+
+      strcpy(szTraceFileName,szTmp);
+
+      fclose(pTraceFile);
+
+      rc = OS_Move(szTmpFileName,szTraceFileName);
+
+      pTraceFile = fopen(szTraceFileName,"ab");
+
+      rc = _unlink(szTmpFileName);
+
+      fFileRenamed = true;
+    }
+    catch(...)
+    {}
+    accessTrace.release();
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void mTraceEx::write(long lLevel,char *pszFile,long lLine,char *pszFormat, ...)
+//
+//  purpose:    trace function
+//
+//  date:       28.12.2001, 13:22
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void mTraceEx::write(long lLevel,char *pszFile,long lLine,char *pszFormat, ...)
+{
+long      lLen;
+char     *pTmp;
+long      bufSize;
+char     *pBuf= 0;
+
+va_list   arg_ptr;
+    // look if trace file opened
+
+    accessTrace.request();
+    try
+    {
+      if((pTraceFile && pTraceBuffer) && (lLevel <= lTraceLevel || lLevel == 255))
+      {
+        pTmp = pTraceBuffer;
+        lLen = 0;
+
+        // check given arguments
+        if(pszFile && pszFormat)
+        {
+          // write traces with date and time
+          lLen+= printDatetime(pTmp + lLen);
+          lLen+= printFileLine(pTmp + lLen, pszFile, lLine);
+
+          // get pointer to first argument
+          va_start(arg_ptr,pszFormat);
+          // print into buffer
+          bufSize= _vsnprintf(0, 0, pszFormat, arg_ptr);
+          if(bufSize + lLen + 2 > MAX_TRACE_BUF)
+          {
+            try
+            {
+              pBuf= new char[bufSize + lLen + 2];
+            }
+            catch(...)
+            {}
+            if(pBuf != 0)
+            {
+              strncpy(pBuf, pTmp, lLen + 1);
+
+              pTmp= pBuf;
+              lLen+= _vsnprintf(pTmp + lLen, bufSize, pszFormat, arg_ptr);
+            }
+            else
+            {
+              bufSize= _vsnprintf(pTmp + lLen, MAX_TRACE_BUF - lLen, pszFormat, arg_ptr);
+              lLen= MAX_TRACE_BUF - 2;
+            }
+          }
+          else
+          {
+            bufSize= _vsnprintf(pTmp + lLen, MAX_TRACE_BUF - lLen, pszFormat, arg_ptr);
+            lLen+= bufSize;
+          }
+          va_end(arg_ptr);
+
+          lLen += sprintf(pTmp + lLen,"\n");
+        }
+        else
+          lLen = sprintf(pTmp,"<< INVALID TRACE >>");
+
+        *(pTmp + lLen) = '\0';
+
+        // write everything to file (only if owner !!)
+
+        writeTrace(pTmp, lLen);
+        if(pBuf != 0)
+        {
+          delete[] pBuf;
+        }
+      }
+    }
+    catch(...)
+    {}
+    accessTrace.release();
+
+    return;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void mTraceEx::dump(long lLevel,char *pszFile,long lLine,void *pData, long len)
+//
+//  purpose:    dump function
+//
+//  date:       28.12.2001, 13:22
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void mTraceEx::dump(long lLevel,char *pszFile,long lLine,void *pData, long len)
+{
+long    i,j;
+long    rc;
+char   *pTmp,
+       *pd;
+long    lSize;
+char   *pBuf= 0;
+
+    pd = (char *)pData;
+
+    accessTrace.request();
+    try
+    {
+      if((pTraceFile && pTraceBuffer) && (lLevel <= lTraceLevel || lLevel == 255))
+      {
+        lSize = ((len >> 4) + 1) * 90 + 290;
+
+        if(!pd || !len)
+        {
+          accessTrace.release();
+          return;
+        }
+
+        pTmp = pTraceBuffer;
+        if(lSize > MAX_TRACE_BUF)
+        {
+          try
+          {
+            pBuf = new char[lSize];
+          }
+          catch(...)
+          {}
+          if(pBuf)
+          {
+            pTmp= pBuf;
+          }
+          else
+          {
+            lSize= MAX_TRACE_BUF;
+          }
+        }
+
+
+        if(pszFile)
+        {
+          rc= 0;
+          rc+= printDatetime(pTmp + rc);
+          rc+= printFileLine(pTmp + rc, pszFile, lLine);
+          rc+= sprintf(pTmp + rc,"%c",'\n');
+
+          for(i = 0; i < len && rc < lSize - 95; i += 16)
+          {
+            rc += sprintf(pTmp +rc,"[%04x,%04d] ",i,i);
+
+            for(j = 0; j < 16 && (i+j) < len; j++)
+            {
+              if(j == 8)
+                rc += sprintf(pTmp + rc,"- %s ",byte2Hex(pd[i+j]));
+              else
+                rc += sprintf(pTmp + rc,"%s ",byte2Hex(pd[i+j]));
+            }
+
+            while(j < 16)
+            {
+              if(j == 8)
+                rc += sprintf(pTmp + rc,"     ");
+              else
+                rc += sprintf(pTmp + rc,"   ");
+
+              j++;
+            }
+
+            for(j = 0; j < 16 && (i+j) < len; j++)
+              rc += sprintf(pTmp + rc,"%c",(pd[i+j] >= ' ') ? pd[i+j]: '.');
+
+            rc += sprintf(pTmp + rc,"\n");
+          }
+        }
+        else
+        {
+          rc= sprintf(pTmp,"<< INVALID TRACE >>");
+        }
+        *(pTmp + rc) = '\0';
+        writeTrace(pTmp, rc);
+        if(pBuf != 0)
+        {
+          delete[] pBuf;
+        }
+      }
+    }
+    catch(...)
+    {}
+    accessTrace.release();
+    return;
+}
\ No newline at end of file
diff --git a/Massai/cpp/MassaiDLL/dll/src/massai.cpp b/Massai/cpp/MassaiDLL/dll/src/massai.cpp
new file mode 100644
index 00000000..75624b24
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/dll/src/massai.cpp
@@ -0,0 +1,1428 @@
+/****************************************************************************
+
+ FILE:      mUtils.cpp
+
+ PURPOSE:   Exported basic massai functions.
+
+ DATE:      11/23/95 - 15:18:31
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+#include <io.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <time.h>
+#include <signal.h>
+
+#include "iostream.h"
+
+#include "base_os.h"
+#include "massai.hpp"
+#include "mtrace.hpp"
+#include "mConfig.h"
+#include "globbase.hpp"
+#include "trace.hpp"
+
+// private constants *********************************************************
+
+#define MAGIC_ID          1234567
+
+typedef struct _M_process
+        {
+          long      ulProcessID;
+          long      ulSessionID;
+          HANDLE    hProcess;
+          bool      fKeepAlive;
+          bool      fCleanupCalled;
+          bool      fStartupCalled;
+        }
+        M_PROCESS;
+
+/* private function prototypes ***********************************************/
+
+static APIRET        mBasicServicesInit (void);  // do DLL initilizations
+static void APIENTRY mBasicServicesTerm (long ulReason) ;
+
+/* global vars for this file  ************************************************/
+
+static HMTX        hmtxSocketSem  = 0;
+static HMTX        hmtxTraceSem   = 0;
+static HMTX        hmtxShMemSem   = 0;
+static HMTX        hmtxServices   = 0;
+
+static long        lMagic         = 0;
+static long        lAccess        = 0;
+static long        lTerminate     = 0;
+static long        lStartProcess  = 0;
+static long        lServicesUp    = 0;
+static TIB        *pStartTib;
+static PIB        *pStartPib;
+
+static int         iSystemReboot  = 1;
+static bool        fMInUse        = false;
+
+static M_PROCESS   mProcesses [M_MAX_DEVICES];
+static long        lMProcess  [M_MAX_DEVICES];
+
+//---------------------------------------------------------------------------
+//
+//  function:   long currentProcessId()
+//
+//  purpose:    returns process id for caller
+//
+//  date:       05-Jan-1999, 12:14:36
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long currentProcessId()
+{
+TIB *pTib;
+PIB *pPib;
+
+  OS_GetInfoBlocks(&pTib,&pPib);
+
+  return(pPib->pib_ulpid);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   static bool startupCalled(long ulProcess)
+//
+//  purpose:    returns true if WSACleanup was called.
+//
+//  date:       05-Jan-1999, 12:15:25
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+static bool startupCalled(long ulProcess)
+{
+bool fRet   = false;
+bool fFound = false;
+int  i;
+
+    for(i = 0; i < M_MAX_DEVICES && !fFound; i++)
+    {
+      if(ulProcess == mProcesses[i].ulProcessID)
+      {
+        fRet = mProcesses[i].fStartupCalled;
+        fFound = true;
+      }
+    }
+
+    return(fRet);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   static bool cleanupCalled(long ulProcess)
+//
+//  purpose:    returns true if WSACleanup was called.
+//
+//  date:       05-Jan-1999, 12:15:25
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+static bool cleanupCalled(long ulProcess)
+{
+bool fRet   = false;
+bool fFound = false;
+int  i;
+
+    for(i = 0; i < M_MAX_DEVICES && !fFound; i++)
+    {
+      if(ulProcess == mProcesses[i].ulProcessID)
+      {
+        fRet = mProcesses[i].fCleanupCalled;
+        fFound = true;
+      }
+    }
+
+    return(fRet);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   static void setStartupCalled(long ulProcess)
+//
+//  purpose:    sets marker for WSACleanup()
+//
+//  date:       05-Jan-1999, 12:14:56
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+static void setStartupCalled(long ulProcess)
+{
+bool fFound = false;
+int  i;
+
+    for(i = 0; i < M_MAX_DEVICES && !fFound; i++)
+    {
+      if(ulProcess == mProcesses[i].ulProcessID)
+      {
+        mProcesses[i].fStartupCalled = fFound = true;
+      }
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   static void setCleanupCalled(long ulProcess)
+//
+//  purpose:    sets marker for WSACleanup()
+//
+//  date:       05-Jan-1999, 12:14:56
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+static void setCleanupCalled(long ulProcess)
+{
+bool fFound = false;
+int  i;
+
+    for(i = 0; i < M_MAX_DEVICES && !fFound; i++)
+    {
+      if(ulProcess == mProcesses[i].ulProcessID)
+      {
+        mProcesses[i].fCleanupCalled = fFound = true;
+      }
+    }
+}
+
+/****************************************************************************
+
+ FUNCTION:  bool isMProcess(long ulProcess)
+
+ COMMENTS:  Check if process is attached to MUTILS.
+
+ DATE:      24-Jul-1998, 09:40:52
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+bool isMProcess(long ulProcess)
+{
+bool fFound = false;
+int  i;
+
+    for(i = 0; i < M_MAX_DEVICES && !fFound; i++)
+      fFound = (ulProcess == lMProcess[i]);
+
+    return(fFound);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   static void stopProcesses()
+//
+//  purpose:    stop processes according to given flags.
+//
+//  date:       05-Nov-1998, 13:38:14
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+static void stopProcesses()
+{
+int   i;
+long  rc;
+
+    if(rc = GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT,0))
+    {
+      for(i = M_MAX_DEVICES -1; i >= 0 ; i--)
+      {
+        if(mProcesses[i].ulSessionID)
+          OS_Sleep(1000);
+      }
+
+      debugWrite(HERE,"CTRL-BREAK, rc = %d",rc);
+    }
+
+    for(i = M_MAX_DEVICES -1; i >= 0 ; i--)
+    {
+      /* check which session to stop */
+
+      if(mProcesses[i].ulSessionID)
+      {
+        rc = OS_StopSession(STOP_SESSION_SPECIFIED, mProcesses[i].hProcess);
+
+        debugWrite(HERE,"OS_StopSession, Index = %ld, rc = %ld",i,rc);
+      }
+    }
+}
+
+/****************************************************************************
+
+ FUNCTION:  void addLog(byte  bLevel,
+                               char *pszFile,
+                               short sLine,
+                               char *pszFunction,
+                               char *pszFormat,...)
+
+ COMMENTS:  Add trace to mutils.log when no Trace available.
+
+ DATE:      24-Jul-1998, 09:40:52
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+void addLog(byte bLevel,char *pszFile,short sLine,char *pszFunction,char *pszFormat,...)
+{
+char     szFile  [256];
+char     szFunc  [256];
+char     szBuffer[1024];
+char    *pStr;
+long     ulLen;
+FILE    *fp;
+DATETIME Date;
+va_list  arg_ptr;
+long     rc;
+
+    if(rc = QueryMUtilsPath(szFile))
+      return;
+
+    if((pStr = strrchr(szFile,'\\')) != NULL)
+       *pStr = '\0';
+
+    strcat(szFile,"\\TRC\\");
+    strcat(szFile,M_UTILSDEV_FILE);
+
+    if((fp = fopen(szFile,"wa+")) == NULL)
+    {
+      return;
+    }
+    else
+    {
+      OS_GetDateTime(&Date);
+
+      memset(szBuffer,0,sizeof(szBuffer));
+
+      ulLen = 0;
+
+      ulLen += sprintf(szBuffer + ulLen,"%02d%02d %02d%02d:%02d.%02d ",
+                                        Date.day,
+                                        Date.month,
+                                        Date.hours,
+                                        Date.minutes,
+                                        Date.seconds,
+                                        Date.hundredths);
+
+      strcpy(szFunc,pszFunction);
+      strcpy(szFile,pszFile);
+
+      // discard function arguments
+
+      if((pStr = strrchr(szFunc,'(')) != NULL)
+      {
+        *(pStr +1) = ')';
+        *(pStr +2) = '\0';
+      }
+
+      // cut path from file name
+
+      if((pStr = strrchr(szFile,'\\')) != NULL)
+        strcpy(szFile,pStr +1);
+
+      // cut file name extension
+
+      if((pStr = strrchr(szFile,'.')) != NULL)
+        *pStr = '\0';
+
+      /* get pointer to first argument */
+
+      ulLen += sprintf(szBuffer + ulLen,"%-16s(%4d): ",szFile,sLine);
+
+      va_start(arg_ptr,pszFormat);
+
+      /* print into buffer */
+
+      ulLen += vsprintf(szBuffer + ulLen,pszFormat,arg_ptr);
+
+      va_end(arg_ptr);
+
+      ulLen += sprintf(szBuffer + ulLen,"\n");
+
+      // write everything and close
+
+      fwrite(szBuffer,ulLen,sizeof(char),fp);
+      fclose(fp);
+    }
+
+    return;
+}
+
+/****************************************************************************
+
+ FUNCTION:  static void initDataSeg()
+
+ COMMENTS:  Initialize data seg vars.
+
+ DATE:      08-Jun-1998, 15:02:13
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+static void initDataSeg()
+{
+int i;
+
+    for(i = 0; i < M_MAX_DEVICES; i++)
+    {
+      mProcesses[i].ulSessionID    = 0L;
+      mProcesses[i].ulProcessID    = 0L;
+      mProcesses[i].fKeepAlive     = 0L;
+      mProcesses[i].fCleanupCalled = 0L;
+      mProcesses[i].fStartupCalled = 0L;
+
+      lMProcess[i] = 0L;
+    }
+
+    hmtxSocketSem   = 0;
+    hmtxTraceSem    = 0;
+    hmtxShMemSem    = 0;
+    hmtxServices    = 0;
+    lAccess         = 0;
+    lTerminate      = 0;
+    lStartProcess   = 0;
+    lServicesUp     = 0;
+    iSystemReboot   = 1;
+    fMInUse         = false;
+
+    lMagic         = MAGIC_ID;
+
+    return;
+}
+
+/****************************************************************************
+
+ FUNCTION:  int mTerminate()
+
+ COMMENTS:  Return value of termination flag.
+
+ DATE:      03/04/97 - 10:08:15
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+int mTerminate()
+{
+    return(lTerminate == MAGIC_ID);
+}
+
+/****************************************************************************
+
+ FUNCTION:  int mInUse()
+
+ COMMENTS:  Return value of usage flag.
+
+ DATE:      03/04/97 - 10:08:15
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+int mInUse()
+{
+    return(fMInUse);
+}
+
+/****************************************************************************
+
+ FUNCTION:  void setMInUse(bool fSet)
+
+ COMMENTS:  Set/reset usage flag.
+
+ DATE:      03/04/97 - 10:08:15
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+void setMInUse(bool fSet)
+{
+    fMInUse = fSet;
+    return;
+}
+
+/****************************************************************************
+
+ FUNCTION:  static long mRebootNT()
+
+ COMMENTS:  System shutdown & reboot (WINNT)
+
+ DATE:      10-29-97, 9:13 AM
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+static long mRebootNT()
+{
+char             szTmp[256];
+mConfig          exec("MUTILS","REBOOT","ExecuteBefore");
+char             szMachineName[MAX_COMPUTERNAME_LENGTH+1];
+DWORD            dwLen = MAX_COMPUTERNAME_LENGTH+1;
+HANDLE           hProcess;
+HANDLE           hToken;
+TOKEN_PRIVILEGES Privileges;
+LUID             BootLUID;
+
+    mStopProgs();
+    OS_Sleep(20000);
+
+    if(!exec.error())
+    {
+      exec.asString(szTmp,sizeof(szTmp));
+
+      if(access(szTmp,0) == 0)
+      {
+        debugWrite(HERE,"post exec: %s",szTmp);
+
+        if(!system(szTmp))
+          OS_Sleep(20000);
+      }
+      else
+        debugWrite(HERE,"post exec [%s] not found.",szTmp);
+    }
+
+    debugWrite(HERE,"shutdown(0)");
+
+    // reboot now!
+
+    if(!GetComputerName(szMachineName,&dwLen))
+      return(-1);
+
+    hProcess = GetCurrentProcess();
+
+    if(!OpenProcessToken(hProcess,TOKEN_WRITE,&hToken))
+      return(-1);
+
+    if(!LookupPrivilegeValue((LPCTSTR)NULL,SE_SHUTDOWN_NAME,&BootLUID))
+      return(-1);
+
+    Privileges.PrivilegeCount = 1;
+    Privileges.Privileges[0].Luid = BootLUID;
+    Privileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
+
+    if(!AdjustTokenPrivileges(hToken,false,&Privileges,0,NULL,NULL))
+      return(-1);
+
+    if(!InitiateSystemShutdown(szMachineName,NULL,0,true,true))
+      return(-1);
+
+    return(0);
+}
+
+/****************************************************************************
+
+ FUNCTION:  LONG mRebootRemote()
+
+ COMMENTS:  System shutdown & reboot.
+
+ DATE:      10/18/96 - 14:52:08
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+LONG mRebootRemote(byte   bLevel,
+                            char  *pszFile,
+                            short  sLine,
+                            char  *pszFunction,
+                            bool   fCheckOnly)
+{
+
+mConfig exec("MUTILS","REBOOT","ExecuteBefore");
+
+    if(mInUse())
+    {
+      debugWrite(HERE,"remote reboot rejected.\ncall: %s, %d",pszFile,sLine);
+      return(-1);
+    }
+
+    if(!fCheckOnly)
+    {
+
+      mRebootNT();
+
+      debugWrite(HERE,"remote reboot.\ncall: %s, %d",pszFile,sLine);
+    }
+
+    return(0);
+}
+
+/****************************************************************************
+
+ FUNCTION:  void mForcedReboot()
+
+ COMMENTS:  System forced shutdown & reboot. (NT only)
+
+ DATE:      16-Jul-1998, 14:13:33
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+void mForcedReboot(byte   bLevel,
+                   char  *pszFile,
+                   short  sLine,
+                   char  *pszFunction)
+{
+char             szMachineName[MAX_COMPUTERNAME_LENGTH+1];
+HANDLE           hToken;
+HANDLE           hProcess;
+LUID             DebugValue;
+LUID             BootLUID;
+TOKEN_PRIVILEGES tkp;
+APIRET           rc;
+LONG             i;
+TIB             *pTib;
+PIB             *pPib;
+DWORD            dwLen = sizeof(szMachineName);
+
+    // Retrieve a handle of the access token
+
+    if(!OpenProcessToken(GetCurrentProcess(),
+                         TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
+                         &hToken))
+    {
+      debugWrite(HERE,"OpenProcessToken failed with %d\n", GetLastError());
+      return;
+    }
+
+    // Enable the SE_DEBUG_NAME privilege
+
+    if(!LookupPrivilegeValue((LPSTR) NULL,SE_DEBUG_NAME,&DebugValue))
+    {
+      debugWrite(HERE,"LookupPrivilegeValue failed with %d\n", GetLastError());
+      return;
+    }
+
+    tkp.PrivilegeCount           = 1;
+    tkp.Privileges[0].Luid       = DebugValue;
+    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
+
+    AdjustTokenPrivileges(hToken,
+                          false,
+                          &tkp,
+                          sizeof(TOKEN_PRIVILEGES),
+                          (PTOKEN_PRIVILEGES) NULL,
+                          (PDWORD) NULL);
+
+    // The return value of AdjustTokenPrivileges can't be tested
+
+    if(GetLastError() != ERROR_SUCCESS)
+    {
+      debugWrite(HERE,"AdjustTokenPrivileges failed with %d\n", GetLastError());
+      return;
+    }
+
+    rc = OS_GetInfoBlocks(&pTib,&pPib);
+
+    if(rc = GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT,0))
+      debugWrite(HERE,"CTRL-BREAK, rc = %ld",rc);
+
+    for(i = M_MAX_DEVICES -1; i >= 0 ; i--)
+    {
+      /* check which session to stop */
+
+      if(mProcesses[i].ulSessionID &&
+         mProcesses[i].ulProcessID != currentProcessId())
+      {
+        /* check which session to stop */
+
+        if(mProcesses[i].ulSessionID)
+        {
+          rc = OS_StopSession(STOP_SESSION_SPECIFIED, mProcesses[i].hProcess);
+
+          debugWrite(HERE,"OS_StopSession, Index = %ld, rc = %ld",i,rc);
+        }
+      }
+      else if(mProcesses[i].ulSessionID)
+        debugWrite(HERE,"no suicide for [%d]",i);
+    }
+
+    // reboot now!
+
+    if(!GetComputerName(szMachineName,&dwLen))
+      return;
+
+    hProcess = GetCurrentProcess();
+
+    if(!OpenProcessToken(hProcess,TOKEN_WRITE,&hToken))
+      return;
+
+    if(!LookupPrivilegeValue((LPCTSTR)NULL,SE_SHUTDOWN_NAME,&BootLUID))
+      return;
+
+    tkp.PrivilegeCount           = 1;
+    tkp.Privileges[0].Luid       = BootLUID;
+    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
+
+    if(!AdjustTokenPrivileges(hToken,false,&tkp,0,NULL,NULL))
+      return;
+
+    if(!InitiateSystemShutdown(szMachineName,NULL,0,true,true))
+      return;
+
+    return;
+}
+
+/****************************************************************************
+
+ FUNCTION:  void mReboot()
+
+ COMMENTS:  System shutdown & reboot.
+
+ DATE:      10/18/96 - 14:52:08
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+void mReboot(byte bLevel, char *pszFile, short sLine)
+{
+    if(!iSystemReboot || mInUse())
+    {
+      debugWrite(HERE,"system reboot rejected.\ncall: %s, %d",pszFile,sLine);
+      return;
+    }
+
+    mRebootNT();
+
+    debugWrite(HERE,"system reboot.\ncall: %s, %d",pszFile,sLine);
+
+    return;
+}
+
+/****************************************************************************
+
+ FUNCTION:  HMTX socketSem()
+
+ COMMENTS:  Return semaphore handle.
+
+ DATE:      10/08/96 - 16:35:26
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+HMTX socketSem()
+{
+    return(hmtxSocketSem);
+}
+
+/****************************************************************************
+
+ FUNCTION:  HMTX traceSem()
+
+ COMMENTS:  Return semaphore handle.
+
+ DATE:      10/08/96 - 16:35:26
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+HMTX traceSem()
+{
+    return(hmtxTraceSem);
+}
+
+/****************************************************************************
+
+ FUNCTION:  HMTX sharedMemSem()
+
+ COMMENTS:  Return semaphore handle.
+
+ DATE:      10/08/96 - 16:35:26
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+HMTX sharedMemSem()
+{
+    return(hmtxShMemSem);
+}
+
+/****************************************************************************
+
+ FUNCTION:  static long createServices()
+
+ COMMENTS:  Create all basic services.
+
+ DATE:      10/10/97 - 10:13:23
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+static long createServices()
+{
+long rc;
+
+    OS_GetInfoBlocks(&pStartTib,&pStartPib);
+
+    if(rc = OS_CreateMutexSem("\\SEM32\\MSOCKS.SEM",
+                              &hmtxSocketSem,
+                              DC_SEM_SHARED,
+                              false))
+    {
+      return(rc);
+    }
+
+    if(rc = OS_CreateMutexSem("\\SEM32\\MTRACE.SEM",
+                              &hmtxTraceSem,
+                              DC_SEM_SHARED,
+                              false))
+    {
+      return(rc);
+    }
+
+    if(rc = OS_CreateMutexSem("\\SEM32\\SHMEMM.SEM",
+                              &hmtxShMemSem,
+                              DC_SEM_SHARED,
+                              false))
+    {
+      return(rc);
+    }
+
+    if(rc = (long) mBasicServicesInit())
+      return(rc);
+    else
+    {
+      // set trace level according to value from M.CFG
+
+      mConfig level("MUTILS","TRACE","TraceLevel");
+    }
+
+    lServicesUp = 1;
+
+    return(0);
+}
+
+/****************************************************************************
+
+ FUNCTION:  static void deleteServices()
+
+ COMMENTS:  Delete all basic services.
+
+ DATE:      10/10/97 - 10:13:23
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+static void deleteServices()
+{
+    // delete all internal allocated resources
+
+    FreeConfiguration();
+
+    // TerminateTrace();
+
+    OS_CloseMutexSem(hmtxSocketSem);
+    OS_CloseMutexSem(hmtxTraceSem);
+    OS_CloseMutexSem(hmtxShMemSem);
+
+    lServicesUp = 0;
+
+    return;
+}
+/****************************************************************************
+
+ FUNCTION:  static void APIRET mBasicServicesTerm(void)
+
+ COMMENTS:  Do cleanup at DLL termination.
+
+ DATE:      11/23/95 - 15:24:13
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+static void APIENTRY mBasicServicesTerm(long ulReason)
+{
+APIRET rc;
+char   szTmp[100];
+char   szCmd[512];
+char  *pStr;
+TIB   *pTib;
+PIB   *pPib;
+
+    *szTmp = '\0';
+
+    rc = OS_GetInfoBlocks(&pTib,&pPib);
+
+    switch(ulReason)
+    {
+    default:
+
+         sprintf(szTmp,"UNKNOWN [%d]",ulReason);
+         break;
+
+    case TC_HARDERROR:
+
+         strcpy(szTmp,"TC_HARDERROR");
+         break;
+
+    case TC_TRAP:
+
+         strcpy(szTmp,"TC_TRAP");
+         break;
+
+    case TC_EXIT:
+
+         strcpy(szTmp,"TC_EXIT");
+         break;
+
+    case TC_KILLPROCESS:
+
+         strcpy(szTmp,"TC_KILLPROCESS");
+         break;
+
+    case TC_EXCEPTION:
+
+         strcpy(szTmp,"TC_EXCEPTION");
+         break;
+    }
+
+    if((pStr = strrchr(pPib->pib_pchcmd,'\\')) != NULL)
+      strcpy(szCmd,pStr +1);
+    else
+      strcpy(szCmd,pPib->pib_pchcmd);
+
+    debugWrite(HERE,"%s [%d,%d] [%d] %s",
+                     szTmp,
+                     currentProcessId(),
+                     pTib->tib_ptib2->tib2_ultid,
+                     pPib->pib_ulppid,
+                     szCmd);
+
+    if(ulReason == TC_EXCEPTION)
+      mReboot(HERE);
+
+    OS_ExitList(EXLST_EXIT,(PFNEXITLIST) mBasicServicesTerm);
+    return;
+}
+
+/****************************************************************************
+
+ FUNCTION:  static APIRET mBasicServicesInit(void)
+
+ COMMENTS:  Read configuration file and do initialisations at DLL startup.
+
+ DATE:      11/23/95 - 15:24:13
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+static APIRET mBasicServicesInit(void)
+{
+APIRET rc = 0;
+
+    if(rc = mUtilsReadConfig())
+      return(rc);
+
+    mConfig rmtDev ("MUTILS","RMTTRACE","ServerName");
+    mConfig trcDev ("MUTILS","RMTTRACE","DeviceName");
+    mConfig reboot ("MUTILS","REBOOT",  "RebootOnCrash");
+
+    if(!reboot.error())
+      iSystemReboot = reboot.asBool();
+
+    InitTrace();
+
+    return(0L);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void scanArguments(char  *pszInput,
+//                                 long  *pulTimeOut,
+//                                 bool  *pfKeepAlive,
+//                                 bool  *pfShow,
+//                                 char  *pszArgs)
+//
+//  purpose:    scan for program arguments and start options
+//
+//  date:       08.08.2001, 08:56
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void scanArguments(char  *pszInput,
+                   long  *pulTimeOut,
+                   bool  *pfKeepAlive,
+                   int   *piShow,
+                   char  *pszArgs)
+{
+char *pStr;
+
+    if((pStr = strrchr(pszInput,';')) != NULL)
+    {
+      *pStr = '\0';
+
+      strupr(++pStr);
+
+      // check for "show = XXXX" statement
+
+      if(strstr(pStr,"SHOW"))
+      {
+        if((pStr = strchr(pStr,'=')) != NULL)
+        {
+          pStr++;
+
+          if(strstr(pStr,"YES"))
+          {
+            *piShow = PROCESS_SHOW;
+          }
+          else if(strstr(pStr,"NO"))
+          {
+            *piShow = PROCESS_HIDE;
+          }
+          else if(strstr(pStr,"HIDE"))
+          {
+            *piShow = PROCESS_HIDE;
+          }
+          else if(strstr(pStr,"MINIMIZED"))
+          {
+            *piShow = PROCESS_MINIMIZED;
+          }
+        }
+        else
+         *piShow = PROCESS_SHOW;
+      }
+
+      // check for "wait = XXXX" statement
+
+      if(strstr(pStr,"WAIT"))
+      {
+        if((pStr = strchr(pStr,'=')) != NULL)
+        {
+          strlwr(++pStr);
+
+          if(strstr(pStr,"terminate"))
+          {
+            *pulTimeOut = -1;
+          }
+          else
+          {
+            // discard leading blanks
+
+            while(*pStr && *pStr <= '0')
+              pStr++;
+
+            if(*pStr)
+            {
+              *pulTimeOut = atol(pStr);
+
+              if(*pulTimeOut < 0)
+                *pulTimeOut *= -1;
+            }
+            else
+              *pulTimeOut = 0;
+          }
+        }
+      }
+    }
+
+    // scan for program arguments
+
+    debugWrite(HERE,"pszInput = %s",pszInput);
+
+    if((pStr = strchr(pszInput,'"')) != NULL)
+    {
+      pStr++;
+
+      while(*pStr && *pStr != '"')
+      {
+        *pszArgs++ = *pStr++;
+      }
+
+      *pszArgs = '\0';
+
+      debugWrite(HERE,"pszArgs = %s",pszArgs);
+
+    }
+    else
+    {
+      if((pStr = strrchr(pszInput,'\\')) != NULL)
+      {
+        while(*pStr && *pStr != ' ')
+          pStr++;
+
+        // cut off arguments from program name
+
+        //@@MaK 7-25-97, 4:20 PM
+
+        if(*pStr)
+        {
+          *pStr = '\0';
+
+          pStr++;
+
+          if(*pStr)
+          {
+            // save program arguments
+
+            strcpy(pszArgs,pStr);
+
+            pStr = pszArgs + strlen(pszArgs) -1;
+
+            while(*pStr <= ' ')
+            {
+              *pStr = '\0';
+              pStr--;
+            }
+          }
+        }
+      }
+    }
+}
+
+/****************************************************************************
+
+ FUNCTION:  APIRET mStartProgs(void);
+
+ COMMENTS:  Starts programs specified in M.CFG
+
+ DATE:      12/06/95 - 10:51:21
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+APIRET mStartProgs(void)
+{
+STARTDATA StartData;
+char      szProgName[1024];
+char      szProgArgs[256];
+char      szTmp     [256];
+long      i;
+long      ulSessionID;
+long      ulTimeOut;
+bool      fKeepAlive;
+int       iShow;
+PID       ProcID;
+HANDLE    ProcHandle;
+APIRET    rc;
+TIB      *pTib;
+PIB      *pPib;
+
+mConfig Config;
+
+    rc = OS_GetInfoBlocks(&pTib,&pPib);
+
+    lStartProcess = currentProcessId();
+
+    StartData.Length      = 32;
+    StartData.Related     = SSF_RELATED_CHILD;
+    StartData.FgBg        = SSF_FGBG_BACK;
+    StartData.TraceOpt    = SSF_TRACEOPT_NONE;
+    StartData.PgmTitle    = NULL;
+    StartData.TermQ       = NULL;
+    StartData.Environment = NULL;
+    StartData.InheritOpt  = SSF_INHERTOPT_PARENT;
+    StartData.SessionType = SSF_TYPE_PM;
+
+    debugWrite(HERE_9,"********** MUTILS Session start **********");
+
+    for(i = 0; i < M_MAX_DEVICES; i++)
+    {
+       ulTimeOut  = 0L;
+      *szProgArgs = '\0';
+
+      /* build search item */
+
+      sprintf(szTmp,M_STARTDEVICE_ID,i);
+
+      /* search configuration */
+
+      if(!Config.readValue(M_STARTDEVICES,szTmp))
+      {
+        //@@MaK7-25-97, 4:11 PM
+
+        memset(szProgName,0,sizeof(szProgName));
+
+        Config.asString(szProgName,sizeof(szProgName));
+
+        scanArguments(szProgName,&ulTimeOut,&fKeepAlive,&iShow,szProgArgs);
+
+        StartData.PgmName   = szProgName;
+        StartData.PgmInputs = (byte*)szProgArgs;
+
+        if(ulTimeOut < 0)
+        {
+          // start and wait for this process
+
+          if(rc = OS_ExecWait(&StartData,iShow))
+          {
+            debugWrite(HERE,"Can't execute: %s, rc = %ld\n",szProgName,rc);
+          }
+        }
+        else
+        {
+          if(rc = OS_StartSession(&StartData,(unsigned long *)&ulSessionID,&ProcID,&ProcHandle,iShow))
+          {
+            debugWrite(HERE,"Can't start: %s, rc = %ld\n",szProgName,rc);
+
+            /* reset session identifier */
+
+            mProcesses[i].ulSessionID = 0;
+          }
+          else
+          {
+            /* store session identifier */
+
+            debugWrite(HERE,"Device started: %s, Index = %ld, SID = %ld, PID = %ld",
+                                   szProgName,i,ulSessionID,ProcID);
+
+            mProcesses[i].ulSessionID = ulSessionID;
+            mProcesses[i].ulProcessID = ProcID;
+            mProcesses[i].hProcess    = ProcHandle;
+            mProcesses[i].fKeepAlive  = fKeepAlive;
+
+            if(ulTimeOut)
+            {
+              debugWrite(HERE,"waiting: %d ms",ulTimeOut);
+
+              OS_Sleep(ulTimeOut);
+            }
+          }
+        }
+      }
+    }
+
+    return(0L);
+}
+
+/****************************************************************************
+
+ FUNCTION:  APIRET mStopProgs(void);
+
+ COMMENTS:  Stops all started programs.
+
+ DATE:      12/06/95 - 10:51:21
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+APIRET mStopProgs(void)
+{
+APIRET  rc;
+TIB    *pTib;
+PIB    *pPib;
+char    szPath[512];
+
+    GetModuleFileName(NULL,szPath,sizeof(szPath));
+
+    debugWrite(HERE,"StopProgs: pid = %d",currentProcessId());
+    debugWrite(HERE,"StopProgs: %s",szPath);
+
+    rc = OS_GetInfoBlocks(&pTib,&pPib);
+
+    // give all attached services a chance to clear resources
+
+    if(currentProcessId() != lStartProcess)
+    {
+       lTerminate = MAGIC_ID;
+
+       while(lServicesUp)
+       {
+         // wait if it's not possible at the moment !!
+
+         OS_Sleep(2000);
+       }
+
+       // reset for next start of application
+
+       lTerminate = 0;
+
+       initDataSeg();
+
+       // restart all MUTILS services
+
+       createServices();
+
+       // this the new start process now !!
+
+       lStartProcess = currentProcessId();
+
+       setMInUse(false);
+
+       return(0L);
+    }
+    else
+      stopProcesses();
+
+    return(0L);
+}
+
+
+// class definition ---------------------------------------------------------
+
+static int initDone= 0;
+
+    MassaiLibraryInitTerm::MassaiLibraryInitTerm()
+    {
+#if defined (SSD_CODELIB)
+      if(initDone == 0)
+      {
+        long rc;
+
+          if(sock_init() > 0)
+            setStartupCalled(currentProcessId());
+
+          rc = createServices();
+      }
+      if(initDone >= 0)
+        initDone++;
+#endif
+    }
+
+    MassaiLibraryInitTerm::~MassaiLibraryInitTerm()
+    {
+#if defined (SSD_CODELIB)
+        if(initDone != 0)
+          initDone--;
+        if(initDone == 0)
+        {
+          deleteServices();
+
+          if(!cleanupCalled(currentProcessId()) &&
+              startupCalled(currentProcessId())    )
+          {
+            debugWrite(HERE_9,"calling WSACleanup(%d)",currentProcessId());
+
+            switch(WSACleanup())
+            {
+            case WSAEINPROGRESS:
+
+                 while(WSACancelBlockingCall() != WSAEINVAL)
+                   debugWrite(HERE,"WSACleanUp repeated, pid = %d",currentProcessId());
+
+                 WSACleanup();
+                 break;
+
+            default:
+                 break;
+            }
+
+            setCleanupCalled(currentProcessId());
+          }
+          else
+            debugWrite(HERE,"discarded WSACleanup(%d), startupCalled() = %d",
+                         currentProcessId(),
+                         startupCalled(currentProcessId()));
+         }
+#endif
+    }
+    void MassaiLibraryInitTerm::ref()
+    {}
+
+#if defined (SSD_CODELIB)
+#else
+
+/****************************************************************************
+
+ FUNCTION:  unsigned long __stdcall _DLL_InitTerm(unsigned long  hModule,
+                                                  unsigned long  ulFlag,
+                                                  long          *dummy)
+
+ COMMENTS:  First function called when DLL is loaded.
+
+ DATE:      11/30/95 - 10:24:26
+
+ AUTHOR:    Dr. Materna GmbH   (MaK/AGe)
+
+****************************************************************************/
+
+bool MASSAI_DLLEXPORT WINAPI DllMain(HINSTANCE hModule,DWORD ulFlag, void *lpvReserved)
+{
+long   rc = 0;
+char    szPath[512];
+WORD    wVersionRequested = MAKEWORD(1,1);
+
+   switch(ulFlag)
+   {
+   case DLL_PROCESS_ATTACH:
+        {
+          sock_init();
+
+          mBasicServicesInit();
+
+          GetModuleFileName(NULL,szPath,sizeof(szPath));
+
+          debugWrite(HERE,"attach: lAccess = %d, pid = %d, %s",lAccess,currentProcessId(),szPath);
+
+        }
+        break;
+
+   case DLL_PROCESS_DETACH :
+        {
+          GetModuleFileName(NULL,szPath,sizeof(szPath));
+
+          debugWrite(HERE,"detach: lAccess = %d, pid = %d, %s",lAccess,currentProcessId(),szPath);
+
+          switch(WSACleanup())
+          {
+          case WSAEINPROGRESS:
+
+               while(WSACancelBlockingCall() != WSAEINVAL)
+                 debugWrite(HERE,"WSACleanUp repeated, pid = %d",currentProcessId());
+
+               WSACleanup();
+               break;
+
+          default:
+               break;
+          }
+
+        }
+        break;
+
+   case DLL_THREAD_ATTACH :
+
+        return 1;
+        break;
+
+   case DLL_THREAD_DETACH :
+
+        return 1;
+        break;
+
+   default:
+
+        return 0;
+        break;
+   }
+
+   /* A non-zero value must be returned to indicate success.                */
+
+   return 1;
+}
+
+#endif // M_CODELIB
diff --git a/Massai/cpp/MassaiDLL/dll/src/mbasicrefs.cpp b/Massai/cpp/MassaiDLL/dll/src/mbasicrefs.cpp
new file mode 100644
index 00000000..9ea6ae35
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/dll/src/mbasicrefs.cpp
@@ -0,0 +1,78 @@
+//---------------------------------------------------------------------------
+//
+//  file:       mbsaicRefss.cpp
+//
+//  purpose:    class implementation
+//
+//  date:       05.09.00, 14:14
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include <string.h>
+
+#include "massai.hpp"
+
+#define APPREF     "-r:"
+#define DISPIOR    "-d:"
+#define APPMGRIOR  "-a:"
+
+//---------------------------------------------------------------------------
+//
+//  function:   mBasicRefs::mBasicRefs(INT argc, CHAR **argv)
+//
+//  purpose:    class contructor
+//
+//  date:       05.09.00, 14:20
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+mBasicRefs::mBasicRefs(INT argc, CHAR **argv)
+{
+CHAR *pStr;
+BOOL  fDone;
+INT   i;
+
+    *szAppRef  = '\0';
+    *szAppMgr  = '\0';
+    *szDisplay = '\0';
+
+    if(argc > 1)
+    {
+      for(i = 1, fDone = FALSE; i < argc && ! fDone; i++)
+        if((pStr = strstr(argv[i],APPREF)) != NULL)
+        {
+          pStr += strlen(APPREF);
+
+          while(*pStr && *pStr == ' ')
+            pStr++;
+
+          strcpy(szAppRef,pStr);
+        }
+
+      for(i = 1, fDone = FALSE; i < argc && ! fDone; i++)
+        if((pStr = strstr(argv[i],DISPIOR)) != NULL)
+        {
+          pStr += strlen(DISPIOR);
+
+          while(*pStr && *pStr == ' ')
+            pStr++;
+
+          strcpy(szDisplay,pStr);
+        }
+
+      for(i = 1, fDone = FALSE; i < argc && ! fDone; i++)
+        if((pStr = strstr(argv[i],APPMGRIOR)) != NULL)
+        {
+          pStr += strlen(APPMGRIOR);
+
+          while(*pStr && *pStr == ' ')
+            pStr++;
+
+          strcpy(szAppMgr,pStr);
+        }
+    }
+}
\ No newline at end of file
diff --git a/Massai/cpp/MassaiDLL/dll/src/mhandler.cpp b/Massai/cpp/MassaiDLL/dll/src/mhandler.cpp
new file mode 100644
index 00000000..ebedf120
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/dll/src/mhandler.cpp
@@ -0,0 +1,329 @@
+//---------------------------------------------------------------------------
+//
+//  file:       mhandler.cpp
+//
+//  purpose:    provide window handling
+//
+//  date:       13.10.99, 16:09
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include "mhandler.hpp"
+
+mThread *mHandler::pPoster    = NULL;
+ULONG      mHandler::ulCnt      = 0;
+ULONG      mHandler::ulLanguage = 0;
+
+typedef struct _meventlist
+        {
+          struct _meventlist *pNext;
+          mEvent             *pEvent;
+        }
+        MEVENT_LIST;
+
+static MEVENT_LIST *pEvents       = NULL;
+static MEVENT_LIST *pEventsLast   = NULL;
+
+static HMTX         hmtxPoster    = 0;
+static HEV          hevEvent      = 0;
+
+//---------------------------------------------------------------------------
+//
+//  function:   ULONG ticker(ULONG pHandler)
+//
+//  purpose:    hread function for timer
+//
+//  date:       13.10.99, 16:29
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+ULONG ticker(ULONG pHandler)
+{
+mHandler *p = (mHandler *)pHandler;
+mEvent    e(mEvent::ME_TIMER,0,0);
+
+  OS_Sleep(p->millis());
+
+  if(!p->timerStopped())
+    p->timerHandler(e);
+
+  return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   VOID mHandler::startTimer(ULONG ulMillis)
+//
+//  purpose:    start a new timer
+//
+//  date:       13.10.99, 16:29
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+VOID mHandler::startTimer(ULONG ulMillis)
+{
+  if(pTimer)
+  {
+    fTimerStopped = TRUE;
+
+    stopTimer();
+  }
+
+  this->ulMillis = ulMillis;
+
+  fTimerStopped = FALSE;
+
+  pTimer = new mThread(ticker,(ULONG) this);
+
+  pTimer->run();
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   VOID mHandler::stopTimer()
+//
+//  purpose:    stop & delet current timer thread
+//
+//  date:       13.10.99, 16:29
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+VOID mHandler::stopTimer()
+{
+   if(pTimer)
+   {
+     fTimerStopped = TRUE;
+
+     pTimer->stop();
+
+     delete pTimer;
+     pTimer = NULL;
+   }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   ULONG poster(ULONG pHandler)
+//
+//  purpose:    thread function
+//
+//  date:       13.10.99, 16:28
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+PRIVATE ULONG poster(ULONG pHandler)
+{
+MEVENT_LIST *pl;
+mEvent      *p;
+ULONG        rc;
+ULONG        ulCntSem;
+
+  OS_WaitEventSem(hevEvent,-1);
+  OS_ResetEventSem(hevEvent,&ulCntSem);
+
+  rc = OS_RequestMutexSem(hmtxPoster,-1L);
+
+  if(pEvents)
+  {
+    pl = pEvents;
+
+    pEvents = pEvents->pNext;
+
+    p = pl->pEvent;
+
+    switch(p->id())
+    {
+    case mEvent::ME_SYSCOM:   p->receiver()->syscomHandler  (*p); break;
+    case mEvent::ME_SELECT:   p->receiver()->controlHandler (*p); break;
+    case mEvent::ME_TIMER:    p->receiver()->timerHandler   (*p); break;
+    case mEvent::ME_ACTIVATE: p->receiver()->activateHandler(*p); break;
+    case mEvent::ME_COMMAND:  p->receiver()->commandHandler (*p); break;
+    }
+
+    delete p;
+
+    free(pl);
+  }
+
+  rc = OS_ReleaseMutexSem(hmtxPoster);
+
+  return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   BOOL mHandler::postEvent(mEvent event)
+//
+//  purpose:    post event to handler
+//
+//  date:       13.10.99, 16:28
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+BOOL mHandler::postEvent(mEvent event)
+{
+  return(postEvent(this,event));
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   BOOL mHandler::postEvent(mHandler* pTo, mEvent event)
+//
+//  purpose:    post event to handler
+//
+//  date:       13.10.99, 16:28
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+BOOL mHandler::postEvent(mHandler* pTo, mEvent event)
+{
+ULONG        rc;
+MEVENT_LIST *pl;
+
+  pl = (MEVENT_LIST *) malloc(sizeof(MEVENT_LIST));
+
+  if(pl)
+  {
+    pl->pNext  = NULL;
+    pl->pEvent = new mEvent(pTo,(mEvent::ME_ID) event.id(),event.param1(),event.param2());
+
+    rc = OS_RequestMutexSem(hmtxPoster,-1L);
+
+    if(pEvents == NULL)
+      pEvents = pEventsLast = pl;
+    else
+      pEventsLast->pNext = pl;
+
+    rc = OS_ReleaseMutexSem(hmtxPoster);
+
+    OS_PostEventSem(hevEvent);
+
+    return(TRUE);
+  }
+  else
+    return(FALSE);
+
+}
+
+VOID mHandler::activate()
+{
+    mEvent e(mEvent::ME_ACTIVATE,TRUE,0);
+
+    activateHandler(e);
+    return;
+}
+
+VOID mHandler::deactivate()
+{
+    mEvent e(mEvent::ME_ACTIVATE,FALSE,0);
+
+    activateHandler(e);
+    return;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   mHandler::mHandler(mHandler* pOwner)
+//
+//  purpose:    class constructor
+//
+//  date:       13.10.99, 16:27
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+mHandler::mHandler(mHandler* pOwner)
+{
+ULONG rc;
+
+   ulId         = 0;
+   pTimer       = NULL;
+   ulId         = 0;
+   this->pOwner = pOwner;
+
+   if(!ulCnt && pPoster == NULL)
+   {
+     rc = OS_CreateMutexSem(NULL,&hmtxPoster,DC_SEM_SHARED,FALSE);
+     rc = OS_CreateEventSem(NULL,&hevEvent,DC_SEM_SHARED,FALSE);
+
+     pPoster = new mThread(poster);
+
+     pPoster->run();
+   }
+
+   ulCnt++;
+
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   mHandler::mHandler()
+//
+//  purpose:    class constructor
+//
+//  date:       13.10.99, 16:27
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+mHandler::mHandler()
+{
+ULONG rc;
+
+   ulId   = 0;
+   pTimer = NULL;
+   ulId   = 0;
+   pOwner = this;
+
+   if(!ulCnt && pPoster == NULL)
+   {
+     rc = OS_CreateMutexSem(NULL,&hmtxPoster,DC_SEM_SHARED,FALSE);
+     rc = OS_CreateEventSem(NULL,&hevEvent,DC_SEM_SHARED,FALSE);
+
+     pPoster = new mThread(poster);
+
+     pPoster->run();
+   }
+
+   ulCnt++;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   mHandler::mHandler()
+//
+//  purpose:    class destructor
+//
+//  date:       13.10.99, 16:28
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+mHandler::~mHandler()
+{
+   ulCnt--;
+
+   if(!ulCnt && pPoster != NULL)
+     delete pPoster;
+
+   OS_CloseMutexSem(hmtxPoster);
+
+}
+
diff --git a/Massai/cpp/MassaiDLL/dll/src/mvsprintf.cpp b/Massai/cpp/MassaiDLL/dll/src/mvsprintf.cpp
new file mode 100644
index 00000000..90d871a8
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/dll/src/mvsprintf.cpp
@@ -0,0 +1,679 @@
+/*
+ *  linux/lib/vsprintf.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+/* vsprintf.c -- Lars Wirzenius & Linus Torvalds. */
+/*
+ * Wirzenius wrote this portably, Torvalds fucked it up :-)
+ */
+
+/*
+ * Fri Jul 13 2001 Crutcher Dunnavant <crutcher+kernel@datastacks.com>
+ * - changed to provide snprintf and vsnprintf functions
+ */
+
+#include <limits.h>
+#include <stdarg.h>
+#include <string.h>
+#include <ctype.h>
+
+static int strnlen(const char * s, size_t count)
+{
+  const char *sc;
+
+  for (sc = s; count-- && *sc != '\0'; ++sc)
+    /* nothing */;
+  return sc - s;
+}
+
+/**
+ * simple_strtoul - convert a string to an unsigned long
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+unsigned long simple_strtoul(const char *cp,char **endp,unsigned int base)
+{
+        unsigned long result = 0,value;
+
+        if (!base) {
+                base = 10;
+                if (*cp == '0') {
+                        base = 8;
+                        cp++;
+                        if ((*cp == 'x') && isxdigit(cp[1])) {
+                                cp++;
+                                base = 16;
+                        }
+                }
+        }
+        while (isxdigit(*cp) &&
+               (value = isdigit(*cp) ? *cp-'0' : toupper(*cp)-'A'+10) < base) {
+                result = result*base + value;
+                cp++;
+        }
+        if (endp)
+                *endp = (char *)cp;
+        return result;
+}
+
+/**
+ * simple_strtol - convert a string to a signed long
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+long simple_strtol(const char *cp,char **endp,unsigned int base)
+{
+        if(*cp=='-')
+                return(-1 * simple_strtoul(cp+1,endp,base));
+        return simple_strtoul(cp,endp,base);
+}
+
+static int skip_atoi(const char **s)
+{
+        int i=0;
+
+        while (isdigit(**s))
+                i = i*10 + *((*s)++) - '0';
+        return i;
+}
+
+#define ZEROPAD 1               /* pad with zero */
+#define SIGN    2               /* unsigned/signed long */
+#define PLUS    4               /* show plus */
+#define SPACE   8               /* space if plus */
+#define LEFT    16              /* left justified */
+#define SPECIAL 32              /* 0x */
+#define LARGE   64              /* use 'ABCDEF' instead of 'abcdef' */
+
+static char * number(char * buf, char * end, long num, int base, int size, int precision, int type)
+{
+        char c,sign,tmp[66],*pbuf;
+        const char *digits;
+        static const char small_digits[] = "0123456789abcdefghijklmnopqrstuvwxyz";
+        static const char large_digits[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
+        int i;
+
+        pbuf = buf;
+
+        digits = (type & LARGE) ? large_digits : small_digits;
+        if (type & LEFT)
+                type &= ~ZEROPAD;
+        if (base < 2 || base > 36)
+                return 0;
+        c = (type & ZEROPAD) ? '0' : ' ';
+        sign = 0;
+        if (type & SIGN) {
+                if (num < 0) {
+                        sign = '-';
+                        num = -num;
+                        size--;
+                } else if (type & PLUS) {
+                        sign = '+';
+                        size--;
+                } else if (type & SPACE) {
+                        sign = ' ';
+                        size--;
+                }
+        }
+        if (type & SPECIAL) {
+                if (base == 16)
+                        size -= 2;
+                else if (base == 8)
+                        size--;
+        }
+        i = 0;
+        if (num == 0)
+                tmp[i++]='0';
+        else while (num != 0)
+        {
+                tmp[i++] = digits[num%base];
+                num /= base;
+        }
+        if (i > precision)
+                precision = i;
+        size -= precision;
+        if (!(type&(ZEROPAD+LEFT))) {
+                while(size-->0) {
+                        if (buf <= end)
+                                *buf = ' ';
+                        ++buf;
+                }
+        }
+        if (sign) {
+                if (buf <= end)
+                        *buf = sign;
+                ++buf;
+        }
+        if (type & SPECIAL) {
+                if (base==8) {
+                        if (buf <= end)
+                                *buf = '0';
+                        ++buf;
+                } else if (base==16) {
+                        if (buf <= end)
+                                *buf = '0';
+                        ++buf;
+                        if (buf <= end)
+                                *buf = digits[33];
+                        ++buf;
+                }
+        }
+        if (!(type & LEFT)) {
+                while (size-- > 0) {
+                        if (buf <= end)
+                                *buf = c;
+                        ++buf;
+                }
+        }
+        while (i < precision--) {
+                if (buf <= end)
+                        *buf = '0';
+                ++buf;
+        }
+        while (i-- > 0) {
+                if (buf <= end)
+                        *buf = tmp[i];
+                ++buf;
+        }
+        while (size-- > 0) {
+                if (buf <= end)
+                        *buf = ' ';
+                ++buf;
+        }
+        return buf;
+}
+
+/**
+* vsnprintf - Format a string and place it in a buffer
+* @buf: The buffer to place the result into
+* @size: The size of the buffer, including the trailing null space
+* @fmt: The format string to use
+* @args: Arguments for the format string
+*
+* Call this function if you are already dealing with a va_list.
+* You probably want snprintf instead.
+ */
+int m_vsnprintf(char *buf, size_t size, const char *fmt, va_list args)
+{
+        int len;
+        unsigned long num;
+        int i, base;
+        char *str, *end, c;
+        const char *s;
+
+        int flags;              /* flags to number() */
+
+        int field_width;        /* width of output field */
+        int precision;          /* min. # of digits for integers; max
+                                   number of chars for from string */
+        int qualifier;          /* 'h', 'l', or 'L' for integer fields */
+                                /* 'z' support added 23/7/1999 S.H.    */
+                                /* 'z' changed to 'Z' --davidm 1/25/99 */
+
+        str = buf;
+        end = buf + size - 1;
+
+        if (end < buf - 1) {
+                end = ((char *) -1);
+                size = end - buf + 1;
+        }
+
+        for (; *fmt ; ++fmt) {
+                if (*fmt != '%') {
+                        if (str <= end)
+                                *str = *fmt;
+                        ++str;
+                        continue;
+                }
+
+                /* process flags */
+                flags = 0;
+                repeat:
+                        ++fmt;          /* this also skips first '%' */
+                        switch (*fmt) {
+                                case '-': flags |= LEFT; goto repeat;
+                                case '+': flags |= PLUS; goto repeat;
+                                case ' ': flags |= SPACE; goto repeat;
+                                case '#': flags |= SPECIAL; goto repeat;
+                                case '0': flags |= ZEROPAD; goto repeat;
+                        }
+
+                /* get field width */
+                field_width = -1;
+                if (isdigit(*fmt))
+                        field_width = skip_atoi(&fmt);
+                else if (*fmt == '*') {
+                        ++fmt;
+                        /* it's the next argument */
+                        field_width = va_arg(args, int);
+                        if (field_width < 0) {
+                                field_width = -field_width;
+                                flags |= LEFT;
+                        }
+                }
+
+                /* get the precision */
+                precision = -1;
+                if (*fmt == '.') {
+                        ++fmt;
+                        if (isdigit(*fmt))
+                                precision = skip_atoi(&fmt);
+                        else if (*fmt == '*') {
+                                ++fmt;
+                                /* it's the next argument */
+                                precision = va_arg(args, int);
+                        }
+                        if (precision < 0)
+                                precision = 0;
+                }
+
+                /* get the conversion qualifier */
+                qualifier = -1;
+                if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' || *fmt =='Z') {
+                        qualifier = *fmt;
+                        ++fmt;
+                        if (qualifier == 'l' && *fmt == 'l') {
+                                qualifier = 'L';
+                                ++fmt;
+                        }
+                }
+
+                /* default base */
+                base = 10;
+
+                switch (*fmt) {
+                        case 'c':
+                                if (!(flags & LEFT)) {
+                                        while (--field_width > 0) {
+                                                if (str <= end)
+                                                        *str = ' ';
+                                                ++str;
+                                        }
+                                }
+                                c = (unsigned char) va_arg(args, int);
+                                if (str <= end)
+                                        *str = c;
+                                ++str;
+                                while (--field_width > 0) {
+                                        if (str <= end)
+                                                *str = ' ';
+                                        ++str;
+                                }
+                                continue;
+
+                        case 's':
+                                s = va_arg(args, char *);
+                                if (!s)
+                                        s = "<NULL>";
+
+                                len = strnlen(s, precision);
+
+                                if (!(flags & LEFT)) {
+                                        while (len < field_width--) {
+                                                if (str <= end)
+                                                        *str = ' ';
+                                                ++str;
+                                        }
+                                }
+                                for (i = 0; i < len; ++i) {
+                                        if (str <= end)
+                                                *str = *s;
+                                        ++str; ++s;
+                                }
+                                while (len < field_width--) {
+                                        if (str <= end)
+                                                *str = ' ';
+                                        ++str;
+                                }
+                                continue;
+
+                        case 'p':
+                                if (field_width == -1) {
+                                        field_width = 2*sizeof(void *);
+                                        flags |= ZEROPAD;
+                                }
+                                str = number(str, end,
+                                                (unsigned long) va_arg(args, void *),
+                                                16, field_width, precision, flags);
+                                continue;
+
+
+                        case 'n':
+                                /* FIXME:
+                                * What does C99 say about the overflow case here? */
+                                if (qualifier == 'l') {
+                                        long * ip = va_arg(args, long *);
+                                        *ip = (str - buf);
+                                } else if (qualifier == 'Z') {
+                                        size_t * ip = va_arg(args, size_t *);
+                                        *ip = (str - buf);
+                                } else {
+                                        int * ip = va_arg(args, int *);
+                                        *ip = (str - buf);
+                                }
+                                continue;
+
+                        case '%':
+                                if (str <= end)
+                                        *str = '%';
+                                ++str;
+                                continue;
+
+                                /* integer number formats - set up the flags and "break" */
+                        case 'o':
+                                base = 8;
+                                break;
+
+                        case 'X':
+                                flags |= LARGE;
+                        case 'x':
+                                base = 16;
+                                break;
+
+                        case 'd':
+                        case 'i':
+                                flags |= SIGN;
+                        case 'u':
+                                break;
+
+                        default:
+                                if (str <= end)
+                                        *str = '%';
+                                ++str;
+                                if (*fmt) {
+                                        if (str <= end)
+                                                *str = *fmt;
+                                        ++str;
+                                } else {
+                                        --fmt;
+                                }
+                                continue;
+                }
+                if (qualifier == 'L')
+                        num = va_arg(args, long);
+                else if (qualifier == 'l') {
+                        num = va_arg(args, unsigned long);
+                        if (flags & SIGN)
+                                num = (signed long) num;
+                } else if (qualifier == 'Z') {
+                        num = va_arg(args, size_t);
+                } else if (qualifier == 'h') {
+                        num = (unsigned short) va_arg(args, int);
+                        if (flags & SIGN)
+                                num = (signed short) num;
+                } else {
+                        num = va_arg(args, unsigned int);
+                        if (flags & SIGN)
+                                num = (signed int) num;
+                }
+                str = number(str, end, num, base,
+                                field_width, precision, flags);
+        }
+        if (str <= end)
+                *str = '\0';
+        else if (size > 0)
+                /* don't write out a null byte if the buf size is zero */
+                *end = '\0';
+        /* the trailing null byte doesn't count towards the total
+        * ++str;
+        */
+        return str-buf;
+}
+
+/**
+ * snprintf - Format a string and place it in a buffer
+ * @buf: The buffer to place the result into
+ * @size: The size of the buffer, including the trailing null space
+ * @fmt: The format string to use
+ * @...: Arguments for the format string
+ */
+int m_snprintf(char * buf, size_t size, const char *fmt, ...)
+{
+        va_list args;
+        int i;
+
+        va_start(args, fmt);
+        i=m_vsnprintf(buf,size,fmt,args);
+        va_end(args);
+        return i;
+}
+
+/**
+ * vsprintf - Format a string and place it in a buffer
+ * @buf: The buffer to place the result into
+ * @fmt: The format string to use
+ * @args: Arguments for the format string
+ *
+ * Call this function if you are already dealing with a va_list.
+ * You probably want sprintf instead.
+ */
+int m_vsprintf(char *buf, const char *fmt, va_list args)
+{
+        return m_vsnprintf(buf, 0xFFFFFFFFUL, fmt, args);
+}
+
+
+/**
+ * sprintf - Format a string and place it in a buffer
+ * @buf: The buffer to place the result into
+ * @fmt: The format string to use
+ * @...: Arguments for the format string
+ */
+int m_sprintf(char * buf, const char *fmt, ...)
+{
+        va_list args;
+        int i;
+
+        va_start(args, fmt);
+        i=m_vsprintf(buf,fmt,args);
+        va_end(args);
+        return i;
+}
+
+/**
+ * vsscanf - Unformat a buffer into a list of arguments
+ * @buf:        input buffer
+ * @fmt:        format of buffer
+ * @args:       arguments
+ */
+int m_vsscanf(const char * buf, const char * fmt, va_list args)
+{
+        const char *str = buf;
+        char *next;
+        char digit;
+        int num = 0;
+        int qualifier;
+        int base;
+        int field_width = -1;
+        int is_sign = 0;
+
+        while(*fmt && *str) {
+                /* skip any white space in format */
+                /* white space in format matchs any amount of
+                 * white space, including none, in the input.
+                 */
+                if (isspace(*fmt)) {
+                        while (isspace(*fmt))
+                                ++fmt;
+                        while (isspace(*str))
+                                ++str;
+                }
+
+                /* anything that is not a conversion must match exactly */
+                if (*fmt != '%' && *fmt) {
+                        if (*fmt++ != *str++)
+                                break;
+                        continue;
+                }
+
+                if (!*fmt)
+                        break;
+                ++fmt;
+
+                /* skip this conversion.
+                 * advance both strings to next white space
+                 */
+                if (*fmt == '*') {
+                        while (!isspace(*fmt) && *fmt)
+                                fmt++;
+                        while (!isspace(*str) && *str)
+                                str++;
+                        continue;
+                }
+
+                /* get field width */
+                if (isdigit(*fmt))
+                        field_width = skip_atoi(&fmt);
+
+                /* get conversion qualifier */
+                qualifier = -1;
+                if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' || *fmt == 'Z') {
+                        qualifier = *fmt;
+                        fmt++;
+                }
+                base = 10;
+                is_sign = 0;
+
+                if (!*fmt || !*str)
+                        break;
+
+                switch(*fmt++) {
+                case 'c':
+                {
+                        char *s = (char *) va_arg(args,char*);
+                        if (field_width == -1)
+                                field_width = 1;
+                        do {
+                                *s++ = *str++;
+                        } while(field_width-- > 0 && *str);
+                        num++;
+                }
+                continue;
+                case 's':
+                {
+                        char *s = (char *) va_arg(args, char *);
+                        if(field_width == -1)
+                                field_width = INT_MAX;
+                        /* first, skip leading white space in buffer */
+                        while (isspace(*str))
+                                str++;
+
+                        /* now copy until next white space */
+                        while (*str && !isspace(*str) && field_width--) {
+                                *s++ = *str++;
+                        }
+                        *s = '\0';
+                        num++;
+                }
+                continue;
+                case 'n':
+                        /* return number of characters read so far */
+                {
+                        int *i = (int *)va_arg(args,int*);
+                        *i = str - buf;
+                }
+                continue;
+                case 'o':
+                        base = 8;
+                        break;
+                case 'x':
+                case 'X':
+                        base = 16;
+                        break;
+                case 'i':
+                        base = 0;
+                case 'd':
+                        is_sign = 1;
+                case 'u':
+                        break;
+                case '%':
+                        /* looking for '%' in str */
+                        if (*str++ != '%')
+                                return num;
+                        continue;
+                default:
+                        /* invalid format; stop here */
+                        return num;
+                }
+
+                /* have some sort of integer conversion.
+                 * first, skip white space in buffer.
+                 */
+                while (isspace(*str))
+                        str++;
+
+                digit = *str;
+                if (is_sign && digit == '-')
+                        digit = *(str + 1);
+
+                if (!digit
+                    || (base == 16 && !isxdigit(digit))
+                    || (base == 10 && !isdigit(digit))
+                    || (base == 8 && (!isdigit(digit) || digit > '7'))
+                    || (base == 0 && !isdigit(digit)))
+                                break;
+
+                switch(qualifier) {
+                case 'h':
+                        if (is_sign) {
+                                short *s = (short *) va_arg(args,short *);
+                                *s = (short) simple_strtol(str,&next,base);
+                        } else {
+                                unsigned short *s = (unsigned short *) va_arg(args, unsigned short *);
+                                *s = (unsigned short) simple_strtoul(str, &next, base);
+                        }
+                        break;
+                case 'l':
+                        if (is_sign) {
+                                long *l = (long *) va_arg(args,long *);
+                                *l = simple_strtol(str,&next,base);
+                        } else {
+                                unsigned long *l = (unsigned long*) va_arg(args,unsigned long*);
+                                *l = simple_strtoul(str,&next,base);
+                        }
+                        break;
+                case 'Z':
+                {
+                        size_t *s = (size_t*) va_arg(args,size_t*);
+                        *s = (size_t) simple_strtoul(str,&next,base);
+                }
+                break;
+                default:
+                        if (is_sign) {
+                                int *i = (int *) va_arg(args, int*);
+                                *i = (int) simple_strtol(str,&next,base);
+                        } else {
+                                unsigned int *i = (unsigned int*) va_arg(args, unsigned int*);
+                                *i = (unsigned int) simple_strtoul(str,&next,base);
+                        }
+                        break;
+                }
+                num++;
+
+                if (!next)
+                        break;
+                str = next;
+        }
+        return num;
+}
+
+/**
+ * sscanf - Unformat a buffer into a list of arguments
+ * @buf:        input buffer
+ * @fmt:        formatting of buffer
+ * @...:        resulting arguments
+ */
+int m_sscanf(const char * buf, const char * fmt, ...)
+{
+        va_list args;
+        int i;
+
+        va_start(args,fmt);
+        i = m_vsscanf(buf,fmt,args);
+        va_end(args);
+        return i;
+}
\ No newline at end of file
diff --git a/Massai/cpp/MassaiDLL/dll/src/trace.cpp b/Massai/cpp/MassaiDLL/dll/src/trace.cpp
new file mode 100644
index 00000000..0b91eed7
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/dll/src/trace.cpp
@@ -0,0 +1,1072 @@
+/****************************************************************************
+
+ FILE:      trace.cpp
+
+ PURPOSE:   MUTILS - trace functionality.
+
+ DATE:      11/28/95 - 14:43:05
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+#include <io.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <iostream.h>
+
+#include "base_os.h"
+#include "massai.hpp"
+#include "globbase.hpp"
+#include "mConfig.h"
+#include "trace.hpp"
+#include "compress.h"
+#include "mThread.hpp"
+
+/* private constants *********************************************************/
+
+#define MAGIC_ID          1234567
+#define MAX_TRACE_BUF     (1024L * 128L)
+#define MAX_FILE_SIZE     (1024L * 2048L)
+#define MAX_HISTORY_LEVEL  9
+
+#define MUTILS_PRIORITY   PRTYC_TIMECRITICAL
+
+// global vars for this file -----------------------------------------------
+
+PRIVATE CHAR      *pszFunction = "";  // not used anymore for tracing
+
+PRIVATE CHAR       szTrcDevice[256];
+PRIVATE CHAR       szRemote[CHARBUF];
+PRIVATE BOOL       fExtendedTrace    = FALSE;
+PRIVATE BOOL       fDoTrace          = FALSE;
+PRIVATE ULONG      ulMaxHistoryLevel = MAX_HISTORY_LEVEL;
+PRIVATE HFILE      hComTrace         = 0;
+PRIVATE BOOL       fSaveTrace        = FALSE;
+PRIVATE CHAR       szTraceBuf[MAX_TRACE_BUF];
+PRIVATE ULONG      ulBytesToWrite;
+PRIVATE USHORT     usPort;
+
+PRIVATE TID        tidTraceThread     = 0;
+PRIVATE TID        tidFileTraceThread = 0;
+PRIVATE HEV        hevTCPIPWrite;
+PRIVATE HEV        hevTCPIPWritten;
+PRIVATE HEV        hevFileWrite;
+PRIVATE HEV        hevFileWritten;
+
+PRIVATE mConfig rmtTrcServer;
+
+// private function prototypes----------------------------------------------
+
+PRIVATE ULONG tcpipWriteThread  (ULONG);
+PRIVATE ULONG debugWriteThread  (ULONG);
+PRIVATE ULONG WriteToFile       (HFILE, VOID *, ULONG, ULONG *);
+
+
+
+#define SADDAM
+
+//---------------------------------------------------------------------------
+//
+//  function:   static char *byte2Hex(int x)
+//
+//  purpose:
+//
+//  date:       02.12.2002, 10:58
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+static char *byte2Hex(int x)
+{
+static char szTmp[3];
+int x1,x2;
+
+    x &= 0xff;
+
+    x1 = (x / 16);
+    x2 = (x % 16);
+
+    szTmp[0] = x1 < 10 ? '0' + (char) x1 : 'a' + (char) (x1 - 10);
+    szTmp[1] = x2 < 10 ? '0' + (char) x2 : 'a' + (char) (x2 - 10);
+
+    szTmp[2] = '\0';
+
+    return(szTmp);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   static char *byte2HEX(int x)
+//
+//  purpose:
+//
+//  date:       02.12.2002, 10:58
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+static char *byte2HEX(int x)
+{
+static char szTmp[3];
+int x1,x2;
+
+    x &= 0xff;
+
+    x1 = (x / 16);
+    x2 = (x % 16);
+
+    szTmp[0] = x1 < 10 ? '0' + (char) x1 : 'A' + (char) (x1 - 10);
+    szTmp[1] = x2 < 10 ? '0' + (char) x2 : 'A' + (char) (x2 - 10);
+
+    szTmp[2] = '\0';
+
+    return(szTmp);
+}
+
+EXPORT VOID debugWrite(BYTE bLevel,CHAR *pszFile,SHORT sLine,CHAR *pszFormat, ...)
+{
+#if defined(SADDAM)
+
+static mConfig traceLevel("MUTILS","TRACE","TraceLevel");
+
+APIRET    rc = 0;
+DATETIME  Date;
+ULONG     ulLen;
+ULONG     ulDump;
+ULONG     ulTmp;
+TIB      *pTib;
+PIB      *pPib;
+CHAR     *pTmp;
+CHAR     *pArg;
+CHAR     *pStr;
+CHAR      szFile[CHARBUF];
+CHAR      szFunc[CHARBUF];
+
+va_list   arg_ptr;
+
+    OS_GetInfoBlocks(&pTib,&pPib);
+
+    if(bLevel <= traceLevel.asInt() || bLevel == 255)
+    {
+      // serialize writing to trace file
+
+      if((pTmp = (CHAR*) malloc(MAX_TRACE_BUF)) == NULL) // XXX
+      {
+        return;
+      }
+
+      /* write traces with date and time */
+
+      OS_GetDateTime(&Date);
+
+      memset(pTmp,0,MAX_TRACE_BUF);
+
+      ulLen = ulTmp = 0;
+
+      if(*szTrcDevice)
+        ulTmp = ulLen = sprintf(pTmp,"[%s] ",szTrcDevice);
+
+      ulLen += sprintf(pTmp + ulLen,"%02d%02d %02d%02d:%02d.%02d ",
+                           Date.day,
+                           Date.month,
+                           Date.hours,
+                           Date.minutes,
+                           Date.seconds,
+                           Date.hundredths);
+
+      /* check given arguments */
+
+      if(pszFile && pszFunction && pszFormat)
+      {
+        strcpy(szFunc,pszFunction);
+        strcpy(szFile,pszFile);
+
+        if(fExtendedTrace)
+        {
+          // write with complete pathname
+
+          ulLen += sprintf(pTmp + ulLen,"%s (%4d), %s\n",pszFile,sLine,pszFunction);
+        }
+        else
+        {
+          // discard function arguments
+
+          if((pStr = strrchr(szFunc,'(')) != NULL)
+          {
+            *(pStr +1) = ')';
+            *(pStr +2) = '\0';
+          }
+
+          // cut path from file name
+
+          if((pStr = strrchr(szFile,'\\')) != NULL)
+            strcpy(szFile,pStr +1);
+
+          // cut file name extension
+
+          if((pStr = strrchr(szFile,'.')) != NULL)
+            *pStr = '\0';
+
+          ulLen += sprintf(pTmp + ulLen,"%-16s(%4d): ",szFile,sLine);
+        }
+
+        if(*pszFormat == '%' && *(pszFormat +1) == 'T')
+        {
+          // comes from mTrace.dump() -> copy only !!
+
+          va_start(arg_ptr,pszFormat);
+
+          // get pointer to first argument
+
+          pArg = (CHAR *)va_arg(arg_ptr,PCHAR);
+
+          // get length of dump
+
+          ulDump = (ULONG) va_arg(arg_ptr,ULONG);
+
+          /* copy to buffer */
+
+          strcpy(pTmp + ulLen,pArg);
+
+          ulLen += ulDump;
+
+          va_end(arg_ptr);
+        }
+        else
+        {
+          /* get pointer to first argument */
+
+          va_start(arg_ptr,pszFormat);
+
+          /* print into buffer */
+
+          ulLen += vsprintf(pTmp + ulLen,pszFormat,arg_ptr);
+
+          va_end(arg_ptr);
+        }
+
+        if(fExtendedTrace)
+          ulLen += sprintf(pTmp + ulLen,"\n\n");
+        else
+          ulLen += sprintf(pTmp + ulLen,"\n");
+      }
+      else
+        ulLen = sprintf(pTmp,"<< INVALID TRACE >>");
+
+      *(pTmp + ulLen) = '\0';
+
+      if(ulTmp)
+        OutputDebugString((CHAR *)(pTmp + ulTmp));
+      else
+        OutputDebugString((CHAR *)pTmp);
+
+      free(pTmp);
+    }
+
+#endif
+
+    return;
+}
+
+EXPORT VOID debugDump (BYTE bLevel,CHAR *pszFile,SHORT sLine,CHAR *pszFunction,BYTE *pData,USHORT usLen)
+{
+static mConfig traceLevel("MUTILS","TRACE","TraceLevel");
+USHORT    i,j;
+SHORT     rc;
+CHAR     *pTmp;
+ULONG     ulSize;
+
+    if(bLevel <= traceLevel.asInt() || bLevel == 255)
+    {
+      ulSize = ((usLen >> 4) +1) * 80;
+
+      if(!pData || !usLen || ulSize > MAX_TRACE_BUF -128)
+        return;
+
+      if((pTmp = (CHAR*) malloc(ulSize)) == NULL) // XXX
+        return;
+
+      rc = sprintf(pTmp,"%c",'\n');
+
+      for(i = 0; i < usLen; i += 16)
+      {
+        rc += sprintf(pTmp +rc,"[%04x,%04d] ",i,i);
+
+        for(j = 0; j < 16 && (i+j) < usLen; j++)
+        {
+          if(j == 8)
+            rc += sprintf(pTmp + rc,"- %s ",byte2Hex(pData[i+j]));
+          else
+            rc += sprintf(pTmp + rc,"%s ",byte2Hex(pData[i+j]));
+        }
+
+        while(j < 16)
+        {
+          if(j == 8)
+            rc += sprintf(pTmp + rc,"     ");
+          else
+            rc += sprintf(pTmp + rc,"   ");
+
+          j++;
+        }
+
+        for(j = 0; j < 16 && (i+j) < usLen; j++)
+          rc += sprintf(pTmp + rc,"%c",(pData[i+j] >= ' ') ? pData[i+j]: '.');
+
+        rc += sprintf(pTmp + rc,"\n");
+      }
+
+      debugWrite(bLevel,pszFile,sLine,pszFunction,"%T",pTmp,rc);
+
+      free(pTmp);
+    }
+
+    return;
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE APIRET addToHistory(CHAR *pszFile)
+
+ COMMENTS:  Adds file to history list.
+
+ DATE:      10/10/96 - 15:54:39
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+APIRET addToHistory(CHAR *pszFile)
+{
+CHAR     *pStr;
+CHAR      szFile[CHARBUF];
+CHAR      szRen [CHARBUF];
+APIRET    rc;
+BOOL      fDone;
+ULONG     i;
+
+    // anything to do ??
+
+    if(!pszFile || !*pszFile)
+      return(-1L);
+
+    strcpy(szFile,pszFile);
+    strcpy(szRen, pszFile);
+
+    // first check if the max level reached
+
+    if((pStr = strrchr(szFile,'.')) != NULL)
+      sprintf((pStr+1),"%03d",ulMaxHistoryLevel);
+
+    if(!access(szFile,0))
+    {
+      // max history level reached !!
+
+      if((pStr = strrchr(szFile,'.')) != NULL)
+      {
+        sprintf((pStr+1),"%03d",0);
+
+        // delete oldest file first
+
+        rc = OS_Delete(szFile);
+      }
+
+      // make all remaining files one level lower
+
+      for(i = 0; i < ulMaxHistoryLevel; i++)
+      {
+        if((pStr = strrchr(szRen,'.')) != NULL)
+          sprintf((pStr+1),"%03d",i);
+
+        if((pStr = strrchr(szFile,'.')) != NULL)
+          sprintf((pStr+1),"%03d",i+1);
+
+        rc = OS_Move(szFile,szRen);
+      }
+    }
+    else
+    {
+      // find most actual level
+
+      for(i = 0, fDone = FALSE; !fDone ; i++)
+      {
+        if((pStr = strrchr(szFile,'.')) != NULL)
+          sprintf((pStr+1),"%03d",i);
+
+        if(access(szFile,0))
+          fDone = TRUE;
+      }
+
+      // count variables are never correct after loops :(
+
+      i--;
+    }
+
+    // make $$$ file the most recent level
+
+    if((pStr = strrchr(szRen,'.')) != NULL)
+      sprintf((pStr+1),"%03d",i);
+
+    rc = OS_Move(pszFile,szRen);
+
+    return(rc);
+}
+
+/****************************************************************************
+
+ FUNCTION:  VOID InitTrace(VOID)
+
+ COMMENTS:  Initializes traces.
+
+ DATE:      05/08/96 - 10:06:59
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+VOID InitTrace()
+{
+mConfig extendedTrace("MUTILS","TRACE","ExtendedTrace");
+mConfig maxHistory   ("MUTILS","TRACE","HistoryLevel");
+
+    fExtendedTrace    = FALSE;
+    fDoTrace          = FALSE;
+    ulMaxHistoryLevel = MAX_HISTORY_LEVEL;
+    hComTrace         = 0;
+    fSaveTrace        = FALSE;
+
+    if(!extendedTrace.error() && extendedTrace.asBool())
+      fExtendedTrace = TRUE;
+
+    if(!maxHistory.error())
+      ulMaxHistoryLevel = (ULONG) maxHistory.asInt();
+
+
+    return;
+}
+
+/****************************************************************************
+
+ METHOD:    BYTE mTrace::getLevel(VOID)
+
+ COMMENTS:  Returns trace level.
+
+ DATE:      11/29/95 - 12:18:05
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+BYTE mTrace::getLevel(VOID)
+{
+  return(bTraceLevel);
+}
+
+/****************************************************************************
+
+ METHOD:    VOID mTrace::setLevel(BYTE bNewLevel)
+
+ COMMENTS:  Set new trace level for this instance.
+
+ DATE:      11/29/95 - 12:18:05
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+VOID mTrace::setLevel(BYTE bNewLevel)
+{
+CHAR   szBuffer[CHARBUF];
+ULONG  ulWritten;
+APIRET rc;
+
+  bTraceLevel = (bNewLevel > 9) ? 9 : bNewLevel;  // set new level
+
+  if(hTraceFile)
+  {
+    sprintf(szBuffer,"DEVID(%d), VER(%s), NEW-LEVEL(%u)\n\n",ulDeviceID,
+                                                             szVersion,
+                                                             bTraceLevel);
+
+    rc = WriteToFile(hTraceFile,szBuffer,strlen(szBuffer),&ulWritten);
+  }
+}
+
+/****************************************************************************
+
+ METHOD:    VOID mTrace::resetLevel(VOID)
+
+ COMMENTS:  Resets trace level to initial level of this instance.
+
+ DATE:      11/29/95 - 12:18:05
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+VOID mTrace::resetLevel(VOID)
+{
+CHAR   szBuffer[CHARBUF];
+ULONG  ulWritten;
+APIRET rc;
+
+  bTraceLevel = bOldTraceLevel;  // reset to previous level
+
+  if(hTraceFile)
+  {
+    sprintf(szBuffer,"DEVID(%d), VER(%s), NEW-LEVEL(%u)\n\n",ulDeviceID,
+                                                             szVersion,
+                                                             bTraceLevel);
+
+    rc = WriteToFile(hTraceFile,szBuffer,strlen(szBuffer),&ulWritten);
+  }
+}
+
+/****************************************************************************
+
+ METHOD:    VOID mTrace::reset()
+
+ COMMENTS:  Close old and open new trace file.
+
+ DATE:      10/11/96 - 14:05:43
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+VOID mTrace::reset()
+{
+    if(!hTraceFile)
+      return;
+
+    // close current file
+
+    if(ulError = CloseTraceFile())
+    {
+      return;
+    }
+
+    // open new trace file
+
+    ulError = OpenTraceFile(szTraceFileName);
+
+    return;
+}
+
+/****************************************************************************
+
+ METHOD:    VOID mTrace::init (ULONG ulDevID,BYTE bLevel,CHAR *pszDevVersion)
+
+ COMMENTS:  Explicit init function (also called from constructor)
+
+ DATE:      05/09/96 - 11:22:53
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+VOID mTrace::init(ULONG ulDevID, BYTE bLevel,CHAR *pszDevVersion,CHAR *pszTraceFileName)
+{
+TIB   *pTib;
+PIB   *pPib;
+
+    OS_GetInfoBlocks(&pTib,&pPib);
+
+    ulPID = pPib->pib_ulpid;
+
+    /* check if already initialized */
+
+    if(hTraceFile)
+      CloseTraceFile();
+
+    *szRemotePipe = '\0';
+
+    hTraceFile     = 0L;
+    ulError        = 0L;
+
+    ulDeviceID     = ulDevID;
+    bTraceLevel    = (bLevel > 9) ? 9 : bLevel;
+    bOldTraceLevel = bTraceLevel;  // save for reset
+
+    if(pszDevVersion && *pszDevVersion)
+      strcpy(szVersion,pszDevVersion);
+    else
+      strcpy(szVersion,"Version string missing !!");
+
+    if(pszTraceFileName && *pszTraceFileName)
+    {
+      strcpy(szTraceFileName,pszTraceFileName);
+
+      if(!strrchr(szTraceFileName,'.'))
+        strcat(szTraceFileName,".trc");
+    }
+    else
+      sprintf(szTraceFileName,"%08lx.trc",ulDevID);
+
+    ulError = OpenTraceFile(szTraceFileName);
+
+    return;
+}
+
+/****************************************************************************
+
+ METHOD:    mTrace::mTrace (ULONG ulDevID,BYTE bLevel,CHAR *pszDevVersion)
+
+ COMMENTS:  Constructor for trace class.
+
+ DATE:      11/29/95 - 12:18:05
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+mTrace::mTrace(ULONG ulDevID,BYTE bLevel,CHAR *pszDevVersion,CHAR *pszTraceFileName)
+{
+    hTraceFile  = 0;
+
+    init(ulDevID,bLevel,pszDevVersion,pszTraceFileName);
+    return;
+}
+
+/****************************************************************************
+
+ METHOD:    mTrace::~mTrace (VOID)
+
+ COMMENTS:  Destructor for trace class.
+
+ DATE:      11/29/95 - 12:18:05
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+mTrace::~mTrace (VOID)
+{
+    OS_CloseMutexSem(hmtxSem);
+
+    CloseTraceFile();
+
+    ulDeviceID       = 0L;
+    bTraceLevel      = 0;
+    bOldTraceLevel   = 0;
+    hTraceFile       = 0;
+
+    *szVersion       = '\0';
+    *szTraceFileName = '\0';
+}
+
+/****************************************************************************
+
+ METHOD:    APIRET mTrace::OpenTraceFile(CHAR *pszTraceFileName)
+
+ COMMENTS:  Opens the trace file
+
+ DATE:      11/29/95 - 12:41:22
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+APIRET mTrace::OpenTraceFile(CHAR *pszTraceFileName)
+{
+CHAR   szFile  [CHARBUF];
+CHAR   szRen   [CHARBUF];
+CHAR   szBuffer[CHARBUF];
+CHAR  *pStr;
+ULONG  ulAction;
+ULONG  ulWritten;
+APIRET rc;
+
+mConfig tracePath("MUTILS","TRACE","TracePath");
+
+    if(tracePath.error() != 0)
+    {
+      if(rc = QueryMUtilsPath(szFile))
+        return(rc);
+
+      if((pStr = strrchr(szFile,'\\')) != NULL)
+         *pStr = '\0';
+
+      strcat(szFile,"\\trc");
+    }
+    else
+      tracePath.asString(szFile,sizeof(szFile));
+
+    /* open file only if not already opened */
+
+    if(!hTraceFile)
+    {
+      /* make trace path if not exist */
+
+      strcpy(szRen,szFile);
+
+      if(access(szFile,0))
+        OS_MkDir(szFile,0L);
+
+      /* check if file already exists */
+
+      strcat(szFile,"\\");
+      strcat(szRen,"\\");
+
+      strcat(szFile,pszTraceFileName);
+      strcat(szRen,pszTraceFileName);
+
+      if((pStr = strrchr(szRen,'.')) != NULL)
+        strcpy(pStr+1,"$$$");
+
+      if(!access(szFile,0))
+      {
+        /* delete old saved file first */
+        COMPRESS compress;
+
+        rc = OS_Delete         (szRen);
+        rc = OS_Move           (szFile,szRen);
+        rc = compress.packFile (szRen);
+        rc = addToHistory      (szRen);
+      }
+
+      if(rc = OS_Open(szFile,
+                      &hTraceFile,
+                      &ulAction,
+                      0,
+                      FILE_NORMAL,
+                      OPEN_ACTION_REPLACE_IF_EXISTS |
+                      OPEN_ACTION_CREATE_IF_NEW,
+                      OPEN_SHARE_DENYNONE   |
+                      OPEN_ACCESS_READWRITE |
+                      OPEN_FLAGS_NOINHERIT,
+                      0))
+      {
+        return(ERR_TRC_FILE_NOT_OPENED);
+      }
+      else
+      {
+        sprintf(szBuffer,"DEVID(%d), VER(%s), INIT-LEVEL(%u)\n\n",ulDeviceID,
+                                                                  szVersion,
+                                                                  bTraceLevel);
+
+        rc = WriteToFile(hTraceFile,szBuffer,strlen(szBuffer),&ulWritten);
+      }
+    }
+
+    return(0L);
+}
+
+/****************************************************************************
+
+ METHOD:    APIRET mTrace::CloseTraceFile (VOID);
+
+ COMMENTS:  Closes trace file for this instance.
+
+ DATE:      11/29/95 - 12:52:24
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+APIRET mTrace::CloseTraceFile()
+{
+APIRET rc = 0;
+
+    /* close only if opened */
+
+    if(hTraceFile)
+      rc = OS_Close(hTraceFile);
+
+    hTraceFile = 0;
+
+    return(rc);
+}
+
+/****************************************************************************
+
+ METHOD: VOID mTrace::write(BYTE  bLevel,
+                              CHAR *pszFile,
+                              SHORT sLine,
+                              CHAR *pszFunction,
+                              CHAR *pszFormat,...)
+
+ COMMENTS:  Writes traces to disk.
+
+ DATE:      11/30/95 - 13:03:08
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+VOID mTrace::write(BYTE bLevel,CHAR *pszFile,SHORT sLine,CHAR *pszFunction,CHAR *pszFormat,...)
+{
+APIRET    rc = 0;
+DATETIME  Date;
+ULONG     ulWritten;
+ULONG     ulFileSize;
+ULONG     ulLen;
+ULONG     ulDump;
+ULONG     ulTmp;
+TIB      *pTib;
+PIB      *pPib;
+CHAR     *pTmp;
+CHAR     *pArg;
+CHAR     *pStr;
+CHAR      szFile[CHARBUF];
+CHAR      szFunc[CHARBUF];
+
+va_list   arg_ptr;
+
+    if(!this)
+    {
+      OutputDebugString("No this-pointer in mTrace::write()");
+      return;
+    }
+
+    OS_GetInfoBlocks(&pTib,&pPib);
+
+    /* look if trace file opened */
+
+    if((hTraceFile && bLevel <= bTraceLevel) || bLevel == 255)
+    {
+      // serialize writing to trace file
+
+      {
+        // wrap trace file if nessecary
+
+        rc = OS_SetFilePtr(hTraceFile,0L,FILE_END,&ulFileSize);
+
+        if(ulFileSize > MAX_FILE_SIZE)
+        {
+          CloseTraceFile();
+
+          if(rc = OpenTraceFile(szTraceFileName))
+          {
+            return;
+          }
+        }
+      }
+
+      if((pTmp = (CHAR*) malloc(MAX_TRACE_BUF)) == NULL) // XXX
+      {
+        ulError = 2003;
+
+        return;
+      }
+
+      /* write traces with date and time */
+
+      OS_GetDateTime(&Date);
+
+      memset(pTmp,0,MAX_TRACE_BUF);
+
+      ulLen = ulTmp = 0;
+
+      if(*szTrcDevice)
+        ulTmp = ulLen = sprintf(pTmp,"[%s] ",szTrcDevice);
+
+      ulLen += sprintf(pTmp + ulLen,"%02d%02d %02d%02d:%02d.%02d ",
+                           Date.day,
+                           Date.month,
+                           Date.hours,
+                           Date.minutes,
+                           Date.seconds,
+                           Date.hundredths);
+
+      /* check given arguments */
+
+      if(pszFile && pszFunction && pszFormat)
+      {
+        strcpy(szFunc,pszFunction);
+        strcpy(szFile,pszFile);
+
+        if(fExtendedTrace)
+        {
+          // write with complete pathname
+
+          ulLen += sprintf(pTmp + ulLen,"%s (%4d), %s\n",pszFile,sLine,pszFunction);
+        }
+        else
+        {
+          // discard function arguments
+
+          if((pStr = strrchr(szFunc,'(')) != NULL)
+          {
+            *(pStr +1) = ')';
+            *(pStr +2) = '\0';
+          }
+
+          // cut path from file name
+
+          if((pStr = strrchr(szFile,'\\')) != NULL)
+            strcpy(szFile,pStr +1);
+
+          // cut file name extension
+
+          if((pStr = strrchr(szFile,'.')) != NULL)
+            *pStr = '\0';
+
+          ulLen += sprintf(pTmp + ulLen,"%-16s(%4d): ",szFile,sLine);
+        }
+
+        if(*pszFormat == '%' && *(pszFormat +1) == 'T')
+        {
+          // comes from mTrace.dump() -> copy only !!
+
+          va_start(arg_ptr,pszFormat);
+
+          // get pointer to first argument
+
+          pArg = (CHAR *)va_arg(arg_ptr,PCHAR);
+
+          // get length of dump
+
+          ulDump = (ULONG) va_arg(arg_ptr,ULONG);
+
+          /* copy to buffer */
+
+          strcpy(pTmp + ulLen,pArg);
+
+          ulLen += ulDump;
+
+          va_end(arg_ptr);
+        }
+        else
+        {
+          /* get pointer to first argument */
+
+          va_start(arg_ptr,pszFormat);
+
+          /* print into buffer */
+
+          ulLen += vsprintf(pTmp + ulLen,pszFormat,arg_ptr);
+
+          va_end(arg_ptr);
+        }
+
+        if(fExtendedTrace)
+          ulLen += sprintf(pTmp + ulLen,"\n\n");
+        else
+          ulLen += sprintf(pTmp + ulLen,"\n");
+      }
+      else
+        ulLen = sprintf(pTmp,"<< INVALID TRACE >>");
+
+      *(pTmp + ulLen) = '\0';
+
+      // write everything to file (only if owner !!)
+
+      if(ulTmp)
+      {
+        OutputDebugString((CHAR *)(pTmp + ulTmp));
+        rc = WriteToFile(hTraceFile,(VOID *)(pTmp + ulTmp),ulLen - ulTmp,&ulWritten);
+      }
+      else
+      {
+        OutputDebugString((CHAR *)pTmp);
+        rc = WriteToFile(hTraceFile,(VOID *)pTmp,ulLen,&ulWritten);
+      }
+
+      free(pTmp);
+    }
+
+    return;
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE ULONG WriteToFile (HFILE, VOID *, ULONG, ULONG *)
+
+ COMMENTS:  Write data to tracefile
+
+ DATE:      8-22-97, 10:45 AM
+
+ AUTHOR:    Dr. Materna GmbH   (MaK)
+
+****************************************************************************/
+
+PRIVATE ULONG WriteToFile (HFILE hFile, VOID *pData, ULONG ulLen, ULONG *pulWritten)
+{
+ULONG rc;
+
+  rc = OS_Write(hFile,pData,ulLen,pulWritten);
+  return rc;
+}
+
+/****************************************************************************
+
+ METHOD: VOID mTrace::dump (BYTE   bLevel,
+                              CHAR  *pszFile,
+                              SHORT  sLine,
+                              BYTE  *pData,
+                              USHORT usLen)
+
+ COMMENTS:  Writes hex dump to disk.
+
+ DATE:      12/04/95 - 16:33:24
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+VOID mTrace::dump(BYTE bLevel,CHAR *pszFile,SHORT sLine,BYTE *pData, USHORT usLen)
+{
+USHORT    i,j;
+SHORT     rc;
+CHAR     *pTmp;
+ULONG     ulSize;
+
+    if(!this)
+    {
+      OutputDebugString("No this-pointer in mTrace::dump()");
+      return;
+    }
+
+    if((hTraceFile && bLevel <= bTraceLevel) || bLevel == 255)
+    {
+      ulSize = ((usLen >> 4) +1) * 80;
+
+      if(!pData || !usLen || ulSize > MAX_TRACE_BUF -128)
+        return;
+
+      if((pTmp = (CHAR*) malloc(ulSize)) == NULL) // XXX
+        return;
+
+      rc = sprintf(pTmp,"%c",'\n');
+
+      for(i = 0; i < usLen; i += 16)
+      {
+        rc += sprintf(pTmp +rc,"[%04x,%04d] ",i,i);
+
+        for(j = 0; j < 16 && (i+j) < usLen; j++)
+        {
+          if(j == 8)
+            rc += sprintf(pTmp + rc,"- %s ",byte2Hex(pData[i+j]));
+          else
+            rc += sprintf(pTmp + rc,"%s ",byte2Hex(pData[i+j]));
+        }
+
+        while(j < 16)
+        {
+          if(j == 8)
+            rc += sprintf(pTmp + rc,"     ");
+          else
+            rc += sprintf(pTmp + rc,"   ");
+
+          j++;
+        }
+
+        for(j = 0; j < 16 && (i+j) < usLen; j++)
+          rc += sprintf(pTmp + rc,"%c",(pData[i+j] >= ' ') ? pData[i+j]: '.');
+
+        rc += sprintf(pTmp + rc,"\n");
+      }
+
+      write(bLevel,pszFile,sLine,pszFunction,"%T",pTmp,rc);
+
+      free(pTmp);
+    }
+
+    return;
+}
diff --git a/Massai/cpp/MassaiDLL/static/inc/COMPRESS.H b/Massai/cpp/MassaiDLL/static/inc/COMPRESS.H
new file mode 100644
index 00000000..8181c40f
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/static/inc/COMPRESS.H
@@ -0,0 +1,59 @@
+/***********************************************************************
+ *                           CMVC Information
+ *                           ----------------
+ * File, Component, Release   : SSDBASE/INC/COMPRESS.H, ATSA.SSD.BASE.SSDBASE.OS2, ATSA_SSDBASE.o1
+ * Version                    : 1.1
+ * Date of last Check-In      : 96/10/22, 16:21:33
+ * Date of last Access        : 96/12/10, 16:28:20
+ **********************************************************************/
+/****************************************************************************
+
+ FILE:      compress.h
+
+ PURPOSE:   Header file
+
+ DATE:      21-Jan-1992
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+#ifndef COMPRESS_H
+#define COMPRESS_H
+
+/* exported functions ********************************************************/
+
+class COMPRESS
+{
+
+ SHORT  *psCodeValue;          /* pointer to code value array          */
+ USHORT *pwPrefixCode;         /* pointer to prefix code array         */
+ BYTE   *pbAppendChar;         /* pointer to array with appended chars */
+ BYTE    abDecodeStack[4000];  /* array to hold decoded string         */
+
+ SHORT sOutputBitCnt;
+ ULONG ulOutputBitBuf;
+ SHORT sInputBitCnt;
+ ULONG ulInputBitBuf;
+
+
+ USHORT  InitLZW       (VOID);
+ USHORT  ReleaseLZW    (VOID);
+ SHORT   FindMatch     (USHORT,USHORT);
+ USHORT  OutputCode    (FILE *,USHORT);
+ USHORT  InputCode     (FILE *);
+ CHAR   *DecodeString  (BYTE  *,USHORT);
+
+
+
+public:
+
+   USHORT packFile   (CHAR *);
+   USHORT unpackFile (CHAR *);
+
+// constructors
+   COMPRESS();
+  ~COMPRESS();
+};  
+
+#endif // COMPRESS_H
diff --git a/Massai/cpp/MassaiDLL/static/inc/TRACE.HPP b/Massai/cpp/MassaiDLL/static/inc/TRACE.HPP
new file mode 100644
index 00000000..c21517e1
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/static/inc/TRACE.HPP
@@ -0,0 +1,53 @@
+/******************************************************************************
+
+ FILE:      trace.hpp
+
+ PURPOSE:   Header file.
+
+ DATE:      11/28/95 - 15:35:33
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+******************************************************************************/
+
+#ifndef TRACE_HPP
+#define TRACE_HPP
+
+#ifdef SHOW_INCLUDE_FILES
+
+#pragma message("including: " __FILE__)
+
+#endif
+
+#ifdef __cplusplus
+      extern "C" {
+#endif
+
+EXPORT VOID InitTrace          (void);
+EXPORT VOID TerminateTrace     (void);
+EXPORT BOOL TraceAttachProcess (void);
+EXPORT BOOL TraceDetachProcess (void);
+
+// trace functions using OutputDebugString()
+
+EXPORT VOID debugWrite         (BYTE   bLevel,        // trace level
+                                CHAR  *pszFile,       // src file name
+                                SHORT  sLine,         // line in src file
+                                CHAR  *pszFormat,     // format of vars
+                                ...);                 // vars...
+
+EXPORT VOID debugDump          (BYTE   bLevel,        // trace level
+                                CHAR  *pszFile,       // src file name
+                                SHORT  sLine,         // line in src file
+                                BYTE  *pDate,         // dump area
+                                USHORT usLen);        // bytes to dump
+
+#ifdef __cplusplus
+      }
+#endif
+
+#endif /* TRACE_HPP */
+
+/******************************************************************************
+ END OF FILE
+******************************************************************************/
diff --git a/Massai/cpp/MassaiDLL/static/inc/globbase.hpp b/Massai/cpp/MassaiDLL/static/inc/globbase.hpp
new file mode 100644
index 00000000..bfedd1d2
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/static/inc/globbase.hpp
@@ -0,0 +1,71 @@
+/******************************************************************************
+
+ FILE:      globbase.hpp
+
+ PURPOSE:   Global exports for SSDBASE only.
+
+ DATE:      12/06/95 - 10:07:50
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+******************************************************************************/
+
+#ifndef GLOBBASE_HPP
+#define GLOBBASE_HPP
+
+//#include <winsock.h>
+
+/* exported classes ********************************************************/
+class MassaiLibraryInitTerm
+{
+public:
+
+    MassaiLibraryInitTerm();
+    ~MassaiLibraryInitTerm();
+    void ref();
+};
+/* exported constants ********************************************************/
+
+#define M_UTILSDEV_TRC         M_UTILSDEV,255,"0.0.0.0","mUtils.log"
+#define M_UTILSDEV_FILE        "mUtils.log"
+
+#define M_STARTDEVICES        "MUTILS","DEVICES"
+#define M_STARTDEVICE_ID      "Device%ld"
+
+#define M_INTERNAL_DEV        (M_MAX_DEVICES +1)
+#define M_SHUTDOWN            0xF0000001
+
+/* exported functions ********************************************************/
+
+EXPORT mTrace&    trc                ();
+EXPORT char      *remoteTrace        ();
+EXPORT char      *traceDevice        ();
+EXPORT HMTX       traceSem           ();
+EXPORT HMTX       sharedMemSem       ();
+EXPORT APIRET     SysComInit         ();
+EXPORT void       SysComTerm         ();
+EXPORT long       SysComDevices      ();
+EXPORT long       startHttp          ();
+EXPORT void       stopHttp           ();
+EXPORT long       startFTP           ();
+EXPORT void       stopFTP            ();
+EXPORT long       lswap              (long);
+EXPORT void       shutdownServices   ();
+EXPORT bool       servicesInShutDown ();
+EXPORT long       mRebootRemote      (BYTE,char *,SHORT,char *,bool);
+EXPORT void       addLog             (BYTE bLevel,char *pszFile,SHORT sLine,char *pszFunction,char *pszFormat,...);
+EXPORT long       currentProcessId   ();
+
+
+/* external definitions ******************************************************/
+
+IMPORT "C" int _CRT_init();         // runtime environment initialisation
+IMPORT "C" int _CRT_term();         // runtime environment deinitialisation
+IMPORT "C" void __ctordtorInit();   // for c++
+IMPORT "C" void __ctordtorTerm();   // for c++
+
+#endif /* GLOBBASE_HPP */
+
+/******************************************************************************
+ END OF FILE
+******************************************************************************/
diff --git a/Massai/cpp/MassaiDLL/static/inc/local_def.h b/Massai/cpp/MassaiDLL/static/inc/local_def.h
new file mode 100644
index 00000000..b177811b
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/static/inc/local_def.h
@@ -0,0 +1,27 @@
+/*! \mainpage massaiDll
+ *
+ *  @version 1.0.0.4
+ *
+ *  \section change1 Change history
+ *
+ *  \date 02.11.2006 \li V1.0.0.4
+ *                   \li SteT EDB 26725: massaiDLL schreibt NULL in die TraceDatei
+ *
+ *  \date 11.10.2006 \li V1.0.0.3
+ *                   \li SteT EDB 26546: Access Violation in massaiDLL
+ *
+ *  \date 26.09.2006 \li V1.0.0.2
+ *                   \li bugfix static dll searching and reading configfile (important for none massai platform)(PtM)
+ *                   \li Start release notes (PtM)
+ */
+
+
+#define FILE_VER_BIN     1,0,0,4
+#define FILE_VER_STR     "FileVersion", "1.0.0.4\0"
+
+#define FILEDESCRIPTION  "FileDescription"  ,"Massai utility dll\0"
+#define INTERNALNAME     "InternalName"     ,"Massai DLL\0"
+#define LEGALTRADEMARKS  "LegalTrademarks"  ,"\0"
+#define ORIGINALFILENAME "OriginalFilename" ,"massai.dll\0"
+
+
diff --git a/Massai/cpp/MassaiDLL/static/inc/mConfig.h b/Massai/cpp/MassaiDLL/static/inc/mConfig.h
new file mode 100644
index 00000000..b16bfa15
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/static/inc/mConfig.h
@@ -0,0 +1,42 @@
+/***********************************************************************
+ *                           CMVC Information
+ *                           ----------------
+ * File, Component, Release   : SSDBASE/INC/CFGBASE.H, ATSA.SSD.BASE.SSDBASE.OS2, ATSA_SSDBASE.o1
+ * Version                    : 1.1
+ * Date of last Check-In      : 96/10/22, 16:21:31
+ * Date of last Access        : 96/12/10, 16:28:16
+ **********************************************************************/
+/****************************************************************************
+
+ FILE:      cfgbase.h
+
+ PURPOSE:   Header file.
+
+ DATE:      11/23/95 - 15:09:31
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+        
+#ifndef MCONFIG_H
+#define MCONFIG_H
+
+/* exported functions ******************************************************/
+
+#ifdef __cplusplus
+      extern "C" {
+#endif
+
+EXPORT APIRET mUtilsReadConfig  (VOID);
+EXPORT APIRET FreeConfiguration  (VOID); 
+EXPORT APIRET QueryMUtilsPath   (CHAR *); 
+
+#ifdef __cplusplus
+      }
+#endif
+
+#endif /* CFGBASE_H */
+
+/****************************************************************************
+ END OF FILE
+****************************************************************************/
diff --git a/Massai/cpp/MassaiDLL/static/inc/mhandler.hpp b/Massai/cpp/MassaiDLL/static/inc/mhandler.hpp
new file mode 100644
index 00000000..c85d96b5
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/static/inc/mhandler.hpp
@@ -0,0 +1,215 @@
+//---------------------------------------------------------------------------
+//
+//  file:       handler.h
+//
+//  purpose:    handler class definition
+//
+//  date:       28.09.99, 08:47
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+#ifndef HANDLER_H
+#define HANDLER_H
+
+//#pragma message("include: " __FILE__ )
+
+#include <iostream>
+
+#include "massai.hpp"
+#include "mThread.hpp"
+
+class mHandler;
+
+
+class mEvent
+{
+private:
+
+    ULONG     ulId;
+    ULONG     ulParam1;
+    ULONG     ulParam2;
+    mHandler *pReceiver;
+
+public:
+
+    enum ME_ID
+    {
+      ME_SYSCOM   = 1,
+      ME_SELECT   = 2,
+      ME_ACTIVATE = 3,
+      ME_TIMER    = 4,
+      ME_COMMAND  = 5
+    };
+
+    mHandler *receiver()       { return(pReceiver); }
+
+    ULONG   id()               { return(ulId);      }
+
+    ULONG   param1()           { return(ulParam1); }
+    ULONG   param2()           { return(ulParam2); }
+
+    SHORT   short11()          { return((SHORT) ulParam1 & 0x0000ffff      ); }
+    SHORT   short12()          { return((SHORT) ulParam1 & 0xffff0000 >> 16); }
+    SHORT   short21()          { return((SHORT) ulParam2 & 0x0000ffff      ); }
+    SHORT   short22()          { return((SHORT) ulParam2 & 0xffff0000 >> 16); }
+
+    USHORT  ushort11()         { return((USHORT) short11()); }
+    USHORT  ushort12()         { return((USHORT) short12()); }
+    USHORT  ushort21()         { return((USHORT) short21()); }
+    USHORT  ushort22()         { return((USHORT) short22()); }
+
+    VOID   *pointer1()         { return( (CHAR *) ulParam1 ); }
+    VOID   *pointer2()         { return( (CHAR *) ulParam2 ); }
+
+    // for COMMAND events -----------------------------------------------------
+
+    ULONG   cmd()               { return( param1() ); }
+
+    // for CONTROL events -----------------------------------------------------
+
+    ULONG   ctrlId()            { return( param1()    ); }
+    ULONG   notificationCode()  { return( id()        ); }
+    ULONG   controlData()       { return( param2()    ); }
+
+    // for CHAR events --------------------------------------------------------
+
+    USHORT  keyFlags()          { return(         ushort22() ); }
+    BYTE    scanCode()          { return((BYTE)   ushort21() ); }
+    USHORT  virtualKey()        { return((USHORT) param1()   ); }
+
+    //BOOL    isUpKey()           { return( keyFlags() & KC_KEYUP); };
+    //USHORT  character()         { return( (id() == WM_CHAR)?param1():0); };
+
+    // for TIMER events -------------------------------------------------------
+
+    USHORT timerID()             { return(ushort11()); }
+
+    // for BUTTON events ------------------------------------------------------
+
+    USHORT button()              { return( ushort11() ); }
+    USHORT buttonX()             { return( ushort21() ); }
+    USHORT buttonY()             { return( ushort22() ); }
+
+    // for CSC-ACTIVATE events ------------------------------------------------
+
+    BOOL   activated()           { return((BOOL) ushort11() ); }
+
+    // for CSC-LANGUAGE events ------------------------------------------------
+
+    ULONG  language()            { return( param1() ); }
+
+    // constructors -----------------------------------------------------------
+
+    mEvent(ME_ID id, ULONG mp1, ULONG mp2)
+    {
+      ulId      = id;
+      ulParam1  = mp1;
+      ulParam2  = mp2;
+    };
+
+    mEvent(const mHandler& hwnd, ME_ID id, ULONG mp1, ULONG mp2)
+    {
+      ulId      = id;
+      ulParam1  = mp1;
+      ulParam2  = mp2;
+    };
+
+    mEvent(mHandler* pRecv, ME_ID id, ULONG mp1, ULONG mp2)
+    {
+      ulId      = id;
+      ulParam1  = mp1;
+      ulParam2  = mp2;
+      pReceiver = pRecv;
+    };
+
+    // destructor -------------------------------------------------------------
+
+    ~mEvent() {};
+};
+
+class mHandler
+{
+private:
+
+       static mThread *pPoster;
+       static ULONG      ulCnt;
+       static ULONG      ulLanguage;
+
+       ULONG     ulId;
+       ULONG     ulMillis;
+       BOOL      fTimerStopped;
+       mHandler* pOwner;
+
+       mThread *pTimer;
+
+public:
+
+              BOOL       timerStopped        ()           { return(fTimerStopped); }
+              ULONG      millis              ()           { return(ulMillis);      }
+              VOID       setId               (ULONG ulId) { this->ulId = ulId;     }
+
+              VOID       startTimer          (ULONG ulMillis);
+              VOID       stopTimer           ();
+              VOID       setLanguage         (ULONG ulId) { ulLanguage = ulId;     }
+              ULONG      getLanguage         ()           { return(ulLanguage);    }
+
+              VOID       enableCancel        ()           { std::cout << "CANCEL = ON" << std::endl; }
+              VOID       enableOk            ()           { std::cout << "OK     = ON" << std::endl; }
+              VOID       enableContinue      ()           { std::cout << "CONT   = ON" << std::endl; }
+              VOID       enableBack          ()           { std::cout << "BACK   = ON" << std::endl; }
+              VOID       enableLang          ()           { std::cout << "LANG   = ON" << std::endl; }
+              VOID       enableHelp          ()           { std::cout << "HELP   = ON" << std::endl; }
+
+              VOID       setText             (CHAR *pStr) { std::cout << pStr << std::endl;               }
+              VOID       setText             (ULONG ulId) { std::cout << "textID = "<< ulId << std::endl; }
+
+              CHAR      *resourceText        (ULONG ulId)
+              {
+                static CHAR szTmp[50];
+
+                sprintf(szTmp,"RES-STR: %d : ",ulId);
+                return(szTmp);
+              }
+
+              mHandler*  handle              ()                            { return(this);}
+
+              ULONG      sendEvent           (mEvent event)                { return(0);   }
+              ULONG      sendEvent           (mHandler& to,  mEvent event) { return(0);   }
+              ULONG      sendEvent           (mHandler* pTo, mEvent event) { return(0);   }
+
+              BOOL       postEvent           (mEvent event);
+              BOOL       postEvent           (mHandler* pTo, mEvent event);
+
+              VOID       activate            ();
+              VOID       deactivate          ();
+
+      virtual CHAR      *name                () { return("internal handler"); };
+
+      virtual BOOL       commandHandler      (mEvent& event) { return(FALSE); };
+      virtual BOOL       controlHandler      (mEvent& event) { return(FALSE); };
+      virtual BOOL       activateHandler     (mEvent& event) { std::cout << "mHandler::ACTIVATE handler" << std::endl; return(FALSE); };
+      virtual BOOL       timerHandler        (mEvent& event) { return(FALSE); };
+      virtual BOOL       syscomHandler       (mEvent& event) { return(FALSE); };
+
+      // need these handlers ??
+
+      virtual BOOL       ctrlCommandHandler  (mEvent& event) { return(FALSE); };
+      virtual BOOL       charHandler         (mEvent& event) { return(FALSE); };
+      virtual BOOL       languageHandler     (mEvent& event) { return(FALSE); };
+      virtual BOOL       createHandler       (mEvent& event) { return(TRUE);  };
+      virtual BOOL       defaultHandler      (mEvent& event) { return(FALSE); };
+      virtual BOOL       buttonUpHandler     (mEvent& event) { return(FALSE); };
+      virtual BOOL       buttonDownHandler   (mEvent& event) { return(FALSE); };
+      virtual BOOL       buttonDoubleHandler (mEvent& event) { return(FALSE); };
+      virtual BOOL       mouseMoveHandler    (mEvent& event) { return(FALSE); };
+      virtual BOOL       touchHandler        (mEvent& event) { return(FALSE); };
+
+               mHandler(mHandler* pOwner);
+               mHandler();
+              ~mHandler();
+};
+
+
+#endif // HANDLER_H
\ No newline at end of file
diff --git a/Massai/cpp/MassaiDLL/static/inc/mvsprintf.h b/Massai/cpp/MassaiDLL/static/inc/mvsprintf.h
new file mode 100644
index 00000000..ac24d892
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/static/inc/mvsprintf.h
@@ -0,0 +1,25 @@
+//---------------------------------------------------------------------------
+//
+//  file:       mvsprintf.h
+//
+//  purpose:    function prototypes
+//
+//  date:       14.03.2003, 12:44
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+#ifndef MVSPRINTF_H
+#define MVSPRINTF_H
+
+int m_vsnprintf(char *buf, size_t size, const char *fmt, va_list args);
+int m_vsprintf(char *buf, const char *fmt, va_list args);
+
+int m_snprintf(char * buf, size_t size, const char *fmt, ...);
+int m_sprintf(char * buf, const char *fmt, ...);
+
+int m_vsscanf(const char * buf, const char * fmt, va_list args);
+int m_sscanf(const char * buf, const char * fmt, ...);
+
+#endif // MVSPRINTF_H
\ No newline at end of file
diff --git a/Massai/cpp/MassaiDLL/static/res/FileVersion.rc b/Massai/cpp/MassaiDLL/static/res/FileVersion.rc
new file mode 100644
index 00000000..499889d1
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/static/res/FileVersion.rc
@@ -0,0 +1,108 @@
+//Microsoft Developer Studio generated resource script.
+//
+// #include "resource.h"
+#include "Global_def.h"
+#include "local_def.h"
+
+#define APSTUDIO_READONLY_SYMBOLS
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 2 resource.
+//
+#include "afxres.h"
+
+/////////////////////////////////////////////////////////////////////////////
+#undef APSTUDIO_READONLY_SYMBOLS
+
+/////////////////////////////////////////////////////////////////////////////
+// German (Germany) resources
+
+#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_DEU)
+#ifdef _WIN32
+LANGUAGE LANG_GERMAN, SUBLANG_GERMAN
+#pragma code_page(1252)
+#endif //_WIN32
+
+#ifndef _MAC
+/////////////////////////////////////////////////////////////////////////////
+//
+// Version
+//
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION FILE_VER_BIN
+ PRODUCTVERSION PRODUCT_VER_BIN
+ FILEFLAGSMASK 0x3fL
+#ifdef _DEBUG
+ FILEFLAGS 0x1L
+#else
+ FILEFLAGS 0x0L
+#endif
+ FILEOS 0x40004L
+ FILETYPE 0x2L
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040704b0"
+        BEGIN
+            VALUE COMPANY
+			VALUE FILEDESCRIPTION
+			VALUE FILE_VER_STR
+			VALUE INTERNALNAME
+			VALUE COPYRIGHT
+			VALUE LEGALTRADEMARKS
+			VALUE ORIGINALFILENAME
+			VALUE PRODUCT
+            VALUE PRODUCT_VER_STR 
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x407, 1200
+    END
+END
+
+#endif    // !_MAC
+
+
+#ifdef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// TEXTINCLUDE
+//
+
+1 TEXTINCLUDE DISCARDABLE
+BEGIN
+    "resource.h\0"
+END
+
+2 TEXTINCLUDE DISCARDABLE
+BEGIN
+    "#include ""afxres.h""\r\n"
+    "\0"
+END
+
+3 TEXTINCLUDE DISCARDABLE
+BEGIN
+    "\r\n"
+    "\0"
+END
+
+#endif    // APSTUDIO_INVOKED
+
+#endif    // German (Germany) resources
+/////////////////////////////////////////////////////////////////////////////
+
+
+
+#ifndef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 3 resource.
+//
+
+
+/////////////////////////////////////////////////////////////////////////////
+#endif    // not APSTUDIO_INVOKED
+
diff --git a/Massai/cpp/MassaiDLL/static/src/NT_MXSEM.cpp b/Massai/cpp/MassaiDLL/static/src/NT_MXSEM.cpp
new file mode 100644
index 00000000..9201cf59
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/static/src/NT_MXSEM.cpp
@@ -0,0 +1,67 @@
+// -------------------------------------------------------------------
+//
+// NT_MXSEM.CPP
+//
+// This module contains os dependent api functions
+//
+// Dr. Materna GmbH - JK - 1997
+//
+// -------------------------------------------------------------------
+
+#include "mutex.hpp"
+
+#include "windows.h"
+
+#define PRIVATE static
+
+PRIVATE int nextid = 0;
+
+mutexSemaphore::mutexSemaphore()
+{
+   iID = ++nextid;
+   hMS = (unsigned long)CreateMutex( 0, 0, 0 );
+}
+
+mutexSemaphore::mutexSemaphore(const char* const szName)
+{
+   iID = ++nextid;
+   hMS = (unsigned long)CreateMutex( 0, 0, szName);
+}
+
+
+mutexSemaphore::~mutexSemaphore()
+{
+   CloseHandle( (HANDLE)hMS );
+}
+
+/* rb141197
+** result:
+** 0 on success ( erg == WAIT_OBJECT_0)
+*/
+int mutexSemaphore::request()
+{
+   long erg = WaitForSingleObject( (HANDLE)hMS, INFINITE );
+   ++iOwn;
+   return (erg != WAIT_OBJECT_0)? 0: erg;
+}
+
+int mutexSemaphore::request(long Time)
+{
+   long erg = WaitForSingleObject( (HANDLE)hMS, Time );
+   ++iOwn;
+   return (erg != WAIT_OBJECT_0)? 0: erg;
+}
+
+
+/* rb141197
+** result:
+** 0 on success ( release returns != 0)
+*/
+int mutexSemaphore::release()
+{
+   --iOwn;
+   if(ReleaseMutex( (HANDLE)hMS ) == 0)
+     return GetLastError();
+   return (0);
+}
+
diff --git a/Massai/cpp/MassaiDLL/static/src/base_os.cpp b/Massai/cpp/MassaiDLL/static/src/base_os.cpp
new file mode 100644
index 00000000..bc21f801
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/static/src/base_os.cpp
@@ -0,0 +1,1177 @@
+/******************************************************************************
+
+ FILE:      base_os.cpp
+
+ PURPOSE:   OS system definitions
+
+ DATE:      01/10/97 - 23:00:00
+
+ AUTHOR:    Dr. Materna GmbH   (MaK)
+
+******************************************************************************/
+
+#include <winsock2.h>
+#include <signal.h>
+#include <stdio.h>
+#include <process.h>
+
+#include "base_os.h"
+
+/* shared memory block *******************************************************/
+
+#define SHMEMSIZE   240L * 1024L
+#define MAX_SOCKETS 256
+
+extern HMTX socketSem(VOID);
+
+BYTE abSharedMem[SHMEMSIZE];
+int  aSockets   [MAX_SOCKETS];
+BOOL bSocketReset = TRUE;
+int  iLock = 0;
+
+#define SHOWARRAY \
+{ \
+int n; \
+ \
+    for(n = 0; n < MAX_SOCKETS; n++) \
+      printf("%04d ",aSockets[n]); \
+ \
+    printf("\n"); \
+}
+
+APIRET OS_Open               (PSZ     FileName,
+                              PHFILE  FileHandle,
+                              PULONG  ActionTaken,
+                              ULONG   FileSize,
+                              ULONG   FileAttribute,
+                              ULONG   OpenFlag,
+                              ULONG   OpenMode,
+                              PEAOP2  EABuf)
+{
+HANDLE hFile;
+
+  if(EABuf)
+    memset(EABuf,0,sizeof(EAOP2));
+
+  hFile = CreateFile((LPCTSTR)FileName,
+                     GENERIC_WRITE | GENERIC_READ,
+                     FILE_SHARE_READ | FILE_SHARE_WRITE,
+                     (LPSECURITY_ATTRIBUTES)NULL,
+                     OPEN_ALWAYS, // | CREATE_NEW,
+                     FILE_ATTRIBUTE_ARCHIVE,
+                     (HANDLE)NULL);
+
+  *ActionTaken=(ULONG)NULL;
+  *FileHandle=(HFILE)hFile;
+
+  if(hFile)
+    return(0);
+  else
+    return(GetLastError());
+}
+
+APIRET OS_Close              (HFILE   FileHandle)
+{
+  if(!CloseHandle((HANDLE)FileHandle))
+    return(GetLastError());
+  else
+    return(0);
+}
+
+APIRET OS_Write              (HFILE   FileHandle,
+                              PVOID   BufferArea,
+                              ULONG   BufferLength,
+                              PULONG  BytesWritten)
+{
+static DWORD dwBytesWritten;
+
+  if (WriteFile((HANDLE)  FileHandle,
+                (LPCVOID) BufferArea,
+                (DWORD)   BufferLength,
+                &dwBytesWritten,
+                (LPOVERLAPPED)NULL))
+  {
+    *BytesWritten = (ULONG)dwBytesWritten;
+    return(0);
+  }
+  else
+    return(GetLastError());
+}
+
+APIRET OS_Read               (HFILE   FileHandle,
+                              PVOID   BufferArea,
+                              ULONG   BufferLength,
+                              PULONG  BytesRead)
+{
+static DWORD dwBytesRead;
+
+  if(ReadFile((HANDLE) FileHandle,
+              (LPVOID) BufferArea,
+              (DWORD)  BufferLength,
+              &dwBytesRead,
+              (LPOVERLAPPED)NULL))
+  {
+    *BytesRead = (ULONG)dwBytesRead;
+
+    if(!dwBytesRead)
+      return(-1);
+    else
+      return(0);
+  }
+  else
+    return(GetLastError());
+}
+
+APIRET OS_Delete             (PSZ     FileName)
+{
+  if(DeleteFile((LPCTSTR)FileName))
+    return(0);
+  else
+    return(GetLastError());
+}
+
+APIRET OS_Move               (PSZ     OldPathName,
+                              PSZ     NewPathName)
+{
+  if(MoveFile((LPCTSTR)OldPathName,(LPCTSTR)NewPathName))
+    return(0);
+  else
+    return(GetLastError());
+}
+
+APIRET OS_MkDir              (PSZ     szName,
+                              ULONG   ulFlag)
+{
+SECURITY_ATTRIBUTES sec_attr;
+
+  sec_attr.nLength=sizeof(SECURITY_ATTRIBUTES);
+  sec_attr.lpSecurityDescriptor=NULL;
+  sec_attr.bInheritHandle=FALSE;
+
+  if(CreateDirectory((LPCTSTR)szName,&sec_attr))
+    return(0);
+  else
+    return(GetLastError());
+}
+
+APIRET OS_SetFilePtr         (HFILE   FileHandle,
+                              LONG    Distance,
+                              ULONG   MoveType,
+                              PULONG  NewPointer)
+{
+DWORD dwFileSize;
+
+  dwFileSize = SetFilePointer((HANDLE)FileHandle,
+                              Distance,
+                              (PLONG)NULL,
+                              MoveType);
+
+  if(dwFileSize==0xFFFFFFFF)
+  {
+    *NewPointer=(ULONG)NULL;
+    return(GetLastError());
+  }
+  else
+  {
+    *NewPointer=(ULONG)dwFileSize;
+
+    return(0);
+  }
+}
+
+APIRET OS_DevIOCtl           (HFILE   DevHandle,
+                              ULONG   Category,
+                              ULONG   Function,
+                              PVOID   ParmList,
+                              ULONG   ParmLengthMax,
+                              PULONG  ParmLengthInOut,
+                              PVOID   DataArea,
+                              ULONG   DataLengthMax,
+                              PULONG  DataLengthInOut)
+{
+  return 0;
+}
+
+APIRET OS_DupHandle          (HFILE   OldFileHandle,
+                              PHFILE  NewFileHandle)
+{
+// not needed ???
+// see NT.DuplicateHandle
+  return 0;
+}
+
+APIRET OS_Error              (ULONG   Flags)
+{
+  return 0;
+}
+
+APIRET OS_Exit               (ULONG   ActionCode,
+                              ULONG   ResultCode)
+{
+  switch(ActionCode)
+  {
+  case EXIT_PROCESS:
+    ExitProcess((UINT)ResultCode);
+    break;
+  case EXIT_THREAD:
+    //ExitThread((UINT)ResultCode);
+    _endthread();
+    break;
+  }
+  return 0;
+}
+
+APIRET OS_ExitList           (ULONG       FunctionOrder,
+                              PFNEXITLIST RtnAddress)
+{
+  return 0;
+}
+
+APIRET OS_GetDateTime        (PDATETIME   pDateTime)
+{
+static SYSTEMTIME systemtime;
+
+  GetLocalTime(&systemtime);
+
+  pDateTime->hours      = (UCHAR) systemtime.wHour;
+  pDateTime->minutes    = (UCHAR) systemtime.wMinute;
+  pDateTime->seconds    = (UCHAR) systemtime.wSecond;
+  pDateTime->hundredths = (UCHAR) (systemtime.wMilliseconds/10);
+  pDateTime->day        = (UCHAR) systemtime.wDay;
+  pDateTime->month      = (UCHAR) systemtime.wMonth;
+  pDateTime->year       = (USHORT)systemtime.wYear;
+  pDateTime->timezone   = (SHORT) 0;
+  pDateTime->weekday    = (UCHAR) systemtime.wDayOfWeek;
+
+  return 0;
+}
+
+APIRET OS_SetDateTime        (PDATETIME   pDateTime)
+{
+static SYSTEMTIME systemtime;
+
+  memset(&systemtime,0,sizeof(SYSTEMTIME));
+
+  systemtime.wHour              = (WORD) pDateTime->hours;
+  systemtime.wMinute            = (WORD) pDateTime->minutes;
+  systemtime.wSecond            = (WORD) pDateTime->seconds;
+  systemtime.wMilliseconds      = (WORD) pDateTime->hundredths*10;
+  systemtime.wDay               = (WORD) pDateTime->day;
+  systemtime.wMonth             = (WORD) pDateTime->month;
+  systemtime.wYear              = (WORD) pDateTime->year;
+  systemtime.wDayOfWeek         = (WORD) pDateTime->weekday;
+
+  SetLocalTime(&systemtime);
+
+  return 0;
+}
+
+APIRET OS_GetInfoBlocks      (PTIB *  ptib,
+                              PPIB *  ppib)
+{
+static pib_s pib;
+
+  pib.pib_ulpid = GetCurrentProcessId();
+
+  *ppib = &pib;
+  return 0;
+}
+
+// semaphor functions ---------------------------------------------------------
+
+APIRET OS_CreateMutexSem     (PSZ     Name,
+                              PHMTX   phmtx,
+                              ULONG   flAttr,
+                              BOOL    fState)
+{
+CHAR szName[MAX_PATH];
+CHAR *szTmp;
+
+SECURITY_ATTRIBUTES sec_attr;
+
+  sec_attr.nLength=sizeof(SECURITY_ATTRIBUTES);
+  sec_attr.lpSecurityDescriptor=NULL;
+  sec_attr.bInheritHandle=TRUE;
+
+  if(Name)
+  {
+    if((szTmp=strrchr(Name,'\\'))!=(CHAR*)NULL)
+      strcpy(szName,(szTmp +1));
+    else
+      strcpy(szName,Name);
+  }
+  else
+    memset((VOID*)szName,0,MAX_PATH);
+
+  *phmtx = (HMTX)CreateMutex((LPSECURITY_ATTRIBUTES)&sec_attr,
+                            fState,
+                            (LPCTSTR)szName);
+
+  if(*phmtx)
+    return (APIRET)0;
+  else
+    return(GetLastError());
+}
+
+APIRET OS_CloseMutexSem      (HMTX    hmtx)
+{
+APIRET rc = 0;
+
+  try
+  {
+    CloseHandle((HANDLE)hmtx);
+  }
+  catch(...)
+  {
+    rc = GetLastError();
+  }
+
+  return(rc);
+}
+
+APIRET OS_RequestMutexSem    (HMTX    hmtx,
+                              ULONG   Timeout)
+{
+DWORD dwRc;
+
+  dwRc = WaitForSingleObject((HANDLE)hmtx,(DWORD)Timeout);
+
+  switch(dwRc)
+  {
+  case WAIT_FAILED:
+    return 1;
+  case WAIT_ABANDONED:
+  case WAIT_OBJECT_0:
+    return 0;
+  case WAIT_TIMEOUT:
+    return 1;
+  default:
+    return 1;
+  }
+}
+
+APIRET OS_OpenMutexSem       (PSZ     Name,
+                              PHMTX   phmtx)
+{
+HANDLE hmtx;
+CHAR szName[MAX_PATH];
+CHAR *szTmp;
+
+  if((szTmp=strrchr(Name,'\\'))!=(CHAR*)NULL)
+    strcpy(szName,(szTmp + 1));
+  else
+    strcpy(szName,Name);
+
+  hmtx=OpenMutex(SYNCHRONIZE,
+                 TRUE,
+                 (LPCTSTR)szName);
+
+
+  if(hmtx)
+  {
+    *phmtx = hmtx;
+    return(0);
+  }
+  else
+    return((APIRET) GetLastError());
+}
+
+APIRET OS_ReleaseMutexSem    (HMTX    hmtx)
+{
+  return (APIRET)ReleaseMutex((HANDLE)hmtx);
+}
+
+APIRET MASSAI_DLLEXPORT OS_CreateEventSem     (PSZ    Name,
+                                      PHEV   pHev,
+                                      ULONG  ulFlags,
+                                      BOOL bState)
+{
+CHAR szName[MAX_PATH];
+CHAR *szTmp;
+
+  if(Name && Name[0])
+  {
+    if((szTmp=strrchr(Name,'\\'))!=(CHAR*)NULL)
+      strcpy(szName,(szTmp + 1));
+    else
+      strcpy(szName,Name);
+
+    *pHev=(HEV)CreateEvent((LPSECURITY_ATTRIBUTES)NULL,
+                           TRUE,
+                           bState,
+                           (LPCTSTR)szName);
+  }
+  else
+  {
+    *pHev=(HEV)CreateEvent((LPSECURITY_ATTRIBUTES)NULL,
+                           TRUE,
+                           bState,
+                           (LPCTSTR)Name);
+  }
+
+  if(*pHev)
+    return (APIRET)0;
+  else
+    return(GetLastError());
+}
+
+APIRET MASSAI_DLLEXPORT OS_OpenEventSem       (PSZ    Name,
+                                      PHEV   pHev)
+{
+CHAR szName[MAX_PATH];
+CHAR *szTmp;
+
+  if(Name && Name[0])
+  {
+    if((szTmp=strrchr(Name,'\\'))!=(CHAR*)NULL)
+      strcpy(szName,(szTmp + 1));
+    else
+      strcpy(szName,Name);
+
+    *pHev=(HEV)OpenEvent(EVENT_ALL_ACCESS,
+                         FALSE,
+                         (LPCTSTR)szName);
+  } else
+  {
+    *pHev=(HEV)OpenEvent(EVENT_ALL_ACCESS,
+                         FALSE,
+                         (LPCTSTR)Name);
+  }
+  if(*pHev)
+    return (APIRET)0;
+  else
+    return(GetLastError());
+}
+
+APIRET MASSAI_DLLEXPORT OS_CloseEventSem      (HEV    hev)
+{
+APIRET rc = 0;
+
+  try
+  {
+    CloseHandle((HANDLE)hev);
+  }
+  catch(...)
+  {
+    rc = GetLastError();
+  }
+
+  return(rc);
+}
+
+APIRET MASSAI_DLLEXPORT OS_ResetEventSem      (HEV    hev,
+                                      PULONG pulPostCount)
+{
+  *pulPostCount = 0;
+  return(APIRET)(ResetEvent((HANDLE)hev)!=NULL);
+}
+
+APIRET MASSAI_DLLEXPORT OS_PostEventSem       (HEV    hev)
+{
+  return(APIRET)(SetEvent((HANDLE)hev)!=NULL);
+}
+
+APIRET MASSAI_DLLEXPORT OS_WaitEventSem       (HEV    hev,
+                                      ULONG  ulTimeout)
+{
+DWORD dwRc;
+
+  dwRc = WaitForSingleObject((HANDLE)hev,(DWORD)ulTimeout);
+  switch(dwRc)
+  {
+  case WAIT_FAILED:
+    return 1;
+  case WAIT_ABANDONED:
+  case WAIT_OBJECT_0:
+    return 0;
+  case WAIT_TIMEOUT:
+    return 1;
+  default:
+    return 1;
+  }
+}
+
+APIRET MASSAI_DLLEXPORT OS_QeueryEventSem     (HEV    hev,
+                                      PULONG pulPostCount)
+{
+
+DWORD dwRc;
+
+  dwRc = WaitForSingleObject((HANDLE)hev,(DWORD)NULL);
+  switch(dwRc)
+  {
+  case WAIT_FAILED:
+    *pulPostCount = 0;
+    break;
+  case WAIT_ABANDONED:
+  case WAIT_OBJECT_0:
+    *pulPostCount = 1;
+    break;
+  case WAIT_TIMEOUT:
+    *pulPostCount = 0;
+    break;
+  default:
+    *pulPostCount = 0;
+    break;
+  }
+  return (APIRET)!*pulPostCount;
+}
+
+
+// shared memory functions ----------------------------------------------------
+#if 0
+APIRET OS_AllocSharedMem     (PPVOID  ppBaseAddress,
+                              PSZ     pszName,
+                              ULONG   cbObjectSize,
+                              ULONG   Flags)
+{
+  *ppBaseAddress = (VOID*)abSharedMem;
+  eg_sm_init((CHAR *)abSharedMem,(CHAR *)(abSharedMem + SHMEMSIZE));
+  return 0;
+}
+
+APIRET OS_FreeMem            (PVOID   baseAddress)
+{
+  // do nothing, memory block is freed when unloading ssdbase.dll
+  return 0;
+}
+
+APIRET OS_GetNamedSharedMem  (PPVOID  ppBaseAddress,
+                              PSZ     ASharedMemName,
+                              ULONG   AttributeFlags)
+{
+  *ppBaseAddress = (VOID*)abSharedMem;
+  return 0;
+}
+
+APIRET OS_SubSetMem          (PVOID   Offset,
+                              ULONG   Flags,
+                              ULONG   Size)
+{
+  return 0;
+}
+
+APIRET OS_SubUnsetMem        (PVOID   Offset)
+{
+  return 0;
+}
+
+APIRET OS_SubAllocMem        (PVOID   Offset,
+                              PPVOID  ppBlockOffset,
+                              ULONG   ulSize)
+{
+  *ppBlockOffset = eg_malloc(ulSize);
+  return 0;
+}
+
+APIRET OS_SubFreeMem         (PVOID   Offset,
+                              PVOID   pBlockOffset,
+                              ULONG   Size)
+{
+  eg_free(pBlockOffset);
+  return 0;
+}
+#endif
+
+// thread & process functions -------------------------------------------------
+
+APIRET OS_CreateThread       (PTID      ThreadID,
+                              PFNTHREAD ThreadAddr,
+                              ULONG     ThreadArg,
+                              ULONG     ThreadFlags,
+                              ULONG     StackSize)
+{
+DWORD dwCreationFlag = 0;
+
+#if 0
+
+HANDLE   hTID;
+
+// don't use windows create thread function because of
+// memory leackage
+//
+  hTID = CreateThread((LPSECURITY_ATTRIBUTES)NULL,
+                     (DWORD) StackSize,
+                     (LPTHREAD_START_ROUTINE) ThreadAddr,
+                     (LPVOID) ThreadArg,
+                     (DWORD)ThreadFlags,
+                     &dwThreadID);
+
+  // The handle returned by CreateThread is converted into
+  // TID in OS/2 notation because the handle is needed
+  // for killing the thread!
+
+  *ThreadID = (TID)hTID;
+
+  return (APIRET)(hTID == (HANDLE)-1);
+
+#else
+
+int   hTID;
+
+  hTID = _beginthread( (PFNTHREAD_ROUTINE) ThreadAddr,
+                        StackSize,
+                        (VOID *) ThreadArg);
+
+  // The handle returned by CreateThread is converted into
+  // TID in OS/2 notation because the handle is needed
+  // for killing the thread!
+
+  *ThreadID = (TID)hTID;
+
+  return (APIRET)(hTID == -1);
+
+#endif
+
+}
+
+APIRET OS_KillThread         (TID     ThreadID)
+{
+BOOL fSuccess;
+
+  if(SuspendThread((HANDLE)ThreadID) == -1)
+  {
+    return (GetLastError());
+  }
+
+  fSuccess = TerminateThread((HANDLE)ThreadID,(DWORD)NULL);
+  CloseHandle((HANDLE)ThreadID);
+  if(fSuccess)
+    return 0;
+  else
+    return (GetLastError());
+}
+
+APIRET MASSAI_DLLEXPORT OS_ResumeThread(TID ThreadID)
+{
+ULONG ulRc;
+  ulRc = ResumeThread((HANDLE)ThreadID);
+  if(ulRc == 0xffffffff)
+    return (GetLastError());
+  else
+    return 0;
+}
+
+APIRET MASSAI_DLLEXPORT OS_SuspendThread(TID ThreadID)
+{
+ULONG ulRc;
+  ulRc = SuspendThread((HANDLE)ThreadID);
+  if(ulRc == 0xffffffff)
+    return (GetLastError());
+  else
+    return 0;
+}
+
+APIRET OS_Sleep              (ULONG   TimeInterval)
+{
+  Sleep((DWORD)TimeInterval);
+  return (APIRET)NULL;
+}
+
+APIRET OS_SetPriority        (ULONG   Scope,
+                              ULONG   PriorityClass,
+                              LONG    PriorityDelta,
+                              ULONG   ID)
+{
+BOOL fSuccess;
+
+  switch(PriorityDelta)
+  {
+  case PRTYC_TIMECRITICAL:
+  case THREAD_PRIORITY_TIME_CRITICAL:
+
+       fSuccess = SetThreadPriority((HANDLE) ID, THREAD_PRIORITY_TIME_CRITICAL);
+       break;
+
+  default:
+
+       fSuccess = SetThreadPriority((HANDLE) ID, THREAD_PRIORITY_NORMAL);
+       break;
+  }
+
+  if(fSuccess)
+    return(0);
+  else
+    return(GetLastError()) ;
+}
+
+APIRET MASSAI_DLLEXPORT OS_WaitThread         (PTID  pTid,
+                                      ULONG ulTimeOut)
+{
+DWORD dwRc;
+
+  dwRc = WaitForSingleObject((HANDLE)*pTid,(DWORD)ulTimeOut);
+  switch(dwRc)
+  {
+  case WAIT_FAILED:
+    return 1;
+  case WAIT_ABANDONED:
+  case WAIT_OBJECT_0:
+    return 0;
+  case WAIT_TIMEOUT:
+    return 1;
+  default:
+    return 1;
+  }
+}
+
+APIRET OS_ExecWait(PSTARTDATA StartData,int iShow)
+{
+STARTUPINFO         si;
+PROCESS_INFORMATION pi;
+BOOL                rc;
+CHAR                szPgmName[512];
+
+    memset(&si,0,sizeof(STARTUPINFO));
+
+    si.cb = sizeof(STARTUPINFO);
+    si.dwFlags = STARTF_USESHOWWINDOW;
+
+    switch(iShow)
+    {
+    case PROCESS_SHOW:      si.wShowWindow = SW_SHOW;          break;
+    case PROCESS_MINIMIZED: si.wShowWindow = SW_SHOWMINIMIZED; break;
+    default:                si.wShowWindow = SW_HIDE;          break;
+    }
+
+    strcpy(szPgmName,StartData->PgmName);
+    strcat(szPgmName," ");
+    strcat(szPgmName,(CHAR*)StartData->PgmInputs);
+
+    rc = CreateProcess((LPCTSTR)NULL,                  //
+                       (LPTSTR)szPgmName,              //
+                       (LPSECURITY_ATTRIBUTES)NULL,    // use default
+                       (LPSECURITY_ATTRIBUTES)NULL,    // use default
+                       FALSE,                          // don`t inherit handles
+                       0,                              // creation flags
+                       (LPVOID)NULL,                   // use parents env.
+                       (LPCTSTR)NULL,                  // use parents rootdir
+                       &si,
+                       &pi);
+    if(!rc)
+      return(GetLastError());
+    else
+    {
+      // wait for the process to terminate
+
+      WaitForSingleObject(pi.hProcess,INFINITE);
+
+      CloseHandle(pi.hThread);
+      CloseHandle(pi.hProcess);
+
+      return(0);
+    }
+}
+
+
+APIRET OS_StartSession       (PSTARTDATA StartData,
+                              PULONG     SessID,
+                              PPID       PID,
+                              HANDLE    *phProcess,
+                              int        iShow)
+{
+STARTUPINFO         si;
+PROCESS_INFORMATION pi;
+BOOL                rc;
+CHAR                szPgmName[512];
+
+    memset(&si,0,sizeof(STARTUPINFO));
+
+    si.cb      = sizeof(STARTUPINFO);
+    si.dwFlags = STARTF_USESHOWWINDOW;
+
+    switch(iShow)
+    {
+    case PROCESS_SHOW:      si.wShowWindow = SW_SHOW;          break;
+    case PROCESS_MINIMIZED: si.wShowWindow = SW_SHOWMINIMIZED; break;
+    default:                si.wShowWindow = SW_HIDE;          break;
+    }
+
+    strcpy(szPgmName,StartData->PgmName);
+    strcat(szPgmName," ");
+    strcat(szPgmName,(CHAR*)StartData->PgmInputs);
+
+    rc=CreateProcess((LPCTSTR)NULL,                  //
+                     (LPTSTR)szPgmName,              //
+                     (LPSECURITY_ATTRIBUTES)NULL,    // use default
+                     (LPSECURITY_ATTRIBUTES)NULL,    // use default
+                     FALSE,                          // don`t inherit handles
+                     0,                              // creation flags
+                     (LPVOID)NULL,                   // use parents env.
+                     (LPCTSTR)NULL,                  // use parents rootdir
+                     &si,
+                     &pi);
+
+    *SessID = *PID = pi.dwProcessId;
+
+    *phProcess = pi.hProcess;
+
+    return (APIRET)((*SessID==0)||(rc==FALSE));
+}
+
+APIRET OS_StopSession (ULONG TargetOption, HANDLE hProcess)
+{
+APIRET rc;
+
+  rc = (APIRET)(TerminateProcess(hProcess,(UINT)NULL) == FALSE);
+
+  CloseHandle(hProcess);
+
+  return rc;
+}
+
+// pipe & named pipe functions ------------------------------------------------
+
+APIRET OS_CreatePipe         (PHFILE  ReadHandle,
+                              PHFILE  WriteHandle,
+                              ULONG   PipeSize)
+{
+  return 0;
+}
+
+APIRET OS_CreateNPipe        (PSZ     FileName,
+                              PHPIPE  PipeHandle,
+                              ULONG   OpenMode,
+                              ULONG   PipeMode,
+                              ULONG   OutBufSize,
+                              ULONG   InBufSize,
+                              ULONG   TimeOut)
+{
+  return 0;
+}
+
+APIRET OS_ConnectNPipe       (HPIPE   Handle)
+{
+  return 0;
+}
+
+APIRET OS_DisConnectNPipe    (HPIPE   Handle)
+{
+  return 0;
+}
+
+// miscallaneous functions ----------------------------------------------------
+
+APIRET OS_FreeModule (HMODULE hmod)
+{
+   if(FreeLibrary(hmod))
+   {
+     CloseHandle((HANDLE)hmod);
+     return(0);
+   }
+   else
+   {
+     CloseHandle((HANDLE)hmod);
+     return(GetLastError());
+   }
+}
+
+APIRET OS_LoadModule (PSZ pszName,ULONG cbName,PSZ pszModName,PHMODULE phmod)
+{
+HINSTANCE hmod;
+
+   if((hmod = LoadLibrary((LPCTSTR) pszModName)) == NULL)
+   {
+     *phmod = (HMODULE) NULL;
+     return(GetLastError());
+   }
+   else
+   {
+     *phmod = (HMODULE) hmod;
+     return(0);
+   }
+
+}
+
+APIRET MASSAI_DLLEXPORT OS_LoadString(HMODULE hmod,long resourceId,PSZ pszBuffer,int iBufferSize)
+{
+APIRET rc;
+
+    rc = LoadString((HINSTANCE)hmod,resourceId,pszBuffer,iBufferSize);
+
+    if(!rc)
+      return(GetLastError());
+    else
+      return(0);
+}
+
+APIRET OS_QueryModuleHandle  (PSZ      ModName,
+                              PHMODULE pModHandle)
+{
+  *pModHandle = GetModuleHandle((LPCTSTR)ModName);
+
+  return (APIRET)(*pModHandle==(HMODULE)0);
+}
+
+APIRET OS_QueryModuleName    (HMODULE ModHandle,
+                              ULONG   BufferLength,
+                              PCHAR   NameBuffer)
+{
+DWORD dwLength;
+
+  dwLength = GetModuleFileName(ModHandle,(LPTSTR)NameBuffer,(DWORD)BufferLength);
+  return (APIRET)(dwLength == 0);
+}
+
+APIRET OS_QueryProcAddr(HMODULE hmod,ULONG ordinal,PSZ pszName,PFN* ppfn)
+{
+FARPROC pfn = NULL;
+
+   if((pfn = GetProcAddress(hmod,(LPCSTR) ordinal)) == NULL)
+     return(GetLastError());
+   else
+   {
+     *ppfn = pfn;
+     return(0);
+   }
+}
+
+APIRET OS_ScanEnv            (PCSZ    EnvVarName,
+                              PCSZ *  ResultPointer)
+{
+static CHAR  szEnvString[4096];
+DWORD dwCnt;
+
+  dwCnt = GetEnvironmentVariable((LPCTSTR)EnvVarName,
+                                 (LPTSTR)szEnvString,
+                                 sizeof(szEnvString));
+
+  *ResultPointer = szEnvString;
+
+  if(dwCnt)
+    return 0;
+  else
+    return 1;
+}
+
+APIRET OS_Beep               (ULONG   Frequency,
+                              ULONG   Duration)
+{
+  return (!Beep((DWORD)Frequency,(DWORD)Duration));
+}
+
+
+int sock_init()
+{
+int     rc;
+int     s;
+WSADATA wsaData;
+WORD    wVersionRequested = MAKEWORD(1,1);
+
+   if((s = socket(AF_INET,SOCK_STREAM, 0)) < 0)
+   {
+     if(WSAGetLastError() == WSANOTINITIALISED)
+     {
+       rc = WSAStartup(wVersionRequested,&wsaData);
+
+       rc == 0 ? rc = 1 : rc = -1;
+     }
+   }
+   else
+   {
+     rc = 0;
+
+     closesocket(s);
+   }
+
+   return(rc);
+}
+
+int ioctl(int s, int cmd, char *pData, int lendata)
+{
+  return ioctlsocket(s,cmd,(ULONG *)pData);
+}
+
+int newSocket (int domain, int type, int protocol)
+{
+#if defined (SADDAM)
+
+int  i;
+int  ns = 0;
+int  iFirstZero;
+BOOL fFound;
+
+    //printf("wait sem...\n");
+
+    OS_RequestMutexSem(socketSem(),-1L);
+
+    //printf("wait sem done.\n");
+
+    if(bSocketReset)
+    {
+      memset(aSockets,0,sizeof(aSockets));
+      bSocketReset = FALSE;
+    }
+
+    while(!ns)
+    {
+      ns = socket(domain,type,protocol);
+
+      if(ns < 0)
+      {
+        // break while loop on error
+
+        break;
+      }
+      else
+      {
+        // socket seems to be ok !!
+
+        //printf("new socket [%d]\n",ns);
+
+        for(i = 0, iFirstZero = 0, fFound = FALSE;
+            i < MAX_SOCKETS && !fFound;
+            i++                                   )
+        {
+          if(i == 0 && !aSockets[0])
+          {
+            aSockets[0] = ns;
+
+            //SHOWARRAY;
+
+            OS_ReleaseMutexSem(socketSem());
+
+            //printf("return socket[0]: %d\n",ns);
+
+            return(ns);
+          }
+
+          if(i && !iFirstZero && !aSockets[i])
+          {
+            // save index to first zero value !!
+
+            iFirstZero = i;
+          }
+
+          // socket already in use ??
+
+          fFound = (aSockets[i] == ns);
+        }
+
+        if(!fFound && i <= MAX_SOCKETS)
+        {
+          // save this socket !!
+
+          aSockets[iFirstZero] = ns;
+        }
+        else if(fFound && i <= MAX_SOCKETS)
+        {
+          // do nothing on a currently used socket !! -> get new one.
+
+          //printf("socket [%d] already in use.\n",ns);
+
+          ns = 0;
+        }
+        else
+        {
+          // close this socket and leave
+
+          closesocket(ns);
+
+          OS_ReleaseMutexSem(socketSem());
+
+          //printf("return socket[0]: %d\n",-1);
+
+          return(-1);
+        }
+      }
+    }
+
+    //SHOWARRAY;
+
+    OS_ReleaseMutexSem(socketSem());
+
+    //printf("return socket: %d\n",ns);
+
+    return(ns);
+
+#else
+
+   return(socket(domain,type,protocol));
+
+#endif // SADDAM
+}
+
+int soclose (int socket)
+{
+#if defined (SADDAM)
+
+int  i;
+int  rc;
+BOOL fFound;
+
+    OS_RequestMutexSem(socketSem(),-1L);
+
+    for(i = rc = 0, fFound = FALSE; i < MAX_SOCKETS && !fFound; i++)
+    {
+      if(aSockets[i] == socket)
+      {
+        fFound = TRUE;
+
+        rc = closesocket(socket);
+
+        aSockets[i] = 0;
+
+        //printf("free socket[%d], index %d\n",socket,i);
+      }
+    }
+
+    OS_ReleaseMutexSem(socketSem());
+
+    return(rc);
+
+#else
+
+    return(closesocket(socket));
+
+#endif // SADDAM
+}
+
+static void signal_process(int iSignal)
+{
+   raise(SIGTERM);
+
+   Sleep(500);
+}
+
+APIRET OS_FlagProcess(ULONG ulProcess,int iSignal)
+{
+DWORD  dwCreationFlag = 0;
+DWORD  dwThreadID     = 0;
+ULONG  ulCnt          = 0;
+HANDLE hProcess       = 0;
+HANDLE hTID           = 0;
+
+    hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,ulProcess);
+
+    if(hProcess)
+    {
+      hTID = CreateRemoteThread(hProcess,
+                                (LPSECURITY_ATTRIBUTES)NULL,
+                                0x1000,
+                                (LPTHREAD_START_ROUTINE) signal_process,
+                                NULL,
+                                0,
+                                &dwThreadID);
+
+      CloseHandle(hTID);
+      CloseHandle(hProcess);
+
+      hProcess = 0;
+    }
+
+    while((hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,ulProcess)) != 0 && ++ulCnt < 10)
+    {
+      CloseHandle(hProcess);
+      Sleep(200);
+    }
+
+    if(hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,ulProcess))
+    {
+      CloseHandle(hProcess);
+      return(-1);
+    }
+
+    return(0);
+}
+
diff --git a/Massai/cpp/MassaiDLL/static/src/compress.cpp b/Massai/cpp/MassaiDLL/static/src/compress.cpp
new file mode 100644
index 00000000..b41b2e59
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/static/src/compress.cpp
@@ -0,0 +1,496 @@
+/***********************************************************************
+ *                           CMVC Information
+ *                           ----------------
+ * File, Component, Release   : MASSAIDLL/SRC/COMPRESS.CPP
+ * Version                    : 1.1
+ * Date of last Check-In      : 96/10/22, 16:20:57
+ * Date of last Access        : 96/12/10, 16:29:37
+ **********************************************************************/
+/****************************************************************************
+
+ FILE:      compress.c
+
+ PURPOSE:   file compressing / decompressing (LZW)
+
+ DATE:      21-Jan-1992
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+#define INCL_BASE
+
+#include "base_os.h"
+#include <stdio.h>
+#include <string.h>
+#include <malloc.h>
+
+#include "massai.hpp"
+#include "compress.h"
+
+/* private constants ********************************************************/
+
+#define LZW_FILE       "_LZWTMP_.LZW"
+#define LZW_TOKEN      "(#)extrct->"
+
+#define BITS           12
+#define HASHING_SHIFT (BITS -8)
+#define MAX_VALUE     ((1 << BITS) -1)
+#define MAX_CODE      (MAX_VALUE -1)
+
+#if (BITS == 14)
+
+  #define TABLE_SIZE   18041
+
+#endif
+
+#if (BITS == 13)
+
+  #define TABLE_SIZE    9029
+
+#endif
+
+#if (BITS <= 12)
+
+  #define TABLE_SIZE    5021
+
+#endif
+
+
+COMPRESS::COMPRESS()
+{
+ psCodeValue  = NULL;  /* pointer to code value array          */
+ pwPrefixCode = NULL;  /* pointer to prefix code array         */
+ pbAppendChar = NULL;  /* pointer to array with appended chars */
+
+ sOutputBitCnt  = 0;
+ ulOutputBitBuf = 0L;
+ sInputBitCnt   = 0;
+ ulInputBitBuf  = 0L;
+}
+
+COMPRESS::~COMPRESS()
+{
+}
+
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE USHORT InitLZW(VOID)
+
+ COMMENTS:  Initializes LZW resources.
+
+ DATE:      21-Jan-1992
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+USHORT COMPRESS::InitLZW()
+{
+SHORT i = 0;
+
+    if((psCodeValue = (SHORT *) malloc(TABLE_SIZE * sizeof(SHORT))) == NULL)
+      return(0xffff);
+
+    if((pwPrefixCode = (USHORT *) malloc(TABLE_SIZE * sizeof(USHORT))) == NULL)
+      return(0xffff);
+
+    if((pbAppendChar = (BYTE *)malloc(TABLE_SIZE * sizeof(BYTE))) == NULL)
+      return(0xffff);
+
+    /* clear string table before starting */
+
+    for(i = 0; i < TABLE_SIZE; i++)
+      *(psCodeValue +i) = -1;
+
+    for(i = 0; i < sizeof(abDecodeStack); i++)
+      abDecodeStack[i] = 0;
+
+    sOutputBitCnt  = 0;
+    sInputBitCnt   = 0;
+    ulOutputBitBuf = 0L;
+    ulInputBitBuf  = 0L;
+
+    return(0);
+
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE USHORT ReleaseLZW(VOID)
+
+ COMMENTS:  Releases LZW resources.
+
+ DATE:      21-Jan-1992
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+USHORT COMPRESS::ReleaseLZW()
+{
+
+    if(psCodeValue)
+      free(psCodeValue);
+
+    if(pwPrefixCode)
+      free(pwPrefixCode);
+
+    if(pbAppendChar)
+      free(pbAppendChar);
+
+    psCodeValue  = NULL;
+    pwPrefixCode = NULL;
+    pbAppendChar = NULL;
+
+    return(0);
+}
+
+/****************************************************************************
+
+ FUNCTION:  PUBLIC USHORT packFile(CHAR *)
+
+ COMMENTS:  Compress a file.
+
+ DATE:      21-Jan-1992
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+USHORT COMPRESS::packFile(CHAR *pszFile)
+{
+USHORT wNextCode    = 0;
+USHORT wChar        = 0;
+USHORT wStringCode  = 0;
+USHORT wIndex       = 0;
+SHORT  rc           = 0;
+SHORT  i            = 0;
+FILE  *pDstFile     = NULL;
+FILE  *pSrcFile     = NULL;
+CHAR  *pStr         = NULL;
+CHAR   szSrcFile[CHARBUF];
+CHAR   szLZWFile[CHARBUF];
+
+   if(!pszFile || !*pszFile)                     /* nothing to do !! */
+     return(0xffff);
+
+   /* get resources */
+
+   if(InitLZW())
+     return(0xffff);
+
+   /* now build destination file name from source file name */
+
+   strcpy(szSrcFile,pszFile);
+   strcpy(szLZWFile,pszFile);
+
+   if((pStr = strrchr(szLZWFile,'\\')) == NULL)
+     strcpy(szLZWFile,LZW_FILE);
+   else
+     strcpy(pStr+1,LZW_FILE);
+
+   /* open files */
+
+   if((pSrcFile = fopen(szSrcFile,"rb")) == NULL)
+     return(0xffff);
+
+   if((pDstFile = fopen(szLZWFile,"wb")) == NULL)
+     return(0xffff);
+
+   /* mark files as packed */
+
+   fwrite(LZW_TOKEN,sizeof(BYTE),strlen(LZW_TOKEN),pDstFile);
+
+   /* next available string code */
+
+   wNextCode = 256;
+
+   /* get first code */
+
+   wStringCode = getc(pSrcFile);
+
+   while((wChar = getc(pSrcFile)) != (USHORT)EOF)
+   {
+     wIndex = FindMatch(wStringCode,wChar);
+
+     if(*(psCodeValue + wIndex) != -1)
+       wStringCode = *(psCodeValue + wIndex);
+     else
+     {
+       if(wNextCode <= MAX_CODE)
+       {
+         *(psCodeValue  + wIndex) = wNextCode++;
+         *(pwPrefixCode + wIndex) = wStringCode;
+         *(pbAppendChar + wIndex) = (BYTE)wChar;
+       }
+
+       OutputCode(pDstFile,wStringCode);
+
+       wStringCode = wChar;
+     }
+   }
+
+   /* do the rest for today */
+
+   OutputCode(pDstFile,wStringCode);
+   OutputCode(pDstFile,MAX_VALUE);
+   OutputCode(pDstFile,0);
+
+   fclose(pDstFile);
+   fclose(pSrcFile);
+
+   /* delete unpacked file and rename the packed file */
+
+   rc = unlink(szSrcFile);
+   rc = rename(szLZWFile,szSrcFile);
+
+   return(ReleaseLZW());
+}
+
+/****************************************************************************
+
+ FUNCTION:  PUBLIC USHORT unpackFile(CHAR *)
+
+ COMMENTS:  Decompress a file.
+
+ DATE:      21-Jan-1992
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+USHORT COMPRESS::unpackFile(CHAR *pszFile)
+{
+USHORT  wNextCode    = 0;
+USHORT  wNewCode     = 0;
+USHORT  wOldCode     = 0;
+USHORT  wChar        = 0;
+SHORT   rc           = 0;
+FILE   *pDstFile     = NULL;
+FILE   *pSrcFile     = NULL;
+CHAR   *pStr         = NULL;
+BYTE   *pArr         = NULL;
+CHAR   szSrcFile[CHARBUF];
+CHAR   szLZWFile[CHARBUF];
+CHAR   szTmp    [CHARBUF];
+
+    if(!pszFile || !*pszFile)                     /* nothing to do !! */
+      return(0xffff);
+
+    /* get resources */
+
+    if(InitLZW())
+      return(0xffff);
+
+    /* now build destination file name from source file name */
+
+    strcpy(szSrcFile,pszFile);
+    strcpy(szLZWFile,pszFile);
+
+    if((pStr = strrchr(szLZWFile,'\\')) == NULL)
+      strcpy(szLZWFile,LZW_FILE);
+    else
+      strcpy(pStr+1,LZW_FILE);
+
+    /* open files */
+
+    if((pSrcFile = fopen(szSrcFile,"rb")) == NULL)
+      return(0xffff);
+
+    /* check if it's a packed file */
+
+    memset(szTmp,0,sizeof(szTmp));
+
+    fread(szTmp,sizeof(BYTE),strlen(LZW_TOKEN),pSrcFile);
+
+    if(strcmp(szTmp,LZW_TOKEN))
+    {
+      fclose(pSrcFile);
+      return(0xffff);
+    }
+
+    if((pDstFile = fopen(szLZWFile,"wb")) == NULL)
+      return(0xffff);
+
+    wNextCode = 256;
+
+    wChar = wOldCode = InputCode(pSrcFile);
+
+    putc(wOldCode,pDstFile);
+
+    while((wNewCode = InputCode(pSrcFile)) != MAX_VALUE)
+    {
+      if(wNewCode >= wNextCode)
+      {
+        *abDecodeStack = (BYTE)wChar;
+
+        if((pArr = (BYTE*)DecodeString(abDecodeStack+1,wOldCode)) == NULL)
+          return(0xffff);
+      }
+      else
+        if((pArr = (BYTE*)DecodeString(abDecodeStack,wNewCode)) == NULL)
+          return(0xffff);
+
+      wChar = *pArr;
+
+      while(pArr >= abDecodeStack)
+      {
+        putc(*pArr,pDstFile);
+        pArr--;
+      }
+
+      if(wNextCode <= MAX_CODE)
+      {
+         *(pwPrefixCode + wNextCode) = wOldCode;
+         *(pbAppendChar + wNextCode) = (BYTE)wChar;
+
+         wNextCode++;
+      }
+
+      wOldCode = wNewCode;
+    }
+
+    /* close all open files */
+
+    fclose(pDstFile);
+    fclose(pSrcFile);
+
+    /* delete packed file and rename the unpacked file */
+
+    rc = unlink(szSrcFile);
+    rc = rename(szLZWFile,szSrcFile);
+
+    return(ReleaseLZW());
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE SHORT FindMatch(USHORT,USHORT)
+
+ COMMENTS:  Hashing routine.
+
+ DATE:      21-Jan-1992
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+SHORT COMPRESS::FindMatch(USHORT wHashPrefix,USHORT wHashChar)
+{
+SHORT sIndex  = 0;
+SHORT sOffset = 0;
+
+    sIndex = (wHashChar << HASHING_SHIFT ^ wHashPrefix);
+
+    if(sIndex == 0)
+      sOffset = 1;
+    else
+      sOffset = TABLE_SIZE - sIndex;
+
+    while(TRUE)
+    {
+      if(*(psCodeValue + sIndex) == -1)
+        return(sIndex);
+
+      if(*(pwPrefixCode + sIndex) == wHashPrefix &&
+         *(pbAppendChar + sIndex) == (BYTE)wHashChar )
+        return(sIndex);
+
+      sIndex -= sOffset;
+
+      if(sIndex < 0)
+        sIndex += TABLE_SIZE;
+    }
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE CHAR* DecodeString(BYTE  *,USHORT)
+
+ COMMENTS:  Decode a string from the string table.
+
+ DATE:      21-Jan-1992
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+CHAR  *COMPRESS::DecodeString(BYTE *pbBuffer,USHORT wCode)
+{
+SHORT  i = 0;
+
+    while(wCode > 255)
+    {
+      *pbBuffer++ = *(pbAppendChar + wCode);
+      wCode       = *(pwPrefixCode + wCode);
+
+      /* on fatal expansion error return NULL */
+
+      if(i++ >= sizeof(abDecodeStack))
+        return(NULL);
+    }
+
+    *pbBuffer = (BYTE)wCode;
+
+    return((CHAR *)pbBuffer);
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE USHORT InputCode(FILE *)
+
+ COMMENTS:  Intput variable length of code.
+
+ DATE:      21-Jan-1992
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+USHORT COMPRESS::InputCode(FILE *pFile)
+{
+USHORT rc = 0;
+
+    while(sInputBitCnt <= 24)
+    {
+      ulInputBitBuf |= (ULONG)getc(pFile) << (24 - sInputBitCnt);
+      sInputBitCnt  += 8;
+    }
+
+    rc              = (USHORT)(ulInputBitBuf >> (32 - BITS));
+    ulInputBitBuf <<= BITS;
+    sInputBitCnt   -= BITS;
+
+    return(rc);
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE USHORT OutputCode(FILE *,USHORT)
+
+ COMMENTS:  Output variable length of code.
+
+ DATE:      21-Jan-1992
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+USHORT COMPRESS::OutputCode(FILE *pFile,USHORT wCode)
+{
+    ulOutputBitBuf |= (ULONG) wCode << (32 - BITS -sOutputBitCnt);
+
+    sOutputBitCnt += BITS;
+
+    while(sOutputBitCnt >= 8)
+    {
+       putc((BYTE)(ulOutputBitBuf >> 24),pFile);
+       ulOutputBitBuf <<= 8;
+       sOutputBitCnt   -= 8;
+    }
+
+    return(0);
+}
+
diff --git a/Massai/cpp/MassaiDLL/static/src/mConfig.cpp b/Massai/cpp/MassaiDLL/static/src/mConfig.cpp
new file mode 100644
index 00000000..83ff8491
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/static/src/mConfig.cpp
@@ -0,0 +1,1385 @@
+/****************************************************************************
+
+ FILE:      mConfig.cpp
+
+ PURPOSE:   MUTILS - configuration functions.
+
+ DATE:      01/19/96 - 14:45:41
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <io.h>
+
+#include "base_os.h"
+#include "massai.hpp"
+#include "mtrace.hpp"
+#include "mConfig.h"
+#include "globbase.hpp"
+#include "trace.hpp"
+
+
+
+static MassaiLibraryInitTerm massaiLibraryInitTerm;
+
+
+
+/* private constants *********************************************************/
+
+#define MUTILS_CFG_FILE         "\\MASSAI.CFG"
+
+#define MULTI_LINE_ITEM_SIZE     1024
+
+/* private datatypes *********************************************************/
+
+typedef struct m_cfg_item
+        {
+           struct m_cfg_item *pNext;
+           CHAR                *pszItem;
+           CHAR                *pszItemValue;
+        }
+        M_CFG_ITEM;
+
+typedef struct m_cfg_section
+        {
+           struct m_cfg_section *pNext;
+           struct m_cfg_item    *pItems;
+           CHAR                 *pszSection;
+        }
+        M_CFG_SECTION;
+
+typedef struct m_cfg_device
+        {
+           struct m_cfg_device  *pNext;
+           struct m_cfg_section *pSections;
+           CHAR                 *pszDevice;
+        }
+        M_CFG_DEVICE;
+
+/* function prototypes *******************************************************/
+
+PRIVATE VOID    cfgErr             (CHAR *pszErr);
+PRIVATE CHAR   *PureName           (CHAR *pszName);
+PRIVATE ULONG   ScanConfiguration  (FILE *pFile);
+PRIVATE ULONG   AppendDevice       (CHAR *pszDevice);
+PRIVATE ULONG   AppendSection      (CHAR *pszSection);
+PRIVATE ULONG   AppendItem         (CHAR *pszItem);
+PRIVATE ULONG   FindItem           (CHAR *pszDev,
+                                    CHAR *pszSec,
+                                    CHAR *pszItem,
+                                    CHAR *pszBuffer);
+
+/* global vars for this file  ************************************************/
+
+PRIVATE CHAR szRootPath  [CHARBUF]; // root path of SSDBASE.DLL
+PRIVATE CHAR szActualFile[CHARBUF]; // actual opened config file
+
+PRIVATE M_CFG_DEVICE  *pConfiguration = (M_CFG_DEVICE  *)NULL;
+PRIVATE M_CFG_DEVICE  *pConfigLast    = (M_CFG_DEVICE  *)NULL;
+PRIVATE M_CFG_SECTION *pSectionLast   = (M_CFG_SECTION *)NULL;
+PRIVATE M_CFG_ITEM    *pItemLast      = (M_CFG_ITEM    *)NULL;
+
+bool configRead = false;
+
+/****************************************************************************
+
+ FUNCTION:  PUBLIC VOID writeMemStatistic()
+
+ COMMENTS:  Trace memory statistics direct to file.
+
+ DATE:      10/10/96 - 09:51:20
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+PUBLIC VOID cfgErr(CHAR *pszErr)
+{
+CHAR   szFile  [CHARBUF];
+CHAR   szBuffer[CHARBUF];
+CHAR  *pStr;
+ULONG  ulAction;
+ULONG  ulWritten;
+ULONG  ulFileSize;
+HFILE  hTraceFile;
+ULONG rc;
+
+    if(rc = QueryMUtilsPath(szFile))
+      return;
+
+    if((pStr = strrchr(szFile,'\\')) != NULL)
+       *pStr = '\0';
+
+    strcat(szFile,"\\TRC\\");
+    strcat(szFile,M_UTILSDEV_FILE);
+
+    if(rc = OS_Open(szFile,
+                    &hTraceFile,
+                    &ulAction,
+                    0,
+                    FILE_NORMAL,
+                    OPEN_ACTION_OPEN_IF_EXISTS |
+                    OPEN_ACTION_CREATE_IF_NEW,
+                    OPEN_SHARE_DENYWRITE  |
+                    OPEN_ACCESS_READWRITE |
+                    OPEN_FLAGS_WRITE_THROUGH |
+                    OPEN_FLAGS_NO_CACHE      |
+                    OPEN_FLAGS_NOINHERIT,
+                    0))
+    {
+      return;
+    }
+    else
+    {
+      // append at end of file
+
+      rc = OS_SetFilePtr(hTraceFile,0L,FILE_END,&ulFileSize);
+
+      sprintf(szBuffer,"\nconfiguration error: %s\n",pszErr);
+
+      // write everything and close
+
+      rc = OS_Write(hTraceFile,szBuffer,strlen(szBuffer),&ulWritten);
+      rc = OS_Close(hTraceFile);
+    }
+
+    return;
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE ULONG FindItem (CHAR *pszDev,
+                                    CHAR *pszSec,
+                                    CHAR *pszItem,
+                                    CHAR *pszBuffer)
+
+ COMMENTS:  Searches configuration for string item.
+
+ DATE:      11/28/95 - 10:18:06
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+PRIVATE ULONG FindItem (CHAR *pszDev,CHAR *pszSec,CHAR *pszItem,CHAR *pszBuffer)
+{
+static CHAR *fn_name = "FindItem()";
+
+M_CFG_DEVICE  *pDevice;
+M_CFG_SECTION *pSection;
+M_CFG_ITEM    *pItem;
+BOOL             fDevFound;
+BOOL             fSecFound;
+BOOL             fItemFound;
+
+    if(!pConfiguration)
+    {
+      //debugWrite(HERE,"Config file not read or empty.");
+
+      /* return error if config file not read or emty */
+
+      return(ERR_CFG_NO_CONFIGURATION);
+    }
+
+    if(!pszDev || !pszSec || !pszItem || !*pszDev || !*pszSec || !*pszItem)
+    {
+      debugWrite(HERE,"Parameter error.");
+
+      /* won't work for this function */
+
+      return(ERR_CFG_PARAMETERS);
+    }
+
+    fDevFound = fSecFound = fItemFound = FALSE;
+
+    pDevice = (M_CFG_DEVICE *) pConfiguration;
+
+    while(pDevice && !fDevFound)
+    {
+      /* check device list */
+
+      fDevFound = (strcmp(pDevice->pszDevice,pszDev) == 0);
+
+      if(!fDevFound)
+        pDevice = pDevice->pNext;
+      else if(pDevice)
+      {
+        fSecFound = FALSE;
+
+        pSection = pDevice->pSections;
+
+        while(pSection && !fSecFound)
+        {
+          /* check section list */
+
+          fSecFound = (strcmp(pSection->pszSection,pszSec) == 0);
+
+          if(!fSecFound)
+            pSection = pSection->pNext;
+          else if(pSection)
+          {
+            fItemFound = FALSE;
+
+            pItem = pSection->pItems;
+
+            while(pItem && !fItemFound)
+            {
+              /* check item list */
+
+              fItemFound = (strcmp(pItem->pszItem,pszItem) == 0);
+
+              if(!fItemFound)
+                pItem = pItem->pNext;
+              else
+                strcpy(pszBuffer,pItem->pszItemValue);
+            }
+          }
+        }
+      }
+    }
+
+    if(!fItemFound)
+    {
+      /* reset buffer and return error */
+
+      *pszBuffer = '\0';
+
+      return(ERR_CFG_NOT_FOUND);
+    }
+    else
+      return(0L);
+}
+
+/****************************************************************************
+
+ FUNCTION:  PUBLIC ULONG FreeConfiguration(VOID);
+
+ COMMENTS:  Frees memory allocated for configuration.
+
+ DATE:      11/28/95 - 10:18:06
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+PUBLIC ULONG FreeConfiguration()
+{
+static CHAR *fn_name = "FreeConfiguration()";
+
+M_CFG_DEVICE  *pTmpDev  = (M_CFG_DEVICE  *)NULL;
+M_CFG_SECTION *pTmpSec  = (M_CFG_SECTION *)NULL;
+M_CFG_ITEM    *pTmpItem = (M_CFG_ITEM    *)NULL;
+
+#if defined (SSD_CODELIB) && defined (WINNT)
+
+    return(0);
+
+#endif
+
+    while(pConfiguration)
+    {
+      while(pConfiguration->pSections)
+      {
+        while(pConfiguration->pSections->pItems)
+        {
+          pTmpItem = pConfiguration->pSections->pItems;
+
+          pConfiguration->pSections->pItems =
+                                     pConfiguration->pSections->pItems->pNext;
+
+          free(pTmpItem->pszItem);
+          free(pTmpItem->pszItemValue);
+          free(pTmpItem);
+        }
+
+        pTmpSec = pConfiguration->pSections;
+
+        pConfiguration->pSections = pConfiguration->pSections->pNext;
+
+        free(pTmpSec->pszSection);
+        free(pTmpSec);
+      }
+
+      pTmpDev = pConfiguration;
+
+      pConfiguration = pConfiguration->pNext;
+
+      free(pTmpDev->pszDevice);
+      free(pTmpDev);
+    }
+
+    pConfiguration = (M_CFG_DEVICE *) NULL;
+
+    return(0L);
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE ULONG AppendDevice(CHAR *pszDevice);
+
+ COMMENTS:  Appends device items to config list.
+
+ DATE:      11/27/95 - 14:41:06
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+PRIVATE ULONG AppendDevice(CHAR *pszDevice)
+{
+CHAR           *pStr;
+CHAR           *pToken;
+M_CFG_DEVICE *pNew;
+M_CFG_DEVICE *pRun;
+
+    if(!pszDevice || !*pszDevice)
+      return((ULONG)-1);
+
+    /* extract device token */
+
+    pToken = pszDevice;
+
+    while(*pToken == '[')
+      pToken++;
+
+    if((pStr = strstr(pToken,"]]")) != NULL)
+      *pStr = '\0';
+    else
+      return((ULONG) -1L);
+
+    // check if device is already in list
+
+    for(pRun = pConfiguration; pRun && pRun->pszDevice;)
+    {
+       if(strcmp(pRun->pszDevice,pToken))
+         pRun = pRun->pNext;
+       else
+       {
+         pConfigLast = pRun;
+         return(0L);
+       }
+    }
+
+    /* allocate new item */
+    if((pNew = (M_CFG_DEVICE *) malloc(sizeof(M_CFG_DEVICE))) == NULL)
+      return((ULONG) -1L);
+
+    if((pNew->pszDevice = (CHAR *) malloc(strlen(pToken) +1)) == NULL)
+    {
+      free(pNew);
+      return((ULONG) -1L);
+    }
+
+    /* save device name */
+
+    strcpy(pNew->pszDevice,pToken);
+
+    pNew->pSections = (M_CFG_SECTION *) NULL;
+    pNew->pNext     = (M_CFG_DEVICE *)  NULL;
+
+    if(!pConfiguration)
+    {
+      /* insert as first item in list */
+
+      pConfiguration = pConfigLast = pNew;
+    }
+    else
+    {
+      /* append at end of list */
+
+      pConfigLast->pNext = pNew;
+
+      /* new item is the last one now */
+
+      pConfigLast        = pNew;
+    }
+
+    /* reset last section pointer for every new device */
+
+    pSectionLast = (M_CFG_SECTION *) NULL;
+
+    return(0L);
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE ULONG AppendSection(CHAR *pszSection);
+
+ COMMENTS:  Appends section items to config list.
+
+ DATE:      11/27/95 - 14:41:06
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+PRIVATE ULONG AppendSection(CHAR *pszSection)
+{
+CHAR            *pStr;
+CHAR            *pToken;
+M_CFG_SECTION *pNew;
+M_CFG_SECTION *pRun;
+
+    if(!pConfiguration || !pszSection || !*pszSection)
+      return((ULONG) -1);
+
+    /* extract section token */
+
+    pToken = pszSection;
+
+    if(*pToken == '[')
+      pToken++;
+    else
+      return((ULONG) -1L);
+
+    if((pStr = strchr(pToken,']')) != NULL)
+      *pStr = '\0';
+    else
+      return((ULONG) -1L);
+
+    // check if section is already in list
+
+    for(pRun = pConfigLast->pSections; pRun && pRun->pszSection;)
+    {
+       if(strcmp(pRun->pszSection,pToken))
+         pRun = pRun->pNext;
+       else
+       {
+         pSectionLast = pRun;
+         return(0L);
+       }
+    }
+
+    /* allocate new item */
+    if((pNew = (M_CFG_SECTION *) malloc(sizeof(M_CFG_SECTION))) == NULL)
+      return((ULONG) -1L);
+    if((pNew->pszSection = (CHAR *) malloc(strlen(pToken) +1)) == NULL)
+    {
+
+      free(pNew);
+      return((ULONG) -1L);
+    }
+
+    /* save section name */
+
+    strcpy(pNew->pszSection,pToken);
+
+    pNew->pItems = (M_CFG_ITEM *)    NULL;
+    pNew->pNext  = (M_CFG_SECTION *) NULL;
+
+    if(!pSectionLast)
+    {
+      /* insert as first item in list */
+
+      pConfigLast->pSections = pSectionLast = pNew;
+    }
+    else
+    {
+      /* append at end of list */
+
+      pSectionLast->pNext = pNew;
+
+      /* new item is the last one now */
+
+      pSectionLast        = pNew;
+    }
+
+    /* reset last item pointer for every new section */
+
+    pItemLast = (M_CFG_ITEM *) NULL;
+
+    return(0L);
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE ULONG AppendItem(CHAR *pszItem);
+
+ COMMENTS:  Appends items to config list.
+
+ DATE:      11/27/95 - 14:41:06
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+PRIVATE ULONG AppendItem(CHAR *pszItem)
+{
+CHAR         *pStr;
+CHAR         *pToken;
+CHAR         *pComment;
+M_CFG_ITEM *pNew;
+M_CFG_ITEM *pRun;
+
+    if(!pConfiguration || !pConfiguration->pSections || !pszItem || !*pszItem)
+      return((ULONG) -1);
+
+    /* extract item token */
+
+    pToken = pszItem;
+
+    if((pStr = strchr(pToken,'=')) != NULL)
+      *pStr = '\0';
+    else
+      return((ULONG) -1L);
+
+    /* cut of pending blanks */
+
+    while(*(pToken + strlen(pToken) -1) <= ' ')
+      *(pToken + strlen(pToken) -1) = '\0';
+
+    // check if item is already in list
+
+    for(pRun = pSectionLast->pItems; pRun && pRun->pszItem;)
+    {
+      if(strcmp(pRun->pszItem,pToken))
+        pRun = pRun->pNext;
+      else
+      {
+        debugWrite(HERE,"error in file:      %s\n"
+                         "item \"[[%s]] [%s] %s\" defined more than once.\n",
+                          szActualFile,
+                          pConfigLast->pszDevice,
+                          pSectionLast->pszSection,
+                          pToken);
+
+        OS_Beep(3000,2000);
+
+        // return error
+
+        return(1L);
+      }
+    }
+
+    /* allocate new item */
+    if((pNew = (M_CFG_ITEM *) malloc(sizeof(M_CFG_ITEM))) == NULL)
+      return((ULONG) -1L);
+    if((pNew->pszItem = (CHAR *) malloc(strlen(pToken) +1)) == NULL)
+    {
+      free(pNew);
+      return((ULONG) -1L);
+    }
+
+    /* set pStr to value */
+
+    pStr++;
+
+    /* discard comments in this line */
+
+    if((pComment = strstr(pStr,"//")) != NULL)
+      *pComment = '\0';
+
+    /* discard leading blanks */
+
+    while(*pStr && *pStr <= ' ')
+      pStr++;
+
+    /* cut of pending blanks and other rubbish */
+
+    while(*pStr && *(pStr + strlen(pStr) -1) <= ' ')
+      *(pStr + strlen(pStr) -1) = '\0';
+
+    if(!*pStr)
+    {
+      // no value ignore !!
+      free(pNew->pszItem);
+      free(pNew);
+      return(0);
+    }
+    if((pNew->pszItemValue = (CHAR *) malloc(strlen(pStr) +1)) == NULL)
+    {
+      free(pNew);
+      free(pNew->pszItem);
+      return((ULONG) -1L);
+    }
+
+    /* save item name */
+
+    strcpy(pNew->pszItem,pToken);
+    strcpy(pNew->pszItemValue,pStr);
+
+    pNew->pNext  = (M_CFG_ITEM *) NULL;
+
+    if(!pItemLast)
+    {
+      /* insert as first item in list */
+
+      pSectionLast->pItems = pItemLast = pNew;
+    }
+    else
+    {
+      /* append at end of list */
+
+      pItemLast->pNext = pNew;
+
+      /* new item is the last one now */
+
+      pItemLast        = pNew;
+    }
+
+    return(0L);
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE ULONG ScanConfiguration(FILE *)
+
+ COMMENTS:  Scans file and saves contents in memory.
+
+ DATE:      11/27/95 - 14:41:06
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+PRIVATE ULONG ScanConfiguration(FILE *pFile,ULONG ulLevel)
+{
+ULONG rc;
+ULONG  ulLen;
+FILE  *pIncFile;
+CHAR   szIncFile[CHARBUF];
+CHAR   szTmp    [CHARBUF];
+CHAR  *pszStr;
+CHAR  *pszValue;
+CHAR  *pszTmp;
+BOOL   fMultiLineEntry;
+
+    pszValue        = NULL;
+    fMultiLineEntry = FALSE;
+
+    while(fgets(szTmp,sizeof(szTmp),pFile))
+    {
+      /* cut out leading blanks */
+
+      pszStr = szTmp;
+
+      while(*pszStr && *pszStr <= ' ')
+        pszStr++;
+
+      /* check if comment */
+
+      if(*pszStr != '/' && *(pszStr+1) != '/')
+      {
+        /* not a commment !! */
+
+        strcpy(szTmp,pszStr);
+
+        if((pszStr = strstr(szTmp,"#include")) != NULL)
+        {
+          // include files allowed on level 1 only !!!
+
+          if(ulLevel == 1)
+          {
+            // include file !!
+
+            if((pszStr = strchr(pszStr,'<')) != NULL)
+            {
+              pszStr++;
+
+              if((pszTmp = strchr(pszStr,'>')) != NULL)
+                *pszTmp = '\0';
+
+              QueryMUtilsPath(szIncFile);
+
+              strcat(szIncFile,"\\");
+              strcat(szIncFile,pszStr);
+
+              if((pIncFile = fopen(szIncFile,"rb")) != NULL)
+              {
+                strcpy(szTmp,szActualFile);
+                strcpy(szActualFile,szIncFile);
+
+                /* read configuration from include file */
+
+                debugWrite(HERE,"including file:     %s",szIncFile);
+
+                rc = ScanConfiguration(pIncFile,2);
+
+                fclose(pIncFile);
+
+                strcpy(szActualFile,szTmp);
+              }
+              else
+              {
+                debugWrite(HERE,"configuration error: "
+                                 "can't open include file [%s]\n",szIncFile);
+
+                OS_Beep(3000,2000);
+
+                return(-1L);
+              }
+            }
+          }
+          else
+          {
+            debugWrite(HERE,"configuration error: "
+                             "include level to high\n\n"
+                             "line:%s\n",szTmp);
+
+            OS_Beep(3000,2000);
+
+            return(-1L);
+          }
+        }
+
+        if((pszStr = strstr(szTmp,"[[")) != NULL)
+        {
+          if(pszValue)
+          {
+            // save first
+
+            rc = AppendItem(pszValue);
+
+            free(pszValue);
+
+            pszValue = NULL;
+
+            if(rc)
+              return(rc);
+          }
+
+          if(rc = AppendDevice(pszStr))
+            return(rc);
+        }
+        else if((pszStr = strchr(szTmp,'[')) != NULL)
+        {
+          if(pszValue)
+          {
+            // save first
+
+            rc = AppendItem(pszValue);
+
+            free(pszValue);
+
+            pszValue = NULL;
+
+            if(rc)
+              return(rc);
+          }
+
+          if(rc = AppendSection(pszStr))
+            return(rc);
+        }
+        else if((pszStr = strchr(szTmp,'=')) != NULL && !fMultiLineEntry)
+        {
+/*
+          if(pszValue)
+          {
+            // save first
+
+            rc = AppendItem(pszValue);
+
+            free(pszValue);
+
+            pszValue = NULL;
+
+            if(rc)
+              return(rc);
+          }
+*/
+          // check for multiple lines
+
+          pszTmp = szTmp + strlen(szTmp) -1;
+
+          if(*pszTmp == '\n' && *(pszTmp -1) == '\r' && *(pszTmp -2) == '\\')
+          {
+            if((pszValue = (CHAR *) malloc(MULTI_LINE_ITEM_SIZE)) == NULL)
+              return(-1L);
+
+            memset(pszValue,0,MULTI_LINE_ITEM_SIZE);
+
+            // cut off backslash
+
+            *(pszTmp -2) = '\0';
+
+            // and save to separate buffer
+
+            ulLen = sprintf(pszValue,"%s\n",szTmp);
+
+            fMultiLineEntry = TRUE;
+          }
+          else
+          {
+            fMultiLineEntry = FALSE;
+
+            // single line item value
+
+            if(rc = AppendItem(szTmp))
+              return(rc);
+          }
+        }
+        else if(pszValue)
+        {
+          // check for more multiple lines
+
+          pszTmp = szTmp + strlen(szTmp) -1;
+
+          if(*pszTmp == '\n' && *(pszTmp -1) == '\r' && *(pszTmp -2) == '\\')
+          {
+            // cut off backslash
+
+            *(pszTmp -2) = '\0';
+
+            // and save to separate buffer
+
+            ulLen += sprintf(pszValue +ulLen,"%s\n",szTmp);
+
+            fMultiLineEntry = TRUE;
+          }
+          else
+          {
+            // and save to separate buffer
+
+            ulLen += sprintf(pszValue +ulLen,"%s",szTmp);
+
+            rc = AppendItem(pszValue);
+
+            free(pszValue);
+
+            pszValue = NULL;
+
+            fMultiLineEntry = FALSE;
+
+            if(rc)
+              return(rc);
+          }
+        }
+      }
+    }
+
+    return(0);
+}
+
+/****************************************************************************
+
+ FUNCTION:  PUBLIC ULONG QueryMUtilsPath(CHAR *);
+
+ COMMENTS:  Returns root path of SSDBASE.DLL.
+
+ DATE:      2-16-95, 12:41 AM
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+PUBLIC ULONG QueryMUtilsPath(CHAR *pszPath)
+{
+#if defined (SSD_CODELIB)
+
+CHAR    *pToken;
+CHAR    szTmp[2048];
+CHAR    szPath[512];
+BOOL    fFound;
+
+#else
+
+ULONG   rc;
+HMODULE hModule;
+
+#endif
+
+CHAR   *pStr;
+
+    if(!pszPath)
+      return((ULONG) -1);
+    else
+    {
+      if(*szRootPath == '\0')
+      {
+
+#if defined (SSD_CODELIB)
+
+        // simply scan path environment var
+
+        if(OS_ScanEnv("PATH",(const CHAR **) &pStr))
+          pStr = NULL;
+
+        if(pStr)
+        {
+          strcpy(szTmp,strlwr(pStr));
+
+          for(fFound = FALSE, pToken = strtok(szTmp,";"); !fFound && pToken;)
+          {
+            strcpy(szPath,pToken);
+            strcat(szPath,"\\massai.dll");
+
+            if(!access(szPath,0))
+            {
+              fFound = TRUE;
+
+              strcpy(szRootPath,pToken);
+            }
+            else
+              pToken = strtok(NULL,";");
+          }
+
+          if(!fFound)
+          {
+            strcpy(szTmp,strlwr(pStr));
+            for(fFound = FALSE, pToken = strtok(szTmp,";"); !fFound && pToken;)
+            {
+              strcpy(szPath,pToken);
+              strcat(szPath,"\\massai.cfg");
+
+              if(!access(szPath,0))
+              {
+                fFound = TRUE;
+
+                strcpy(szRootPath,pToken);
+              }
+              else
+                pToken = strtok(NULL,";");
+            }
+          }
+        }
+
+#else  // SSD_CODELIB
+
+        if(rc = OS_QueryModuleHandle((PSZ)"MASSAI",&hModule))
+          return(rc);
+
+        if(rc = OS_QueryModuleName(hModule,sizeof(szRootPath),szRootPath))
+        {
+
+#ifdef WINNT
+
+          CloseHandle((HANDLE)hModule);
+#endif
+
+          return(rc);
+        }
+
+        if((pStr = strrchr(szRootPath,'\\')) != NULL)
+          *pStr = '\0';
+
+#endif // SSD_CODELIB
+
+      }
+
+      strcpy(pszPath,szRootPath);
+      return(0);
+    }
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE CHAR *PureName(CHAR *)
+
+ COMMENTS:  Skips quotation marks in string.
+
+ DATE:      30-Jul-1991
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+PRIVATE CHAR *PureName(CHAR *s)
+{
+static CHAR  szBuf[1024];
+
+CHAR *p;
+
+   strcpy(szBuf,s);
+
+   /* query string from beginning */
+
+   while((p = strchr(szBuf,'"')) != NULL)
+     if(*(p+1))
+       strcpy(szBuf,p+1);
+     else
+       szBuf[strlen(szBuf) -1] = '\0';
+
+   return(szBuf);
+}
+
+/****************************************************************************
+
+ FUNCTION:  PUBLIC ULONG mUtilsReadConfig (VOID);
+
+ COMMENTS:  Creates configuration structure an parses configuration file.
+
+ DATE:      11/24/95 - 12:28:57
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+PUBLIC ULONG mUtilsReadConfig()
+{
+ULONG  rc          = 0x0000;
+CHAR   szConfigFile  [CHARBUF];
+CHAR  *pStr;
+FILE  *pScanFile;
+
+    if (configRead)
+      return 0;
+    configRead = true;
+
+    QueryMUtilsPath(szConfigFile);
+    /* Build Configuration File name for global configurations */
+
+    if(OS_ScanEnv("MUTILS_CFG_FILE",(const CHAR **) &pStr))
+      strcat(szConfigFile,MUTILS_CFG_FILE);
+    else
+    {
+      // make config file name from environment
+      // (only for local test purposes !!)
+
+      strcat(szConfigFile,"\\");
+      strcat(szConfigFile,pStr);
+    }
+
+    /* scan configuration file */
+
+    if((pScanFile = fopen(szConfigFile,"rb")) == NULL)
+      return((ULONG)-1L);
+    else
+    {
+      /* read configuration file */
+
+      debugWrite(HERE,"configuration file: %s\n",szConfigFile);
+
+      strcpy(szActualFile,szConfigFile);
+
+      rc = ScanConfiguration(pScanFile,1);
+
+      fclose(pScanFile);
+    }
+
+    if (rc) //error
+      configRead = false;
+
+
+    return(rc);
+}
+
+/****************************************************************************
+
+ METHOD:    mConfig::mConfig()
+
+ COMMENTS:  constructor without setting Data. SetData is required.
+
+ DATE:      01/16/96 - 18:00:45
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+mConfig::mConfig()
+{
+    ulError     = 0L;
+    szBuffer[0] = '\0';   // initialize Buffer
+
+    massaiLibraryInitTerm.ref(); // reference massaiLibraryInitTerm
+}
+
+/****************************************************************************
+
+ METHOD:    mConfig::mConfig (CHAR *pszDev,
+                                  CHAR *pszSec,
+                                  CHAR *pszItem)
+
+ COMMENTS:  constructor.
+
+ DATE:      01/16/96 - 18:00:45
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+mConfig::mConfig (CHAR *pszDev,            /* device ID - [[device]]   */
+                      CHAR *pszSec,            /* section ID - [section]   */
+                      CHAR *pszItem)           /* item ID - item = foo bar */
+{
+   ulError = readValue(pszDev,pszSec,pszItem);
+   return;
+}
+
+mConfig::mConfig (CHAR *pszCfgItem)
+{
+   ulError = readValue(pszCfgItem);
+   return;
+}
+
+/****************************************************************************
+
+ METHOD:     ULONG mConfig::readValue (CHAR *pszDev,
+                                         CHAR *pszSec,
+                                         CHAR *pszItem)
+
+ COMMENTS:  Reads new Item
+
+ DATE:      01/16/96 - 18:00:45
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+ULONG mConfig::readValue (CHAR *pszDev,     /* device ID - [[device]]   */
+                            CHAR *pszSec,     /* section ID - [section]   */
+                            CHAR *pszItem)    /* item ID - item = foo bar */
+{
+    if((ulError = CfgReadStr(pszDev,pszSec,pszItem,sizeof(szBuffer),szBuffer)) )
+    {
+       /* Item not found */
+
+       szBuffer[0] = '\0';
+       //trc().write(HERE_8,"Item not found: <%s>:<%s>:<%s>",pszDev,pszSec,pszItem);
+    }
+
+    return(ulError);
+}
+
+ULONG mConfig::readValue (CHAR *pszCfgItem)
+{
+CHAR szTmp[512];
+CHAR *pszDev;
+CHAR *pszSec;
+CHAR *pszItem;
+
+    if(pszCfgItem && *pszCfgItem)
+    {
+      strcpy(szTmp,pszCfgItem);
+
+      pszDev  = strtok(szTmp,".");
+      pszSec  = strtok(NULL,".");
+      pszItem = strtok(NULL,".");
+
+      if((ulError = CfgReadStr(pszDev,pszSec,pszItem,sizeof(szBuffer),szBuffer)))
+      {
+         /* Item not found */
+
+         szBuffer[0] = '\0';
+
+         debugWrite(HERE,"Item not found: [%s]",pszCfgItem);
+      }
+    }
+    else
+      ulError = -1;
+
+    return(ulError);
+}
+
+
+/****************************************************************************
+
+ METHOD:    ULONG mConfig::CfgReadStr (CHAR *pszDev,
+                                         CHAR *pszSec,
+                                         CHAR *pszItem,
+                                         LONG  lBufLen,
+                                         CHAR *pszRet)
+
+ COMMENTS:  Searches configuration for string item.
+
+ DATE:      11/28/95 - 10:18:06
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+ULONG mConfig::CfgReadStr (CHAR *pszDev,          /* device ID - [[device]]   */
+                              CHAR *pszSec,          /* section ID - [section]   */
+                              CHAR *pszItem,         /* item ID - item = foo bar */
+                              LONG  lBufLen,         /* length of return buffer  */
+                              CHAR *pszRet)          /* return buffer            */
+{
+ULONG  rc = 0L;
+LONG   i;
+CHAR   szTmp[1024];
+
+    if(!pszRet || !lBufLen)
+    {
+      /* won't work for this function */
+
+      return(ERR_CFG_PARAMETERS);
+    }
+
+    if(rc = FindItem(pszDev,pszSec,pszItem,szTmp))
+      return(rc);
+    else
+    {
+      /* copy string to return buffer */
+
+      for(i = 0; i < lBufLen && szTmp[i]; i++)
+        *(pszRet +i) = szTmp[i];
+
+      *(pszRet +i) = '\0';
+    }
+
+    return(0L);
+}
+
+/****************************************************************************
+
+ METHOD:    VOID mConfig::itemString (CHAR *pszDev,
+                                        CHAR *pszSec,
+                                        CHAR *pszItem,
+                                        CHAR *pszBuf, LONG lBufLen);
+
+ COMMENTS:  sets and returns item as String.
+
+ DATE:      01/16/96 - 18:25:41
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+VOID  mConfig::itemString(CHAR *pszDev, CHAR *pszSec, CHAR *pszItem,
+                            CHAR *pszBuf, LONG lBufLen)
+{
+    readValue(pszDev,pszSec,pszItem);
+    asString(pszBuf,lBufLen);
+}
+
+/****************************************************************************
+
+ METHOD:    INT  mConfig::itemInteger(CHAR *pszDev,
+                                        CHAR *pszSec,
+                                        CHAR *pszItem)
+
+ COMMENTS:  sets and returns item as Integer.
+
+ DATE:      01/16/96 - 18:25:41
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+INT mConfig::itemInteger(CHAR *pszDev, CHAR *pszSec, CHAR *pszItem)
+{
+    readValue(pszDev,pszSec,pszItem);
+    return(asInt());
+}
+
+/****************************************************************************
+
+ METHOD:    BOOL mConfig::itemBoolean(CHAR *pszDev,
+                                        CHAR *pszSec,
+                                        CHAR *pszItem)
+
+ COMMENTS:  sets and returns item as Boolean.
+
+ DATE:      01/16/96 - 18:25:41
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+BOOL mConfig::itemBoolean(CHAR *pszDev, CHAR *pszSec, CHAR *pszItem)
+{
+    readValue(pszDev,pszSec,pszItem);
+    return(asBool());
+}
+
+/****************************************************************************
+
+ METHOD:    VOID mConfig::asString (CHAR *pszBuf, LONG lBufLen);
+
+ COMMENTS:  returns item as String.
+
+ DATE:      01/16/96 - 18:25:41
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+VOID mConfig::asString (CHAR *pszBuf, LONG lBufLen)
+{
+INT i = 0;
+
+    if(pszBuf && *szBuffer)
+    {
+      /* Copy String */
+      i = 0;
+      while((pszBuf[i] = szBuffer[i++]) && (i < lBufLen));
+    }
+    else                    //No Data in Buffer
+    {
+      *pszBuf = '\0';
+      ulError = ERR_CFG_NOT_FOUND;
+    }
+}
+
+/****************************************************************************
+
+ METHOD:    INT mConfig::asInt (VOID)
+
+ COMMENTS:  returns item as Integer.
+
+ DATE:      01/16/96 - 18:25:41
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+INT mConfig::asInt(VOID)
+{
+    if(*szBuffer)
+    {
+      /* convert string to integer */
+      return(atoi(szBuffer));
+    }
+    else                    //No Data in Buffer
+    {
+      ulError = ERR_CFG_NOT_FOUND;
+      return(0);
+    }
+}
+
+/****************************************************************************
+
+ METHOD:     BOOL mConfig::asBool(VOID)
+
+ COMMENTS:  returns item as Boolean.
+
+ DATE:      01/16/96 - 18:25:41
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+BOOL mConfig::asBool(VOID)
+{
+BOOL rc = FALSE;
+
+    if(*szBuffer)
+    {
+      /* check uppercase string in Buffer for boolean value */
+
+      strupr(szBuffer);
+
+      rc =    ((strcmp(szBuffer,"TRUE")    == 0) ||
+               (strcmp(szBuffer,"YES")     == 0) ||
+               (strcmp(szBuffer,"OK")      == 0) ||
+               (strcmp(szBuffer,"ENABLED") == 0) ||
+               (strcmp(szBuffer,"ENABLE")  == 0) &&
+               (strcmp(szBuffer,"0")       != 0)   );
+    }
+    else                    //No Data in Buffer
+    {
+      ulError = ERR_CFG_NOT_FOUND;
+      rc = FALSE;           //Better Arise an Exception
+    }
+    return(rc);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   ULONG mConfig::reloadConfiguration()
+//
+//  purpose:    try to reload the configuration files
+//
+//  date:       08.08.2001, 16:32
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+ULONG mConfig::reloadConfiguration()
+{
+    return(0);
+}
diff --git a/Massai/cpp/MassaiDLL/static/src/mDate.cpp b/Massai/cpp/MassaiDLL/static/src/mDate.cpp
new file mode 100644
index 00000000..355a5452
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/static/src/mDate.cpp
@@ -0,0 +1,520 @@
+#include "mDate.hpp"
+
+#include <time.h>
+
+#define self (*this)
+
+/*------------------------------------------------------------------------------
+|  These arrays give the number of days in the year that precede each month    |
+|  (in non-leap and leap years, respectively).  They should be indexed by the  |
+|  Month value minus 1 (e.g., the days preceding April in a non-leap year is   |
+|  daysToMonth[0][3]).                                                         |
+------------------------------------------------------------------------------*/
+static const int
+  daysToMonth[ 2 ] [ 13 ] =
+    {
+    { 0,  31,  59,  90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
+    { 0,  31,  60,  91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
+    };
+
+/*------------------------------------------------------------------------------
+|  These arrays give the number of days in a 4 year block that precede each    |
+|  year. Each group of 4 year may / may not start with a leap year             |
+------------------------------------------------------------------------------*/
+static const int
+  daysIn4Years[2][5] =
+  {
+  { 0, 365, 730, 1095, 1460},
+  { 0, 366, 731, 1096, 1461}
+  };
+
+
+/*------------------------------------------------------------------------------
+|  This structure simply combines separate Month, Day, and Year values for a   |
+|  given date (for communication with the various utility functions, see       |
+|  below).                                                                     |
+|                                                                              |
+------------------------------------------------------------------------------*/
+typedef struct
+  {
+  mDate::Month month;
+  int          day;
+  int          year;
+  } MDY;
+
+
+/*------------------------------------------------------------------------------
+|  reformMDY                                                                   |
+|  reformJulianDayNumber                                                       |
+|  reformDays                                                                  |
+|  julianReferenceYear                                                         |
+|  dayNumber160101                                                             |
+|  dayNumber170101                                                             |
+|                                                                              |
+|  These constants give the date at which the Gregorian reforms were           |
+|  adopted (in both MDY and Julian day number format) and the number           |
+|  of dates skipped upon adoption.                                             |
+|                                                                              |
+|  Note:  There are restrictions on the values these constants can             |
+|         have, specifically, the skipped days cannot span the end             |
+|         of the month.                                                        |
+------------------------------------------------------------------------------*/
+static const MDY
+  reformMDY = { mDate::September, 2, 1752 };
+
+static const long int
+  reformJulianDayNumber = 2361221;
+
+static const int
+  reformDays = 11;
+
+static const int
+  julianReferenceYear = -4713;
+
+static const long int
+  dayNumber16010101 = 2305824;
+
+static const long int
+  dayNumber17010101 = 2342349;
+
+/*------------------------------------------------------------------------------
+| Function prototypes for static/local utilities (see below)                   |
+------------------------------------------------------------------------------*/
+static MDY
+  julianToMDY ( unsigned long julianDate ),
+  DYToMDY     ( int aDay, int aYear );
+
+static unsigned long
+  MDYToJulian ( MDY aMDY );
+
+/*------------------------------------------------------------------------------
+| mDate::mDate                                                                 |
+|                                                                              |
+| To construct a date given year/month/day, simply invoke the protected member |
+| function initialize() with the year, month, and day (these latter two        |
+| calculated via DYToMDY(), if need be).                                       |
+|                                                                              |
+| To construct the current time, invoke the static member function today() and |
+| use the julian date from its result.                                         |
+|                                                                              |
+| The protected constructor that accepts a julian day number (long int) simply |
+| initializes the data member 'julian' to the argument value.                  |
+|                                                                              |
+| To construct a date from the container CDATE structure, simply initialize    |
+| from the month/day/year in that structure.                                   |
+------------------------------------------------------------------------------*/
+mDate :: mDate ( int  aYear,
+                 int  aDay )
+   {
+   MDY mdy = DYToMDY( aDay, aYear );
+   self.initialize( mdy.month, mdy.day, mdy.year );
+   }
+
+mDate :: mDate ( unsigned long julianDayNumber ) : julian( julianDayNumber )
+  {
+  }
+
+
+#if 0
+mDate :: mDate ( const ICnrDate &cnrDate )
+   {
+   self.initialize( (mDate::Month)cnrDate.month, cnrDate.day, cnrDate.year );
+   }
+#endif
+
+/*------------------------------------------------------------------------------
+| mDate::asICnrDate                                                            |
+|                                                                              |
+| Build result ICnrDate structure from receiver's day/month/year.              |
+------------------------------------------------------------------------------*/
+ICnrDate mDate :: asICnrDate ( ) const
+  {
+  ICnrDate
+    result = { (unsigned char)this->dayOfMonth(),
+               (unsigned char)this->monthOfYear(),
+               (unsigned short)this->year() };
+  return result;
+  }
+
+
+/*------------------------------------------------------------------------------
+| mDate::dayOfMonth                                                            |
+|                                                                              |
+| The receiver's Julian date is converted to year/month/day format using the   |
+| function julianToMDY() (see below).  The day of the mongth is then simply    |
+| returned.                                                                    |
+------------------------------------------------------------------------------*/
+int mDate :: dayOfMonth ( ) const
+   {
+   MDY mdy = julianToMDY( self.julian );
+   return mdy.day;
+   }
+
+/*------------------------------------------------------------------------------
+| mDate::dayOfYear                                                             |
+|                                                                              |
+| The receiver's Julian date is converted to year/month/day format via a call  |
+| to julianToMDY().  Then, the day within the year is calculated by adding the |
+| days prior to that month (from the daysToMonth array) to the day of the      |
+| month.                                                                       |
+------------------------------------------------------------------------------*/
+int mDate :: dayOfYear ( ) const
+   {
+   MDY mdy = julianToMDY( self.julian );
+   return daysToMonth[ mDate::isLeapYear( mdy.year ) ][ mdy.month - 1 ]
+          +
+          mdy.day;
+   }
+
+/*------------------------------------------------------------------------------
+| mDate::Month mDate :: monthOfYear                                            |
+|                                                                              |
+| Convert the receiver's Julian date to year/month/day format via a call to    |
+| julianToMDY().  Simply return the resulting month.                           |
+------------------------------------------------------------------------------*/
+mDate::Month mDate :: monthOfYear ( ) const
+   {
+   return julianToMDY( self.julian ).month;
+   }
+
+/*------------------------------------------------------------------------------
+| mDate::year                                                                  |
+|                                                                              |
+| Convert the receiver's Julian date to year/month/day format via a call to    |
+| julianToMDY().  Simply return the resulting year.                            |
+------------------------------------------------------------------------------*/
+int mDate :: year ( ) const
+   {
+   return julianToMDY( self.julian ).year;
+   }
+
+
+/*------------------------------------------------------------------------------
+| mDate::daysInMonth                                                           |
+|                                                                              |
+| We use the daysToMonth array to calculate the basic length of the month (it  |
+| is the days to the next month - the days to the argument month).  Lastly,    |
+| if the year and month are those when the Gregorian reform took effect, then  |
+| we subtract the proper number of "reform days."                              |
+------------------------------------------------------------------------------*/
+int mDate :: daysInMonth ( Month aMonth,
+                           int   aYear )
+   {
+   int leap = ( mDate :: isLeapYear( aYear ) != 0 );
+   int result =  daysToMonth[ leap ][ aMonth ]
+                 -
+                 daysToMonth[ leap ][ aMonth - 1 ];
+   if ( aYear == reformMDY.year
+        &&
+        aMonth == reformMDY.month )
+      result -= reformDays;
+   return result;
+   }
+
+/*------------------------------------------------------------------------------
+| mDate::daysInYear                                                            |
+|                                                                              |
+| Return either 365 or 366 (the latter if the year is a leap year), unless     |
+| this is the year of the Gregorian reform (in which case the length of the    |
+| year is reduced by the number of "reform days.")                             |
+------------------------------------------------------------------------------*/
+int mDate :: daysInYear ( int aYear )
+   {
+   int result = 365 + mDate :: isLeapYear( aYear );
+   if ( aYear == reformMDY.year )
+      result -= reformDays;
+   return result;
+   }
+
+/*------------------------------------------------------------------------------
+| mDate::isLeapYear                                                            |
+|                                                                              |
+| Prior the the Gregorian reform, leap years were any that were even           |
+| multiples of 4. Subsequent to that, century years not divisible by 400 are   |
+| not leap years.  Note that the input int is in "standard" form (-1 is 1      |
+| BC).  Since 1 BC *was* a leap year, we add 1 to negative years before        |
+| testing for being multiples of 4.                                            |
+------------------------------------------------------------------------------*/
+int mDate :: isLeapYear ( int aYear )
+   {
+   int result = 0;
+   int y = aYear + ( aYear < 0 );
+   if ( y % 4 == 0                // Must be divisible by 4...
+        &&
+        ( aYear < reformMDY.year  // ...and either before reform...
+          ||
+          y % 100 != 0            // ...or not a century year...
+          ||
+          y % 400 == 0 ) )        // ...or a multiple of 400...
+      result = 1;              // to be a leap year.
+   return result;
+   }
+
+/*------------------------------------------------------------------------------
+| mDate::isValid                                                               |
+|                                                                              |
+| The year/day version simply makes sure that the day is less than or equal to |
+| the number of days in the year (determined via a call to the static member   |
+| function daysInYear()).                                                      |
+|                                                                              |
+| The year/month/day simply makes sure that the month is valid (just in case)  |
+| and that the day is less than or equal to the number of days in the month    |
+| (determined via a call to the static member function daysInMonth()).  In     |
+| addition, the date cannot be one of days skipped upon adoption of the        |
+| Gregorian calendar reform.                                                   |
+|                                                                              |
+| The year 0 is always rejected.                                               |
+------------------------------------------------------------------------------*/
+int mDate :: isValid ( Month aMonth,
+                           int   aDay,
+                           int   aYear )
+   {
+   // Make sure month and year are legitimate (and day is feasible):
+   int result = ( aMonth >= January
+                      &&
+                      aMonth <= December
+                      &&
+                      aDay > 0
+                      &&
+                      aYear != 0 );
+   int days = reformMDY.day;
+       days += reformDays;
+   if ( result )
+      // OK so far, make sure day is OK, too:
+      if ( aYear == reformMDY.year
+           &&
+           aMonth == reformMDY.month )
+         // int is within month with some deleted days, make
+         // sure it isn't too big (using different calculation)
+         // and that it isn't one of the deleted days:
+         result = ( aDay <= ( mDate::daysInMonth( aMonth, aYear )
+                              +
+                              reformDays )
+                    &&
+                    ( aDay <= reformMDY.day
+                      ||
+                      aDay >  days ) );
+      else
+         // int isn't within month with deleted days, just make
+         // sure the day isn't too big:
+         result = ( aDay <= mDate::daysInMonth( aMonth, aYear ) );
+
+   return result;
+   }
+
+/*------------------------------------------------------------------------------
+| mDate::initialize                                                            |
+|                                                                              |
+| The argument is validated, and if OK, converted to a Julian day number via   |
+| a call to the function MDYToJulian().  The result of this function is        |
+| stored in the data member 'julian.'  If the date is not valid, then the      |
+| mDate is set to Julian day number 0.                                         |
+------------------------------------------------------------------------------*/
+mDate& mDate :: initialize ( Month aMonth,
+                             int   aDay,
+                             int   aYear )
+   {
+      if ( mDate::isValid( aMonth, aDay, aYear ) )
+      {
+         MDY mdy = { aMonth, aDay, aYear };
+         self.julian = MDYToJulian( mdy );
+      }
+      else
+         self.julian = 0;
+      return self;
+   }
+
+/*------------------------------------------------------------------------------
+| julianToMDY                                                                  |
+|                                                                              |
+| Converts from julian into a MDY format.                                      |
+------------------------------------------------------------------------------*/
+static MDY julianToMDY ( unsigned long julianDayNumber )
+   {
+   int reformAdjustment = 0;
+
+   // if after reform, adjust julian day to skip the missing calendar days
+   if (julianDayNumber > reformJulianDayNumber)
+   {
+      julianDayNumber += reformDays;
+      // find the number of centuries year that is not a leap year
+      // according to the reform method.
+      reformAdjustment = (julianDayNumber - dayNumber17010101) / 36524 -
+                         (julianDayNumber - dayNumber16010101) / 146097;
+   }
+   // get the number of 4 complete years since 4713 B.C. by fist
+   // adding the reform adjustment back to julianDayNumber - causing
+   // all years divisible by 4 as leap year.
+   int num4Year = (julianDayNumber + reformAdjustment) / 1461;
+
+   // find the group of 4 year where the julianDayNumber fall into
+   int years = (num4Year << 2) + julianReferenceYear;
+
+   if (years >= 0) years++; // introduce the gap between B.C. & A.D.
+
+   // recalculate the actual number of non leap century year
+   if (reformAdjustment)
+      reformAdjustment = (years - 1701) / 100 - (years - 1601) / 400;
+   // get the days in the group of 4 years, add 1 to make the day
+   // actual day instead of elapse days
+   int days = (julianDayNumber + reformAdjustment) % 1461 + 1;
+
+   // normally, the beginning of 4 year group is a leap year unless
+   // it is one of those non leap century year;
+   int leap = 1;
+   if (years > reformMDY.year &&
+       !(years % 100) &&
+       years % 400)
+      leap = 0;
+
+   // find the year in which the remaining day reside
+   int yearIn4;
+   for (yearIn4 = 1; yearIn4 < 5; yearIn4++)
+      if (daysIn4Years[leap][yearIn4] >= days)
+         break;
+   years += yearIn4 - 1;
+   days -= daysIn4Years[leap][yearIn4 - 1];
+
+   // only the first year can be leap
+   if (yearIn4 > 1)
+      leap = 0;
+
+   // adjust the years between 0 A.D. and 2 A.D. to 1.A.D. to 3 A.D.
+   if (years >= 0 && years <= 2) years++;
+
+   int month;
+   for (month = 1; month < 13; month++)
+       if (days <= daysToMonth[leap][month])
+          break;
+
+   days -= daysToMonth[leap][month - 1];
+
+   MDY result;
+      result.month = (mDate::Month) month;
+      result.day   = days;
+      result.year  = years;
+
+   return result;
+   }
+
+/*------------------------------------------------------------------------------
+| DYToMDY                                                                      |
+|                                                                              |
+| This function takes a date (as day and year) and converts it to              |
+| month/day/year format.  It initializes the result to the given year with     |
+| month January and the given day.  It then iterates till the result day is a  |
+| valid day in the result month (determined via a call to daysInMonth()),      |
+| incrementing the result month and subtracting the days in the month from the |
+| result day.                                                                  |
+|                                                                              |
+| If the resulting MDY is not valid (which would only be the case if it fell   |
+| during the days deleted upon adoption of the Gregorian calendar reform),     |
+| then the day is incremented by the number of days that were deleted and the  |
+| loop iterates again.  The loop terminates when the result day is valid.      |
+|                                                                              |
+| If the input day/year are invalid, then the day number is too big.  In this  |
+| case, the same day appears in the result MDY (which is thus also invalid).   |
+------------------------------------------------------------------------------*/
+static MDY DYToMDY ( int aDay, int aYear )
+   {
+   MDY result;
+      result.month = mDate::January,
+      result.day   = aDay,
+      result.year  = aYear;
+
+   if ( mDate :: isValid( aYear, aDay ) )
+      while ( 1 )
+         {
+         int maxDay = mDate :: daysInMonth( result.month, result.year );
+         if ( result.day > maxDay )
+            result.month = (mDate::Month) ( result.month + 1 ),
+            result.day -= maxDay;
+         else
+           break;
+         }
+
+  if ( result.year == reformMDY.year
+       &&
+       result.month == reformMDY.month
+       &&
+       result.day > reformMDY.day )
+     result.day += reformDays;
+
+   return result;
+   }
+
+/*------------------------------------------------------------------------------
+| MDYToJulian                                                                  |
+|                                                                              |
+| This function converts a calendar date (in year/month/day format) to the     |
+| corresponding Julian day number.                                             |
+|                                                                              |
+| First, if the calendar year is negative, it is incremented by 1. This is     |
+| to put the years in a continuous interval [-4712, ...], which simplifies     |
+| some of the mathematics (and is required by the "julian" algorithm used).    |
+------------------------------------------------------------------------------*/
+static unsigned long MDYToJulian ( MDY aDate )
+   {
+
+   // get the # of years from 4713 B.C. and adjust the gap between B.C. & A.D.
+   int  years = aDate.year - julianReferenceYear - (aDate.year > 0 ? 1 : 0);
+
+   // julian reference year is a leap year, so leap year is the first year
+   // of a 4 year block
+   long int julian_date = years ? (years * 365) + ((years + 3) >> 2) : 0;
+
+   // normally, if the year is divisible by 4, a leap year
+   int  leap = years & 3 ? 0 : 1;
+   // if aDate.year is after reform, then century year not divisible
+   // by 400 is not a leap year
+   if (aDate.year >  reformMDY.year &&
+       !(aDate.year % 100) &&
+       aDate.year % 400)
+      leap = 0;
+
+   // julian is measured as elapse days from 1/1/4713 B.C. so subtract 1
+   // to get elapse days
+   julian_date += daysToMonth[leap][aDate.month -1] + aDate.day - 1;
+
+   if ( julian_date > reformJulianDayNumber )
+   {
+      // after reform, new leap year calculation kicks in so check
+      // for # of elapse centuries and 4 centuries - upto last year
+      aDate.year--;
+      julian_date += (aDate.year - 1600) / 400 - (aDate.year - 1700) / 100;
+      // 11 days missing in the calendar during reform.
+      if (julian_date > reformJulianDayNumber + reformDays)
+         julian_date -= reformDays;
+      else
+         julian_date = reformJulianDayNumber;
+     }
+   return julian_date;
+   }
+
+#if 0
+mDate :: mDate ( const _CDATE &cDate )
+   {
+   self.initialize( (mDate::Month)cDate.month, cDate.day, cDate.year );
+   }
+/*------------------------------------------------------------------------------
+| mDate::asCDATE                                                               |
+|                                                                              |
+| Build result CDATE structure from receiver's day/month/year.                 |
+------------------------------------------------------------------------------*/
+_CDATE mDate :: asCDATE ( ) const
+  {
+  CDATE
+    result = { (unsigned char)this->dayOfMonth(),
+               (unsigned char)this->monthOfYear(),
+               (unsigned short)this->year() };
+  return result;
+  }
+#endif
+
+mDate mDate::today()
+   {
+      time_t t   = time(0);
+      tm     now = *localtime( &t );
+      return mDate(  now.tm_year + 1900, now.tm_yday + 1 );
+   }
+
diff --git a/Massai/cpp/MassaiDLL/static/src/mList.cpp b/Massai/cpp/MassaiDLL/static/src/mList.cpp
new file mode 100644
index 00000000..02ac33b7
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/static/src/mList.cpp
@@ -0,0 +1,339 @@
+/**
+ *  @file      mListBase.cpp
+ *
+ *  @brief     Thread save list implementation
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ *
+ ************************************************************************/
+
+#include "mList.h"
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        void mListBase::append(void *item)
+ *
+ *  @brief     appends an item at the end of the list
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+void mListBase::append(void *item)
+{
+    if(item)
+    {
+      mThreadAutoMutex protect(&sem);
+
+      l.push_back(item);
+
+      c = l.end();
+    }
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        void mListBase::insert(void *item)
+ *
+ *  @brief     inserts an item at the bginning of the list
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+void mListBase::insert(void *item)
+{
+    if(item)
+    {
+      mThreadAutoMutex protect(&sem);
+
+      l.push_front(item);
+
+      c = l.begin();
+    }
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        void mListBase::remove(void *item)
+ *
+ *  @brief     removes the specified item from the list
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+void mListBase::remove(void *item)
+{
+std::list<void *>::iterator tmp;
+std::list<void *>::iterator i;
+bool fFound;
+
+    if(item)
+    {
+      mThreadAutoMutex protect(&sem);
+
+      for(i = l.begin(), fFound = false; i != l.end() && !fFound; i++)
+      {
+        tmp = i;
+
+        if((*i) == item)
+          fFound = true;
+      }
+
+      if(fFound)
+      {
+        l.erase(tmp);
+      }
+    }
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mListBase::replace(void *oldItem, void *newItem)
+ *
+ *  @brief     replaces an old item with a new one
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mListBase::replace(void *oldItem, void *newItem)
+{
+std::list<void *>::iterator tmp;
+std::list<void *>::iterator i;
+bool fFound;
+long rc = 0;
+
+    if(oldItem && newItem)
+    {
+      mThreadAutoMutex protect(&sem);
+
+      for(i = l.begin(), fFound = false; i != l.end() && !fFound; i++)
+      {
+        tmp = i;
+
+        if((*i) == oldItem)
+          fFound = true;
+      }
+
+      if(fFound)
+      {
+        l.erase(tmp);
+        l.insert(i,newItem);
+
+        // adjust cursor
+
+        c = i;
+      }
+      else
+        rc = -2;
+
+      return(rc);
+    }
+    else
+      return(-1);
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        void mListBase::deleteAll()
+ *
+ *  @brief     deletes all items from the list
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+void mListBase::deleteAll()
+{
+    mThreadAutoMutex protect(&sem);
+    l.clear();
+    c = l.begin();
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        void *mListBase::first()
+ *
+ *  @brief     returns the first item in the list
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+void *mListBase::first()
+{
+    mThreadAutoMutex protect(&sem);
+
+    if(l.size())
+    {
+      c = l.begin();
+
+      return((*c));
+    }
+    else
+      return(NULL);
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        void *mListBase::last()
+ *
+ *  @brief     returns last item in the list
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+void *mListBase::last()
+{
+    mThreadAutoMutex protect(&sem);
+
+    if(l.size())
+    {
+      c = l.end();
+      c--;
+
+      return((*c));
+    }
+    else
+      return(NULL);
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        void *mListBase::next()
+ *
+ *  @brief     returns next item following the cursor
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+void *mListBase::next()
+{
+    mThreadAutoMutex protect(&sem);
+
+    if(++c != l.end())
+      return((*c));
+    else
+      return(NULL);
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        void *mListBase::previous()
+ *
+ *  @brief     returns item before the cursor
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+void *mListBase::previous()
+{
+    mThreadAutoMutex protect(&sem);
+
+    if(--c != l.begin())
+      return((*c));
+    else
+      return(NULL);
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        void *mListBase::current()
+ *
+ *  @brief     returns the item at the current cursor position
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+void *mListBase::current()
+{
+    mThreadAutoMutex protect(&sem);
+
+    if(l.size())
+      return((*c));
+    else
+      return(NULL);
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mListBase::items()
+ *
+ *  @brief     returns the number of items in the list
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mListBase::items()
+{
+    mThreadAutoMutex protect(&sem);
+
+    return(l.size());
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        mListBase::mListBase()
+ *
+ *  @brief     class constructor
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+mListBase::mListBase()
+{
+    c = l.begin();
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        mListBase::~mListBase()
+ *
+ *  @brief     class destructor
+ *
+ *  @date      03.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+mListBase::~mListBase()
+{
+    mThreadAutoMutex protect(&sem);
+
+    try { deleteAll(); } catch(...) {};
+}
\ No newline at end of file
diff --git a/Massai/cpp/MassaiDLL/static/src/mThread.cpp b/Massai/cpp/MassaiDLL/static/src/mThread.cpp
new file mode 100644
index 00000000..7923e97d
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/static/src/mThread.cpp
@@ -0,0 +1,260 @@
+/****************************************************************************
+
+ FILE:      mThread.cpp
+
+ PURPOSE:   MUtils - thread class implemtation
+
+ DATE:      21/11/97
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+#include "massai.hpp"
+#include "mThread.hpp"
+
+class mCritSec
+{
+private:
+
+    static CRITICAL_SECTION *pCriticalSection;
+
+public:
+
+    mCritSec()
+    {
+      if(!pCriticalSection)
+      {
+         pCriticalSection= new CRITICAL_SECTION;
+         InitializeCriticalSection(pCriticalSection);
+      }
+
+      EnterCriticalSection(pCriticalSection);
+    }
+
+    ~mCritSec()
+    {
+      LeaveCriticalSection(pCriticalSection);
+
+      //  Deleting this causes race conditions at process shutdown.  We
+      //  let the critical section be cleaned up by the system.
+      //    DeleteCriticalSection(pCriticalSection);
+      //    delete pCriticalSection;
+      //    pCriticalSection = 0;
+    };
+
+};
+
+CRITICAL_SECTION *mCritSec::pCriticalSection = 0;
+
+//---------------------------------------------------------------------------
+//
+//  function:   static void _run (void *p)
+//
+//  purpose:    thread execution function
+//
+//  date:       18.07.2001, 09:40
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+static void _run (void *p)
+{
+mThread *pClass = (mThread *)p;
+
+    if(p)
+    {
+      while(pClass->fRun)
+      {
+        pClass->fRunning = true;
+
+        pClass->lError = pClass->function();
+
+        if(pClass->lError == -1)
+        {
+          pClass->fRunning = false;
+          return;
+        }
+        else
+          OS_Sleep(1);
+      }
+    }
+
+    pClass->fRunning = false;
+
+    return;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long mThread::setTimeCritical()
+//
+//  purpose:    change priority
+//
+//  date:       18.07.2001, 09:40
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long mThread::setTimeCritical()
+{
+  mCritSec protect;
+
+  fRun = false;
+
+  lError = OS_SetPrty(PRTYS_THREAD,PRTYC_TIMECRITICAL,0,lTid);
+
+  fRun = true;
+
+  return(lError);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long mThread::setRegular()
+//
+//  purpose:    change priority
+//
+//  date:       18.07.2001, 09:40
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long mThread::setRegular()
+{
+  mCritSec protect;
+
+  fRun = false;
+
+  lError = OS_SetPrty(PRTYS_THREAD,PRTYC_REGULAR,0,lTid);
+
+  fRun = true;
+
+  return(lError);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long mThread::run ()
+//
+//  purpose:    create and start thread
+//
+//  date:       18.07.2001, 09:40
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long mThread::run ()
+{
+  fRun = true;
+
+  lError = OS_CreateThread((unsigned long *)&lTid,PFNTHREAD(_run),long(this),0,lStackSize);
+
+  return (lError);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void mThread::stop ()
+//
+//  purpose:    pause execution
+//
+//  date:       18.07.2001, 09:41
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void mThread::stop ()
+{
+  if(!fStopped)
+  {
+    mCritSec protect;
+
+    fRun     = false;
+    fStopped = true;
+  }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void mThread::restart ()
+//
+//  purpose:    restart execution
+//
+//  date:       18.07.2001, 09:41
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void mThread::restart ()
+{
+  if(fStopped)
+  {
+    fRun     = true;
+    fStopped = false;
+  }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long mThread::killWait()
+//
+//  purpose:    kill it (gracefully)
+//
+//  date:       18.07.2001, 09:41
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long mThread::killWait()
+{
+  {
+    mCritSec protect;
+
+    fRun    = false;
+    fKilled = true;
+  }
+
+  while(fRunning) OS_Sleep(1);
+
+  lError = OS_KillThread(lTid);
+
+  return (lError);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   long mThread::kill ()
+//
+//  purpose:    kill it
+//
+//  date:       18.07.2001, 09:41
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+long mThread::kill ()
+{
+  {
+    mCritSec protect;
+
+    fRun    = false;
+    fKilled = true;
+  }
+
+  lError = OS_KillThread(lTid);
+
+  return (lError);
+}
+
+/****************************************************************************
+ END OF FILE
+****************************************************************************/
diff --git a/Massai/cpp/MassaiDLL/static/src/mThreadEx.cpp b/Massai/cpp/MassaiDLL/static/src/mThreadEx.cpp
new file mode 100644
index 00000000..88db7b29
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/static/src/mThreadEx.cpp
@@ -0,0 +1,459 @@
+/**
+ *  @file      mThreadEx.cpp
+ *
+ *  @brief     Thread class implementation
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ *
+ ************************************************************************/
+
+#include "mThreadEx.h"
+
+static ACE_Thread_Mutex _sem;
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        static void *worker(mThread *p)
+ *
+ *  @brief     threads worker function
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+static void *worker(mThreadEx *p)
+{
+long rc = 0;
+
+    p->lId = GetCurrentThreadId();
+
+    while(ACE_Thread_Manager::instance()->testcancel(ACE_Thread::self()) == 0)
+    {
+      try
+      {
+        if(p->isSynchronized())
+        {
+          _sem.acquire();
+
+          rc = ((mSynchThread *)p)->synchronized();
+
+          _sem.release();
+        }
+        else
+          rc = p->function();
+      }
+      catch(...)
+      {
+        rc = -1;
+      }
+
+      if(rc < 0)
+      {
+        // terminate thread when return value is < 0
+
+        break;
+      }
+    }
+
+    // Destructor removes thread from Thread_Manager.
+
+    return 0;
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mThreadEx::isSynchronized()
+ *
+ *  @brief     return synchronized flag
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mThreadEx::isSynchronized()
+{
+    return(lSynchronized);
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mThreadEx::error()
+ *
+ *  @brief     retruns current error
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mThreadEx::error()
+{
+    return(lError);
+};
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mThreadEx::run()
+ *
+ *  @brief     starts execution
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mThreadEx::run()
+{
+    if(groupId)
+      return(0);
+
+    if(pThreadMgr)
+    {
+      groupId = pThreadMgr->spawn_n(lThreads,
+                                    ACE_THR_FUNC (worker),
+                                    ACE_reinterpret_cast (void *,this),
+                                    THR_NEW_LWP | THR_DETACHED);
+    }
+    else
+    {
+      lError = -1;
+    }
+
+    return(error());
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mThreadEx::stop()
+ *
+ *  @brief     suspends execution
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mThreadEx::stop()
+{
+    if(pThreadMgr)
+    {
+      lError = pThreadMgr->suspend_grp(groupId);
+    }
+    else
+    {
+      lError = -1;
+    }
+
+    return(error());
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mThreadEx::restart()
+ *
+ *  @brief     resumes execution
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mThreadEx::restart()
+{
+    if(pThreadMgr)
+    {
+      lError = pThreadMgr->resume_grp(groupId);
+    }
+    else
+    {
+      lError = -1;
+    }
+
+    return(error());
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mThreadEx::kill()
+ *
+ *  @brief     stops execution
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mThreadEx::kill()
+{
+    if(pThreadMgr)
+    {
+      lError = pThreadMgr->cancel_grp(groupId);
+    }
+    else
+    {
+      lError = -1;
+    }
+
+    return(error());
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mThreadEx::killWait()
+ *
+ *  @brief     stops execution & waits for termination
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mThreadEx::killWait()
+{
+    if(pThreadMgr)
+    {
+      lError = kill();
+      wait();
+    }
+    else
+    {
+      lError = -1;
+    }
+
+    return(error());
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mThreadEx::wait()
+ *
+ *  @brief     waits for thread termination
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mThreadEx::wait()
+{
+    if(groupId && pThreadMgr)
+    {
+      lError = pThreadMgr->wait_grp(groupId);
+    }
+    else
+    {
+      lError = -1;
+    }
+
+    return(error());
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mThreadEx::id()
+ *
+ *  @brief     returns thread identifier
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mThreadEx::id()
+{
+    if(lThreads > 1)
+      return(groupId);
+    else
+      return(lId);
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        mThreadEx::mThreadEx()
+ *
+ *  @brief     class constructor
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+mThreadEx::mThreadEx(long lCopies)
+{
+    lId           = 0;
+    lSynchronized = 0;
+    groupId       = 0;
+    lThreads      = lCopies;
+
+    pThreadMgr    = ACE_Thread_Manager::instance();
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        mThreadEx::~mThreadEx()
+ *
+ *  @brief     class destructor
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+mThreadEx::~mThreadEx()
+{
+    //try { killWait(); } catch(...) {};
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        mSynchThread::mSynchThread()
+ *
+ *  @brief     class constructor
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+mSynchThread::mSynchThread()
+{
+    // simply set this flag
+
+    lSynchronized = 1;
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        mSynchThread::~mSynchThread()
+ *
+ *  @brief     class destructor (rely on base class' destructor)
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+mSynchThread::~mSynchThread()
+{
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mThreadMutex::lock()
+ *
+ *  @brief     lock the semaphor
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mThreadMutex::lock()
+{
+    return(sem.acquire());
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mThreadMutex::trylock()
+ *
+ *  @brief     try to lock the semaphor (don't block)
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mThreadMutex::trylock()
+{
+    return(sem.tryacquire());
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        long mThreadMutex::unlock()
+ *
+ *  @brief     unlock the semaphor
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+long mThreadMutex::unlock()
+{
+    return(sem.release());
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        mThreadMutex::mThreadMutex(const char *pszName)
+ *
+ *  @brief     class constructor
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+mThreadMutex::mThreadMutex(const char *pszName)
+  : sem((const ACE_TCHAR *) pszName)
+{
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        mThreadAutoMutex::mThreadAutoMutex(mThreadMutex& s)
+ *
+ *  @brief     auto lock the semaphor
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+mThreadAutoMutex::mThreadAutoMutex(mThreadMutex *s)
+{
+    sem = s;
+    sem->lock();
+}
+
+//------------------------------------------------------------------------
+/**
+ *  @fn        mThreadAutoMutex::~mThreadAutoMutex()
+ *
+ *  @brief     auto unlock the semaphor
+ *
+ *  @date      02.12.2003
+ *
+ *  @author    Materna Information & Communications (AGe)
+ */
+//------------------------------------------------------------------------
+
+mThreadAutoMutex::~mThreadAutoMutex()
+{
+    sem->unlock();
+}
diff --git a/Massai/cpp/MassaiDLL/static/src/mTime.cpp b/Massai/cpp/MassaiDLL/static/src/mTime.cpp
new file mode 100644
index 00000000..490c18a5
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/static/src/mTime.cpp
@@ -0,0 +1,43 @@
+//-------------------------------------------------------------------------
+//
+// mTime.cpp
+//
+// Implementation file for mTime.hpp
+//
+// Dr.Materna GmbH 1999, jk
+//
+//-------------------------------------------------------------------------
+
+#include "mTime.hpp"
+#include <iostream.h>
+
+
+
+static void dec2( char * Dst, unsigned N )
+   {
+      N %= 100;
+      Dst[0] = (N / 10) + '0';
+      Dst[1] = (N % 10) + '0';
+   }
+
+
+
+std::ostream & operator <<( std::ostream & OS, const mTime & Time )
+   {
+      char Buffer[9];
+      dec2( Buffer+0, Time.hours() );
+      Buffer[2] = ':';
+      dec2( Buffer+3, Time.minutes() );
+      Buffer[5] = ':';
+      dec2( Buffer+6, Time.seconds() );
+      Buffer[8] = 0;
+      OS << Buffer;
+      return OS;
+   }
+
+
+
+//-------------------------------------------------------------------------
+// End of file
+//-------------------------------------------------------------------------
+
diff --git a/Massai/cpp/MassaiDLL/static/src/mTimer.cpp b/Massai/cpp/MassaiDLL/static/src/mTimer.cpp
new file mode 100644
index 00000000..d8880d5a
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/static/src/mTimer.cpp
@@ -0,0 +1,203 @@
+//---------------------------------------------------------------------------
+//
+//  file:       mTimer.cpp
+//
+//  purpose:    Timer implementation
+//
+//  date:       02.11.00, 10:45
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include <sys/timeb.h>
+
+#include "base_os.h"
+#include "mTimer.hpp"
+
+// function prototypes ------------------------------------------------------
+
+void LINKAGE timerThread(mTimer *timer);
+
+/*---------------------------------------------------------------------------
+
+ FUNCTION:  void _SYSTEM TimerThread()
+
+ COMMENTS:  timer thread
+
+ DATE:      03/05/96 - 17:42:11
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+---------------------------------------------------------------------------*/
+
+PRIVATE void LINKAGE timerThread(mTimer *timer)
+{
+ULONG ulCntSem;
+LONG  lMillis;
+
+    //printf("timer: waiting to start (initial)...\n");
+
+    OS_WaitEventSem(timer->hEvent,-1);
+    OS_ResetEventSem(timer->hEvent,&ulCntSem);
+
+    while(timer->lMilliSeconds >= 0)
+    {
+      lMillis = timer->lMilliSeconds;
+
+      if(lMillis > 0)
+      {
+        //printf("timer: started.\n");
+
+        while(lMillis >= 0 && timer->lMilliSeconds > 0)
+        {
+           lMillis -= 10;
+           OS_Sleep(10);
+        }
+
+        if(timer->lMilliSeconds > 0)
+        {
+          //printf("timer: elapsed.\n");
+
+          if(timer->ticker() < 0)
+          {
+            //printf("timer: handler called (one shot).\n");
+            return;
+          }
+          //else
+            //printf("timer: handler called.\n");
+        }
+        //else
+          //printf("timer: interrupted\n");
+      }
+      else
+      {
+        //printf("timer: waiting to start...\n");
+
+        OS_WaitEventSem(timer->hEvent,-1);
+        OS_ResetEventSem(timer->hEvent,&ulCntSem);
+      }
+    }
+
+    //printf("timer: thread terminated ...\n");
+
+    return;
+}
+
+/*---------------------------------------------------------------------------
+
+ METHOD:    void ~mTimer(void)
+
+ COMMENTS:  destructor of the class
+
+ DATE:      03/07/96 - 12:31:50
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+---------------------------------------------------------------------------*/
+
+mTimer::~mTimer()
+{
+    lMilliSeconds = -1;
+
+    OS_PostEventSem(hEvent);
+
+    if(hEvent)
+      OS_CloseEventSem(hEvent);
+
+    return;
+}
+
+/*---------------------------------------------------------------------------
+
+ METHOD:    void mTimer(void)
+
+ COMMENTS:  constructor of the class
+
+ DATE:      03/07/96 - 12:31:50
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+---------------------------------------------------------------------------*/
+
+mTimer::mTimer()
+{
+    hEvent = 0;
+
+    OS_CreateEventSem(NULL,&hEvent,DC_SEM_SHARED,FALSE);
+
+    lMilliSeconds = 0;
+
+    OS_CreateThread(&tidWT,(PFNTHREAD)timerThread,(long)this,0L,8192);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   mTimer::mTimer(long lMillis)
+//
+//  purpose:    class constructor
+//
+//  date:       02.11.00, 13:08
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+mTimer::mTimer(long lMillis)
+{
+    hMutex = 0;
+    hEvent = 0;
+
+    OS_CreateEventSem(NULL,&hEvent,DC_SEM_SHARED,FALSE);
+
+    lMilliSeconds = lMillis;
+
+    OS_CreateThread(&tidWT,(PFNTHREAD)timerThread,(long)this,0L,8192);
+
+    OS_PostEventSem(hEvent);
+}
+
+/*---------------------------------------------------------------------------
+
+ FUNCTION:  void mTimer::start(long lMillis)
+
+ COMMENTS:  start timer
+
+ DATE:      03/05/96 - 17:42:50
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+---------------------------------------------------------------------------*/
+
+void mTimer::start(long lMillis)
+{
+    lMilliSeconds = lMillis;
+
+    OS_PostEventSem(hEvent);
+}
+
+/*---------------------------------------------------------------------------
+
+ FUNCTION:  void mTimer::stop(void)
+
+ COMMENTS:  stop timer
+
+ DATE:      03/05/96 - 17:43:27
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+---------------------------------------------------------------------------*/
+
+void mTimer::stop(void)
+{
+    /* Clear this record */
+
+    lMilliSeconds = 0;
+
+    // just wait a little bit
+
+    OS_Sleep(10);
+}
+
+
+
diff --git a/Massai/cpp/MassaiDLL/static/src/mTraceEx.cpp b/Massai/cpp/MassaiDLL/static/src/mTraceEx.cpp
new file mode 100644
index 00000000..6e09aab0
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/static/src/mTraceEx.cpp
@@ -0,0 +1,635 @@
+//---------------------------------------------------------------------------
+//
+//  file:       mTraceEx.cpp
+//
+//  purpose:    extended trace functionality for CUSS applications
+//
+//  date:       28.12.2001, 13:01
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include <io.h>
+#include <direct.h>
+
+#include "mTrace.hpp"
+#include "mConfig.h"
+#include <stdio.h>
+
+#define MAX_TRACE_BUF (1024 * 1) // 1KByte buffer for tracing
+
+APIRET addToHistory(CHAR *pszFile);
+
+#define MAX_FILE_SIZE     (1024L * 1024L * 10) //10Mb
+
+unsigned long ulMaxFileSize = MAX_FILE_SIZE;
+
+//---------------------------------------------------------------------------
+//
+//  function:   static char *byte2Hex(int x)
+//
+//  purpose:
+//
+//  date:       02.12.2002, 10:58
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+static char *byte2Hex(int x)
+{
+static char szTmp[3];
+int x1,x2;
+
+    x &= 0xff;
+
+    x1 = (x / 16);
+    x2 = (x % 16);
+
+    szTmp[0] = x1 < 10 ? '0' + (char) x1 : 'a' + (char) (x1 - 10);
+    szTmp[1] = x2 < 10 ? '0' + (char) x2 : 'a' + (char) (x2 - 10);
+
+    szTmp[2] = '\0';
+
+    return(szTmp);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   static char *byte2HEX(int x)
+//
+//  purpose:
+//
+//  date:       02.12.2002, 10:58
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+static char *byte2HEX(int x)
+{
+static char szTmp[3];
+int x1,x2;
+
+    x &= 0xff;
+
+    x1 = (x / 16);
+    x2 = (x % 16);
+
+    szTmp[0] = x1 < 10 ? '0' + (char) x1 : 'A' + (char) (x1 - 10);
+    szTmp[1] = x2 < 10 ? '0' + (char) x2 : 'A' + (char) (x2 - 10);
+
+    szTmp[2] = '\0';
+
+    return(szTmp);
+}
+
+long mTraceEx::OpenTraceFile(long lLevel)
+{
+char   *pStr;
+char    szPath[1024];
+long    rc=0;
+
+mConfig tracePath("MUTILS","TRACE","TracePath");
+
+    if(tracePath.error() != 0)
+    {
+      if(rc = QueryMUtilsPath(szPath))
+        return rc;
+
+      if((pStr = strrchr(szPath,'\\')) != NULL)
+         *pStr = '\0';
+
+      strcat(szPath,"\\trc");
+    }
+    else
+      tracePath.asString(szPath,sizeof(szPath));
+
+    mConfig traceSize("MUTILS","TRACE","MaxFileSize");
+    if (!traceSize.error())
+    {
+      ulMaxFileSize = traceSize.asInt();
+    }
+
+
+    if(access(szPath,0))
+      OS_MkDir(szPath,0L);
+
+    pTraceFile   = NULL;
+    lTraceLevel  = lLevel;
+    fFileRenamed = false;
+
+    if(strlen(szFileName)>0)
+      sprintf(szTraceFileName,"%s\\%s",szPath,szFileName);
+    else
+      sprintf(szTraceFileName,"%s\\trc%p",szPath,this);
+
+    strcpy(szTmpFileName, szTraceFileName);
+    /* Check for existence */
+    if( (_access( szTmpFileName, 0 )) != -1 )
+    {
+      /* Rename */
+      addToHistory(szTmpFileName);
+    }
+
+    pTraceFile = fopen(szTmpFileName,"wb");
+
+return rc;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   mTraceEx::mTraceEx(long lLevel,char *pszFileName)
+//
+//  purpose:    class constructor
+//
+//  date:       28.12.2001, 13:21
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+mTraceEx::mTraceEx(long lLevel,char *pszFileName)
+{
+    strcpy(szLocation,"");
+    strcpy(szId,"");
+    strcpy(szFileName, pszFileName);
+    OpenTraceFile(lLevel);
+
+    pTraceBuffer = (char*) malloc(MAX_TRACE_BUF);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   mTraceEx::~mTraceEx()
+//
+//  purpose:    class destructor
+//
+//  date:       28.12.2001, 13:22
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+mTraceEx::~mTraceEx()
+{
+    if(pTraceFile)
+    {
+      if(!fFileRenamed)
+      {
+        // move temporary trace to default location
+
+        // move(); only move if owner explicit wants to.
+      }
+    }
+
+    if(pTraceFile)
+      fflush(pTraceFile);
+
+    if(pTraceFile)
+      fclose(pTraceFile);
+
+    if(pTraceBuffer) free(pTraceBuffer);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void mTraceEx::createDir(char *pszPath)
+//
+//  purpose:    creates a directory from the given path
+//
+//  date:       28.12.2001, 14:05
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void mTraceEx::createDir(char *pszPath)
+{
+char  szPath[1024];
+char *pEnd = szPath;
+char del= 0;
+
+    if(!pszPath)
+      return;
+
+    strcpy(szPath,pszPath);
+
+    do
+    {
+      while(*pEnd != 0 && *pEnd != '/' && *pEnd != '\\')
+        ++pEnd;
+      del= *pEnd;
+      *pEnd= 0;
+
+      _mkdir(szPath);
+
+      *pEnd= del;
+      ++pEnd;
+    } while(del != 0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void mTraceEx::printDatetime(char *buf)
+//
+//  purpose:    write current date/timeto buf
+//
+//  date:       16.08.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+long mTraceEx::printDatetime(char* buf)
+{
+  DATETIME  Date;
+  long result= 0;
+  OS_GetDateTime(&Date);
+
+  result= sprintf(buf, "%02d%02d %02d%02d:%02d.%02d ",
+                       Date.day,
+                       Date.month,
+                       Date.hours,
+                       Date.minutes,
+                       Date.seconds,
+                       Date.hundredths);
+
+  return result;
+}
+//---------------------------------------------------------------------------
+//
+//  function:   void mTraceEx::printFileLine(char *buf, char *pszFile,long lLine)
+//
+//  purpose:    write file name, line to buf
+//
+//  date:       16.08.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+long mTraceEx::printFileLine(char* buf, char *pszFile,long lLine)
+{
+  char szFile[CHARBUF];
+  long result= 0;
+  char *pStr= 0;
+
+  strncpy(szFile,pszFile, sizeof(szFile));
+  szFile[sizeof(szFile) - 1]= 0;
+
+  // cut path from file name
+
+  if((pStr = strrchr(szFile,'\\')) != NULL)
+    strcpy(szFile,pStr +1);
+
+  // cut file name extension
+
+  if((pStr = strrchr(szFile,'.')) != NULL)
+    *pStr = '\0';
+
+  result += sprintf(buf,"%-16s(%4d): ",szFile,lLine);
+  return result;
+}
+
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   void mTraceEx::writeTrace(char* pData)
+//
+//  purpose:    write pData to the trace file
+//
+//  date:       16.08.2006
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//---------------------------------------------------------------------------
+
+void mTraceEx::writeTrace(char* pData, long len)
+{
+  fpos_t    pos;
+
+  if (fseek(pTraceFile,0,SEEK_END) == 0)
+  {
+    if( fgetpos( pTraceFile, &pos ) == 0 )
+    {
+      if(pos > ulMaxFileSize)
+      {
+        move(szLocation, szId);
+      }
+    }
+  }
+
+  OutputDebugString((char *)pData);
+  fwrite((void *)pData,sizeof(char),len,pTraceFile);
+  fflush(pTraceFile);
+}
+
+
+//---------------------------------------------------------------------------
+//
+//  function:   void mTraceEx::move(char *pszLocation, char *pszId)
+//
+//  purpose:
+//
+//  date:       28.12.2001, 13:22
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void mTraceEx::move(char *pszLocation, char *pszId)
+{
+DATETIME Date;
+char     szPath   [512];
+char     szDefPath[512];
+char     szTmp    [1024];
+char    *pStr;
+long     rc;
+mConfig  tracePath("MUTILS","TRACE","TracePath");
+
+    accessTrace.request();
+    try
+    {
+      if (pszLocation)
+        strcpy(szLocation, pszLocation);
+
+      if (pszId)
+        strcpy(szId, pszId);
+
+      if(tracePath.error() != 0)
+      {
+        if(rc = QueryMUtilsPath(szDefPath))
+        {
+          accessTrace.release();
+          return;
+        }
+
+        if((pStr = strrchr(szDefPath,'\\')) != NULL)
+           *pStr = '\0';
+
+        strcat(szDefPath,"\\trc");
+      }
+      else
+        tracePath.asString(szDefPath,sizeof(szDefPath));
+
+      OS_GetDateTime(&Date);
+
+      if(!pszLocation || !pszId)
+      {
+        // save to default path
+
+        sprintf(szPath,"%s\\%02d%02d\\",szDefPath,Date.day,Date.month);
+      }
+      else if(pszLocation && !pszId)
+      {
+        // save to default//location
+
+        sprintf(szPath,"%s\\%s\\%02d%02d\\",szDefPath,pszLocation,Date.day,Date.month);
+      }
+      else if(!pszLocation && pszId)
+      {
+        // save to default//id
+
+        sprintf(szPath,"%s\\%s\\%02d%02d\\",szDefPath,pszId,Date.day,Date.month);
+      }
+      else
+      {
+        // save to default//location/id
+
+        sprintf(szPath,"%s\\%s\\%s\\%02d%02d\\",szDefPath,pszLocation,pszId,Date.day,Date.month);
+      }
+
+      createDir(szPath);
+
+      if((pStr = strstr(strlwr(szTraceFileName),".trc")) != NULL)
+        *pStr = '\0';
+
+      //if((pStr = strrchr(szTraceFileName,'\\')) != NULL)
+      if((pStr = strrchr(szFileName,'\\')) != NULL)
+        sprintf(szTmp,"%s%s.%02d%02d%02d.trc",szPath,pStr +1,
+                                                 Date.hours,Date.minutes,Date.seconds);
+      else
+        //sprintf(szTmp,"%s\\%s.%02d%02d%02d.trc",szPath,szTraceFileName,
+        sprintf(szTmp,"%s\\%s.%02d%02d%02d.trc",szPath,szFileName,
+                                                 Date.hours,Date.minutes,Date.seconds);
+
+      strcpy(szTraceFileName,szTmp);
+
+      fclose(pTraceFile);
+
+      rc = OS_Move(szTmpFileName,szTraceFileName);
+
+      pTraceFile = fopen(szTraceFileName,"ab");
+
+      rc = _unlink(szTmpFileName);
+
+      fFileRenamed = true;
+    }
+    catch(...)
+    {}
+    accessTrace.release();
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void mTraceEx::write(long lLevel,char *pszFile,long lLine,char *pszFormat, ...)
+//
+//  purpose:    trace function
+//
+//  date:       28.12.2001, 13:22
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void mTraceEx::write(long lLevel,char *pszFile,long lLine,char *pszFormat, ...)
+{
+long      lLen;
+char     *pTmp;
+long      bufSize;
+char     *pBuf= 0;
+
+va_list   arg_ptr;
+    // look if trace file opened
+
+    accessTrace.request();
+    try
+    {
+      if((pTraceFile && pTraceBuffer) && (lLevel <= lTraceLevel || lLevel == 255))
+      {
+        pTmp = pTraceBuffer;
+        lLen = 0;
+
+        // check given arguments
+        if(pszFile && pszFormat)
+        {
+          // write traces with date and time
+          lLen+= printDatetime(pTmp + lLen);
+          lLen+= printFileLine(pTmp + lLen, pszFile, lLine);
+
+          // get pointer to first argument
+          va_start(arg_ptr,pszFormat);
+          // print into buffer
+          bufSize= _vsnprintf(0, 0, pszFormat, arg_ptr);
+          if(bufSize + lLen + 2 > MAX_TRACE_BUF)
+          {
+            try
+            {
+              pBuf= new char[bufSize + lLen + 2];
+            }
+            catch(...)
+            {}
+            if(pBuf != 0)
+            {
+              strncpy(pBuf, pTmp, lLen + 1);
+
+              pTmp= pBuf;
+              lLen+= _vsnprintf(pTmp + lLen, bufSize, pszFormat, arg_ptr);
+            }
+            else
+            {
+              bufSize= _vsnprintf(pTmp + lLen, MAX_TRACE_BUF - lLen, pszFormat, arg_ptr);
+              lLen= MAX_TRACE_BUF - 2;
+            }
+          }
+          else
+          {
+            bufSize= _vsnprintf(pTmp + lLen, MAX_TRACE_BUF - lLen, pszFormat, arg_ptr);
+            lLen+= bufSize;
+          }
+          va_end(arg_ptr);
+
+          lLen += sprintf(pTmp + lLen,"\n");
+        }
+        else
+          lLen = sprintf(pTmp,"<< INVALID TRACE >>");
+
+        *(pTmp + lLen) = '\0';
+
+        // write everything to file (only if owner !!)
+
+        writeTrace(pTmp, lLen);
+        if(pBuf != 0)
+        {
+          delete[] pBuf;
+        }
+      }
+    }
+    catch(...)
+    {}
+    accessTrace.release();
+
+    return;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void mTraceEx::dump(long lLevel,char *pszFile,long lLine,void *pData, long len)
+//
+//  purpose:    dump function
+//
+//  date:       28.12.2001, 13:22
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void mTraceEx::dump(long lLevel,char *pszFile,long lLine,void *pData, long len)
+{
+long    i,j;
+long    rc;
+char   *pTmp,
+       *pd;
+long    lSize;
+char   *pBuf= 0;
+
+    pd = (char *)pData;
+
+    accessTrace.request();
+    try
+    {
+      if((pTraceFile && pTraceBuffer) && (lLevel <= lTraceLevel || lLevel == 255))
+      {
+        lSize = ((len >> 4) + 1) * 90 + 290;
+
+        if(!pd || !len)
+        {
+          accessTrace.release();
+          return;
+        }
+
+        pTmp = pTraceBuffer;
+        if(lSize > MAX_TRACE_BUF)
+        {
+          try
+          {
+            pBuf = new char[lSize];
+          }
+          catch(...)
+          {}
+          if(pBuf)
+          {
+            pTmp= pBuf;
+          }
+          else
+          {
+            lSize= MAX_TRACE_BUF;
+          }
+        }
+
+
+        if(pszFile)
+        {
+          rc= 0;
+          rc+= printDatetime(pTmp + rc);
+          rc+= printFileLine(pTmp + rc, pszFile, lLine);
+          rc+= sprintf(pTmp + rc,"%c",'\n');
+
+          for(i = 0; i < len && rc < lSize - 95; i += 16)
+          {
+            rc += sprintf(pTmp +rc,"[%04x,%04d] ",i,i);
+
+            for(j = 0; j < 16 && (i+j) < len; j++)
+            {
+              if(j == 8)
+                rc += sprintf(pTmp + rc,"- %s ",byte2Hex(pd[i+j]));
+              else
+                rc += sprintf(pTmp + rc,"%s ",byte2Hex(pd[i+j]));
+            }
+
+            while(j < 16)
+            {
+              if(j == 8)
+                rc += sprintf(pTmp + rc,"     ");
+              else
+                rc += sprintf(pTmp + rc,"   ");
+
+              j++;
+            }
+
+            for(j = 0; j < 16 && (i+j) < len; j++)
+              rc += sprintf(pTmp + rc,"%c",(pd[i+j] >= ' ') ? pd[i+j]: '.');
+
+            rc += sprintf(pTmp + rc,"\n");
+          }
+        }
+        else
+        {
+          rc= sprintf(pTmp,"<< INVALID TRACE >>");
+        }
+        *(pTmp + rc) = '\0';
+        writeTrace(pTmp, rc);
+        if(pBuf != 0)
+        {
+          delete[] pBuf;
+        }
+      }
+    }
+    catch(...)
+    {}
+    accessTrace.release();
+    return;
+}
\ No newline at end of file
diff --git a/Massai/cpp/MassaiDLL/static/src/massai.cpp b/Massai/cpp/MassaiDLL/static/src/massai.cpp
new file mode 100644
index 00000000..75624b24
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/static/src/massai.cpp
@@ -0,0 +1,1428 @@
+/****************************************************************************
+
+ FILE:      mUtils.cpp
+
+ PURPOSE:   Exported basic massai functions.
+
+ DATE:      11/23/95 - 15:18:31
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+#include <io.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <time.h>
+#include <signal.h>
+
+#include "iostream.h"
+
+#include "base_os.h"
+#include "massai.hpp"
+#include "mtrace.hpp"
+#include "mConfig.h"
+#include "globbase.hpp"
+#include "trace.hpp"
+
+// private constants *********************************************************
+
+#define MAGIC_ID          1234567
+
+typedef struct _M_process
+        {
+          long      ulProcessID;
+          long      ulSessionID;
+          HANDLE    hProcess;
+          bool      fKeepAlive;
+          bool      fCleanupCalled;
+          bool      fStartupCalled;
+        }
+        M_PROCESS;
+
+/* private function prototypes ***********************************************/
+
+static APIRET        mBasicServicesInit (void);  // do DLL initilizations
+static void APIENTRY mBasicServicesTerm (long ulReason) ;
+
+/* global vars for this file  ************************************************/
+
+static HMTX        hmtxSocketSem  = 0;
+static HMTX        hmtxTraceSem   = 0;
+static HMTX        hmtxShMemSem   = 0;
+static HMTX        hmtxServices   = 0;
+
+static long        lMagic         = 0;
+static long        lAccess        = 0;
+static long        lTerminate     = 0;
+static long        lStartProcess  = 0;
+static long        lServicesUp    = 0;
+static TIB        *pStartTib;
+static PIB        *pStartPib;
+
+static int         iSystemReboot  = 1;
+static bool        fMInUse        = false;
+
+static M_PROCESS   mProcesses [M_MAX_DEVICES];
+static long        lMProcess  [M_MAX_DEVICES];
+
+//---------------------------------------------------------------------------
+//
+//  function:   long currentProcessId()
+//
+//  purpose:    returns process id for caller
+//
+//  date:       05-Jan-1999, 12:14:36
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+long currentProcessId()
+{
+TIB *pTib;
+PIB *pPib;
+
+  OS_GetInfoBlocks(&pTib,&pPib);
+
+  return(pPib->pib_ulpid);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   static bool startupCalled(long ulProcess)
+//
+//  purpose:    returns true if WSACleanup was called.
+//
+//  date:       05-Jan-1999, 12:15:25
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+static bool startupCalled(long ulProcess)
+{
+bool fRet   = false;
+bool fFound = false;
+int  i;
+
+    for(i = 0; i < M_MAX_DEVICES && !fFound; i++)
+    {
+      if(ulProcess == mProcesses[i].ulProcessID)
+      {
+        fRet = mProcesses[i].fStartupCalled;
+        fFound = true;
+      }
+    }
+
+    return(fRet);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   static bool cleanupCalled(long ulProcess)
+//
+//  purpose:    returns true if WSACleanup was called.
+//
+//  date:       05-Jan-1999, 12:15:25
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+static bool cleanupCalled(long ulProcess)
+{
+bool fRet   = false;
+bool fFound = false;
+int  i;
+
+    for(i = 0; i < M_MAX_DEVICES && !fFound; i++)
+    {
+      if(ulProcess == mProcesses[i].ulProcessID)
+      {
+        fRet = mProcesses[i].fCleanupCalled;
+        fFound = true;
+      }
+    }
+
+    return(fRet);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   static void setStartupCalled(long ulProcess)
+//
+//  purpose:    sets marker for WSACleanup()
+//
+//  date:       05-Jan-1999, 12:14:56
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+static void setStartupCalled(long ulProcess)
+{
+bool fFound = false;
+int  i;
+
+    for(i = 0; i < M_MAX_DEVICES && !fFound; i++)
+    {
+      if(ulProcess == mProcesses[i].ulProcessID)
+      {
+        mProcesses[i].fStartupCalled = fFound = true;
+      }
+    }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   static void setCleanupCalled(long ulProcess)
+//
+//  purpose:    sets marker for WSACleanup()
+//
+//  date:       05-Jan-1999, 12:14:56
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+static void setCleanupCalled(long ulProcess)
+{
+bool fFound = false;
+int  i;
+
+    for(i = 0; i < M_MAX_DEVICES && !fFound; i++)
+    {
+      if(ulProcess == mProcesses[i].ulProcessID)
+      {
+        mProcesses[i].fCleanupCalled = fFound = true;
+      }
+    }
+}
+
+/****************************************************************************
+
+ FUNCTION:  bool isMProcess(long ulProcess)
+
+ COMMENTS:  Check if process is attached to MUTILS.
+
+ DATE:      24-Jul-1998, 09:40:52
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+bool isMProcess(long ulProcess)
+{
+bool fFound = false;
+int  i;
+
+    for(i = 0; i < M_MAX_DEVICES && !fFound; i++)
+      fFound = (ulProcess == lMProcess[i]);
+
+    return(fFound);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   static void stopProcesses()
+//
+//  purpose:    stop processes according to given flags.
+//
+//  date:       05-Nov-1998, 13:38:14
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+static void stopProcesses()
+{
+int   i;
+long  rc;
+
+    if(rc = GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT,0))
+    {
+      for(i = M_MAX_DEVICES -1; i >= 0 ; i--)
+      {
+        if(mProcesses[i].ulSessionID)
+          OS_Sleep(1000);
+      }
+
+      debugWrite(HERE,"CTRL-BREAK, rc = %d",rc);
+    }
+
+    for(i = M_MAX_DEVICES -1; i >= 0 ; i--)
+    {
+      /* check which session to stop */
+
+      if(mProcesses[i].ulSessionID)
+      {
+        rc = OS_StopSession(STOP_SESSION_SPECIFIED, mProcesses[i].hProcess);
+
+        debugWrite(HERE,"OS_StopSession, Index = %ld, rc = %ld",i,rc);
+      }
+    }
+}
+
+/****************************************************************************
+
+ FUNCTION:  void addLog(byte  bLevel,
+                               char *pszFile,
+                               short sLine,
+                               char *pszFunction,
+                               char *pszFormat,...)
+
+ COMMENTS:  Add trace to mutils.log when no Trace available.
+
+ DATE:      24-Jul-1998, 09:40:52
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+void addLog(byte bLevel,char *pszFile,short sLine,char *pszFunction,char *pszFormat,...)
+{
+char     szFile  [256];
+char     szFunc  [256];
+char     szBuffer[1024];
+char    *pStr;
+long     ulLen;
+FILE    *fp;
+DATETIME Date;
+va_list  arg_ptr;
+long     rc;
+
+    if(rc = QueryMUtilsPath(szFile))
+      return;
+
+    if((pStr = strrchr(szFile,'\\')) != NULL)
+       *pStr = '\0';
+
+    strcat(szFile,"\\TRC\\");
+    strcat(szFile,M_UTILSDEV_FILE);
+
+    if((fp = fopen(szFile,"wa+")) == NULL)
+    {
+      return;
+    }
+    else
+    {
+      OS_GetDateTime(&Date);
+
+      memset(szBuffer,0,sizeof(szBuffer));
+
+      ulLen = 0;
+
+      ulLen += sprintf(szBuffer + ulLen,"%02d%02d %02d%02d:%02d.%02d ",
+                                        Date.day,
+                                        Date.month,
+                                        Date.hours,
+                                        Date.minutes,
+                                        Date.seconds,
+                                        Date.hundredths);
+
+      strcpy(szFunc,pszFunction);
+      strcpy(szFile,pszFile);
+
+      // discard function arguments
+
+      if((pStr = strrchr(szFunc,'(')) != NULL)
+      {
+        *(pStr +1) = ')';
+        *(pStr +2) = '\0';
+      }
+
+      // cut path from file name
+
+      if((pStr = strrchr(szFile,'\\')) != NULL)
+        strcpy(szFile,pStr +1);
+
+      // cut file name extension
+
+      if((pStr = strrchr(szFile,'.')) != NULL)
+        *pStr = '\0';
+
+      /* get pointer to first argument */
+
+      ulLen += sprintf(szBuffer + ulLen,"%-16s(%4d): ",szFile,sLine);
+
+      va_start(arg_ptr,pszFormat);
+
+      /* print into buffer */
+
+      ulLen += vsprintf(szBuffer + ulLen,pszFormat,arg_ptr);
+
+      va_end(arg_ptr);
+
+      ulLen += sprintf(szBuffer + ulLen,"\n");
+
+      // write everything and close
+
+      fwrite(szBuffer,ulLen,sizeof(char),fp);
+      fclose(fp);
+    }
+
+    return;
+}
+
+/****************************************************************************
+
+ FUNCTION:  static void initDataSeg()
+
+ COMMENTS:  Initialize data seg vars.
+
+ DATE:      08-Jun-1998, 15:02:13
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+static void initDataSeg()
+{
+int i;
+
+    for(i = 0; i < M_MAX_DEVICES; i++)
+    {
+      mProcesses[i].ulSessionID    = 0L;
+      mProcesses[i].ulProcessID    = 0L;
+      mProcesses[i].fKeepAlive     = 0L;
+      mProcesses[i].fCleanupCalled = 0L;
+      mProcesses[i].fStartupCalled = 0L;
+
+      lMProcess[i] = 0L;
+    }
+
+    hmtxSocketSem   = 0;
+    hmtxTraceSem    = 0;
+    hmtxShMemSem    = 0;
+    hmtxServices    = 0;
+    lAccess         = 0;
+    lTerminate      = 0;
+    lStartProcess   = 0;
+    lServicesUp     = 0;
+    iSystemReboot   = 1;
+    fMInUse         = false;
+
+    lMagic         = MAGIC_ID;
+
+    return;
+}
+
+/****************************************************************************
+
+ FUNCTION:  int mTerminate()
+
+ COMMENTS:  Return value of termination flag.
+
+ DATE:      03/04/97 - 10:08:15
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+int mTerminate()
+{
+    return(lTerminate == MAGIC_ID);
+}
+
+/****************************************************************************
+
+ FUNCTION:  int mInUse()
+
+ COMMENTS:  Return value of usage flag.
+
+ DATE:      03/04/97 - 10:08:15
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+int mInUse()
+{
+    return(fMInUse);
+}
+
+/****************************************************************************
+
+ FUNCTION:  void setMInUse(bool fSet)
+
+ COMMENTS:  Set/reset usage flag.
+
+ DATE:      03/04/97 - 10:08:15
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+void setMInUse(bool fSet)
+{
+    fMInUse = fSet;
+    return;
+}
+
+/****************************************************************************
+
+ FUNCTION:  static long mRebootNT()
+
+ COMMENTS:  System shutdown & reboot (WINNT)
+
+ DATE:      10-29-97, 9:13 AM
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+static long mRebootNT()
+{
+char             szTmp[256];
+mConfig          exec("MUTILS","REBOOT","ExecuteBefore");
+char             szMachineName[MAX_COMPUTERNAME_LENGTH+1];
+DWORD            dwLen = MAX_COMPUTERNAME_LENGTH+1;
+HANDLE           hProcess;
+HANDLE           hToken;
+TOKEN_PRIVILEGES Privileges;
+LUID             BootLUID;
+
+    mStopProgs();
+    OS_Sleep(20000);
+
+    if(!exec.error())
+    {
+      exec.asString(szTmp,sizeof(szTmp));
+
+      if(access(szTmp,0) == 0)
+      {
+        debugWrite(HERE,"post exec: %s",szTmp);
+
+        if(!system(szTmp))
+          OS_Sleep(20000);
+      }
+      else
+        debugWrite(HERE,"post exec [%s] not found.",szTmp);
+    }
+
+    debugWrite(HERE,"shutdown(0)");
+
+    // reboot now!
+
+    if(!GetComputerName(szMachineName,&dwLen))
+      return(-1);
+
+    hProcess = GetCurrentProcess();
+
+    if(!OpenProcessToken(hProcess,TOKEN_WRITE,&hToken))
+      return(-1);
+
+    if(!LookupPrivilegeValue((LPCTSTR)NULL,SE_SHUTDOWN_NAME,&BootLUID))
+      return(-1);
+
+    Privileges.PrivilegeCount = 1;
+    Privileges.Privileges[0].Luid = BootLUID;
+    Privileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
+
+    if(!AdjustTokenPrivileges(hToken,false,&Privileges,0,NULL,NULL))
+      return(-1);
+
+    if(!InitiateSystemShutdown(szMachineName,NULL,0,true,true))
+      return(-1);
+
+    return(0);
+}
+
+/****************************************************************************
+
+ FUNCTION:  LONG mRebootRemote()
+
+ COMMENTS:  System shutdown & reboot.
+
+ DATE:      10/18/96 - 14:52:08
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+LONG mRebootRemote(byte   bLevel,
+                            char  *pszFile,
+                            short  sLine,
+                            char  *pszFunction,
+                            bool   fCheckOnly)
+{
+
+mConfig exec("MUTILS","REBOOT","ExecuteBefore");
+
+    if(mInUse())
+    {
+      debugWrite(HERE,"remote reboot rejected.\ncall: %s, %d",pszFile,sLine);
+      return(-1);
+    }
+
+    if(!fCheckOnly)
+    {
+
+      mRebootNT();
+
+      debugWrite(HERE,"remote reboot.\ncall: %s, %d",pszFile,sLine);
+    }
+
+    return(0);
+}
+
+/****************************************************************************
+
+ FUNCTION:  void mForcedReboot()
+
+ COMMENTS:  System forced shutdown & reboot. (NT only)
+
+ DATE:      16-Jul-1998, 14:13:33
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+void mForcedReboot(byte   bLevel,
+                   char  *pszFile,
+                   short  sLine,
+                   char  *pszFunction)
+{
+char             szMachineName[MAX_COMPUTERNAME_LENGTH+1];
+HANDLE           hToken;
+HANDLE           hProcess;
+LUID             DebugValue;
+LUID             BootLUID;
+TOKEN_PRIVILEGES tkp;
+APIRET           rc;
+LONG             i;
+TIB             *pTib;
+PIB             *pPib;
+DWORD            dwLen = sizeof(szMachineName);
+
+    // Retrieve a handle of the access token
+
+    if(!OpenProcessToken(GetCurrentProcess(),
+                         TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
+                         &hToken))
+    {
+      debugWrite(HERE,"OpenProcessToken failed with %d\n", GetLastError());
+      return;
+    }
+
+    // Enable the SE_DEBUG_NAME privilege
+
+    if(!LookupPrivilegeValue((LPSTR) NULL,SE_DEBUG_NAME,&DebugValue))
+    {
+      debugWrite(HERE,"LookupPrivilegeValue failed with %d\n", GetLastError());
+      return;
+    }
+
+    tkp.PrivilegeCount           = 1;
+    tkp.Privileges[0].Luid       = DebugValue;
+    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
+
+    AdjustTokenPrivileges(hToken,
+                          false,
+                          &tkp,
+                          sizeof(TOKEN_PRIVILEGES),
+                          (PTOKEN_PRIVILEGES) NULL,
+                          (PDWORD) NULL);
+
+    // The return value of AdjustTokenPrivileges can't be tested
+
+    if(GetLastError() != ERROR_SUCCESS)
+    {
+      debugWrite(HERE,"AdjustTokenPrivileges failed with %d\n", GetLastError());
+      return;
+    }
+
+    rc = OS_GetInfoBlocks(&pTib,&pPib);
+
+    if(rc = GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT,0))
+      debugWrite(HERE,"CTRL-BREAK, rc = %ld",rc);
+
+    for(i = M_MAX_DEVICES -1; i >= 0 ; i--)
+    {
+      /* check which session to stop */
+
+      if(mProcesses[i].ulSessionID &&
+         mProcesses[i].ulProcessID != currentProcessId())
+      {
+        /* check which session to stop */
+
+        if(mProcesses[i].ulSessionID)
+        {
+          rc = OS_StopSession(STOP_SESSION_SPECIFIED, mProcesses[i].hProcess);
+
+          debugWrite(HERE,"OS_StopSession, Index = %ld, rc = %ld",i,rc);
+        }
+      }
+      else if(mProcesses[i].ulSessionID)
+        debugWrite(HERE,"no suicide for [%d]",i);
+    }
+
+    // reboot now!
+
+    if(!GetComputerName(szMachineName,&dwLen))
+      return;
+
+    hProcess = GetCurrentProcess();
+
+    if(!OpenProcessToken(hProcess,TOKEN_WRITE,&hToken))
+      return;
+
+    if(!LookupPrivilegeValue((LPCTSTR)NULL,SE_SHUTDOWN_NAME,&BootLUID))
+      return;
+
+    tkp.PrivilegeCount           = 1;
+    tkp.Privileges[0].Luid       = BootLUID;
+    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
+
+    if(!AdjustTokenPrivileges(hToken,false,&tkp,0,NULL,NULL))
+      return;
+
+    if(!InitiateSystemShutdown(szMachineName,NULL,0,true,true))
+      return;
+
+    return;
+}
+
+/****************************************************************************
+
+ FUNCTION:  void mReboot()
+
+ COMMENTS:  System shutdown & reboot.
+
+ DATE:      10/18/96 - 14:52:08
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+void mReboot(byte bLevel, char *pszFile, short sLine)
+{
+    if(!iSystemReboot || mInUse())
+    {
+      debugWrite(HERE,"system reboot rejected.\ncall: %s, %d",pszFile,sLine);
+      return;
+    }
+
+    mRebootNT();
+
+    debugWrite(HERE,"system reboot.\ncall: %s, %d",pszFile,sLine);
+
+    return;
+}
+
+/****************************************************************************
+
+ FUNCTION:  HMTX socketSem()
+
+ COMMENTS:  Return semaphore handle.
+
+ DATE:      10/08/96 - 16:35:26
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+HMTX socketSem()
+{
+    return(hmtxSocketSem);
+}
+
+/****************************************************************************
+
+ FUNCTION:  HMTX traceSem()
+
+ COMMENTS:  Return semaphore handle.
+
+ DATE:      10/08/96 - 16:35:26
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+HMTX traceSem()
+{
+    return(hmtxTraceSem);
+}
+
+/****************************************************************************
+
+ FUNCTION:  HMTX sharedMemSem()
+
+ COMMENTS:  Return semaphore handle.
+
+ DATE:      10/08/96 - 16:35:26
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+HMTX sharedMemSem()
+{
+    return(hmtxShMemSem);
+}
+
+/****************************************************************************
+
+ FUNCTION:  static long createServices()
+
+ COMMENTS:  Create all basic services.
+
+ DATE:      10/10/97 - 10:13:23
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+static long createServices()
+{
+long rc;
+
+    OS_GetInfoBlocks(&pStartTib,&pStartPib);
+
+    if(rc = OS_CreateMutexSem("\\SEM32\\MSOCKS.SEM",
+                              &hmtxSocketSem,
+                              DC_SEM_SHARED,
+                              false))
+    {
+      return(rc);
+    }
+
+    if(rc = OS_CreateMutexSem("\\SEM32\\MTRACE.SEM",
+                              &hmtxTraceSem,
+                              DC_SEM_SHARED,
+                              false))
+    {
+      return(rc);
+    }
+
+    if(rc = OS_CreateMutexSem("\\SEM32\\SHMEMM.SEM",
+                              &hmtxShMemSem,
+                              DC_SEM_SHARED,
+                              false))
+    {
+      return(rc);
+    }
+
+    if(rc = (long) mBasicServicesInit())
+      return(rc);
+    else
+    {
+      // set trace level according to value from M.CFG
+
+      mConfig level("MUTILS","TRACE","TraceLevel");
+    }
+
+    lServicesUp = 1;
+
+    return(0);
+}
+
+/****************************************************************************
+
+ FUNCTION:  static void deleteServices()
+
+ COMMENTS:  Delete all basic services.
+
+ DATE:      10/10/97 - 10:13:23
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+static void deleteServices()
+{
+    // delete all internal allocated resources
+
+    FreeConfiguration();
+
+    // TerminateTrace();
+
+    OS_CloseMutexSem(hmtxSocketSem);
+    OS_CloseMutexSem(hmtxTraceSem);
+    OS_CloseMutexSem(hmtxShMemSem);
+
+    lServicesUp = 0;
+
+    return;
+}
+/****************************************************************************
+
+ FUNCTION:  static void APIRET mBasicServicesTerm(void)
+
+ COMMENTS:  Do cleanup at DLL termination.
+
+ DATE:      11/23/95 - 15:24:13
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+static void APIENTRY mBasicServicesTerm(long ulReason)
+{
+APIRET rc;
+char   szTmp[100];
+char   szCmd[512];
+char  *pStr;
+TIB   *pTib;
+PIB   *pPib;
+
+    *szTmp = '\0';
+
+    rc = OS_GetInfoBlocks(&pTib,&pPib);
+
+    switch(ulReason)
+    {
+    default:
+
+         sprintf(szTmp,"UNKNOWN [%d]",ulReason);
+         break;
+
+    case TC_HARDERROR:
+
+         strcpy(szTmp,"TC_HARDERROR");
+         break;
+
+    case TC_TRAP:
+
+         strcpy(szTmp,"TC_TRAP");
+         break;
+
+    case TC_EXIT:
+
+         strcpy(szTmp,"TC_EXIT");
+         break;
+
+    case TC_KILLPROCESS:
+
+         strcpy(szTmp,"TC_KILLPROCESS");
+         break;
+
+    case TC_EXCEPTION:
+
+         strcpy(szTmp,"TC_EXCEPTION");
+         break;
+    }
+
+    if((pStr = strrchr(pPib->pib_pchcmd,'\\')) != NULL)
+      strcpy(szCmd,pStr +1);
+    else
+      strcpy(szCmd,pPib->pib_pchcmd);
+
+    debugWrite(HERE,"%s [%d,%d] [%d] %s",
+                     szTmp,
+                     currentProcessId(),
+                     pTib->tib_ptib2->tib2_ultid,
+                     pPib->pib_ulppid,
+                     szCmd);
+
+    if(ulReason == TC_EXCEPTION)
+      mReboot(HERE);
+
+    OS_ExitList(EXLST_EXIT,(PFNEXITLIST) mBasicServicesTerm);
+    return;
+}
+
+/****************************************************************************
+
+ FUNCTION:  static APIRET mBasicServicesInit(void)
+
+ COMMENTS:  Read configuration file and do initialisations at DLL startup.
+
+ DATE:      11/23/95 - 15:24:13
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+static APIRET mBasicServicesInit(void)
+{
+APIRET rc = 0;
+
+    if(rc = mUtilsReadConfig())
+      return(rc);
+
+    mConfig rmtDev ("MUTILS","RMTTRACE","ServerName");
+    mConfig trcDev ("MUTILS","RMTTRACE","DeviceName");
+    mConfig reboot ("MUTILS","REBOOT",  "RebootOnCrash");
+
+    if(!reboot.error())
+      iSystemReboot = reboot.asBool();
+
+    InitTrace();
+
+    return(0L);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   void scanArguments(char  *pszInput,
+//                                 long  *pulTimeOut,
+//                                 bool  *pfKeepAlive,
+//                                 bool  *pfShow,
+//                                 char  *pszArgs)
+//
+//  purpose:    scan for program arguments and start options
+//
+//  date:       08.08.2001, 08:56
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+void scanArguments(char  *pszInput,
+                   long  *pulTimeOut,
+                   bool  *pfKeepAlive,
+                   int   *piShow,
+                   char  *pszArgs)
+{
+char *pStr;
+
+    if((pStr = strrchr(pszInput,';')) != NULL)
+    {
+      *pStr = '\0';
+
+      strupr(++pStr);
+
+      // check for "show = XXXX" statement
+
+      if(strstr(pStr,"SHOW"))
+      {
+        if((pStr = strchr(pStr,'=')) != NULL)
+        {
+          pStr++;
+
+          if(strstr(pStr,"YES"))
+          {
+            *piShow = PROCESS_SHOW;
+          }
+          else if(strstr(pStr,"NO"))
+          {
+            *piShow = PROCESS_HIDE;
+          }
+          else if(strstr(pStr,"HIDE"))
+          {
+            *piShow = PROCESS_HIDE;
+          }
+          else if(strstr(pStr,"MINIMIZED"))
+          {
+            *piShow = PROCESS_MINIMIZED;
+          }
+        }
+        else
+         *piShow = PROCESS_SHOW;
+      }
+
+      // check for "wait = XXXX" statement
+
+      if(strstr(pStr,"WAIT"))
+      {
+        if((pStr = strchr(pStr,'=')) != NULL)
+        {
+          strlwr(++pStr);
+
+          if(strstr(pStr,"terminate"))
+          {
+            *pulTimeOut = -1;
+          }
+          else
+          {
+            // discard leading blanks
+
+            while(*pStr && *pStr <= '0')
+              pStr++;
+
+            if(*pStr)
+            {
+              *pulTimeOut = atol(pStr);
+
+              if(*pulTimeOut < 0)
+                *pulTimeOut *= -1;
+            }
+            else
+              *pulTimeOut = 0;
+          }
+        }
+      }
+    }
+
+    // scan for program arguments
+
+    debugWrite(HERE,"pszInput = %s",pszInput);
+
+    if((pStr = strchr(pszInput,'"')) != NULL)
+    {
+      pStr++;
+
+      while(*pStr && *pStr != '"')
+      {
+        *pszArgs++ = *pStr++;
+      }
+
+      *pszArgs = '\0';
+
+      debugWrite(HERE,"pszArgs = %s",pszArgs);
+
+    }
+    else
+    {
+      if((pStr = strrchr(pszInput,'\\')) != NULL)
+      {
+        while(*pStr && *pStr != ' ')
+          pStr++;
+
+        // cut off arguments from program name
+
+        //@@MaK 7-25-97, 4:20 PM
+
+        if(*pStr)
+        {
+          *pStr = '\0';
+
+          pStr++;
+
+          if(*pStr)
+          {
+            // save program arguments
+
+            strcpy(pszArgs,pStr);
+
+            pStr = pszArgs + strlen(pszArgs) -1;
+
+            while(*pStr <= ' ')
+            {
+              *pStr = '\0';
+              pStr--;
+            }
+          }
+        }
+      }
+    }
+}
+
+/****************************************************************************
+
+ FUNCTION:  APIRET mStartProgs(void);
+
+ COMMENTS:  Starts programs specified in M.CFG
+
+ DATE:      12/06/95 - 10:51:21
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+APIRET mStartProgs(void)
+{
+STARTDATA StartData;
+char      szProgName[1024];
+char      szProgArgs[256];
+char      szTmp     [256];
+long      i;
+long      ulSessionID;
+long      ulTimeOut;
+bool      fKeepAlive;
+int       iShow;
+PID       ProcID;
+HANDLE    ProcHandle;
+APIRET    rc;
+TIB      *pTib;
+PIB      *pPib;
+
+mConfig Config;
+
+    rc = OS_GetInfoBlocks(&pTib,&pPib);
+
+    lStartProcess = currentProcessId();
+
+    StartData.Length      = 32;
+    StartData.Related     = SSF_RELATED_CHILD;
+    StartData.FgBg        = SSF_FGBG_BACK;
+    StartData.TraceOpt    = SSF_TRACEOPT_NONE;
+    StartData.PgmTitle    = NULL;
+    StartData.TermQ       = NULL;
+    StartData.Environment = NULL;
+    StartData.InheritOpt  = SSF_INHERTOPT_PARENT;
+    StartData.SessionType = SSF_TYPE_PM;
+
+    debugWrite(HERE_9,"********** MUTILS Session start **********");
+
+    for(i = 0; i < M_MAX_DEVICES; i++)
+    {
+       ulTimeOut  = 0L;
+      *szProgArgs = '\0';
+
+      /* build search item */
+
+      sprintf(szTmp,M_STARTDEVICE_ID,i);
+
+      /* search configuration */
+
+      if(!Config.readValue(M_STARTDEVICES,szTmp))
+      {
+        //@@MaK7-25-97, 4:11 PM
+
+        memset(szProgName,0,sizeof(szProgName));
+
+        Config.asString(szProgName,sizeof(szProgName));
+
+        scanArguments(szProgName,&ulTimeOut,&fKeepAlive,&iShow,szProgArgs);
+
+        StartData.PgmName   = szProgName;
+        StartData.PgmInputs = (byte*)szProgArgs;
+
+        if(ulTimeOut < 0)
+        {
+          // start and wait for this process
+
+          if(rc = OS_ExecWait(&StartData,iShow))
+          {
+            debugWrite(HERE,"Can't execute: %s, rc = %ld\n",szProgName,rc);
+          }
+        }
+        else
+        {
+          if(rc = OS_StartSession(&StartData,(unsigned long *)&ulSessionID,&ProcID,&ProcHandle,iShow))
+          {
+            debugWrite(HERE,"Can't start: %s, rc = %ld\n",szProgName,rc);
+
+            /* reset session identifier */
+
+            mProcesses[i].ulSessionID = 0;
+          }
+          else
+          {
+            /* store session identifier */
+
+            debugWrite(HERE,"Device started: %s, Index = %ld, SID = %ld, PID = %ld",
+                                   szProgName,i,ulSessionID,ProcID);
+
+            mProcesses[i].ulSessionID = ulSessionID;
+            mProcesses[i].ulProcessID = ProcID;
+            mProcesses[i].hProcess    = ProcHandle;
+            mProcesses[i].fKeepAlive  = fKeepAlive;
+
+            if(ulTimeOut)
+            {
+              debugWrite(HERE,"waiting: %d ms",ulTimeOut);
+
+              OS_Sleep(ulTimeOut);
+            }
+          }
+        }
+      }
+    }
+
+    return(0L);
+}
+
+/****************************************************************************
+
+ FUNCTION:  APIRET mStopProgs(void);
+
+ COMMENTS:  Stops all started programs.
+
+ DATE:      12/06/95 - 10:51:21
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+APIRET mStopProgs(void)
+{
+APIRET  rc;
+TIB    *pTib;
+PIB    *pPib;
+char    szPath[512];
+
+    GetModuleFileName(NULL,szPath,sizeof(szPath));
+
+    debugWrite(HERE,"StopProgs: pid = %d",currentProcessId());
+    debugWrite(HERE,"StopProgs: %s",szPath);
+
+    rc = OS_GetInfoBlocks(&pTib,&pPib);
+
+    // give all attached services a chance to clear resources
+
+    if(currentProcessId() != lStartProcess)
+    {
+       lTerminate = MAGIC_ID;
+
+       while(lServicesUp)
+       {
+         // wait if it's not possible at the moment !!
+
+         OS_Sleep(2000);
+       }
+
+       // reset for next start of application
+
+       lTerminate = 0;
+
+       initDataSeg();
+
+       // restart all MUTILS services
+
+       createServices();
+
+       // this the new start process now !!
+
+       lStartProcess = currentProcessId();
+
+       setMInUse(false);
+
+       return(0L);
+    }
+    else
+      stopProcesses();
+
+    return(0L);
+}
+
+
+// class definition ---------------------------------------------------------
+
+static int initDone= 0;
+
+    MassaiLibraryInitTerm::MassaiLibraryInitTerm()
+    {
+#if defined (SSD_CODELIB)
+      if(initDone == 0)
+      {
+        long rc;
+
+          if(sock_init() > 0)
+            setStartupCalled(currentProcessId());
+
+          rc = createServices();
+      }
+      if(initDone >= 0)
+        initDone++;
+#endif
+    }
+
+    MassaiLibraryInitTerm::~MassaiLibraryInitTerm()
+    {
+#if defined (SSD_CODELIB)
+        if(initDone != 0)
+          initDone--;
+        if(initDone == 0)
+        {
+          deleteServices();
+
+          if(!cleanupCalled(currentProcessId()) &&
+              startupCalled(currentProcessId())    )
+          {
+            debugWrite(HERE_9,"calling WSACleanup(%d)",currentProcessId());
+
+            switch(WSACleanup())
+            {
+            case WSAEINPROGRESS:
+
+                 while(WSACancelBlockingCall() != WSAEINVAL)
+                   debugWrite(HERE,"WSACleanUp repeated, pid = %d",currentProcessId());
+
+                 WSACleanup();
+                 break;
+
+            default:
+                 break;
+            }
+
+            setCleanupCalled(currentProcessId());
+          }
+          else
+            debugWrite(HERE,"discarded WSACleanup(%d), startupCalled() = %d",
+                         currentProcessId(),
+                         startupCalled(currentProcessId()));
+         }
+#endif
+    }
+    void MassaiLibraryInitTerm::ref()
+    {}
+
+#if defined (SSD_CODELIB)
+#else
+
+/****************************************************************************
+
+ FUNCTION:  unsigned long __stdcall _DLL_InitTerm(unsigned long  hModule,
+                                                  unsigned long  ulFlag,
+                                                  long          *dummy)
+
+ COMMENTS:  First function called when DLL is loaded.
+
+ DATE:      11/30/95 - 10:24:26
+
+ AUTHOR:    Dr. Materna GmbH   (MaK/AGe)
+
+****************************************************************************/
+
+bool MASSAI_DLLEXPORT WINAPI DllMain(HINSTANCE hModule,DWORD ulFlag, void *lpvReserved)
+{
+long   rc = 0;
+char    szPath[512];
+WORD    wVersionRequested = MAKEWORD(1,1);
+
+   switch(ulFlag)
+   {
+   case DLL_PROCESS_ATTACH:
+        {
+          sock_init();
+
+          mBasicServicesInit();
+
+          GetModuleFileName(NULL,szPath,sizeof(szPath));
+
+          debugWrite(HERE,"attach: lAccess = %d, pid = %d, %s",lAccess,currentProcessId(),szPath);
+
+        }
+        break;
+
+   case DLL_PROCESS_DETACH :
+        {
+          GetModuleFileName(NULL,szPath,sizeof(szPath));
+
+          debugWrite(HERE,"detach: lAccess = %d, pid = %d, %s",lAccess,currentProcessId(),szPath);
+
+          switch(WSACleanup())
+          {
+          case WSAEINPROGRESS:
+
+               while(WSACancelBlockingCall() != WSAEINVAL)
+                 debugWrite(HERE,"WSACleanUp repeated, pid = %d",currentProcessId());
+
+               WSACleanup();
+               break;
+
+          default:
+               break;
+          }
+
+        }
+        break;
+
+   case DLL_THREAD_ATTACH :
+
+        return 1;
+        break;
+
+   case DLL_THREAD_DETACH :
+
+        return 1;
+        break;
+
+   default:
+
+        return 0;
+        break;
+   }
+
+   /* A non-zero value must be returned to indicate success.                */
+
+   return 1;
+}
+
+#endif // M_CODELIB
diff --git a/Massai/cpp/MassaiDLL/static/src/mbasicrefs.cpp b/Massai/cpp/MassaiDLL/static/src/mbasicrefs.cpp
new file mode 100644
index 00000000..9ea6ae35
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/static/src/mbasicrefs.cpp
@@ -0,0 +1,78 @@
+//---------------------------------------------------------------------------
+//
+//  file:       mbsaicRefss.cpp
+//
+//  purpose:    class implementation
+//
+//  date:       05.09.00, 14:14
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include <string.h>
+
+#include "massai.hpp"
+
+#define APPREF     "-r:"
+#define DISPIOR    "-d:"
+#define APPMGRIOR  "-a:"
+
+//---------------------------------------------------------------------------
+//
+//  function:   mBasicRefs::mBasicRefs(INT argc, CHAR **argv)
+//
+//  purpose:    class contructor
+//
+//  date:       05.09.00, 14:20
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+mBasicRefs::mBasicRefs(INT argc, CHAR **argv)
+{
+CHAR *pStr;
+BOOL  fDone;
+INT   i;
+
+    *szAppRef  = '\0';
+    *szAppMgr  = '\0';
+    *szDisplay = '\0';
+
+    if(argc > 1)
+    {
+      for(i = 1, fDone = FALSE; i < argc && ! fDone; i++)
+        if((pStr = strstr(argv[i],APPREF)) != NULL)
+        {
+          pStr += strlen(APPREF);
+
+          while(*pStr && *pStr == ' ')
+            pStr++;
+
+          strcpy(szAppRef,pStr);
+        }
+
+      for(i = 1, fDone = FALSE; i < argc && ! fDone; i++)
+        if((pStr = strstr(argv[i],DISPIOR)) != NULL)
+        {
+          pStr += strlen(DISPIOR);
+
+          while(*pStr && *pStr == ' ')
+            pStr++;
+
+          strcpy(szDisplay,pStr);
+        }
+
+      for(i = 1, fDone = FALSE; i < argc && ! fDone; i++)
+        if((pStr = strstr(argv[i],APPMGRIOR)) != NULL)
+        {
+          pStr += strlen(APPMGRIOR);
+
+          while(*pStr && *pStr == ' ')
+            pStr++;
+
+          strcpy(szAppMgr,pStr);
+        }
+    }
+}
\ No newline at end of file
diff --git a/Massai/cpp/MassaiDLL/static/src/mhandler.cpp b/Massai/cpp/MassaiDLL/static/src/mhandler.cpp
new file mode 100644
index 00000000..ebedf120
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/static/src/mhandler.cpp
@@ -0,0 +1,329 @@
+//---------------------------------------------------------------------------
+//
+//  file:       mhandler.cpp
+//
+//  purpose:    provide window handling
+//
+//  date:       13.10.99, 16:09
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+#include "mhandler.hpp"
+
+mThread *mHandler::pPoster    = NULL;
+ULONG      mHandler::ulCnt      = 0;
+ULONG      mHandler::ulLanguage = 0;
+
+typedef struct _meventlist
+        {
+          struct _meventlist *pNext;
+          mEvent             *pEvent;
+        }
+        MEVENT_LIST;
+
+static MEVENT_LIST *pEvents       = NULL;
+static MEVENT_LIST *pEventsLast   = NULL;
+
+static HMTX         hmtxPoster    = 0;
+static HEV          hevEvent      = 0;
+
+//---------------------------------------------------------------------------
+//
+//  function:   ULONG ticker(ULONG pHandler)
+//
+//  purpose:    hread function for timer
+//
+//  date:       13.10.99, 16:29
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+ULONG ticker(ULONG pHandler)
+{
+mHandler *p = (mHandler *)pHandler;
+mEvent    e(mEvent::ME_TIMER,0,0);
+
+  OS_Sleep(p->millis());
+
+  if(!p->timerStopped())
+    p->timerHandler(e);
+
+  return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   VOID mHandler::startTimer(ULONG ulMillis)
+//
+//  purpose:    start a new timer
+//
+//  date:       13.10.99, 16:29
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+VOID mHandler::startTimer(ULONG ulMillis)
+{
+  if(pTimer)
+  {
+    fTimerStopped = TRUE;
+
+    stopTimer();
+  }
+
+  this->ulMillis = ulMillis;
+
+  fTimerStopped = FALSE;
+
+  pTimer = new mThread(ticker,(ULONG) this);
+
+  pTimer->run();
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   VOID mHandler::stopTimer()
+//
+//  purpose:    stop & delet current timer thread
+//
+//  date:       13.10.99, 16:29
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+VOID mHandler::stopTimer()
+{
+   if(pTimer)
+   {
+     fTimerStopped = TRUE;
+
+     pTimer->stop();
+
+     delete pTimer;
+     pTimer = NULL;
+   }
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   ULONG poster(ULONG pHandler)
+//
+//  purpose:    thread function
+//
+//  date:       13.10.99, 16:28
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+PRIVATE ULONG poster(ULONG pHandler)
+{
+MEVENT_LIST *pl;
+mEvent      *p;
+ULONG        rc;
+ULONG        ulCntSem;
+
+  OS_WaitEventSem(hevEvent,-1);
+  OS_ResetEventSem(hevEvent,&ulCntSem);
+
+  rc = OS_RequestMutexSem(hmtxPoster,-1L);
+
+  if(pEvents)
+  {
+    pl = pEvents;
+
+    pEvents = pEvents->pNext;
+
+    p = pl->pEvent;
+
+    switch(p->id())
+    {
+    case mEvent::ME_SYSCOM:   p->receiver()->syscomHandler  (*p); break;
+    case mEvent::ME_SELECT:   p->receiver()->controlHandler (*p); break;
+    case mEvent::ME_TIMER:    p->receiver()->timerHandler   (*p); break;
+    case mEvent::ME_ACTIVATE: p->receiver()->activateHandler(*p); break;
+    case mEvent::ME_COMMAND:  p->receiver()->commandHandler (*p); break;
+    }
+
+    delete p;
+
+    free(pl);
+  }
+
+  rc = OS_ReleaseMutexSem(hmtxPoster);
+
+  return(0);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   BOOL mHandler::postEvent(mEvent event)
+//
+//  purpose:    post event to handler
+//
+//  date:       13.10.99, 16:28
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+BOOL mHandler::postEvent(mEvent event)
+{
+  return(postEvent(this,event));
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   BOOL mHandler::postEvent(mHandler* pTo, mEvent event)
+//
+//  purpose:    post event to handler
+//
+//  date:       13.10.99, 16:28
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+BOOL mHandler::postEvent(mHandler* pTo, mEvent event)
+{
+ULONG        rc;
+MEVENT_LIST *pl;
+
+  pl = (MEVENT_LIST *) malloc(sizeof(MEVENT_LIST));
+
+  if(pl)
+  {
+    pl->pNext  = NULL;
+    pl->pEvent = new mEvent(pTo,(mEvent::ME_ID) event.id(),event.param1(),event.param2());
+
+    rc = OS_RequestMutexSem(hmtxPoster,-1L);
+
+    if(pEvents == NULL)
+      pEvents = pEventsLast = pl;
+    else
+      pEventsLast->pNext = pl;
+
+    rc = OS_ReleaseMutexSem(hmtxPoster);
+
+    OS_PostEventSem(hevEvent);
+
+    return(TRUE);
+  }
+  else
+    return(FALSE);
+
+}
+
+VOID mHandler::activate()
+{
+    mEvent e(mEvent::ME_ACTIVATE,TRUE,0);
+
+    activateHandler(e);
+    return;
+}
+
+VOID mHandler::deactivate()
+{
+    mEvent e(mEvent::ME_ACTIVATE,FALSE,0);
+
+    activateHandler(e);
+    return;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   mHandler::mHandler(mHandler* pOwner)
+//
+//  purpose:    class constructor
+//
+//  date:       13.10.99, 16:27
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+mHandler::mHandler(mHandler* pOwner)
+{
+ULONG rc;
+
+   ulId         = 0;
+   pTimer       = NULL;
+   ulId         = 0;
+   this->pOwner = pOwner;
+
+   if(!ulCnt && pPoster == NULL)
+   {
+     rc = OS_CreateMutexSem(NULL,&hmtxPoster,DC_SEM_SHARED,FALSE);
+     rc = OS_CreateEventSem(NULL,&hevEvent,DC_SEM_SHARED,FALSE);
+
+     pPoster = new mThread(poster);
+
+     pPoster->run();
+   }
+
+   ulCnt++;
+
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   mHandler::mHandler()
+//
+//  purpose:    class constructor
+//
+//  date:       13.10.99, 16:27
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+mHandler::mHandler()
+{
+ULONG rc;
+
+   ulId   = 0;
+   pTimer = NULL;
+   ulId   = 0;
+   pOwner = this;
+
+   if(!ulCnt && pPoster == NULL)
+   {
+     rc = OS_CreateMutexSem(NULL,&hmtxPoster,DC_SEM_SHARED,FALSE);
+     rc = OS_CreateEventSem(NULL,&hevEvent,DC_SEM_SHARED,FALSE);
+
+     pPoster = new mThread(poster);
+
+     pPoster->run();
+   }
+
+   ulCnt++;
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   mHandler::mHandler()
+//
+//  purpose:    class destructor
+//
+//  date:       13.10.99, 16:28
+//
+//  author:     Dr. Materna GmbH (AGe)
+//
+//---------------------------------------------------------------------------
+
+mHandler::~mHandler()
+{
+   ulCnt--;
+
+   if(!ulCnt && pPoster != NULL)
+     delete pPoster;
+
+   OS_CloseMutexSem(hmtxPoster);
+
+}
+
diff --git a/Massai/cpp/MassaiDLL/static/src/mvsprintf.cpp b/Massai/cpp/MassaiDLL/static/src/mvsprintf.cpp
new file mode 100644
index 00000000..90d871a8
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/static/src/mvsprintf.cpp
@@ -0,0 +1,679 @@
+/*
+ *  linux/lib/vsprintf.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+/* vsprintf.c -- Lars Wirzenius & Linus Torvalds. */
+/*
+ * Wirzenius wrote this portably, Torvalds fucked it up :-)
+ */
+
+/*
+ * Fri Jul 13 2001 Crutcher Dunnavant <crutcher+kernel@datastacks.com>
+ * - changed to provide snprintf and vsnprintf functions
+ */
+
+#include <limits.h>
+#include <stdarg.h>
+#include <string.h>
+#include <ctype.h>
+
+static int strnlen(const char * s, size_t count)
+{
+  const char *sc;
+
+  for (sc = s; count-- && *sc != '\0'; ++sc)
+    /* nothing */;
+  return sc - s;
+}
+
+/**
+ * simple_strtoul - convert a string to an unsigned long
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+unsigned long simple_strtoul(const char *cp,char **endp,unsigned int base)
+{
+        unsigned long result = 0,value;
+
+        if (!base) {
+                base = 10;
+                if (*cp == '0') {
+                        base = 8;
+                        cp++;
+                        if ((*cp == 'x') && isxdigit(cp[1])) {
+                                cp++;
+                                base = 16;
+                        }
+                }
+        }
+        while (isxdigit(*cp) &&
+               (value = isdigit(*cp) ? *cp-'0' : toupper(*cp)-'A'+10) < base) {
+                result = result*base + value;
+                cp++;
+        }
+        if (endp)
+                *endp = (char *)cp;
+        return result;
+}
+
+/**
+ * simple_strtol - convert a string to a signed long
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+long simple_strtol(const char *cp,char **endp,unsigned int base)
+{
+        if(*cp=='-')
+                return(-1 * simple_strtoul(cp+1,endp,base));
+        return simple_strtoul(cp,endp,base);
+}
+
+static int skip_atoi(const char **s)
+{
+        int i=0;
+
+        while (isdigit(**s))
+                i = i*10 + *((*s)++) - '0';
+        return i;
+}
+
+#define ZEROPAD 1               /* pad with zero */
+#define SIGN    2               /* unsigned/signed long */
+#define PLUS    4               /* show plus */
+#define SPACE   8               /* space if plus */
+#define LEFT    16              /* left justified */
+#define SPECIAL 32              /* 0x */
+#define LARGE   64              /* use 'ABCDEF' instead of 'abcdef' */
+
+static char * number(char * buf, char * end, long num, int base, int size, int precision, int type)
+{
+        char c,sign,tmp[66],*pbuf;
+        const char *digits;
+        static const char small_digits[] = "0123456789abcdefghijklmnopqrstuvwxyz";
+        static const char large_digits[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
+        int i;
+
+        pbuf = buf;
+
+        digits = (type & LARGE) ? large_digits : small_digits;
+        if (type & LEFT)
+                type &= ~ZEROPAD;
+        if (base < 2 || base > 36)
+                return 0;
+        c = (type & ZEROPAD) ? '0' : ' ';
+        sign = 0;
+        if (type & SIGN) {
+                if (num < 0) {
+                        sign = '-';
+                        num = -num;
+                        size--;
+                } else if (type & PLUS) {
+                        sign = '+';
+                        size--;
+                } else if (type & SPACE) {
+                        sign = ' ';
+                        size--;
+                }
+        }
+        if (type & SPECIAL) {
+                if (base == 16)
+                        size -= 2;
+                else if (base == 8)
+                        size--;
+        }
+        i = 0;
+        if (num == 0)
+                tmp[i++]='0';
+        else while (num != 0)
+        {
+                tmp[i++] = digits[num%base];
+                num /= base;
+        }
+        if (i > precision)
+                precision = i;
+        size -= precision;
+        if (!(type&(ZEROPAD+LEFT))) {
+                while(size-->0) {
+                        if (buf <= end)
+                                *buf = ' ';
+                        ++buf;
+                }
+        }
+        if (sign) {
+                if (buf <= end)
+                        *buf = sign;
+                ++buf;
+        }
+        if (type & SPECIAL) {
+                if (base==8) {
+                        if (buf <= end)
+                                *buf = '0';
+                        ++buf;
+                } else if (base==16) {
+                        if (buf <= end)
+                                *buf = '0';
+                        ++buf;
+                        if (buf <= end)
+                                *buf = digits[33];
+                        ++buf;
+                }
+        }
+        if (!(type & LEFT)) {
+                while (size-- > 0) {
+                        if (buf <= end)
+                                *buf = c;
+                        ++buf;
+                }
+        }
+        while (i < precision--) {
+                if (buf <= end)
+                        *buf = '0';
+                ++buf;
+        }
+        while (i-- > 0) {
+                if (buf <= end)
+                        *buf = tmp[i];
+                ++buf;
+        }
+        while (size-- > 0) {
+                if (buf <= end)
+                        *buf = ' ';
+                ++buf;
+        }
+        return buf;
+}
+
+/**
+* vsnprintf - Format a string and place it in a buffer
+* @buf: The buffer to place the result into
+* @size: The size of the buffer, including the trailing null space
+* @fmt: The format string to use
+* @args: Arguments for the format string
+*
+* Call this function if you are already dealing with a va_list.
+* You probably want snprintf instead.
+ */
+int m_vsnprintf(char *buf, size_t size, const char *fmt, va_list args)
+{
+        int len;
+        unsigned long num;
+        int i, base;
+        char *str, *end, c;
+        const char *s;
+
+        int flags;              /* flags to number() */
+
+        int field_width;        /* width of output field */
+        int precision;          /* min. # of digits for integers; max
+                                   number of chars for from string */
+        int qualifier;          /* 'h', 'l', or 'L' for integer fields */
+                                /* 'z' support added 23/7/1999 S.H.    */
+                                /* 'z' changed to 'Z' --davidm 1/25/99 */
+
+        str = buf;
+        end = buf + size - 1;
+
+        if (end < buf - 1) {
+                end = ((char *) -1);
+                size = end - buf + 1;
+        }
+
+        for (; *fmt ; ++fmt) {
+                if (*fmt != '%') {
+                        if (str <= end)
+                                *str = *fmt;
+                        ++str;
+                        continue;
+                }
+
+                /* process flags */
+                flags = 0;
+                repeat:
+                        ++fmt;          /* this also skips first '%' */
+                        switch (*fmt) {
+                                case '-': flags |= LEFT; goto repeat;
+                                case '+': flags |= PLUS; goto repeat;
+                                case ' ': flags |= SPACE; goto repeat;
+                                case '#': flags |= SPECIAL; goto repeat;
+                                case '0': flags |= ZEROPAD; goto repeat;
+                        }
+
+                /* get field width */
+                field_width = -1;
+                if (isdigit(*fmt))
+                        field_width = skip_atoi(&fmt);
+                else if (*fmt == '*') {
+                        ++fmt;
+                        /* it's the next argument */
+                        field_width = va_arg(args, int);
+                        if (field_width < 0) {
+                                field_width = -field_width;
+                                flags |= LEFT;
+                        }
+                }
+
+                /* get the precision */
+                precision = -1;
+                if (*fmt == '.') {
+                        ++fmt;
+                        if (isdigit(*fmt))
+                                precision = skip_atoi(&fmt);
+                        else if (*fmt == '*') {
+                                ++fmt;
+                                /* it's the next argument */
+                                precision = va_arg(args, int);
+                        }
+                        if (precision < 0)
+                                precision = 0;
+                }
+
+                /* get the conversion qualifier */
+                qualifier = -1;
+                if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' || *fmt =='Z') {
+                        qualifier = *fmt;
+                        ++fmt;
+                        if (qualifier == 'l' && *fmt == 'l') {
+                                qualifier = 'L';
+                                ++fmt;
+                        }
+                }
+
+                /* default base */
+                base = 10;
+
+                switch (*fmt) {
+                        case 'c':
+                                if (!(flags & LEFT)) {
+                                        while (--field_width > 0) {
+                                                if (str <= end)
+                                                        *str = ' ';
+                                                ++str;
+                                        }
+                                }
+                                c = (unsigned char) va_arg(args, int);
+                                if (str <= end)
+                                        *str = c;
+                                ++str;
+                                while (--field_width > 0) {
+                                        if (str <= end)
+                                                *str = ' ';
+                                        ++str;
+                                }
+                                continue;
+
+                        case 's':
+                                s = va_arg(args, char *);
+                                if (!s)
+                                        s = "<NULL>";
+
+                                len = strnlen(s, precision);
+
+                                if (!(flags & LEFT)) {
+                                        while (len < field_width--) {
+                                                if (str <= end)
+                                                        *str = ' ';
+                                                ++str;
+                                        }
+                                }
+                                for (i = 0; i < len; ++i) {
+                                        if (str <= end)
+                                                *str = *s;
+                                        ++str; ++s;
+                                }
+                                while (len < field_width--) {
+                                        if (str <= end)
+                                                *str = ' ';
+                                        ++str;
+                                }
+                                continue;
+
+                        case 'p':
+                                if (field_width == -1) {
+                                        field_width = 2*sizeof(void *);
+                                        flags |= ZEROPAD;
+                                }
+                                str = number(str, end,
+                                                (unsigned long) va_arg(args, void *),
+                                                16, field_width, precision, flags);
+                                continue;
+
+
+                        case 'n':
+                                /* FIXME:
+                                * What does C99 say about the overflow case here? */
+                                if (qualifier == 'l') {
+                                        long * ip = va_arg(args, long *);
+                                        *ip = (str - buf);
+                                } else if (qualifier == 'Z') {
+                                        size_t * ip = va_arg(args, size_t *);
+                                        *ip = (str - buf);
+                                } else {
+                                        int * ip = va_arg(args, int *);
+                                        *ip = (str - buf);
+                                }
+                                continue;
+
+                        case '%':
+                                if (str <= end)
+                                        *str = '%';
+                                ++str;
+                                continue;
+
+                                /* integer number formats - set up the flags and "break" */
+                        case 'o':
+                                base = 8;
+                                break;
+
+                        case 'X':
+                                flags |= LARGE;
+                        case 'x':
+                                base = 16;
+                                break;
+
+                        case 'd':
+                        case 'i':
+                                flags |= SIGN;
+                        case 'u':
+                                break;
+
+                        default:
+                                if (str <= end)
+                                        *str = '%';
+                                ++str;
+                                if (*fmt) {
+                                        if (str <= end)
+                                                *str = *fmt;
+                                        ++str;
+                                } else {
+                                        --fmt;
+                                }
+                                continue;
+                }
+                if (qualifier == 'L')
+                        num = va_arg(args, long);
+                else if (qualifier == 'l') {
+                        num = va_arg(args, unsigned long);
+                        if (flags & SIGN)
+                                num = (signed long) num;
+                } else if (qualifier == 'Z') {
+                        num = va_arg(args, size_t);
+                } else if (qualifier == 'h') {
+                        num = (unsigned short) va_arg(args, int);
+                        if (flags & SIGN)
+                                num = (signed short) num;
+                } else {
+                        num = va_arg(args, unsigned int);
+                        if (flags & SIGN)
+                                num = (signed int) num;
+                }
+                str = number(str, end, num, base,
+                                field_width, precision, flags);
+        }
+        if (str <= end)
+                *str = '\0';
+        else if (size > 0)
+                /* don't write out a null byte if the buf size is zero */
+                *end = '\0';
+        /* the trailing null byte doesn't count towards the total
+        * ++str;
+        */
+        return str-buf;
+}
+
+/**
+ * snprintf - Format a string and place it in a buffer
+ * @buf: The buffer to place the result into
+ * @size: The size of the buffer, including the trailing null space
+ * @fmt: The format string to use
+ * @...: Arguments for the format string
+ */
+int m_snprintf(char * buf, size_t size, const char *fmt, ...)
+{
+        va_list args;
+        int i;
+
+        va_start(args, fmt);
+        i=m_vsnprintf(buf,size,fmt,args);
+        va_end(args);
+        return i;
+}
+
+/**
+ * vsprintf - Format a string and place it in a buffer
+ * @buf: The buffer to place the result into
+ * @fmt: The format string to use
+ * @args: Arguments for the format string
+ *
+ * Call this function if you are already dealing with a va_list.
+ * You probably want sprintf instead.
+ */
+int m_vsprintf(char *buf, const char *fmt, va_list args)
+{
+        return m_vsnprintf(buf, 0xFFFFFFFFUL, fmt, args);
+}
+
+
+/**
+ * sprintf - Format a string and place it in a buffer
+ * @buf: The buffer to place the result into
+ * @fmt: The format string to use
+ * @...: Arguments for the format string
+ */
+int m_sprintf(char * buf, const char *fmt, ...)
+{
+        va_list args;
+        int i;
+
+        va_start(args, fmt);
+        i=m_vsprintf(buf,fmt,args);
+        va_end(args);
+        return i;
+}
+
+/**
+ * vsscanf - Unformat a buffer into a list of arguments
+ * @buf:        input buffer
+ * @fmt:        format of buffer
+ * @args:       arguments
+ */
+int m_vsscanf(const char * buf, const char * fmt, va_list args)
+{
+        const char *str = buf;
+        char *next;
+        char digit;
+        int num = 0;
+        int qualifier;
+        int base;
+        int field_width = -1;
+        int is_sign = 0;
+
+        while(*fmt && *str) {
+                /* skip any white space in format */
+                /* white space in format matchs any amount of
+                 * white space, including none, in the input.
+                 */
+                if (isspace(*fmt)) {
+                        while (isspace(*fmt))
+                                ++fmt;
+                        while (isspace(*str))
+                                ++str;
+                }
+
+                /* anything that is not a conversion must match exactly */
+                if (*fmt != '%' && *fmt) {
+                        if (*fmt++ != *str++)
+                                break;
+                        continue;
+                }
+
+                if (!*fmt)
+                        break;
+                ++fmt;
+
+                /* skip this conversion.
+                 * advance both strings to next white space
+                 */
+                if (*fmt == '*') {
+                        while (!isspace(*fmt) && *fmt)
+                                fmt++;
+                        while (!isspace(*str) && *str)
+                                str++;
+                        continue;
+                }
+
+                /* get field width */
+                if (isdigit(*fmt))
+                        field_width = skip_atoi(&fmt);
+
+                /* get conversion qualifier */
+                qualifier = -1;
+                if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' || *fmt == 'Z') {
+                        qualifier = *fmt;
+                        fmt++;
+                }
+                base = 10;
+                is_sign = 0;
+
+                if (!*fmt || !*str)
+                        break;
+
+                switch(*fmt++) {
+                case 'c':
+                {
+                        char *s = (char *) va_arg(args,char*);
+                        if (field_width == -1)
+                                field_width = 1;
+                        do {
+                                *s++ = *str++;
+                        } while(field_width-- > 0 && *str);
+                        num++;
+                }
+                continue;
+                case 's':
+                {
+                        char *s = (char *) va_arg(args, char *);
+                        if(field_width == -1)
+                                field_width = INT_MAX;
+                        /* first, skip leading white space in buffer */
+                        while (isspace(*str))
+                                str++;
+
+                        /* now copy until next white space */
+                        while (*str && !isspace(*str) && field_width--) {
+                                *s++ = *str++;
+                        }
+                        *s = '\0';
+                        num++;
+                }
+                continue;
+                case 'n':
+                        /* return number of characters read so far */
+                {
+                        int *i = (int *)va_arg(args,int*);
+                        *i = str - buf;
+                }
+                continue;
+                case 'o':
+                        base = 8;
+                        break;
+                case 'x':
+                case 'X':
+                        base = 16;
+                        break;
+                case 'i':
+                        base = 0;
+                case 'd':
+                        is_sign = 1;
+                case 'u':
+                        break;
+                case '%':
+                        /* looking for '%' in str */
+                        if (*str++ != '%')
+                                return num;
+                        continue;
+                default:
+                        /* invalid format; stop here */
+                        return num;
+                }
+
+                /* have some sort of integer conversion.
+                 * first, skip white space in buffer.
+                 */
+                while (isspace(*str))
+                        str++;
+
+                digit = *str;
+                if (is_sign && digit == '-')
+                        digit = *(str + 1);
+
+                if (!digit
+                    || (base == 16 && !isxdigit(digit))
+                    || (base == 10 && !isdigit(digit))
+                    || (base == 8 && (!isdigit(digit) || digit > '7'))
+                    || (base == 0 && !isdigit(digit)))
+                                break;
+
+                switch(qualifier) {
+                case 'h':
+                        if (is_sign) {
+                                short *s = (short *) va_arg(args,short *);
+                                *s = (short) simple_strtol(str,&next,base);
+                        } else {
+                                unsigned short *s = (unsigned short *) va_arg(args, unsigned short *);
+                                *s = (unsigned short) simple_strtoul(str, &next, base);
+                        }
+                        break;
+                case 'l':
+                        if (is_sign) {
+                                long *l = (long *) va_arg(args,long *);
+                                *l = simple_strtol(str,&next,base);
+                        } else {
+                                unsigned long *l = (unsigned long*) va_arg(args,unsigned long*);
+                                *l = simple_strtoul(str,&next,base);
+                        }
+                        break;
+                case 'Z':
+                {
+                        size_t *s = (size_t*) va_arg(args,size_t*);
+                        *s = (size_t) simple_strtoul(str,&next,base);
+                }
+                break;
+                default:
+                        if (is_sign) {
+                                int *i = (int *) va_arg(args, int*);
+                                *i = (int) simple_strtol(str,&next,base);
+                        } else {
+                                unsigned int *i = (unsigned int*) va_arg(args, unsigned int*);
+                                *i = (unsigned int) simple_strtoul(str,&next,base);
+                        }
+                        break;
+                }
+                num++;
+
+                if (!next)
+                        break;
+                str = next;
+        }
+        return num;
+}
+
+/**
+ * sscanf - Unformat a buffer into a list of arguments
+ * @buf:        input buffer
+ * @fmt:        formatting of buffer
+ * @...:        resulting arguments
+ */
+int m_sscanf(const char * buf, const char * fmt, ...)
+{
+        va_list args;
+        int i;
+
+        va_start(args,fmt);
+        i = m_vsscanf(buf,fmt,args);
+        va_end(args);
+        return i;
+}
\ No newline at end of file
diff --git a/Massai/cpp/MassaiDLL/static/src/trace.cpp b/Massai/cpp/MassaiDLL/static/src/trace.cpp
new file mode 100644
index 00000000..0b91eed7
--- /dev/null
+++ b/Massai/cpp/MassaiDLL/static/src/trace.cpp
@@ -0,0 +1,1072 @@
+/****************************************************************************
+
+ FILE:      trace.cpp
+
+ PURPOSE:   MUTILS - trace functionality.
+
+ DATE:      11/28/95 - 14:43:05
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+#include <io.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <iostream.h>
+
+#include "base_os.h"
+#include "massai.hpp"
+#include "globbase.hpp"
+#include "mConfig.h"
+#include "trace.hpp"
+#include "compress.h"
+#include "mThread.hpp"
+
+/* private constants *********************************************************/
+
+#define MAGIC_ID          1234567
+#define MAX_TRACE_BUF     (1024L * 128L)
+#define MAX_FILE_SIZE     (1024L * 2048L)
+#define MAX_HISTORY_LEVEL  9
+
+#define MUTILS_PRIORITY   PRTYC_TIMECRITICAL
+
+// global vars for this file -----------------------------------------------
+
+PRIVATE CHAR      *pszFunction = "";  // not used anymore for tracing
+
+PRIVATE CHAR       szTrcDevice[256];
+PRIVATE CHAR       szRemote[CHARBUF];
+PRIVATE BOOL       fExtendedTrace    = FALSE;
+PRIVATE BOOL       fDoTrace          = FALSE;
+PRIVATE ULONG      ulMaxHistoryLevel = MAX_HISTORY_LEVEL;
+PRIVATE HFILE      hComTrace         = 0;
+PRIVATE BOOL       fSaveTrace        = FALSE;
+PRIVATE CHAR       szTraceBuf[MAX_TRACE_BUF];
+PRIVATE ULONG      ulBytesToWrite;
+PRIVATE USHORT     usPort;
+
+PRIVATE TID        tidTraceThread     = 0;
+PRIVATE TID        tidFileTraceThread = 0;
+PRIVATE HEV        hevTCPIPWrite;
+PRIVATE HEV        hevTCPIPWritten;
+PRIVATE HEV        hevFileWrite;
+PRIVATE HEV        hevFileWritten;
+
+PRIVATE mConfig rmtTrcServer;
+
+// private function prototypes----------------------------------------------
+
+PRIVATE ULONG tcpipWriteThread  (ULONG);
+PRIVATE ULONG debugWriteThread  (ULONG);
+PRIVATE ULONG WriteToFile       (HFILE, VOID *, ULONG, ULONG *);
+
+
+
+#define SADDAM
+
+//---------------------------------------------------------------------------
+//
+//  function:   static char *byte2Hex(int x)
+//
+//  purpose:
+//
+//  date:       02.12.2002, 10:58
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+static char *byte2Hex(int x)
+{
+static char szTmp[3];
+int x1,x2;
+
+    x &= 0xff;
+
+    x1 = (x / 16);
+    x2 = (x % 16);
+
+    szTmp[0] = x1 < 10 ? '0' + (char) x1 : 'a' + (char) (x1 - 10);
+    szTmp[1] = x2 < 10 ? '0' + (char) x2 : 'a' + (char) (x2 - 10);
+
+    szTmp[2] = '\0';
+
+    return(szTmp);
+}
+
+//---------------------------------------------------------------------------
+//
+//  function:   static char *byte2HEX(int x)
+//
+//  purpose:
+//
+//  date:       02.12.2002, 10:58
+//
+//  author:     Materna Information & Communications (AGe)
+//
+//---------------------------------------------------------------------------
+
+static char *byte2HEX(int x)
+{
+static char szTmp[3];
+int x1,x2;
+
+    x &= 0xff;
+
+    x1 = (x / 16);
+    x2 = (x % 16);
+
+    szTmp[0] = x1 < 10 ? '0' + (char) x1 : 'A' + (char) (x1 - 10);
+    szTmp[1] = x2 < 10 ? '0' + (char) x2 : 'A' + (char) (x2 - 10);
+
+    szTmp[2] = '\0';
+
+    return(szTmp);
+}
+
+EXPORT VOID debugWrite(BYTE bLevel,CHAR *pszFile,SHORT sLine,CHAR *pszFormat, ...)
+{
+#if defined(SADDAM)
+
+static mConfig traceLevel("MUTILS","TRACE","TraceLevel");
+
+APIRET    rc = 0;
+DATETIME  Date;
+ULONG     ulLen;
+ULONG     ulDump;
+ULONG     ulTmp;
+TIB      *pTib;
+PIB      *pPib;
+CHAR     *pTmp;
+CHAR     *pArg;
+CHAR     *pStr;
+CHAR      szFile[CHARBUF];
+CHAR      szFunc[CHARBUF];
+
+va_list   arg_ptr;
+
+    OS_GetInfoBlocks(&pTib,&pPib);
+
+    if(bLevel <= traceLevel.asInt() || bLevel == 255)
+    {
+      // serialize writing to trace file
+
+      if((pTmp = (CHAR*) malloc(MAX_TRACE_BUF)) == NULL) // XXX
+      {
+        return;
+      }
+
+      /* write traces with date and time */
+
+      OS_GetDateTime(&Date);
+
+      memset(pTmp,0,MAX_TRACE_BUF);
+
+      ulLen = ulTmp = 0;
+
+      if(*szTrcDevice)
+        ulTmp = ulLen = sprintf(pTmp,"[%s] ",szTrcDevice);
+
+      ulLen += sprintf(pTmp + ulLen,"%02d%02d %02d%02d:%02d.%02d ",
+                           Date.day,
+                           Date.month,
+                           Date.hours,
+                           Date.minutes,
+                           Date.seconds,
+                           Date.hundredths);
+
+      /* check given arguments */
+
+      if(pszFile && pszFunction && pszFormat)
+      {
+        strcpy(szFunc,pszFunction);
+        strcpy(szFile,pszFile);
+
+        if(fExtendedTrace)
+        {
+          // write with complete pathname
+
+          ulLen += sprintf(pTmp + ulLen,"%s (%4d), %s\n",pszFile,sLine,pszFunction);
+        }
+        else
+        {
+          // discard function arguments
+
+          if((pStr = strrchr(szFunc,'(')) != NULL)
+          {
+            *(pStr +1) = ')';
+            *(pStr +2) = '\0';
+          }
+
+          // cut path from file name
+
+          if((pStr = strrchr(szFile,'\\')) != NULL)
+            strcpy(szFile,pStr +1);
+
+          // cut file name extension
+
+          if((pStr = strrchr(szFile,'.')) != NULL)
+            *pStr = '\0';
+
+          ulLen += sprintf(pTmp + ulLen,"%-16s(%4d): ",szFile,sLine);
+        }
+
+        if(*pszFormat == '%' && *(pszFormat +1) == 'T')
+        {
+          // comes from mTrace.dump() -> copy only !!
+
+          va_start(arg_ptr,pszFormat);
+
+          // get pointer to first argument
+
+          pArg = (CHAR *)va_arg(arg_ptr,PCHAR);
+
+          // get length of dump
+
+          ulDump = (ULONG) va_arg(arg_ptr,ULONG);
+
+          /* copy to buffer */
+
+          strcpy(pTmp + ulLen,pArg);
+
+          ulLen += ulDump;
+
+          va_end(arg_ptr);
+        }
+        else
+        {
+          /* get pointer to first argument */
+
+          va_start(arg_ptr,pszFormat);
+
+          /* print into buffer */
+
+          ulLen += vsprintf(pTmp + ulLen,pszFormat,arg_ptr);
+
+          va_end(arg_ptr);
+        }
+
+        if(fExtendedTrace)
+          ulLen += sprintf(pTmp + ulLen,"\n\n");
+        else
+          ulLen += sprintf(pTmp + ulLen,"\n");
+      }
+      else
+        ulLen = sprintf(pTmp,"<< INVALID TRACE >>");
+
+      *(pTmp + ulLen) = '\0';
+
+      if(ulTmp)
+        OutputDebugString((CHAR *)(pTmp + ulTmp));
+      else
+        OutputDebugString((CHAR *)pTmp);
+
+      free(pTmp);
+    }
+
+#endif
+
+    return;
+}
+
+EXPORT VOID debugDump (BYTE bLevel,CHAR *pszFile,SHORT sLine,CHAR *pszFunction,BYTE *pData,USHORT usLen)
+{
+static mConfig traceLevel("MUTILS","TRACE","TraceLevel");
+USHORT    i,j;
+SHORT     rc;
+CHAR     *pTmp;
+ULONG     ulSize;
+
+    if(bLevel <= traceLevel.asInt() || bLevel == 255)
+    {
+      ulSize = ((usLen >> 4) +1) * 80;
+
+      if(!pData || !usLen || ulSize > MAX_TRACE_BUF -128)
+        return;
+
+      if((pTmp = (CHAR*) malloc(ulSize)) == NULL) // XXX
+        return;
+
+      rc = sprintf(pTmp,"%c",'\n');
+
+      for(i = 0; i < usLen; i += 16)
+      {
+        rc += sprintf(pTmp +rc,"[%04x,%04d] ",i,i);
+
+        for(j = 0; j < 16 && (i+j) < usLen; j++)
+        {
+          if(j == 8)
+            rc += sprintf(pTmp + rc,"- %s ",byte2Hex(pData[i+j]));
+          else
+            rc += sprintf(pTmp + rc,"%s ",byte2Hex(pData[i+j]));
+        }
+
+        while(j < 16)
+        {
+          if(j == 8)
+            rc += sprintf(pTmp + rc,"     ");
+          else
+            rc += sprintf(pTmp + rc,"   ");
+
+          j++;
+        }
+
+        for(j = 0; j < 16 && (i+j) < usLen; j++)
+          rc += sprintf(pTmp + rc,"%c",(pData[i+j] >= ' ') ? pData[i+j]: '.');
+
+        rc += sprintf(pTmp + rc,"\n");
+      }
+
+      debugWrite(bLevel,pszFile,sLine,pszFunction,"%T",pTmp,rc);
+
+      free(pTmp);
+    }
+
+    return;
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE APIRET addToHistory(CHAR *pszFile)
+
+ COMMENTS:  Adds file to history list.
+
+ DATE:      10/10/96 - 15:54:39
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+APIRET addToHistory(CHAR *pszFile)
+{
+CHAR     *pStr;
+CHAR      szFile[CHARBUF];
+CHAR      szRen [CHARBUF];
+APIRET    rc;
+BOOL      fDone;
+ULONG     i;
+
+    // anything to do ??
+
+    if(!pszFile || !*pszFile)
+      return(-1L);
+
+    strcpy(szFile,pszFile);
+    strcpy(szRen, pszFile);
+
+    // first check if the max level reached
+
+    if((pStr = strrchr(szFile,'.')) != NULL)
+      sprintf((pStr+1),"%03d",ulMaxHistoryLevel);
+
+    if(!access(szFile,0))
+    {
+      // max history level reached !!
+
+      if((pStr = strrchr(szFile,'.')) != NULL)
+      {
+        sprintf((pStr+1),"%03d",0);
+
+        // delete oldest file first
+
+        rc = OS_Delete(szFile);
+      }
+
+      // make all remaining files one level lower
+
+      for(i = 0; i < ulMaxHistoryLevel; i++)
+      {
+        if((pStr = strrchr(szRen,'.')) != NULL)
+          sprintf((pStr+1),"%03d",i);
+
+        if((pStr = strrchr(szFile,'.')) != NULL)
+          sprintf((pStr+1),"%03d",i+1);
+
+        rc = OS_Move(szFile,szRen);
+      }
+    }
+    else
+    {
+      // find most actual level
+
+      for(i = 0, fDone = FALSE; !fDone ; i++)
+      {
+        if((pStr = strrchr(szFile,'.')) != NULL)
+          sprintf((pStr+1),"%03d",i);
+
+        if(access(szFile,0))
+          fDone = TRUE;
+      }
+
+      // count variables are never correct after loops :(
+
+      i--;
+    }
+
+    // make $$$ file the most recent level
+
+    if((pStr = strrchr(szRen,'.')) != NULL)
+      sprintf((pStr+1),"%03d",i);
+
+    rc = OS_Move(pszFile,szRen);
+
+    return(rc);
+}
+
+/****************************************************************************
+
+ FUNCTION:  VOID InitTrace(VOID)
+
+ COMMENTS:  Initializes traces.
+
+ DATE:      05/08/96 - 10:06:59
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+VOID InitTrace()
+{
+mConfig extendedTrace("MUTILS","TRACE","ExtendedTrace");
+mConfig maxHistory   ("MUTILS","TRACE","HistoryLevel");
+
+    fExtendedTrace    = FALSE;
+    fDoTrace          = FALSE;
+    ulMaxHistoryLevel = MAX_HISTORY_LEVEL;
+    hComTrace         = 0;
+    fSaveTrace        = FALSE;
+
+    if(!extendedTrace.error() && extendedTrace.asBool())
+      fExtendedTrace = TRUE;
+
+    if(!maxHistory.error())
+      ulMaxHistoryLevel = (ULONG) maxHistory.asInt();
+
+
+    return;
+}
+
+/****************************************************************************
+
+ METHOD:    BYTE mTrace::getLevel(VOID)
+
+ COMMENTS:  Returns trace level.
+
+ DATE:      11/29/95 - 12:18:05
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+BYTE mTrace::getLevel(VOID)
+{
+  return(bTraceLevel);
+}
+
+/****************************************************************************
+
+ METHOD:    VOID mTrace::setLevel(BYTE bNewLevel)
+
+ COMMENTS:  Set new trace level for this instance.
+
+ DATE:      11/29/95 - 12:18:05
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+VOID mTrace::setLevel(BYTE bNewLevel)
+{
+CHAR   szBuffer[CHARBUF];
+ULONG  ulWritten;
+APIRET rc;
+
+  bTraceLevel = (bNewLevel > 9) ? 9 : bNewLevel;  // set new level
+
+  if(hTraceFile)
+  {
+    sprintf(szBuffer,"DEVID(%d), VER(%s), NEW-LEVEL(%u)\n\n",ulDeviceID,
+                                                             szVersion,
+                                                             bTraceLevel);
+
+    rc = WriteToFile(hTraceFile,szBuffer,strlen(szBuffer),&ulWritten);
+  }
+}
+
+/****************************************************************************
+
+ METHOD:    VOID mTrace::resetLevel(VOID)
+
+ COMMENTS:  Resets trace level to initial level of this instance.
+
+ DATE:      11/29/95 - 12:18:05
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+VOID mTrace::resetLevel(VOID)
+{
+CHAR   szBuffer[CHARBUF];
+ULONG  ulWritten;
+APIRET rc;
+
+  bTraceLevel = bOldTraceLevel;  // reset to previous level
+
+  if(hTraceFile)
+  {
+    sprintf(szBuffer,"DEVID(%d), VER(%s), NEW-LEVEL(%u)\n\n",ulDeviceID,
+                                                             szVersion,
+                                                             bTraceLevel);
+
+    rc = WriteToFile(hTraceFile,szBuffer,strlen(szBuffer),&ulWritten);
+  }
+}
+
+/****************************************************************************
+
+ METHOD:    VOID mTrace::reset()
+
+ COMMENTS:  Close old and open new trace file.
+
+ DATE:      10/11/96 - 14:05:43
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+VOID mTrace::reset()
+{
+    if(!hTraceFile)
+      return;
+
+    // close current file
+
+    if(ulError = CloseTraceFile())
+    {
+      return;
+    }
+
+    // open new trace file
+
+    ulError = OpenTraceFile(szTraceFileName);
+
+    return;
+}
+
+/****************************************************************************
+
+ METHOD:    VOID mTrace::init (ULONG ulDevID,BYTE bLevel,CHAR *pszDevVersion)
+
+ COMMENTS:  Explicit init function (also called from constructor)
+
+ DATE:      05/09/96 - 11:22:53
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+VOID mTrace::init(ULONG ulDevID, BYTE bLevel,CHAR *pszDevVersion,CHAR *pszTraceFileName)
+{
+TIB   *pTib;
+PIB   *pPib;
+
+    OS_GetInfoBlocks(&pTib,&pPib);
+
+    ulPID = pPib->pib_ulpid;
+
+    /* check if already initialized */
+
+    if(hTraceFile)
+      CloseTraceFile();
+
+    *szRemotePipe = '\0';
+
+    hTraceFile     = 0L;
+    ulError        = 0L;
+
+    ulDeviceID     = ulDevID;
+    bTraceLevel    = (bLevel > 9) ? 9 : bLevel;
+    bOldTraceLevel = bTraceLevel;  // save for reset
+
+    if(pszDevVersion && *pszDevVersion)
+      strcpy(szVersion,pszDevVersion);
+    else
+      strcpy(szVersion,"Version string missing !!");
+
+    if(pszTraceFileName && *pszTraceFileName)
+    {
+      strcpy(szTraceFileName,pszTraceFileName);
+
+      if(!strrchr(szTraceFileName,'.'))
+        strcat(szTraceFileName,".trc");
+    }
+    else
+      sprintf(szTraceFileName,"%08lx.trc",ulDevID);
+
+    ulError = OpenTraceFile(szTraceFileName);
+
+    return;
+}
+
+/****************************************************************************
+
+ METHOD:    mTrace::mTrace (ULONG ulDevID,BYTE bLevel,CHAR *pszDevVersion)
+
+ COMMENTS:  Constructor for trace class.
+
+ DATE:      11/29/95 - 12:18:05
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+mTrace::mTrace(ULONG ulDevID,BYTE bLevel,CHAR *pszDevVersion,CHAR *pszTraceFileName)
+{
+    hTraceFile  = 0;
+
+    init(ulDevID,bLevel,pszDevVersion,pszTraceFileName);
+    return;
+}
+
+/****************************************************************************
+
+ METHOD:    mTrace::~mTrace (VOID)
+
+ COMMENTS:  Destructor for trace class.
+
+ DATE:      11/29/95 - 12:18:05
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+mTrace::~mTrace (VOID)
+{
+    OS_CloseMutexSem(hmtxSem);
+
+    CloseTraceFile();
+
+    ulDeviceID       = 0L;
+    bTraceLevel      = 0;
+    bOldTraceLevel   = 0;
+    hTraceFile       = 0;
+
+    *szVersion       = '\0';
+    *szTraceFileName = '\0';
+}
+
+/****************************************************************************
+
+ METHOD:    APIRET mTrace::OpenTraceFile(CHAR *pszTraceFileName)
+
+ COMMENTS:  Opens the trace file
+
+ DATE:      11/29/95 - 12:41:22
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+APIRET mTrace::OpenTraceFile(CHAR *pszTraceFileName)
+{
+CHAR   szFile  [CHARBUF];
+CHAR   szRen   [CHARBUF];
+CHAR   szBuffer[CHARBUF];
+CHAR  *pStr;
+ULONG  ulAction;
+ULONG  ulWritten;
+APIRET rc;
+
+mConfig tracePath("MUTILS","TRACE","TracePath");
+
+    if(tracePath.error() != 0)
+    {
+      if(rc = QueryMUtilsPath(szFile))
+        return(rc);
+
+      if((pStr = strrchr(szFile,'\\')) != NULL)
+         *pStr = '\0';
+
+      strcat(szFile,"\\trc");
+    }
+    else
+      tracePath.asString(szFile,sizeof(szFile));
+
+    /* open file only if not already opened */
+
+    if(!hTraceFile)
+    {
+      /* make trace path if not exist */
+
+      strcpy(szRen,szFile);
+
+      if(access(szFile,0))
+        OS_MkDir(szFile,0L);
+
+      /* check if file already exists */
+
+      strcat(szFile,"\\");
+      strcat(szRen,"\\");
+
+      strcat(szFile,pszTraceFileName);
+      strcat(szRen,pszTraceFileName);
+
+      if((pStr = strrchr(szRen,'.')) != NULL)
+        strcpy(pStr+1,"$$$");
+
+      if(!access(szFile,0))
+      {
+        /* delete old saved file first */
+        COMPRESS compress;
+
+        rc = OS_Delete         (szRen);
+        rc = OS_Move           (szFile,szRen);
+        rc = compress.packFile (szRen);
+        rc = addToHistory      (szRen);
+      }
+
+      if(rc = OS_Open(szFile,
+                      &hTraceFile,
+                      &ulAction,
+                      0,
+                      FILE_NORMAL,
+                      OPEN_ACTION_REPLACE_IF_EXISTS |
+                      OPEN_ACTION_CREATE_IF_NEW,
+                      OPEN_SHARE_DENYNONE   |
+                      OPEN_ACCESS_READWRITE |
+                      OPEN_FLAGS_NOINHERIT,
+                      0))
+      {
+        return(ERR_TRC_FILE_NOT_OPENED);
+      }
+      else
+      {
+        sprintf(szBuffer,"DEVID(%d), VER(%s), INIT-LEVEL(%u)\n\n",ulDeviceID,
+                                                                  szVersion,
+                                                                  bTraceLevel);
+
+        rc = WriteToFile(hTraceFile,szBuffer,strlen(szBuffer),&ulWritten);
+      }
+    }
+
+    return(0L);
+}
+
+/****************************************************************************
+
+ METHOD:    APIRET mTrace::CloseTraceFile (VOID);
+
+ COMMENTS:  Closes trace file for this instance.
+
+ DATE:      11/29/95 - 12:52:24
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+APIRET mTrace::CloseTraceFile()
+{
+APIRET rc = 0;
+
+    /* close only if opened */
+
+    if(hTraceFile)
+      rc = OS_Close(hTraceFile);
+
+    hTraceFile = 0;
+
+    return(rc);
+}
+
+/****************************************************************************
+
+ METHOD: VOID mTrace::write(BYTE  bLevel,
+                              CHAR *pszFile,
+                              SHORT sLine,
+                              CHAR *pszFunction,
+                              CHAR *pszFormat,...)
+
+ COMMENTS:  Writes traces to disk.
+
+ DATE:      11/30/95 - 13:03:08
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+VOID mTrace::write(BYTE bLevel,CHAR *pszFile,SHORT sLine,CHAR *pszFunction,CHAR *pszFormat,...)
+{
+APIRET    rc = 0;
+DATETIME  Date;
+ULONG     ulWritten;
+ULONG     ulFileSize;
+ULONG     ulLen;
+ULONG     ulDump;
+ULONG     ulTmp;
+TIB      *pTib;
+PIB      *pPib;
+CHAR     *pTmp;
+CHAR     *pArg;
+CHAR     *pStr;
+CHAR      szFile[CHARBUF];
+CHAR      szFunc[CHARBUF];
+
+va_list   arg_ptr;
+
+    if(!this)
+    {
+      OutputDebugString("No this-pointer in mTrace::write()");
+      return;
+    }
+
+    OS_GetInfoBlocks(&pTib,&pPib);
+
+    /* look if trace file opened */
+
+    if((hTraceFile && bLevel <= bTraceLevel) || bLevel == 255)
+    {
+      // serialize writing to trace file
+
+      {
+        // wrap trace file if nessecary
+
+        rc = OS_SetFilePtr(hTraceFile,0L,FILE_END,&ulFileSize);
+
+        if(ulFileSize > MAX_FILE_SIZE)
+        {
+          CloseTraceFile();
+
+          if(rc = OpenTraceFile(szTraceFileName))
+          {
+            return;
+          }
+        }
+      }
+
+      if((pTmp = (CHAR*) malloc(MAX_TRACE_BUF)) == NULL) // XXX
+      {
+        ulError = 2003;
+
+        return;
+      }
+
+      /* write traces with date and time */
+
+      OS_GetDateTime(&Date);
+
+      memset(pTmp,0,MAX_TRACE_BUF);
+
+      ulLen = ulTmp = 0;
+
+      if(*szTrcDevice)
+        ulTmp = ulLen = sprintf(pTmp,"[%s] ",szTrcDevice);
+
+      ulLen += sprintf(pTmp + ulLen,"%02d%02d %02d%02d:%02d.%02d ",
+                           Date.day,
+                           Date.month,
+                           Date.hours,
+                           Date.minutes,
+                           Date.seconds,
+                           Date.hundredths);
+
+      /* check given arguments */
+
+      if(pszFile && pszFunction && pszFormat)
+      {
+        strcpy(szFunc,pszFunction);
+        strcpy(szFile,pszFile);
+
+        if(fExtendedTrace)
+        {
+          // write with complete pathname
+
+          ulLen += sprintf(pTmp + ulLen,"%s (%4d), %s\n",pszFile,sLine,pszFunction);
+        }
+        else
+        {
+          // discard function arguments
+
+          if((pStr = strrchr(szFunc,'(')) != NULL)
+          {
+            *(pStr +1) = ')';
+            *(pStr +2) = '\0';
+          }
+
+          // cut path from file name
+
+          if((pStr = strrchr(szFile,'\\')) != NULL)
+            strcpy(szFile,pStr +1);
+
+          // cut file name extension
+
+          if((pStr = strrchr(szFile,'.')) != NULL)
+            *pStr = '\0';
+
+          ulLen += sprintf(pTmp + ulLen,"%-16s(%4d): ",szFile,sLine);
+        }
+
+        if(*pszFormat == '%' && *(pszFormat +1) == 'T')
+        {
+          // comes from mTrace.dump() -> copy only !!
+
+          va_start(arg_ptr,pszFormat);
+
+          // get pointer to first argument
+
+          pArg = (CHAR *)va_arg(arg_ptr,PCHAR);
+
+          // get length of dump
+
+          ulDump = (ULONG) va_arg(arg_ptr,ULONG);
+
+          /* copy to buffer */
+
+          strcpy(pTmp + ulLen,pArg);
+
+          ulLen += ulDump;
+
+          va_end(arg_ptr);
+        }
+        else
+        {
+          /* get pointer to first argument */
+
+          va_start(arg_ptr,pszFormat);
+
+          /* print into buffer */
+
+          ulLen += vsprintf(pTmp + ulLen,pszFormat,arg_ptr);
+
+          va_end(arg_ptr);
+        }
+
+        if(fExtendedTrace)
+          ulLen += sprintf(pTmp + ulLen,"\n\n");
+        else
+          ulLen += sprintf(pTmp + ulLen,"\n");
+      }
+      else
+        ulLen = sprintf(pTmp,"<< INVALID TRACE >>");
+
+      *(pTmp + ulLen) = '\0';
+
+      // write everything to file (only if owner !!)
+
+      if(ulTmp)
+      {
+        OutputDebugString((CHAR *)(pTmp + ulTmp));
+        rc = WriteToFile(hTraceFile,(VOID *)(pTmp + ulTmp),ulLen - ulTmp,&ulWritten);
+      }
+      else
+      {
+        OutputDebugString((CHAR *)pTmp);
+        rc = WriteToFile(hTraceFile,(VOID *)pTmp,ulLen,&ulWritten);
+      }
+
+      free(pTmp);
+    }
+
+    return;
+}
+
+/****************************************************************************
+
+ FUNCTION:  PRIVATE ULONG WriteToFile (HFILE, VOID *, ULONG, ULONG *)
+
+ COMMENTS:  Write data to tracefile
+
+ DATE:      8-22-97, 10:45 AM
+
+ AUTHOR:    Dr. Materna GmbH   (MaK)
+
+****************************************************************************/
+
+PRIVATE ULONG WriteToFile (HFILE hFile, VOID *pData, ULONG ulLen, ULONG *pulWritten)
+{
+ULONG rc;
+
+  rc = OS_Write(hFile,pData,ulLen,pulWritten);
+  return rc;
+}
+
+/****************************************************************************
+
+ METHOD: VOID mTrace::dump (BYTE   bLevel,
+                              CHAR  *pszFile,
+                              SHORT  sLine,
+                              BYTE  *pData,
+                              USHORT usLen)
+
+ COMMENTS:  Writes hex dump to disk.
+
+ DATE:      12/04/95 - 16:33:24
+
+ AUTHOR:    Dr. Materna GmbH   (AGe)
+
+****************************************************************************/
+
+VOID mTrace::dump(BYTE bLevel,CHAR *pszFile,SHORT sLine,BYTE *pData, USHORT usLen)
+{
+USHORT    i,j;
+SHORT     rc;
+CHAR     *pTmp;
+ULONG     ulSize;
+
+    if(!this)
+    {
+      OutputDebugString("No this-pointer in mTrace::dump()");
+      return;
+    }
+
+    if((hTraceFile && bLevel <= bTraceLevel) || bLevel == 255)
+    {
+      ulSize = ((usLen >> 4) +1) * 80;
+
+      if(!pData || !usLen || ulSize > MAX_TRACE_BUF -128)
+        return;
+
+      if((pTmp = (CHAR*) malloc(ulSize)) == NULL) // XXX
+        return;
+
+      rc = sprintf(pTmp,"%c",'\n');
+
+      for(i = 0; i < usLen; i += 16)
+      {
+        rc += sprintf(pTmp +rc,"[%04x,%04d] ",i,i);
+
+        for(j = 0; j < 16 && (i+j) < usLen; j++)
+        {
+          if(j == 8)
+            rc += sprintf(pTmp + rc,"- %s ",byte2Hex(pData[i+j]));
+          else
+            rc += sprintf(pTmp + rc,"%s ",byte2Hex(pData[i+j]));
+        }
+
+        while(j < 16)
+        {
+          if(j == 8)
+            rc += sprintf(pTmp + rc,"     ");
+          else
+            rc += sprintf(pTmp + rc,"   ");
+
+          j++;
+        }
+
+        for(j = 0; j < 16 && (i+j) < usLen; j++)
+          rc += sprintf(pTmp + rc,"%c",(pData[i+j] >= ' ') ? pData[i+j]: '.');
+
+        rc += sprintf(pTmp + rc,"\n");
+      }
+
+      write(bLevel,pszFile,sLine,pszFunction,"%T",pTmp,rc);
+
+      free(pTmp);
+    }
+
+    return;
+}
-- 
2.41.0.windows.1

