From c5f7ff5a658f414e7a9183648afe1e0384f4843d Mon Sep 17 00:00:00 2001
From: jkreierh <jkreierh@90b65887-3827-0410-9a23-83215b262276>
Date: Thu, 2 Dec 2010 16:18:38 +0000
Subject: [PATCH 0064/1077] AEAParser

git-svn-id: svn://localhost/SelfServiceCommon/trunk@77 90b65887-3827-0410-9a23-83215b262276
---
 .../generic/fsm/mStateMachineTime.hpp         |  65 +-
 .../generic/fsm/mStateMachineTimeX.hpp        |   4 +-
 .../inc/AEAParser/aeaBagtagPectab.h           | 211 +++++
 .../inc/AEAParser/aeaBagtagPrintJob.h         |  43 +
 .../inc/AEAParser/aeaBoardingPassPectab.h     | 139 +++
 .../inc/AEAParser/aeaBoardingPassPrintJob.h   |  56 ++
 .../inc/AEAParser/aeaBoardingPassTemplate.h   | 137 +++
 .../Interfaces/inc/AEAParser/aeaCommonData.h  |  78 ++
 .../Interfaces/inc/AEAParser/aeaLogo.h        |  51 ++
 .../Interfaces/inc/AEAParser/aeaParse.h       |  54 ++
 .../inc/AEAParser/aeaPrintProcessor.h         |  61 ++
 .../Interfaces/inc/AEAParser/aeaReceipt.h     | 162 ++++
 .../Interfaces/inc/AEAParser/aeaResponse.h    |  75 ++
 .../Interfaces/inc/AEAParser/aeaSimulator.h   |  65 ++
 .../Interfaces/inc/AEAParser/aeaStatus.h      |  73 ++
 .../Interfaces/inc/AEAParser/aeaStock.h       |  72 ++
 .../Massai/cpp/AEAParser/inc/Console.h        | 110 +++
 .../cpp/AEAParser/inc/aeaBagTagResponse.h     |  42 +
 .../Massai/cpp/AEAParser/inc/aeaBinSetup.h    |  69 ++
 .../AEAParser/inc/aeaBoardingPassResponse.h   |  58 ++
 .../Massai/cpp/AEAParser/inc/aeaContext.h     |  93 ++
 .../AEAParser/inc/aeaSimulator_BagtagImpl.h   |  47 +
 .../inc/aeaSimulator_BoardingPassImpl.h       |  49 +
 .../cpp/AEAParser/inc/aeaSimulator_Impl.h     |  53 ++
 .../Massai/cpp/AEAParser/inc/aeaToken.h       |  88 ++
 .../Massai/cpp/AEAParser/inc/aeaTrack.h       |  31 +
 .../cpp/AEAParser/inc/decoder/AEAContext.h    | 277 ++++++
 .../cpp/AEAParser/inc/decoder/AEADecoder.h    |  66 ++
 .../cpp/AEAParser/inc/decoder/AEAPectab.h     | 145 +++
 .../cpp/AEAParser/inc/decoder/AEAReader.h     |  23 +
 .../Massai/cpp/AEAParser/makefile.mak         |  52 ++
 .../cpp/AEAParser/src/AEASimulatorTest.cpp    |  68 ++
 .../Massai/cpp/AEAParser/src/Console.cpp      | 230 +++++
 .../cpp/AEAParser/src/TestAEASimulator.cpp    | 204 +++++
 .../cpp/AEAParser/src/aeaBagtagPectab.cpp     | 822 +++++++++++++++++
 .../cpp/AEAParser/src/aeaBagtagResponse.cpp   | 109 +++
 .../Massai/cpp/AEAParser/src/aeaBinSetup.cpp  | 335 +++++++
 .../AEAParser/src/aeaBoardingPassPectab.cpp   | 706 +++++++++++++++
 .../AEAParser/src/aeaBoardingPassResponse.cpp | 220 +++++
 .../AEAParser/src/aeaBoardingPassTemplate.cpp | 494 +++++++++++
 .../Massai/cpp/AEAParser/src/aeaContext.cpp   | 606 +++++++++++++
 .../Massai/cpp/AEAParser/src/aeaData.cpp      |   5 +
 .../Massai/cpp/AEAParser/src/aeaLogo.cpp      |  96 ++
 .../Massai/cpp/AEAParser/src/aeaParse.cpp     |  36 +
 .../cpp/AEAParser/src/aeaPrintProcessor.cpp   |  72 ++
 .../Massai/cpp/AEAParser/src/aeaReceipt.cpp   | 121 +++
 .../Massai/cpp/AEAParser/src/aeaResponse.cpp  |  79 ++
 .../Massai/cpp/AEAParser/src/aeaSimulator.cpp | 110 +++
 .../AEAParser/src/aeaSimulator_BagtagImpl.cpp | 285 ++++++
 .../src/aeaSimulator_BoardingPassImpl.cpp     | 527 +++++++++++
 .../cpp/AEAParser/src/aeaSimulator_Impl.cpp   | 111 +++
 .../Massai/cpp/AEAParser/src/aeaToken.cpp     | 839 ++++++++++++++++++
 .../cpp/AEAParser/src/decoder/AEAContext.cpp  | 759 ++++++++++++++++
 .../cpp/AEAParser/src/decoder/AEADecoder.cpp  | 211 +++++
 .../cpp/AEAParser/src/decoder/AEAPectab.cpp   | 255 ++++++
 .../Massai/cpp/AEAParser/src/local_def.cpp    |  14 +
 56 files changed, 9835 insertions(+), 28 deletions(-)
 create mode 100644 SelfServiceCommon/Interfaces/inc/AEAParser/aeaBagtagPectab.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/AEAParser/aeaBagtagPrintJob.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/AEAParser/aeaBoardingPassPectab.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/AEAParser/aeaBoardingPassPrintJob.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/AEAParser/aeaBoardingPassTemplate.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/AEAParser/aeaCommonData.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/AEAParser/aeaLogo.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/AEAParser/aeaParse.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/AEAParser/aeaPrintProcessor.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/AEAParser/aeaReceipt.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/AEAParser/aeaResponse.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/AEAParser/aeaSimulator.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/AEAParser/aeaStatus.h
 create mode 100644 SelfServiceCommon/Interfaces/inc/AEAParser/aeaStock.h
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/inc/Console.h
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaBagTagResponse.h
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaBinSetup.h
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaBoardingPassResponse.h
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaContext.h
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaSimulator_BagtagImpl.h
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaSimulator_BoardingPassImpl.h
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaSimulator_Impl.h
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaToken.h
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaTrack.h
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/inc/decoder/AEAContext.h
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/inc/decoder/AEADecoder.h
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/inc/decoder/AEAPectab.h
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/inc/decoder/AEAReader.h
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/makefile.mak
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/src/AEASimulatorTest.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/src/Console.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/src/TestAEASimulator.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/src/aeaBagtagPectab.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/src/aeaBagtagResponse.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/src/aeaBinSetup.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/src/aeaBoardingPassPectab.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/src/aeaBoardingPassResponse.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/src/aeaBoardingPassTemplate.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/src/aeaContext.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/src/aeaData.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/src/aeaLogo.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/src/aeaParse.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/src/aeaPrintProcessor.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/src/aeaReceipt.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/src/aeaResponse.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/src/aeaSimulator.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/src/aeaSimulator_BagtagImpl.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/src/aeaSimulator_BoardingPassImpl.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/src/aeaSimulator_Impl.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/src/aeaToken.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/src/decoder/AEAContext.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/src/decoder/AEADecoder.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/src/decoder/AEAPectab.cpp
 create mode 100644 SelfServiceCommon/Massai/cpp/AEAParser/src/local_def.cpp

diff --git a/SelfServiceCommon/Interfaces/generic/fsm/mStateMachineTime.hpp b/SelfServiceCommon/Interfaces/generic/fsm/mStateMachineTime.hpp
index a9af89cc..f2ea3340 100644
--- a/SelfServiceCommon/Interfaces/generic/fsm/mStateMachineTime.hpp
+++ b/SelfServiceCommon/Interfaces/generic/fsm/mStateMachineTime.hpp
@@ -66,11 +66,8 @@ namespace StateMachine
       //! The place-specific timeout value, may be 0.
       unsigned M_Time;
 
-      //! Has a timeout value been set?
-      bool     M_Timing;
-
       //! The timeout event.
-      EVT      M_Event;
+      EVT *    M_Event;
 
    protected:
 
@@ -124,50 +121,68 @@ namespace StateMachine
       explicit timedPlace( char const * Name ) :
          place<EVT>( Name ),
          M_Time( 0 ),
-         M_Timing( false ),
-         M_Event()
+         M_Event( 0 )
       {
       }
 
       /**
        *
-       * Set the place timeout value
+       * Constructor.
        *
-       * @param Time:   The time to wait in ticks (0 = immediately).
+      **/
+      virtual ~timedPlace() throw()
+      {
+         try
+         {
+            delete M_Event;
+         }
+         catch( ... )
+         {
+         }
+      }
+
+      /**
        *
-       * @param Event:  The event to be generated upon timeout.
+       * Return the "event" attribute, which might have been set by
+       * the "timeout() method.
        *
-       * @return        A reference to this object.
+       * @return        A pointer to the "event" attribute or NULL.
        *
       **/
-      timedPlace<EVT> & timeout( unsigned Time, EVT const & Event )
+      EVT const * event() const
       {
-         M_Time = Time;
-         M_Timing = true;
-         M_Event = Event;
-         return *this;
+         return M_Event;
       }
 
       /**
        *
-       * Return an attribute, which has been set by the constructor.
+       * Set the place timeout value
+       *
+       * @param Time:   The time to wait in ticks (0 = immediately).
        *
-       * @return        A reference to the "event" attribute.
+       * @param Event:  The event to be generated upon timeout.
+       *
+       * @return        A reference to this object.
        *
       **/
-      EVT const & event() const
+      timedPlace<EVT> & timeout( unsigned Time, EVT const & Event )
       {
-         return M_Event;
+         M_Time = Time;
+         delete M_Event;
+         M_Event = new EVT( Event );
+         return *this;
       }
 
       /**
        *
        * Return an attribute, which has been set by the constructor.
+       * This method may be overloaded to e.g. provide a "dynamic"
+       * time value.
        *
        * @return        The "time" attribute.
        *
       **/
-      unsigned time() const
+      virtual unsigned time() const
       {
          return M_Time;
       }
@@ -182,7 +197,7 @@ namespace StateMachine
       **/
       bool timing() const
       {
-         return M_Timing;
+         return( M_Event != 0 );
       }
 
    private:
@@ -501,7 +516,7 @@ namespace StateMachine
       EVT const &
    ) const throw( inputException )
    {
-      if( M_Timing )
+      if( M_Event )
       {
          timedWalker<EVT> * W = dynamic_cast<timedWalker<EVT> *>( &TmWlk );
          if( !W )
@@ -520,13 +535,13 @@ namespace StateMachine
       EVT const &
    ) const throw( inputException )
    {
-      if( M_Timing )
+      if( M_Event )
       {
          timedWalker<EVT> * W = dynamic_cast<timedWalker<EVT> *>( &TmWlk );
          if( !W )
             throw inputException( S_TimedEx );
-         timedEvent<EVT> StartIt( this, M_Event );
-         W->timerStart( M_Time, StartIt );
+         timedEvent<EVT> StartIt( this, *M_Event );
+         W->timerStart( time(), StartIt );
       }
    }
 
diff --git a/SelfServiceCommon/Interfaces/generic/fsm/mStateMachineTimeX.hpp b/SelfServiceCommon/Interfaces/generic/fsm/mStateMachineTimeX.hpp
index a2a139fd..5c36d753 100644
--- a/SelfServiceCommon/Interfaces/generic/fsm/mStateMachineTimeX.hpp
+++ b/SelfServiceCommon/Interfaces/generic/fsm/mStateMachineTimeX.hpp
@@ -76,11 +76,9 @@ namespace StateMachine
       {
          timedPlace<EVT> const * CurrPlace =
             dynamic_cast<timedPlace<EVT> const *>( &currentPlace() );
-
-         timedEvent<EVT> StartIt( CurrPlace, CurrPlace->event() );
-
          if( CurrPlace && CurrPlace->timing() )
          {
+            timedEvent<EVT> StartIt( CurrPlace, *CurrPlace->event() );
             timerStart( ((time < 0) ? CurrPlace->time() : time), StartIt );
          }
       }
diff --git a/SelfServiceCommon/Interfaces/inc/AEAParser/aeaBagtagPectab.h b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaBagtagPectab.h
new file mode 100644
index 00000000..3ad8d77c
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaBagtagPectab.h
@@ -0,0 +1,211 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaBagtagPectab.h
+//
+//  purpose:    aea command data, pectab data structure for parsing baggage tag commands
+//
+//  date:       16.11.2010
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef AEABAGTAGPECTAB_H_INCLUDED
+#define AEABAGTAGPECTAB_H_INCLUDED
+
+#include "aeaParse.h"
+#include "aeaCommonData.h"
+#include <string>
+#include <list>
+#include <map>
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    typedef std::list<std::string> StringList;
+
+    class BagTagPectabField
+    {
+      public:
+        BagTagPectabField();
+        static BagTagPectabField* readPectabField(char referenceChar, char delimiter, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+        const std::string& getId() const;
+        bool mirror() const;
+      protected:
+        void setMirror(bool mirror);
+        std::string incrementContent(const std::string& content, int increment, int fieldLength) const;
+        void readElementReference(char referenceChar, const std::string& text, StringList& referenceList, StringList& textList) const;
+        std::string m_elementId;
+        bool m_mirror;
+    };
+
+
+    class BagTagCharacter: public BagTagPectabField
+    {
+      public:
+        BagTagCharacter();
+        bool readBagTagCharacter(char referenceChar, char delimiter, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+
+        Orientation getPrintOrientation() const;
+        HorizontalAlignment getHorizontalAlignment() const;
+        ReverseView getReverseView() const;
+        int getX() const;
+        int getY() const;
+        int getHeight() const;
+        int getWidth() const;
+        const StringList& getReferenceList() const;
+        const StringList& getPrefixTextList() const;
+        bool useIncrement() const;
+      private:
+        Orientation m_printOrientation;
+        HorizontalAlignment m_horizontalAlignment;
+        ReverseView m_reverseView;
+        int m_x;
+        int m_y;
+        int m_height;
+        int m_width;
+        StringList m_referenceList;
+        StringList m_prefixTextList;
+        bool m_increment;
+    };
+    class BagTagLogo: public BagTagPectabField
+    {
+      public:
+        BagTagLogo();
+        bool readBagTagLogo(char referenceChar,char delimiter, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+
+        Orientation getPrintOrientation() const;
+        HorizontalAlignment getHorizontalAlignment() const;
+        ReverseView getReverseView() const;
+        int getX() const;
+        int getY() const;
+        const StringList& getReferenceList() const;
+        const StringList& getPrefixTextList() const;
+      private:
+        Orientation m_printOrientation;
+        HorizontalAlignment m_horizontalAlignment;
+        ReverseView m_reverseView;
+        int m_x;
+        int m_y;
+        StringList m_referenceList;
+        StringList m_prefixTextList;
+    };
+    class BagTagSeparation: public BagTagPectabField
+    {
+      public:
+        BagTagSeparation();
+        bool readBagTagSeparation(char delimiter, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+
+        Orientation getPrintOrientation() const;
+        HorizontalAlignment getHorizontalAlignment() const;
+        int getY() const;
+        int getHeight() const;
+        int getWidth() const;
+      private:
+        Orientation m_printOrientation;
+        HorizontalAlignment m_horizontalAlignment;
+        int m_y;
+        int m_height;
+        int m_width;
+    };
+    class BagTagBarcodeDefinition
+    {
+      public:
+        BagTagBarcodeDefinition();
+        bool readBarcodeType(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+        bool readBarcodeFormat(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+
+        int getX() const;
+        int getY() const;
+        int getHeight() const;
+        PectabBarcode getBarcode() const;
+        bool useCheckDigit() const;
+        int getWideBarDots() const;
+        int getNarrowBarDots() const;
+        int getErrorLevel() const;
+      private:
+        int m_x;
+        int m_y;
+        int m_height;
+        PectabBarcode m_barcode;
+        bool m_withCheckDigit;
+        int m_wideBarDots;
+        int m_narrowBarDots;
+        int m_errorLevel;
+    };
+    class BagTagBarcode: public BagTagPectabField
+    {
+      public:
+        BagTagBarcode();
+        bool readBagTagBarcode(char referenceChar, char delimiter, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+
+        const BagTagBarcodeDefinition& getBarcode() const;
+        Orientation getPrintOrientation() const;
+        HorizontalAlignment getHorizontalAlignment() const;
+        int getX() const;
+        int getY() const;
+        const StringList& getReferenceList() const;
+        const StringList& getPrefixTextList() const;
+        bool useIncrement() const;
+      private:
+        BagTagBarcodeDefinition m_barcode;
+        Orientation m_printOrientation;
+        HorizontalAlignment m_horizontalAlignment;
+        int m_x;
+        int m_y;
+        StringList m_referenceList;
+        StringList m_prefixTextList;
+        bool m_increment;
+    };
+
+
+    typedef std::map<std::string, std::auto_ptr<BagTagPectabField> > BagTagPectabFieldMap;
+
+    class BagTagPectabData
+    {
+      public:
+        BagTagPectabData();
+        bool readPectabData(const std::string& contextId, const std::string& pectabCmd) throw(ParseException);
+        const std::string& pectab() const;
+        const std::string& pectabId() const;
+        const std::string& pectabVersion() const;
+        char continuationCharacter() const;
+        int autoIncrementFieldLength() const;
+        char colorSteering() const;
+        int width_tenth_mm() const;
+        int mirrorPoint_tenth_mm() const;
+        char elementReferenceCharacter() const;
+        char delimiter() const;
+        int version() const;
+        const BagTagPectabFieldMap& getFields() const;
+        const BagTagPectabField* getField(const std::string& fieldId) const;
+
+      private:
+        std::string m_pectab;
+        std::string m_pectabId;
+        std::string m_pectabVersion;
+        int m_version;
+
+        char m_continuationCharacter;
+        int  m_autoIncrementFieldLength;
+        char m_colorSteering;
+        int  m_width_tenth_mm;
+        int  m_mirrorPoint_tenth_mm;
+        char m_elementReferenceCharacter;
+        char m_delimiter;
+
+        BagTagPectabFieldMap m_fieldMap;
+    };
+
+    typedef std::map<std::pair<std::string, std::string>, BagTagPectabData> BagTagPectabDatas;
+
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/AEAParser/aeaBagtagPrintJob.h b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaBagtagPrintJob.h
new file mode 100644
index 00000000..715cf745
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaBagtagPrintJob.h
@@ -0,0 +1,43 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaBagtagPrintJob.h
+//
+//  purpose:    interpret aea commands
+//
+//  date:       16.11.2010
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef AEABAGTAGPRINTJOB_H_INCLUDED
+#define AEABAGTAGPRINTJOB_H_INCLUDED
+
+#include <string>
+#include <map>
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    struct AEABagtagPrintJob
+    {
+      public:
+        typedef std::map<std::string, std::string> TextMap;
+        TextMap fields;
+        TextMap logos;
+        TextMap templates;
+        std::string context;
+        std::string pectab;
+        std::string transactionCode;
+        int printCount;
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/AEAParser/aeaBoardingPassPectab.h b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaBoardingPassPectab.h
new file mode 100644
index 00000000..c9d9d3d5
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaBoardingPassPectab.h
@@ -0,0 +1,139 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaBoardingPassPectab.h
+//
+//  purpose:    aea command data, pectab data structure for boarding pass commands
+//
+//  date:       16.11.2010
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef AEABOARDINGPASSPECTAB_H_INCLUDED
+#define AEABOARDINGPASSPECTAB_H_INCLUDED
+
+#include "aeaParse.h"
+#include "aeaCommonData.h"
+#include <string>
+#include <map>
+#include <list>
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    class PectabPrintPosition
+    {
+      public:
+        PectabPrintPosition();
+        bool readPectabPrintPosition(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+        int getRow() const;
+        int getColumn() const;
+      private:
+        int m_row;
+        int m_column;
+    };
+    class PectabMagStripePosition
+    {
+      public:
+        PectabMagStripePosition();
+        bool readPectabMagStripePosition(int fieldLength, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+        int getTrack() const;
+        int getBlock() const;
+        int getPosition() const;
+      private:
+        int m_track;
+        int m_block;
+        int m_position;
+    };
+    typedef std::list<PectabPrintPosition> PectabPrintPositions;
+    typedef std::list<PectabMagStripePosition> PectabMagStripePositions;
+
+    class PectabBarcodeDefinition
+    {
+      public:
+        PectabBarcodeDefinition();
+        bool readBarcodeType(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+        bool readBarcodeFormat(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+
+        bool useCheckDigit() const;
+        int getHeight() const;
+        int getWideBarDots() const;
+        int getNarrowBarDots() const;
+        int getErrorLevel() const;
+        Orientation getOrientation() const;
+      private:
+        PectabBarcode m_barcode;
+        bool m_withCheckDigit;
+        int m_height;
+        int m_wideBarDots;
+        int m_narrowBarDots;
+        int m_errorLevel;
+        Orientation m_orientation;
+    };
+    class PectabField
+    {
+      public:
+        PectabField();
+        bool readPectabField(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+        bool readFont(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+        const std::string& getId() const;
+
+        int getMaximumLength() const;
+        const PectabPrintPositions& getPrintPositions() const;
+        const PectabMagStripePositions& getMagStripePositions() const;
+        PectabFont getFont() const;
+        const PectabBarcodeDefinition& getBarcodeDefinition() const;
+      private:
+        std::string m_elementId;
+        int m_maximumLength;
+        PectabPrintPositions m_printPositions;
+        PectabMagStripePositions m_magStripePositions;
+        PectabFont m_font;
+        PectabBarcodeDefinition m_barcodeDefinition;
+    };
+    typedef std::map<std::string, PectabField> PectabFieldMap;
+
+    class PectabData
+    {
+      public:
+        PectabData();
+        bool PectabData::readPectabData(const std::string& contextId, const std::string& pectabCmd) throw(ParseException);
+
+        const std::string& pectab() const;
+        const std::string& pectabId() const;
+        const std::string& transactionCodeTicket() const;
+        const std::string& transactionCodeCheckin() const;
+        const std::string& transactionCodeBoarding() const;
+        char logoSteering() const;
+        char colorSteering() const;
+        char unreadable() const;
+        char delimiter() const;
+        int version() const;
+        void getVersion(std::string& text) const;
+        const PectabFieldMap& getFields() const;
+        const PectabField* getField(const std::string& fieldId) const;
+      private:
+        std::string m_pectab;
+        std::string m_pectabId;
+        char m_delimiter;
+        char m_logoSteering;
+        char m_colorSteering;
+        char m_unreadable;
+        int m_version;
+        std::string m_transactionCodeTicket;
+        std::string m_transactionCodeCheckin;
+        std::string m_transactionCodeBoarding;
+        PectabFieldMap m_fieldMap;
+    };
+    typedef std::map<std::string, PectabData> Pectabs;
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/AEAParser/aeaBoardingPassPrintJob.h b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaBoardingPassPrintJob.h
new file mode 100644
index 00000000..052dca84
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaBoardingPassPrintJob.h
@@ -0,0 +1,56 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaBoardingPassPrintJob.h
+//
+//  purpose:    interpret aea commands
+//
+//  date:       16.11.2010
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef AEABOARDINGPASSPRINTJOB_H_INCLUDED
+#define AEABOARDINGPASSPRINTJOB_H_INCLUDED
+
+#include "aeaReceipt.h"
+#include <string>
+#include <map>
+#include <list>
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    struct AEATicketPrintJob
+    {
+      public:
+        typedef std::map<std::string, std::string> TextMap;
+        TextMap fields;
+        TextMap logos;
+        TextMap templates;
+        std::string formatCode;
+        std::string paperType;
+        std::string context;
+        std::string pectab;
+        std::string transactionCode;
+        char delimiter;
+        int printCount;
+    };
+    struct AEAReceiptPrintJob
+    {
+      public:
+        typedef std::list<receipt::ReceiptCommand> CommandList;
+        CommandList fields;
+        std::string context;
+        std::string transactionCode;
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/AEAParser/aeaBoardingPassTemplate.h b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaBoardingPassTemplate.h
new file mode 100644
index 00000000..5547e18b
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaBoardingPassTemplate.h
@@ -0,0 +1,137 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaBoardingPassTemplate.h
+//
+//  purpose:    aea command data, template data structure for parsing boarding pass commands
+//
+//  date:       16.11.2010
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef AEABOARDINGPASSTEMPLATE_H_INCLUDED
+#define AEABOARDINGPASSTEMPLATE_H_INCLUDED
+
+#include "aeaParse.h"
+#include "aeaCommonData.h"
+#include <string>
+#include <map>
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    class TemplateField
+    {
+      public:
+        TemplateField();
+        TemplateField* readTemplateField(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+        const std::string& getId() const;
+      private:
+        std::string m_elementId;
+    };
+    class TemplateLogo: public TemplateField
+    {
+      public:
+        TemplateLogo();
+        bool readTemplateLogo(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+
+        int getLeft() const;
+        int getBottom() const;
+        const std::string& getLogoId() const;
+      private:
+        int m_left;
+        int m_bottom;
+        std::string m_logoId;
+    };
+    class TemplateLine: public TemplateField
+    {
+      public:
+        TemplateLine();
+        bool readTemplateLine(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+
+        int getX1() const;
+        int getY1() const;
+        int getX2() const;
+        int getY2() const;
+        int getThickness() const;
+      private:
+        int m_x1;
+        int m_y1;
+        int m_x2;
+        int m_y2;
+        int m_thickness;
+    };
+    class TemplateBox: public TemplateField
+    {
+      public:
+        TemplateBox();
+        bool readTemplateBox(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+
+        int getLeft() const;
+        int getBottom() const;
+        int getWidth() const;
+        int getHeight() const;
+        int getThickness() const;
+      private:
+        int m_left;
+        int m_bottom;
+        int m_width;
+        int m_height;
+        int m_thickness;
+    };
+    class TemplateText: public TemplateField
+    {
+      public:
+        TemplateText();
+        bool readTemplateText(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+
+        int getLeft() const;
+        int getBottom() const;
+        Orientation getPrintOrientation() const;
+        Orientation getCharacterOrientation() const;
+        PectabFont getAeafont() const;
+        TemplateFontDomain getFontDomain() const;
+        int getPitch() const;
+        bool usePitchInsteadOfAeaFont() const;
+        int getHeight_factor() const;
+        int getWidth_factor() const;
+        const std::string& getText() const;
+      private:
+        int m_left;
+        int m_bottom;
+        Orientation m_printOrientation;
+        Orientation m_characterOrientation;
+        PectabFont m_aeafont;
+        TemplateFontDomain m_fontDomain;
+        int m_pitch;
+        bool m_usePitchInsteadOfAeaFont;
+        int m_height_factor;
+        int m_width_factor;
+        std::string m_text;
+    };
+    typedef std::map<std::string, std::auto_ptr<TemplateField> > TemplateFieldMap;
+
+    class TemplateData
+    {
+      public:
+        TemplateData();
+        bool readTemplateData(const std::string& templateCmd) throw(ParseException);
+        const std::string& templateId() const;
+
+        const TemplateFieldMap& getFields() const;
+      private:
+        std::string m_templateId;
+        TemplateFieldMap m_fieldMap;
+    };
+    typedef std::map<std::string, TemplateData> Templates;
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/AEAParser/aeaCommonData.h b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaCommonData.h
new file mode 100644
index 00000000..72eaf3d6
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaCommonData.h
@@ -0,0 +1,78 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaCommonData.h
+//
+//  purpose:
+//
+//  date:       14.06.2010
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef AEACOMMONDATA_H_INCLUDED
+#define AEACOMMONDATA_H_INCLUDED
+
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    enum TemplateFontDomain
+    {
+      FD_UNKNOWN,
+      FD_AEA,
+      FD_DOWNLOAD,
+      FD_PITCH
+    };
+    enum PectabFont
+    {
+      PT_FONT_UNKNOWN,
+      PT_FONT_NORMAL,
+      PT_FONT_LARGE,
+      PT_FONT_CONDENSED,
+      PT_FONT_OCR,
+      PT_FONT_CONDENSED_BOLD,
+      PT_FONT_CPI_5,
+      PT_FONT_BARCODE
+    };
+    enum PectabBarcode
+    {
+      PT_BC_UNKNOWN,
+      PT_BC_INTERLEAVED_2_OF_5,
+      PT_BC_INDUSTRIAL_2_OF_5,
+      PT_BC_39,
+      PT_BC_128,
+      PT_BC_PDF417,
+      PT_BT_RESERVED
+    };
+    enum Orientation
+    {
+      PT_OR_UNKNOWN,
+      PT_OR_0DEGREE,   // HORIZONTAL
+      PT_OR_90DEGREE,  //
+      PT_OR_180DEGREE, // HEADFIRST
+      PT_OR_270DEGREE, // VERTICAL
+    };
+    enum HorizontalAlignment
+    {
+      PT_HA_UNKNOWN,
+      PT_HA_LEFT,
+      PT_HA_CENTER,
+      PT_HA_RIGHT
+    };
+    enum ReverseView
+    {
+      PT_RV_UNKNOWN,
+      PT_RV_NORMAL,
+      PT_RV_REVERSE
+    };
+
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/AEAParser/aeaLogo.h b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaLogo.h
new file mode 100644
index 00000000..1a3e997e
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaLogo.h
@@ -0,0 +1,51 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaBoardingLogo.h
+//
+//  purpose:    aea command data, logo data structure for parsing boarding pass commands
+//
+//  date:       16.11.2010
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef AEABOARDINGLOGO_H_INCLUDED
+#define AEABOARDINGLOGO_H_INCLUDED
+
+#include "aeaParse.h"
+#include <map>
+#include <string>
+
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    class LogoData
+    {
+      public:
+        LogoData();
+        bool readLogoData(const std::string& logoCmd) throw(ParseException);
+        const std::string& logo() const;
+        // const std::string& logoInBase64() const;
+        const std::string& logoId() const;
+        double width() const;
+        double height() const;
+      private:
+        std::string m_logoId;
+        std::string m_logoData;
+        std::string m_base64LogoData;
+        double m_width;
+        double m_height;
+    };
+    typedef std::map<std::string, LogoData> Logos;
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/AEAParser/aeaParse.h b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaParse.h
new file mode 100644
index 00000000..9c5a5ac1
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaParse.h
@@ -0,0 +1,54 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaParse.h
+//
+//  purpose:
+//
+//  date:       14.06.2010
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef AEAPARSE_H_INCLUDED
+#define AEAPARSE_H_INCLUDED
+
+#include <string>
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    typedef std::string::const_iterator Iterator;
+
+    class ParseException: public std::runtime_error
+    {
+      public:
+        ParseException(const std::string& what);
+    };
+    class InvalidPectab: public ParseException
+    {
+      public:
+        InvalidPectab(const std::string& what, const std::string& pectabId);
+        std::string pectab;
+    };
+    class InvalidField: public ParseException
+    {
+      public:
+        InvalidField(const std::string& what, const std::string& fieldId);
+        std::string field;
+    };
+    class InvalidFieldContent: public InvalidField
+    {
+      public:
+        InvalidFieldContent(const std::string& what, const std::string& fieldId, const std::string& fieldContent);
+        std::string content;
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/AEAParser/aeaPrintProcessor.h b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaPrintProcessor.h
new file mode 100644
index 00000000..52faeb94
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaPrintProcessor.h
@@ -0,0 +1,61 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaPrintProcessor.h
+//
+//  purpose:    interpret aea commands
+//
+//  date:       10.01.2005
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef AEAPRINTPROCESSOR_H_INCLUDED
+#define AEAPRINTPROCESSOR_H_INCLUDED
+
+#include <string>
+#include "aeaResponse.h"
+#include "aeaLogo.h"
+#include "aeaBagtagPectab.h"
+#include "aeaBagtagPrintJob.h"
+#include "aeaBoardingPassPectab.h"
+#include "aeaBoardingPassPrintJob.h"
+#include "aeaBoardingPassTemplate.h"
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    class AEAPrintProcessor
+    {
+      public:
+        AEAPrintProcessor();
+        virtual ~AEAPrintProcessor();
+
+        virtual bool parseContent(const std::string& context);
+        virtual bool parseContent(const std::string& context, ContextType type, LogoData& logo);
+        virtual bool parseContent(const std::string& context, PectabData& pectab);
+        virtual bool parseContent(const std::string& context, BagTagPectabData& pectab);
+        virtual bool parseContent(const std::string& context, TemplateData& template_);
+
+        virtual void processLoad(const std::string& context, ContextType type, LogoData& logo);
+        virtual void processLoad(const std::string& context, PectabData& pectab);
+        virtual void processLoad(const std::string& context, BagTagPectabData& pectab);
+        virtual void processLoad(const std::string& context, TemplateData& template_);
+        virtual void processClear(const std::string& context, ContextType type, LogoData& logo);
+        virtual void processClear(const std::string& context, PectabData& pectab);
+        virtual void processClear(const std::string& context, BagTagPectabData& pectab);
+        virtual void processClear(const std::string& context, TemplateData& template_);
+
+        virtual void process(const std::string& context, AEABagtagPrintJob& job);
+        virtual void process(const std::string& context, AEATicketPrintJob& job);
+        virtual void process(const std::string& context, AEAReceiptPrintJob& job);
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/AEAParser/aeaReceipt.h b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaReceipt.h
new file mode 100644
index 00000000..b5ebb6c6
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaReceipt.h
@@ -0,0 +1,162 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaReceipt.h
+//
+//  purpose:    interpret aea commands
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef AEARECEIPT_H_INCLUDED
+#define AEARECEIPT_H_INCLUDED
+
+#include <string>
+#include <map>
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    namespace receipt
+    {
+      enum ReceiptControl
+      {
+        RC_NOTHING,
+        RC_PRINT_CONTENT,
+        RC_PRINT_LABEL_CONTENT,
+        RC_SET_FONTSIZE,
+        RC_SET_FONTNAME,
+      };
+      struct ReceiptCLF
+      {
+        public:
+          const char* code;
+          ReceiptControl command;
+      };
+      struct ReceiptFont
+      {
+        public:
+          const char* id;
+          const char* fontName;
+      };
+      enum FontWeight
+      {
+        FW_NORMAL,
+        FW_BOLD,
+      };
+      struct ReceiptFontSize
+      {
+        public:
+          const char* id;
+          int fontSize;
+          FontWeight fontWeight;
+      };
+      const ReceiptCLF receiptCLF[] =
+      {
+        {"FMCD", RC_NOTHING},
+        {"ALCD", RC_PRINT_LABEL_CONTENT},
+        {"FLNR", RC_PRINT_LABEL_CONTENT},
+        {"NAME", RC_PRINT_LABEL_CONTENT},
+        {"BORD", RC_PRINT_LABEL_CONTENT},
+        {"DEST", RC_PRINT_LABEL_CONTENT},
+        {"SEAT", RC_PRINT_LABEL_CONTENT},
+        {"DATE", RC_PRINT_LABEL_CONTENT},
+        {"SQNR", RC_PRINT_LABEL_CONTENT},
+        {"CPST", RC_NOTHING},
+        {"CLSS", RC_PRINT_LABEL_CONTENT},
+        {"COMP", RC_PRINT_CONTENT},
+        {"PNRA", RC_PRINT_LABEL_CONTENT},
+        {"ETKT", RC_PRINT_LABEL_CONTENT},
+        {"STAT", RC_PRINT_CONTENT},
+        {"REAS", RC_PRINT_CONTENT},
+        {"TBNR", RC_PRINT_CONTENT},
+        {"TBWG", RC_PRINT_CONTENT},
+        {"FREE", RC_PRINT_CONTENT},
+        {"FONT", RC_SET_FONTNAME},
+        {"SIZE", RC_SET_FONTSIZE},
+      };
+      const ReceiptFont receiptFont[] =
+      {
+        {"0", "Courier New, Monospace"},
+        {"1", "Arial, Sans-serif"},
+        {"2", "Verdana, sans-serif"},
+        {"3", "Times New Roman, Serif"},
+      };
+      const ReceiptFontSize receiptFontSize[] =
+      {
+        {"0", 8,  FW_NORMAL},
+        {"1", 8,  FW_BOLD},
+        {"2", 10, FW_NORMAL},
+        {"3", 10, FW_BOLD},
+        {"4", 12, FW_NORMAL},
+        {"5", 12, FW_BOLD},
+        {"6", 14, FW_NORMAL},
+        {"7", 14, FW_BOLD},
+      };
+      class PrintReceiptException: public std::runtime_error
+      {
+        public:
+          PrintReceiptException(const std::string& what);
+      };
+      class PrintReceiptInvalidFontException: public PrintReceiptException
+      {
+        public:
+          PrintReceiptInvalidFontException(const std::string& font);
+          PrintReceiptInvalidFontException();
+      };
+      class PrintReceiptInvalidFontSizeException: public PrintReceiptException
+      {
+        public:
+          PrintReceiptInvalidFontSizeException(const std::string& fontsize);
+          PrintReceiptInvalidFontSizeException();
+      };
+      class PrintReceiptInvalidCLFException: public PrintReceiptException
+      {
+        public:
+          PrintReceiptInvalidCLFException(const std::string& clf);
+      };
+      struct Font
+      {
+        public:
+          Font();
+          const ReceiptFont* fontId;
+          const ReceiptFontSize* fontSizeId;
+      };
+      struct ReceiptCommand
+      {
+        public:
+          ReceiptCommand();
+          const ReceiptCLF* pCommand;
+          std::string content;
+      };
+      class ReceiptPrinting
+      {
+        public:
+          ReceiptPrinting();
+          ReceiptCommand parseCLF(const std::string& clf) const;
+          const ReceiptFont* getFont(const std::string& id);
+          const ReceiptFontSize* getFontSize(const std::string& id);
+
+        private:
+          enum CONSTS
+          {
+            CLF_MIN_SIZE= 4,
+            CLF_MAX_SIZE= 4,
+          };
+          typedef std::map<std::string, const ReceiptCLF*> ReceiptCLFMap;
+          ReceiptCLFMap receiptCLFMap;
+          typedef std::map<std::string, const ReceiptFont*> ReceiptFontMap;
+          ReceiptFontMap receiptFontMap;
+          typedef std::map<std::string, const ReceiptFontSize*> ReceiptFontSizeMap;
+          ReceiptFontSizeMap receiptFontSizeMap;
+      };
+    }
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/AEAParser/aeaResponse.h b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaResponse.h
new file mode 100644
index 00000000..146fbf46
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaResponse.h
@@ -0,0 +1,75 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaReponse.h
+//
+//  purpose:
+//
+//  date:       14.06.2010
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef AEAREPONSE_H_INCLUDED
+#define AEAREPONSE_H_INCLUDED
+
+#include <string>
+#include <memory>
+#include <stddef.h>
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    enum ContextType
+    {
+      BAGTAG,
+      BOARDINGPASS,
+    };
+    struct Status;
+    enum Command
+    {
+      COMMAND_UNKNOWN,
+      COMMAND_SETUP,
+      COMMAND_PRINT,
+      COMMAND_INDICATION
+    };
+    enum ResultCode
+    {
+      RESULT_SUCCESS,
+      RESULT_FORMAT_ERROR,
+    };
+    class AEAResponse
+    {
+      public:
+        AEAResponse();
+        virtual ~AEAResponse();
+        virtual Command getCommandType() const;
+        virtual std::string getResponse() const;
+        virtual std::string getResponse(const Status& status) const;
+        virtual ResultCode getResultCode() const;
+        virtual size_t getDocumentCount() const;
+    };
+    class AEAConstResponse: public AEAResponse
+    {
+      public:
+        AEAConstResponse(Command cmd, ResultCode resultCode, const std::string& response);
+        ~AEAConstResponse();
+        Command getCommandType() const;
+        std::string getResponse(const Status& status) const;
+        ResultCode getResultCode() const;
+      private:
+        Command m_cmd;
+        ResultCode m_resultCode;
+        std::string m_response;
+    };
+
+    typedef std::auto_ptr<AEAResponse> AEAResult;
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/AEAParser/aeaSimulator.h b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaSimulator.h
new file mode 100644
index 00000000..dad4a1ba
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaSimulator.h
@@ -0,0 +1,65 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaSimulator.h
+//
+//  purpose:    interpret aea commands
+//
+//  date:       10.01.2005
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef AEASIMULATOR_H_INCLUDED
+#define AEASIMULATOR_H_INCLUDED
+
+#include <string>
+
+#include "aeaStock.h"
+#include "aeaResponse.h"
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    class AEAPrintProcessor;
+    class LogoData;
+    class PectabData;
+    class BagTagPectabData;
+    class TemplateData;
+    class AEAPrintSimulation
+    {
+      public:
+        AEAPrintSimulation(const std::string& transactionCode);
+        AEAPrintSimulation(const AEAPrintSimulation& assign);
+        AEAPrintSimulation& operator=(const AEAPrintSimulation& assign);
+        ~AEAPrintSimulation();
+
+        void setContext(const std::string& contextId, ContextType type= BOARDINGPASS);
+        const std::string& getContext(ContextType type= BOARDINGPASS) const;
+        AEAResult sendCommand(const std::string& cmd, ContextType type= BOARDINGPASS);
+        void setPrintProcessor(AEAPrintProcessor* pProcessor);
+        //  AEAResult sendTracks(const Tracks& tracks);  // type BOARDINGPASS
+
+        const LogoData* getLogoData(const std::string& context, const std::string& id, ContextType type= BOARDINGPASS) const;
+        const PectabData* getPectabData(const std::string& context, const std::string& id) const;
+        const BagTagPectabData* getBagTagPectabData(const std::string& context, const std::string& id, const std::string& version) const;
+        const TemplateData* getTemplateData(const std::string& context, const std::string& id) const;
+
+        StockSet getStocks(Media media) const;
+        StockSetting getMedia(Stock stock) const;
+      private:
+        class _AEAPrintSimulation* getSimulation(ContextType type);
+        const class _AEAPrintSimulation* getSimulation(ContextType type) const;
+
+        class BagtagAEAPrintSimulation* m_pBagtag;
+        class BoardingPassAEAPrintSimulation* m_pBoardingPass;
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/AEAParser/aeaStatus.h b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaStatus.h
new file mode 100644
index 00000000..b2bafc42
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaStatus.h
@@ -0,0 +1,73 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaStatus.h
+//
+//  purpose:    interpret aea commands, printer status
+//
+//  date:       16.11.2010
+//
+//  author:     Materna Information & Communications
+//
+//---------------------------------------------------------------------------
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef AEASTATUS_H_INCLUDED
+#define AEASTATUS_H_INCLUDED
+
+#include <vector>
+#include <stddef.h>
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    enum RibbonStatus
+    {
+      RS_OK,
+      RS_LOW,
+      RS_EMPTY,
+    };
+    enum DispenserStatus
+    {
+      DS_OK,
+      DS_HIGH,
+      DS_FULL,
+    };
+    enum PrinterStatus
+    {
+      PS_OK,
+      PS_BUSY,
+      PS_OFFLINE,
+      PS_NOT_ENABLED,
+      PS_UNAVAILABLE,
+      PS_PAPEROUT,
+      PS_PAPERJAM
+    };
+    enum PaperStatus
+    {
+      PS_PRESENT,
+      PS_LOW,
+      PS_ABSENT,
+    };
+    struct FeederStatus
+    {
+      public:
+        size_t printed;
+        size_t voided;
+        PaperStatus paperStatus;
+    };
+    typedef std::vector<FeederStatus> Feeder;
+    struct Status
+    {
+      public:
+        RibbonStatus    ribbonStatus;
+        DispenserStatus dispenserStatus;
+        PrinterStatus   printerStatus;
+        Feeder          feeder;
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Interfaces/inc/AEAParser/aeaStock.h b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaStock.h
new file mode 100644
index 00000000..2e97c9c7
--- /dev/null
+++ b/SelfServiceCommon/Interfaces/inc/AEAParser/aeaStock.h
@@ -0,0 +1,72 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaStock.h
+//
+//  purpose:    aea stock settings
+//
+//  date:       16.11.2010
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef AEASTOCK_H_INCLUDED
+#define AEASTOCK_H_INCLUDED
+
+#include <set>
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    enum PaperType
+    {
+      PT_UNDEFINED,
+      PT_TICKET,
+      PT_BOARDINGPASS,
+      PT_GENERALPURPOSEDOC,
+      PT_BAGGAGETAG,
+    };
+    enum PaperTypeClass
+    {
+      PC_UNDEFINED,
+      PC_FIRST,
+      PC_BUSINESS,
+      PC_ECONOMY
+    };
+    struct Media
+    {
+      public:
+        PaperType paperType;
+        PaperTypeClass paperTypeClass;
+    };
+
+    typedef int Stock;
+    typedef std::set<Stock> StockSet;
+    enum Verify
+    {
+      VERIFY_ON,
+      VERIFY_OFF,
+    };
+    enum PreencodedStockControl
+    {
+      STOCK_CONTROL_ASCENDING,
+      STOCK_CONTROL_DESCENDING,
+      STOCK_CONTROL_OFF
+    };
+    struct StockSetting
+    {
+      public:
+        Media media;
+        Verify verify;
+        PreencodedStockControl scnr;
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/inc/Console.h b/SelfServiceCommon/Massai/cpp/AEAParser/inc/Console.h
new file mode 100644
index 00000000..bf591aef
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/inc/Console.h
@@ -0,0 +1,110 @@
+//---------------------------------------------------------------------------
+//
+//  file:       Console.h
+//
+//  purpose:    read input from std in
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#include <list>
+#include <string>
+#include <stddef.h>
+#include <vector>
+
+namespace Console
+{
+  enum CONSTS
+  {
+    MAX_PARAMETER_COUNT= 10
+  };
+  enum InputType
+  {
+    IT_IGNORE,
+    IT_INPUT,
+    IT_FILENAME
+  };
+  struct Input
+  {
+    public:
+      InputType type;
+      const char* pPrompt;
+  };
+  typedef Input InputList[MAX_PARAMETER_COUNT];
+  struct Input_
+  {
+    public:
+      Input_(InputType type, const std::string& prompt);
+      InputType type;
+      std::string prompt;
+  };
+  typedef std::list<Input_> InputList_;
+  typedef std::vector<std::string> Strings;
+
+  enum ResultCode
+  {
+    RC_SUCCESS,
+    RC_FAILED,
+    RC_NOT_FOUND
+  };
+
+  class SelectionCommandBase
+  {
+    public:
+      SelectionCommandBase();
+      virtual ~SelectionCommandBase();
+      virtual ResultCode execute(char selector, int parameter, const Strings& parameterList);
+  };
+
+  struct Selection
+  {
+    public:
+      SelectionCommandBase* pCmd;
+      const char*           selector;
+      const char*           help;
+      InputList             parameterList;
+      int                   parameter;
+  };
+
+
+  struct Selection_: public SelectionCommandBase
+  {
+    public:
+      SelectionCommandBase* pCmd;
+      std::string           selector;
+      std::string           help;
+      InputList_            parameterList;
+      int                   parameter;
+  };
+  class ConsoleSelection: public SelectionCommandBase
+  {
+    public:
+      enum Parameter
+      {
+        P_QUIT,
+        P_HELP
+      };
+
+      ConsoleSelection();
+      ~ConsoleSelection();
+      void add(const Selection_& command);
+      void add(const Selection& command);
+      void add(SelectionCommandBase* pCmd, const std::string& selector, const std::string& help, const InputList_& parameterList, int parameter= 0);
+      void addSimple(SelectionCommandBase* pCmd, const std::string& selector, const std::string& help, int parameter= 0);
+      void addInput(SelectionCommandBase* pCmd, const std::string& selector, const std::string& help, const InputList& input, int parameter= 0);
+      ResultCode select() const;
+      void loop() const;
+      void printHelp() const;
+    private:
+      ResultCode execute(char selector, int parameter, const Strings& parameterList);
+      char readChar() const;
+      std::string getLine(const std::string& help) const;
+      const Selection_* getCommand(char c) const;
+
+      typedef std::list<Selection_> SelectionList;
+      SelectionList m_selectionList;
+      bool mutable m_quit;
+  };
+}
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaBagTagResponse.h b/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaBagTagResponse.h
new file mode 100644
index 00000000..0fe5d423
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaBagTagResponse.h
@@ -0,0 +1,42 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaBagtagResponse.h
+//
+//  purpose:
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef AEABAGTAGRESPONSE_H_INCLUDED
+#define AEABAGTAGRESPONSE_H_INCLUDED
+
+#include "AEAParser/aeaResponse.h"
+#include <string>
+#include <stddef.h>
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    class AEABagtagResponse: public AEAResponse
+    {
+      public:
+        AEABagtagResponse(const std::string& transactionCode, size_t jobCount);
+        ~AEABagtagResponse();
+        Command getCommandType() const;
+        std::string getResponse(const Status& status) const;
+        ResultCode getResultCode() const;
+        size_t getDocumentCount() const;
+      private:
+        std::string m_transactionCode;
+        size_t m_jobCount;
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaBinSetup.h b/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaBinSetup.h
new file mode 100644
index 00000000..8ef76fbb
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaBinSetup.h
@@ -0,0 +1,69 @@
+//---------------------------------------------------------------------------
+//
+//  file:       BinSetup.h
+//
+//  purpose:    settings of the stocks
+//
+//  date:       14.06.2010
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef BINSETUP_H_INCLUDED
+#define BINSETUP_H_INCLUDED
+
+#include "AEAParser/aeaParse.h"
+#include "AEAParser/aeaStock.h"
+#include <map>
+#include <string>
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    struct MediaCompare
+    {
+      public:
+        bool operator()(const Media& x, const Media& y) const;
+    };
+
+    struct BinSetupData
+    {
+      public:
+        BinSetupData();
+        bool readMedia(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+        bool readVerify(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+        bool readSCNR(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+        std::string status(bool includeSCNRInfo) const;
+
+        StockSetting getStockSetting() const;
+      private:
+        void setMedia(PaperTypeClass class_, PaperType type);
+        StockSetting m_stockSetting;
+    };
+    class BinSetup
+    {
+      public:
+        BinSetup();
+        ~BinSetup();
+        std::string setup(const std::string& input);
+        StockSet getStocks(Media media) const;
+        StockSetting getMedia(Stock stock) const;
+        std::string status(bool includeSCNRInfo) const;
+      private:
+        void generateStockMap();
+        typedef std::map<Media, StockSet, MediaCompare> StockMap;
+        typedef std::map<Stock, BinSetupData> MediaMap;
+        StockMap m_stockMap;
+        MediaMap m_mediaMap;
+        Stock m_defaultStock;
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaBoardingPassResponse.h b/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaBoardingPassResponse.h
new file mode 100644
index 00000000..0d240a6f
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaBoardingPassResponse.h
@@ -0,0 +1,58 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaBoardingPassResponse.h
+//
+//  purpose:
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef AEABOARDINGPASSREPONSE_H_INCLUDED
+#define AEABOARDINGPASSREPONSE_H_INCLUDED
+
+#include "AEAParser/aeaResponse.h"
+#include <string>
+#include <stddef.h>
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    class AEACouponResponse: public AEAResponse
+    {
+      public:
+        AEACouponResponse(const std::string& transactionCode, char delimiter, size_t jobCount, size_t stockCount);
+        AEACouponResponse(const std::string& transactionCode, char delimiter, const std::string& rsp, size_t stockCount);
+        ~AEACouponResponse();
+        Command getCommandType() const;
+        std::string getResponse(const Status& status) const;
+        ResultCode getResultCode() const;
+        size_t getDocumentCount() const;
+      private:
+        std::string m_transactionCode;
+        std::string m_delimiter;
+        std::string m_rsp;
+        size_t m_jobCount;
+        size_t m_stockCount;
+    };
+    class AEAReceiptResponse: public AEAResponse
+    {
+      public:
+        AEAReceiptResponse(const std::string& transactionCode);
+        ~AEAReceiptResponse();
+        Command getCommandType() const;
+        std::string getResponse(const Status& status) const;
+        ResultCode getResultCode() const;
+        size_t getDocumentCount() const;
+      private:
+        std::string m_transactionCode;
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaContext.h b/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaContext.h
new file mode 100644
index 00000000..2fe3c7d7
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaContext.h
@@ -0,0 +1,93 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaContext.h
+//
+//  purpose:    aea command data
+//
+//  date:       24.05.2007
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//  history:
+//---------------------------------------------------------------------------
+
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef AEACMD_H_INCLUDED
+#define AEACMD_H_INCLUDED
+
+#include "AEAParser/aeaLogo.h"
+#include "AEAParser/aeaBagtagPectab.h"
+#include "AEAParser/aeaBoardingPassPectab.h"
+#include "AEAParser/aeaBoardingPassTemplate.h"
+#include "AEAParser/aeaResponse.h"
+#include <string>
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    class AEAPrintProcessor;
+    class AEAContextBase
+    {
+      public:
+        AEAContextBase(const std::string& contextId, const std::string& transactionCode);
+        const LogoData* logo(const std::string& logoId) const;
+        const std::string& contextId() const;
+        const std::string& transactionCode() const;
+      protected:
+        bool inputLogo(const std::string& cmd, AEAResult& rsp, AEAPrintProcessor* pProcessor);
+        bool inputTransactionCode(const std::string& cmd, AEAResult& rsp);
+      private:
+        bool clearLogos(const std::string& cmd, AEAResult& rsp, AEAPrintProcessor* pProcessor);
+        bool loadLogo(const std::string& cmd, AEAResult& rsp, AEAPrintProcessor* pProcessor);
+        bool getLogoStatus(const std::string& cmd, AEAResult& rsp);
+        void logostatus(std::string& logos);
+
+        Logos m_logos;
+        std::string m_contextId;
+        std::string m_transactionCode;
+    };
+
+    class BagtagAEAContext: public AEAContextBase
+    {
+      public:
+        BagtagAEAContext(const std::string& contextId, const std::string& transactionCode);
+        bool input(const std::string& cmd, AEAResult& rsp, AEAPrintProcessor* pProcessor);
+        const BagTagPectabData* pectab(const std::string& pectabId, const std::string& pectabVersion) const;
+      private:
+        bool clearPectabs(const std::string& cmd, AEAResult& rsp, AEAPrintProcessor* pProcessor);
+        bool loadPectab(const std::string& cmd, AEAResult& rsp, AEAPrintProcessor* pProcessor);
+        bool getPectabStatus(const std::string& cmd, AEAResult& rsp);
+        void pectabstatus(std::string& pectabs);
+
+        BagTagPectabDatas m_pectabs;
+    };
+
+    class BoardingAEAContext: public AEAContextBase
+    {
+      public:
+        BoardingAEAContext(const std::string& contextId, const std::string& transactionCode);
+        bool input(const std::string& cmd, AEAResult& rsp, AEAPrintProcessor* pProcessor);
+        const PectabData* pectab(const std::string& pectabId) const;
+        const TemplateData* template_(const std::string& templateId) const;
+      private:
+        bool clearPectabs(const std::string& cmd, AEAResult& rsp, AEAPrintProcessor* pProcessor);
+        bool loadPectab(const std::string& cmd, AEAResult& rsp, AEAPrintProcessor* pProcessor);
+        bool getPectabStatus(const std::string& cmd, AEAResult& rsp);
+        void pectabstatus(std::string& pectabs);
+
+        bool clearTemplates(const std::string& cmd, AEAResult& rsp, AEAPrintProcessor* pProcessor);
+        bool loadTemplate(const std::string& cmd, AEAResult& rsp, AEAPrintProcessor* pProcessor);
+        bool getTemplateStatus(const std::string& cmd, AEAResult& rsp);
+        void templatestatus(std::string& templates);
+
+        Pectabs m_pectabs;
+        Templates m_templates;
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaSimulator_BagtagImpl.h b/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaSimulator_BagtagImpl.h
new file mode 100644
index 00000000..df612fa5
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaSimulator_BagtagImpl.h
@@ -0,0 +1,47 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaSimulator_BagtagImpl.h
+//
+//  purpose:    interpret aea commands
+//
+//  date:       10.01.2005
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef AEASIMULATOR_BAGTAGIMPL_H_INCLUDED
+#define AEASIMULATOR_BAGTAGIMPL_H_INCLUDED
+
+#include "aeaSimulator_Impl.h"
+#include "aeaContext.h"
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    class BagtagAEAPrintSimulation: public _AEAPrintSimulation
+    {
+      public:
+        BagtagAEAPrintSimulation(const std::string& transactionCode);
+        ~BagtagAEAPrintSimulation();
+        AEAResult do_input(const std::string& cmd);
+
+        const LogoData* getLogoData(const std::string& context, const std::string& id) const;
+        const BagTagPectabData* getBagTagPectabData(const std::string& context, const std::string& id, const std::string& version) const;
+      private:
+        const BagtagAEAContext* findContext(const std::string& context) const;
+        BagtagAEAContext& getContext();
+        bool printTicket(const BagtagAEAContext& context, const std::string& cmd, AEAResult& rsp) throw(ParseException);
+
+        typedef std::map<std::string, BagtagAEAContext> Contexts;
+        Contexts m_contexts;
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaSimulator_BoardingPassImpl.h b/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaSimulator_BoardingPassImpl.h
new file mode 100644
index 00000000..1c02e488
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaSimulator_BoardingPassImpl.h
@@ -0,0 +1,49 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaSimulator_BoardingPassImpl.h
+//
+//  purpose:    interpret aea commands
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef AEASIMULATOR_BOARDINGPASSIMPL_H_INCLUDED
+#define AEASIMULATOR_BOARDINGPASSIMPL_H_INCLUDED
+
+#include "aeaSimulator_Impl.h"
+#include "aeaContext.h"
+#include "AEAParser/aeaReceipt.h"
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    class BoardingPassAEAPrintSimulation: public _AEAPrintSimulation
+    {
+      public:
+        BoardingPassAEAPrintSimulation(const std::string& transactionCode);
+        ~BoardingPassAEAPrintSimulation();
+        AEAResult do_input(const std::string& cmd);
+
+        const LogoData* getLogoData(const std::string& context, const std::string& id) const;
+        const PectabData* getPectabData(const std::string& context, const std::string& id) const;
+        const TemplateData* getTemplateData(const std::string& context, const std::string& id) const;
+      private:
+        const BoardingAEAContext* findContext(const std::string& context) const;
+        BoardingAEAContext& getContext();
+        bool printTicket(const BoardingAEAContext& context, const std::string& cmd, AEAResult& rsp) throw(ParseException);
+        bool printReceipt(const BoardingAEAContext& context, const std::string& cmd, AEAResult& rsp) throw(ParseException);
+
+        typedef std::map<std::string, BoardingAEAContext> Contexts;
+        Contexts m_contexts;
+        receipt::ReceiptPrinting receiptPrinting;
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaSimulator_Impl.h b/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaSimulator_Impl.h
new file mode 100644
index 00000000..8877110d
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaSimulator_Impl.h
@@ -0,0 +1,53 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaSimulator_Impl.h
+//
+//  purpose:    interpret aea commands
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef AEASIMULATOR_IMPL_H_INCLUDED
+#define AEASIMULATOR_IMPL_H_INCLUDED
+
+#include <string>
+
+#include "AEAParser/aeaResponse.h"
+#include "mMutexSem.hpp"
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    class AEAPrintProcessor;
+    class _AEAPrintSimulation
+    {
+      public:
+        _AEAPrintSimulation(const std::string& transactionCode);
+        _AEAPrintSimulation(const _AEAPrintSimulation& assign);
+        _AEAPrintSimulation& operator=(const _AEAPrintSimulation& assign);
+        virtual ~_AEAPrintSimulation();
+        AEAResult input(const std::string& cmd);
+        void setContext(const std::string& contextId);
+        const std::string& getTransactionCode() const;
+        const std::string& getContextId() const;
+        void setPrintProcessor(AEAPrintProcessor* processor);
+        AEAPrintProcessor* getPrintProcessor();
+
+      private:
+        virtual AEAResult do_input(const std::string& cmd)= 0;
+        std::string m_contextId;
+        std::string m_transactionCode;
+        Materna::MSSD::mutexSemaphore m_access;
+        bool m_active;
+        AEAPrintProcessor* m_pProcessor;
+    };
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaToken.h b/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaToken.h
new file mode 100644
index 00000000..962ab52c
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaToken.h
@@ -0,0 +1,88 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaToken.h
+//
+//  purpose:    aea command tokenizer
+//
+//  date:       24.05.2007
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef AEATOKEN_H_INCLUDED
+#define AEATOKEN_H_INCLUDED
+
+#include "AEAParser/aeaParse.h"
+#include "AEAParser/aeaCommonData.h"
+
+#pragma warning (disable:4786)
+#pragma warning (disable:4503)
+
+namespace Tokenizer
+{
+  typedef MASSAI::AEA::Iterator Iterator;
+  bool readText(const std::string& in, const std::string& text);
+  bool readChar(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readAlpha(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readChar(char text, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readChar(const std::string& list, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readDigit(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readDigit(int count, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readToChar(char text, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readToChar(const std::string& list, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readText(const std::string& text, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readPectab(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readPectabVersion(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readTransactionCode(char delimiter, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readFieldId(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readDocumentType(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readLogoCmd(char cmd, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd, Iterator& idBegin);
+  bool readLogoId(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readTemplateCmd(char cmd, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd, Iterator& idBegin);
+  bool readTemplateId(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readColor(char cmd, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readRow(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readCLF(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readOrientation(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readTemplateFontDomain(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readTemplateFont(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readTemplateCharFactor(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  void charFactor(Iterator inBegin, int& width, int& height);
+  int characterValue(Iterator inBegin);
+
+  int charHeightFactor(Iterator inBegin);
+  int charWidthFactor(Iterator inBegin);
+  MASSAI::AEA::PectabFont font(Iterator inBegin);
+  MASSAI::AEA::TemplateFontDomain fontDomain(Iterator inBegin);
+  MASSAI::AEA::Orientation orientation(Iterator inBegin);
+  int digit(Iterator inBegin);
+  int digit(Iterator inBegin, Iterator inEnd);
+  int row(Iterator inBegin);
+  int pectabVersion(Iterator inBegin, Iterator inEnd);
+  std::string clf(Iterator inBegin, Iterator inEnd);
+  std::string documentType(Iterator inBegin, Iterator inEnd);
+  char dec(unsigned int value);
+
+  bool readBTPPectab(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readBTPPectabVersion(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readBagTagFont(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readMirrorIndicator(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readBagTagOrientation(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readBagTagLineOrientation(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool readBagTagBarcodeOrientation(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd);
+  bool mirrorIndicator(Iterator inBegin);
+  MASSAI::AEA::Orientation bagTagOrientation(Iterator inBegin);
+  MASSAI::AEA::HorizontalAlignment bagTagAlignment(Iterator inBegin);
+  MASSAI::AEA::ReverseView bagTagReverseView(Iterator inBegin);
+
+  std::string fromHexLittleEndian(const std::string& data);
+  std::string fromHexBigEndian(const std::string& data);
+
+}
+
+#endif
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaTrack.h b/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaTrack.h
new file mode 100644
index 00000000..21980205
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/inc/aeaTrack.h
@@ -0,0 +1,31 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaTrack.h
+//
+//  purpose:    aea track
+//
+//  date:       16.11.2010
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+
+#if defined(SHOW_INCLUDE_FILES)
+#pragma message("including: " __FILE__)
+#endif
+#ifndef AEATRACK_H_INCLUDED
+#define AEATRACK_H_INCLUDED
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    typedef std::string Block;
+    typedef std::vector<Block> Track;
+    typedef std::vector<Track> Tracks;
+  }
+}
+
+#endif
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/inc/decoder/AEAContext.h b/SelfServiceCommon/Massai/cpp/AEAParser/inc/decoder/AEAContext.h
new file mode 100644
index 00000000..e2d02e9e
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/inc/decoder/AEAContext.h
@@ -0,0 +1,277 @@
+/**
+ **************************************************************************
+ *
+ * @file AEAContext.h
+ *
+ * Contains class AEAContext.
+ *
+ * @author MaK
+ *
+ * Copyright (c) 2005 MATERNA Information & Communications
+ *
+ **************************************************************************
+**/
+#ifndef AEACONTEXT_H_
+#define AEACONTEXT_H_
+
+#pragma warning(disable: 4786)
+
+#include <map>
+#include <string>
+
+#include "ATBMessage.hpp"
+
+namespace AEA_Impl
+{
+
+enum ioMode
+{
+  unknown,
+  ticketing,
+  checkin,
+  boarding
+};
+
+typedef std::string dataKey;
+
+struct contextChangeListener
+{
+public:
+  /**
+   ******************************************************************************
+   * function: virtual void changed()
+   *
+   * purpose: indicates a change in the context(s)
+   *
+   * @@MaK 08.06.2005 09:24
+   ******************************************************************************
+  **/
+  virtual void changed() = 0;
+};
+
+class context
+{
+  typedef std::map<dataKey, atbMessage> storageMap;
+
+  storageMap pectabs;
+  storageMap logos;
+  storageMap templates;
+  storageMap fonts;
+
+  std::string transactionHeader;        // set by CT command
+  std::string name;                     // the name of this context
+
+  ioMode mode;
+
+  std::vector<contextChangeListener *> changeListeners;
+
+public:
+
+  enum RC
+  {
+    RC_OK,
+    RC_ERROR
+  };
+
+  context();  // don't implement me, we don't want anonymous contexts!
+  context(std::string const & name);
+  context(context const & c);
+
+  void setListener(contextChangeListener * pListener);
+
+  RC loadLogo(atbMessage const & data);
+  RC loadPectab(atbMessage const & data);
+  RC loadTemplate(atbMessage const & data);
+  RC loadFont(atbMessage const & data);
+
+  RC deleteLogo(std::vector<dataKey> const & keys);
+  RC deletePectab(std::vector<dataKey> const & keys);
+  RC deleteTemplate(std::vector<dataKey> const & keys);
+  RC deleteFont(std::vector<dataKey> const & keys);
+
+  RC setTransactionHeader(std::string const & data);
+
+  RC setIOMode(ioMode m);
+
+  RC getPectab    (dataKey const & key, atbMessage & m) const;
+  RC getLogo      (dataKey const & key, atbMessage & m) const;
+  RC getTemplate  (dataKey const & key, atbMessage & m) const;
+  RC getFont      (dataKey const & key, atbMessage & m) const;
+
+  std::vector<dataKey> enumPectabs() const;
+  std::vector<dataKey> enumLogos() const;
+  std::vector<dataKey> enumTemplates() const;
+  std::vector<dataKey> enumFonts() const;
+
+  std::string const & getTransactionHeader() const;
+  ioMode getIOMode() const;
+};
+
+typedef std::string contextKey;
+typedef std::map<contextKey, context> contextMap;
+
+static char const * GLOBAL_USER = "__GU__";
+
+class multiContext : public contextChangeListener
+{
+  contextMap contexts;
+  contextKey currentContext;
+
+protected:
+
+  /**
+   ******************************************************************************
+   * function: virtual void changed()
+   *
+   * purpose: indicates a change in the context(s)
+   *
+   * @@MaK 08.06.2005 09:24
+   ******************************************************************************
+  **/
+  virtual void changed()
+  {
+  }
+
+public:
+
+  multiContext();
+  multiContext(multiContext const & mc); // DON'T implement me!
+
+  /**
+   ******************************************************************************
+   * function: setContext(contextKey const & key);
+   *
+   * purpose: set / add a context
+   *
+   * @@MaK 06.06.2005 17:57
+   ******************************************************************************
+  **/
+  context::RC setContext(contextKey const & key);
+
+  /**
+   ******************************************************************************
+   * function: context::RC getContext(contextKey const & key);
+   *
+   * purpose: get a reference to the specified context
+   *
+   * @@MaK 06.06.2005 17:59
+   ******************************************************************************
+  **/
+  context::RC getContext(contextKey const & key, context & c) const;
+
+  /**
+   ******************************************************************************
+   * function: context & getContext();
+   *
+   * purpose: get a reference to the current context
+   *
+   * @@MaK 06.06.2005 18:00
+   ******************************************************************************
+  **/
+  context & getContext();
+
+  /**
+   ******************************************************************************
+   * function: context const & getContext();
+   *
+   * purpose: get a reference to the current context
+   *
+   * @@MaK 06.06.2005 18:00
+   ******************************************************************************
+  **/
+  context const & getContext() const;
+
+  /**
+   ******************************************************************************
+   * function: contextMap const & getContexts() const;
+   *
+   * purpose:
+   *
+   * @@MaK 09.06.2005 13:16
+   ******************************************************************************
+  **/
+  contextMap const & getContexts() const;
+};
+
+class persistentMultiContext : public multiContext
+{
+public:
+
+  /**
+   * Default constructor - Don't implement me,
+   * we don't want a persistency object that's not linked to a context object
+  **/
+  persistentMultiContext();
+
+  /**
+   * Copy constructor - Don't implement me,
+   * we don't want more than one persistency object linked to one context object
+  **/
+  persistentMultiContext(persistentMultiContext const &);
+
+  /**
+   ******************************************************************************
+   * function: persistentMultiContext(std::string const & storageLocation);
+   *
+   * purpose:
+   *
+   * @@MaK 08.06.2005 09:20
+   ******************************************************************************
+  **/
+  persistentMultiContext(std::string const & storageLocation);
+
+  /**
+   ******************************************************************************
+   * function: virtual void changed()
+   *
+   * purpose: indicates a change in the context(s)
+   *
+   * @@MaK 08.06.2005 09:24
+   ******************************************************************************
+  **/
+  virtual void changed();
+};
+
+class contextParser
+{
+  multiContext & ctx;
+
+public:
+  /**
+   * Default constructor - Don't implement me,
+   * we don't want a parser that's not linked to a context object
+  **/
+  contextParser();
+
+  /**
+   * Copy constructor - Don't implement me,
+   * we don't want more than one parser linked to the same context object
+  **/
+  contextParser(contextParser const &);
+
+  /**
+   ******************************************************************************
+   * function: contextParser(multiContext & ctx);
+   *
+   * purpose:
+   *
+   * @@MaK 07.06.2005 12:19
+   ******************************************************************************
+  **/
+  contextParser(multiContext & ctx);
+
+  /**
+   ******************************************************************************
+   * function: std::string process(atbMessage const & data);
+   *
+   * purpose:
+   *
+   * @@MaK 15.06.2005 11:58
+   ******************************************************************************
+  **/
+  std::string process(atbMessage const & data);
+};
+
+} // namespace AEA_Impl
+
+#endif //AEACONTEXT_H_
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/inc/decoder/AEADecoder.h b/SelfServiceCommon/Massai/cpp/AEAParser/inc/decoder/AEADecoder.h
new file mode 100644
index 00000000..39c66794
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/inc/decoder/AEADecoder.h
@@ -0,0 +1,66 @@
+/**
+ **************************************************************************
+ *
+ * @file AEADecoder.h
+ *
+ * Contains class AEADecoder.
+ *
+ * @author MaK
+ *
+ * Copyright (c) 2005 MATERNA Information & Communications
+ *
+ **************************************************************************
+**/
+#ifndef AEADECODERECTAB_H_
+#define AEADECODERECTAB_H_
+
+#include <string>
+#include <vector>
+
+#include "AEAContext.h"
+#include "mrEvent.h"
+
+namespace AEA_Impl
+{
+
+class magstripeDecoder
+{
+  multiContext const & mc;
+public:
+  enum RC
+  {
+    RC_OK,
+    RC_ERROR
+  };
+
+  /**
+   * default constructor, don't implement me, we don't want a decoder without context
+   **/
+  magstripeDecoder();
+
+  /**
+   ******************************************************************************
+   * function: magstripeDecoder(multiContext const & mc);
+   *
+   * purpose:
+   *
+   * @@MaK 23.06.2005 09:29
+   ******************************************************************************
+  **/
+  magstripeDecoder(multiContext const & mc);
+
+  /**
+   ******************************************************************************
+   * function: RC decode(mrEvent const & e);
+   *
+   * purpose:
+   *
+   * @@MaK 23.06.2005 09:31
+   ******************************************************************************
+  **/
+  RC decode(mrEvent const & e, std::string & ret);
+};
+
+} // namespace AEA_Impl;
+
+#endif //AEADECODERECTAB_H_
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/inc/decoder/AEAPectab.h b/SelfServiceCommon/Massai/cpp/AEAParser/inc/decoder/AEAPectab.h
new file mode 100644
index 00000000..e654223f
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/inc/decoder/AEAPectab.h
@@ -0,0 +1,145 @@
+/**
+ **************************************************************************
+ *
+ * @file AEAPectab.h
+ *
+ * Contains class AEAPectab.
+ *
+ * @author MaK
+ *
+ * Copyright (c) 2005 MATERNA Information & Communications
+ *
+ **************************************************************************
+**/
+#ifndef _AEAPECTAB_H_
+#define _AEAPECTAB_H_
+
+#include <string>
+#include <vector>
+
+namespace AEA_Impl
+{
+
+struct printPosition
+{
+  char row;
+  unsigned int column;
+};
+
+struct magstripePosition
+{
+  unsigned int track;
+  unsigned int block;
+  unsigned int column;
+};
+
+struct pectabElement
+{
+  std::string number;
+  unsigned int length;
+  std::vector<printPosition> printPositions;
+  std::vector<magstripePosition> magstripePositions;
+  char steeringCommand;
+
+  void clear()
+  {
+    number = "";
+    length = 0;
+    printPositions.clear();
+    magstripePositions.clear();
+    steeringCommand = 0;
+  }
+
+  pectabElement()
+  {
+    clear();
+  }
+};
+
+struct pectabData
+{
+  char delimiterPectab;
+  char delimiter;
+  char unreadable;
+  std::string formatCode;
+  char pectabVersion;
+  char atbSteering;
+  char logoSteering;
+  char colorSteering;
+  std::string headerTicketing;
+  std::string headerCheckin;
+  std::string headerBoarding;
+
+  std::vector<pectabElement> elements;
+
+  bool fValid;
+
+  void clear()
+  {
+    delimiterPectab = 0;
+    delimiter = 0;
+    unreadable = 0;
+    formatCode = "";
+    pectabVersion = 0;
+    atbSteering = 0;
+    logoSteering = 0;
+    colorSteering = 0;
+    headerTicketing = "";
+    headerCheckin = "";
+    headerBoarding = "";
+
+    elements.clear();
+
+    fValid = false;
+  }
+
+  pectabData()
+  {
+    clear();
+  }
+};
+
+class pectabParser;
+
+class pectab
+{
+  std::string pectabString;
+
+  pectabParser * pParser;
+public:
+
+  enum RC
+  {
+    RC_OK,
+    RC_ERROR
+  };
+
+  pectab();                    // default constructor not implemented
+  pectab(pectab const&);       // copy constructor not implemented
+
+  pectab(std::string const & data);
+  ~pectab();
+
+  /**
+   * getters for global pectab data
+  **/
+  char getDelimiterPectab() const;
+  char getDelimiter() const;
+  char getUnreadable() const;
+  std::string const & getFormatCode() const;
+  char getPectabVersion() const;
+  char getATBSteering() const;
+  char getLogoSteering() const;
+  char getColorSteering() const;
+  std::string const & getHeaderTicketing() const;
+  std::string const & getHeaderCheckin() const;
+  std::string const & getHeaderBoarding() const;
+
+  std::vector<pectabElement> const & getElements() const;
+
+  bool isValid() const;
+};
+
+} // namespace AEA_Impl;
+
+#endif //_AEAPECTAB_H_
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/inc/decoder/AEAReader.h b/SelfServiceCommon/Massai/cpp/AEAParser/inc/decoder/AEAReader.h
new file mode 100644
index 00000000..689a400f
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/inc/decoder/AEAReader.h
@@ -0,0 +1,23 @@
+/**
+ **************************************************************************
+ *
+ * @file AEAReader.h
+ *
+ * Contains class AEAReader.
+ *
+ * @author MaK
+ *
+ * Copyright (c) 2005 MATERNA Information & Communications
+ *
+ **************************************************************************
+**/
+#ifndef _AEAREADER_H_
+#define _AEAREADER_H_
+
+#include "AEAPectab.h"
+
+class AEAReader
+{
+};
+
+#endif //_AEAREADER_H_
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/makefile.mak b/SelfServiceCommon/Massai/cpp/AEAParser/makefile.mak
new file mode 100644
index 00000000..ae3e25f7
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/makefile.mak
@@ -0,0 +1,52 @@
+######################################################################
+#
+# /vob/SelfServiceCommon/Massai/cpp/AEAParser/makefile.mak
+#
+######################################################################
+
+!include $(BUILDROOT)\Build\cpp\makefile.common.mak
+
+######################################################################
+
+MY_CFLAGS =     -GR -G5 $(INC_COMMON_INTER)
+
+MY_LIB1 =       $(_LIB)\aeaParser.lib
+
+MY_LIB1_OBJS =  $(_OBJ)\local_def.obj \
+                $(_OBJ)\aeaParse.obj \
+                $(_OBJ)\aeaToken.obj \
+                $(_OBJ)\aeaLogo.obj \
+                $(_OBJ)\aeaResponse.obj \
+                $(_OBJ)\aeaBoardingPassResponse.obj \
+                $(_OBJ)\aeaBagtagResponse.obj \
+                $(_OBJ)\aeaBagtagPectab.obj \
+                $(_OBJ)\aeaBoardingPassTemplate.obj \
+                $(_OBJ)\aeaBoardingPassPectab.obj \
+                $(_OBJ)\aeaBinSetup.obj \
+                $(_OBJ)\aeaContext.obj \
+                $(_OBJ)\aeaReceipt.obj \
+                $(_OBJ)\aeaSimulator_Impl.obj \
+                $(_OBJ)\aeaSimulator_BoardingPassImpl.obj \
+                $(_OBJ)\aeaSimulator_BagtagImpl.obj \
+                $(_OBJ)\aeaSimulator.obj \
+                $(_OBJ)\aeaPrintProcessor.obj
+
+######################################################################
+
+MY_BIN1 =               $(_BIN)\TestAEASimulator.exe
+
+MY_BIN1_USER_LIBS =     $(_LIB)\aeaParser.lib $(LIB_TRACE) $(LIB_TOOLS) $(LIB_SYSTOOLS)
+
+MY_BIN1_OBJS =          $(_OBJ)\Console.obj $(_OBJ)\TestAEASimulator.obj
+
+######################################################################
+
+MY_BIN2 =               $(_BIN)\AEASimulatorTest.exe
+
+MY_BIN2_USER_LIBS =     $(_LIB)\aeaParser.lib $(LIB_TRACE) $(LIB_SYSTOOLS)
+
+MY_BIN2_OBJS =          $(_OBJ)\AEASimulatorTest.obj
+
+######################################################################
+
+!include $(BUILDROOT)\Build\cpp\makefile.rules.mak
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/src/AEASimulatorTest.cpp b/SelfServiceCommon/Massai/cpp/AEAParser/src/AEASimulatorTest.cpp
new file mode 100644
index 00000000..ce749d6f
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/src/AEASimulatorTest.cpp
@@ -0,0 +1,68 @@
+//---------------------------------------------------------------------------
+//
+//  file:       TestAEASimulator.cpp
+//
+//  purpose:    interpret aea commands
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#pragma warning (disable:4786)
+
+#include "AEAParser/aeaSimulator.h"
+#include <iostream>
+#include "TraceClt.h"
+
+using namespace MASSAI::AEA;
+
+namespace
+{
+  AEAPrintSimulation aeaPrinter("SIM");
+
+  std::string getResultCodeText(ResultCode code)
+  {
+    switch(code)
+    {
+      case RESULT_SUCCESS: return "success";
+      default:             return "format error";
+    }
+  }
+  std::string getCommandText(Command code)
+  {
+    switch(code)
+    {
+      case COMMAND_SETUP:      return "setup";
+      case COMMAND_PRINT:      return "print";
+      case COMMAND_INDICATION: return "indication";
+      default:                 return "unknown";
+    }
+  }
+  void sendCommand(const std::string& command)
+  {
+    std::cout << "Printer command: (" << command << ")" << std::endl;
+    AEAResult result= aeaPrinter.sendCommand(command);
+    if(result.get() != 0)
+    {
+      std::cout << "Printer response: " << std::endl
+                << "(" << getCommandText(result->getCommandType()) << ")" << std::endl
+                << "(" << getResultCodeText(result->getResultCode()) << ")" << std::endl
+                << "(" << result->getResponse() << ")" << std::endl;
+
+    }
+    else
+    {
+      std::cout << "No response from printer" << std::endl;
+    }
+  }
+
+}
+
+int main(int argc, char** argv)
+{
+  openTrace("AEASimulatorTest");
+  sendCommand("CTHX");
+  closeTrace();
+  return 0;
+}
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/src/Console.cpp b/SelfServiceCommon/Massai/cpp/AEAParser/src/Console.cpp
new file mode 100644
index 00000000..ea4207fa
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/src/Console.cpp
@@ -0,0 +1,230 @@
+//---------------------------------------------------------------------------
+//
+//  file:       Console.cpp
+//
+//  purpose:    read input from std in
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#pragma warning (disable:4786)
+
+#include "Console.h"
+#include <conio.h>
+#include "mInFile.hpp"
+#include <iostream>
+
+
+namespace Console
+{
+  std::istream& getline(std::istream &is, std::string &s)
+  {
+   using namespace std;
+
+   char buffer[20];
+   const int bufsize = sizeof buffer;
+   s.erase();
+
+   for (;;) {
+    is.getline(buffer, bufsize);
+    s += buffer;
+    if (is.gcount() == bufsize-1 && is.fail() && !is.eof()) {
+     is.clear();
+    } else {
+     break;
+    }
+   }
+
+   return is;
+  }
+  std::istream& getline(std::istream &is, char *buf, size_t buf_len)
+  {
+   using namespace std;
+
+   size_t rest = buf_len - 1;
+   bool   err = false;
+
+   buf[0] = 0;
+
+   for (;;) {
+    is.getline(buf, rest);
+    if (is.gcount() == rest-1 && is.fail() && !is.eof()) {
+     is.clear();
+     err = true;
+    } else {
+     break;
+    }
+   }
+
+   if (err)
+    *buf = 0;
+
+   return is;
+  }
+
+  Input_::Input_(InputType type, const std::string& prompt):
+    type(type),
+    prompt(prompt)
+  {}
+
+
+  SelectionCommandBase::SelectionCommandBase()
+  {}
+  SelectionCommandBase::~SelectionCommandBase()
+  {}
+  ResultCode SelectionCommandBase::execute(char selector, int parameter, const Strings& parameterList)
+  {
+    return RC_NOT_FOUND;
+  }
+
+  ConsoleSelection::ConsoleSelection():
+    m_quit(false)
+  {}
+  ConsoleSelection::~ConsoleSelection()
+  {}
+  void ConsoleSelection::add(const Selection_& command)
+  {
+    m_selectionList.push_back(command);
+  }
+  void ConsoleSelection::add(const Selection& command)
+  {
+    addInput(command.pCmd, command.selector, command.help, command.parameterList, command.parameter);
+  }
+  void ConsoleSelection::add(SelectionCommandBase* pCmd, const std::string& selector, const std::string& help, const InputList_& parameterList, int parameter)
+  {
+    Selection_ selection;
+    selection.pCmd= pCmd;
+    selection.selector= selector;
+    selection.help= help;
+    selection.parameterList= parameterList;
+    selection.parameter= parameter;
+    add(selection);
+  }
+  void ConsoleSelection::addSimple(SelectionCommandBase* pCmd, const std::string& selector, const std::string& help, int parameter)
+  {
+    InputList_ parameterList;
+    add(pCmd, selector, help, parameterList, parameter);
+  }
+  void ConsoleSelection::addInput(SelectionCommandBase* pCmd, const std::string& selector, const std::string& help, const InputList& input, int parameter)
+  {
+    InputList_ parameterList;
+    for(int i= 0; i < MAX_PARAMETER_COUNT; i++)
+    {
+      if(input[i].type != IT_IGNORE && input[i].pPrompt != 0)
+      {
+        Input_ in(input[i].type, input[i].pPrompt);
+        parameterList.push_back(in);
+      }
+    }
+    add(pCmd, selector, help, parameterList, parameter);
+  }
+  void ConsoleSelection::loop() const
+  {
+    m_quit= false;
+    printHelp();
+    while(!m_quit)
+    {
+      if(select() == Console::RC_NOT_FOUND)
+      {
+        printHelp();
+      }
+    }
+  }
+  ResultCode ConsoleSelection::select() const
+  {
+    ResultCode result= RC_NOT_FOUND;
+    char c= readChar();
+    const Selection_* pSelect= getCommand(c);
+    if(pSelect != 0)
+    {
+      int size= pSelect->parameterList.size();
+      Strings parameterList(size);
+
+      std::cout << pSelect->help << std::endl;
+      InputList_::const_iterator it= pSelect->parameterList.begin();
+      InputList_::const_iterator end= pSelect->parameterList.end();
+      for(int i= 0; (it != end) && (i < size); it++, i++)
+      {
+        const Input_& input= *it;
+        std::string command= getLine(input.prompt);
+        if(input.type == IT_FILENAME)
+        {
+          mInFile<std::string> file(command.c_str());
+          if(file.success())
+          {
+            parameterList[i]= file.container();
+          }
+          else
+          {
+            std::cout << "Reading failed: (" << command << ")" << std::endl;
+            result= RC_FAILED;
+            break;
+          }
+        }
+        else
+        {
+          parameterList[i]= command;
+        }
+      }
+      if(result != RC_FAILED)
+      {
+        result= pSelect->pCmd->execute(c, pSelect->parameter, parameterList);
+      }
+    }
+    return result;
+  }
+  ResultCode ConsoleSelection::execute(char selector, int parameter, const Strings& parameterList)
+  {
+    if(parameter == P_QUIT)
+    {
+      m_quit= true;
+    }
+    else
+    {
+      printHelp();
+    }
+    return RC_SUCCESS;
+  }
+  void ConsoleSelection::printHelp() const
+  {
+    SelectionList::const_iterator it= m_selectionList.begin();
+    SelectionList::const_iterator end= m_selectionList.end();
+    std::cout << "Commands:" << std::endl;
+    for(; it != end; it++)
+    {
+      std::cout << " " << it->selector << ": " << it->help << std::endl;
+    }
+  }
+  std::string ConsoleSelection::getLine(const std::string& help) const
+  {
+    std::string result;
+    std::cout << help << ": ";
+    std::cout.flush();
+    Console::getline(std::cin, result);
+    return result;
+  }
+  char ConsoleSelection::readChar() const
+  {
+    std::cout << std::endl;
+    char c = _getch();
+    std::cout << c << std::endl;
+    return c;
+  }
+  const Selection_* ConsoleSelection::getCommand(char c) const
+  {
+    const Selection_* result= 0;
+    SelectionList::const_iterator it= m_selectionList.begin();
+    SelectionList::const_iterator end= m_selectionList.end();
+    for(; it != end; it++)
+    {
+      if((*it).selector.find(c) != std::string::npos)
+      {
+        result= &(*it);
+        break;
+      }
+    }
+    return result;
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/src/TestAEASimulator.cpp b/SelfServiceCommon/Massai/cpp/AEAParser/src/TestAEASimulator.cpp
new file mode 100644
index 00000000..399d2020
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/src/TestAEASimulator.cpp
@@ -0,0 +1,204 @@
+//---------------------------------------------------------------------------
+//
+//  file:       TestAEASimulator.cpp
+//
+//  purpose:    interpret aea commands
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#pragma warning (disable:4786)
+
+#include "AEAParser/aeaBagtagPectab.h"
+#include "AEAParser/aeaBoardingPassPectab.h"
+#include "AEAParser/aeaSimulator.h"
+#include "AEAParser/aeaLogo.h"
+#include "Console.h"
+#include "TraceClt.h"
+#include <iostream>
+
+using namespace MASSAI::AEA;
+
+
+AEAPrintSimulation aeaPrinter("SIM");
+ContextType contextType= BOARDINGPASS;
+
+
+class SendCommand: public Console::SelectionCommandBase
+{
+  public:
+    std::string getResultCodeText(ResultCode code)
+    {
+      switch(code)
+      {
+        case RESULT_SUCCESS: return "success";
+        default:             return "format error";
+      }
+    }
+    std::string getCommandText(Command code)
+    {
+      switch(code)
+      {
+        case COMMAND_SETUP:      return "setup";
+        case COMMAND_PRINT:      return "print";
+        case COMMAND_INDICATION: return "indication";
+        default:                 return "unknown";
+      }
+    }
+    Console::ResultCode execute(char selector, int parameter, const Console::Strings& parameterList)
+    {
+      Console::ResultCode rc= Console::RC_FAILED;
+      if(parameterList.size() > 0)
+      {
+        AEAResult result= aeaPrinter.sendCommand(parameterList[0], contextType);
+        if(result.get() != 0)
+        {
+          std::cout << "Printer response: " << std::endl
+                    << "(" << getCommandText(result->getCommandType()) << "), "
+                    << "(" << getResultCodeText(result->getResultCode()) << ")" << std::endl
+                    << "(" << result->getResponse() << ")" << std::endl;
+
+          rc= Console::RC_SUCCESS;
+        }
+        else
+        {
+          std::cout << "No response from printer" << std::endl;
+        }
+      }
+      return rc;
+    }
+};
+class SetContext: public Console::SelectionCommandBase
+{
+  public:
+    Console::ResultCode execute(char selector, int parameter, const Console::Strings& parameterList)
+    {
+      Console::ResultCode rc= Console::RC_FAILED;
+      if(parameterList.size() > 0)
+      {
+        aeaPrinter.setContext(parameterList[0], contextType);
+        rc= Console::RC_SUCCESS;
+      }
+      return rc;
+    }
+};
+class SetPrinterType: public Console::SelectionCommandBase
+{
+  public:
+    Console::ResultCode execute(char selector, int parameter, const Console::Strings& parameterList)
+    {
+      contextType= ContextType(parameter);
+      return Console::RC_SUCCESS;
+    }
+};
+class BTGetPectab: public Console::SelectionCommandBase
+{
+  public:
+    Console::ResultCode execute(char selector, int parameter, const Console::Strings& parameterList)
+    {
+      Console::ResultCode rc= Console::RC_FAILED;
+      if(parameterList.size() >= 2)
+      {
+         const BagTagPectabData* pectab= aeaPrinter.getBagTagPectabData(aeaPrinter.getContext(contextType), parameterList[0], parameterList[1]);
+         if(pectab != 0)
+         {
+           std::cout << "pectab:                    (" << pectab->pectab() << ")" << std::endl;
+           std::cout << "pectabId:                  (" << pectab->pectabId() << ")" << std::endl;
+           std::cout << "pectabVersion:             (" << pectab->pectabVersion() << ")" << std::endl;
+           std::cout << "continuationCharacter:     (" << pectab->continuationCharacter() << ")" << std::endl;
+           std::cout << "autoIncrementFieldLength:  (" << pectab->autoIncrementFieldLength() << ")" << std::endl;
+           std::cout << "colorSteering:             (" << pectab->colorSteering() << ")" << std::endl;
+           std::cout << "width_tenth_mm:            (" << pectab->width_tenth_mm() << ")" << std::endl;
+           std::cout << "mirrorPoint_tenth_mm:      (" << pectab->mirrorPoint_tenth_mm() << ")" << std::endl;
+           std::cout << "elementReferenceCharacter: (" << pectab->elementReferenceCharacter() << ")" << std::endl;
+           std::cout << "delimiter:                 (" << pectab->delimiter() << ")" << std::endl;
+           std::cout << "version:                   (" << pectab->version() << ")" << std::endl;
+         }
+         else
+         {
+           std::cout << "pectab " << parameterList[0] << ", " << parameterList[1] << " not found" << std::endl;
+         }
+      }
+      return rc;
+    }
+};
+class GetPectab: public Console::SelectionCommandBase
+{
+  public:
+    Console::ResultCode execute(char selector, int parameter, const Console::Strings& parameterList)
+    {
+      Console::ResultCode rc= Console::RC_FAILED;
+      if(parameterList.size() >= 1)
+      {
+        const PectabData* pectab= aeaPrinter.getPectabData(aeaPrinter.getContext(contextType), parameterList[0]);
+        if(pectab != 0)
+        {
+          std::cout << "pectab:       (" << pectab->pectab() << ")" << std::endl;
+          std::cout << "pectabId:     (" << pectab->pectabId() << ")" << std::endl;
+          std::cout << "Ticket:       (" << pectab->transactionCodeTicket() << ")" << std::endl;
+          std::cout << "Checkin:      (" << pectab->transactionCodeCheckin() << ")" << std::endl;
+          std::cout << "Boarding:     (" << pectab->transactionCodeBoarding() << ")" << std::endl;
+          std::cout << "logoSteering: (" << pectab->logoSteering() << ")" << std::endl;
+          std::cout << "colorSteering:(" << pectab->colorSteering() << ")" << std::endl;
+          std::cout << "unreadable:   (" << pectab->unreadable() << ")" << std::endl;
+          std::cout << "delimiter:    (" << pectab->delimiter() << ")" << std::endl;
+          std::cout << "version:      (" << pectab->version() << ")" << std::endl;
+        }
+        else
+        {
+          std::cout << "pectab " << parameterList[0] << " not found" << std::endl;
+        }
+        rc= Console::RC_SUCCESS;
+      }
+      return rc;
+    }
+};
+int main(int argc, char** argv)
+{
+  openTrace("TestAEASimulator");
+
+  Console::ConsoleSelection selection;
+  SendCommand sendCommand;
+  SetContext contextCommand;
+  SetPrinterType typeCommand;
+  GetPectab pectabCommand;
+  BTGetPectab btPectabCommand;
+
+  selection.addSimple(&selection,      "h", "help", Console::ConsoleSelection::P_HELP);
+  selection.addSimple(&selection,      "q", "quit", Console::ConsoleSelection::P_QUIT);
+  selection.addSimple(&typeCommand,    "b", "select bagtag printer", BAGTAG);
+  selection.addSimple(&typeCommand,    "t", "select ticket printer", BOARDINGPASS);
+
+  Console::Selection pectabInputList=
+    {&pectabCommand,   "p", "print boarding pectab",
+      {Console::IT_INPUT, "enter pectab id"}};
+  selection.add(pectabInputList);
+
+  Console::Selection btPectabInputList=
+    {&btPectabCommand, "P", "print bagtag pectab",
+      {{Console::IT_INPUT, "enter pectab id"},
+       {Console::IT_INPUT, "enter pectab version"}}};
+  selection.add(btPectabInputList);
+
+  Console::Selection contextInputList=
+    {&contextCommand,  "c", "set context",
+      {Console::IT_INPUT, "enter context id"}};
+  selection.add(contextInputList);
+
+  Console::Selection commandInputList=
+    {&sendCommand,     "s", "send command to printer",
+      {Console::IT_INPUT, "enter aea command"}};
+  selection.add(commandInputList);
+
+  Console::Selection commandFileInputList=
+    {&sendCommand,     "f", "send file to printer",
+      {Console::IT_FILENAME, "enter aea command filename"}};
+  selection.add(commandFileInputList);
+
+  selection.loop();
+
+  closeTrace();
+  return 0;
+}
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaBagtagPectab.cpp b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaBagtagPectab.cpp
new file mode 100644
index 00000000..44cba843
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaBagtagPectab.cpp
@@ -0,0 +1,822 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaBagtagPectab.cpp
+//
+//  purpose:    aea command data, pectab data structure for parsing baggage tag commands
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//  history:
+//---------------------------------------------------------------------------
+
+
+#pragma warning (disable:4786)
+
+#include "AEAParser/aeaBagtagPectab.h"
+#include "aeaToken.h"
+#include "TraceClt.h"
+
+namespace
+{
+  const char* BTP_PECTAB_LOAD= "BTT";
+  const char  BTP_PECTAB_CHARACTER_ID= 'C';
+  const char  BTP_PECTAB_LOGO_ID= 'L';
+  const char  BTP_PECTAB_SEPARATIONLINE_ID= 'S';
+  const char  BTP_PECTAB_BARCODE_ID= 'B';
+  const char  BTP_PECTAB_INCREMENT_BARCODE_ID= 'I';
+  const char  BTP_PECTAB_INCREMENT_CHARACTER_ID= 'K';
+  const char* BEFORE_FIRST_FIELD= "00";
+}
+
+
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    BagTagPectabField::BagTagPectabField()
+    {}
+    BagTagPectabField* BagTagPectabField::readPectabField(char referenceChar, char delimiter, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+    {
+      if(Tokenizer::readFieldId(inBegin, inEnd, outBegin, inBegin))
+      {
+        wrtTrace(SecondaryRuntime_HERE, "field (%.1000s)", std::string(outBegin, inBegin).c_str());
+        std::string elementId= std::string(outBegin, inBegin);
+        std::auto_ptr<BagTagLogo> logo= std::auto_ptr<BagTagLogo>(new BagTagLogo);
+        std::auto_ptr<BagTagSeparation> line= std::auto_ptr<BagTagSeparation>(new BagTagSeparation);
+        std::auto_ptr<BagTagBarcode> barcode= std::auto_ptr<BagTagBarcode>(new BagTagBarcode);
+        std::auto_ptr<BagTagCharacter> text= std::auto_ptr<BagTagCharacter>(new BagTagCharacter);
+        Iterator readBegin;
+        if(logo->readBagTagLogo(referenceChar, delimiter, inBegin, inEnd, readBegin, outEnd))
+        {
+          static_cast<BagTagPectabField*>(logo.get())->m_elementId= elementId;
+          return logo.release();
+        }
+        else if(line->readBagTagSeparation(delimiter, inBegin, inEnd, readBegin, outEnd))
+        {
+          static_cast<BagTagPectabField*>(line.get())->m_elementId= elementId;
+          return line.release();
+        }
+        else if(barcode->readBagTagBarcode(referenceChar, delimiter, inBegin, inEnd, readBegin, outEnd))
+        {
+          static_cast<BagTagPectabField*>(barcode.get())->m_elementId= elementId;
+          return barcode.release();
+        }
+        else if(text->readBagTagCharacter(referenceChar, delimiter, inBegin, inEnd, readBegin, outEnd))
+        {
+          static_cast<BagTagPectabField*>(text.get())->m_elementId= elementId;
+          return text.release();
+        }
+      }
+      wrtTrace(SecondaryRuntime_HERE, "no match");
+      return 0;
+
+    }
+    const std::string& BagTagPectabField::getId() const
+    {
+      return m_elementId;
+    }
+    bool BagTagPectabField::mirror() const
+    {
+      return m_mirror;
+    }
+    void BagTagPectabField::setMirror(bool mirror)
+    {
+      m_mirror= mirror;
+    }
+    void BagTagPectabField::readElementReference(char referenceChar, const std::string& text, StringList& referenceList, StringList& textList) const
+    {
+      std::string::size_type pos= 0;
+      std::string::size_type oldPos= pos;
+      while(pos != std::string::npos)
+      {
+        oldPos= pos;
+        pos= text.find(referenceChar, pos);
+        if(pos != std::string::npos)
+        {
+          wrtTrace(SecondaryRuntime_HERE, "text (%.1000s)", std::string(text, oldPos, pos-oldPos).c_str());
+          textList.push_back(std::string(text, oldPos, pos-oldPos));
+          if(pos < text.size())
+          {
+            wrtTrace(SecondaryRuntime_HERE, "reference (%.1000s)", std::string(text, pos+1, 2).c_str());
+            referenceList.push_back(std::string(text, pos+1, 2));
+            pos+= 3;
+          }
+          else
+          {
+            pos= std::string::npos;
+          }
+        }
+        else
+        {
+          wrtTrace(SecondaryRuntime_HERE, "text (%.1000s)", std::string(text, oldPos, text.size() - oldPos).c_str());
+          textList.push_back(std::string(text, oldPos, text.size() - oldPos));
+        }
+      }
+    }
+
+    std::string BagTagPectabField::incrementContent(const std::string& content, int increment, int fieldLength) const
+    {
+      std::string prefix;
+      std::string number;
+      if(fieldLength < content.size())
+      {
+        prefix= std::string(content, 0, content.size() - fieldLength);
+        number= std::string(content, content.size() - fieldLength, fieldLength);
+      }
+      else
+      {
+        number= content;
+      }
+      char buffer[256];
+      __int64 value= _atoi64(number.c_str()) + increment;
+      number= _i64toa(value, buffer, 10);
+      if(number.size() > fieldLength)
+      {
+        number= std::string(number, content.size() - fieldLength, fieldLength);
+      }
+      if(number.size() < fieldLength && prefix.size() > 0)
+      {
+        number= std::string(fieldLength - number.size(), '0') + number;
+      }
+      return prefix + number;
+
+    }
+
+
+
+    BagTagCharacter::BagTagCharacter()
+    {}
+    bool BagTagCharacter::readBagTagCharacter(char referenceChar, char delimiter, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+    {
+      bool result= false;
+      std::string::const_iterator readBegin;
+      outBegin= inBegin;
+      if(Tokenizer::readChar(BTP_PECTAB_CHARACTER_ID, inBegin, inEnd, readBegin, inBegin))
+      {
+        m_increment= false;
+        result= true;
+      }
+      else if(Tokenizer::readChar(BTP_PECTAB_INCREMENT_CHARACTER_ID, inBegin, inEnd, readBegin, inBegin))
+      {
+        m_increment= true;
+        result= true;
+      }
+      if(result)
+      {
+        result= false;
+        wrtTrace(SecondaryRuntime_HERE, "character id (%.1000s)", std::string(readBegin, inBegin).c_str());
+        if(Tokenizer::readBagTagFont(inBegin, inEnd, readBegin, inBegin))
+        {
+          wrtTrace(SecondaryRuntime_HERE, "font (%.1000s)", std::string(readBegin, inBegin).c_str());
+          if(Tokenizer::readMirrorIndicator(inBegin, inEnd, readBegin, inBegin))
+          {
+            wrtTrace(SecondaryRuntime_HERE, "mirror (%.1000s)", std::string(readBegin, inBegin).c_str());
+            setMirror(Tokenizer::mirrorIndicator(readBegin));
+            if(Tokenizer::readBagTagOrientation(inBegin, inEnd, readBegin, inBegin))
+            {
+              wrtTrace(SecondaryRuntime_HERE, "print orientation (%.1000s)", std::string(readBegin, inBegin).c_str());
+              m_printOrientation= Tokenizer::bagTagOrientation(readBegin);
+              m_horizontalAlignment= Tokenizer::bagTagAlignment(readBegin);
+              m_reverseView= Tokenizer::bagTagReverseView(readBegin);
+              if(Tokenizer::readDigit(3, inBegin, inEnd, readBegin, inBegin))
+              {
+                wrtTrace(SecondaryRuntime_HERE, "vertical position (%.1000s)", std::string(readBegin, inBegin).c_str());
+                m_y= 10 * Tokenizer::digit(readBegin, inBegin);
+                if(Tokenizer::readDigit(2, inBegin, inEnd, readBegin, inBegin))
+                {
+                  wrtTrace(SecondaryRuntime_HERE, "horizontal position (%.1000s)", std::string(readBegin, inBegin).c_str());
+                  m_x= 10 * Tokenizer::digit(readBegin, inBegin);
+                  if(Tokenizer::readDigit(2, inBegin, inEnd, readBegin, inBegin))
+                  {
+                    wrtTrace(SecondaryRuntime_HERE, "height (%.1000s)", std::string(readBegin, inBegin).c_str());
+                    m_height= 10 * Tokenizer::digit(readBegin, inBegin);
+                    if(Tokenizer::readDigit(2, inBegin, inEnd, readBegin, inBegin))
+                    {
+                      wrtTrace(SecondaryRuntime_HERE, "width (%.1000s)", std::string(readBegin, inBegin).c_str());
+                      m_width= 10 * Tokenizer::digit(readBegin, inBegin);
+                      Tokenizer::readToChar(delimiter, inBegin, inEnd, readBegin, inBegin);
+                      wrtTrace(SecondaryRuntime_HERE, "text (%.1000s)", std::string(readBegin, inBegin).c_str());
+                      readElementReference(referenceChar, std::string(readBegin, inBegin), m_referenceList, m_prefixTextList);
+                      outEnd= inBegin;
+                      result= true;
+                    }
+                  }
+                }
+              }
+            }
+          }
+        }
+      }
+      return result;
+    }
+    Orientation BagTagCharacter::getPrintOrientation() const
+    {
+      return m_printOrientation;
+    }
+    HorizontalAlignment BagTagCharacter::getHorizontalAlignment() const
+    {
+      return m_horizontalAlignment;
+    }
+    ReverseView BagTagCharacter::getReverseView() const
+    {
+      return m_reverseView;
+    }
+    int BagTagCharacter::getX() const
+    {
+      return m_x;
+    }
+    int BagTagCharacter::getY() const
+    {
+      return m_y;
+    }
+    int BagTagCharacter::getHeight() const
+    {
+      return m_height;
+    }
+    int BagTagCharacter::getWidth() const
+    {
+      return m_width;
+    }
+    const StringList& BagTagCharacter::getReferenceList() const
+    {
+      return m_referenceList;
+    }
+    const StringList& BagTagCharacter::getPrefixTextList() const
+    {
+      return m_prefixTextList;
+    }
+    bool BagTagCharacter::useIncrement() const
+    {
+      return m_increment;
+    }
+
+
+
+    BagTagLogo::BagTagLogo()
+    {}
+
+    bool BagTagLogo::readBagTagLogo(char referenceChar, char delimiter, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+    {
+      bool result= false;
+      std::string::const_iterator readBegin;
+      outBegin= inBegin;
+      if(Tokenizer::readChar(BTP_PECTAB_LOGO_ID, inBegin, inEnd, readBegin, inBegin))
+      {
+        wrtTrace(SecondaryRuntime_HERE, "logo (%.1000s)", std::string(readBegin, inBegin).c_str());
+        if(Tokenizer::readChar('0', inBegin, inEnd, readBegin, inBegin))
+        {
+          wrtTrace(SecondaryRuntime_HERE, "reserved (%.1000s)", std::string(readBegin, inBegin).c_str());
+          if(Tokenizer::readMirrorIndicator(inBegin, inEnd, readBegin, inBegin))
+          {
+            wrtTrace(SecondaryRuntime_HERE, "mirror (%.1000s)", std::string(readBegin, inBegin).c_str());
+            setMirror(Tokenizer::mirrorIndicator(readBegin));
+            if(Tokenizer::readBagTagOrientation(inBegin, inEnd, readBegin, inBegin))
+            {
+              wrtTrace(SecondaryRuntime_HERE, "print orientation (%.1000s)", std::string(readBegin, inBegin).c_str());
+              m_printOrientation= Tokenizer::bagTagOrientation(readBegin);
+              m_horizontalAlignment= Tokenizer::bagTagAlignment(readBegin);
+              m_reverseView= Tokenizer::bagTagReverseView(readBegin);
+              if(Tokenizer::readDigit(3, inBegin, inEnd, readBegin, inBegin))
+              {
+                wrtTrace(SecondaryRuntime_HERE, "vertical position (%.1000s)", std::string(readBegin, inBegin).c_str());
+                m_y= 10 * Tokenizer::digit(readBegin, inBegin);
+                if(Tokenizer::readDigit(2, inBegin, inEnd, readBegin, inBegin))
+                {
+                  wrtTrace(SecondaryRuntime_HERE, "horizontal position (%.1000s)", std::string(readBegin, inBegin).c_str());
+                  m_x= 10 * Tokenizer::digit(readBegin, inBegin);
+                  if(Tokenizer::readText("00", inBegin, inEnd, readBegin, inBegin))
+                  {
+                    wrtTrace(SecondaryRuntime_HERE, "reserved (%.1000s)", std::string(readBegin, inBegin).c_str());
+                    if(Tokenizer::readText("00", inBegin, inEnd, readBegin, inBegin))
+                    {
+                      wrtTrace(SecondaryRuntime_HERE, "reserved (%.1000s)", std::string(readBegin, inBegin).c_str());
+                      Tokenizer::readToChar(delimiter, inBegin, inEnd, readBegin, inBegin);
+                      wrtTrace(SecondaryRuntime_HERE, "text (%.1000s)", std::string(readBegin, inBegin).c_str());
+                      readElementReference(referenceChar, std::string(readBegin, inBegin), m_referenceList, m_prefixTextList);
+                      result= true;
+                      outEnd= inBegin;
+                    }
+                  }
+                }
+              }
+            }
+          }
+        }
+      }
+      return result;
+    }
+    Orientation BagTagLogo::getPrintOrientation() const
+    {
+      return m_printOrientation;
+    }
+    HorizontalAlignment BagTagLogo::getHorizontalAlignment() const
+    {
+      return m_horizontalAlignment;
+    }
+    ReverseView BagTagLogo::getReverseView() const
+    {
+      return m_reverseView;
+    }
+    int BagTagLogo::getX() const
+    {
+      return m_x;
+    }
+    int BagTagLogo::getY() const
+    {
+      return m_y;
+    }
+    const StringList& BagTagLogo::getReferenceList() const
+    {
+      return m_referenceList;
+    }
+    const StringList& BagTagLogo::getPrefixTextList() const
+    {
+      return m_prefixTextList;
+    }
+
+    BagTagSeparation::BagTagSeparation()
+    {}
+    bool BagTagSeparation::readBagTagSeparation(char delimiter, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+    {
+      bool result= false;
+      std::string::const_iterator readBegin;
+      outBegin= inBegin;
+      if(Tokenizer::readChar(BTP_PECTAB_SEPARATIONLINE_ID, inBegin, inEnd, readBegin, inBegin))
+      {
+        wrtTrace(SecondaryRuntime_HERE, "separation line (%.1000s)", std::string(readBegin, inBegin).c_str());
+        if(Tokenizer::readBagTagFont(inBegin, inEnd, readBegin, inBegin))
+        {
+          wrtTrace(SecondaryRuntime_HERE, "font (%.1000s)", std::string(readBegin, inBegin).c_str());
+          if(Tokenizer::readMirrorIndicator(inBegin, inEnd, readBegin, inBegin))
+          {
+            wrtTrace(SecondaryRuntime_HERE, "mirror (%.1000s)", std::string(readBegin, inBegin).c_str());
+            setMirror(Tokenizer::mirrorIndicator(readBegin));
+            if(Tokenizer::readBagTagLineOrientation(inBegin, inEnd, readBegin, inBegin))
+            {
+              wrtTrace(SecondaryRuntime_HERE, "print orientation (%.1000s)", std::string(readBegin, inBegin).c_str());
+              m_printOrientation= Tokenizer::bagTagOrientation(readBegin);
+              m_horizontalAlignment= Tokenizer::bagTagAlignment(readBegin);
+              if(Tokenizer::readDigit(3, inBegin, inEnd, readBegin, inBegin))
+              {
+                wrtTrace(SecondaryRuntime_HERE, "vertical position (%.1000s)", std::string(readBegin, inBegin).c_str());
+                m_y= 10 * Tokenizer::digit(readBegin, inBegin);
+                // if(Tokenizer::readText("00", inBegin, inEnd, readBegin, inBegin)) // should be "00" found "02" => ignore
+                if(Tokenizer::readDigit(2, inBegin, inEnd, readBegin, inBegin))
+                {
+                  wrtTrace(SecondaryRuntime_HERE, "reserved (%.1000s)", std::string(readBegin, inBegin).c_str());
+                  if(Tokenizer::readDigit(2, inBegin, inEnd, readBegin, inBegin))
+                  {
+                    wrtTrace(SecondaryRuntime_HERE, "height (%.1000s)", std::string(readBegin, inBegin).c_str());
+                    m_height= Tokenizer::digit(readBegin, inBegin);
+                    if(Tokenizer::readDigit(2, inBegin, inEnd, readBegin, inBegin))
+                    {
+                      wrtTrace(SecondaryRuntime_HERE, "width (%.1000s)", std::string(readBegin, inBegin).c_str());
+                      m_width= 10 * Tokenizer::digit(readBegin, inBegin);
+                      outEnd= inBegin;
+                      result= true;
+                    }
+                  }
+                }
+              }
+            }
+          }
+        }
+      }
+      return result;
+    }
+    Orientation BagTagSeparation::getPrintOrientation() const
+    {
+      return m_printOrientation;
+    }
+    HorizontalAlignment BagTagSeparation::getHorizontalAlignment() const
+    {
+      return m_horizontalAlignment;
+    }
+    int BagTagSeparation::getY() const
+    {
+      return m_y;
+    }
+    int BagTagSeparation::getHeight() const
+    {
+      return m_height;
+    }
+    int BagTagSeparation::getWidth() const
+    {
+      return m_width;
+    }
+
+    BagTagBarcodeDefinition::BagTagBarcodeDefinition()
+    {}
+    bool BagTagBarcodeDefinition::readBarcodeType(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+    {
+      bool result= false;
+      outBegin= inBegin;
+      if(inBegin != inEnd)
+      {
+        result= true;
+        switch(*inBegin)
+        {
+          case '0':
+            m_withCheckDigit= true;
+            m_barcode= PT_BC_INTERLEAVED_2_OF_5;
+            break;
+          case '1':
+            m_withCheckDigit= false;
+            m_barcode= PT_BC_INTERLEAVED_2_OF_5;
+            break;
+          case '2':
+            m_withCheckDigit= false;
+            m_barcode= PT_BC_INDUSTRIAL_2_OF_5;
+            break;
+          case '3':
+            m_withCheckDigit= false;
+            m_barcode= PT_BC_39;
+            break;
+          case '4':
+            m_withCheckDigit= true;
+            m_barcode= PT_BC_128;
+            break;
+          case '5':
+            m_withCheckDigit= false;
+            m_barcode= PT_BT_RESERVED;
+            break;
+          case '6':
+            m_withCheckDigit= true;
+            m_barcode= PT_BC_PDF417;
+            break;
+          case '7':
+            m_withCheckDigit= true;
+            m_barcode= PT_BC_128;
+            break;
+          case '8':
+            m_withCheckDigit= true;
+            m_barcode= PT_BC_39;
+            break;
+          case '9':
+            m_withCheckDigit= true;
+            m_barcode= PT_BC_INDUSTRIAL_2_OF_5;
+            break;
+          default:
+            result= false;
+        }
+        if(result == true)
+        {
+          wrtTrace(SecondaryRuntime_HERE, "barcode type(%.c)", *inBegin);
+          ++inBegin;
+          outEnd= inBegin;
+        }
+      }
+      return result;
+    }
+    bool BagTagBarcodeDefinition::readBarcodeFormat(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+    {
+      bool result= false;
+      std::string::const_iterator readBegin;
+      outBegin= inBegin;
+      if(Tokenizer::readDigit(2, inBegin, inEnd, readBegin, inBegin))
+      {
+        wrtTrace(SecondaryRuntime_HERE, "height (%.1000s)", std::string(readBegin, inBegin).c_str());
+        m_height= 10 * Tokenizer::digit(readBegin, inBegin);
+        if(Tokenizer::readDigit(inBegin, inEnd, readBegin, inBegin))
+        {
+          wrtTrace(SecondaryRuntime_HERE, "magnification (%.1000s)", std::string(readBegin, inBegin).c_str());
+          int magnification= Tokenizer::digit(readBegin);
+          if(Tokenizer::readDigit(inBegin, inEnd, readBegin, inBegin))
+          {
+            wrtTrace(SecondaryRuntime_HERE, "barcodeRatio (%.1000s)", std::string(readBegin, inBegin).c_str());
+            int barcodeRatio= Tokenizer::digit(readBegin);
+            if(1 <= m_height && m_height <= 990
+              && 1 <= magnification && magnification <= 9
+              && 1 <= barcodeRatio && barcodeRatio  <= 3)
+            {
+              if(m_barcode == PT_BC_PDF417)
+              {
+                /* CUSS Addendum A.1.9 Clarification of AEA2002 PDF417 support */
+                m_errorLevel= magnification -  1;
+                switch(barcodeRatio)
+                {
+                  case 1: m_wideBarDots= 6; m_narrowBarDots= 2; break;
+                  case 2: m_wideBarDots= 9; m_narrowBarDots= 3; break;
+                  case 3: m_wideBarDots= 12; m_narrowBarDots= 4; break;
+                }
+              }
+              else
+              {
+                switch(barcodeRatio)
+                {
+                  case 1: m_wideBarDots= magnification * 2; m_narrowBarDots= magnification; break;
+                  case 2: m_wideBarDots= magnification * 3; m_narrowBarDots= magnification; break;
+                  case 3: m_wideBarDots= magnification * 5; m_narrowBarDots= magnification * 2; break;
+                }
+                m_errorLevel= 3;
+              }
+              result= true;
+              outEnd= inBegin;
+            }
+          }
+        }
+      }
+      return result;
+    }
+    int BagTagBarcodeDefinition::getX() const
+    {
+      return m_x;
+    }
+    int BagTagBarcodeDefinition::getY() const
+    {
+      return m_y;
+    }
+    int BagTagBarcodeDefinition::getHeight() const
+    {
+      return m_height;
+    }
+    PectabBarcode BagTagBarcodeDefinition::getBarcode() const
+    {
+      return m_barcode;
+    }
+    bool BagTagBarcodeDefinition::useCheckDigit() const
+    {
+      return m_withCheckDigit;
+    }
+    int BagTagBarcodeDefinition::getWideBarDots() const
+    {
+      return m_wideBarDots;
+    }
+    int BagTagBarcodeDefinition::getNarrowBarDots() const
+    {
+      return m_narrowBarDots;
+    }
+    int BagTagBarcodeDefinition::getErrorLevel() const
+    {
+      return m_errorLevel;
+    }
+
+
+    BagTagBarcode::BagTagBarcode()
+    {}
+    bool BagTagBarcode::readBagTagBarcode(char referenceChar, char delimiter, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+    {
+      bool result= false;
+      std::string::const_iterator readBegin;
+      outBegin= inBegin;
+      if(Tokenizer::readChar(BTP_PECTAB_BARCODE_ID, inBegin, inEnd, readBegin, inBegin))
+      {
+        m_increment= false;
+        result= true;
+      }
+      else if(Tokenizer::readChar(BTP_PECTAB_INCREMENT_BARCODE_ID, inBegin, inEnd, readBegin, inBegin))
+      {
+        m_increment= true;
+        result= true;
+      }
+      if(result)
+      {
+        result= false;
+        wrtTrace(SecondaryRuntime_HERE, "barcode id (%.1000s)", std::string(readBegin, inBegin).c_str());
+        if(m_barcode.readBarcodeType(inBegin, inEnd, readBegin, inBegin))
+        {
+          wrtTrace(SecondaryRuntime_HERE, "font (%.1000s)", std::string(readBegin, inBegin).c_str());
+          if(Tokenizer::readMirrorIndicator(inBegin, inEnd, readBegin, inBegin))
+          {
+            wrtTrace(SecondaryRuntime_HERE, "mirror (%.1000s)", std::string(readBegin, inBegin).c_str());
+            setMirror(Tokenizer::mirrorIndicator(readBegin));
+            if(Tokenizer::readBagTagBarcodeOrientation(inBegin, inEnd, readBegin, inBegin))
+            {
+              wrtTrace(SecondaryRuntime_HERE, "print orientation (%.1000s)", std::string(readBegin, inBegin).c_str());
+              m_printOrientation= Tokenizer::bagTagOrientation(readBegin);
+              m_horizontalAlignment= Tokenizer::bagTagAlignment(readBegin);
+              if(Tokenizer::readDigit(3, inBegin, inEnd, readBegin, inBegin))
+              {
+                wrtTrace(SecondaryRuntime_HERE, "vertical position (%.1000s)", std::string(readBegin, inBegin).c_str());
+                m_y= 10 * Tokenizer::digit(readBegin, inBegin);
+                if(Tokenizer::readDigit(2, inBegin, inEnd, readBegin, inBegin))
+                {
+                  wrtTrace(SecondaryRuntime_HERE, "horizontal position (%.1000s)", std::string(readBegin, inBegin).c_str());
+                  m_x= 10 * Tokenizer::digit(readBegin, inBegin);
+                  if(m_barcode.readBarcodeFormat(inBegin, inEnd, readBegin, inBegin))
+                  {
+                    Tokenizer::readToChar(delimiter, inBegin, inEnd, readBegin, inBegin);
+                    wrtTrace(SecondaryRuntime_HERE, "text (%.1000s)", std::string(readBegin, inBegin).c_str());
+                    readElementReference(referenceChar, std::string(readBegin, inBegin), m_referenceList, m_prefixTextList);
+                    outEnd= inBegin;
+                    result= true;
+                  }
+                }
+              }
+            }
+          }
+        }
+      }
+      return result;
+    }
+    const BagTagBarcodeDefinition& BagTagBarcode::getBarcode() const
+    {
+      return m_barcode;
+    }
+    Orientation BagTagBarcode::getPrintOrientation() const
+    {
+      return m_printOrientation;
+    }
+    HorizontalAlignment BagTagBarcode::getHorizontalAlignment() const
+    {
+      return m_horizontalAlignment;
+    }
+    int BagTagBarcode::getX() const
+    {
+      return m_x;
+    }
+    int BagTagBarcode::getY() const
+    {
+      return m_y;
+    }
+    const StringList& BagTagBarcode::getReferenceList() const
+    {
+      return m_referenceList;
+    }
+    const StringList& BagTagBarcode::getPrefixTextList() const
+    {
+      return m_prefixTextList;
+    }
+    bool BagTagBarcode::useIncrement() const
+    {
+      return m_increment;
+    }
+
+
+    BagTagPectabData::BagTagPectabData()
+    {}
+    bool BagTagPectabData::readPectabData(const std::string& contextId, const std::string& pectabCmd) throw(ParseException)
+    {
+      std::string::const_iterator it= pectabCmd.begin();
+      std::string::const_iterator end= pectabCmd.end();
+      std::string::const_iterator readBegin;
+      std::string fieldId= BEFORE_FIRST_FIELD;
+      bool success= false;
+      bool isPectab= false;
+      switch(success)  // not really a switch statement; environment for using break is needed
+      {
+        case false:
+        {
+          if(!Tokenizer::readText(BTP_PECTAB_LOAD, it, end, readBegin, it)) break; // BTT
+          wrtTrace(SecondaryRuntime_HERE, "Pectab_Load (%.1000s)", std::string(readBegin, it).c_str());
+          isPectab= true;
+
+          if(!Tokenizer::readDigit(2, it, end, readBegin, it)) break; // table number
+          wrtTrace(SecondaryRuntime_HERE, "Table number (%.1000s)", std::string(readBegin, it).c_str());
+          m_pectabId= std::string(readBegin, it).c_str();
+
+          if(!Tokenizer::readDigit(2, it, end, readBegin, it)) break; // table table version
+          wrtTrace(SecondaryRuntime_HERE, "Table version (%.1000s)", std::string(readBegin, it).c_str());
+          m_pectabVersion= std::string(readBegin, it).c_str();
+          m_version= Tokenizer::digit(readBegin, it);
+
+          if(!Tokenizer::readChar(it, end, readBegin, it)) break; // continuation Character
+          wrtTrace(SecondaryRuntime_HERE, "Continuation character (%.1000s)", std::string(readBegin, it).c_str());
+          m_continuationCharacter= *readBegin;
+
+          if(!Tokenizer::readChar(it, end, readBegin, it)) break; // auto incement field length
+          wrtTrace(SecondaryRuntime_HERE, "AutoIncrement field length (%.1000s)", std::string(readBegin, it).c_str());
+          m_autoIncrementFieldLength= Tokenizer::characterValue(readBegin);
+          wrtTrace(SecondaryRuntime_HERE, "AutoIncrement field length (%d)", m_autoIncrementFieldLength);
+
+          if(!Tokenizer::readChar(it, end, readBegin, it)) break; // colour Character
+          wrtTrace(SecondaryRuntime_HERE, "Colour character (%.1000s)", std::string(readBegin, it).c_str());
+          m_colorSteering= *readBegin;
+
+          if(!Tokenizer::readDigit(3, it, end, readBegin, it)) break; // Tag width
+          wrtTrace(SecondaryRuntime_HERE, "Tag width (%.1000s)", std::string(readBegin, it).c_str());
+          m_width_tenth_mm= Tokenizer::digit(readBegin, it);
+
+          if(!Tokenizer::readDigit(3, it, end, readBegin, it)) break; // Mirror Point
+          wrtTrace(SecondaryRuntime_HERE, "Mirror Point (%.1000s)", std::string(readBegin, it).c_str());
+          m_mirrorPoint_tenth_mm= Tokenizer::digit(readBegin, it) * 10;
+
+          if(!Tokenizer::readChar(it, end, readBegin, it)) break; // Element reference character
+          wrtTrace(SecondaryRuntime_HERE, "Element reference character (%.1000s)", std::string(readBegin, it).c_str());
+          m_elementReferenceCharacter= *readBegin;
+
+          if(!Tokenizer::readChar(it, end, readBegin, it)) break; // Delimiter
+          wrtTrace(SecondaryRuntime_HERE, "Delimiter (%.1000s)", std::string(readBegin, it).c_str());
+          m_delimiter= *readBegin;
+
+          success= true;
+          m_pectab= pectabCmd;
+
+          {
+            std::string::const_iterator readEnd;
+            std::string::const_iterator readBegin2;
+            while(it != end)
+            {
+              Tokenizer::readToChar(m_delimiter, it, end, readBegin, it);   // Field Definition
+              wrtTrace(SecondaryRuntime_HERE, "Field (%.1000s)", std::string(readBegin, it).c_str());
+              std::auto_ptr<BagTagPectabField> field=  std::auto_ptr<BagTagPectabField>(BagTagPectabField::readPectabField(m_elementReferenceCharacter, m_delimiter, readBegin, it, readBegin2, readEnd));
+              if(field.get() != 0 && readEnd == it)
+              {
+                if(fieldId < field->getId())
+                {
+                  m_fieldMap[field->getId()]= field;
+                }
+                else
+                {
+                  fieldId= field->getId();
+                  success= false;
+                  break;
+                }
+                fieldId= field->getId();
+                if(readEnd != it)
+                {
+                  success= false;
+                  break;
+                }
+              }
+              else
+              {
+                success= false;
+                break;
+              }
+              Tokenizer::readChar(m_delimiter, it, end, readBegin, it);
+            }
+            if(it != end)
+              success= false;
+          }
+        }
+      }
+      if(isPectab && !success)
+      {
+        writeTraceText(MajorWarning_HERE, "Invalid Pectab");
+        dumpTrace(MajorWarning_HERE, pectabCmd.size(), pectabCmd.data());
+        if(fieldId != BEFORE_FIRST_FIELD)
+        {
+          wrtTrace(MajorWarning_HERE, "Invalid Field (%s)", fieldId.c_str());
+          throw InvalidField("Invalid Field", fieldId);
+        }
+        else
+        {
+          throw ParseException("Invalid Pectab");
+        }
+      }
+      return isPectab;
+    }
+    const std::string& BagTagPectabData::pectab() const
+    {
+      return m_pectab;
+    }
+    const std::string& BagTagPectabData::pectabId() const
+    {
+      return m_pectabId;
+    }
+    char BagTagPectabData::continuationCharacter() const
+    {
+      return m_continuationCharacter;
+    }
+    int BagTagPectabData::autoIncrementFieldLength() const
+    {
+      return m_autoIncrementFieldLength;
+    }
+    char BagTagPectabData::colorSteering() const
+    {
+      return m_colorSteering;
+    }
+    int BagTagPectabData::width_tenth_mm() const
+    {
+      return m_width_tenth_mm;
+    }
+    int BagTagPectabData::mirrorPoint_tenth_mm() const
+    {
+      return m_mirrorPoint_tenth_mm;
+    }
+    char BagTagPectabData::elementReferenceCharacter() const
+    {
+      return m_elementReferenceCharacter;
+    }
+    char BagTagPectabData::delimiter() const
+    {
+      return m_delimiter;
+    }
+    int BagTagPectabData::version() const
+    {
+      return m_version;
+    }
+    const std::string& BagTagPectabData::pectabVersion() const
+    {
+      return m_pectabVersion;
+    }
+    const BagTagPectabFieldMap& BagTagPectabData::getFields() const
+    {
+      return m_fieldMap;
+    }
+    const BagTagPectabField* BagTagPectabData::getField(const std::string& fieldId) const
+    {
+      BagTagPectabFieldMap::const_iterator it= m_fieldMap.find(fieldId);
+      if(it == m_fieldMap.end())
+      {
+        return 0;
+      }
+      else
+      {
+        return ((*it).second).get();
+      }
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaBagtagResponse.cpp b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaBagtagResponse.cpp
new file mode 100644
index 00000000..635cd487
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaBagtagResponse.cpp
@@ -0,0 +1,109 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaBagtagResponse.cpp
+//
+//  purpose:
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+
+#include "aeaBagtagResponse.h"
+#include "AEAParser/aeaStatus.h"
+#include <sstream>
+#include <iomanip>
+
+using namespace MASSAI::AEA;
+
+namespace
+{
+  std::string couponResponse(size_t printJobs, size_t printed)
+  {
+    if(printed == printJobs)
+    {
+      return "PROK";
+    }
+    else
+    {
+      return "ERR5";
+    }
+  }
+  std::string stockText(int stockId, PaperStatus status)
+  {
+    std::ostringstream out;
+    if(status == PS_PRESENT)
+    {
+      out << std::setw(1) << stockId;
+    }
+    else if(status == PS_LOW)
+    {
+      out << 'L';
+    }
+    else
+    {
+      out << 'O';
+    }
+    return out.str();
+  }
+  std::string printedText(size_t printed)
+  {
+    std::ostringstream out;
+    if(printed > 99)
+    {
+      out << "99";
+    }
+    else
+    {
+      out << std::setw(2) << std::setfill('0') << printed;
+    }
+    return out.str();
+  }
+
+}
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    AEABagtagResponse::AEABagtagResponse(const std::string& transactionCode, size_t jobCount):
+      m_transactionCode(transactionCode),
+      m_jobCount(jobCount)
+    {}
+    AEABagtagResponse::~AEABagtagResponse()
+    {}
+    Command AEABagtagResponse::getCommandType() const
+    {
+      return COMMAND_PRINT;
+    }
+    std::string AEABagtagResponse::getResponse(const Status& status) const
+    {
+      std::string result;
+      size_t printed= 0;
+      int i= 0;
+      for(; i < status.feeder.size() && i < 1; i++)
+      {
+        const FeederStatus& feeder= status.feeder[i];
+        result+= stockText(i, feeder.paperStatus);
+        result+= printedText(feeder.printed);
+        printed+= feeder.printed;
+      }
+      for(; i < 1; i++)
+      {
+        result+= "O00";
+      }
+
+      result= m_transactionCode + couponResponse(m_jobCount, printed) + result;
+      return result;
+    }
+    ResultCode AEABagtagResponse::getResultCode() const
+    {
+      return RESULT_SUCCESS;
+    }
+    size_t AEABagtagResponse::getDocumentCount() const
+    {
+      return m_jobCount;
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaBinSetup.cpp b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaBinSetup.cpp
new file mode 100644
index 00000000..14368e9c
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaBinSetup.cpp
@@ -0,0 +1,335 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaBinSetup.cpp
+//
+//  purpose:    settings of the stocks
+//
+//  date:       14.06.2010
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#pragma warning (disable:4786)
+
+#include "aeaBinSetup.h"
+#include "TraceClt.h"
+#include "aeaToken.h"
+
+namespace
+{
+  const char* BIN_SETUP=     "BT";
+  const char DEFAULT_BIN=    'D';
+  const char FRONT_FEED=     'F';
+  const char STATUS_REQUEST= 'S';
+
+  enum BT_PaperType
+  {
+    BT_PAPER_TYPE_RESERVED_0=    '0',
+    BT_PAPER_TYPE_TICKET=        '1',
+    BT_PAPER_TYPE_MULTI_PURPOSE= '2',
+    BT_PAPER_TYPE_BOARDINGPASS=  '3',
+    BT_PAPER_TYPE_BLANKO=        '4',
+    BT_PAPER_TYPE_ARC=           '5',
+    BT_PAPER_TYPE_BP_FIRST=      '6',
+    BT_PAPER_TYPE_BP_BUSINESS=   '7',
+    BT_PAPER_TYPE_BP_ECONOMY=    '8',
+    BT_PAPER_TYPE_RESERVED_9=    '9',
+  };
+
+
+}
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    bool MediaCompare::operator()(const Media& x, const Media& y) const
+    {
+      bool result= false;
+      if(x.paperType == y.paperType)
+      {
+        return x.paperTypeClass < y.paperTypeClass;
+      }
+      else
+      {
+        return x.paperType < y.paperType;
+      }
+    }
+    BinSetupData::BinSetupData()
+    {
+      m_stockSetting.verify= VERIFY_OFF;
+      m_stockSetting.scnr= STOCK_CONTROL_OFF;
+      setMedia(PC_UNDEFINED, PT_UNDEFINED);
+    }
+    bool BinSetupData::readMedia(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+    {
+      bool result= false;
+      if(Tokenizer::readDigit(inBegin, inEnd, outBegin, outEnd))
+      {
+        switch(*outBegin)
+        {
+          case BT_PAPER_TYPE_TICKET:        setMedia(PC_UNDEFINED, PT_TICKET);            break;
+          case BT_PAPER_TYPE_BOARDINGPASS:  setMedia(PC_UNDEFINED, PT_BOARDINGPASS);      break;
+          case BT_PAPER_TYPE_BP_FIRST:      setMedia(PC_FIRST,     PT_BOARDINGPASS);      break;
+          case BT_PAPER_TYPE_BP_BUSINESS:   setMedia(PC_BUSINESS,  PT_BOARDINGPASS);      break;
+          case BT_PAPER_TYPE_BP_ECONOMY:    setMedia(PC_ECONOMY,   PT_BOARDINGPASS);      break;
+          case BT_PAPER_TYPE_RESERVED_9:    setMedia(PC_UNDEFINED, PT_BAGGAGETAG);        break;
+          default:                          setMedia(PC_UNDEFINED, PT_GENERALPURPOSEDOC);
+        }
+        result= true;
+      }
+      return result;
+    }
+    bool BinSetupData::readVerify(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+    {
+      bool result= false;
+      if(Tokenizer::readChar("VN", inBegin, inEnd, outBegin, outEnd))
+      {
+        result= true;
+      }
+      return result;
+    }
+    bool BinSetupData::readSCNR(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+    {
+      bool result= false;
+      if(Tokenizer::readChar("SN", inBegin, inEnd, outBegin, outEnd))
+      {
+        result= true;
+      }
+      return result;
+    }
+    std::string BinSetupData::status(bool includeSCNRInfo) const
+    {
+      std::string response;
+      switch(m_stockSetting.media.paperType)
+      {
+        case PT_TICKET:               response.append(1, BT_PAPER_TYPE_TICKET);       break;
+        case PT_GENERALPURPOSEDOC:    response.append(1, BT_PAPER_TYPE_BLANKO);       break;
+        case PT_BAGGAGETAG:           response.append(1, BT_PAPER_TYPE_RESERVED_9);   break;
+        case PT_BOARDINGPASS:
+        {
+          switch(m_stockSetting.media.paperTypeClass)
+          {
+            case PC_UNDEFINED:        response.append(1, BT_PAPER_TYPE_BOARDINGPASS);   break;
+            case PC_FIRST:            response.append(1, BT_PAPER_TYPE_BP_FIRST);   break;
+            case PC_BUSINESS:         response.append(1, BT_PAPER_TYPE_BP_BUSINESS);   break;
+            case PC_ECONOMY:          response.append(1, BT_PAPER_TYPE_BP_ECONOMY);   break;
+          }
+          break;
+        }
+      }
+      switch(m_stockSetting.verify)
+      {
+        case VERIFY_ON: response.append("V"); break;
+        default:        response.append("N");
+      }
+      if(includeSCNRInfo)
+      {
+        switch(m_stockSetting.scnr)
+        {
+          case     STOCK_CONTROL_ASCENDING:  response.append("A"); break;
+          case     STOCK_CONTROL_DESCENDING: response.append("D"); break;
+          default:                           response.append("N");
+        }
+      }
+      else
+      {
+        response.append("N");
+      }
+      return response;
+    }
+    void BinSetupData::setMedia(PaperTypeClass class_, PaperType type)
+    {
+      m_stockSetting.media.paperType= type;
+      m_stockSetting.media.paperTypeClass= class_;
+    }
+    StockSetting BinSetupData::getStockSetting() const
+    {
+      return m_stockSetting;
+    }
+
+
+
+    BinSetup::BinSetup():
+      m_defaultStock(1)
+    {}
+    BinSetup::~BinSetup()
+    {}
+    std::string BinSetup::setup(const std::string& input)
+    {
+      bool result= false;
+      std::string response;
+      Iterator it= input.begin();
+      Iterator end= input.end();
+      Iterator readBegin;
+      MediaMap mediaMap;
+      bool includeSCNRInfo= false;
+      Stock defaultStock= 0;
+      if(Tokenizer::readText(BIN_SETUP, it, end, readBegin, it))
+      {
+        result= true;
+        wrtTrace(BasicRuntime_HERE, "Bin Setup (%.1000s)", std::string(readBegin, it).c_str());
+        int currentStock= 0;
+        while(Tokenizer::readDigit(it, end, readBegin, it))  // Stock Setup
+        {
+          Iterator setupBegin= readBegin;
+          wrtTrace(BasicRuntime_HERE, "Stock (%.1000s)", std::string(readBegin, it).c_str());
+          Stock stock= Tokenizer::digit(readBegin);
+          if(stock <= currentStock)
+          {
+            wrtTrace(MajorWarning_HERE, "Invalid stock order (%.1000s)", std::string(readBegin, it).c_str());
+            return false;
+          }
+          else
+          {
+            currentStock= stock;
+            BinSetupData setting;
+            if(setting.readMedia(it, end, readBegin, it)) // Media Type
+            {
+              wrtTrace(BasicRuntime_HERE, "Media Type (%.1000s)", std::string(readBegin, it).c_str());
+              if(setting.readVerify(it, end, readBegin, it))  // Verify
+              {
+                wrtTrace(BasicRuntime_HERE, "Verify (%.1000s)", std::string(readBegin, it).c_str());
+                if(setting.readSCNR(it, end, readBegin, it)) // delimiter
+                {
+                  wrtTrace(SecondaryRuntime_HERE, "SCNR (%.1000s)", std::string(readBegin, it).c_str());
+                  mediaMap[currentStock]= setting;
+                }
+              }
+            }
+          }
+        }
+        if(Tokenizer::readChar(DEFAULT_BIN, it, end, readBegin, it)) // Default Bin Setup
+        {
+          Iterator setupBegin= readBegin;
+          if(Tokenizer::readDigit(it, end, readBegin, it))  // Stock Setup
+          {
+            defaultStock= Tokenizer::digit(readBegin);
+            if(defaultStock == 0)
+            {
+              result= false;
+            }
+          }
+          else
+          {
+            result= false;
+          }
+        }
+        if(Tokenizer::readChar(FRONT_FEED, it, end, readBegin, it)) // Front Feed Setup
+        {
+          if(Tokenizer::readChar("VN", it, end, readBegin, it))  // Verify On/Off
+          {}
+          else
+          {
+            wrtTrace(MajorWarning_HERE, "Invalid front feed setup");
+            result= false;
+          }
+        }
+        if(Tokenizer::readChar(STATUS_REQUEST, it, end, readBegin, it)) // Status request
+        {
+          if(Tokenizer::readChar("SN", it, end, readBegin, it))  // SCNR info included
+          {
+            if(*readBegin == 'S')
+            {
+              includeSCNRInfo= true;
+            }
+          }
+          else
+          {
+            wrtTrace(MajorWarning_HERE, "Invalid status query");
+            result= false;
+          }
+        }
+
+      }
+      if(result)
+      {
+        if(defaultStock != 0)
+        {
+          m_defaultStock= defaultStock;
+        }
+        MediaMap::iterator mediaIt= mediaMap.begin();
+        MediaMap::iterator mediaEnd= mediaMap.end();
+        for(; mediaIt != mediaEnd; mediaIt++)
+        {
+          m_mediaMap[mediaIt->first]= mediaIt->second;
+        }
+        generateStockMap();
+      }
+      else
+      {
+        response= "BTERR2";
+      }
+      return response;
+    }
+    std::string BinSetup::status(bool includeSCNRInfo) const
+    {
+      std::string result= "BT";
+      for(Stock stock= 1; stock <= 3; stock++)
+      {
+        MediaMap::const_iterator it= m_mediaMap.find(stock);
+        if(it != m_mediaMap.end())
+        {
+          result.append(1, '0' + stock);
+          result.append(it->second.status(includeSCNRInfo));
+        }
+        else
+        {
+          result.append("OOOO");
+        }
+      }
+      result.append("D");
+      result.append(1, '0' + m_defaultStock);
+      result.append("FN");
+      result.append("S");
+      if(includeSCNRInfo)
+      {
+        result.append("S");
+      }
+      else
+      {
+        result.append("N");
+      }
+      return result;
+    }
+    void BinSetup::generateStockMap()
+    {
+      m_stockMap.clear();
+      MediaMap::iterator it= m_mediaMap.begin();
+      MediaMap::iterator end= m_mediaMap.end();
+      for(; it != end; it++)
+      {
+        m_stockMap[it->second.getStockSetting().media].insert(it->first);
+      }
+    }
+
+    StockSet BinSetup::getStocks(Media media) const
+    {
+      StockSet result;
+      StockMap::const_iterator it= m_stockMap.find(media);
+      if(it != m_stockMap.end())
+      {
+        result= it->second;
+      }
+      return result;
+    }
+    StockSetting BinSetup::getMedia(Stock stock) const
+    {
+      StockSetting result;
+      MediaMap::const_iterator it= m_mediaMap.find(stock);
+      if(it != m_mediaMap.end())
+      {
+        result= it->second.getStockSetting();
+      }
+      else
+      {
+        result.media.paperType= PT_UNDEFINED;
+        result.media.paperTypeClass= PC_UNDEFINED;
+      }
+      return result;
+    }
+  }
+}
+
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaBoardingPassPectab.cpp b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaBoardingPassPectab.cpp
new file mode 100644
index 00000000..3dc5c7ea
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaBoardingPassPectab.cpp
@@ -0,0 +1,706 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaCmd.h
+//
+//  purpose:    aea command data, pectab data structure for boarding pass commands
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+
+#pragma warning (disable:4786)
+
+#include "AEAParser/aeaBoardingPassPectab.h"
+#include "aeaToken.h"
+#include "TraceClt.h"
+
+namespace
+{
+  const char* PECTAB_LOAD= "PT";
+  const char  PECTAB_BARCODE_ID= 'B';
+  const char* LAST_FIELD= "ZZ";
+  const char* FIRST_FIELD= "01";
+}
+
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    PectabPrintPosition::PectabPrintPosition()
+    {}
+    bool PectabPrintPosition::readPectabPrintPosition(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+    {
+      bool result= false;
+      std::string::const_iterator readBegin;
+      outBegin= inBegin;
+      if(Tokenizer::readRow(inBegin, inEnd, readBegin, inBegin))
+      {
+        wrtTrace(SecondaryRuntime_HERE, "row (%.1000s)", std::string(readBegin, inBegin).c_str());
+        m_row= Tokenizer::row(readBegin);
+        if(Tokenizer::readDigit(2, inBegin, inEnd, readBegin, inBegin))
+        {
+          wrtTrace(SecondaryRuntime_HERE, "column (%.1000s)", std::string(readBegin, inBegin).c_str());
+          m_column= Tokenizer::digit(readBegin, inBegin);
+          if(1 <= m_column && m_column <= 72)
+          {
+            result= true;
+            outEnd= inBegin;
+          }
+        }
+      }
+      return result;
+    }
+    int PectabPrintPosition::getRow() const
+    {
+      return m_row;
+    }
+    int PectabPrintPosition::getColumn() const
+    {
+      return m_column;
+    }
+    PectabMagStripePosition::PectabMagStripePosition()
+    {}
+    bool PectabMagStripePosition::readPectabMagStripePosition(int fieldLength, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+    {
+      bool result= false;
+      std::string::const_iterator readBegin;
+      outBegin= inBegin;
+      if(Tokenizer::readDigit(inBegin, inEnd, readBegin, inBegin))
+      {
+        wrtTrace(SecondaryRuntime_HERE, "track (%.1000s)", std::string(readBegin, inBegin).c_str());
+        m_track= Tokenizer::digit(readBegin);
+        if(Tokenizer::readDigit(inBegin, inEnd, readBegin, inBegin))
+        {
+          wrtTrace(SecondaryRuntime_HERE, "block (%.1000s)", std::string(readBegin, inBegin).c_str());
+          m_block= Tokenizer::digit(readBegin);
+          if(Tokenizer::readDigit(2, inBegin, inEnd, readBegin, inBegin))
+          {
+            wrtTrace(SecondaryRuntime_HERE, "position (%.1000s)", std::string(readBegin, inBegin).c_str());
+            m_position= Tokenizer::digit(readBegin, inBegin);
+            /* accept invalid track/block/position, values are not used
+            if(1 <= m_track && m_track <= 4
+              && 1 <= m_block && m_block <= 3
+              && 1 <= m_position && (m_position + fieldLength - 1 <= 40 || (m_position + fieldLength - 1 <= 60 && m_block < 3)))
+            */
+            {
+              result= true;
+              outEnd= inBegin;
+            }
+          }
+        }
+      }
+      return result;
+    }
+    int PectabMagStripePosition::getTrack() const
+    {
+      return m_track;
+    }
+    int PectabMagStripePosition::getBlock() const
+    {
+      return m_block;
+    }
+    int PectabMagStripePosition::getPosition() const
+    {
+      return m_position;
+    }
+    PectabBarcodeDefinition::PectabBarcodeDefinition()
+    {}
+    bool PectabBarcodeDefinition::readBarcodeType(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+    {
+      bool result= false;
+      outBegin= inBegin;
+      if(inBegin != inEnd)
+      {
+        result= true;
+        switch(*inBegin)
+        {
+          case '0':
+            m_withCheckDigit= true;
+            m_barcode= PT_BC_INTERLEAVED_2_OF_5;
+            m_orientation= PT_OR_0DEGREE;
+            break;
+          case '1':
+            m_withCheckDigit= false;
+            m_barcode= PT_BC_INTERLEAVED_2_OF_5;
+            m_orientation= PT_OR_0DEGREE;
+            break;
+          case '2':
+            m_withCheckDigit= false;
+            m_barcode= PT_BC_INDUSTRIAL_2_OF_5;
+            m_orientation= PT_OR_0DEGREE;
+            break;
+          case '3':
+            m_withCheckDigit= false;
+            m_barcode= PT_BC_39;
+            m_orientation= PT_OR_0DEGREE;
+            break;
+          case '4':
+            m_withCheckDigit= true;
+            m_barcode= PT_BC_128;
+            m_orientation= PT_OR_0DEGREE;
+            break;
+          case '5':
+            m_withCheckDigit= false;
+            m_barcode= PT_BT_RESERVED;
+            m_orientation= PT_OR_0DEGREE;
+            break;
+          case '6':
+            m_withCheckDigit= true;
+            m_barcode= PT_BC_PDF417;
+            m_orientation= PT_OR_0DEGREE;
+            break;
+          case '7':
+            m_withCheckDigit= true;
+            m_barcode= PT_BC_128;
+            m_orientation= PT_OR_0DEGREE;
+            break;
+          case '8':
+            m_withCheckDigit= true;
+            m_barcode= PT_BC_39;
+            m_orientation= PT_OR_0DEGREE;
+            break;
+          case '9':
+            m_withCheckDigit= true;
+            m_barcode= PT_BC_INDUSTRIAL_2_OF_5;
+            m_orientation= PT_OR_0DEGREE;
+            break;
+          case 'Q':
+            m_withCheckDigit= false;
+            m_barcode= PT_BT_RESERVED;
+            m_orientation= PT_OR_270DEGREE;
+            break;
+          case 'R':
+            m_withCheckDigit= true;
+            m_barcode= PT_BC_PDF417;
+            m_orientation= PT_OR_270DEGREE;
+            break;
+          case 'S':
+            m_withCheckDigit= false;
+            m_barcode= PT_BC_INTERLEAVED_2_OF_5;
+            m_orientation= PT_OR_270DEGREE;
+            break;
+          case 'T':
+            m_withCheckDigit= false;
+            m_barcode= PT_BC_INDUSTRIAL_2_OF_5;
+            m_orientation= PT_OR_270DEGREE;
+            break;
+          case 'U':
+            m_withCheckDigit= false;
+            m_barcode= PT_BC_39;
+            m_orientation= PT_OR_270DEGREE;
+            break;
+          case 'V':
+            m_withCheckDigit= true;
+            m_barcode= PT_BC_128;
+            m_orientation= PT_OR_270DEGREE;
+            break;
+          case 'W':
+            m_withCheckDigit= true;
+            m_barcode= PT_BC_128;
+            m_orientation= PT_OR_270DEGREE;
+            break;
+          case 'X':
+            m_withCheckDigit= true;
+            m_barcode= PT_BC_39;
+            m_orientation= PT_OR_270DEGREE;
+            break;
+          case 'Y':
+            m_withCheckDigit= true;
+            m_barcode= PT_BC_INDUSTRIAL_2_OF_5;
+            m_orientation= PT_OR_270DEGREE;
+            break;
+          case 'Z':
+            m_withCheckDigit= true;
+            m_barcode= PT_BC_INTERLEAVED_2_OF_5;
+            m_orientation= PT_OR_270DEGREE;
+            break;
+          default:
+            result= false;
+        }
+        if(result == true)
+        {
+          wrtTrace(SecondaryRuntime_HERE, "barcode type(%.c)", *inBegin);
+          ++inBegin;
+          outEnd= inBegin;
+        }
+      }
+      return result;
+    }
+    bool PectabBarcodeDefinition::readBarcodeFormat(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+    {
+      bool result= false;
+      std::string::const_iterator readBegin;
+      outBegin= inBegin;
+      if(Tokenizer::readDigit(2, inBegin, inEnd, readBegin, inBegin))
+      {
+        wrtTrace(SecondaryRuntime_HERE, "height (%.1000s)", std::string(readBegin, inBegin).c_str());
+        m_height= Tokenizer::digit(readBegin, inBegin);
+        if(Tokenizer::readDigit(inBegin, inEnd, readBegin, inBegin))
+        {
+          wrtTrace(SecondaryRuntime_HERE, "magnification (%.1000s)", std::string(readBegin, inBegin).c_str());
+          int magnification= Tokenizer::digit(readBegin);
+          if(Tokenizer::readDigit(inBegin, inEnd, readBegin, inBegin))
+          {
+            wrtTrace(SecondaryRuntime_HERE, "barcodeRatio (%.1000s)", std::string(readBegin, inBegin).c_str());
+            int barcodeRatio= Tokenizer::digit(readBegin);
+            if(1 <= m_height && m_height <= 99
+              && 1 <= magnification && magnification <= 9
+              && 1 <= barcodeRatio && barcodeRatio  <= 3)
+            {
+              if(m_barcode == PT_BC_PDF417)
+              {
+                /* CUSS Addendum A.1.9 Clarification of AEA2002 PDF417 support */
+                m_errorLevel= magnification -  1;
+                switch(barcodeRatio)
+                {
+                  case 1: m_wideBarDots= 6; m_narrowBarDots= 2; break;
+                  case 2: m_wideBarDots= 9; m_narrowBarDots= 3; break;
+                  case 3: m_wideBarDots= 12; m_narrowBarDots= 4; break;
+                }
+              }
+              else
+              {
+                switch(barcodeRatio)
+                {
+                  case 1: m_wideBarDots= magnification * 2; m_narrowBarDots= magnification; break;
+                  case 2: m_wideBarDots= magnification * 3; m_narrowBarDots= magnification; break;
+                  case 3: m_wideBarDots= magnification * 5; m_narrowBarDots= magnification * 2; break;
+                }
+                m_errorLevel= 3;
+              }
+              result= true;
+              outEnd= inBegin;
+            }
+          }
+        }
+      }
+      return result;
+    }
+    bool PectabBarcodeDefinition::useCheckDigit() const
+    {
+      return m_withCheckDigit;
+    }
+    int PectabBarcodeDefinition::getHeight() const
+    {
+      return m_height;
+    }
+    int PectabBarcodeDefinition::getWideBarDots() const
+    {
+      return m_wideBarDots;
+    }
+    int PectabBarcodeDefinition::getNarrowBarDots() const
+    {
+      return m_narrowBarDots;
+    }
+    int PectabBarcodeDefinition::getErrorLevel() const
+    {
+      return m_errorLevel;
+    }
+    Orientation PectabBarcodeDefinition::getOrientation() const
+    {
+      return m_orientation;
+    }
+
+    PectabField::PectabField()
+    {}
+    bool PectabField::readPectabField(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+    {
+      bool result= false;
+      std::string::const_iterator readBegin;
+      outBegin= inBegin;
+      if(Tokenizer::readFieldId(inBegin, inEnd, readBegin, inBegin))
+      {
+        wrtTrace(SecondaryRuntime_HERE, "fieldId (%.1000s)", std::string(readBegin, inBegin).c_str());
+        m_elementId= std::string(readBegin, inBegin);
+        if(Tokenizer::readDigit(2, inBegin, inEnd, readBegin, inBegin))
+        {
+          wrtTrace(SecondaryRuntime_HERE, "maximumLength (%.1000s)", std::string(readBegin, inBegin).c_str());
+          m_font= PT_FONT_NORMAL;
+          m_maximumLength= Tokenizer::digit(readBegin, inBegin);
+          result= true;
+          while(inBegin != inEnd)
+          {
+            PectabPrintPosition printPosition;
+            PectabMagStripePosition magStripePosition;
+            if(printPosition.readPectabPrintPosition(inBegin, inEnd, readBegin, inBegin))
+            {
+              m_printPositions.push_back(printPosition);
+            }
+            else if(magStripePosition.readPectabMagStripePosition(m_maximumLength, inBegin, inEnd, readBegin, inBegin))
+            {
+              m_magStripePositions.push_back(magStripePosition);
+            }
+            else if(readFont(inBegin, inEnd, readBegin, inBegin))
+            {
+              break;
+            }
+            else
+            {
+              result= false;
+              break;
+            }
+          }
+        }
+        else if(Tokenizer::readChar(PECTAB_BARCODE_ID, inBegin, inEnd, readBegin, inBegin))
+        {
+          wrtTrace(SecondaryRuntime_HERE, "barcode (%.c)", *inBegin);
+          m_font= PT_FONT_BARCODE;
+          if(m_barcodeDefinition.readBarcodeType(inBegin, inEnd, readBegin, inBegin))
+          {
+            wrtTrace(SecondaryRuntime_HERE, "barcodeType (%.1000s)", std::string(readBegin, inBegin).c_str());
+            bool formatFound= false;
+            result= true;
+            while(inBegin != inEnd)
+            {
+              PectabPrintPosition printPosition;
+              if(printPosition.readPectabPrintPosition(inBegin, inEnd, readBegin, inBegin))
+              {
+                m_printPositions.push_back(printPosition);
+              }
+              else if(!formatFound && m_barcodeDefinition.readBarcodeFormat(inBegin, inEnd, readBegin, inBegin))
+              {
+                formatFound= true;
+              }
+              else if(readFont(inBegin, inEnd, readBegin, inBegin))
+              {
+                break;
+              }
+              else
+              {
+                result= false;
+                break;
+              }
+            }
+          }
+        }
+      }
+      if(result == true)
+      {
+        outEnd= inBegin;
+      }
+      return result;
+    }
+    bool PectabField::readFont(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+    {
+      bool result= false;
+      outBegin= inBegin;
+      if(inBegin != inEnd)
+      {
+        result= true;
+        switch(*inBegin)
+        {
+          case 'A':
+            m_font= PT_FONT_NORMAL;
+            break;
+          case 'B':
+            m_font= PT_FONT_LARGE;
+            break;
+          case 'C':
+            m_font= PT_FONT_NORMAL;
+            break;
+          case 'D':
+            m_font= PT_FONT_NORMAL;
+            break;
+          case 'E':
+            m_font= PT_FONT_NORMAL;
+            break;
+          case 'F':
+            m_font= PT_FONT_LARGE;
+            break;
+          case 'G':
+            m_font= PT_FONT_NORMAL;
+            break;
+          case 'H':
+            m_font= PT_FONT_LARGE;
+            break;
+          case 'I':
+            m_font= PT_FONT_NORMAL;
+            break;
+          case 'J':
+            m_font= PT_FONT_LARGE;
+            break;
+          case 'K':
+            m_font= PT_FONT_NORMAL;
+            break;
+          case 'L':
+            m_font= PT_FONT_CONDENSED;
+            break;
+          case 'M':
+            m_font= PT_FONT_OCR;
+            break;
+          case 'N':
+            m_font= PT_FONT_CONDENSED;
+            break;
+          case 'O':
+            m_font= PT_FONT_CONDENSED_BOLD;
+            break;
+          case 'P':
+            m_font= PT_FONT_CONDENSED_BOLD;
+            break;
+          case 'Q':
+            m_font= PT_FONT_CONDENSED;
+            break;
+          case 'R':
+            m_font= PT_FONT_CPI_5;
+            break;
+          default:
+            if(isalpha(*inBegin))
+            {
+              m_font= PT_FONT_NORMAL;
+            }
+            else
+            {
+              result= false;
+            }
+        }
+        if(result == true)
+        {
+          wrtTrace(SecondaryRuntime_HERE, "font (%.c)", *inBegin);
+          ++inBegin;
+          outEnd= inBegin;
+        }
+      }
+      return result;
+    }
+    const std::string& PectabField::getId() const
+    {
+      return m_elementId;
+    }
+    int PectabField::getMaximumLength() const
+    {
+      return m_maximumLength;
+    }
+    const PectabPrintPositions& PectabField::getPrintPositions() const
+    {
+      return m_printPositions;
+    }
+    const PectabMagStripePositions& PectabField::getMagStripePositions() const
+    {
+      return m_magStripePositions;
+    }
+    PectabFont PectabField::getFont() const
+    {
+      return m_font;
+    }
+    const PectabBarcodeDefinition& PectabField::getBarcodeDefinition() const
+    {
+      return m_barcodeDefinition;
+    }
+
+
+    PectabData::PectabData()
+    {}
+    bool PectabData::readPectabData(const std::string& contextId, const std::string& pectabCmd) throw(ParseException)
+    {
+      std::string::const_iterator it= pectabCmd.begin();
+      std::string::const_iterator end= pectabCmd.end();
+      std::string::const_iterator readBegin;
+      std::string fieldId= LAST_FIELD;
+      bool success= false;
+      bool isPectab= false;
+      switch(success)  // not really a switch statement; environment for using break is needed
+      {
+        case false:
+        {
+          if(!Tokenizer::readText(PECTAB_LOAD, it, end, readBegin, it)) break;// PT
+          wrtTrace(SecondaryRuntime_HERE, "Pectab_Load (%.1000s)", std::string(readBegin, it).c_str());
+          isPectab= true;
+
+          if(!Tokenizer::readChar(it, end, readBegin, it)) break; // delimiter for this command
+          wrtTrace(SecondaryRuntime_HERE, "Delimiter (%.1000s)", std::string(readBegin, it).c_str());
+          char delimiter= *readBegin;
+
+          if(!Tokenizer::readChar(it, end, readBegin, it)) break; // delimiter for messages from atb to host
+          wrtTrace(SecondaryRuntime_HERE, "Delimiter (%.1000s)", std::string(readBegin, it).c_str());
+          m_delimiter= *readBegin;
+
+          if(!Tokenizer::readChar(it, end, readBegin, it)) break; // character for unreadable data
+          wrtTrace(SecondaryRuntime_HERE, "Unreadable (%.1000s)", std::string(readBegin, it).c_str());
+          m_unreadable= *readBegin;
+
+          if(!Tokenizer::readPectab(it, end, readBegin, it)) break; // pectab id
+          wrtTrace(SecondaryRuntime_HERE, "Pectab id (%.1000s)", std::string(readBegin, it).c_str());
+          m_pectabId= std::string(readBegin, it);
+
+          if(!Tokenizer::readPectabVersion(it, end, readBegin, it)) break; // pectab version
+          wrtTrace(SecondaryRuntime_HERE, "Pectab version (%.1000s)", std::string(readBegin, it).c_str());
+          m_version= Tokenizer::pectabVersion(readBegin, it);
+
+          if(!Tokenizer::readChar(it, end, readBegin, it)) break; // atb steering
+          if(!Tokenizer::readChar(delimiter, it, end, readBegin, it)) break; // delimiter
+          if(!Tokenizer::readChar(it, end, readBegin, it)) break; // load logo command char
+          wrtTrace(SecondaryRuntime_HERE, "Logo Steering (%.1000s)", std::string(readBegin, it).c_str());
+          m_logoSteering= *readBegin;
+
+          if(!Tokenizer::readChar(it, end, readBegin, it)) break; // set color command char
+          wrtTrace(SecondaryRuntime_HERE, "Color Steering (%.1000s)", std::string(readBegin, it).c_str());
+          m_colorSteering= *readBegin;
+
+          if(!Tokenizer::readChar(delimiter, it, end, readBegin, it)) break; // delimiter
+          if(!Tokenizer::readTransactionCode(delimiter, it, end, readBegin, it)) break; // ticket transaction code
+          wrtTrace(SecondaryRuntime_HERE, "Ticket Transaction Code (%.1000s)", std::string(readBegin, it).c_str());
+          m_transactionCodeTicket= std::string(readBegin, it);
+
+          if(!Tokenizer::readChar(delimiter, it, end, readBegin, it)) break;// delimiter
+          if(!Tokenizer::readTransactionCode(delimiter, it, end, readBegin, it)) break; // checkin transaction code
+          wrtTrace(SecondaryRuntime_HERE, "Checkin Transaction Code (%.1000s)", std::string(readBegin, it).c_str());
+          m_transactionCodeCheckin= std::string(readBegin, it);
+
+          if(!Tokenizer::readChar(delimiter, it, end, readBegin, it)) break; // delimiter
+          if(!Tokenizer::readTransactionCode(delimiter, it, end, readBegin, it)) break;// boarding transaction code
+          wrtTrace(SecondaryRuntime_HERE, "Boarding Transaction Code (%.1000s)", std::string(readBegin, it).c_str());
+          m_transactionCodeBoarding= std::string(readBegin, it);
+
+          success= true;
+          m_pectab= pectabCmd;
+          // read fields?
+          {
+            std::string::const_iterator readEnd;
+            std::string::const_iterator readBegin2;
+            if(!Tokenizer::readChar(delimiter, it, end, readBegin, it)) break; // delimiter
+            while(it != end)
+            {
+              Tokenizer::readToChar(delimiter, it, end, readBegin, it);   // Field Definition
+              wrtTrace(SecondaryRuntime_HERE, "Field (%.1000s)", std::string(readBegin, it).c_str());
+              PectabField field;
+              if(field.readPectabField(readBegin, it, readBegin2, readEnd) && readEnd == it)
+              {
+                if(fieldId < field.getId())
+                  m_fieldMap[field.getId()]= field;
+                else if(fieldId == LAST_FIELD && field.getId() == FIRST_FIELD)
+                  m_fieldMap[field.getId()]= field;
+                else
+                {
+                  fieldId= field.getId();
+                  success= false;
+                  break;
+                }
+                fieldId= field.getId();
+                if(readEnd != it)
+                {
+                  success= false;
+                  break;
+                }
+              }
+              else if(Tokenizer::readCLF(readBegin, it, readBegin2, readEnd) && readEnd == it)
+              {
+                wrtTrace(SecondaryRuntime_HERE, "clf (%.1000s)", std::string(readBegin2, readEnd).c_str());
+                fieldId= Tokenizer::clf(readBegin2, readEnd);
+                if(readEnd != it)
+                  success= false;
+                Tokenizer::readChar(delimiter, it, end, readBegin2, it);
+                break;
+              }
+              else
+              {
+                success= false;
+                break;
+              }
+              Tokenizer::readChar(delimiter, it, end, readBegin, it);
+            }
+            while(it != end)
+            {
+              Tokenizer::readToChar(delimiter, it, end, readBegin, it);   // Field Definition
+              if(Tokenizer::readCLF(readBegin, it, readBegin, readEnd) && readEnd == it)
+              {
+                wrtTrace(SecondaryRuntime_HERE, "clf (%.1000s)", std::string(readBegin, readEnd).c_str());
+                fieldId= Tokenizer::clf(readBegin, readEnd);
+                if(readEnd != it)
+                {
+                  success= false;
+                  break;
+                }
+              }
+              else
+              {
+                success= false;
+                break;
+              }
+              Tokenizer::readChar(delimiter, it, end, readBegin, it);
+            }
+            if(it != end)
+              success= false;
+          }
+        }
+      }
+      if(isPectab && !success)
+      {
+        writeTraceText(MajorWarning_HERE, "Invalid Pectab");
+        dumpTrace(MajorWarning_HERE, pectabCmd.size(), pectabCmd.data());
+        if(fieldId != LAST_FIELD)
+        {
+          wrtTrace(MajorWarning_HERE, "Invalid Field (%s)", fieldId.c_str());
+          throw InvalidField("Invalid Field", fieldId);
+        }
+        else
+        {
+          throw ParseException("Invalid Pectab");
+        }
+      }
+      return isPectab;
+    }
+    const std::string& PectabData::pectab() const
+    {
+      return m_pectab;
+    }
+    const std::string& PectabData::pectabId() const
+    {
+      return m_pectabId;
+    }
+    const std::string& PectabData::transactionCodeTicket() const
+    {
+      return m_transactionCodeTicket;
+    }
+    const std::string& PectabData::transactionCodeCheckin() const
+    {
+      return m_transactionCodeCheckin;
+    }
+    const std::string& PectabData::transactionCodeBoarding() const
+    {
+      return m_transactionCodeBoarding;
+    }
+    char PectabData::logoSteering() const
+    {
+      return m_logoSteering;
+    }
+    char PectabData::colorSteering() const
+    {
+      return m_colorSteering;
+    }
+    char PectabData::unreadable() const
+    {
+      return m_unreadable;
+    }
+    char PectabData::delimiter() const
+    {
+      return m_delimiter;
+    }
+    int PectabData::version() const
+    {
+      return m_version;
+    }
+    void PectabData::getVersion(std::string& text) const
+    {
+      text+= Tokenizer::dec(m_version);
+    }
+    const PectabFieldMap& PectabData::getFields() const
+    {
+      return m_fieldMap;
+    }
+    const PectabField* PectabData::getField(const std::string& fieldId) const
+    {
+      PectabFieldMap::const_iterator it= m_fieldMap.find(fieldId);
+      if(it == m_fieldMap.end())
+      {
+        return 0;
+      }
+      else
+      {
+        return &((*it).second);
+      }
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaBoardingPassResponse.cpp b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaBoardingPassResponse.cpp
new file mode 100644
index 00000000..6602acab
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaBoardingPassResponse.cpp
@@ -0,0 +1,220 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaBoardingPassResponse.cpp
+//
+//  purpose:
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+
+#include "aeaBoardingPassResponse.h"
+#include "AEAParser/aeaStatus.h"
+#include <sstream>
+#include <iomanip>
+
+using namespace MASSAI::AEA;
+
+namespace
+{
+  std::string receiptResponse(PrinterStatus status, size_t printed)
+  {
+    if(printed > 0)
+    {
+      return "RDOK";
+    }
+    else
+    {
+      switch(status)
+      {
+        case PS_BUSY:        return "ERRBUSY";
+        case PS_OFFLINE:     return "ERROFFLINE";
+        case PS_NOT_ENABLED: return "ERRDENIED";
+        case PS_PAPEROUT:    return "ERRPAPEROUT";
+        case PS_PAPERJAM:    return "ERRPAPERJAM";
+        default:             return "ERRUNAVAIL";
+      }
+    }
+  }
+  std::string couponResponse(const std::string& rsp, size_t printJobs, size_t printed)
+  {
+    if(rsp.size() != 0)
+    {
+      return rsp;
+    }
+    else if(printed == printJobs)
+    {
+      return "PROK";
+    }
+    else
+    {
+      return "ERR5";
+    }
+  }
+  std::string voidedText(size_t voided)
+  {
+    std::ostringstream out;
+    if(voided == 0)
+    {
+      out << 'V';
+    }
+    else if(voided > 9)
+    {
+      out << '9';
+    }
+    else
+    {
+      out << std::setw(1) << voided;
+    }
+    return out.str();
+  }
+  std::string dispenserText(DispenserStatus status)
+  {
+    if(status == DS_FULL)
+    {
+      return "O";
+    }
+    else
+    {
+      return "S";
+    }
+  }
+  std::string ribbonText(RibbonStatus status)
+  {
+    if(status == RS_OK)
+    {
+      return "R";
+    }
+    else if(status == RS_LOW)
+    {
+      return "L";
+    }
+    else
+    {
+      return "O";
+    }
+  }
+  std::string stockText(int stockId, PaperStatus status)
+  {
+    std::ostringstream out;
+    if(status == PS_PRESENT)
+    {
+      out << std::setw(1) << stockId;
+    }
+    else if(status == PS_LOW)
+    {
+      out << 'L';
+    }
+    else
+    {
+      out << 'O';
+    }
+    return out.str();
+  }
+  std::string printedText(size_t printed)
+  {
+    std::ostringstream out;
+    if(printed > 99)
+    {
+      out << "99";
+    }
+    else
+    {
+      out << std::setw(2) << std::setfill('0') << printed;
+    }
+    return out.str();
+  }
+
+}
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    AEACouponResponse::AEACouponResponse(const std::string& transactionCode, char delimiter, size_t jobCount, size_t stockCount):
+      m_transactionCode(transactionCode),
+      m_delimiter(1, delimiter),
+      m_jobCount(jobCount),
+      m_stockCount(stockCount)
+    {}
+    AEACouponResponse::AEACouponResponse(const std::string& transactionCode, char delimiter, const std::string& rsp, size_t stockCount):
+      m_transactionCode(transactionCode),
+      m_delimiter(1, delimiter),
+      m_jobCount(0),
+      m_stockCount(stockCount),
+      m_rsp(rsp)
+    {}
+    AEACouponResponse::~AEACouponResponse()
+    {}
+    Command AEACouponResponse::getCommandType() const
+    {
+      return COMMAND_PRINT;
+    }
+    std::string AEACouponResponse::getResponse(const Status& status) const
+    {
+      std::string result;
+      size_t printed= 0;
+      size_t voided= 0;
+      int i= 0;
+      for(; i < status.feeder.size(); i++)
+      {
+        const FeederStatus& feeder= status.feeder[i];
+        result+= m_delimiter;
+        result+= stockText(i+1, feeder.paperStatus);
+        result+= printedText(feeder.printed);
+        printed+= feeder.printed;
+        voided+= feeder.voided;
+      }
+      for(; i < m_stockCount; i++)
+      {
+        result+= m_delimiter + "O00";
+      }
+      result+= m_delimiter;
+      result+= voidedText(voided);
+      result+= dispenserText(status.dispenserStatus);
+      result+= ribbonText(status.ribbonStatus);
+
+      result= m_transactionCode + couponResponse(m_rsp, m_jobCount, printed) + result;
+      return result;
+    }
+    ResultCode AEACouponResponse::getResultCode() const
+    {
+      return RESULT_SUCCESS;
+    }
+    size_t AEACouponResponse::getDocumentCount() const
+    {
+      return m_jobCount;
+    }
+
+
+
+    AEAReceiptResponse::AEAReceiptResponse(const std::string& transactionCode):
+      m_transactionCode(transactionCode)
+    {}
+    AEAReceiptResponse::~AEAReceiptResponse()
+    {}
+    Command AEAReceiptResponse::getCommandType() const
+    {
+      return COMMAND_PRINT;
+    }
+    std::string AEAReceiptResponse::getResponse(const Status& status) const
+    {
+      size_t printed= 0;
+      for(int i= 0; i < status.feeder.size(); i++)
+      {
+        printed+= status.feeder[i].printed;
+      }
+      return m_transactionCode + receiptResponse(status.printerStatus, printed);
+    }
+    ResultCode AEAReceiptResponse::getResultCode() const
+    {
+      return RESULT_SUCCESS;
+    }
+    size_t AEAReceiptResponse::getDocumentCount() const
+    {
+      return 1;
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaBoardingPassTemplate.cpp b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaBoardingPassTemplate.cpp
new file mode 100644
index 00000000..a574f041
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaBoardingPassTemplate.cpp
@@ -0,0 +1,494 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaCmd.h
+//
+//  purpose:    aea command data, template data structure for parsing boarding pass commands
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//  history:
+//---------------------------------------------------------------------------
+
+
+#pragma warning (disable:4786)
+
+#include "AEAParser/aeaBoardingPassTemplate.h"
+#include "aeaToken.h"
+#include "TraceClt.h"
+
+namespace
+{
+  const char* TEMPLATE_LOAD= "TT";
+  const char  TEMPLATE_LOGO_ID= 'L';
+  const char  TEMPLATE_BOX_ID= 'B';
+  const char  TEMPLATE_TEXT_ID= 'T';
+  const char  TEMPLATE_LINE_ID= 'S';
+  const char  TEMPLATE_OBLIQUE_LINE_ID= 'O';
+  const char* BEFORE_FIRST_FIELD= "00";
+}
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    TemplateField::TemplateField()
+    {}
+    TemplateField* TemplateField::readTemplateField(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+    {
+      if(Tokenizer::readFieldId(inBegin, inEnd, outBegin, inBegin))
+      {
+        wrtTrace(SecondaryRuntime_HERE, "field (%.1000s)", std::string(outBegin, inBegin).c_str());
+        std::string elementId= std::string(outBegin, inBegin);
+        std::auto_ptr<TemplateLogo> logo= std::auto_ptr<TemplateLogo>(new TemplateLogo);
+        std::auto_ptr<TemplateLine> line= std::auto_ptr<TemplateLine>(new TemplateLine);
+        std::auto_ptr<TemplateBox> box= std::auto_ptr<TemplateBox>(new TemplateBox);
+        std::auto_ptr<TemplateText> text= std::auto_ptr<TemplateText>(new TemplateText);
+        Iterator readBegin;
+        if(logo->readTemplateLogo(inBegin, inEnd, readBegin, outEnd))
+        {
+          static_cast<TemplateField*>(logo.get())->m_elementId= elementId;
+          return logo.release();
+        }
+        else if(line->readTemplateLine(inBegin, inEnd, readBegin, outEnd))
+        {
+          static_cast<TemplateField*>(line.get())->m_elementId= elementId;
+          return line.release();
+        }
+        else if(box->readTemplateBox(inBegin, inEnd, readBegin, outEnd))
+        {
+          static_cast<TemplateField*>(box.get())->m_elementId= elementId;
+          return box.release();
+        }
+        else if(text->readTemplateText(inBegin, inEnd, readBegin, outEnd))
+        {
+          static_cast<TemplateField*>(text.get())->m_elementId= elementId;
+          return text.release();
+        }
+      }
+      wrtTrace(SecondaryRuntime_HERE, "no match");
+      return 0;
+    }
+    const std::string& TemplateField::getId() const
+    {
+      return m_elementId;
+    }
+
+    TemplateLogo::TemplateLogo()
+    {}
+    bool TemplateLogo::readTemplateLogo(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+    {
+      bool result= false;
+      std::string::const_iterator readBegin;
+      outBegin= inBegin;
+      if(Tokenizer::readChar(TEMPLATE_LOGO_ID, inBegin, inEnd, readBegin, inBegin))
+      {
+        wrtTrace(SecondaryRuntime_HERE, "template logo (%.1000s)", std::string(readBegin, inBegin).c_str());
+        if(Tokenizer::readDigit(4, inBegin, inEnd, readBegin, inBegin))
+        {
+          wrtTrace(SecondaryRuntime_HERE, "left (%.1000s)", std::string(readBegin, inBegin).c_str());
+          m_left= Tokenizer::digit(readBegin, inBegin);
+          if(Tokenizer::readDigit(3, inBegin, inEnd, readBegin, inBegin))
+          {
+            wrtTrace(SecondaryRuntime_HERE, "bottom (%.1000s)", std::string(readBegin, inBegin).c_str());
+            m_bottom= Tokenizer::digit(readBegin, inBegin);
+            if(Tokenizer::readLogoId(inBegin, inEnd, readBegin, inBegin))
+            {
+              wrtTrace(SecondaryRuntime_HERE, "logoid (%.1000s)", std::string(readBegin, inBegin).c_str());
+              m_logoId= std::string(readBegin, inBegin);
+              if(Tokenizer::readDigit(5, inBegin, inEnd, readBegin, inBegin))
+              {
+                wrtTrace(SecondaryRuntime_HERE, "reserved (%.1000s)", std::string(readBegin, inBegin).c_str());
+                result= true;
+                outEnd= inBegin;
+              }
+            }
+          }
+        }
+      }
+      return result;
+    }
+    int TemplateLogo::getLeft() const
+    {
+      return m_left;
+    }
+    int TemplateLogo::getBottom() const
+    {
+      return m_bottom;
+    }
+    const std::string& TemplateLogo::getLogoId() const
+    {
+      return m_logoId;
+    }
+
+
+    TemplateLine::TemplateLine()
+    {}
+    bool TemplateLine::readTemplateLine(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+    {
+      bool result= false;
+      std::string::const_iterator readBegin;
+      outBegin= inBegin;
+      if(Tokenizer::readChar(TEMPLATE_LINE_ID, inBegin, inEnd, readBegin, inBegin))
+      {
+        wrtTrace(SecondaryRuntime_HERE, "template line (%.1000s)", std::string(readBegin, inBegin).c_str());
+        if(Tokenizer::readDigit(4, inBegin, inEnd, readBegin, inBegin))
+        {
+          wrtTrace(SecondaryRuntime_HERE, "x1 (%.1000s)", std::string(readBegin, inBegin).c_str());
+          m_x1= Tokenizer::digit(readBegin, inBegin);
+          if(Tokenizer::readDigit(3, inBegin, inEnd, readBegin, inBegin))
+          {
+            wrtTrace(SecondaryRuntime_HERE, "y1 (%.1000s)", std::string(readBegin, inBegin).c_str());
+            m_y1= Tokenizer::digit(readBegin, inBegin);
+            if(Tokenizer::readDigit(3, inBegin, inEnd, readBegin, inBegin))
+            {
+              wrtTrace(SecondaryRuntime_HERE, "height (%.1000s)", std::string(readBegin, inBegin).c_str());
+              int height= Tokenizer::digit(readBegin, inBegin);
+              if(Tokenizer::readDigit(4, inBegin, inEnd, readBegin, inBegin))
+              {
+                wrtTrace(SecondaryRuntime_HERE, "length (%.1000s)", std::string(readBegin, inBegin).c_str());
+                int length= Tokenizer::digit(readBegin, inBegin);
+                if(Tokenizer::readDigit(5, inBegin, inEnd, readBegin, inBegin))
+                {
+                  if(height < length)
+                  {
+                    m_x2= m_x1 + length - 1;
+                    m_y2= m_y1;
+                    m_thickness= height;
+                  }
+                  else
+                  {
+                    m_x2= m_x1;
+                    m_y2= m_y1 - height + 1;
+                    m_thickness= length;
+                  }
+                  result= true;
+                  outEnd= inBegin;
+                }
+              }
+            }
+          }
+        }
+      }
+      else if(Tokenizer::readChar(TEMPLATE_OBLIQUE_LINE_ID, inBegin, inEnd, readBegin, inBegin))
+      {
+        wrtTrace(SecondaryRuntime_HERE, "line id (%.1000s)", std::string(readBegin, inBegin).c_str());
+        if(Tokenizer::readDigit(4, inBegin, inEnd, readBegin, inBegin))
+        {
+          wrtTrace(SecondaryRuntime_HERE, "x1 (%.1000s)", std::string(readBegin, inBegin).c_str());
+          m_x1= Tokenizer::digit(readBegin, inBegin);
+          if(Tokenizer::readDigit(3, inBegin, inEnd, readBegin, inBegin))
+          {
+            wrtTrace(SecondaryRuntime_HERE, "y1 (%.1000s)", std::string(readBegin, inBegin).c_str());
+            m_y1= Tokenizer::digit(readBegin, inBegin);
+            if(Tokenizer::readDigit(4, inBegin, inEnd, readBegin, inBegin))
+            {
+              wrtTrace(SecondaryRuntime_HERE, "x2 (%.1000s)", std::string(readBegin, inBegin).c_str());
+              m_x2= Tokenizer::digit(readBegin, inBegin);
+              if(Tokenizer::readDigit(3, inBegin, inEnd, readBegin, inBegin))
+              {
+                wrtTrace(SecondaryRuntime_HERE, "y2 (%.1000s)", std::string(readBegin, inBegin).c_str());
+                m_y2= Tokenizer::digit(readBegin, inBegin);
+                if(Tokenizer::readDigit(3, inBegin, inEnd, readBegin, inBegin))
+                {
+                  wrtTrace(SecondaryRuntime_HERE, "thickness (%.1000s)", std::string(readBegin, inBegin).c_str());
+                  m_thickness= Tokenizer::digit(readBegin, inBegin);
+                  if(Tokenizer::readDigit(5, inBegin, inEnd, readBegin, inBegin))
+                  {
+                    wrtTrace(SecondaryRuntime_HERE, "reserved (%.1000s)", std::string(readBegin, inBegin).c_str());
+                    result= true;
+                    outEnd= inBegin;
+                  }
+                }
+              }
+            }
+          }
+        }
+      }
+      return result;
+    }
+    int TemplateLine::getX1() const
+    {
+      return m_x1;
+    }
+    int TemplateLine::getY1() const
+    {
+      return m_y1;
+    }
+    int TemplateLine::getX2() const
+    {
+      return m_x2;
+    }
+    int TemplateLine::getY2() const
+    {
+      return m_y2;
+    }
+    int TemplateLine::getThickness() const
+    {
+      return m_thickness;
+    }
+
+
+    TemplateBox::TemplateBox()
+    {}
+    bool TemplateBox::readTemplateBox(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+    {
+      bool result= false;
+      std::string::const_iterator readBegin;
+      outBegin= inBegin;
+      if(Tokenizer::readChar(TEMPLATE_BOX_ID, inBegin, inEnd, readBegin, inBegin))
+      {
+        wrtTrace(SecondaryRuntime_HERE, "box id (%.1000s)", std::string(readBegin, inBegin).c_str());
+        if(Tokenizer::readDigit(4, inBegin, inEnd, readBegin, inBegin))
+        {
+          wrtTrace(SecondaryRuntime_HERE, "left (%.1000s)", std::string(readBegin, inBegin).c_str());
+          m_left= Tokenizer::digit(readBegin, inBegin);
+          if(Tokenizer::readDigit(3, inBegin, inEnd, readBegin, inBegin))
+          {
+            wrtTrace(SecondaryRuntime_HERE, "bottom (%.1000s)", std::string(readBegin, inBegin).c_str());
+            m_bottom= Tokenizer::digit(readBegin, inBegin);
+            if(Tokenizer::readDigit(3, inBegin, inEnd, readBegin, inBegin))
+            {
+              wrtTrace(SecondaryRuntime_HERE, "height (%.1000s)", std::string(readBegin, inBegin).c_str());
+              m_height= Tokenizer::digit(readBegin, inBegin);
+              if(Tokenizer::readDigit(4, inBegin, inEnd, readBegin, inBegin))
+              {
+                wrtTrace(SecondaryRuntime_HERE, "width (%.1000s)", std::string(readBegin, inBegin).c_str());
+                m_width= Tokenizer::digit(readBegin, inBegin);
+                if(Tokenizer::readDigit(3, inBegin, inEnd, readBegin, inBegin))
+                {
+                  wrtTrace(SecondaryRuntime_HERE, "thickness (%.1000s)", std::string(readBegin, inBegin).c_str());
+                  m_thickness= Tokenizer::digit(readBegin, inBegin);
+                  if(Tokenizer::readDigit(5, inBegin, inEnd, readBegin, inBegin))
+                  {
+                    wrtTrace(SecondaryRuntime_HERE, "reserved (%.1000s)", std::string(readBegin, inBegin).c_str());
+                    result= true;
+                    outEnd= inBegin;
+                  }
+                }
+              }
+            }
+          }
+        }
+      }
+      return result;
+    }
+    int TemplateBox::getLeft() const
+    {
+      return m_left;
+    }
+    int TemplateBox::getBottom() const
+    {
+      return m_bottom;
+    }
+    int TemplateBox::getWidth() const
+    {
+      return m_width;
+    }
+    int TemplateBox::getHeight() const
+    {
+      return m_height;
+    }
+    int TemplateBox::getThickness() const
+    {
+      return m_thickness;
+    }
+
+    TemplateText::TemplateText()
+    {}
+    bool TemplateText::readTemplateText(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+    {
+      bool result= false;
+      std::string::const_iterator readBegin;
+      outBegin= inBegin;
+      if(Tokenizer::readChar(TEMPLATE_TEXT_ID, inBegin, inEnd, readBegin, inBegin))
+      {
+        wrtTrace(SecondaryRuntime_HERE, "text id (%.1000s)", std::string(readBegin, inBegin).c_str());
+        if(Tokenizer::readDigit(4, inBegin, inEnd, readBegin, inBegin))
+        {
+          wrtTrace(SecondaryRuntime_HERE, "left (%.1000s)", std::string(readBegin, inBegin).c_str());
+          m_left= Tokenizer::digit(readBegin, inBegin);
+          if(Tokenizer::readDigit(3, inBegin, inEnd, readBegin, inBegin))
+          {
+            wrtTrace(SecondaryRuntime_HERE, "bottom (%.1000s)", std::string(readBegin, inBegin).c_str());
+            m_bottom= Tokenizer::digit(readBegin, inBegin);
+            if(Tokenizer::readOrientation(inBegin, inEnd, readBegin, inBegin))
+            {
+              wrtTrace(SecondaryRuntime_HERE, "print orientation (%.1000s)", std::string(readBegin, inBegin).c_str());
+              m_printOrientation= Tokenizer::orientation(readBegin);
+              if(Tokenizer::readOrientation(inBegin, inEnd, readBegin, inBegin))
+              {
+                wrtTrace(SecondaryRuntime_HERE, "character orientation (%.1000s)", std::string(readBegin, inBegin).c_str());
+                m_characterOrientation= Tokenizer::orientation(readBegin);
+                if(Tokenizer::readTemplateFontDomain(inBegin, inEnd, readBegin, inBegin))
+                {
+                  wrtTrace(SecondaryRuntime_HERE, "font domain (%.1000s)", std::string(readBegin, inBegin).c_str());
+                  m_fontDomain= Tokenizer::fontDomain(readBegin);
+                  if(Tokenizer::readTemplateFont(inBegin, inEnd, readBegin, inBegin))
+                  {
+                    wrtTrace(SecondaryRuntime_HERE, "template font (%.1000s)", std::string(readBegin, inBegin).c_str());
+                    m_aeafont= Tokenizer::font(readBegin);
+                    m_usePitchInsteadOfAeaFont= false;
+                    if(m_fontDomain != FD_PITCH)
+                      result= true;
+                  }
+                  else if(Tokenizer::readDigit(2, inBegin, inEnd, readBegin, inBegin))
+                  {
+                    wrtTrace(SecondaryRuntime_HERE, "pitch (%.1000s)", std::string(readBegin, inBegin).c_str());
+                    m_pitch= Tokenizer::digit(readBegin, inBegin);
+                    m_usePitchInsteadOfAeaFont= true;
+                    if(m_fontDomain != FD_AEA && m_pitch != 0)
+                      result= true;
+                  }
+                  if(result)
+                  {
+                    result= false;
+                    if(Tokenizer::readTemplateCharFactor(inBegin, inEnd, readBegin, inBegin))
+                    {
+                      wrtTrace(SecondaryRuntime_HERE, "factor (%.1000s)", std::string(readBegin, inBegin).c_str());
+                      Tokenizer::charFactor(readBegin, m_width_factor, m_height_factor);
+                      if(m_usePitchInsteadOfAeaFont || m_aeafont != PT_FONT_OCR || (m_width_factor == 1 && m_height_factor == 1))
+                      {
+                        if(Tokenizer::readDigit(5, inBegin, inEnd, readBegin, inBegin))
+                        {
+                          wrtTrace(SecondaryRuntime_HERE, "reserved (%.1000s)", std::string(readBegin, inBegin).c_str());
+                          m_text= std::string(inBegin, inEnd);
+                          wrtTrace(SecondaryRuntime_HERE, "text (%.1000s)", std::string(inBegin, inEnd).c_str());
+                          result= true;
+                          outEnd= inEnd;
+                        }
+                      }
+                    }
+                  }
+                }
+              }
+            }
+          }
+        }
+      }
+      return result;
+    }
+    int TemplateText::getLeft() const
+    {
+      return m_left;
+    }
+    int TemplateText::getBottom() const
+    {
+      return m_bottom;
+    }
+    Orientation TemplateText::getPrintOrientation() const
+    {
+      return m_printOrientation;
+    }
+    Orientation TemplateText::getCharacterOrientation() const
+    {
+      return m_characterOrientation;
+    }
+    PectabFont TemplateText::getAeafont() const
+    {
+      return m_aeafont;
+    }
+    TemplateFontDomain TemplateText::getFontDomain() const
+    {
+      return m_fontDomain;
+    }
+    int TemplateText::getPitch() const
+    {
+      return m_pitch;
+    }
+    bool TemplateText::usePitchInsteadOfAeaFont() const
+    {
+      return m_usePitchInsteadOfAeaFont;
+    }
+    int TemplateText::getHeight_factor() const
+    {
+      return m_height_factor;
+    }
+    int TemplateText::getWidth_factor() const
+    {
+      return m_width_factor;
+    }
+    const std::string& TemplateText::getText() const
+    {
+      return m_text;
+    }
+
+    TemplateData::TemplateData()
+    {}
+    bool TemplateData::readTemplateData(const std::string& templateCmd) throw(ParseException)
+    {
+      std::string::const_iterator it= templateCmd.begin();
+      std::string::const_iterator end= templateCmd.end();
+      std::string::const_iterator readBegin;
+      bool success= false;
+      bool isTemplateCmd= false;
+      m_templateId= "";
+      std::string fieldId= BEFORE_FIRST_FIELD;
+
+      if(Tokenizer::readText(TEMPLATE_LOAD, it, end, readBegin, it))  // TT
+      {
+        wrtTrace(SecondaryRuntime_HERE, "Template_Load (%.1000s)", std::string(readBegin, it).c_str());
+        isTemplateCmd= true;
+        if(Tokenizer::readTemplateId(it, end, readBegin, it))
+        {
+          wrtTrace(SecondaryRuntime_HERE, "TemplateId: (%.1000s)", std::string(readBegin, it).c_str());
+          m_templateId= std::string(readBegin, it);
+          if(Tokenizer::readChar(it, end, readBegin, it)) // delimiter for this command
+          {
+            wrtTrace(SecondaryRuntime_HERE, "Delimiter (%.1000s)", std::string(readBegin, it).c_str());
+            char delimiter= *readBegin;
+            std::string::const_iterator readEnd;
+            std::string::const_iterator readBegin2;
+            success= true;
+            TemplateField field;
+            while(it != end)
+            {
+              Tokenizer::readToChar(delimiter, it, end, readBegin, it);   // Field Definition
+              wrtTrace(SecondaryRuntime_HERE, "field (%.1000s)", std::string(readBegin, it).c_str());
+              std::auto_ptr<TemplateField> pField= std::auto_ptr<TemplateField>(field.readTemplateField(readBegin, it, readBegin2, readEnd));
+              if(pField.get() == 0)
+              {
+                success= false;
+                break;
+              }
+              else if(fieldId < pField->getId())
+              {
+                fieldId= pField->getId();
+                m_fieldMap[pField->getId()]= pField;
+              }
+              else
+              {
+                fieldId= pField->getId();
+                success= false;
+                break;
+              }
+              if(readEnd != it)
+              {
+                success= false;
+                break;
+              }
+              Tokenizer::readChar(delimiter, it, end, readBegin, it);
+            }
+          }
+        }
+      }
+      if(isTemplateCmd && !success)
+      {
+        writeTraceText(MajorWarning_HERE, "Invalid Template");
+        if(m_templateId == "")
+          throw InvalidField("Invalid Template", m_templateId);
+        else
+          throw ParseException("Invalid Template");
+      }
+      return isTemplateCmd;
+    }
+    const std::string& TemplateData::templateId() const
+    {
+      return m_templateId;
+    }
+    const TemplateFieldMap& TemplateData::getFields() const
+    {
+      return m_fieldMap;
+    }
+
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaContext.cpp b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaContext.cpp
new file mode 100644
index 00000000..dc25da47
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaContext.cpp
@@ -0,0 +1,606 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaContext.cpp
+//
+//  purpose:    aea command data
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+
+#pragma warning (disable:4786)
+#pragma warning (disable:4503)
+
+#include "aeaContext.h"
+#include "aeaToken.h"
+#include "TraceClt.h"
+
+using namespace MASSAI::AEA;
+
+namespace
+{
+  const char* TRANSACTION_CODE= "CT";
+  const char* TEMPLATE_STATUS=  "TA";
+  const char* TEMPLATE_CLEAR=   "TC";
+  const char* TEMPLATE_LOAD=    "TT";
+  const char* PECTAB_STATUS=    "PS";
+  const char* PECTAB_CLEAR=     "PC";
+  const char* PECTAB_LOAD=      "PT";
+  const char* LOGO_STATUS=      "LS";
+  const char* LOGO_CLEAR=       "LC";
+  const char* LOGO_LOAD=        "LT";
+  const char* RETURN_OK=                "OK";
+  const char* RETURN_FORMATERROR=       "ERR8";
+  const char* RETURN_LOADLOGOERROR=     "ERRL";
+  const char* RETURN_LOADTEMPLATEERROR= "ERRT";
+
+}
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    AEAContextBase::AEAContextBase(const std::string& contextId, const std::string& transactionCode):
+      m_contextId(contextId),
+      m_transactionCode(transactionCode)
+    {}
+    bool AEAContextBase::inputLogo(const std::string& cmd, AEAResult& rsp, AEAPrintProcessor* pProcessor)
+    {
+      bool acceptInput= true;
+      if(loadLogo(cmd, rsp, pProcessor))
+      {
+        writeTraceText(BasicRuntime_HERE, "AEAContext LoadLogo");
+      }
+      else if(clearLogos(cmd, rsp, pProcessor))
+      {
+        writeTraceText(BasicRuntime_HERE, "AEAContext ClearLogos");
+      }
+      else if(getLogoStatus(cmd, rsp))
+      {
+        writeTraceText(BasicRuntime_HERE, "AEAContext LogoStatus");
+      }
+      else
+      {
+        acceptInput= false;
+      }
+      return acceptInput;
+    }
+    bool AEAContextBase::inputTransactionCode(const std::string& cmd, AEAResult& rsp)
+    {
+      bool isTransactionCodeRequest= false;
+      if(Tokenizer::readText(cmd, TRANSACTION_CODE))
+      {
+        isTransactionCodeRequest= true;
+        m_transactionCode= std::string(cmd, 2, cmd.size() - 2);
+
+        std::string response= m_transactionCode + TRANSACTION_CODE + RETURN_OK + m_transactionCode;
+        rsp= AEAResult(new AEAConstResponse(COMMAND_SETUP, RESULT_SUCCESS, response));
+      }
+      return isTransactionCodeRequest;
+    }
+    bool AEAContextBase::clearLogos(const std::string& cmd, AEAResult& rsp, AEAPrintProcessor* pProcessor)
+    {
+      bool isClearLogo= false;
+      std::string::const_iterator it= cmd.begin();
+      std::string::const_iterator end= cmd.end();
+      std::string::const_iterator lcBegin, lcEnd;
+      if(Tokenizer::readText(LOGO_CLEAR, it, end, lcBegin, lcEnd))
+      {
+        isClearLogo= true;
+        if(lcEnd == end)
+        {
+          wrtTrace(BasicRuntime_HERE, "ClearLogos clear all logos");
+          m_logos.clear();
+        }
+        else
+        {
+          std::string::const_iterator logoBegin, logoEnd;
+          it= lcEnd;
+          while(Tokenizer::readLogoId(it, end, logoBegin, logoEnd))
+          {
+            it= logoEnd;
+            Logos::iterator logoIt= m_logos.find(std::string(logoBegin, logoEnd));
+            if(logoIt == m_logos.end())
+            {
+              wrtTrace(BasicRuntime_HERE, "Ignore ClearLogos (%.1000s): not found", std::string(logoBegin, logoEnd).c_str());
+            }
+            else
+            {
+              wrtTrace(BasicRuntime_HERE, "ClearLogos (%.1000s)", std::string(logoBegin, logoEnd).c_str());
+              m_logos.erase(logoIt);
+            }
+          }
+        }
+        std::string response= m_transactionCode + LOGO_CLEAR + RETURN_OK;
+        logostatus(response);
+        rsp= AEAResult(new AEAConstResponse(COMMAND_SETUP, RESULT_SUCCESS, response));
+      }
+      return isClearLogo;
+    }
+    bool AEAContextBase::loadLogo(const std::string& cmd, AEAResult& rsp, AEAPrintProcessor* pProcessor)
+    {
+      bool isLoadLogo= true;
+      try
+      {
+        LogoData lg;
+        isLoadLogo= lg.readLogoData(cmd);
+        if(isLoadLogo)
+        {
+          m_logos[lg.logoId()]= lg;
+          std::string response= m_transactionCode + LOGO_LOAD + RETURN_OK;
+          logostatus(response);
+          rsp= AEAResult(new AEAConstResponse(COMMAND_SETUP, RESULT_SUCCESS, response));
+        }
+      }
+      catch(InvalidField& ex)
+      {
+        std::string response= m_transactionCode + LOGO_LOAD + RETURN_LOADLOGOERROR + ex.field;
+        rsp= AEAResult(new AEAConstResponse(COMMAND_SETUP, RESULT_FORMAT_ERROR, response));
+        wrtTrace(MajorWarning_HERE, "ParseException: (%.4000s), (%.10s)", ex.what(), ex.field.c_str());
+      }
+      catch(ParseException& ex)
+      {
+        std::string response= m_transactionCode + LOGO_LOAD + RETURN_LOADLOGOERROR + "00";
+        rsp= AEAResult(new AEAConstResponse(COMMAND_SETUP, RESULT_FORMAT_ERROR, response));
+        wrtTrace(MajorWarning_HERE, "ParseException: (%.4000s)", ex.what());
+      }
+      return isLoadLogo;
+    }
+    bool AEAContextBase::getLogoStatus(const std::string& cmd, AEAResult& rsp)
+    {
+      bool isLogoStatusRequest= false;
+      std::string::const_iterator it= cmd.begin();
+      std::string::const_iterator end= cmd.end();
+      std::string::const_iterator pcBegin, pcEnd;
+      if(Tokenizer::readText(LOGO_STATUS, it, end, pcBegin, pcEnd) && pcEnd == end)
+      {
+        isLogoStatusRequest= true;
+        std::string response= m_transactionCode + LOGO_STATUS + RETURN_OK;
+        logostatus(response);
+        rsp= AEAResult(new AEAConstResponse(COMMAND_SETUP, RESULT_SUCCESS, response));
+      }
+      return isLogoStatusRequest;
+    }
+    void AEAContextBase::logostatus(std::string& logos)
+    {
+      Logos::iterator it= m_logos.begin();
+      Logos::iterator end= m_logos.end();
+      for(; it != end; ++it)
+      {
+        logos+= (*it).first;
+      }
+    }
+    const LogoData* AEAContextBase::logo(const std::string& logoId) const
+    {
+      Logos::const_iterator it= m_logos.find(logoId);
+      if(it == m_logos.end())
+      {
+        Logos::const_iterator it2= m_logos.find("0" + logoId);
+        if(it2 == m_logos.end())
+        {
+          return 0;
+        }
+        else
+        {
+          return &((*it2).second);
+        }
+      }
+      else
+      {
+        return &((*it).second);
+      }
+    }
+    const std::string& AEAContextBase::contextId() const
+    {
+      return m_contextId;
+    }
+    const std::string& AEAContextBase::transactionCode() const
+    {
+      return m_transactionCode;
+    }
+
+
+    BagtagAEAContext::BagtagAEAContext(const std::string& contextId, const std::string& transactionCode):
+      AEAContextBase(contextId, transactionCode)
+    {}
+    bool BagtagAEAContext::input(const std::string& cmd, AEAResult& rsp, AEAPrintProcessor* pProcessor)
+    {
+      bool acceptInput= true;
+      if(inputTransactionCode(cmd, rsp))
+      {
+        writeTraceText(BasicRuntime_HERE, "AEAContext TransactionCode");
+      }
+      else if(inputLogo(cmd, rsp, pProcessor))
+      {
+        writeTraceText(BasicRuntime_HERE, "AEAContext Logo");
+      }
+      else if(loadPectab(cmd, rsp, pProcessor))
+      {
+        writeTraceText(BasicRuntime_HERE, "AEAContext LoadPectab");
+      }
+      else if(clearPectabs(cmd, rsp, pProcessor))
+      {
+        writeTraceText(BasicRuntime_HERE, "AEAContext ClearPectabs");
+      }
+      else if(getPectabStatus(cmd, rsp))
+      {
+        writeTraceText(BasicRuntime_HERE, "AEAContext PectabStatus");
+      }
+      else
+      {
+        acceptInput= false;
+      }
+      return acceptInput;
+    }
+    const BagTagPectabData* BagtagAEAContext::pectab(const std::string& pectabId, const std::string& pectabVersion) const
+    {
+      BagTagPectabDatas::const_iterator it= m_pectabs.find(std::make_pair(pectabId, pectabVersion));
+      if(it == m_pectabs.end())
+      {
+        return 0;
+      }
+      else
+      {
+        return &((*it).second);
+      }
+    }
+    bool BagtagAEAContext::clearPectabs(const std::string& cmd, AEAResult& rsp, AEAPrintProcessor* pProcessor)
+    {
+      bool isClearPectab= false;
+      std::string::const_iterator it= cmd.begin();
+      std::string::const_iterator end= cmd.end();
+      std::string::const_iterator pcBegin, pcEnd;
+      if(Tokenizer::readText(PECTAB_CLEAR, it, end, pcBegin, pcEnd))
+      {
+        isClearPectab= true;
+        if(pcEnd == end)
+        {
+          wrtTrace(BasicRuntime_HERE, "ClearPectabs clear all pectabs");
+          m_pectabs.clear();
+        }
+        else
+        {
+          std::string::const_iterator pectabBegin, pectabEnd, versionBegin, versionEnd;
+          it= pcEnd;
+          while(Tokenizer::readBTPPectab(it, end, pectabBegin, pectabEnd) && Tokenizer::readBTPPectabVersion(pectabEnd, end, versionBegin, versionEnd))
+          {
+            std::string& pectabId= std::string(pectabBegin, pectabEnd);
+            std::string& pectabVersion= std::string(versionBegin, versionEnd);
+            it= versionEnd;
+            BagTagPectabDatas::iterator pectabIt= m_pectabs.find(std::make_pair(pectabId, pectabVersion));
+            if(pectabIt == m_pectabs.end())
+            {
+              wrtTrace(BasicRuntime_HERE, "Ignore ClearPectabs (%.1000s) (%.1000s) : not found", pectabId.c_str(), pectabVersion.c_str());
+            }
+            else
+            {
+              wrtTrace(BasicRuntime_HERE, "ClearPectabs (%.1000s) %d", pectabId.c_str(), pectabIt->second.version());
+              m_pectabs.erase(pectabIt);
+            }
+          }
+        }
+        std::string response= transactionCode() + PECTAB_CLEAR + RETURN_OK;
+        pectabstatus(response);
+        rsp= AEAResult(new AEAConstResponse(COMMAND_SETUP, RESULT_SUCCESS, response));
+      }
+      return isClearPectab;
+    }
+    bool BagtagAEAContext::loadPectab(const std::string& cmd, AEAResult& rsp, AEAPrintProcessor* pProcessor)
+    {
+      bool isLoadPectab= true;
+      try
+      {
+        BagTagPectabData pt;
+        isLoadPectab= pt.readPectabData(contextId(), cmd);
+        if(isLoadPectab)
+        {
+          m_pectabs[std::make_pair(pt.pectabId(), pt.pectabVersion())]= pt;
+          std::string response= transactionCode() + PECTAB_LOAD + RETURN_OK;
+          pectabstatus(response);
+          rsp= AEAResult(new AEAConstResponse(COMMAND_SETUP, RESULT_SUCCESS, response));
+        }
+      }
+      catch(InvalidField& ex)
+      {
+        std::string response= transactionCode() + PECTAB_LOAD + RETURN_FORMATERROR + ex.field;
+        rsp= AEAResult(new AEAConstResponse(COMMAND_SETUP, RESULT_FORMAT_ERROR, response));
+        wrtTrace(MajorWarning_HERE, "ParseException: (%.4000s), (%.10s)", ex.what(), ex.field.c_str());
+      }
+      catch(ParseException& ex)
+      {
+        std::string response= transactionCode() + PECTAB_LOAD + RETURN_FORMATERROR + "00";
+        rsp= AEAResult(new AEAConstResponse(COMMAND_SETUP, RESULT_FORMAT_ERROR, response));
+        wrtTrace(MajorWarning_HERE, "ParseException: (%.4000s)", ex.what());
+      }
+      return isLoadPectab;
+
+    }
+    bool BagtagAEAContext::getPectabStatus(const std::string& cmd, AEAResult& rsp)
+    {
+      bool isPectabStatusRequest= false;
+      std::string::const_iterator it= cmd.begin();
+      std::string::const_iterator end= cmd.end();
+      std::string::const_iterator pcBegin, pcEnd;
+      if(Tokenizer::readText(PECTAB_STATUS, it, end, pcBegin, pcEnd) && pcEnd == end)
+      {
+        isPectabStatusRequest= true;
+        std::string response= transactionCode() + PECTAB_STATUS + RETURN_OK;
+        pectabstatus(response);
+        rsp= AEAResult(new AEAConstResponse(COMMAND_SETUP, RESULT_SUCCESS, response));
+      }
+      return isPectabStatusRequest;
+    }
+    void BagtagAEAContext::pectabstatus(std::string& pectabs)
+    {
+      BagTagPectabDatas::iterator it= m_pectabs.begin();
+      BagTagPectabDatas::iterator end= m_pectabs.end();
+      for(; it != end; ++it)
+      {
+        pectabs+= (*it).second.pectabId();
+        pectabs+= (*it).second.pectabVersion();
+      }
+    }
+
+    BoardingAEAContext::BoardingAEAContext(const std::string& contextId, const std::string& transactionCode):
+      AEAContextBase(contextId, transactionCode)
+    {}
+    bool BoardingAEAContext::input(const std::string& cmd, AEAResult& rsp, AEAPrintProcessor* pProcessor)
+    {
+      bool acceptInput= true;
+      if(inputTransactionCode(cmd, rsp))
+      {
+        writeTraceText(BasicRuntime_HERE, "AEAContext TransactionCode");
+      }
+      else if(inputLogo(cmd, rsp, pProcessor))
+      {
+        writeTraceText(BasicRuntime_HERE, "AEAContext Logo");
+      }
+      else if(clearPectabs(cmd, rsp, pProcessor))
+      {
+        writeTraceText(BasicRuntime_HERE, "AEAContext ClearPectabs");
+      }
+      else if(loadPectab(cmd, rsp, pProcessor))
+      {
+        writeTraceText(BasicRuntime_HERE, "AEAContext LoadPectab");
+      }
+      else if(getPectabStatus(cmd, rsp))
+      {
+        writeTraceText(BasicRuntime_HERE, "AEAContext PectabStatus");
+      }
+      else if(loadTemplate(cmd, rsp, pProcessor))
+      {
+        writeTraceText(BasicRuntime_HERE, "AEAContext LoadTemplate");
+      }
+      else if(clearTemplates(cmd, rsp, pProcessor))
+      {
+        writeTraceText(BasicRuntime_HERE, "AEAContext ClearTemplates");
+      }
+      else if(getTemplateStatus(cmd, rsp))
+      {
+        writeTraceText(BasicRuntime_HERE, "AEAContext TemplateStatus");
+      }
+      else
+      {
+        acceptInput= false;
+      }
+      return acceptInput;
+    }
+
+    bool BoardingAEAContext::clearPectabs(const std::string& cmd, AEAResult& rsp, AEAPrintProcessor* pProcessor)
+    {
+      bool isClearPectab= false;
+      std::string::const_iterator it= cmd.begin();
+      std::string::const_iterator end= cmd.end();
+      std::string::const_iterator pcBegin, pcEnd;
+      if(Tokenizer::readText(PECTAB_CLEAR, it, end, pcBegin, pcEnd))
+      {
+        isClearPectab= true;
+        if(pcEnd == end)
+        {
+          wrtTrace(BasicRuntime_HERE, "ClearPectabs clear all pectabs");
+          m_pectabs.clear();
+        }
+        else
+        {
+          std::string::const_iterator pectabBegin, pectabEnd, versionBegin, versionEnd;
+          it= pcEnd;
+          while(Tokenizer::readPectab(it, end, pectabBegin, pectabEnd) && Tokenizer::readPectabVersion(pectabEnd, end, versionBegin, versionEnd))
+          {
+            it= versionEnd;
+            Pectabs::iterator pectabIt= m_pectabs.find(std::string(pectabBegin, pectabEnd));
+            if(pectabIt == m_pectabs.end())
+            {
+              wrtTrace(BasicRuntime_HERE, "Ignore ClearPectabs (%.1000s) %d: not found", std::string(pectabBegin, pectabEnd).c_str(), Tokenizer::pectabVersion(versionBegin, versionEnd));
+            }
+            else if((*pectabIt).second.version() == Tokenizer::pectabVersion(versionBegin, versionEnd))
+            {
+              wrtTrace(BasicRuntime_HERE, "ClearPectabs (%.1000s) %d", std::string(pectabBegin, pectabEnd).c_str(), Tokenizer::pectabVersion(versionBegin, versionEnd));
+              m_pectabs.erase(pectabIt);
+            }
+            else
+            {
+              wrtTrace(BasicRuntime_HERE, "Ignore ClearPectabs (%.1000s) %d: version is %d", std::string(pectabBegin, pectabEnd).c_str(), Tokenizer::pectabVersion(versionBegin, versionEnd), (*pectabIt).second.version());
+            }
+          }
+        }
+        std::string response= transactionCode() + PECTAB_CLEAR + RETURN_OK;
+        pectabstatus(response);
+        rsp= AEAResult(new AEAConstResponse(COMMAND_SETUP, RESULT_SUCCESS, response));
+      }
+      return isClearPectab;
+    }
+    bool BoardingAEAContext::getPectabStatus(const std::string& cmd, AEAResult& rsp)
+    {
+      bool isPectabStatusRequest= false;
+      std::string::const_iterator it= cmd.begin();
+      std::string::const_iterator end= cmd.end();
+      std::string::const_iterator pcBegin, pcEnd;
+      if(Tokenizer::readText(PECTAB_STATUS, it, end, pcBegin, pcEnd) && pcEnd == end)
+      {
+        isPectabStatusRequest= true;
+        std::string response= transactionCode() + PECTAB_STATUS + RETURN_OK;
+        pectabstatus(response);
+        rsp= AEAResult(new AEAConstResponse(COMMAND_SETUP, RESULT_SUCCESS, response));
+      }
+      return isPectabStatusRequest;
+    }
+    bool BoardingAEAContext::loadPectab(const std::string& cmd, AEAResult& rsp, AEAPrintProcessor* pProcessor)
+    {
+      bool isLoadPectab= true;
+      try
+      {
+        PectabData pt;
+        isLoadPectab= pt.readPectabData(contextId(), cmd);
+        if(isLoadPectab)
+        {
+          m_pectabs[pt.pectabId()]= pt;
+          std::string response= transactionCode() + PECTAB_LOAD + RETURN_OK;
+          pectabstatus(response);
+          rsp= AEAResult(new AEAConstResponse(COMMAND_SETUP, RESULT_SUCCESS, response));
+        }
+      }
+      catch(InvalidField& ex)
+      {
+        std::string response= transactionCode() + PECTAB_LOAD + RETURN_FORMATERROR + ex.field;
+        rsp= AEAResult(new AEAConstResponse(COMMAND_SETUP, RESULT_FORMAT_ERROR, response));
+        wrtTrace(MajorWarning_HERE, "ParseException: (%.4000s), (%.10s)", ex.what(), ex.field.c_str());
+      }
+      catch(ParseException& ex)
+      {
+        std::string response= transactionCode() + PECTAB_LOAD + RETURN_FORMATERROR + "00";
+        rsp= AEAResult(new AEAConstResponse(COMMAND_SETUP, RESULT_FORMAT_ERROR, response));
+        wrtTrace(MajorWarning_HERE, "ParseException: (%.4000s)", ex.what());
+      }
+      return isLoadPectab;
+    }
+    void BoardingAEAContext::pectabstatus(std::string& pectabs)
+    {
+      Pectabs::iterator it= m_pectabs.begin();
+      Pectabs::iterator end= m_pectabs.end();
+      for(; it != end; ++it)
+      {
+        pectabs+= (*it).first;
+        (*it).second.getVersion(pectabs);
+      }
+    }
+    bool BoardingAEAContext::clearTemplates(const std::string& cmd, AEAResult& rsp, AEAPrintProcessor* pProcessor)
+    {
+      bool isClearTemplate= false;
+      std::string::const_iterator it= cmd.begin();
+      std::string::const_iterator end= cmd.end();
+      std::string::const_iterator lcBegin, lcEnd;
+      if(Tokenizer::readText(TEMPLATE_CLEAR, it, end, lcBegin, lcEnd))
+      {
+        isClearTemplate= true;
+        if(lcEnd == end)
+        {
+          wrtTrace(BasicRuntime_HERE, "ClearTemplates clear all templates");
+          m_templates.clear();
+        }
+        else
+        {
+          std::string::const_iterator templateBegin, templateEnd;
+          it= lcEnd;
+          while(Tokenizer::readTemplateId(it, end, templateBegin, templateEnd))
+          {
+            it= templateEnd;
+            Templates::iterator templateIt= m_templates.find(std::string(templateBegin, templateEnd));
+            if(templateIt == m_templates.end())
+            {
+              wrtTrace(BasicRuntime_HERE, "Ignore ClearTemplates (%.1000s): not found", std::string(templateBegin, templateEnd).c_str());
+            }
+            else
+            {
+              wrtTrace(BasicRuntime_HERE, "ClearTemplates (%.1000s)", std::string(templateBegin, templateEnd).c_str());
+              m_templates.erase(templateIt);
+            }
+          }
+        }
+        std::string response= transactionCode() + TEMPLATE_CLEAR + RETURN_OK;
+        templatestatus(response);
+        rsp= AEAResult(new AEAConstResponse(COMMAND_SETUP, RESULT_SUCCESS, response));
+      }
+      return isClearTemplate;
+    }
+    bool BoardingAEAContext::loadTemplate(const std::string& cmd, AEAResult& rsp, AEAPrintProcessor* pProcessor)
+    {
+      bool isLoadTemplate= true;
+      try
+      {
+        TemplateData td;
+        isLoadTemplate= td.readTemplateData(cmd);
+        if(isLoadTemplate)
+        {
+          m_templates[td.templateId()]= td;
+          std::string response= transactionCode() + TEMPLATE_LOAD + RETURN_OK;
+          templatestatus(response);
+          rsp= AEAResult(new AEAConstResponse(COMMAND_SETUP, RESULT_SUCCESS, response));
+        }
+      }
+      catch(InvalidField& ex)
+      {
+        std::string response= transactionCode() + TEMPLATE_LOAD + RETURN_LOADTEMPLATEERROR + ex.field;
+        rsp= AEAResult(new AEAConstResponse(COMMAND_SETUP, RESULT_FORMAT_ERROR, response));
+        wrtTrace(MajorWarning_HERE, "ParseException: (%.4000s), (%.10s)", ex.what(), ex.field.c_str());
+      }
+      catch(ParseException& ex)
+      {
+        std::string response= transactionCode() + TEMPLATE_LOAD + RETURN_LOADTEMPLATEERROR;
+        rsp= AEAResult(new AEAConstResponse(COMMAND_SETUP, RESULT_FORMAT_ERROR, response));
+        wrtTrace(MajorWarning_HERE, "ParseException: (%.4000s)", ex.what());
+      }
+      return isLoadTemplate;
+    }
+    bool BoardingAEAContext::getTemplateStatus(const std::string& cmd, AEAResult& rsp)
+    {
+      bool isTemplateStatusRequest= false;
+      std::string::const_iterator it= cmd.begin();
+      std::string::const_iterator end= cmd.end();
+      std::string::const_iterator pcBegin, pcEnd;
+      if(Tokenizer::readText(TEMPLATE_STATUS, it, end, pcBegin, pcEnd) && pcEnd == end)
+      {
+        isTemplateStatusRequest= true;
+        std::string response= transactionCode() + TEMPLATE_STATUS + RETURN_OK;
+        templatestatus(response);
+        rsp= AEAResult(new AEAConstResponse(COMMAND_SETUP, RESULT_SUCCESS, response));
+      }
+      return isTemplateStatusRequest;
+    }
+    void BoardingAEAContext::templatestatus(std::string& templates)
+    {
+      Templates::iterator it= m_templates.begin();
+      Templates::iterator end= m_templates.end();
+      for(; it != end; ++it)
+      {
+        templates+= (*it).first;
+      }
+    }
+
+    const PectabData* BoardingAEAContext::pectab(const std::string& pectabId) const
+    {
+      Pectabs::const_iterator it= m_pectabs.find(pectabId);
+      if(it == m_pectabs.end())
+      {
+        return 0;
+      }
+      else
+      {
+        return &((*it).second);
+      }
+    }
+    const TemplateData* BoardingAEAContext::template_(const std::string& templateId) const
+    {
+      Templates::const_iterator it= m_templates.find(templateId);
+      if(it == m_templates.end())
+      {
+        return 0;
+      }
+      else
+      {
+        return &((*it).second);
+      }
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaData.cpp b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaData.cpp
new file mode 100644
index 00000000..59df821d
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaData.cpp
@@ -0,0 +1,5 @@
+ case 'PV':
+   {
+     Resp+= "PVOK";
+     Resp+= pSvgPrint->getVersion();
+   }
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaLogo.cpp b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaLogo.cpp
new file mode 100644
index 00000000..55b4df3b
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaLogo.cpp
@@ -0,0 +1,96 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaCmd.h
+//
+//  purpose:    aea command data
+//
+//  date:       24.05.2007
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//  history:
+//---------------------------------------------------------------------------
+
+
+#pragma warning (disable:4786)
+
+#include "AEAParser/aeaLogo.h"
+#include "aeaToken.h"
+#include "TraceClt.h"
+
+namespace
+{
+  const char* LOGO_STATUS= "LS";
+  const char* LOGO_CLEAR= "LC";
+  const char* LOGO_LOAD= "LT";
+}
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    LogoData::LogoData()
+    {}
+    bool LogoData::readLogoData(const std::string& logoCmd) throw(ParseException)
+    {
+      std::string::const_iterator it= logoCmd.begin();
+      std::string::const_iterator end= logoCmd.end();
+      std::string::const_iterator readBegin;
+      bool success= false;
+      bool isLogoCmd= false;
+      m_logoId= "";
+
+      if(Tokenizer::readText(LOGO_LOAD, it, end, readBegin, it))  // LT
+      {
+        wrtTrace(SecondaryRuntime_HERE, "Logo_Load (%.1000s)", std::string(readBegin, it).c_str());
+        isLogoCmd= true;
+        if(Tokenizer::readLogoId(it, end, readBegin, it))
+        {
+          wrtTrace(SecondaryRuntime_HERE, "LogoId: (%.1000s)", std::string(readBegin, it).c_str());
+          m_logoId= std::string(readBegin, it);
+          if(Tokenizer::readDigit(4, it, end, readBegin, it))
+          {
+            int size= Tokenizer::digit(readBegin, it);
+            if(end - it == size)
+            {
+              std::string logoData= std::string(it, end);
+              if(logoData.size() >= 1 && (logoData.data()[0] == 0xA)) // binary data
+                m_logoData= logoData;
+              else if(logoData.size() >= 2 && (logoData.data()[0] == 'A') && (logoData.data()[1] == '0')) // hex format
+                m_logoData= Tokenizer::fromHexLittleEndian(logoData);
+              else if(logoData.size() >= 2 && (logoData.data()[0] == '0') && (logoData.data()[1] == 'A')) // hex format
+                m_logoData= Tokenizer::fromHexBigEndian(logoData);
+              dumpTrace(SecondaryRuntime_HERE, m_logoData.size(), m_logoData.data());
+              success= true;
+            }
+          }
+        }
+      }
+      if(isLogoCmd && !success)
+      {
+        writeTraceText(MajorWarning_HERE, "Invalid Logo");
+        if(m_logoId == "")
+          throw InvalidField("Invalid Logo", m_logoId);
+        else
+          throw ParseException("Invalid Logo");
+      }
+      return isLogoCmd;
+    }
+    double LogoData::width() const
+    {
+      return m_width;
+    }
+    double LogoData::height() const
+    {
+      return m_height;
+    }
+    const std::string& LogoData::logo() const
+    {
+      return m_logoData;
+    }
+    const std::string& LogoData::logoId() const
+    {
+      return m_logoId;
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaParse.cpp b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaParse.cpp
new file mode 100644
index 00000000..ab5f4e06
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaParse.cpp
@@ -0,0 +1,36 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaParse.cpp
+//
+//  purpose:
+//
+//  date:       14.06.2010
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#include "AEAParser/aeaParse.h"
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    ParseException::ParseException(const std::string& what): std::runtime_error(what)
+    {}
+    InvalidPectab::InvalidPectab(const std::string& what, const std::string& pectabId):
+      ParseException(what),
+      pectab(pectabId)
+    {}
+    InvalidField::InvalidField(const std::string& what, const std::string& fieldId):
+      ParseException(what),
+      field(fieldId)
+    {}
+    InvalidFieldContent::InvalidFieldContent(const std::string& what, const std::string& fieldId, const std::string& fieldContent):
+      InvalidField(what, fieldId),
+      content(fieldContent)
+    {}
+  }
+}
+
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaPrintProcessor.cpp b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaPrintProcessor.cpp
new file mode 100644
index 00000000..5bca864e
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaPrintProcessor.cpp
@@ -0,0 +1,72 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaPrintProcessor.cpp
+//
+//  purpose:    interpret aea commands
+//
+//  date:       10.01.2005
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#pragma warning (disable:4786)
+
+
+
+#include "AEAParser/aeaPrintProcessor.h"
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    AEAPrintProcessor::AEAPrintProcessor()
+    {}
+    AEAPrintProcessor::~AEAPrintProcessor()
+    {}
+    bool AEAPrintProcessor::parseContent(const std::string& context)
+    {
+      return false;
+    }
+    bool AEAPrintProcessor::parseContent(const std::string& context, ContextType type, LogoData& logo)
+    {
+      return parseContent(context);
+    }
+    bool AEAPrintProcessor::parseContent(const std::string& context, PectabData& pectab)
+    {
+      return parseContent(context);
+    }
+    bool AEAPrintProcessor::parseContent(const std::string& context, BagTagPectabData& pectab)
+    {
+      return parseContent(context);
+    }
+    bool AEAPrintProcessor::parseContent(const std::string& context, TemplateData& template_)
+    {
+      return parseContent(context);
+    }
+    void AEAPrintProcessor::processLoad(const std::string& context, ContextType type, LogoData& logo)
+    {}
+    void AEAPrintProcessor::processLoad(const std::string& context, PectabData& pectab)
+    {}
+    void AEAPrintProcessor::processLoad(const std::string& context, BagTagPectabData& pectab)
+    {}
+    void AEAPrintProcessor::processLoad(const std::string& context, TemplateData& template_)
+    {}
+    void AEAPrintProcessor::processClear(const std::string& context, ContextType type, LogoData& logo)
+    {}
+    void AEAPrintProcessor::processClear(const std::string& context, PectabData& pectab)
+    {}
+    void AEAPrintProcessor::processClear(const std::string& context, BagTagPectabData& pectab)
+    {}
+    void AEAPrintProcessor::processClear(const std::string& context, TemplateData& template_)
+    {}
+    void AEAPrintProcessor::process(const std::string& context, AEABagtagPrintJob& job)
+    {}
+    void AEAPrintProcessor::process(const std::string& context, AEATicketPrintJob& job)
+    {}
+    void AEAPrintProcessor::process(const std::string& context, AEAReceiptPrintJob& job)
+    {}
+  }
+}
+
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaReceipt.cpp b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaReceipt.cpp
new file mode 100644
index 00000000..2009f259
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaReceipt.cpp
@@ -0,0 +1,121 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaReceipt.cpp
+//
+//  purpose:    interpret aea commands
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#pragma warning (disable:4786)
+
+#include "AEAParser/aeaReceipt.h"
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    namespace receipt
+    {
+      PrintReceiptException::PrintReceiptException(const std::string& what):
+        std::runtime_error(what)
+      {}
+      PrintReceiptInvalidFontException::PrintReceiptInvalidFontException(const std::string& font):
+        PrintReceiptException(std::string("Invalid font: ") + font)
+      {}
+      PrintReceiptInvalidFontException::PrintReceiptInvalidFontException():
+        PrintReceiptException("No font set!")
+      {}
+      PrintReceiptInvalidFontSizeException::PrintReceiptInvalidFontSizeException(const std::string& fontsize):
+        PrintReceiptException(std::string("Invalid font size: ") + fontsize)
+      {}
+      PrintReceiptInvalidFontSizeException::PrintReceiptInvalidFontSizeException():
+        PrintReceiptException("No font size set!")
+      {}
+      PrintReceiptInvalidCLFException::PrintReceiptInvalidCLFException(const std::string& clf):
+        PrintReceiptException(std::string("Invalid clf: ") + clf)
+      {}
+      Font::Font():
+        fontId(0),
+        fontSizeId(0)
+      {}
+      ReceiptCommand::ReceiptCommand():
+        pCommand(0)
+      {}
+      ReceiptPrinting::ReceiptPrinting()
+      {
+        { // receiptCLF -> receiptCLFMap
+          for(int i= 0; i < sizeof(receiptCLF) / sizeof(*receiptCLF); i++)
+          {
+            const ReceiptCLF& clf= receiptCLF[i];
+            receiptCLFMap[clf.code]= &clf;
+          }
+        }
+        { // receiptFont -> receiptFontMap
+          for(int i= 0; i < sizeof(receiptFont) / sizeof(*receiptFont); i++)
+          {
+            const ReceiptFont& clf= receiptFont[i];
+            receiptFontMap[clf.id]= &clf;
+          }
+        }
+        { // receiptFontSize -> receiptFontSizeMap
+          for(int i= 0; i < sizeof(receiptFontSize) / sizeof(*receiptFontSize); i++)
+          {
+            const ReceiptFontSize& clf= receiptFontSize[i];
+            receiptFontSizeMap[clf.id]= &clf;
+          }
+        }
+      }
+      ReceiptCommand ReceiptPrinting::parseCLF(const std::string& clf) const
+      {
+        ReceiptCommand result;
+        int i= CLF_MAX_SIZE;
+        if(i > clf.length())
+        {
+          i= clf.length();
+        }
+        for(; i >= CLF_MIN_SIZE; i--)
+        {
+          ReceiptCLFMap::const_iterator it= receiptCLFMap.find(std::string(clf, 0, i));
+          if(it != receiptCLFMap.end())
+          {
+            result.pCommand= it->second;
+            result.content= std::string(clf, i, clf.length() - i);
+          }
+        }
+        return result;
+      };
+      const ReceiptFont* ReceiptPrinting::getFont(const std::string& id)
+      {
+        const ReceiptFont* result= 0;
+        ReceiptFontMap::const_iterator it= receiptFontMap.find(id);
+        if(it != receiptFontMap.end())
+        {
+          result= it->second;
+        }
+        else
+        {
+          throw PrintReceiptInvalidFontException(id);
+        }
+        return result;
+      }
+      const ReceiptFontSize* ReceiptPrinting::getFontSize(const std::string& id)
+      {
+        const ReceiptFontSize* result= 0;
+        ReceiptFontSizeMap::const_iterator it= receiptFontSizeMap.find(id);
+        if(it != receiptFontSizeMap.end())
+        {
+          result= it->second;
+        }
+        else
+        {
+          throw PrintReceiptInvalidFontSizeException(id);
+        }
+        return result;
+      }
+    }
+  }
+}
+
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaResponse.cpp b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaResponse.cpp
new file mode 100644
index 00000000..b43f5ab5
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaResponse.cpp
@@ -0,0 +1,79 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaReponse.cpp
+//
+//  purpose:
+//
+//  date:       14.06.2010
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#include "AEAParser/aeaResponse.h"
+#include "AEAParser/aeaStatus.h"
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    AEAResponse::AEAResponse()
+    {}
+    AEAResponse::~AEAResponse()
+    {}
+    Command AEAResponse::getCommandType() const
+    {
+      return COMMAND_UNKNOWN;
+    }
+    std::string AEAResponse::getResponse() const
+    {
+      Status status;
+      status.ribbonStatus= RS_OK;
+      status.dispenserStatus= DS_OK;
+      status.printerStatus= PS_OK;
+      status.feeder.resize(3);
+      for(int i= 0; i < status.feeder.size(); i++)
+      {
+        status.feeder[i].printed= 0;
+        status.feeder[i].voided= 0;
+        status.feeder[i].paperStatus= PS_PRESENT;
+      }
+      status.feeder[0].printed= getDocumentCount();
+      return getResponse(status);
+    }
+    size_t AEAResponse::getDocumentCount() const
+    {
+      return 0;
+    }
+
+    std::string AEAResponse::getResponse(const Status& status) const
+    {
+      return "";
+    }
+    ResultCode AEAResponse::getResultCode() const
+    {
+      return RESULT_FORMAT_ERROR;
+    }
+
+    AEAConstResponse::AEAConstResponse(Command cmd, ResultCode resultCode, const std::string& response):
+      m_cmd(cmd),
+      m_resultCode(resultCode),
+      m_response(response)
+    {}
+    AEAConstResponse::~AEAConstResponse()
+    {}
+    Command AEAConstResponse::getCommandType() const
+    {
+      return m_cmd;
+    }
+    std::string AEAConstResponse::getResponse(const Status& status) const
+    {
+      return m_response;
+    }
+    ResultCode AEAConstResponse::getResultCode() const
+    {
+      return m_resultCode;
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaSimulator.cpp b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaSimulator.cpp
new file mode 100644
index 00000000..ffc814f9
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaSimulator.cpp
@@ -0,0 +1,110 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaSimulator.cpp
+//
+//  purpose:    interpret aea commands
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#pragma warning (disable:4786)
+
+
+#include "AEAParser/aeaSimulator.h"
+#include "aeaSimulator_BoardingPassImpl.h"
+#include "aeaSimulator_BagtagImpl.h"
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    AEAPrintSimulation::AEAPrintSimulation(const std::string& transactionCode)
+    {
+      m_pBagtag=       new BagtagAEAPrintSimulation(transactionCode);
+      m_pBoardingPass= new BoardingPassAEAPrintSimulation(transactionCode);
+    }
+    AEAPrintSimulation::AEAPrintSimulation(const AEAPrintSimulation& assign)
+    {
+      m_pBagtag= new BagtagAEAPrintSimulation(*(assign.m_pBagtag));
+      m_pBoardingPass= new BoardingPassAEAPrintSimulation(*(assign.m_pBoardingPass));
+    }
+    AEAPrintSimulation& AEAPrintSimulation::operator=(const AEAPrintSimulation& assign)
+    {
+      if(&assign != this)
+      {
+        delete m_pBagtag;
+        delete m_pBoardingPass;
+        m_pBagtag= new BagtagAEAPrintSimulation(*(assign.m_pBagtag));
+        m_pBoardingPass= new BoardingPassAEAPrintSimulation(*(assign.m_pBoardingPass));
+      }
+      return *this;
+    }
+    _AEAPrintSimulation* AEAPrintSimulation::getSimulation(ContextType type)
+    {
+      switch(type)
+      {
+        case BAGTAG: return m_pBagtag;
+        default:     return m_pBoardingPass;
+      }
+    }
+    const _AEAPrintSimulation* AEAPrintSimulation::getSimulation(ContextType type) const
+    {
+      switch(type)
+      {
+        case BAGTAG: return m_pBagtag;
+        default:     return m_pBoardingPass;
+      }
+    }
+    AEAPrintSimulation::~AEAPrintSimulation()
+    {
+      delete m_pBagtag;
+      delete m_pBoardingPass;
+    }
+    AEAResult AEAPrintSimulation::sendCommand(const std::string& cmd, ContextType type)
+    {
+      return getSimulation(type)->input(cmd);
+    }
+    void AEAPrintSimulation::setContext(const std::string& contextId, ContextType type)
+    {
+      getSimulation(type)->setContext(contextId);
+    }
+    const std::string& AEAPrintSimulation::getContext(ContextType type) const
+    {
+      return getSimulation(type)->getContextId();
+    }
+    void AEAPrintSimulation::setPrintProcessor(AEAPrintProcessor* pProcessor)
+    {
+      m_pBagtag->setPrintProcessor(pProcessor);
+      m_pBoardingPass->setPrintProcessor(pProcessor);
+    }
+    const LogoData* AEAPrintSimulation::getLogoData(const std::string& context, const std::string& id, ContextType type) const
+    {
+      switch(type)
+      {
+        case BAGTAG: return m_pBagtag->getLogoData(context, id);
+        default:     return m_pBoardingPass->getLogoData(context, id);
+      }
+    }
+    const PectabData* AEAPrintSimulation::getPectabData(const std::string& context, const std::string& id) const
+    {
+      return m_pBoardingPass->getPectabData(context, id);
+    }
+    const BagTagPectabData* AEAPrintSimulation::getBagTagPectabData(const std::string& context, const std::string& id, const std::string& version) const
+    {
+      return m_pBagtag->getBagTagPectabData(context, id, version);
+    }
+    const TemplateData* AEAPrintSimulation::getTemplateData(const std::string& context, const std::string& id) const
+    {
+      return m_pBoardingPass->getTemplateData(context, id);
+    }
+
+    /*
+    AEAResult sendTracks(const Tracks& tracks)
+    {
+      return m_pBoardingPass->sendTracks(tracks);
+    }
+    */
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaSimulator_BagtagImpl.cpp b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaSimulator_BagtagImpl.cpp
new file mode 100644
index 00000000..6c518b48
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaSimulator_BagtagImpl.cpp
@@ -0,0 +1,285 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaSimulator_BagtagImpl.cpp
+//
+//  purpose:    interpret aea commands
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#pragma warning (disable:4786)
+
+#include "TraceClt.h"
+#include "aeaSimulator_BagtagImpl.h"
+#include "aeaToken.h"
+#include "aeaBagtagResponse.h"
+#include "AEAParser/aeaBagtagPrintJob.h"
+#include <vector>
+
+namespace
+{
+  const char* PRINT_BAGTAG=  "BTP";
+  const char* RETURN_PRINTINCORRECT_FIELD= "ERR3";
+  const char* RETURN_PECTABNOTFOUNDERROR=  "ERR6";
+}
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+
+    BagtagAEAPrintSimulation::BagtagAEAPrintSimulation(const std::string& transactionCode):
+      _AEAPrintSimulation(transactionCode)
+    {}
+    BagtagAEAPrintSimulation::~BagtagAEAPrintSimulation()
+    {}
+    AEAResult BagtagAEAPrintSimulation::do_input(const std::string& cmd)
+    {
+      AEAResult rsp;
+      writeTraceText(BasicRuntime_HERE, "BagtagAEAPrintSimulation::input()");
+      dumpTrace(BasicRuntime_HERE, cmd.size(), cmd.data());
+      // rsp.printJobs.clear();
+      if(getContext().input(cmd, rsp, getPrintProcessor()))
+      {
+        writeTraceText(BasicRuntime_HERE, "Setup command");
+      }
+      else if(printTicket(getContext(), cmd, rsp))
+      {
+        writeTraceText(BasicRuntime_HERE, "Print Coupon");
+      }
+      else
+      {
+        writeTraceText(BasicRuntime_HERE, "Unknown input");
+      }
+      return rsp;
+    }
+    const BagtagAEAContext* BagtagAEAPrintSimulation::findContext(const std::string& context) const
+    {
+      const BagtagAEAContext* result= 0;
+      Contexts::const_iterator it= m_contexts.find(getContextId());
+      if(it != m_contexts.end())
+      {
+        result= &((*it).second);
+      }
+      return result;
+    }
+    BagtagAEAContext& BagtagAEAPrintSimulation::getContext()
+    {
+      Contexts::iterator it= m_contexts.find(getContextId());
+      if(it == m_contexts.end())
+      {
+        return (*(m_contexts.insert(std::make_pair(getContextId(), BagtagAEAContext(getContextId(), getTransactionCode())))).first).second;
+      }
+      else
+      {
+        return (*it).second;
+      }
+    }
+
+    bool BagtagAEAPrintSimulation::printTicket(const BagtagAEAContext& context, const std::string& cmd, AEAResult& rsp) throw(ParseException)
+    {
+      bool isPrintCommand= false;
+      Iterator it= cmd.begin();
+      Iterator end= cmd.end();
+      Iterator readBegin;
+      const BagTagPectabData* pPectab= 0;
+      size_t jobCount= 0;
+
+      if(Tokenizer::readText(PRINT_BAGTAG, it, end, readBegin, it))
+      {
+        //rsp.command= COMMAND_PRINT_BAGTAG;
+        isPrintCommand= true;
+        try
+        {
+          if(Tokenizer::readDigit(2, it, end, readBegin, it))
+          {
+            wrtTrace(SecondaryRuntime_HERE, "Table number (%.1000s)", std::string(readBegin, it).c_str());
+            std::string pectabId= std::string(readBegin, it).c_str();
+            if(Tokenizer::readDigit(2, it, end, readBegin, it))
+            {
+              wrtTrace(SecondaryRuntime_HERE, "Table version (%.1000s)", std::string(readBegin, it).c_str());
+              std::string pectabVersion= std::string(readBegin, it).c_str();
+              if(Tokenizer::readDigit(2, it, end, readBegin, it))
+              {
+                wrtTrace(SecondaryRuntime_HERE, "Number of tags (%.1000s)", std::string(readBegin, it).c_str());
+                int printCount= Tokenizer::digit(readBegin, it);
+                jobCount+= printCount;
+                if(Tokenizer::readChar(it, end, readBegin, it))  // delimiter for this command
+                {
+                  typedef std::vector<std::auto_ptr<AEABagtagPrintJob> > JobList;
+                  typedef std::list<JobList> JobListList;
+                  JobListList jobs;
+                  wrtTrace(BasicRuntime_HERE, "Delimiter (%.1000s)", std::string(readBegin, it).c_str());
+                  char delimiter= *readBegin;
+
+                  bool endOfJob= false;
+                  do  // Print Job Loop
+                  {
+                    pPectab= context.pectab(pectabId, pectabVersion);
+                    std::auto_ptr<AEABagtagPrintJob> jobBase= std::auto_ptr<AEABagtagPrintJob>(new AEABagtagPrintJob());
+                    jobBase->context= context.contextId();
+                    // jobBase->isGenerated= true;
+                    if(pPectab == 0)
+                    {
+                      throw InvalidPectab("Pectab Not found", pectabId + pectabVersion);
+                    }
+                    else
+                    {
+                      endOfJob= true;  // do not continue Print Job Loop, after reading Fields (unless continuation character found)
+                      std::string delimiters;
+                      delimiters.append(1, delimiter);
+                      delimiters.append(1, pPectab->continuationCharacter());
+                      while(Tokenizer::readFieldId(it, end, readBegin, it)) // Field Loop
+                      {
+                        wrtTrace(SecondaryRuntime_HERE, "Field (%.1000s)", std::string(readBegin, it).c_str());
+                        std::string fieldId= std::string(readBegin, it);
+                        Tokenizer::readToChar(delimiter, it, end, readBegin, it);   // Field Content
+                        wrtTrace(SecondaryRuntime_HERE, "Field Content (%.1000s)", std::string(readBegin, it).c_str());
+                        jobBase->fields[fieldId]= std::string(readBegin, it);
+
+
+                        if(Tokenizer::readChar(pPectab->continuationCharacter(), it, end, readBegin, it))
+                        {
+                          Iterator continuationBegin= readBegin;
+                          wrtTrace(SecondaryRuntime_HERE, "Continuation (%.1000s)", std::string(readBegin, it).c_str());
+                          if(Tokenizer::readDigit(2, it, end, readBegin, it))
+                          {
+                            wrtTrace(SecondaryRuntime_HERE, "Table number (%.1000s)", std::string(readBegin, it).c_str());
+                            pectabId= std::string(readBegin, it).c_str();
+                            if(Tokenizer::readDigit(2, it, end, readBegin, it))
+                            {
+                              wrtTrace(SecondaryRuntime_HERE, "Table version (%.1000s)", std::string(readBegin, it).c_str());
+                              std::string pectabVersion= std::string(readBegin, it).c_str();
+                              endOfJob= false; // continue in Print Job Loop
+                            }
+                          }
+                          if(!endOfJob)
+                          {
+                            throw InvalidPectab("Pectab Not found", std::string(continuationBegin, it));
+                          }
+                          break;      // leave Field Loop
+                        }
+                        else
+                        {
+                          Tokenizer::readChar(delimiter, it, end, readBegin, it);
+                        }
+                      }
+                      {
+
+                        // check fields
+                        {
+                          AEABagtagPrintJob::TextMap::const_iterator it= jobBase->fields.begin();
+                          AEABagtagPrintJob::TextMap::const_iterator end= jobBase->fields.end();
+                          for(; it != end; ++it)
+                          {
+                            const BagTagPectabField* pPectabField= pPectab->getField((*it).first);
+                            if(pPectabField == 0)
+                              throw InvalidField("Not defined in Pectab", (*it).first);
+                          }
+                        }
+                        JobList jobList(printCount);
+                        // draw fields
+                        for(int i= 0; i < printCount; i++)
+                        {
+                          std::auto_ptr<AEABagtagPrintJob> job= std::auto_ptr<AEABagtagPrintJob>(new AEABagtagPrintJob(*jobBase.get()));
+                          // job->useTemplateFile= false;
+                          job->printCount= 1;
+                          // SVG::SVGContext svgContext(m_printWidth, m_printHeight, SVG::P_BAGTAG);
+                          BagTagPectabFieldMap::const_iterator it= pPectab->getFields().begin();
+                          BagTagPectabFieldMap::const_iterator end= pPectab->getFields().end();
+                          for(; it != end; ++it)
+                          {
+                            const BagTagPectabField* pPectabField= it->second.get();
+                            // pPectabField->svg(svgContext, context, *pPectab, job->fields[pPectabField->getId()], i, job->fields);
+                          }
+                          // pPectab->svgBeginMirror(svgContext);
+                          for(it= pPectab->getFields().begin(); it != end; ++it)
+                          {
+                            const BagTagPectabField* pPectabField= it->second.get();
+                            if(pPectabField->mirror())
+                            {
+                              // pPectabField->svg(svgContext, context, *pPectab, job->fields[pPectabField->getId()], i, job->fields);
+                            }
+                          }
+                          // pPectab->svgEndMirror(svgContext);
+
+                          // svgContext.finalize();
+                          // job->svgClfs["GENERIC_SVG"]= svgContext.svgContent;
+                          jobList[i]= job;
+                        }
+                        jobs.push_back(jobList);
+                      }
+
+                    }
+                  } while(!endOfJob);
+                  for(int i= 0; i < printCount; i++)
+                  {
+                    JobListList::iterator it= jobs.begin();
+                    JobListList::iterator end= jobs.end();
+                    for(; it != end; it++)
+                    {
+                      // rsp.printJobs.push_back((*it)[i]);
+                    }
+                  }
+                }
+              }
+            }
+          }
+          if(it != end)
+          {
+            throw ParseException("Missing Delimiter");
+          }
+
+          rsp= AEAResult(new AEABagtagResponse(getTransactionCode(), jobCount));
+        }
+        catch(InvalidPectab& ex)
+        {
+          std::string response= getTransactionCode() + RETURN_PECTABNOTFOUNDERROR + ex.pectab;
+          rsp= AEAResult(new AEAConstResponse(COMMAND_PRINT, RESULT_FORMAT_ERROR, response));
+          wrtTrace(MajorWarning_HERE, "ParseException: (%.4000s), (%.10s)", ex.what(), ex.pectab.c_str());
+        }
+        catch(InvalidFieldContent& ex)
+        {
+          std::string response= getTransactionCode() + RETURN_PECTABNOTFOUNDERROR + ex.field + ex.content;
+          rsp= AEAResult(new AEAConstResponse(COMMAND_PRINT, RESULT_FORMAT_ERROR, response));
+          wrtTrace(MajorWarning_HERE, "ParseException: (%.4000s), (%.10s) (%.100s)", ex.what(), ex.field.c_str(), ex.content.c_str());
+        }
+        catch(InvalidField& ex)
+        {
+          std::string response= getTransactionCode() + RETURN_PECTABNOTFOUNDERROR + ex.field;
+          rsp= AEAResult(new AEAConstResponse(COMMAND_PRINT, RESULT_FORMAT_ERROR, response));
+          wrtTrace(MajorWarning_HERE, "ParseException: (%.4000s), (%.10s)", ex.what(), ex.field.c_str());
+        }
+        catch(ParseException& ex)
+        {
+          std::string response= getTransactionCode() + RETURN_PECTABNOTFOUNDERROR + "00";
+          rsp= AEAResult(new AEAConstResponse(COMMAND_PRINT, RESULT_FORMAT_ERROR, response));
+          wrtTrace(MajorWarning_HERE, "ParseException: (%.4000s)", ex.what());
+        }
+      }
+      return isPrintCommand;
+    }
+    const LogoData* BagtagAEAPrintSimulation::getLogoData(const std::string& context, const std::string& id) const
+    {
+      const LogoData* result= 0;
+      const BagtagAEAContext* contextElement= findContext(context);
+      if(contextElement)
+      {
+        result= contextElement->logo(id);
+      }
+      return result;
+    }
+    const BagTagPectabData* BagtagAEAPrintSimulation::getBagTagPectabData(const std::string& context, const std::string& id, const std::string& version) const
+    {
+      const BagTagPectabData* result= 0;
+      const BagtagAEAContext* contextElement= findContext(context);
+      if(contextElement)
+      {
+        result= contextElement->pectab(id, version);
+      }
+      return result;
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaSimulator_BoardingPassImpl.cpp b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaSimulator_BoardingPassImpl.cpp
new file mode 100644
index 00000000..ca9f8556
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaSimulator_BoardingPassImpl.cpp
@@ -0,0 +1,527 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaSimulator_BoardingPassImpl.cpp
+//
+//  purpose:    interpret aea commands
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#pragma warning (disable:4786)
+
+#include "aeaSimulator_BoardingPassImpl.h"
+#include "TraceClt.h"
+#include "aeaToken.h"
+#include "AEAParser/aeaResponse.h"
+#include "aeaBoardingPassResponse.h"
+#include "AEAParser/aeaBoardingPassPrintJob.h"
+
+using namespace MASSAI::AEA;
+
+namespace
+{
+  const char* PRINT_COUPON=  "CP";
+  const char* PRINT_TICKET=  "TK";
+  const char* PRINT_RECEIPT= "RD";
+  const char* RETURN_PRINTINCORRECT_FIELD= "ERR3";
+  const char* RETURN_PECTABNOTFOUNDERROR=  "ERR6";
+
+  const char* RETURN_FONTSIZE_UNAVAILABLE= "ERRSIZE";
+  const char* RETURN_FONT_UNAVAILABLE=     "ERRFONT";
+  const char* RETURN_CLF_INVALID=          "ERRCLF";
+
+  const char* FIRST_FIELD= "01";
+
+  const char* RECEIPT_DOCUMENT_TYPE= "4"; // blank paper
+
+  AEAResult responseIncorrectField(const std::string& transactionCode, char delimiter, const std::string& field)
+  {
+    return AEAResult(new AEACouponResponse(transactionCode, delimiter, RETURN_PRINTINCORRECT_FIELD, 3));
+  }
+}
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    BoardingPassAEAPrintSimulation::BoardingPassAEAPrintSimulation(const std::string& transactionCode):
+      _AEAPrintSimulation(transactionCode)
+    {
+    }
+    BoardingPassAEAPrintSimulation::~BoardingPassAEAPrintSimulation()
+    {}
+    AEAResult BoardingPassAEAPrintSimulation::do_input(const std::string& cmd)
+    {
+      AEAResult rsp;
+      writeTraceText(BasicRuntime_HERE, "BoardingPassAEAPrintSimulation::input()");
+      dumpTrace(BasicRuntime_HERE, cmd.size(), cmd.data());
+      if(getContext().input(cmd, rsp, getPrintProcessor()))
+      {
+        writeTraceText(BasicRuntime_HERE, "Setup command");
+      }
+      else if(printTicket(getContext(), cmd, rsp))
+      {
+        writeTraceText(BasicRuntime_HERE, "Print Coupon");
+      }
+      else if(printReceipt(getContext(), cmd, rsp))
+      {
+        writeTraceText(BasicRuntime_HERE, "Print Receipt");
+      }
+      else
+      {
+        writeTraceText(BasicRuntime_HERE, "Unknown input");
+      }
+      return rsp;
+    }
+    const BoardingAEAContext* BoardingPassAEAPrintSimulation::findContext(const std::string& context) const
+    {
+      const BoardingAEAContext* result= 0;
+      Contexts::const_iterator it= m_contexts.find(getContextId());
+      if(it != m_contexts.end())
+      {
+        result= &((*it).second);
+      }
+      return result;
+    }
+    BoardingAEAContext& BoardingPassAEAPrintSimulation::getContext()
+    {
+      Contexts::iterator it= m_contexts.find(getContextId());
+      if(it == m_contexts.end())
+      {
+        return (*(m_contexts.insert(std::make_pair(getContextId(), BoardingAEAContext(getContextId(), getTransactionCode())))).first).second;
+      }
+      else
+      {
+        return (*it).second;
+      }
+    }
+
+    bool BoardingPassAEAPrintSimulation::printTicket(const BoardingAEAContext& context, const std::string& cmd, AEAResult& rsp) throw(ParseException)
+    {
+      bool isPrintCommand= true;
+      Iterator it= cmd.begin();
+      Iterator end= cmd.end();
+      Iterator readBegin;
+      char delimiter;
+      AEATicketPrintJob::TextMap allData;
+      std::auto_ptr<AEATicketPrintJob> job;
+      std::auto_ptr<AEATicketPrintJob> all;
+      const PectabData* pPectab= 0;
+      const PectabData* pPectabAll= 0;
+      std::string actionCode;
+
+      char responseDelimiter;
+      std::string responseTransactionCode= getTransactionCode();
+      size_t jobCount= 0;
+
+      if(Tokenizer::readText(cmd, PRINT_COUPON))
+      {
+        actionCode= PRINT_COUPON;
+      }
+      else if(Tokenizer::readText(cmd, PRINT_TICKET))
+      {
+        actionCode= PRINT_TICKET;
+      }
+      else
+      {
+        isPrintCommand= false;
+      }
+      if(isPrintCommand)
+      {
+        try
+        {
+          while(Tokenizer::readText(actionCode, it, end, readBegin, it))  // Document Begin
+          {
+            wrtTrace(BasicRuntime_HERE, "Print Ticket (%.1000s)", std::string(readBegin, it).c_str());
+            job= std::auto_ptr<AEATicketPrintJob>(new AEATicketPrintJob());
+            job->context= context.contextId();
+            if(Tokenizer::readChar(it, end, readBegin, it))  // delimiter for this command
+            {
+              wrtTrace(BasicRuntime_HERE, "Delimiter (%.1000s)", std::string(readBegin, it).c_str());
+              delimiter= *readBegin;
+              if(Tokenizer::readDocumentType(it, end, readBegin, it)) // Document Type
+              {
+                wrtTrace(BasicRuntime_HERE, "Document Type (%.1000s)", std::string(readBegin, it).c_str());
+                job->paperType= Tokenizer::documentType(readBegin, it);
+                if(job->paperType.size() > 0 && job->paperType[job->paperType.size()-1] == 'X')
+                {
+                  if(all.get() != 0)
+                  {
+                    job->fields[FIRST_FIELD]= all->fields[FIRST_FIELD];
+                    job->formatCode= all->formatCode;
+                  }
+                }
+                else // get common data
+                {
+                  if(all.get() != 0)
+                  {
+                    job->templates= all->templates;
+                    job->logos= all->logos;
+                    job->fields= all->fields;
+                    job->formatCode= all->formatCode;
+                  }
+                }
+                pPectab= pPectabAll;
+
+                if(Tokenizer::readDigit(it, end, readBegin, it))  // Document Repeat
+                {
+                  wrtTrace(BasicRuntime_HERE, "Document Repeat (%.1000s)", std::string(readBegin, it).c_str());
+                  job->printCount= Tokenizer::digit(readBegin);
+                }
+                else
+                {
+                  job->printCount= 1;
+                }
+                jobCount+= job->printCount;
+                if(Tokenizer::readChar(delimiter, it, end, readBegin, it)) // delimiter
+                {
+                  while(Tokenizer::readFieldId(it, end, readBegin, it)) // Field Id
+                  {
+                    wrtTrace(SecondaryRuntime_HERE, "Field (%.1000s)", std::string(readBegin, it).c_str());
+                    std::string fieldId= std::string(readBegin, it);
+                    Tokenizer::readToChar(delimiter, it, end, readBegin, it);   // Field Content
+                    wrtTrace(SecondaryRuntime_HERE, "Field Content (%.1000s)", std::string(readBegin, it).c_str());
+                    std::string content;
+                    if(pPectab)
+                    {
+                      Iterator contentIt= readBegin;
+                      Iterator idBegin;
+                      while(contentIt != it)
+                      {
+                        if(Tokenizer::readTemplateCmd(pPectab->logoSteering(), contentIt, it, readBegin, contentIt, idBegin))
+                        {
+                          job->templates[fieldId]= std::string(idBegin, contentIt);
+                        }
+                        else if(Tokenizer::readLogoCmd(pPectab->logoSteering(), contentIt, it, readBegin, contentIt, idBegin))
+                        {
+                          job->logos[fieldId]= std::string(idBegin, contentIt);
+                        }
+                        else if(Tokenizer::readColor(pPectab->colorSteering(), contentIt, it, readBegin, contentIt))
+                        {}
+                        else
+                        {
+                          content+= *contentIt;
+                          ++contentIt;
+                        }
+                      }
+                    }
+                    else
+                    {
+                      content= std::string(readBegin, it);
+                    }
+                    wrtTrace(SecondaryRuntime_HERE, "Field Content (%.1000s)", content.c_str());
+                    if(fieldId == FIRST_FIELD)
+                    {
+                      Iterator pectabBegin, pectabEnd;
+                      if(Tokenizer::readPectab(content.begin(), content.end(), pectabBegin, pectabEnd))
+                      {
+                        pPectab= context.pectab(std::string(pectabBegin, pectabEnd));
+                        if(pPectab)
+                        {
+                          responseDelimiter= pPectab->delimiter();
+                          if(actionCode == PRINT_TICKET)
+                          {
+                            responseTransactionCode= pPectab->transactionCodeTicket();
+                          }
+                          else if(actionCode == PRINT_COUPON)
+                          {
+                            responseTransactionCode= pPectab->transactionCodeCheckin();
+                          }
+                        }
+                        else
+                          throw InvalidPectab("Pectab Not found", std::string(pectabBegin, pectabEnd));
+                        job->formatCode= std::string(pectabBegin, pectabEnd);
+                        wrtTrace(BasicRuntime_HERE, "Pectab (%.1000s)", std::string(pectabBegin, pectabEnd).c_str());
+                      }
+                      else
+                      {
+                        wrtTrace(MajorWarning_HERE, "Field 01 not pectab (%.1000s)", std::string(pectabBegin, pectabEnd).c_str());
+                      }
+                    }
+
+                    job->fields[fieldId]= content;
+                    Tokenizer::readChar(delimiter, it, end, readBegin, it); // delimiter
+                  }
+                }
+              }
+            }
+            if(job->paperType == "A")
+            {
+              if(all.get() == 0)
+              {
+                all= job;
+                pPectabAll= pPectab;
+              }
+            }
+            else
+            {
+              if(pPectab != 0)
+              {
+                if(true) // if(!pPectab->useTemplateFile())
+                {
+                  // use default template, create full svg content
+                  //job->isGenerated= true;
+                  //job->useTemplateFile= false;
+
+                  // draw logos
+                  {
+                    AEATicketPrintJob::TextMap::const_iterator it= job->logos.begin();
+                    AEATicketPrintJob::TextMap::const_iterator end= job->logos.end();
+                    for(; it != end; ++it)
+                    {
+                      const PectabField* pPectabField= pPectab->getField((*it).first);
+                      const LogoData* pLogo= context.logo((*it).second);
+                      if(pPectabField == 0)
+                        throw InvalidFieldContent("Not defined in Pectab", (*it).first, (*it).second);
+                      else if(pLogo == 0)
+                        throw InvalidFieldContent("Logo not found", (*it).first, (*it).second);
+                      else
+                      {
+                        // pPectabField->logo(svgContext, *pLogo);
+                      }
+                    }
+                  }
+                  // draw templates logos
+                  {
+                    AEATicketPrintJob::TextMap::const_iterator it= job->templates.begin();
+                    AEATicketPrintJob::TextMap::const_iterator end= job->templates.end();
+                    for(; it != end; ++it)
+                    {
+                      const PectabField* pPectabField= pPectab->getField((*it).first);
+                      const TemplateData* pTemplate= context.template_((*it).second);
+                      if(pPectabField == 0)
+                        throw InvalidFieldContent("Not defined in Pectab", (*it).first, (*it).second);
+                      else if(pTemplate == 0)
+                        throw InvalidFieldContent("Template not found", (*it).first, (*it).second);
+                      else
+                      {
+                        // pTemplate->svg_logo(svgContext, context);
+                      }
+                    }
+                  }
+                  // draw templates non logos
+                  {
+                    AEATicketPrintJob::TextMap::const_iterator it= job->templates.begin();
+                    AEATicketPrintJob::TextMap::const_iterator end= job->templates.end();
+                    for(; it != end; ++it)
+                    {
+                      const PectabField* pPectabField= pPectab->getField((*it).first);
+                      const TemplateData* pTemplate= context.template_((*it).second);
+                      if(pPectabField == 0)
+                        throw InvalidFieldContent("Not defined in Pectab", (*it).first, (*it).second);
+                      else if(pTemplate == 0)
+                        throw InvalidFieldContent("Template not found", (*it).first, (*it).second);
+                      else
+                      {
+                        // pTemplate->svg(svgContext, context);
+                      }
+                    }
+                  }
+                  // draw barcode and text from print command
+                  {
+                    AEATicketPrintJob::TextMap::const_iterator it= job->fields.begin();
+                    AEATicketPrintJob::TextMap::const_iterator end= job->fields.end();
+                    for(; it != end; ++it)
+                    {
+                      const PectabField* pPectabField= pPectab->getField((*it).first);
+                      if(pPectabField != 0)
+                      {
+                        // pPectabField->svg(svgContext, (*it).second);
+                      }
+                      else
+                        throw InvalidField("Not defined in Pectab", (*it).first);
+                    }
+                  }
+                  // svgContext.finalize();
+                  // job->svgClfs["GENERIC_SVG"]= svgContext.svgContent;
+                }
+                else
+                {
+                  // use template from file, create the field content
+                  // job->isGenerated= false;
+                  // job->useTemplateFile= true;
+                  // CLF::fillFields(pPectab, job.get());
+                }
+              }
+              wrtTrace(BasicRuntime_HERE, "Add Job (%.1000s)", job->paperType.c_str());
+              // rsp.printJobs.push_back(job);
+            }
+          }
+          if(it != end)
+          {
+            throw ParseException("Missing Delimiter");
+          }
+          if(pPectab != 0)
+          {
+            rsp= AEAResult(new AEACouponResponse(responseTransactionCode, responseDelimiter, jobCount, 3));
+          }
+          else
+          {
+            isPrintCommand= false;
+          }
+        }
+        catch(InvalidPectab& ex)
+        {
+          std::string response= responseTransactionCode + RETURN_PECTABNOTFOUNDERROR + ex.pectab;
+          rsp= AEAResult(new AEAConstResponse(COMMAND_PRINT, RESULT_FORMAT_ERROR, response));
+          wrtTrace(MajorWarning_HERE, "ParseException: (%.4000s), (%.10s)", ex.what(), ex.pectab.c_str());
+        }
+        catch(InvalidFieldContent& ex)
+        {
+          rsp= responseIncorrectField(responseTransactionCode, responseDelimiter, ex.field + ex.content);
+          wrtTrace(MajorWarning_HERE, "ParseException: (%.4000s), (%.10s) (%.100s)", ex.what(), ex.field.c_str(), ex.content.c_str());
+        }
+        catch(InvalidField& ex)
+        {
+          rsp= responseIncorrectField(responseTransactionCode, responseDelimiter, ex.field);
+          wrtTrace(MajorWarning_HERE, "ParseException: (%.4000s), (%.10s)", ex.what(), ex.field.c_str());
+        }
+        catch(ParseException& ex)
+        {
+          rsp= responseIncorrectField(responseTransactionCode, responseDelimiter, "00");
+          wrtTrace(MajorWarning_HERE, "ParseException: (%.4000s)", ex.what());
+        }
+      }
+      return isPrintCommand;
+    }
+    // Example:
+    // RD#FONT0#SIZE3#FREEBOARDING-RECEIPT#FONT1#SIZE2#NAMEHASSELHORN/DIETRICHM#ALCDLH#FONT3#SIZE7#FLNR404
+    bool BoardingPassAEAPrintSimulation::printReceipt(const BoardingAEAContext& context, const std::string& cmd, AEAResult& rsp) throw(ParseException)
+    {
+      bool isPrintCommand= false;
+      Iterator it= cmd.begin();
+      Iterator end= cmd.end();
+      Iterator readBegin;
+      char delimiter;
+      AEATicketPrintJob::TextMap allData;
+      std::auto_ptr<AEATicketPrintJob> job;
+
+      if(Tokenizer::readText(PRINT_RECEIPT, it, end, readBegin, it))
+      {
+        // rsp.command= COMMAND_PRINT_RECEIPT;
+        wrtTrace(BasicRuntime_HERE, "Print Receipt (%.1000s)", std::string(readBegin, it).c_str());
+        isPrintCommand= true;
+        try
+        {
+          job= std::auto_ptr<AEATicketPrintJob>(new AEATicketPrintJob());
+          job->context= context.contextId();
+          job->paperType= RECEIPT_DOCUMENT_TYPE;
+          job->printCount= 1;
+          //job->useTemplateFile= false;
+          //job->isGenerated= false;
+          // SVG::SVGContext svgContext(m_printWidth*96/m_resolutionX, m_printHeight*96/m_resolutionY, SVG::P_RECEIPT);
+
+          receipt::Font contentFont;
+          receipt::Font labelFont;
+          labelFont.fontId= receiptPrinting.getFont("0");
+          labelFont.fontSizeId= receiptPrinting.getFontSize("0");
+
+          if(Tokenizer::readChar(it, end, readBegin, it))  // delimiter for this command
+          {
+            wrtTrace(BasicRuntime_HERE, "Delimiter (%.1000s)", std::string(readBegin, it).c_str());
+            delimiter= *readBegin;
+            // rsp.delimiter= delimiter;
+            while(Tokenizer::readToChar(delimiter, it, end, readBegin, it)) // Field Content
+            {
+              wrtTrace(SecondaryRuntime_HERE, "Field Content (%.1000s)", std::string(readBegin, it).c_str());
+              std::string content= std::string(readBegin, it);
+              receipt::ReceiptCommand command= receiptPrinting.parseCLF(content);
+              if(command.pCommand == 0)
+              {
+                throw receipt::PrintReceiptInvalidCLFException(content);
+              }
+              else
+              {
+                switch(command.pCommand->command)
+                {
+                  case receipt::RC_PRINT_CONTENT:
+                  case receipt::RC_PRINT_LABEL_CONTENT:
+                  {
+                    wrtTrace(SecondaryRuntime_HERE, "Print (%.100s)->(%.100s)", command.pCommand->code, command.content.c_str());
+                    // receiptPrinting.svg(svgContext, context, command, contentFont, labelFont);
+                    break;
+                  }
+                  case receipt::RC_SET_FONTSIZE:
+                  {
+                    wrtTrace(SecondaryRuntime_HERE, "FontSize (%.100s)->(%.100s)", command.pCommand->code, command.content.c_str());
+                    contentFont.fontSizeId= receiptPrinting.getFontSize(command.content);
+                    break;
+                  }
+                  case receipt::RC_SET_FONTNAME:
+                  {
+                    wrtTrace(SecondaryRuntime_HERE, "FontName (%.100s)->(%.100s)", command.pCommand->code, command.content.c_str());
+                    contentFont.fontId= receiptPrinting.getFont(command.content);
+                    break;
+                  }
+                  default:
+                    wrtTrace(MinorWarning_HERE, "Field (%.100s)->(%.100s) command: (%d)", command.pCommand->code, command.content.c_str(), command.pCommand->command);
+                }
+              }
+              Tokenizer::readChar(delimiter, it, end, readBegin, it); // delimiter
+              if(it == end)
+              {
+                break;
+              }
+            }
+            // svgContext.finalize();
+            // job->svgClfs["GENERIC_SVG"]= svgContext.svgContent;
+            wrtTrace(BasicRuntime_HERE, "Add Job (%.1000s)", job->paperType.c_str());
+            // rsp.printJobs.push_back(job);
+            rsp= AEAResult(new AEAReceiptResponse(getTransactionCode()));
+          }
+        }
+        catch(receipt::PrintReceiptInvalidCLFException& ex)
+        {
+          std::string response= getTransactionCode() + RETURN_CLF_INVALID;
+          rsp= AEAResult(new AEAConstResponse(COMMAND_PRINT, RESULT_FORMAT_ERROR, response));
+          wrtTrace(MajorWarning_HERE, "PrintReceiptInvalidCLFException: (%.4000s)", ex.what());
+        }
+        catch(receipt::PrintReceiptInvalidFontException& ex)
+        {
+          std::string response= getTransactionCode() + RETURN_FONT_UNAVAILABLE;
+          rsp= AEAResult(new AEAConstResponse(COMMAND_PRINT, RESULT_FORMAT_ERROR, response));
+          wrtTrace(MajorWarning_HERE, "PrintReceiptInvalidFontException: (%.4000s)", ex.what());
+        }
+        catch(receipt::PrintReceiptInvalidFontSizeException& ex)
+        {
+          std::string response= getTransactionCode() + RETURN_FONTSIZE_UNAVAILABLE;
+          rsp= AEAResult(new AEAConstResponse(COMMAND_PRINT, RESULT_FORMAT_ERROR, response));
+          wrtTrace(MajorWarning_HERE, "PrintReceiptInvalidFontSizeException: (%.4000s)", ex.what());
+        }
+      }
+      return isPrintCommand;
+    }
+    const LogoData* BoardingPassAEAPrintSimulation::getLogoData(const std::string& context, const std::string& id) const
+    {
+      const LogoData* result= 0;
+      const BoardingAEAContext* contextElement= findContext(context);
+      if(contextElement)
+      {
+        result= contextElement->logo(id);
+      }
+      return result;
+    }
+    const PectabData* BoardingPassAEAPrintSimulation::getPectabData(const std::string& context, const std::string& id) const
+    {
+      const PectabData* result= 0;
+      const BoardingAEAContext* contextElement= findContext(context);
+      if(contextElement)
+      {
+        result= contextElement->pectab(id);
+      }
+      return result;
+    }
+    const TemplateData* BoardingPassAEAPrintSimulation::getTemplateData(const std::string& context, const std::string& id) const
+    {
+      const TemplateData* result= 0;
+      const BoardingAEAContext* contextElement= findContext(context);
+      if(contextElement)
+      {
+        result= contextElement->template_(id);
+      }
+      return result;
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaSimulator_Impl.cpp b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaSimulator_Impl.cpp
new file mode 100644
index 00000000..07eb316a
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaSimulator_Impl.cpp
@@ -0,0 +1,111 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaSimulator_Impl.cpp
+//
+//  purpose:    interpret aea commands
+//
+//  author:     Materna Information & Communications
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#include "aeaSimulator_Impl.h"
+#include "TraceClt.h"
+#include "mAutoMutex.hpp"
+
+namespace
+{
+  const char* RETURN_ERROR_ILLOGICAL=  "ERR2";
+  const char* RETURN_ERROR_INPROGRESS= "ERR7";
+}
+
+
+namespace MASSAI
+{
+  namespace AEA
+  {
+    _AEAPrintSimulation::_AEAPrintSimulation(const _AEAPrintSimulation& assign):
+      m_contextId(assign.m_contextId),
+      m_transactionCode(assign.m_transactionCode),
+      m_active(false),
+      m_pProcessor(0)
+    {}
+    _AEAPrintSimulation& _AEAPrintSimulation::operator=(const _AEAPrintSimulation& assign)
+    {
+      if(&assign != this)
+      {
+        m_contextId= assign.m_contextId;
+        m_transactionCode= assign.m_transactionCode;
+        m_pProcessor= assign.m_pProcessor;
+        m_active= false;
+      }
+      return *this;
+    }
+
+    _AEAPrintSimulation::_AEAPrintSimulation(const std::string& transactionCode):
+      m_contextId("GID"),
+      m_transactionCode(transactionCode),
+      m_active(false)
+    {}
+
+    _AEAPrintSimulation::~_AEAPrintSimulation()
+    {}
+    void _AEAPrintSimulation::setContext(const std::string& contextId)
+    {
+      wrtTrace(BasicRuntime_HERE, "Set Context (%.4000s)", contextId.c_str());
+      if(contextId.size() == 0)
+      {
+        wrtTrace(BasicRuntime_HERE, "Set Context (GID) for ()");
+        m_contextId= "GID";
+      }
+      else
+      {
+        m_contextId= contextId;
+      }
+    }
+    AEAResult _AEAPrintSimulation::input(const std::string& cmd)
+    {
+      AEAResult result;
+      {
+        Materna::MSSD::autoMutex mx(m_access);
+        if(m_active)
+        {
+          result= AEAResult(new AEAConstResponse(COMMAND_UNKNOWN, RESULT_FORMAT_ERROR, m_transactionCode + RETURN_ERROR_INPROGRESS));
+        }
+        else
+        {
+          m_active= true;
+        }
+      }
+      if(result.get() == 0)
+      {
+        result= do_input(cmd);
+        if(result.get() == 0)
+        {
+          result= AEAResult(new AEAConstResponse(COMMAND_UNKNOWN, RESULT_FORMAT_ERROR, m_transactionCode + RETURN_ERROR_ILLOGICAL + cmd));
+        }
+        {
+          Materna::MSSD::autoMutex mx(m_access);
+          m_active= false;
+        }
+      }
+      return result;
+    }
+    const std::string& _AEAPrintSimulation::getTransactionCode() const
+    {
+      return m_transactionCode;
+    }
+    const std::string& _AEAPrintSimulation::getContextId() const
+    {
+      return m_contextId;
+    }
+    void _AEAPrintSimulation::setPrintProcessor(AEAPrintProcessor* pProcessor)
+    {
+      m_pProcessor= pProcessor;
+    }
+    AEAPrintProcessor* _AEAPrintSimulation::getPrintProcessor()
+    {
+      return m_pProcessor;
+    }
+  }
+}
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaToken.cpp b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaToken.cpp
new file mode 100644
index 00000000..d67a1113
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/src/aeaToken.cpp
@@ -0,0 +1,839 @@
+//---------------------------------------------------------------------------
+//
+//  file:       aeaToken.cpp
+//
+//  purpose:    parse aea commands
+//
+//  date:       24.05.2007
+//
+//  author:     Materna Information & Communications (SteT)
+//
+//  history:
+//---------------------------------------------------------------------------
+
+#pragma warning (disable:4786)
+
+#include <sstream>
+#include <windows.h>
+#include <algorithm>
+
+#include "aeaToken.h"
+
+
+using namespace::Tokenizer;
+
+namespace
+{
+
+  void extractBagTagOrientation(Iterator inBegin, MASSAI::AEA::Orientation& orientation, MASSAI::AEA::HorizontalAlignment& alignment, MASSAI::AEA::ReverseView& reverseView)
+  {
+    switch(*inBegin)
+    {
+      case '1': orientation= MASSAI::AEA::PT_OR_0DEGREE;   reverseView= MASSAI::AEA::PT_RV_NORMAL;  alignment= MASSAI::AEA::PT_HA_LEFT;    break;
+      case '2': orientation= MASSAI::AEA::PT_OR_0DEGREE;   reverseView= MASSAI::AEA::PT_RV_REVERSE; alignment= MASSAI::AEA::PT_HA_LEFT;    break;
+      case '3': orientation= MASSAI::AEA::PT_OR_90DEGREE;  reverseView= MASSAI::AEA::PT_RV_NORMAL;  alignment= MASSAI::AEA::PT_HA_LEFT;    break;
+      case '4': orientation= MASSAI::AEA::PT_OR_90DEGREE;  reverseView= MASSAI::AEA::PT_RV_REVERSE; alignment= MASSAI::AEA::PT_HA_LEFT;    break;
+      case '5': orientation= MASSAI::AEA::PT_OR_180DEGREE; reverseView= MASSAI::AEA::PT_RV_NORMAL;  alignment= MASSAI::AEA::PT_HA_LEFT;    break;
+      case '6': orientation= MASSAI::AEA::PT_OR_180DEGREE; reverseView= MASSAI::AEA::PT_RV_REVERSE; alignment= MASSAI::AEA::PT_HA_LEFT;    break;
+      case '7': orientation= MASSAI::AEA::PT_OR_270DEGREE; reverseView= MASSAI::AEA::PT_RV_NORMAL;  alignment= MASSAI::AEA::PT_HA_LEFT;    break;
+      case '8': orientation= MASSAI::AEA::PT_OR_270DEGREE; reverseView= MASSAI::AEA::PT_RV_REVERSE; alignment= MASSAI::AEA::PT_HA_LEFT;    break;
+      case 'A': orientation= MASSAI::AEA::PT_OR_0DEGREE;   reverseView= MASSAI::AEA::PT_RV_NORMAL;  alignment= MASSAI::AEA::PT_HA_CENTER;  break;
+      case 'B': orientation= MASSAI::AEA::PT_OR_0DEGREE;   reverseView= MASSAI::AEA::PT_RV_REVERSE; alignment= MASSAI::AEA::PT_HA_CENTER;  break;
+      case 'C': orientation= MASSAI::AEA::PT_OR_90DEGREE;  reverseView= MASSAI::AEA::PT_RV_NORMAL;  alignment= MASSAI::AEA::PT_HA_CENTER;  break;
+      case 'D': orientation= MASSAI::AEA::PT_OR_90DEGREE;  reverseView= MASSAI::AEA::PT_RV_REVERSE; alignment= MASSAI::AEA::PT_HA_CENTER;  break;
+      case 'E': orientation= MASSAI::AEA::PT_OR_180DEGREE; reverseView= MASSAI::AEA::PT_RV_NORMAL;  alignment= MASSAI::AEA::PT_HA_CENTER;  break;
+      case 'F': orientation= MASSAI::AEA::PT_OR_180DEGREE; reverseView= MASSAI::AEA::PT_RV_REVERSE; alignment= MASSAI::AEA::PT_HA_CENTER;  break;
+      case 'G': orientation= MASSAI::AEA::PT_OR_270DEGREE; reverseView= MASSAI::AEA::PT_RV_NORMAL;  alignment= MASSAI::AEA::PT_HA_CENTER;  break;
+      case 'H': orientation= MASSAI::AEA::PT_OR_270DEGREE; reverseView= MASSAI::AEA::PT_RV_REVERSE; alignment= MASSAI::AEA::PT_HA_CENTER;  break;
+      case 'I': orientation= MASSAI::AEA::PT_OR_0DEGREE;   reverseView= MASSAI::AEA::PT_RV_NORMAL;  alignment= MASSAI::AEA::PT_HA_RIGHT;   break;
+      case 'J': orientation= MASSAI::AEA::PT_OR_0DEGREE;   reverseView= MASSAI::AEA::PT_RV_REVERSE; alignment= MASSAI::AEA::PT_HA_RIGHT;   break;
+      case 'K': orientation= MASSAI::AEA::PT_OR_90DEGREE;  reverseView= MASSAI::AEA::PT_RV_NORMAL;  alignment= MASSAI::AEA::PT_HA_RIGHT;   break;
+      case 'L': orientation= MASSAI::AEA::PT_OR_90DEGREE;  reverseView= MASSAI::AEA::PT_RV_REVERSE; alignment= MASSAI::AEA::PT_HA_RIGHT;   break;
+      case 'M': orientation= MASSAI::AEA::PT_OR_180DEGREE; reverseView= MASSAI::AEA::PT_RV_NORMAL;  alignment= MASSAI::AEA::PT_HA_RIGHT;   break;
+      case 'N': orientation= MASSAI::AEA::PT_OR_180DEGREE; reverseView= MASSAI::AEA::PT_RV_REVERSE; alignment= MASSAI::AEA::PT_HA_RIGHT;   break;
+      case 'O': orientation= MASSAI::AEA::PT_OR_270DEGREE; reverseView= MASSAI::AEA::PT_RV_NORMAL;  alignment= MASSAI::AEA::PT_HA_RIGHT;   break;
+      case 'P': orientation= MASSAI::AEA::PT_OR_270DEGREE; reverseView= MASSAI::AEA::PT_RV_REVERSE; alignment= MASSAI::AEA::PT_HA_RIGHT;   break;
+      default:  orientation= MASSAI::AEA::PT_OR_UNKNOWN;   reverseView= MASSAI::AEA::PT_RV_UNKNOWN; alignment= MASSAI::AEA::PT_HA_UNKNOWN; break;
+    }
+  }
+}
+
+namespace Tokenizer
+{
+  bool readText(const std::string& in, const std::string& text)
+  {
+    return in.substr(0, text.size()) == text;
+  }
+  bool readChar(char text, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    if(inBegin != inEnd && *inBegin == text)
+    {
+      ++inBegin;
+      outEnd= inBegin;
+      result= true;
+    }
+    return result;
+  }
+  bool readChar(const std::string& list, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    if(inBegin != inEnd && (list.find(*inBegin) != list.npos))
+    {
+      ++inBegin;
+      outEnd= inBegin;
+      result= true;
+    }
+    return result;
+  }
+  bool readAlpha(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    if(inBegin != inEnd && isalpha(*inBegin))
+    {
+      ++inBegin;
+      outEnd= inBegin;
+      result= true;
+    }
+    return result;
+  }
+
+  bool readChar(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    if(inBegin != inEnd)
+    {
+      ++inBegin;
+      outEnd= inBegin;
+      result= true;
+    }
+    return result;
+  }
+  bool readDigit(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    if(inBegin != inEnd && isdigit(*inBegin))
+    {
+      ++inBegin;
+      outEnd= inBegin;
+      result= true;
+    }
+    return result;
+  }
+  bool readDigit(int count, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    for(;count > 0 && inBegin != inEnd && isdigit(*inBegin); count--)
+    {
+      ++inBegin;
+    }
+    if(count == 0)
+    {
+      outEnd= inBegin;
+      result= true;
+    }
+    return result;
+  }
+  bool readToChar(char text, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    while(inBegin != inEnd && *inBegin != text)
+    {
+      ++inBegin;
+    }
+    // if(inBegin != inEnd)
+    {
+      outEnd= inBegin;
+      result= true;
+    }
+    return result;
+  }
+  bool readToChar(const std::string& list, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    while(inBegin != inEnd && (list.find(*inBegin) == list.npos))
+    {
+      ++inBegin;
+    }
+    // if(inBegin != inEnd)
+    {
+      outEnd= inBegin;
+      result= true;
+    }
+    return result;
+  }
+
+  bool readText(const std::string& text, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    bool result= false;
+    std::string::const_iterator it= text.begin();
+    std::string::const_iterator end= text.end();
+    outBegin= inBegin;
+    while(it != end && inBegin != inEnd && *it == *inBegin)
+    {
+      ++it;
+      ++inBegin;
+    }
+    if(it == end)
+    {
+      outEnd= inBegin;
+      result= true;
+    }
+    return result;
+  }
+  bool readPectab(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    if(inBegin != inEnd)
+    {
+      if(*inBegin == 'P' || *inBegin == 'Z' || *inBegin == 'p' || *inBegin == 'z' )
+      {
+        ++inBegin;
+        if(inBegin != inEnd && (isalpha(*inBegin) || isdigit(*inBegin)))
+        {
+          ++inBegin;
+          if(inBegin != inEnd && (isalpha(*inBegin) || isdigit(*inBegin)))
+          {
+            ++inBegin;
+            outEnd= inBegin;
+            result= true;
+          }
+        }
+      }
+      else if(isalpha(*inBegin) || isdigit(*inBegin))
+      {
+        ++inBegin;
+        outEnd= inBegin;
+        result= true;
+      }
+    }
+    return result;
+  }
+  bool readPectabVersion(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    return readDigit(inBegin, inEnd, outBegin, outEnd);
+  }
+  bool readTransactionCode(char delimiter, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    int i= 0;
+    while(inBegin != inEnd && delimiter != *inBegin && i <= 5)
+    {
+      ++inBegin;
+      ++i;
+    }
+    if(1 <= i && i <= 5)
+    {
+      outEnd= inBegin;
+      result= true;
+    }
+    return result;
+  }
+  bool readFieldId(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    if(inBegin != inEnd)
+    {
+      if(isxdigit(*inBegin))
+      {
+        ++inBegin;
+        if(inBegin != inEnd && isxdigit(*inBegin))
+        {
+          ++inBegin;
+          outEnd= inBegin;
+          result= true;
+        }
+      }
+      else if(isalpha(*inBegin))
+      {
+        ++inBegin;
+        if(inBegin != inEnd && isdigit(*inBegin))
+        {
+          ++inBegin;
+          outEnd= inBegin;
+          result= true;
+        }
+      }
+    }
+    return result;
+  }
+  bool readDocumentType(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    if(inBegin != inEnd)
+    {
+      if(*inBegin == '0' || *inBegin == '1' || *inBegin == '2' || *inBegin == '3' || *inBegin == '4' || *inBegin == '5' || *inBegin == '6')
+      {
+        ++inBegin;
+      }
+      if(inBegin != inEnd)
+      {
+        if(*inBegin == 'F' || *inBegin == 'I' || *inBegin == 'R' || *inBegin == 'S' || *inBegin == 'U' || *inBegin == 'X' || *inBegin == 'A')
+        {
+          ++inBegin;
+          outEnd= inBegin;
+          result= true;
+        }
+        else if(*inBegin == 'C')
+        {
+          ++inBegin;
+          if(inBegin != inEnd && isdigit(*inBegin))
+          {
+            ++inBegin;
+            if(inBegin != inEnd && isdigit(*inBegin))
+            {
+              ++inBegin;
+              outEnd= inBegin;
+              result= true;
+            }
+          }
+        }
+      }
+    }
+    return result;
+  }
+  bool readTemplateId(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    if(inBegin != inEnd && (isdigit(*inBegin) || isdigit(*inBegin))) // 1 digit addressing
+    {
+      ++inBegin;
+      if(inBegin != inEnd && (isdigit(*inBegin) || isdigit(*inBegin))) // 2 digit addressing
+      {
+        ++inBegin;
+        outEnd= inBegin;
+        result= true;
+      }
+    }
+    return result;
+  }
+  bool readTemplateCmd(char cmd, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd, Iterator& idBegin)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    if(inBegin != inEnd && *inBegin == cmd)  // steering command
+    {
+      ++inBegin;
+      if(inBegin != inEnd && *inBegin == cmd)  // steering command
+      {
+        ++inBegin;
+        result= readTemplateId(inBegin, inEnd, idBegin, outEnd);
+      }
+    }
+    return result;
+  }
+  bool readLogoId(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    if(inBegin != inEnd && (isdigit(*inBegin) || isalpha(*inBegin))) // 1 digit addressing
+    {
+      ++inBegin;
+      if(inBegin != inEnd && (isdigit(*inBegin) || isalpha(*inBegin))) // 2 digit addressing
+      {
+        ++inBegin;
+      }
+      outEnd= inBegin;
+      result= true;
+    }
+    return result;
+  }
+  bool readLogoCmd(char cmd, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd, Iterator& idBegin)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    if(inBegin != inEnd && *inBegin == cmd)  // steering command
+    {
+      ++inBegin;
+      result= readLogoId(inBegin, inEnd, idBegin, outEnd);
+    }
+    return result;
+  }
+  bool readColor(char cmd, Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    if(inBegin != inEnd && *inBegin == cmd)  // steering command
+    {
+      ++inBegin;
+      if(inBegin != inEnd && isxdigit(*inBegin)) // color
+      {
+        ++inBegin;
+        outEnd= inBegin;
+        result= true;
+      }
+    }
+    return result;
+  }
+  bool readRow(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    if(inBegin != inEnd && 'A' <= *inBegin && *inBegin <= 'R')
+    {
+      ++inBegin;
+      outEnd= inBegin;
+      result= true;
+    }
+    return result;
+  }
+  bool readCLF(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    if(inBegin != inEnd && isalpha(*inBegin))
+    {
+      ++inBegin;
+      if(inBegin != inEnd && isalpha(*inBegin))
+      {
+        ++inBegin;
+        if(inBegin != inEnd && isalpha(*inBegin))
+        {
+          ++inBegin;
+          if(inBegin != inEnd && isalpha(*inBegin))
+          {
+            ++inBegin;
+            std::string::const_iterator readBegin;
+            if(readFieldId(inBegin, inEnd, readBegin, inBegin))
+            {
+              while(readFieldId(inBegin, inEnd, readBegin, inBegin))
+              {}
+              outEnd= inBegin;
+              result= true;
+            }
+          }
+        }
+      }
+    }
+    return result;
+  }
+  bool readOrientation(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    if(inBegin != inEnd && orientation(inBegin) != MASSAI::AEA::PT_OR_UNKNOWN)
+    {
+      ++inBegin;
+      outEnd= inBegin;
+      result= true;
+    }
+    return result;
+  }
+  bool readTemplateFontDomain(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    if(inBegin != inEnd && fontDomain(inBegin) != MASSAI::AEA::FD_UNKNOWN)
+    {
+      ++inBegin;
+      outEnd= inBegin;
+      result= true;
+    }
+    return result;
+  }
+  bool readTemplateFont(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    if(inBegin != inEnd && font(inBegin) != MASSAI::AEA::PT_FONT_UNKNOWN)
+    {
+      char ft= *inBegin;
+      ++inBegin;
+      if(inBegin != inEnd && *inBegin == ft)
+      {
+        ++inBegin;
+        outEnd= inBegin;
+        result= true;
+      }
+    }
+    return result;
+  }
+  bool readTemplateCharFactor(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    if(inBegin != inEnd && charHeightFactor(inBegin) != -1)
+    {
+      ++inBegin;
+      outEnd= inBegin;
+      result= true;
+    }
+    return result;
+  }
+  void charFactor(Iterator inBegin, int& width, int& height)
+  {
+    switch(*inBegin)
+    {
+      case '@': height= 1; width= 1; break;
+      case 'A': height= 2; width= 1; break;
+      case 'B': height= 3; width= 1; break;
+      case 'C': height= 4; width= 1; break;
+      case 'D': height= 1; width= 2; break;
+      case 'E': height= 2; width= 2; break;
+      case 'F': height= 3; width= 2; break;
+      case 'G': height= 4; width= 2; break;
+      case 'H': height= 1; width= 3; break;
+      case 'I': height= 2; width= 3; break;
+      case 'J': height= 3; width= 3; break;
+      case 'K': height= 4; width= 3; break;
+      case 'L': height= 1; width= 4; break;
+      case 'M': height= 2; width= 4; break;
+      case 'N': height= 3; width= 4; break;
+      case 'O': height= 4; width= 4; break;
+      default: height= -1; width= -1;
+    }
+  }
+  int characterValue(Iterator inBegin)
+  {
+    switch(*inBegin)
+    {
+      case 'A': return 1;
+      case 'B': return 2;
+      case 'C': return 3;
+      case 'D': return 4;
+      case 'E': return 5;
+      case 'F': return 6;
+      case 'G': return 7;
+      case 'H': return 8;
+      case 'I': return 9;
+      case 'J': return 10;
+      case 'K': return 11;
+      case 'L': return 12;
+      case 'M': return 13;
+      case 'N': return 14;
+      case 'O': return 15;
+      case 'P': return 16;
+      case 'Q': return 17;
+      case 'R': return 18;
+      case 'S': return 19;
+      case 'T': return 20;
+      case 'U': return 21;
+      case 'V': return 22;
+      case 'W': return 23;
+      case 'X': return 24;
+      case 'Y': return 25;
+      case 'Z': return 26;
+      case 'a': return 1;
+      case 'b': return 2;
+      case 'c': return 3;
+      case 'd': return 4;
+      case 'e': return 5;
+      case 'f': return 6;
+      case 'g': return 7;
+      case 'h': return 8;
+      case 'i': return 9;
+      case 'j': return 10;
+      case 'k': return 11;
+      case 'l': return 12;
+      case 'm': return 13;
+      case 'n': return 14;
+      case 'o': return 15;
+      case 'p': return 16;
+      case 'q': return 17;
+      case 'r': return 18;
+      case 's': return 19;
+      case 't': return 20;
+      case 'u': return 21;
+      case 'v': return 22;
+      case 'w': return 23;
+      case 'x': return 24;
+      case 'y': return 25;
+      case 'z': return 26;
+      default: return -1;
+    }
+  }
+
+  int charHeightFactor(Iterator inBegin)
+  {
+    int width;
+    int height;
+    charFactor(inBegin, width, height);
+    return height;
+  }
+  int charWidthFactor(Iterator inBegin)
+  {
+    int width;
+    int height;
+    charFactor(inBegin, width, height);
+    return height;
+  }
+  MASSAI::AEA::PectabFont font(Iterator inBegin)
+  {
+    switch(*inBegin)
+    {
+      case 'A':
+        return MASSAI::AEA::PT_FONT_NORMAL;
+      case 'F':
+        return MASSAI::AEA::PT_FONT_LARGE;
+      case 'L':
+        return MASSAI::AEA::PT_FONT_CONDENSED;
+      case 'M':
+        return MASSAI::AEA::PT_FONT_OCR;
+      case 'O':
+        return MASSAI::AEA::PT_FONT_CONDENSED_BOLD;
+      case 'R':
+        return MASSAI::AEA::PT_FONT_CPI_5;
+      default:
+        return MASSAI::AEA::PT_FONT_UNKNOWN;
+    }
+  }
+  MASSAI::AEA::TemplateFontDomain fontDomain(Iterator inBegin)
+  {
+    switch(*inBegin)
+    {
+      case 'A':
+        return MASSAI::AEA::FD_AEA;
+      case 'D':
+        return MASSAI::AEA::FD_DOWNLOAD;
+      case 'P':
+        return MASSAI::AEA::FD_PITCH;
+      default:
+        return MASSAI::AEA::FD_UNKNOWN;
+    }
+  }
+  MASSAI::AEA::Orientation orientation(Iterator inBegin)
+  {
+    switch(*inBegin)
+    {
+      case '0':
+        return MASSAI::AEA::PT_OR_0DEGREE;
+      case '1':
+        return MASSAI::AEA::PT_OR_90DEGREE;
+      case '2':
+        return MASSAI::AEA::PT_OR_180DEGREE;
+      case '3':
+        return MASSAI::AEA::PT_OR_270DEGREE;
+      default:
+        return MASSAI::AEA::PT_OR_UNKNOWN;
+    }
+  }
+  int digit(Iterator inBegin)
+  {
+    return *inBegin - '0';
+  }
+  int digit(Iterator inBegin, Iterator inEnd)
+  {
+    int result= 0;
+    for( ;inBegin != inEnd; inBegin++)
+      result= result * 10 + digit(inBegin);
+    return result;
+  }
+  int row(Iterator inBegin)
+  {
+    return *inBegin - 'A';
+  }
+  int pectabVersion(Iterator inBegin, Iterator inEnd)
+  {
+    return digit(inBegin);
+  }
+  std::string documentType(Iterator inBegin, Iterator inEnd)
+  {
+    std::string result= std::string(inBegin, inBegin + 1);
+    return result;
+  }
+  std::string clf(Iterator inBegin, Iterator inEnd)
+  {
+    std::string result;
+    if(inEnd - inBegin >= 4)
+      result= std::string(inBegin, inBegin + 4);
+    return result;
+  }
+  char dec(unsigned int value)
+  {
+    switch(value)
+    {
+      case 0: return '0';
+      case 1: return '1';
+      case 2: return '2';
+      case 3: return '3';
+      case 4: return '4';
+      case 5: return '5';
+      case 6: return '6';
+      case 7: return '7';
+      case 8: return '8';
+      case 9: return '9';
+      default: return 'D';
+    }
+  }
+
+
+  bool readBTPPectab(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    return readDigit(2, inBegin, inEnd, outBegin, outEnd);
+  }
+  bool readBTPPectabVersion(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    return readDigit(2, inBegin, inEnd, outBegin, outEnd);
+  }
+  bool readBagTagFont(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    return readChar('0', inBegin, inEnd, outBegin, outEnd);
+  }
+  bool readMirrorIndicator(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    return readChar(' ', inBegin, inEnd, outBegin, outEnd) || readChar('M', inBegin, inEnd, outBegin, outEnd);
+  }
+  bool readBagTagOrientation(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    if(inBegin != inEnd && bagTagOrientation(inBegin) != MASSAI::AEA::PT_OR_UNKNOWN)
+    {
+      ++inBegin;
+      outEnd= inBegin;
+      result= true;
+    }
+    return result;
+  }
+  bool readBagTagLineOrientation(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    if(inBegin != inEnd)
+    {
+      MASSAI::AEA::Orientation orientation;
+      MASSAI::AEA::HorizontalAlignment alignment;
+      MASSAI::AEA::ReverseView reverseView;
+      extractBagTagOrientation(inBegin, orientation, alignment, reverseView);
+      if((orientation == MASSAI::AEA::PT_OR_0DEGREE
+        || orientation == MASSAI::AEA::PT_OR_90DEGREE)
+        && alignment != MASSAI::AEA::PT_HA_UNKNOWN
+        && reverseView == MASSAI::AEA::PT_RV_NORMAL)
+      {
+        ++inBegin;
+        outEnd= inBegin;
+        result= true;
+      }
+    }
+    return result;
+  }
+  bool readBagTagBarcodeOrientation(Iterator inBegin, Iterator inEnd, Iterator& outBegin, Iterator& outEnd)
+  {
+    bool result= false;
+    outBegin= inBegin;
+    if(inBegin != inEnd)
+    {
+      MASSAI::AEA::Orientation orientation;
+      MASSAI::AEA::HorizontalAlignment alignment;
+      MASSAI::AEA::ReverseView reverseView;
+      extractBagTagOrientation(inBegin, orientation, alignment, reverseView);
+      if(orientation != MASSAI::AEA::PT_OR_UNKNOWN
+        && alignment != MASSAI::AEA::PT_HA_UNKNOWN
+        && reverseView == MASSAI::AEA::PT_RV_NORMAL)
+      {
+        ++inBegin;
+        outEnd= inBegin;
+        result= true;
+      }
+    }
+    return result;
+  }
+  bool mirrorIndicator(Iterator inBegin)
+  {
+    return *inBegin == 'M';
+  }
+  MASSAI::AEA::Orientation bagTagOrientation(Iterator inBegin)
+  {
+    MASSAI::AEA::Orientation orientation;
+    MASSAI::AEA::HorizontalAlignment alignment;
+    MASSAI::AEA::ReverseView reverseView;
+    extractBagTagOrientation(inBegin, orientation, alignment, reverseView);
+    return orientation;
+  }
+  MASSAI::AEA::HorizontalAlignment bagTagAlignment(Iterator inBegin)
+  {
+    MASSAI::AEA::Orientation orientation;
+    MASSAI::AEA::HorizontalAlignment alignment;
+    MASSAI::AEA::ReverseView reverseView;
+    extractBagTagOrientation(inBegin, orientation, alignment, reverseView);
+    return alignment;
+  }
+  MASSAI::AEA::ReverseView bagTagReverseView(Iterator inBegin)
+  {
+    MASSAI::AEA::Orientation orientation;
+    MASSAI::AEA::HorizontalAlignment alignment;
+    MASSAI::AEA::ReverseView reverseView;
+    extractBagTagOrientation(inBegin, orientation, alignment, reverseView);
+    return reverseView;
+  }
+
+  int fromHex(char value)
+  {
+    switch(value)
+    {
+      case '0': return  0;
+      case '1': return  1;
+      case '2': return  2;
+      case '3': return  3;
+      case '4': return  4;
+      case '5': return  5;
+      case '6': return  6;
+      case '7': return  7;
+      case '8': return  8;
+      case '9': return  9;
+      case 'A': return  10;
+      case 'B': return  11;
+      case 'C': return  12;
+      case 'D': return  13;
+      case 'E': return  14;
+      case 'F': return  15;
+      case 'a': return  10;
+      case 'b': return  11;
+      case 'c': return  12;
+      case 'd': return  13;
+      case 'e': return  14;
+      case 'f': return  15;
+      default: return -1;
+    }
+  }
+  std::string fromHexLittleEndian(const std::string& data)
+  {
+    std::string result;
+    result.reserve(data.size() / 2);
+    for(int i= 0; i < data.size() - 1; i+= 2)
+    {
+      int v1= fromHex(data[i]);
+      int v2= fromHex(data[i+1]);
+      if(v1 < 0 || v2 < 0)
+      {
+        result= "";
+        break;
+      }
+      else
+        result.append(1, static_cast<char>(v1 + v2 * 16));
+    }
+    return result;
+  }
+  std::string fromHexBigEndian(const std::string& data)
+  {
+    std::string result;
+    result.reserve(data.size() / 2);
+    for(int i= 0; i < data.size() - 1; i+= 2)
+    {
+      int v1= fromHex(data[i]);
+      int v2= fromHex(data[i+1]);
+      if(v1 < 0 || v2 < 0)
+      {
+        result= "";
+        break;
+      }
+      else
+        result.append(1, static_cast<char>(v1 *16 + v2));
+    }
+    return result;
+  }
+
+}
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/src/decoder/AEAContext.cpp b/SelfServiceCommon/Massai/cpp/AEAParser/src/decoder/AEAContext.cpp
new file mode 100644
index 00000000..a9fe660d
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/src/decoder/AEAContext.cpp
@@ -0,0 +1,759 @@
+/**
+ **************************************************************************
+ *
+ * @file AEAContext.cpp
+ *
+ * Contains class implementation for AEAPectab.
+ *
+ * @author MaK
+ *
+ * Copyright (c) 2005 MATERNA Information & Communications
+ *
+ **************************************************************************
+**/
+
+#include <algorithm>
+#include <iostream>
+
+#include "AEAContext.h"
+#include "AEAPectab.h"
+using namespace AEA_Impl;
+
+#include <boost/spirit.hpp>
+using namespace boost::spirit;
+
+typedef uint_parser<unsigned int, 10, 2, 2> int_2_p;
+
+namespace
+{
+
+class fnString
+{
+  dataKey & object;
+public:
+  fnString(dataKey & object) : object(object) { }
+  void operator()(char const * pszStart, char const * pszEnd) const
+  {
+    object = std::string(pszStart, pszEnd);
+  }
+};
+
+std::string msg2String(atbMessage const & m, int max = -1)
+{
+  std::string s;
+  if(max > 0)
+  {
+    s.resize(((m.size() > max) ? max : m.size()) + 1);
+    std::copy(m.begin(), (m.size() > max) ? m.begin() + max : m.end(), s.begin());
+  } else
+  {
+    s.resize(m.size() + 1);
+    std::copy(m.begin(), m.end(), s.begin());
+  }
+  return s;
+}
+
+} // namespace
+
+/**
+ ******************************************************************************
+ ******************************************************************************
+ * class implementation: context
+ ******************************************************************************
+ ******************************************************************************
+**/
+
+context::context(std::string const & name)
+ : name(name),
+   pectabs(),
+   logos(),
+   templates(),
+   fonts(),
+   transactionHeader("ATBR "),
+   mode(checkin),
+   changeListeners()
+{
+}
+
+context::context(context const & c)
+ : name(c.name),
+   pectabs(c.pectabs),
+   logos(c.logos),
+   templates(c.templates),
+   fonts(c.fonts),
+   transactionHeader(c.transactionHeader),
+   mode(c.mode),
+   changeListeners(c.changeListeners)
+{
+}
+
+void context::setListener(contextChangeListener * pListener)
+{
+  // check if we already have a listener for this instance...
+  for(std::vector<contextChangeListener *>::const_iterator i = changeListeners.begin(); i != changeListeners.end(); ++i)
+    if(pListener == *i)
+      return;
+
+  changeListeners.push_back(pListener);
+}
+
+context::RC context::loadLogo(atbMessage const & data)
+{
+  std::string key;
+
+  rule<> logo = str_p("LT") >> (alnum_p >> alnum_p)[fnString(key)] >> *anychar_p;
+
+  if(parse(msg2String(data, 16).c_str(), logo).full)
+  {
+    logos[key] = data;
+    std::cout << "context[" << name.c_str() << "].logo[" << key.c_str() << "].set(" << msg2String(data).c_str() << ")" << std::endl;
+    return RC_OK;
+  }
+  return RC_ERROR;
+}
+
+context::RC context::loadPectab(atbMessage const & data)
+{
+  pectab p(msg2String(data));
+
+  if(!p.isValid())
+    return RC_ERROR;
+
+  std::string key(p.getFormatCode());
+  key.append(std::string(1, p.getPectabVersion()));
+  std::cout << "context[" << name.c_str() << "].pectab[" << key.c_str() << "].set(" << msg2String(data).c_str() << ")" << std::endl;
+  pectabs[key] = data;
+
+  return RC_OK;
+}
+
+context::RC context::loadTemplate(atbMessage const & data)
+{
+  std::string key;
+
+  rule<> templateRule = str_p("TT") >> (digit_p >> digit_p)[fnString(key)] >> *anychar_p;
+
+  if(parse(msg2String(data, 16).c_str(), templateRule).full)
+  {
+    templates[key] = data;
+    std::cout << "context[" << name.c_str() << "].template[" << key.c_str() << "].set(" << msg2String(data).c_str() << ")" << std::endl;
+    return RC_OK;
+  }
+  return RC_ERROR;
+}
+
+context::RC context::loadFont(atbMessage const & data)
+{
+  std::string key;
+
+  rule<> font = str_p("FT") >> (alnum_p >> alnum_p)[fnString(key)] >> *anychar_p;
+
+  if(parse(msg2String(data, 16).c_str(), font).full)
+  {
+    fonts[key] = data;
+    std::cout << "context[" << name.c_str() << "].font[" << key.c_str() << "].set(" << msg2String(data).c_str() << ")" << std::endl;
+    return RC_OK;
+  }
+  return RC_ERROR;
+}
+
+context::RC context::deleteLogo(std::vector<dataKey> const & keys)
+{
+  if(keys.size() == 0)
+    logos.clear();
+
+  for(std::vector<dataKey>::const_iterator i = keys.begin(); i != keys.end(); ++i)
+    logos.erase(*i);
+
+  return RC_OK;
+}
+
+context::RC context::deletePectab(std::vector<dataKey> const & keys)
+{
+  if(keys.size() == 0)
+    pectabs.clear();
+
+  for(std::vector<dataKey>::const_iterator i = keys.begin(); i != keys.end(); ++i)
+    pectabs.erase(*i);
+
+  return RC_OK;
+}
+
+context::RC context::deleteTemplate(std::vector<dataKey> const & keys)
+{
+  if(keys.size() == 0)
+    templates.clear();
+
+  for(std::vector<dataKey>::const_iterator i = keys.begin(); i != keys.end(); ++i)
+    templates.erase(*i);
+
+  return RC_OK;
+}
+
+context::RC context::deleteFont(std::vector<dataKey> const & keys)
+{
+  if(keys.size() == 0)
+    fonts.clear();
+
+  for(std::vector<dataKey>::const_iterator i = keys.begin(); i != keys.end(); ++i)
+    fonts.erase(*i);
+
+  return RC_OK;
+}
+
+context::RC context::setTransactionHeader(std::string const & data)
+{
+  transactionHeader = data;
+
+  return RC_OK;
+}
+
+context::RC context::setIOMode(ioMode m)
+{
+  mode = m;
+
+  return RC_OK;
+}
+
+context::RC context::getPectab(dataKey const & key, atbMessage & m) const
+{
+  for(storageMap::const_iterator i = pectabs.begin(); i != pectabs.end(); ++i)
+    if(i->first[0] == key[0])
+    {
+    m = i->second;
+    return RC_OK;
+    }
+  return RC_ERROR;
+}
+
+context::RC context::getLogo(dataKey const & key, atbMessage & m) const
+{
+  storageMap::const_iterator i = logos.find(key);
+  if(i != logos.end())
+  {
+    m = i->second;
+    return RC_OK;
+  }
+  return RC_ERROR;
+}
+
+context::RC context::getTemplate(dataKey const & key, atbMessage & m) const
+{
+  storageMap::const_iterator i = templates.find(key);
+  if(i != templates.end())
+  {
+    m = i->second;
+    return RC_OK;
+  }
+  return RC_ERROR;
+}
+
+context::RC context::getFont(dataKey const & key, atbMessage & m) const
+{
+  storageMap::const_iterator i = fonts.find(key);
+  if(i != fonts.end())
+  {
+    m = i->second;
+    return RC_OK;
+  }
+  return RC_ERROR;
+}
+
+std::vector<dataKey> context::enumPectabs() const
+{
+  std::vector<dataKey> v;
+  for(storageMap::const_iterator i = pectabs.begin(); i != pectabs.end(); ++i)
+    v.push_back(i->first);
+
+  return v;
+}
+
+std::vector<dataKey> context::enumLogos() const
+{
+  std::vector<dataKey> v;
+  for(storageMap::const_iterator i = logos.begin(); i != logos.end(); ++i)
+    v.push_back(i->first);
+
+  return v;
+}
+
+std::vector<dataKey> context::enumTemplates() const
+{
+  std::vector<dataKey> v;
+  for(storageMap::const_iterator i = templates.begin(); i != templates.end(); ++i)
+    v.push_back(i->first);
+
+  return v;
+}
+
+std::vector<dataKey> context::enumFonts() const
+{
+  std::vector<dataKey> v;
+  for(storageMap::const_iterator i = fonts.begin(); i != fonts.end(); ++i)
+    v.push_back(i->first);
+
+  return v;
+}
+
+std::string const & context::getTransactionHeader() const
+{
+  return transactionHeader;
+}
+
+ioMode context::getIOMode() const
+{
+  return mode;
+}
+
+/**
+ ******************************************************************************
+ ******************************************************************************
+ * class implementation: multiContext
+ ******************************************************************************
+ ******************************************************************************
+**/
+
+/**
+ ******************************************************************************
+ * function: multiContext();
+ *
+ * purpose:
+ *
+ * @@MaK 14.06.2005 10:01
+ ******************************************************************************
+**/
+multiContext::multiContext()
+ : contexts(),
+   currentContext(GLOBAL_USER)
+{
+  setContext(GLOBAL_USER);
+}
+
+/**
+ ******************************************************************************
+ * function: setContext(contextKey const & key);
+ *
+ * purpose: set / add a context
+ *
+ * @@MaK 06.06.2005 17:57
+ ******************************************************************************
+**/
+context::RC multiContext::setContext(contextKey const & key)
+{
+  contextMap::const_iterator i = contexts.find(key);
+  if(i != contexts.end())
+  {
+    currentContext = key;
+  } else
+  {
+    contexts.insert(contextMap::value_type(key, context(key)));
+    currentContext = key;
+  }
+  return context::RC_OK;
+}
+
+/**
+ ******************************************************************************
+ * function: context const & getContext(contextKey const & key);
+ *
+ * purpose: get a reference to the specified context
+ *
+ * @@MaK 06.06.2005 17:59
+ ******************************************************************************
+**/
+context::RC multiContext::getContext(contextKey const & key, context & c) const
+{
+  contextMap::const_iterator i = contexts.find(key);
+  if(i != contexts.end())
+  {
+    c = i->second;
+    return context::RC_OK;
+  }
+  return context::RC_ERROR;
+}
+
+/**
+ ******************************************************************************
+ * function: context & getContext();
+ *
+ * purpose: get a reference to the current context
+ *
+ * @@MaK 06.06.2005 18:00
+ ******************************************************************************
+**/
+context & multiContext::getContext()
+{
+  static context invalidContext("this is an invalid context object that should never be returned!");
+
+  contextMap::iterator i = contexts.find(currentContext);
+  if(i != contexts.end())
+  {
+    return i->second;
+  }
+  return invalidContext;
+}
+
+/**
+ ******************************************************************************
+ * function: context const & getContext() const;
+ *
+ * purpose: get a const reference to the current context
+ *
+ * @@MaK 06.06.2005 18:00
+ ******************************************************************************
+**/
+context const & multiContext::getContext() const
+{
+  static context invalidContext("this is an invalid context object that should never be returned!");
+
+  contextMap::const_iterator i = contexts.find(currentContext);
+  if(i != contexts.end())
+  {
+    return i->second;
+  }
+  return invalidContext;
+}
+
+/**
+ ******************************************************************************
+ * function: contextMap const & getContexts() const;
+ *
+ * purpose:
+ *
+ * @@MaK 09.06.2005 13:16
+ ******************************************************************************
+**/
+contextMap const & multiContext::getContexts() const
+{
+  return contexts;
+}
+
+/**
+ ******************************************************************************
+ ******************************************************************************
+ * local helpers fon context access
+ ******************************************************************************
+ ******************************************************************************
+**/
+
+namespace
+{
+
+std::string enumPectabs(multiContext & ctx)
+{
+  std::vector<dataKey> keys = ctx.getContext().enumPectabs();
+  std::string ret;
+
+  for(std::vector<dataKey>::const_iterator i = keys.begin(); i != keys.end(); ++i)
+    ret.append(*i);
+
+  return ret;
+}
+
+std::string enumLogos(multiContext & ctx)
+{
+  std::vector<dataKey> keys = ctx.getContext().enumLogos();
+  std::string ret;
+
+  for(std::vector<dataKey>::const_iterator i = keys.begin(); i != keys.end(); ++i)
+    ret.append(*i);
+
+  return ret;
+}
+
+std::string enumFonts(multiContext & ctx)
+{
+  std::vector<dataKey> keys = ctx.getContext().enumFonts();
+  std::string ret;
+
+  for(std::vector<dataKey>::const_iterator i = keys.begin(); i != keys.end(); ++i)
+    ret.append(*i);
+
+  return ret;
+}
+
+std::string enumTemplates(multiContext & ctx)
+{
+  std::vector<dataKey> keys = ctx.getContext().enumTemplates();
+  std::string ret;
+
+  for(std::vector<dataKey>::const_iterator i = keys.begin(); i != keys.end(); ++i)
+    ret.append(*i);
+
+  return ret;
+}
+
+std::string pectabStatus(multiContext & ctx)
+{
+  std::string ret(ctx.getContext().getTransactionHeader());
+  switch(ctx.getContext().getIOMode())
+  {
+  case ticketing:
+    ret.append("TSOK");
+    break;
+  case checkin:
+    ret.append("CSOK");
+    break;
+  case boarding:
+  default:
+    ret.append("PSOK");
+    break;
+  }
+
+  ret.append(enumPectabs(ctx));
+  return ret;
+}
+
+std::string pectabClear(multiContext & ctx, atbMessage const & data)
+{
+  std::string ret(ctx.getContext().getTransactionHeader());
+  std::string s(msg2String(data));
+
+  std::vector<dataKey> keys;
+  rule<> cmd = str_p("PC") >> *(alpha_p >> *digit_p)[append(keys)];
+  if(parse(s.c_str(), cmd).full)
+    if(ctx.getContext().deletePectab(keys) == context::RC_OK)
+    {
+      ret.append("PCOK");
+      ret.append(enumPectabs(ctx));
+      return ret;
+    }
+  ret.append("ERR2");
+  ret.append(s);
+  return ret;
+}
+
+std::string pectabLoad(multiContext & ctx, atbMessage const & data)
+{
+  std::string ret(ctx.getContext().getTransactionHeader());
+
+  if(ctx.getContext().loadPectab(data) == context::RC_OK)
+  {
+    ret.append("PTOK");
+    ret.append(enumPectabs(ctx));
+  } else
+  {
+    ret.append("ERR2");
+    ret.append(msg2String(data, 10));
+  }
+  return ret;
+}
+
+std::string templateStatus(multiContext & ctx)
+{
+  std::string ret(ctx.getContext().getTransactionHeader());
+  ret.append("TAOK");
+  ret.append(enumTemplates(ctx));
+  return ret;
+}
+
+std::string templateClear(multiContext & ctx, atbMessage const & data)
+{
+  std::string ret(ctx.getContext().getTransactionHeader());
+
+  std::string s(msg2String(data));
+
+  std::vector<dataKey> keys;
+  rule<> cmd = str_p("TC") >> *(digit_p >> digit_p)[append(keys)];
+  if(parse(s.c_str(), cmd).full)
+    if(ctx.getContext().deleteTemplate(keys) == context::RC_OK)
+    {
+      ret.append("TCOK");
+      ret.append(enumTemplates(ctx));
+      return ret;
+    }
+  ret.append("ERR2");
+  ret.append(s);
+  return ret;
+}
+
+std::string templateLoad(multiContext & ctx, atbMessage const & data)
+{
+  std::string ret(ctx.getContext().getTransactionHeader());
+
+  if(ctx.getContext().loadTemplate(data) == context::RC_OK)
+  {
+    ret.append("TTOK");
+    ret.append(enumTemplates(ctx));
+  } else
+  {
+    ret.append("ERR2");
+    ret.append(msg2String(data, 10));
+  }
+  return ret;
+}
+
+std::string logoStatus(multiContext & ctx)
+{
+  std::string ret(ctx.getContext().getTransactionHeader());
+  ret.append("LSOK");
+  ret.append(enumLogos(ctx));
+  return ret;
+}
+
+std::string logoClear(multiContext & ctx, atbMessage const & data)
+{
+  std::string ret(ctx.getContext().getTransactionHeader());
+
+  std::string s(msg2String(data));
+
+  std::vector<dataKey> keys;
+  rule<> cmd = str_p("LC") >> *(digit_p >> digit_p)[append(keys)];
+  if(parse(s.c_str(), cmd).full)
+    if(ctx.getContext().deleteLogo(keys) == context::RC_OK)
+    {
+      ret.append("LCOK");
+      ret.append(enumLogos(ctx));
+      return ret;
+    }
+  ret.append("ERR2");
+  ret.append(s);
+  return ret;
+}
+
+std::string logoLoad(multiContext & ctx, atbMessage const & data)
+{
+  std::string ret(ctx.getContext().getTransactionHeader());
+
+  if(ctx.getContext().loadLogo(data) == context::RC_OK)
+  {
+    ret.append("LTOK");
+    ret.append(enumLogos(ctx));
+  } else
+  {
+    ret.append("ERR2");
+    ret.append(msg2String(data, 10));
+  }
+  return ret;
+}
+
+std::string fontStatus(multiContext & ctx)
+{
+  std::string ret(ctx.getContext().getTransactionHeader());
+  ret.append("FSOK");
+  ret.append(enumFonts(ctx));
+  return ret;
+}
+
+std::string fontClear(multiContext & ctx, atbMessage const & data)
+{
+  std::string ret(ctx.getContext().getTransactionHeader());
+
+  std::string s(msg2String(data));
+
+  std::vector<dataKey> keys;
+  rule<> cmd = str_p("FC") >> *(digit_p >> digit_p)[append(keys)];
+  if(parse(s.c_str(), cmd).full)
+    if(ctx.getContext().deleteFont(keys) == context::RC_OK)
+    {
+      ret.append("FCOK");
+      ret.append(enumFonts(ctx));
+      return ret;
+    }
+  ret.append("ERR2");
+  ret.append(s);
+  return ret;
+}
+
+std::string fontLoad(multiContext & ctx, atbMessage const & data)
+{
+  std::string ret(ctx.getContext().getTransactionHeader());
+
+  if(ctx.getContext().loadFont(data) == context::RC_OK)
+  {
+    ret.append("FTOK");
+    ret.append(enumFonts(ctx));
+  } else
+  {
+    ret.append("ERR2");
+    ret.append(msg2String(data, 10));
+  }
+  return ret;
+}
+
+std::string setTransactionHeader(multiContext & ctx, atbMessage const & data)
+{
+  std::string s;
+  s.resize(data.size() - 2);
+  std::copy(data.begin() + 2, data.end(), s.begin());
+  ctx.getContext().setTransactionHeader(s);
+  std::string r("CTOK");
+  r.append(ctx.getContext().getTransactionHeader());
+  return r;
+}
+
+} // namespace
+
+/**
+ ******************************************************************************
+ ******************************************************************************
+ * class implementation: contextParser
+ ******************************************************************************
+ ******************************************************************************
+**/
+
+/**
+ ******************************************************************************
+ * function: contextParser(multiContext & ctx);
+ *
+ * purpose:
+ *
+ * @@MaK 07.06.2005 12:19
+ ******************************************************************************
+**/
+contextParser::contextParser(multiContext & ctx)
+ : ctx(ctx)
+{
+}
+
+/**
+ ******************************************************************************
+ * function: std::string process(atbMessage const & data);
+ *
+ * purpose:
+ *
+ * @@MaK 15.06.2005 11:58
+ ******************************************************************************
+**/
+std::string contextParser::process(atbMessage const & data)
+{
+  std::string s(msg2String(data, 10));
+  std::cout << "contextParser: process [" << s.c_str() << "]" << std::endl;
+  std::string ret;
+
+  if(s.compare(0, 2, "PS") == 0)
+    ret = pectabStatus(ctx);
+  else if(s.compare(0, 2, "PC") == 0)
+    ret = pectabClear(ctx, data);
+  else if(s.compare(0, 2, "PT") == 0)
+    ret = pectabLoad(ctx, data);
+  else if(s.compare(0, 2, "TA") == 0)
+    ret = templateStatus(ctx);
+  else if(s.compare(0, 2, "TC") == 0)
+    ret = templateClear(ctx, data);
+  else if(s.compare(0, 2, "TT") == 0)
+    ret = templateLoad(ctx, data);
+  else if(s.compare(0, 2, "LS") == 0)
+    ret = logoStatus(ctx);
+  else if(s.compare(0, 2, "LC") == 0)
+    ret = logoClear(ctx, data);
+  else if(s.compare(0, 2, "LT") == 0)
+    ret = logoLoad(ctx, data);
+  else if(s.compare(0, 2, "FS") == 0)
+    ret = fontStatus(ctx);
+  else if(s.compare(0, 2, "FC") == 0)
+    ret = fontClear(ctx, data);
+  else if(s.compare(0, 2, "FT") == 0)
+    ret = fontLoad(ctx, data);
+  else if(s.compare(0, 2, "CT") == 0)
+    ret = setTransactionHeader(ctx, data);
+  else
+  {
+    ret = ctx.getContext().getTransactionHeader();
+    ret.append("ERR2");
+    ret.append(s);
+  }
+  std::cout << "contextParser: return [" << ret.c_str() << "]" << std::endl;
+  return ret;
+}
+
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/src/decoder/AEADecoder.cpp b/SelfServiceCommon/Massai/cpp/AEAParser/src/decoder/AEADecoder.cpp
new file mode 100644
index 00000000..baa7fc5a
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/src/decoder/AEADecoder.cpp
@@ -0,0 +1,211 @@
+/**
+ **************************************************************************
+ *
+ * @file AEADecoder.cpp
+ *
+ * Contains class implementation for AEADecoder.
+ *
+ * @author MaK
+ *
+ * Copyright (c) 2005 MATERNA Information & Communications
+ *
+ **************************************************************************
+**/
+
+#include "AEADecoder.h"
+#include "AEAContext.h"
+#include "AEAPectab.h"
+#include "atbMessage.hpp"
+
+using namespace AEA_Impl;
+
+namespace
+{
+
+bool getTrackData(std::vector<trackData> const & tracks,
+                  std::string & s,
+                  int track,
+                  int block,
+                  int position,
+                  int size)
+{
+  bool found = false;
+  for(std::vector<trackData>::const_iterator t = tracks.begin(); t != tracks.end() && ! found; ++t)
+    for(std::vector<blockData>::const_iterator b = t->begin(); b != t->end() && !found; ++b)
+      if(t->number() == track &&
+         b->number() == block &&
+         b->size() >= position + size - 1)
+      {
+        s.resize(size);
+        std::copy(b->begin() + position - 1, b->begin() + position - 1 + size, s.begin());
+
+        int lastNotBlank = s.find_last_not_of(' ');
+        if(lastNotBlank != std::string::npos)
+          s.erase(lastNotBlank + 1);
+        else
+          s.erase();
+
+        found = true;
+      }
+  return found;
+}
+
+} // namespace
+
+/**
+ ******************************************************************************
+ * function: magstripeDecoder::magstripeDecoder(multiContext const & mc)
+ *
+ * purpose:
+ *
+ * @@MaK 23.06.2005 09:34
+ ******************************************************************************
+**/
+magstripeDecoder::magstripeDecoder(multiContext const & mc)
+ : mc(mc)
+{
+}
+
+/**
+ ******************************************************************************
+ * function: magstripeDecoder::RC magstripeDecoder::decode(mrEvent const & e, std::string & ret)
+ *
+ * purpose:
+ *
+ * @@MaK 23.06.2005 09:34
+ ******************************************************************************
+**/
+magstripeDecoder::RC magstripeDecoder::decode(mrEvent const & e, std::string & ret)
+{
+  if(e.dataType() != T_ATB)
+    return RC_ERROR;
+
+  std::vector<trackData> const & tracks = e.getTracks();
+
+  // search for something that looks like a valid format code...
+
+  std::string fmtCode;
+
+  bool found = false;
+  for(std::vector<trackData>::const_iterator t = tracks.begin(); t != tracks.end() && ! found; ++t)
+    for(std::vector<blockData>::const_iterator b = t->begin(); b != t->end() && !found; ++b)
+      if(b->size() >= 1)
+      {
+        char code = (*b)[0];
+        switch(code)
+        {
+          case 'P':
+          case 'Z':
+            if(b->size() >= 4)
+            {
+              fmtCode.resize(4);
+              std::copy(b->begin(), b->begin() + 4, fmtCode.begin());
+              found = true;
+            }
+            break;
+          default:
+            fmtCode = std::string(1, b->begin()[0]);
+            found = true;
+            break;
+        }
+      }
+  if(!found)
+    return RC_ERROR;
+
+  // we have a format code, do we have a pectab?
+
+  atbMessage pectabData;
+  if(mc.getContext().getPectab(fmtCode, pectabData) == context::RC_OK)
+  {
+    std::string pectabString;
+    pectabString.resize(pectabData.size());
+    std::copy(pectabData.begin(), pectabData.end(), pectabString.begin());
+    pectab p(pectabString);
+
+    // we have a pectab, create the response header
+
+    //ret = mc.getContext().getTransactionHeader();
+
+    switch(mc.getContext().getIOMode())
+    {
+    case ticketing:
+      ret = p.getHeaderTicketing();
+      ret.append("TKTI");
+      break;
+
+    case checkin:
+      ret = p.getHeaderCheckin();
+      ret.append("ATBI");
+      break;
+
+    case boarding:
+      ret = p.getHeaderBoarding();
+      ret.append("CPNI");
+      break;
+
+    default:
+      return RC_ERROR;
+    }
+
+    ret.append(1, p.getDelimiter());
+
+    // add the format code
+
+    ret.append("01");
+    ret.append(fmtCode);
+
+    // add each data field...
+
+    std::vector<pectabElement> const & elements = p.getElements();
+
+    for(std::vector<pectabElement>::const_iterator i = elements.begin(); i != elements.end(); ++i)
+    {
+      if(i->number.compare("01") == 0)
+        continue;
+
+      if(i->magstripePositions.size() == 0)
+        continue;
+
+      if(((mc.getContext().getIOMode() == checkin ||
+           mc.getContext().getIOMode() == boarding) &&
+          (i->steeringCommand == 'A' ||
+           i->steeringCommand == 'B' ||
+           i->steeringCommand == 'C' ||
+           i->steeringCommand == 'D' ||
+           i->steeringCommand == 'E' ||
+           i->steeringCommand == 'H' ||
+           i->steeringCommand == 'Q')) ||
+         (mc.getContext().getIOMode() == ticketing &&
+          (i->steeringCommand == 'A' ||
+           i->steeringCommand == 'E' ||
+           i->steeringCommand == 'H' ||
+           i->steeringCommand == 'I' ||
+           i->steeringCommand == 'J' ||
+           i->steeringCommand == 'K' ||
+           i->steeringCommand == 'N' ||
+           i->steeringCommand == 'P')))
+      {
+        std::string s;
+        for(std::vector<magstripePosition>::const_iterator m = i->magstripePositions.begin(); m != i->magstripePositions.end(); ++m)
+        {
+          if(getTrackData(tracks, s, m->track, m->block, m->column, i->length))
+            break; //we found it!
+        }
+
+        if(m == i->magstripePositions.end())
+          s = std::string(1, p.getUnreadable());
+
+        ret.append(1, p.getDelimiter());
+        ret.append(i->number);
+        ret.append(s);
+      }
+    }
+  } else
+  {
+    ret = mc.getContext().getTransactionHeader();
+    ret.append("ERR6");
+    ret.append(fmtCode);
+  }
+
+  return RC_OK;
+}
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/src/decoder/AEAPectab.cpp b/SelfServiceCommon/Massai/cpp/AEAParser/src/decoder/AEAPectab.cpp
new file mode 100644
index 00000000..fb761fe7
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/src/decoder/AEAPectab.cpp
@@ -0,0 +1,255 @@
+/**
+ **************************************************************************
+ *
+ * @file pectab.cpp
+ *
+ * Contains class implementation for pectab.
+ *
+ * @author MaK
+ *
+ * Copyright (c) 2005 MATERNA Information & Communications
+ *
+ **************************************************************************
+**/
+
+#include <boost/spirit.hpp>
+using namespace boost::spirit;
+
+typedef uint_parser<unsigned int, 10, 1, 1> int_1_p;
+typedef uint_parser<unsigned int, 10, 2, 2> int_2_p;
+
+#include <iostream>
+
+#include "AEAPectab.h"
+
+namespace AEA_Impl
+{
+
+class pectabParser : public pectabData
+{
+  pectabElement currentElement;
+public:
+  pectabElement & getCurrentElement()
+  {
+    return currentElement;
+  }
+
+  void saveElement()
+  {
+    elements.push_back(currentElement);
+    currentElement.clear();
+  }
+
+  void pectabParser::parsePectab(std::string const & pectabString);
+};
+
+} // namespace AEA_Impl
+
+using namespace AEA_Impl;
+
+class fnChar
+{
+  char & object;
+public:
+  fnChar(char & object) : object(object) { }
+  void operator()(char c) const
+  {
+    object = c;
+  }
+};
+
+class fnString
+{
+  std::string & object;
+public:
+  fnString(std::string & object) : object(object) { }
+  void operator()(char const * pszStart, char const * pszEnd) const
+  {
+    object = std::string(pszStart, pszEnd);
+  }
+};
+
+class fnElementNo
+{
+  pectabParser * p;
+public:
+  fnElementNo(pectabParser * p) : p(p) { }
+  void operator()(char const * pszStart, char const * pszEnd) const
+  {
+    p->getCurrentElement().number = std::string(pszStart, pszEnd);
+  }
+};
+
+class fnElementSize
+{
+  pectabParser * p;
+public:
+  fnElementSize(pectabParser * p) : p(p) { }
+  void operator()(unsigned int i) const
+  {
+    p->getCurrentElement().length = i;
+  }
+};
+
+class fnPrintPos
+{
+  pectabParser * p;
+public:
+  fnPrintPos(pectabParser * p) : p(p) { }
+  void operator()(char const * pszStart, char const * pszEnd) const
+  {
+    printPosition pos;
+    rule<> printPos = alpha_p[assign(pos.row)] >> uint_p[assign(pos.column)];
+    if(parse(std::string(pszStart, pszEnd).c_str(), printPos).full)
+      p->getCurrentElement().printPositions.push_back(pos);
+  }
+};
+
+class fnMagstripePos
+{
+  pectabParser * p;
+public:
+  fnMagstripePos(pectabParser * p) : p(p) { }
+  void operator()(char const * pszStart, char const * pszEnd) const
+  {
+    magstripePosition pos;
+    rule<> magstripePos = int_1_p()[assign(pos.track)] >> int_1_p()[assign(pos.block)] >> int_2_p()[assign(pos.column)];
+    if(parse(std::string(pszStart, pszEnd).c_str(), magstripePos).full)
+      p->getCurrentElement().magstripePositions.push_back(pos);
+  }
+};
+
+class fnSteeringCmd
+{
+  pectabParser * p;
+public:
+  fnSteeringCmd(pectabParser * p) : p(p) { }
+  void operator()(char c) const
+  {
+    p->getCurrentElement().steeringCommand = c;
+  }
+};
+
+class fnElement
+{
+  pectabParser * p;
+public:
+  fnElement(pectabParser * p) : p(p) { }
+  void operator()(char const * pszStart, char const * pszEnd) const
+  {
+    p->saveElement();
+  }
+};
+
+void pectabParser::parsePectab(std::string const & pectabString)
+{
+  rule<> header         = str_p("PT") >> anychar_p[fnChar(delimiterPectab)] >> anychar_p[fnChar(delimiter)]  >> anychar_p[fnChar(unreadable)],
+         delim          = ch_p(boost::ref(delimiterPectab)),
+         pectabName     = (((ch_p('Z') | ch_p('P')) >> alnum_p >> alnum_p) |
+                           (alpha_p - ch_p('Z') - ch_p('P'))
+                          )[fnString(formatCode)]
+                          >> digit_p[fnChar(pectabVersion)]
+                          >> alpha_p[fnChar(atbSteering)]
+                          >> delim,
+         commands       = anychar_p[fnChar(logoSteering)] >> anychar_p[fnChar(colorSteering)],
+         headers        = delim >> (*(anychar_p - delim))[fnString(headerTicketing)]
+                                >> delim >> (*(anychar_p - delim))[fnString(headerCheckin)]
+                                >> delim >> (*(anychar_p - delim))[fnString(headerBoarding)],
+         elementNo      = alnum_p >> alnum_p,
+         printPos       = alpha_p >> int_2_p(),
+         magstripePos   = int_1_p() >> int_1_p() >> int_2_p(),
+         elementText    = elementNo[fnElementNo(this)] >> int_2_p()[fnElementSize(this)] >> *printPos[fnPrintPos(this)] || *magstripePos[fnMagstripePos(this)] >> !alpha_p[fnSteeringCmd(this)] >> delim,
+         elementBarcode = elementNo[fnElementNo(this)] >> ch_p('B') >> int_1_p() >> printPos >> int_2_p() >> int_1_p() >> int_1_p() >> delim,
+         elementField   = alpha_p >> alpha_p >> alpha_p >> alpha_p >> elementNo >> delim,
+         element        = elementText[fnElement(this)] || elementBarcode[fnElement(this)] || elementField[fnElement(this)],
+         completePectab = header >> pectabName >> commands >> headers >> delim >> *element;
+
+  fValid = parse(pectabString.c_str(), completePectab).full;
+}
+
+/**
+ ******************************************************************************
+ ******************************************************************************
+ *
+ * pectab class implementation
+ *
+ ******************************************************************************
+ ******************************************************************************
+**/
+
+pectab::pectab(std::string const & data)
+ : pectabString(data)
+{
+  pParser = new pectabParser();
+  pParser->parsePectab(pectabString);
+}
+
+pectab::~pectab()
+{
+  delete pParser;
+}
+
+char pectab::getDelimiterPectab() const
+{
+  return pParser->delimiterPectab;
+}
+
+char pectab::getDelimiter() const
+{
+  return pParser->delimiter;
+}
+
+char pectab::getUnreadable() const
+{
+  return pParser->unreadable;
+}
+
+std::string const & pectab::getFormatCode() const
+{
+  return pParser->formatCode;
+}
+
+char pectab::getPectabVersion() const
+{
+  return pParser->pectabVersion;
+}
+
+char pectab::getATBSteering() const
+{
+  return pParser->atbSteering;
+}
+
+char pectab::getLogoSteering() const
+{
+  return pParser->logoSteering;
+}
+
+char pectab::getColorSteering() const
+{
+  return pParser->colorSteering;
+}
+
+std::string const & pectab::getHeaderTicketing() const
+{
+  return pParser->headerTicketing;
+}
+
+std::string const & pectab::getHeaderCheckin() const
+{
+  return pParser->headerCheckin;
+}
+
+std::string const & pectab::getHeaderBoarding() const
+{
+  return pParser->headerBoarding;
+}
+
+std::vector<pectabElement> const & pectab::getElements() const
+{
+  return pParser->elements;
+}
+
+bool pectab::isValid() const
+{
+  return pParser->fValid;
+}
diff --git a/SelfServiceCommon/Massai/cpp/AEAParser/src/local_def.cpp b/SelfServiceCommon/Massai/cpp/AEAParser/src/local_def.cpp
new file mode 100644
index 00000000..79046ca6
--- /dev/null
+++ b/SelfServiceCommon/Massai/cpp/AEAParser/src/local_def.cpp
@@ -0,0 +1,14 @@
+#include "versionlib.h"
+
+/*! \mainpage aea_parser
+ *
+ *
+ *  \date 19.10.2010 \li V1.0.0.1
+ *                   \li JK Moved to SelfServiceCommon, changing #include lines
+ *
+ *  \date 19.10.2010 \li V1.0.0.0
+ *                   \li SteT Initial Version
+ *
+ */
+
+VERSION_ID_DT(aea_parser, 1, 0, 0, 1);
-- 
2.41.0.windows.1

