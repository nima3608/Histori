From aa4f197d2af7f8dd1c8c5d39b6f15ab09609653c Mon Sep 17 00:00:00 2001
From: kkluge <kkluge@90b65887-3827-0410-9a23-83215b262276>
Date: Tue, 11 Jul 2017 13:57:09 +0000
Subject: [PATCH 0775/1000] MANTIS 0045630 part 1 : integrate and compile
 barcodeParserLib from Gate-Repository

git-svn-id: svn://localhost/SelfServiceCommon/trunk@1222 90b65887-3827-0410-9a23-83215b262276
---
 .../java/barcodeParserLib/BCConsole.bat       |   4 +
 .../java/barcodeParserLib/BCConsoleTest.bat   |   2 +
 .../java/barcodeParserLib/ReleaseNotes.txt    |  25 +
 .../Massai/java/barcodeParserLib/pom.xml      |  65 ++
 .../materna/buc/cugate/barcode/BCConsole.java |  30 +
 .../buc/cugate/barcode/BCScannerProtocol.java |  97 ++
 .../materna/buc/cugate/barcode/BCStatus.java  |   8 +
 .../materna/buc/cugate/barcode/BCTest.java    | 398 +++++++
 .../materna/buc/cugate/barcode/BCType.java    |   6 +
 .../materna/buc/cugate/barcode/BCWarning.java |   8 +
 .../buc/cugate/barcode/BarcodeInfo.java       | 223 ++++
 .../buc/cugate/barcode/BarcodeParser.java     | 977 ++++++++++++++++++
 .../buc/cugate/barcode/BarcodeSegment.java    | 338 ++++++
 .../buc/cugate/barcode/ConditionalBCPart.java |  73 ++
 .../materna/buc/cugate/barcode/Security.java  |  18 +
 .../buc/cugate/barcode/BarcodeParserTest.java | 135 +++
 .../src/test/resources/log4j.xml              |  42 +
 17 files changed, 2449 insertions(+)
 create mode 100644 SelfServiceCommon/Massai/java/barcodeParserLib/BCConsole.bat
 create mode 100644 SelfServiceCommon/Massai/java/barcodeParserLib/BCConsoleTest.bat
 create mode 100644 SelfServiceCommon/Massai/java/barcodeParserLib/ReleaseNotes.txt
 create mode 100644 SelfServiceCommon/Massai/java/barcodeParserLib/pom.xml
 create mode 100644 SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BCConsole.java
 create mode 100644 SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BCScannerProtocol.java
 create mode 100644 SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BCStatus.java
 create mode 100644 SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BCTest.java
 create mode 100644 SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BCType.java
 create mode 100644 SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BCWarning.java
 create mode 100644 SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BarcodeInfo.java
 create mode 100644 SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BarcodeParser.java
 create mode 100644 SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BarcodeSegment.java
 create mode 100644 SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/ConditionalBCPart.java
 create mode 100644 SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/Security.java
 create mode 100644 SelfServiceCommon/Massai/java/barcodeParserLib/src/test/java/com/materna/buc/cugate/barcode/BarcodeParserTest.java
 create mode 100644 SelfServiceCommon/Massai/java/barcodeParserLib/src/test/resources/log4j.xml

diff --git a/SelfServiceCommon/Massai/java/barcodeParserLib/BCConsole.bat b/SelfServiceCommon/Massai/java/barcodeParserLib/BCConsole.bat
new file mode 100644
index 00000000..ffefcede
--- /dev/null
+++ b/SelfServiceCommon/Massai/java/barcodeParserLib/BCConsole.bat
@@ -0,0 +1,4 @@
+java -cp .;target\barcodeParserLib-1.2.0.1-jar-with-dependencies.jar com.materna.buc.cugate.barcode.BCConsole %1
+echo will open BCConsole.log now... 
+pause
+start BCConsole.log
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/java/barcodeParserLib/BCConsoleTest.bat b/SelfServiceCommon/Massai/java/barcodeParserLib/BCConsoleTest.bat
new file mode 100644
index 00000000..b2a265bc
--- /dev/null
+++ b/SelfServiceCommon/Massai/java/barcodeParserLib/BCConsoleTest.bat
@@ -0,0 +1,2 @@
+java -cp src\test\resources;target\barcodeParserLib-1.2.0.1-jar-with-dependencies.jar com.materna.buc.cugate.barcode.BCConsole "M2MICHAILOPOULOS/XXXXXEKKNYKC TBSATHA3 0983 182C001A0025 35D>5180  7181BA3              2A39024289051830    A3 120423306           Y*30600000K09  A3G    KKNYKC ATHSKGOA 0108 182Y015A0074 3372A39024289051830 A3 A3 120423306           Y09         "
+pause
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/java/barcodeParserLib/ReleaseNotes.txt b/SelfServiceCommon/Massai/java/barcodeParserLib/ReleaseNotes.txt
new file mode 100644
index 00000000..36dfba69
--- /dev/null
+++ b/SelfServiceCommon/Massai/java/barcodeParserLib/ReleaseNotes.txt
@@ -0,0 +1,25 @@
+/*! \mainpage Secure Access
+ *
+ *  @version 1.0.0.03
+ *
+ *  \section change1 Change history
+ *
+ *  \date 20.04.2010 \li V1.0.0.04
+ *                   \li BnS: 04-19/barcodeParserLib/#0014117: NullPointerException beim Parsen kaputter Daten
+ *
+ *  \date 15.04.2010 \li V1.0.0.03
+ *                   \li added single segment barcode type (PtM)
+ *
+ *  \date xx.xx.2010 \li V1.0.0.02
+ *                   \li 1.Calculate BarcodeDate year on base of 6 month in the past.
+ *
+ *  \date xx.xx.2010 \li V1.0.0.01
+ *                   \li 1.PaxState will be set in BarcodeInfo unconverted. As "0" or "1" or "2" etc ...
+ *
+ *  \date 19.01.2010 \li V1.0.0.00
+ *                   \li Initial version (BnS)
+ *
+ *  \date 11.12.2012 \li V1.0.1.0
+  *                   \li E Ticket barcode parser(PeJ)
+ *
+ */
\ No newline at end of file
diff --git a/SelfServiceCommon/Massai/java/barcodeParserLib/pom.xml b/SelfServiceCommon/Massai/java/barcodeParserLib/pom.xml
new file mode 100644
index 00000000..5667499d
--- /dev/null
+++ b/SelfServiceCommon/Massai/java/barcodeParserLib/pom.xml
@@ -0,0 +1,65 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.materna.buc.ips.framework</groupId>
+  <artifactId>barcodeParserLib</artifactId>
+  <packaging>jar</packaging>
+  <name>barcodeParserLib</name>
+  <!-- Please check in dependencies of other modules -->
+  <version>1.2.0.1</version>
+
+  <properties>
+    <!-- Please maintain this module version, since it is used as version information -->
+    <ModuleVersion>1.2.0.1</ModuleVersion>
+  </properties>
+  
+<!-- was used while in Gate-Repository   
+  <parent>
+    <groupId>com.materna.buc.cugate</groupId>
+    <artifactId>java</artifactId>
+    <version>1.0</version>
+  </parent>
+-->
+  
+  <dependencies>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <version>4.7</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>log4j</groupId>
+      <artifactId>log4j</artifactId>
+      <version>1.2.15</version>
+    </dependency>
+  </dependencies> 
+  
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-assembly-plugin</artifactId>
+        <executions>
+          <execution>
+            <id>create-jar</id>
+            <phase>package</phase>
+            <goals>
+              <goal>single</goal>
+            </goals>
+            <configuration>
+              <descriptorRefs>
+                <descriptorRef>jar-with-dependencies</descriptorRef>
+              </descriptorRefs>
+              <archive>
+                <manifest>
+                  <mainClass>com.materna.buc.cugate.barcode.BCConsole</mainClass>
+                </manifest>
+              </archive>
+            </configuration>
+          </execution>
+        </executions>
+			</plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BCConsole.java b/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BCConsole.java
new file mode 100644
index 00000000..c5ca657a
--- /dev/null
+++ b/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BCConsole.java
@@ -0,0 +1,30 @@
+package com.materna.buc.cugate.barcode;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+
+import org.apache.log4j.Logger;
+
+public class BCConsole {
+    private static final Logger LOG = Logger.getLogger(BCConsole.class);
+
+    public static void main(String[] args) throws IOException {
+        String barcodeData = null;
+        if (args.length == 1 && args[0].equals("-i")) {
+            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
+            System.out.println("Enter raw barcode data (without quotes!): ");
+            barcodeData = br.readLine();
+        } else if (args.length != 1) {
+            System.out.println("ERROR: Need barcode data!");
+            System.out.println("Usage: BCConsole [<raw-data>|-i (interactive)]");
+            return;
+        } else {
+            barcodeData = args[0];
+        }
+
+        BCTest bc = new BCTest();
+        bc.parseAndDump(barcodeData);
+        LOG.info("--------------------------------------------------------------------");
+    }
+}
diff --git a/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BCScannerProtocol.java b/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BCScannerProtocol.java
new file mode 100644
index 00000000..88183f77
--- /dev/null
+++ b/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BCScannerProtocol.java
@@ -0,0 +1,97 @@
+package com.materna.buc.cugate.barcode;
+
+import java.util.Vector;
+
+import org.apache.log4j.Logger;
+
+public class BCScannerProtocol {
+
+	private static final Logger log=Logger.getLogger("com.materna.buc.cugate.bpcheck");
+
+    public  BarcodeInfo parseResponse(String in_deviceRsp) {
+
+    	log.debug(">>Parse response "+ in_deviceRsp);
+    	BarcodeInfo info= new BarcodeInfo();
+    	info.setStatus( BCStatus.STATUS_NOK_NOT_BARCODE);
+
+    	//searching for xMx or xSx from begin of barcode - this is the really start
+    	int pos_pax = in_deviceRsp.indexOf("/");
+    	if(pos_pax == -1){
+    		log.error("Cannot find slash in name in barcode");
+    		return info;
+    	}
+    	String dev_prefix_orig =in_deviceRsp.substring(0, pos_pax);
+
+    	int pos_data = -1;
+    	//check for xMx
+    	pos_data =checkFormat("M",  dev_prefix_orig);
+    	if(pos_data == -1){
+    		//check for xSx
+    		pos_data =checkFormat("S",  dev_prefix_orig);
+    	}
+    	if(pos_data == -1 ){
+    		log.error("Cannot xMx or xSx in begin of barcode");
+    		return info;
+    	}
+    	BarcodeParser bcp = new BarcodeParser();
+
+    	log.debug("delete from <"+in_deviceRsp+"> pos "+pos_data);
+    	String barcode = in_deviceRsp.substring(pos_data);
+
+    	info = bcp.parseBC( barcode);
+	    log.debug("<<Parse response, info set "+ info.isInfoSet() +" status "+ info.getStatus());
+	    return info;
+    }
+
+	//BGR format
+	//AR;IERBCRI#6M1PATZER/MICHAEL       5599886LHRDXBAB 2638 075 02A 815   3c#108WWW7008 29123123        2ABCSA 1234567890       20K
+	private boolean checkTrio(String trio){
+		  if(trio.length() !=3){
+			  return false;
+		  }
+    	   char pos_m_vor =trio.charAt(0);
+    	   if(pos_m_vor=='I'){
+    		   return true;
+    	   }
+    	   String c_str =String.valueOf(pos_m_vor);
+    	   try{
+    		 int t = Integer.parseInt(c_str) ;
+    		 if(t>=9){
+    			 return false;
+    		 }
+    		 char pos_m_af =trio.charAt(2);
+    		 String a_str =String.valueOf(pos_m_af);
+    		 int a = Integer.parseInt(a_str) ;
+    		 if(t>=9){
+    			 return false;
+    		 }
+    		 return true;
+
+    	   }catch(Exception e){
+    		  return false;
+    	   }
+	}
+
+	private  int checkFormat(String test,  String dev_prefix_orig){
+		log.debug("Test with "+test+" <"+dev_prefix_orig+">");
+      String dev_prefix = dev_prefix_orig;
+	  Vector <Integer> positions_m =  new Vector<Integer>();
+	  int posM = dev_prefix.indexOf(test);
+      while(posM !=-1 && posM !=0 && posM != dev_prefix.length()-1){
+		 positions_m.add(new Integer(posM));
+		 dev_prefix = dev_prefix.substring(posM);
+		 posM = dev_prefix.indexOf(test);
+	  }
+	  for(int i=0; i<positions_m.size(); i++){
+		int p = positions_m.get(i).intValue();
+		String trio = dev_prefix_orig.substring(p-1, p+2);
+		log.debug("check trio: <"+trio+">");
+		if(checkTrio(trio)){
+			log.debug("Format with "+test+" found ok");
+			return p;
+		}
+	  }
+	  return -1;
+	}
+
+}
diff --git a/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BCStatus.java b/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BCStatus.java
new file mode 100644
index 00000000..25b74e9c
--- /dev/null
+++ b/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BCStatus.java
@@ -0,0 +1,8 @@
+package com.materna.buc.cugate.barcode;
+
+public enum  BCStatus {
+
+	STATUS_OK,	
+	STATUS_NOK,	
+	STATUS_NOK_NOT_BARCODE
+	};
diff --git a/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BCTest.java b/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BCTest.java
new file mode 100644
index 00000000..537336d4
--- /dev/null
+++ b/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BCTest.java
@@ -0,0 +1,398 @@
+package com.materna.buc.cugate.barcode;
+
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.Calendar;
+
+import org.apache.log4j.Logger;
+
+public class BCTest {
+    private static final Logger LOG = Logger.getLogger(BCTest.class);
+
+    /**
+     * @param args
+     */
+    public static void main(String[] args) {
+
+        //		final String res792BC = "M1DEVKROELLA/THOMAS   E       FRATXLLH 8287 023M036K0001 355>2180 O9023BLH              262203000047716  LH                     *30600000005     ";
+        //		final String res792BC = "M1THOEMMES/BERNHARDM EX9KK5E FRAHAMLH 0014079M024E0139 355>2180WO9079BLH              262203940233809  LH                     *30600000005     ";
+        //		final String res792BC = "M1THOEMMES/BERNHARDM  EX9KK5E HAMFRALH 0027 079M022E0022 355>2180WO9079BLH              262203940233809  LH                     *30600000005     ";
+        //		final String res792BC = "M1HUSMANN/MANFREDMR   E5AHYUD MUCTXLLH 0180 079M015H0123 355>2180 O9079BLH              262203591739761  LH LH 992005494836264  *30600000005     ";
+        //		final String res792BC = "M4KULM/STEVEN         YABCDEF NCECDGAF 05143121Y008A135  100BCDEFG CDGATLDL 00005121Y008E24   100CDEFGH ATLYVRAC 02580122Y012A21   100DEFGHI YVRAMSKL 00420122Y007F11   100";
+        final String res792BCv3 = "M2GRANDMARIE/MELANIE  EABC123 GVACDGAF 0123 228C002F0025 12F>300290571234567890                         20KDEF456 CDGDTWNW 0049 228F001A0002 12B29012098765432101                       2PC^1641234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890"; //OK!
+        //		final String res792BCv1	= "M2GRANDMARIE/MELANIE  EABC123 GVACDGAF 0123 228C002F0025 12F>100290571234567890                         20KDEF456 CDGDTWNW 0049 228F001A0002 12B29012098765432101                       2PC";
+
+        //		final String res792BC = "M1AHUMADAGOMEZ/HECTOR EZ3FQDQ LHRJNBSA 0235 211M23A 010  108CKI=SSD;";
+        //		final String ierBC = "AR;IERBCRI#6M1AHUMADAGOMEZ/HECTOR EZ3FQDQ LHRJNBSA 0235 211M23A 010  108CKI=SSD;";
+        final String bpcheck_witho = "M1AHUMADAGOMEZ/HECTOR EZ3FQDQ LHRJNBSA 0235 211M23A 010  108CKI=SSD;"; //OK, on place of conditional - variable airline use
+        final String bpcheck_with = "IERBCRI#6M1PATZER/MICHAEL       5599886LHRDXBAB 2638 075 02A 815   3c#108WWW7008 29123123        2ABCSA 1234567890       20K";//OK, materna false format
+        final String without_cond = "M1VANDERZON/PETER     EABC123 AMSGVAKL 1925 228Y002A0003 100";
+        final String half_cond = "M1GRANDMAIRE/MELANIE  EABC123 GVACDGAF 0123 228C002F0025 11D>2081WW6225B0F0571234567890 0";
+        final String mpatzer = "_J_BCRI#6M1PATZER/MICHAEL       5599886LHRDXBAB 2638 075 02A 815   3c#108WWW7008 29123123        2ABCSA 1234567890       20K.";
+        final String mfalsch = "_J_BCRI#6M1Thurtle/Jasmine     ED5A6DW DXBDOHEK 0845 123Y18K 015  137>1  2WW7123B                1                          .";
+        final String tetet = "AR;IERBCRI#6M1PATZER/MICHAEL       5599886LHRDXBAB 2638 075Y02A 815   3c#108WWW7008 29123123        2ABCSA 1234567890       20K ";
+
+        final String short_p = "M1PATZER/MICHAEL       5599886LHRDXBAB 2638 360Y02A 815   3c#108WWW7008 29123123        2ABCSA 1234567890       20K";
+        final String materna_false = "M1JHFBRUSH/LPEINSA M  ET04915 FRAHAMLH 1964 106M052K0011 355>2180WO0106BLH 262203000003158 LH LH 992004873990289 *30600";
+        final String materna_ok = "M1JHFBRUSH/LPEINSA M  ET04915 FRAHAMLH 1964 106M052K0011 33B>2180WO0106BLH 26220300000311C LH LH 992004873990289 *30600";
+
+        final String martin1 = "M1DESMARAIS/LUC       EABC123 YULFRAAC 0834 226F001A0025 161>2181WW6225BAC 7125123456003290141234567890 1AC AC 1234567890123    2PC*30602018K0900ACSWCHRLX58Z";
+        final String martin2 = "M1QAKROELLD/THOMAS M  ET05617 FRATXLLH 4017 077M035A0002 355>2180KO1077BLH              262203000004637  LH                     *30600000005";
+        final String martin3 = "M1JANEZIC/MATTHIASMR  E3LS7W9 FRAZRHLH 1182 082M012D0044 355>2180KO1082BLH              262205113492751  LH LH 992003019206949  *30600000005";
+        final String Martin4 = "M1JANEZIC/MATTHIASMR  E3LS7W9 FRAZRHLH 1182 082M         355>2180      I                262205113492751  LH LH 992003019206949  *30600000005     ";
+        final String Martin5 = "M2ELVING/S                    OSLFRALH 3135 254C007A0084 326>10B0OO9254BSK 00*2060 K   02201111074       FRANCELH 4142 254C005A0073 30C0002 073    ";
+        //final String res792BCv1	=   "M2DESMARAIS/LUC       EABC123 YULFRAAC 0843 226F001A0025 13F>10B1WW6225BAC 290141234567890 1AC AC 1234567890123    20KLX58ZDEF456 FRAGVALH 3664 227C012C0002 12D290140987654321 1AC AC 1234567890123    2PCWQ";  //OK!
+        final String Volker5 = "M2DOMONTO/A MR        E       FRAMUCLH 1600 077M072A0013 14C>3181WW1077BLH              292202351765018 1LH LH                  20K       MUCHAMLH 1767 077M008A0002 12D292202351765018 1LH LH                  2PCWQ^164";
+        final String Sven1 = "M1OLMESDAHL/ERNIE      5509120JNBDXB UU 0342139  01A5234  3c#108WWW7008 29123123        2ABCSA 1234567890       20K";
+        final String short_p2 = "M1PATZER/MICHAEL       5599886LHRDXBAB 2638 360Y02A 815   3c#108WWW7008 29123123        2ABCSA 1234567890       20K";
+        final String Sven2 = "WJNBCPTBA60212HY 141K01A BA6SCHWARZENEGGER/HEIDI            W                                                           WJNBCPTBA60212HY 141K01A BA6";
+        final String ABBug = "M1OLMESDAHL/ERNIE      5509120JNBDXB UU 0342139  01A5234  02FL";
+        //final String Michaeltest   ="M1De Bruin/Johann    EPCGZTM PLZJNBT6 522  275E11B 00000100^eccfb811-562a-4ba3-bee3-f64978d7d286";
+
+        final String Michaeltest1 = "M1De Bruin/Johann     EPCGZTM PLZJNBT6 522  275E11B 00000100^eccfb811-562a-4ba3-bee3-f64978d7d286";
+        final String singleType = "SPEAKE/FRANCESMS     C0ZR51              JNB        LHRVS 602  096Y   39H 131                      JNBLH                       ";
+        final String singleType1 = "SPEAKE/FRANCESMS     C0ZR51              JNB        LHRVS 602  096Y   39H 131                      JNBLH                     1XXX";
+        final String MichaeltestS = "SBAIRD LINDAANN                          JNBQA      SINSQ 479  262Y   53J 0019  3                  JNBSINSQ8092798375        1";
+
+        final String Michaeltest = "M1De Bruin/Johann    EPCGZTM PLZJNBT6 522  275E11B 00000100^eccfb811-562a-4ba3-bee3-f64978d7d286";
+
+        final String tets = "M1HOVSEPYAN/SMBATMR   EJWBAJQ ZRHVLCLX 2142 285Y000A0000 03A>10B0      ILX 297242125649458 0LX LX                  1PC ";
+        final String cussNOK = "M1QAKROELLD/THOMAS M  ET05617 FRATXLLH 4017 077M035A0002 355>2180KO1077BLH              262203000004637  LH                     *30600000005";
+        final String cussOK = "M1QAKROELLD/THOMAS M  ET05617 FRATXLLH 4017 077M035A0002 355>2180KO1077BLH              262203000004637  LH                     *30600000005     ";
+        final String miniBar2 = "M1MUSTERMANN/MAX MR   E220    FRAHAMLH 24   119C19A 1    300";
+        final String sven2 = "M1BOOKING/EASYJET     EEGZM4NW                            00#";
+        final String Sven3 = "M1KRAPOHL/ANJA        EU9FNSW DUSHERX3 4104 182Y007D0035 30B0351B67007D";
+        final String res792BCv1 = "M2DESMARAIS/LUC       EABC123 YULFRAAC 0843 226F001A0025 13F>10B1WW6225BAC 290141234567890 1AC AC 1234567890123    20KLX58ZDEF456 FRAGVALH 3664 227C012C0002 12D290140987654321 1AC AC 1234567890123    2PCWQ"; //OK!
+        final String ThomasS = "M2DOMONTO/A MR        E       FRAMUCLH 1600 077M072A0013 14C>3181WW1077BLH              292202351765018 1LH LH                  20K       MUCHAMLH 1767 077M008A0002 12D292202351765018 1LH LH                  2PCWQ^164";
+
+        final String nnn = "M1                     S44WPF KWIDXBJ9 0164 350           00";
+        //extra case s1 AS  MULTIPLE TYPE
+        final String multipleS1 = "S1ROSHAN/RAKESH       ED67FSZ KWIDXBJ9 1036 192Y014F0001 114>10B6  2191BJ9 03486";
+        final String ThomasS2 = "M2DOMONTO/A MR        E       FRAMUCLH 1600 077M072A0013 14C>3181WW1077BLH              292202351765018 1LH LH                  20K            MUCHAMLH 1767 077M008A0002 12D292202351765018 1LH LH                  2PCWQ^164";
+        final String unklar = "M1RAATH/JESSICA CATHEREMAAHXC JNBDURMN 0603 249P000	'0037 100";
+        final String unklar2 = "M1RAATH/JESSICA CATHEREMAAHXC JNBDURMN 0603 249P0000003ü 000";
+        final String abaused = "M1TREBESIUS/SIMON     EZD33IC HAMDUSAB 6753 278Y018C0045 320>2080      B0E             0FLY ";
+        final String abaused2 = "M1BREHM/CHRISTIAN     E3ZPPMV TXLNUEAB 6417 278 014F0033 108>10000FL";
+        final String abaused3 = "M1PARK/HISUNG DR              TXLCGNAB 6505 279Y07A 019   08>30000FL";
+        final String abaused4 = "M1TIETJE/CARINA       EZCXGJB TXLSTRAB 6539 279Y006A0007 337>2080      B25                  AB 103051010       FLB ";
+        final String abaused5 = "M1BREHM/CHRISTIAN     E3ZPPMV TXLNUEAB 6417 278 014F0033 108>10000FL";
+        final String abaused6 = "M1TREBESIUS/SIMON     EZD33IC HAMDUSAB 6753 278Y018C0045 320>2080      B0E             0FLY";
+
+        final String abausedWithou = "M1TREBESIUS/SIMON     EZD33IC HAMDUSAB 6753 278Y018C0045 320>2080      B0E             0FLY";
+        final String abcHam = "M1BREHM/CHRISTIAN     E3ZPPMV HAMMUCLH 2073 100 014F0033 108>10000FL";
+        final String ttttu = "M1TREBESIUS/SIMON     EZD33IC HAMDUSAB 675  278Y018C0045 100";
+        final String eTicket = "E                                           60321000032210201";
+        final String sven_eTicket = "E                                           60326439099890201                      60326439099890201";
+
+        final String abaused33 = "M1TREBESIUS/SIMON     EZD33IC HAMDUSAB 6753 278Y018C0045 320>2080      B0E             0FLY ";
+        final String sen_ab = "M1SOHAIL/IR/          E C4CPRDDUSBHXBE 7046 317Y9A  40";
+        final String sen_abOk = "M1SOHAIL/IR/          E C4CPRDDUSBHXBE 7046 317Y9A  40   100";
+        final String sen2 = "M1POTTER/DA/          EC4G2D2 DUSBHXBE 7048 317Y2D  51   100";
+
+        final String atest = "M1BEER/ULRICHMR       EFUEH64 HAMZRHLX 1051 318C001D0065 355>2180 O3318BLH 0220396121001267242131166262  LX LH 222015354416794 X*30601000805  LHG";
+        final String matip = "M1APPLE/DARLENA        2K7FEQ ORKLHREI 7992 041Y008C0001 100";
+        final String matip2 = "M1APPLE/DARLENA        2K7FEQ ORKLHREI 7992 044Y008C0001 100";
+        final String matip3 = "M1CHERRIES/ANDRIA      29VAM3 ORKLHREI 7992 055Y014D0008 100";
+        final String svenSecurity = "M1LANGE/ULRICHMR      EGEN9ST DUSATLDL 0025 264Y17E 0023 10FDL3JCYIOYH517EN4cMDUCGQDn3e+MugUYIK7iQkOAPshhJcuIJKhFYgACGCwgpIEuT14dWyMAZO+NSUr4O2WK9OVYGw==";
+        final String gg = "M1TOTA GRZEGORZ               VNOKBPPS 0182  65S012A0012  00";
+
+        final String my = "M1MAXIMOVA/EKATERINA  EPLGXH  VNODME   UN254088T023A0039 100";
+
+        final String validt = "M1TREBESIUS/SIMON     EZD33IC HAMDUSAB 6753 278Y018C0045 320>2080      B0E             0FLY ";
+        final String mys = "M1JOHANNES/NAEEMMR     ZYGIN3 JNBCPTBA 6441 057M018D0071 13B>30B1WM6056BBA 29                                         8";
+        final String noch = "M1CHENG/WEIYANG MS    EKRFRJT ATHSVOSU 2111 037Q027B0056 146>5181WK7037BSU              2A5551078275763  SU                         ";
+        final String fastTrack = "M1FOX/SIX             E3499TY ATHCDGA3 9614 047C003A0006 35D>5180  7047BA3              2A39024263326170 A3                        Y*30600000K09         ";
+        final String fastTrack3 = "M1GOLF/SEVEN          E35AB77 ATHCDGA3 9614 047Y012B0008 35D>5180  7047BA3              2A39024263326210 A3                        N*30600000K09         ";
+        final String fastTrack2 = "M2NEAMO/MARIE         E3NJY3H ATHSKGA3 9125 044C003C0002 35D>5180  7044BA3              2A39024263325990 A3                        Y*30600000K09         3NJY3H SKGCDGA3 9126 044C003C0002 3372A39024263325990 A3                        Y09         ";
+        final String myTest = "M1TREBESIUS/LIMON     EZD33IC DTMHAMTK 1554 278Y018C0045 320>2080      B0E             0FLY ";
+        final String myTestZ = "M1DALAKOURAS/GEORGIOS EJHB389 ATHGVALX 1823 146Y008F0011 15C>5180 W7145BLX              3F72411671119460    A3 107450103           Y*30600000K09  A3G    ";
+        final String mmm = "M1DALAKOURAS/GEORGIOS EJHB389 ATHGVALX 1823 146Y008F0011 15C>5180 W7145BLX              3F72411671119460    A3 107450103           Y*30600000K09  A3G    ";
+        final String mSven = "M1DALAKOURAS/GEORGIOS EJHB389 ATHGVALX 1823 146Y008F0011 15C>5180 W7145BLX              3F72411671119460    A3 107450103          Y*30600000K09  A3G    ";
+        final String fastTrack22 = "M2MICHAILOPOULOS/XXXXXEKKNYKC TBSATHA3 0983 182C001A0025 35D>5180  7181BA3              2A39024289051830    A3 120423306           Y*30600000K09  A3G    KKNYKC ATHSKGOA 0108 182Y015A0074 3372A39024289051830 A3 A3 120423306           Y09         ";
+
+        BCTest bct = new BCTest();
+        bct.parseAndDump(fastTrack22);
+    }
+
+    public void parseAndDump(String barcodeString) {
+        BarcodeInfo bci;
+        BarcodeParser bcp = new BarcodeParser();
+
+        LOG.info("Raw barcode data: '" + barcodeString + "'");
+        bci = bcp.parseBC(barcodeString);
+
+        if (bci.getStatus() != BCStatus.STATUS_OK) {
+            LOG.info("ERROR: Parsing failed (status=" + bci.getStatus() + ")!");
+            return;
+        }
+        LOG.info("OK: Parsing successful");
+        if (bci.getType() == BCType.E_TICKET) {
+            LOG.info("E-Ticket read. ETI: " + bci.getE_TicketNumber() + " conjunctionNumber: " + bci.getConjuctionNumber());
+            return;
+
+        }
+        if (bci.getWarning() == BCWarning.WARN_NOT_SET) {
+            LOG.info("OK: No warnings");
+        }
+        if (bci.getWarning() == BCWarning.WARN_SECOND_SEGMENT_NOK) {
+            LOG.info("WARNING: Second Segment NOK");
+        }
+        if (bci.getWarning() == BCWarning.WARN_CONDITIONAL_PART_NOK) {
+            LOG.info("WARNING: Conditional part NOK");
+        }
+        if (bci.getWarning() == BCWarning.WARN_SYNTAX_NOK) {
+            LOG.info("WARNING: Syntax NOK: " + bci.getErrorDetails());
+        }
+
+        LOG.info("Parsed barcode data:");
+        LOG.info("Mandatory items:");
+        printElementNoFormat("Item", "Element Description", "Value");
+        printElement("1", "Format code", bci.getFormatCode());
+        printElement("5", "Number of Legs Encoded", bci.getNumbLegs());
+        printElement("11", "Passenger Name (first)", bci.getFirstName());
+        printElement("11", "Passenger Name (last)", bci.getLastName());
+        printElement("253", "Electronic ticket indicator", bci.getETI());
+        printElement("9", "Version number", String.valueOf(bci.getVersionNumber()), true, resolveVersionNumber(bci.getVersionNumber()));
+        DateFormat df = new SimpleDateFormat("dd.MM.yyyy");
+        if (bci.getConditional() != null) {
+            LOG.info("Conditional items:");
+            printElement("15", "Passenger description", bci.getConditional().getPassengerDesc(), true, resolvePassengerDescription(bci.getConditional().getPassengerDesc()));
+            printElement("12", "Source of check-in", bci.getConditional().getSrcChekin(), true, resolveSourceOfCheck(bci.getConditional().getSrcChekin()));
+            printElement("14", "Source of boarding pass issuance:", bci.getConditional().getSrcBoardPass(), true, resolveSourceOfBoardingPassIssuance(bci.getConditional().getSrcBoardPass()));
+            Calendar cal = Calendar.getInstance();
+            if (bci.getConditional().getBoardPassIssueDate() != null) {
+                cal.setTime(bci.getConditional().getBoardPassIssueDate());
+                printElement("22", "Date of issue of BP (parsed)",
+                        "year: " + cal.get(Calendar.YEAR) + ", day: " + cal.get(Calendar.DAY_OF_YEAR), false);
+                printElement("22", "Date of issue of BP (formatted)", df.format((cal.getTime())));
+            } else {
+                printElement("22", "Date of issue", null);
+            }
+            printElement("16", "Document type:", bci.getConditional().getDocType(), true, resolveDocType(bci.getConditional().getDocType()));
+            printElement("21", "Airline designator", bci.getConditional().getAirlineDesignatorBpIssuer());
+            printElement("23", "Baggage Tag Licence Plate Number", bci.getConditional().getBaggageTagLicencePlateNumber());
+            printElement("31", "First NCB Licence Plate Number", bci.getConditional().getFirstNonConsecutiveBagTagLicencePlateNumber());
+            printElement("32", "Second NCB Licence Plate Number", bci.getConditional().getSecondNonConsecutiveBagTagLicencePlateNumber());
+        }
+        LOG.info("Number of segments: " + bci.getSegments().size());
+        for (int i = 0; i < bci.getSegments().size(); i++) {
+            BarcodeSegment bc = bci.getSegments().get(i);
+            LOG.info("Segment #" + (i + 1) + ":");
+            LOG.info("Mandatory segment data (segment " + (i + 1) + "):");
+            printElement("7", "Operating carrier PNR Code", bc.getPnr());
+            printElement("26", "From City Airport Code", bc.getOrigin());
+            printElement("38", "To City Airport Code", bc.getDestination());
+            printElement("42", "Operating carrier designator", bc.getAirlineCode());
+            printElement("43", "Flight number", bc.getFlightNumber());
+            printElement("46", "Date of flight (formatted)", df.format(bc.getFlightDate()));
+            printElement("71", "Compartment code", bc.getCompartmentCode());
+            printElement("104", "Seat", bc.getSeat());
+            printElement("107", "Check-In Sequence Number", bc.getBoardingNumber());
+            printElement("113", "Passenger Status", bc.getPaxStatus(), true, resolvePassengerStatus(bc.getPaxStatus()));
+            LOG.info("Conditional segment data (segment " + (i + 1) + "):");
+            printElement("142", "Airline numeric code", bc.getAirlineNumericCode());
+            printElement("143", "Document Form/Serial Number", bc.getDocSerialNumber());
+            printElement("18", "Selectee indicator", bc.getSelecteeInd(), true, resolveSelecteeIndicator(bc.getSelecteeInd()));
+            printElement("108", "International document verification", bc.getIntDocVer());
+            printElement("19", "Marketing carrier designator", bc.getMrkCarrierDesignator());
+            printElement("20", "Frequent flyer airline designator", bc.getFrqntFlyerArlDesignator());
+            printElement("236", "Frequent flyer number", bc.getFrqntFlyerNumber());
+            printElement("89", "ID/AD Indicator", bc.getID_AD_Ind());
+            printElement("118", "Free baggage allowance", bc.getFreeBaggageAllowance());
+            printElement("254", "Fast Track", bc.getFastTrack(), true, resolveFastTrack(bc.getFastTrack()));
+            printElement("4", "Airline used", bc.getAirlineUsed());
+        }
+        if (bci.getSecurity() != null) {
+            LOG.info("Security data:");
+            printElement("28", "Type of Security Data", bci.getSecurity().getType());
+            printElement("30", "Security data", bci.getSecurity().getSecurityStr());
+        }
+    }
+
+    private String resolveFastTrack(String fastTrack) {
+        if(fastTrack == null || fastTrack.length() == 0) {
+            return null;
+        }
+        if(fastTrack.equals("Y")) {
+            return "yes";
+        }
+        if(fastTrack.equals("N")) {
+            return "no fast track";
+        }
+        return "ERROR: unknown (check implementation)!";
+    }
+
+    private String resolveSelecteeIndicator(String selecteeInd) {
+        if(selecteeInd == null || selecteeInd.length() == 0) {
+            return null;
+        }
+        if(selecteeInd.equals("0")) {
+            return "not selectee";
+        }
+        if(selecteeInd.equals("1")) {
+            return "selectee";
+        }
+        return "ERROR: unknown (check implementation)!";
+    }
+
+    private String resolveDocType(String docType) {
+        if(docType == null || docType.length() == 0) {
+            return null;
+        }
+        if(docType.equals("B")) {
+            return "boarding pass";
+        }
+        if(docType.equals("I")) {
+            return "itinerary receipt";
+        }
+        return "ERROR: unknown (check implementation)!";
+    }
+
+    private String resolveSourceOfCheck(String source) {
+        if(source == null || source.length() == 0) {
+            return null;
+        }
+        if(source.equals("W")) {
+            return "web";
+        }
+        if(source.equals("K")) {
+            return "airport kiosk";
+        }
+        if(source.equals("R")) {
+            return "remote or off-site kiosk";
+        }
+        if(source.equals("M")) {
+            return "mobile device";
+        }
+        if(source.equals("O")) {
+            return "airport agent";
+        }
+        if(source.equals("T")) {
+            return "town agent";
+        }
+        if(source.equals("V")) {
+            return "third party vendor";
+        }
+        return "ERROR: unknown (check implementation)!";
+    }
+
+    private String resolveSourceOfBoardingPassIssuance(String source) {
+        if(source == null || source.length() == 0) {
+            return null;
+        }
+        if(source.equals("W")) {
+            return "web printed";
+        }
+        if(source.equals("K")) {
+            return "airport kiosk printed";
+        }
+        if(source.equals("R")) {
+            return "remote or off-site kiosk";
+        }
+        if(source.equals("X")) {
+            return "transfer kiosk printed";
+        }
+        if(source.equals("M")) {
+            return "mobile device printed";
+        }
+        if(source.equals("O")) {
+            return "airport agent printed";
+        }
+        if(source.equals("T")) {
+            return "town agent printed";
+        }
+        if(source.equals("V")) {
+            return "third party vendor printed";
+        }
+        return "ERROR: unknown (check implementation)!";
+    }
+    
+    private String resolvePassengerDescription(String paxDesc) {
+        if(paxDesc == null || paxDesc.length() == 0) {
+            return null;
+        }
+        if(paxDesc.equals("0")) {
+            return "adult";
+        }
+        else if(paxDesc.equals("6")) {
+            return "adult with infant";
+        }
+        else if(paxDesc.equals("4")) {
+            return "infant";
+        }
+        return "ERROR: unknown (check implementation)!";
+    }
+
+    private String resolveVersionNumber(int version) {
+        switch(version) {
+        case 2:
+            return "standard 2008";
+        case 3:
+            return "standard 2009";
+        case 4:
+            return "standard 2011";
+        case 5:
+            return "standard 2013";
+        case 6:
+            return "standard 2016";
+        }
+        return "ERROR: unknown (check implementation)!";
+    }
+    
+    private String resolvePassengerStatus(String paxStatus) {
+        if(paxStatus == null || paxStatus.length() == 0) {
+            return null;
+        }
+        if(paxStatus.equals("0")) {
+            return "ticket issuance/passenger not checked in";
+        }
+        else if(paxStatus.equals("1")) {
+            return "ticket issuance/passenger checked in";
+        }
+        else if(paxStatus.equals("2")) {
+            return "baggage checked - passenger not checked in";
+        }
+        else if(paxStatus.equals("3")) {
+            return "baggage checked - passenger checked in";
+        }
+        else if(paxStatus.equals("4")) {
+            return "passenger passed security check";
+        }
+        else if(paxStatus.equals("5")) {
+            return "passenger passed gate exit (coupon used)";
+        }
+        else if(paxStatus.equals("6")) {
+            return "transit";
+        }
+        else if(paxStatus.equals("7")) {
+            return "standby";
+        }
+        else if(paxStatus.equals("8")) {
+            return "boarding data revalidated done";
+        }
+        else if(paxStatus.equals("9")) {
+            return "original boarding line used at time of ticket inssuance";
+        }
+        return "ERROR: unknown (check implementation)!";
+    }
+    
+    private static void printElement(String element, String description, String value) {
+        printElement(element, description, value, true);
+    }
+
+    private static void printElementNoFormat(String element, String description, String value) {
+        printElement(element, description, value, false);
+    }
+
+    private static void printElement(String element, String description, String value, boolean format) {
+        printElement(element, description, value, format, null);
+    }
+    
+    private static void printElement(String element, String description, String value, boolean format, String resolved) {
+        if (format) {
+            LOG.info(String.format("%4s %-36s: %s %s", element, description, (value != null && value.length() > 0) ? "'" + value + "'" : "-", (resolved != null ? "(" + resolved + ")": "")));
+        } else {
+            LOG.info(String.format("%4s %-36s: %s %s", element, description, (value != null && value.length() > 0) ? value : "-", (resolved != null ? "(" + resolved + ")": "")));
+        }
+    }
+}
diff --git a/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BCType.java b/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BCType.java
new file mode 100644
index 00000000..495f0c1c
--- /dev/null
+++ b/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BCType.java
@@ -0,0 +1,6 @@
+package com.materna.buc.cugate.barcode;
+
+public enum BCType {
+    BARCODE,
+    E_TICKET
+}
diff --git a/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BCWarning.java b/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BCWarning.java
new file mode 100644
index 00000000..c808f6c6
--- /dev/null
+++ b/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BCWarning.java
@@ -0,0 +1,8 @@
+package com.materna.buc.cugate.barcode;
+
+public enum BCWarning {
+	WARN_NOT_SET,	// no warning, default
+	WARN_CONDITIONAL_PART_NOK,	//cannot read conditional part
+	WARN_SECOND_SEGMENT_NOK,  // in second segment error, no second and father segments  set
+	WARN_SYNTAX_NOK  // Syntax  not conform with spec. See ErrorDetails
+}
diff --git a/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BarcodeInfo.java b/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BarcodeInfo.java
new file mode 100644
index 00000000..31e5a6b0
--- /dev/null
+++ b/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BarcodeInfo.java
@@ -0,0 +1,223 @@
+package com.materna.buc.cugate.barcode;
+
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.Vector;
+
+public class BarcodeInfo {
+  BCType type =BCType.BARCODE;
+  public String firstName;
+  String lastName;
+  String ETI;
+  String formatCode;
+  String numbLegs;
+  int versionNumber = 1;
+  Vector<BarcodeSegment> segments = new Vector<BarcodeSegment>();
+  ConditionalBCPart conditional = null;
+  Security security = null;
+  public BCStatus status = BCStatus.STATUS_OK;
+  public BCWarning warning =BCWarning.WARN_NOT_SET;
+  public String errorDetails= null;
+  public DateFormat commonDF = new SimpleDateFormat("yyyy.MM.dd");
+  //set  only if type BCType.E_TICKET
+  public Integer conjuctionNumber = null;
+  public String e_TicketNumber = null;
+
+  public int getVersionNumber() {
+    return versionNumber;
+  }
+
+  public void setVersionNumber(int versionNumber) {
+    this.versionNumber = versionNumber;
+  }
+
+  public String getFirstName() {
+    return firstName;
+  }
+
+  public void setFirstName(String userName) {
+    this.firstName = userName.trim();
+  }
+
+  public String getLastName() {
+    return lastName;
+  }
+
+  public void setLastName(String lastName) {
+    this.lastName = lastName.trim();
+  }
+
+  public String getETI() {
+    return ETI;
+  }
+
+  public void setETI(String eti) {
+    ETI = eti;
+  }
+
+  public Vector<BarcodeSegment> getSegments() {
+    return segments;
+  }
+
+  public void setSegments(Vector<BarcodeSegment> segments) {
+    this.segments = segments;
+  }
+
+  public String toString() {
+    String ret = "------------------------------\r\n";
+    ret += "PASSENGER: ";
+    ret += getFirstName();
+    ret += " ";
+    ret += getLastName();
+    ret += "\r\n";
+    if (this.conditional != null) {
+      ret += "\r\nCONDITIONAL: ";
+      ret += "\r\nAirline Designator BP Issuer: ";
+      ret += this.conditional.airlineDesignatorBpIssuer;
+      ret += "\r\nBaggage Tag Licence Plate Number: ";
+      ret += this.conditional.baggageTagLicencePlateNumber;
+      ret += "\r\nDoc Type: ";
+      ret += this.conditional.docType;
+      ret += "\r\nPassenger Description: ";
+      ret += this.conditional.passengerDesc;
+      ret += "\r\nSrc BoardingPass: ";
+      ret += this.conditional.getSrcBoardPass();
+      ret += "\r\nSrc CheckIn: ";
+      ret += this.conditional.getSrcChekin();
+      if (this.conditional.boardPassIssueDate != null) {
+        ret += "\r\nSrc CheckIn:  ";
+        ret += commonDF.format(this.conditional.boardPassIssueDate);
+      }
+    }
+    if (this.getSegments().size() != 0) {
+      for (int i = 0; i < this.getSegments().size(); i++) {
+        ret += "\r\nFLIGHT DATA: ";
+        if (getSegments().get(i) != null) {
+          ret += "\r\nPNR: ";
+          ret += this.getSegments().get(i).getPnr();
+          ret += "\r\nCOMPARTMENT CODE: ";
+          ret += this.getSegments().get(i).getCompartmentCode();
+          ret += "\r\nFLIGHT Number: ";
+          ret += this.getSegments().get(i).getFlightNumber();
+          ret += "\r\nAIRLINE : ";
+          ret += this.getSegments().get(i).getAirlineCode();
+          ret += "\r\nFROM: ";
+          ret += this.getSegments().get(i).getOrigin();
+          ret += "\r\nTO: ";
+          ret += this.getSegments().get(i).getDestination();
+          if (this.getSegments().get(i).getFlightDate() != null) {
+            ret += "\r\nDATE:  ";
+            ret += BarcodeSegment.formatDate(this.getSegments().get(i).getFlightDate());
+          }
+          ret += "\r\nBOARDING Number: ";
+          ret += this.getSegments().get(i).getBoardingNumber();
+          ret += "\r\n SEAT: ";
+          ret += this.getSegments().get(i).getSeat();
+          ret += "\r\n STATUS: ";
+          ret += this.getSegments().get(i).getPaxStatus();
+          ret += "\r\n----------------------------\r\n";
+        } else {
+          ret = "BarcodeInfo is corrupt";
+        }
+      }
+    } else {
+      ret = "BarcodeInfo not set";
+    }
+    return ret;
+  }
+
+  public ConditionalBCPart getConditional() {
+    return conditional;
+  }
+
+  public void setConditional(ConditionalBCPart conditional) {
+    this.conditional = conditional;
+  }
+
+  public BCStatus getStatus() {
+    return status;
+  }
+
+  public void setStatus(BCStatus status) {
+    this.status = status;
+  }
+
+  public boolean isInfoSet() {
+    if ((firstName != null && firstName.length() != 0) || (lastName != null && lastName.length() != 0)) {
+      return true;
+    }
+    return false;
+  }
+
+  public Security getSecurity() {
+    return security;
+  }
+
+  public void setSecurity(Security security) {
+    this.security = security;
+  }
+
+  public String getFormatCode() {
+    return formatCode;
+  }
+
+  public void setFormatCode(String formatCode) {
+    this.formatCode = formatCode;
+  }
+
+  public String getNumbLegs() {
+    return numbLegs;
+  }
+
+  public void setNumbLegs(String numbLegs) {
+    this.numbLegs = numbLegs;
+  }
+
+public BCWarning getWarning() {
+	return warning;
+}
+
+public void setWarning(BCWarning warning) {
+	this.warning = warning;
+}
+
+public String getErrorDetails() {
+	return errorDetails;
+}
+
+public void setErrorDetails(String errorDetails) {
+	if(this.errorDetails!= null){
+		this.errorDetails+="; ";
+		this.errorDetails+=errorDetails;
+	}else{
+	  this.errorDetails = errorDetails;
+	}
+}
+
+public BCType getType() {
+	return type;
+}
+
+public void setType(BCType type) {
+	this.type = type;
+}
+
+public Integer getConjuctionNumber() {
+	return conjuctionNumber;
+}
+
+public void setConjuctionNumber(Integer conjuctionNumber) {
+	this.conjuctionNumber = conjuctionNumber;
+}
+
+public String getE_TicketNumber() {
+	return e_TicketNumber;
+}
+
+public void setE_TicketNumber(String e_TicketNumber) {
+	this.e_TicketNumber = e_TicketNumber;
+}
+
+
+
+}
diff --git a/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BarcodeParser.java b/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BarcodeParser.java
new file mode 100644
index 00000000..8ac61977
--- /dev/null
+++ b/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BarcodeParser.java
@@ -0,0 +1,977 @@
+package com.materna.buc.cugate.barcode;
+
+import java.text.SimpleDateFormat;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import org.apache.log4j.Logger;
+
+public class BarcodeParser {
+	private static final int segmentStaticLen = 37;
+	private static final Logger log = Logger.getLogger(BarcodeParser.class);
+	private Pattern header_pattern = null;
+	private Pattern segment_stat_pattern = null; //for segment static part
+	private Pattern singleSegmentTypeBarcodeMatcher = null;
+	Calendar yearCalendar = null;
+	
+	 Pattern eTicketeMatcher = null;
+	
+
+	private Pattern versionSizePattern=null;
+
+	public BarcodeParser()
+	{
+		header_pattern = Pattern.compile("(.)(.)(.{20})(.)");
+		segment_stat_pattern = Pattern
+				.compile("(.{7})(.{3})(.{3})(.{3})(.{5})(.{3})(.)(.{4})(.{5})(.)");
+		versionSizePattern=Pattern.compile("(.)(.)(.{2})");
+
+		singleSegmentTypeBarcodeMatcher = Pattern.compile("(.)(.{20})(.{7})(.{3})(.)(.{4})(.{4})(.)(.{3})(.{8})(.{3})(.{3})(.{5})(.{3})(.)(.{2})(.)(.{4})(.{5})(.)(.)(.{3})(.)(.{3})(.{10})(.)(.{3})(.{3})(.{16})(.{4})(.)");
+        
+		eTicketeMatcher = Pattern.compile("(.{44})(.{13})(.{2})(.{2})");	
+
+	}
+
+  public void setExternalYear(Calendar cY){
+	  yearCalendar=cY;
+  }
+	public BarcodeInfo parseBC(String in_barcode)
+	{
+		
+		if(in_barcode.length()>1 && in_barcode.charAt(0)=='E'){
+			//parse as E-Ticket Mantis 25320
+			return parseETicket(in_barcode);
+		}
+		//patch to ModuleVersion 1.0.0.21
+		if (in_barcode.length()>1 && (in_barcode.charAt(0)=='S' && !Character.isDigit(in_barcode.charAt(1))))
+			return parseSingleSegementTypeBarcode(in_barcode);
+		else
+			return parseMultipleSegmentTypeBarcode(in_barcode);
+	}
+	
+	private BarcodeInfo parseETicket(String in_barcode){
+		log.debug("work with BARCODE <" + in_barcode + ">");
+		BarcodeInfo info = new BarcodeInfo();
+		info.setStatus(BCStatus.STATUS_NOK);
+		info.setType(BCType.E_TICKET);
+		//Ticket-Nummer durch extrahieren von Zeichen 45-57 holen (-> als eTicketNumber/String extrahieren), hier "6032100003221"
+		//Dann muss "02" folgen.
+		// Dann müssen 2 Zeichen folgen (-> als conjunctionNumber,int extrahieren), hier 1.
+
+        if(in_barcode == null || in_barcode.length()<61){
+        	log.error("E Ticket length  less as 61 chars");
+        	 info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+			 info.setErrorDetails("E Ticket length too short");
+			 return info;
+        }
+        if(in_barcode.length()>61){
+        	log.error("E Ticket length  more as 61 chars");
+       	    info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+       	    in_barcode = in_barcode.substring(0, 61);
+        }
+        Matcher matcher= eTicketeMatcher.matcher(in_barcode);
+		boolean matched = false;		
+		matched = matcher.matches();
+		 if (!matched) {
+				log.error("Cannot parse E Ticket");
+				 info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+				 info.setErrorDetails(" E Ticket syntax NOK");
+				 return info;
+		  } else {				
+				String eti = matcher.group(2).trim();
+				String trenn = matcher.group(3).trim();
+				if(!trenn.equalsIgnoreCase("02")){
+					log.error("Cannot parse E Ticket, separator not 02");
+					 info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+					 info.setErrorDetails(" E Ticket syntax NOK");
+					 return info;
+				}
+				String conj = matcher.group(4).trim();
+				Integer cN = null;
+				try {
+					cN = Integer.valueOf(conj);
+				} catch (Exception e) {
+					log.error("Cannot parse E Ticket, conjuction number not integer");
+					 info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+					 info.setErrorDetails("conjuction number not integer");
+					 return info;
+				}
+				info.setE_TicketNumber(eti);
+				info.setConjuctionNumber(cN);
+				info.setStatus(BCStatus.STATUS_OK);
+		  }		
+		return info;
+	}
+
+
+	/*
+	 * Barcode =
+	 * "M1AHUMADAGOMEZ/HECTOR EZ3FQDQ LHRJNBSA 0235 211M23A 010  108CKI=SSD;";
+	 * "M1AHUMADAGOMEZ/HECTOR EZ3FQDQ LHRJFKSA 0235 211M23A 010  108CKI=SSD;";
+	 * M1TESTNEWGOMEZ/HECTOR EZ3FQDQ LHRJNBSA 0235 211M23A 010 114CKI=SSD;
+	 * ------error materna M1MIRZAEI/RONAK IE7NME CGNPMIX3 2108 354Y008E0035 300
+	 * M1OJASTE/TRIIN E25H72H TLLAMSKL 1326 22M005E0011 300
+	 *
+	 * M1BATZNER/CHRISTIAN IE36EC CPHTXLNB 0553 275 14A 051 00 //for test ampacs
+	 * R6M1AHUMADAGOMEZ/HECTOR EZ3FQDQ LHRJNBSA 0235 211M23A 010 108CKI=SSD;
+	 */
+
+	// Barcode =
+	// "SPUMPKIN/B                      001001  JNB        DURSA 0543 267    22A 037                                                 00"
+    // "SPEAKE/FRANCESMS     C0ZR51              JNB        LHRVS 602  096Y   39H 131                      JNBLHR"
+	// ;
+	// example barcode for
+	// M1MACKINNON/CHRISTINA EZ9MGLH LHRGLABD 014 153M23A 010 108CKI=SSD;
+	// Barcode structure (idx, length)
+	// Segment-number = 1, 1
+	// Name = 2, 20
+	// Elec. ticket indicator = 22, 1
+	// PNR = 23, 7
+	// from = 30, 3
+	// to = 33, 3
+	// alcd = 36, 3
+	// fl.-no = 39, 5
+	// julian date = 44, 3
+	// specials = 58, n (n contained in 58-59)
+	// scanner will shift a window of size 57 bytes over memory
+	// this 57 will be parsed and in case of a multisegment this process
+	// will be repeated n times. All leginfo should be stored somehow vor later
+	// use
+
+	private BarcodeInfo parseMultipleSegmentTypeBarcode(String in_barcode)
+	{
+		BarcodeInfo info = new BarcodeInfo();
+		info.setStatus(BCStatus.STATUS_NOK_NOT_BARCODE);
+		
+        try{
+		  boolean bgr_format = false;
+
+		  if (in_barcode.indexOf("#") != -1) {
+			log.debug("Format BGR");
+			bgr_format = true;
+		  }
+		  if (bgr_format) {
+			in_barcode = in_barcode.replace("#", "");
+		 }
+
+		 if (in_barcode.length() < 24) {
+			log.error("cannot parse barcode lenth problem");
+			return info;
+		 }
+
+		  Matcher matcher;
+		  boolean matched = false;
+		  String header = in_barcode.substring(0, 23);
+		  String barcode = in_barcode.substring(23);
+		  log.debug("work with BARCODE <" + in_barcode + ">");
+		  matcher = header_pattern.matcher(header);
+		  matched = matcher.matches();
+
+		  String type, nrOfSeg, name, eti;
+		  if (!matched) {
+			log.error("Cannot parse PDF417 barcode! No valid header was found!");
+			return info;
+		  } else {
+			info.setStatus(BCStatus.STATUS_NOK);
+			type = matcher.group(1).trim();
+			nrOfSeg = matcher.group(2).trim();
+			name = matcher.group(3).trim();
+			eti = matcher.group(4).trim();
+			log.debug("Found user name <" + name + ">");
+			int pos = name.indexOf("/");
+			if (pos == -1 || pos == name.length() - 1) {
+				int blank =name.indexOf(" ");
+				if(blank !=-1){
+					String l_name = name.substring(0, blank);
+					String f_name = name.substring(blank + 1);
+					info.setFirstName(f_name);
+					info.setLastName(l_name);
+					 log.info("name separator is not slash but blank");
+					 info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+					 info.setErrorDetails("name separator is not slash but blank");
+				}else{
+				  info.setLastName(name);
+				}
+			} else {
+				String l_name = name.substring(0, pos);
+				String f_name = name.substring(pos + 1);
+				info.setFirstName(f_name);
+				info.setLastName(l_name);
+			}
+			info.setETI(eti);
+			info.setFormatCode(type);
+			info.setNumbLegs(nrOfSeg);			
+			log.debug("Type: " + type + " ** NrOfSeg: " + nrOfSeg + " ** "
+					+ "Name: " + name + " ** ETI: " + eti);
+
+		  }
+		// /////////////////////////
+		// // COUNTING SEGMENTS ////
+		// /////////////////////////
+
+		 log.debug(barcode);
+		 int test_s = 0;
+		 test_s = Integer.valueOf(nrOfSeg);
+		 int fieldSize = 0;
+		 int redLen = 0;
+		 String seg = barcode.substring(0, segmentStaticLen);
+		 // walk over segment 1, part 1
+		 BarcodeSegment first_bs = null;
+		 if (seg.length() > segmentStaticLen - 2) {
+			seg = seg.substring(0, seg.length() - 2);
+			first_bs = createBarcodeSegment(seg, info);
+			if(first_bs == null){
+				return  info;
+			}
+
+		}
+		info.getSegments().add(first_bs);
+		if ( barcode.length()>= segmentStaticLen) {
+			barcode = barcode.substring(segmentStaticLen - 2);
+		} else {
+			barcode = "";
+		}
+		int condPartLen=0;
+		int versNumber =1;
+        boolean errorSpec =false;
+		log.debug(seg);
+		fieldSize =readSize(barcode.substring(0, 2), info, "variable field length");		
+		barcode = barcode.substring(2);
+		//here the  begin of following variable size field
+		int test =barcode.length();
+		if(fieldSize !=0 && barcode.length() < fieldSize){
+			log.error("barcode length " + barcode.length()	+ " is less as given size " + fieldSize + "");
+			info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+			info.setErrorDetails("Barcode variable part too short, have to be " + fieldSize);
+			// test for error in materna created barcode
+			if (test_s == 1) {
+				log.info("working for test with false barcode");
+				errorSpec =true;	
+				fieldSize =barcode.length();				
+			} else {
+				return info;
+		  }
+		}
+		if (fieldSize != 0) {
+			log.debug("here is variable field size ="+fieldSize);
+			//the first char after field 6
+			String next_part =barcode.substring(0,fieldSize);
+			int npl = next_part.length();
+			String rest_barcode =barcode.substring(fieldSize);
+
+			String begin =barcode.substring(0,1);
+			if(begin.equalsIgnoreCase(">")){
+			  String version_sz =barcode.substring(0,4);
+			  StringBuffer version= new StringBuffer();
+			  StringBuffer sz = new StringBuffer();
+			  extractVersionAndCondSize(version_sz, version, sz);
+			  try{
+			    condPartLen=readSize(sz.toString(), info, "Conditional part length");
+			  }catch(Exception e){
+				   log.error("Conditional part length not int <"+sz.toString()+">");
+					
+			  }
+			  try{
+			    versNumber=readSize(version.toString(), info, "Version number");
+			  }catch(Exception e){
+				log.error("version number not int <"+version.toString()+">");
+				
+			  }
+			  info.setVersionNumber(versNumber);
+			  barcode =barcode.substring(4);
+			  redLen+=4;
+			  if(condPartLen !=0){
+				if(barcode.length() < condPartLen){
+					info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+					info.setErrorDetails("Conditional part too short, have to be " + condPartLen);
+					log.debug("rest length of barcode <"+ barcode+" less as conditionalPart "+condPartLen);
+					log.error("Not ok: rest  length < as conditional part");
+					return info;
+				}
+			   String conditional_part = barcode.substring(0, condPartLen);
+			   log.debug("conditional is <" + conditional_part + ">");
+			   ConditionalBCPart cp = parseConditional(conditional_part, info);
+				if (cp != null) {
+					info.setConditional(cp);
+				}else{
+					info.setWarning(BCWarning.WARN_CONDITIONAL_PART_NOK);
+					info.setErrorDetails("conditional part syntax error");
+				}
+			  }
+			  if(errorSpec){					
+				    info.setStatus(BCStatus.STATUS_OK);
+				    return info;
+				 }
+			  barcode = barcode.substring(condPartLen);
+			  redLen += condPartLen;
+		    //1 segment conditional
+		     if(barcode.length() ==0 || barcode.length() <2){
+		    	log.debug("no data after conditional part, no cond for 1 segment");		    
+		    	info.setStatus(BCStatus.STATUS_OK);
+		     }
+			 //some data after conditional part found
+			 int sgmntCondLen =0;
+			 String nextSize =barcode.substring(0, 2);
+			 sgmntCondLen =readSize(nextSize, info, "Variable data length after conditional part");
+			 barcode = barcode.substring(2);
+			 redLen +=2;
+		 	 if(barcode.length() < sgmntCondLen ){
+		 		 int tt =barcode.length();
+		 		log.info(" declared segment  conditional part length "+sgmntCondLen +" , larger as rest barcode length "+barcode.length() +"  don't read it");
+		 		info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+				info.setErrorDetails("Conditional part of segment too short, have to be longer as " + sgmntCondLen);				
+		    	info.setStatus(BCStatus.STATUS_OK);
+				return info;
+		 	 }
+		 	 if(sgmntCondLen !=0){
+				 String seg_second = barcode.substring(0,  sgmntCondLen);
+				 setSegmentSecondPart(seg_second, first_bs);
+				 barcode = barcode.substring(sgmntCondLen);
+				 redLen +=sgmntCondLen;
+				 int varAirlineLen =fieldSize-redLen;
+				 if(varAirlineLen  <0 ){
+					    log.info("segment  conditional part not right, red "+redLen +" , more as declared variable barcode length "+ fieldSize+"  don't read it");
+					    info.setWarning(BCWarning.WARN_CONDITIONAL_PART_NOK);
+					    info.setStatus(BCStatus.STATUS_OK);					   
+						info.setErrorDetails("conditional part length error");
+						return info;
+				 }
+				 String varAir =barcode.substring(0, varAirlineLen );
+				 first_bs.setAirlineUsed(varAir);
+				 barcode = barcode.substring(varAirlineLen);
+			 }else{
+				 log.debug("no first segment conditional  part");
+				 if(errorSpec){					
+				    info.setStatus(BCStatus.STATUS_OK);
+				    return info;
+				 }
+				 String varAir =next_part.substring(redLen);
+				 first_bs.setAirlineUsed(varAir);
+				 barcode =rest_barcode;
+
+			 }
+			}else{
+				log.debug("no version part, no conditional, the rest is for airport use");
+				if(errorSpec){					
+					info.setStatus(BCStatus.STATUS_OK);
+					return info;
+				}
+				String varAir =barcode.substring(0, fieldSize);
+				first_bs.setAirlineUsed(varAir);
+				barcode =barcode.substring(fieldSize);
+			}
+		 }else{
+			log.debug("no  conditional  part, var size is 0 ");
+		 }		
+		//check if here the end and security
+		if(checkSecurity(barcode, info)){
+			info.setStatus(BCStatus.STATUS_OK);
+			return info;
+		}
+		// walk over the  rest of segments
+		int red_segmts =1;
+		while(red_segmts < test_s){
+			if(barcode.length()>=segmentStaticLen){
+				log.debug("read  static part of segment "+red_segmts);
+				String segmt = barcode.substring(0, segmentStaticLen);
+				int tst =segmt.length();
+				BarcodeSegment bsgmt = null;
+				 if (segmt.length() > segmentStaticLen - 2) {
+					 String ssz =segmt.substring(segmentStaticLen-2);
+					 int var_sz =readSize(ssz, info, "Static segment length");
+					 segmt = segmt.substring(0, segmt.length() - 2);
+					 bsgmt = createBarcodeSegment(segmt, info);
+					 if(bsgmt == null){
+						 log.error("Cannot read barcode segment number "+red_segmts+" break reading");						 
+						 info.setWarning(BCWarning.WARN_SECOND_SEGMENT_NOK);
+						 info.setErrorDetails("Syntax error in barcode segment "+ red_segmts);
+						 break;
+					 }
+					 barcode = barcode.substring(segmentStaticLen);
+					 if(var_sz !=0){
+						 if( barcode.length()>= var_sz){
+							 log.debug("read conditional part of barcode segment "+red_segmts);
+							 int segmntCondLen =readSize(barcode.substring(0,2), info, "Conditional part of segment "+red_segmts);
+							 barcode = barcode.substring(2);
+							 String seg_second = barcode.substring(0,   segmntCondLen);
+							 setSegmentSecondPart(seg_second, bsgmt);
+							 barcode = barcode.substring(segmntCondLen);
+							 int varAirlineLen =var_sz-(segmntCondLen+2);
+							 String varAir =barcode.substring(0, varAirlineLen );
+							 bsgmt.setAirlineUsed(varAir);
+							 if(barcode.length()<varAirlineLen){
+								 log.error("something wrong, length not enough for airline used");
+								 return info;
+							 }
+							 barcode = barcode.substring(varAirlineLen);
+							 info.getSegments().add(bsgmt);
+						 }else{
+							 log.warn("barcode length not enough for read, must be at least "+var_sz +" is only "+barcode.length());
+
+							 if(bsgmt != null && red_segmts ==test_s-1){
+								 info.getSegments().add(bsgmt);
+								 info.setStatus(BCStatus.STATUS_OK);
+							 }
+							 return info;
+						 }
+					 }else{
+						 log.debug("no conditional part in segment "+red_segmts+ " read next");
+						 info.getSegments().add(bsgmt);
+
+					 }
+				}
+			}else{
+				log.error("barcode rest length less as segment length, cannot read next segment");
+				info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+				info.setErrorDetails("barcode rest length less as segment length, cannot read next segment ");
+				return info;
+			}
+			red_segmts++;
+			if(checkSecurity(barcode, info)){
+				break;
+			}
+		}
+		 info.setStatus(BCStatus.STATUS_OK);
+       } catch (Exception e) {
+			return info;
+		}
+		log.debug("<<Parse response, info set " + info.isInfoSet() + " status "
+				+ info.getStatus());
+		return info;
+	}
+
+	/*
+ 		Sample:
+	 	SPEAKE/FRANCESMS     C0ZR51              JNB        LHRVS 602  096Y   39H 131                      JNBLHR
+
+   		Single segment type specification:
+		1 1     Format code
+		2 20    Name
+		22 7    PNR
+		29 3    Carrier
+		32 1    PAX description
+		33 4    Date of issue (exchange)
+		37 4    Date of issue
+		41 1    X/O indicator
+		42 3    FROM
+		45 8    Agent code
+		53 3    TO
+		56 3    Airline designator
+		59 5    Flight number
+		64 3    Date of flight
+		67 1    compartment code
+		68 2    processing indicator
+		70 1    ID/AD indicator
+		71 4    Seat
+		75 5    sequence number
+		80 1    international documentation
+		81 1    PAX Status
+		82 3    Free baggage allowance
+		85 1    coupon accepted in exchange
+		86 3    Airline numeric code
+		89 10   serial number of this document
+		99 1    check digit
+		100 3   origin
+		103 3   destination
+		106 16  FQTV number
+		122 4   additianl seat info
+		126 1   E-Ticket indicator
+		127 1   Individual use
+	 */
+	private BarcodeInfo parseSingleSegementTypeBarcode(String in_barcode)
+	{
+		BarcodeInfo info = new BarcodeInfo();
+		info.setStatus(BCStatus.STATUS_NOK_NOT_BARCODE);
+
+    	try
+    	{
+    		boolean bgr_format = false;
+    		if (in_barcode.indexOf("#") != -1)
+    		{
+    			log.debug("Format BGR");
+				bgr_format = true;
+			}
+			if (bgr_format)
+			{
+				in_barcode = in_barcode.replace("#", "");
+			}
+			if (in_barcode.length() < 24) {
+				log.debug("cannot parse barcode <" + in_barcode + ">");
+				log.error("cannot parse barcode");
+				return info;
+			}
+			info.setStatus(BCStatus.STATUS_NOK);
+			String ar_use="";
+            if(in_barcode.length()>126){
+            	ar_use =in_barcode.substring(126);
+            	in_barcode= in_barcode.substring(0, 126);
+            }
+			
+			
+			Matcher matcher;
+			boolean matched = false;
+			log.debug("work with S-BARCODE <" + in_barcode + ">");
+			matcher = singleSegmentTypeBarcodeMatcher.matcher(in_barcode);
+			matched = matcher.matches();
+
+			if (!matched)
+			{
+				log.error("Cannot parse PDF417 s-barcode! Structure is not valid");
+				return info;
+			}
+			info.setStatus(BCStatus.STATUS_NOK);
+			BarcodeSegment segment = new BarcodeSegment();
+			
+			info.setFormatCode(matcher.group(1).trim());
+			info.setNumbLegs("1");
+			info.setETI(matcher.group(31).trim());
+
+			String name = matcher.group(2).trim();
+
+			int pos = name.indexOf("/");
+			if (pos == -1 || pos == name.length() - 1)
+			{
+				info.setLastName(name);
+			}
+			else
+			{
+				String l_name = name.substring(0, pos);
+				String f_name = name.substring(pos + 1);
+				info.setFirstName(f_name);
+				info.setLastName(l_name);
+			}
+
+			segment.setPnr(matcher.group(3).trim());
+			segment.setOrigin(matcher.group(9), info);
+			segment.setDestination(matcher.group(11), info);
+			segment.setAirlineCode(matcher.group(12).trim(), info);			
+			segment.setAirlineUsed(ar_use.trim());
+			segment.setFlightNumber(matcher.group(13), info);
+			segment.setCompartmentCode(matcher.group(15).trim());
+			segment.setSeat(matcher.group(18), info);
+			segment.setBoardingNumber(matcher.group(19), info);
+			segment.setPaxStatus(matcher.group(21).trim());
+			segment.setFreeBaggageAllowance(matcher.group(22).trim());
+			segment.setAirlineNumericCode(matcher.group(24).trim());
+			segment.setFrqntFlyerNumber(matcher.group(29).trim());
+
+			String date = matcher.group(14).trim();
+			int f_day = 0;
+			try
+			{
+				f_day = Integer.parseInt(date);
+			}
+			catch (Exception e)
+			{
+				log.error("Invalid syntax of date in barcode <" + date + ">");
+				info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+			    info.setErrorDetails("Date of Flight <" + date + "> not  integer");
+				return info;
+			}
+			Date d = formatDate(f_day, this.yearCalendar);
+			segment.setFlightDate(d);
+
+			info.getSegments().add(segment);
+			info.setStatus(BCStatus.STATUS_OK);
+    	}
+    	catch (Exception e)
+    	{
+			return info;
+    	}
+    	return info;
+	}
+	
+
+	private int readSize(String strSz, BarcodeInfo info, String type) throws Exception{
+		int ret =0;
+
+		try {
+			ret = Integer.valueOf(strSz, 16).intValue();
+		} catch (Exception e) {
+			log.error("Exc. " + e);
+			log.error("cannot parse conditional length, not int <"
+					+ strSz + ">");
+			info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+			info.setErrorDetails("Value of "+type +" not integer");
+			throw e;
+		}
+		return ret;
+	}
+	private void extractVersionAndCondSize(String test, StringBuffer vers, StringBuffer sz)throws Exception{
+		 Matcher matcher;
+		 boolean matched = false;
+		 matcher = versionSizePattern.matcher(test);
+		 matched = matcher.matches();
+		  String vrs, szL;
+		  if (!matched) {
+			log	.error("Cannot Version-size!");
+			throw new Exception();
+		  } else {
+			 vrs = matcher.group(2).trim();
+			 szL = matcher.group(3).trim();
+			 vers.append(vrs);
+			 sz.append(szL);
+		  }
+	}
+	private boolean checkSecurity(String barcode, BarcodeInfo info){
+		//search for security data and cut it of - begin with ^
+		  int pos_security = barcode.indexOf("^");
+		  if(pos_security ==0){
+			  log.debug("here is security part, end of barcode!");
+			  String security_type = barcode.substring(1,2);
+			  String security_l =barcode.substring(2,4);
+			  barcode =barcode.substring(4);
+			  int sz =0;
+			  try {
+				 sz = readSize(security_l, info, "Security size");
+			} catch (Exception e) {
+				log.error("cannot estimate security size");				
+				return true;
+			}
+			if(barcode.length()<sz){
+				log.error("security sz  not enough");
+				return true;
+			}
+			String scr =barcode.substring(0,sz);
+			Security s = new Security();
+			s.setType(security_type);
+			s.setSecurityStr(scr);
+			info.setSecurity(s);
+			return true;
+		  }else{
+			  return false;
+		  }
+	}
+
+
+	private BarcodeSegment createBarcodeSegment(String segment, BarcodeInfo info) {
+		BarcodeSegment bs = new BarcodeSegment();
+		String pnr, offp, dest, alcd, flightNr, date, compartmentCode, seatNr, checkInSeq, status;
+
+		Matcher matcher = segment_stat_pattern.matcher(segment);
+		boolean matched = matcher.matches();
+		if (matched) {
+			pnr = matcher.group(1).trim();
+			offp = matcher.group(2);
+			dest = matcher.group(3);
+			alcd = matcher.group(4);
+			flightNr = matcher.group(5);
+			date = matcher.group(6).trim();
+			compartmentCode = matcher.group(7).trim();
+			seatNr = matcher.group(8);
+			checkInSeq = matcher.group(9);
+			status = matcher.group(10).trim();
+
+			log.debug(" PNR:" + pnr + " ** Offp: " + offp + " ** " + "Dest: "
+					+ dest + " ** ALCD: " + alcd + " ** FlightNr: " + flightNr
+					+ " ** " + "Date: " + date + " ** CompCode: "
+					+ compartmentCode + " ** " + "SeatNr: " + seatNr
+					+ " ** CheckInSeq: " + checkInSeq + " **" + "Status: "
+					+ status);
+
+			// ////////////////////////////////////////////////
+			// ////////////// CREATE SEGMENT //////////////////
+			// ////////////////////////////////////////////////
+
+			// seg.setTicketType(TicketT
+			bs.setCompartmentCode(compartmentCode);
+			bs.setBoardingNumber(checkInSeq, info);
+			bs.setSeat(seatNr, info);
+			bs.setPaxStatus(parseCheckInType(status));
+			bs.setPnr(pnr);
+
+			// Set up flight
+			bs.setAirlineCode(alcd, info);
+			bs.setOrigin(offp, info);
+			bs.setDestination(dest, info);			
+			bs.setFlightNumber(flightNr, info);
+			int f_day = 0;
+			try {
+				f_day = Integer.parseInt(date);
+			} catch (Exception e) {
+			    log.error("Date <" + date + "> not parseable as integer, ignoring segment");
+			    info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+			    info.setErrorDetails("Date of Flight <" + date + "> not  integer");
+				return null;
+			}
+			Date d = formatDate(f_day, this.yearCalendar);
+			bs.setFlightDate(d);
+		}
+		return bs;
+	}
+
+	private ConditionalBCPart parseConditional(String cond_segment, BarcodeInfo info) {
+
+		ConditionalBCPart cp =  new ConditionalBCPart();
+		// (.)(.)(.)(.{4})(.)(.{3})(.{13})
+		String  passengerDesc, srcChekin, srcBp, bpDate, docType, airlineDesBp, bTagLic;
+		String firstNCBLic, secondNCBLic;
+		passengerDesc =cond_segment.substring(0,1);
+		cp.setPassengerDesc(passengerDesc.trim());
+		if(cond_segment.length() >=2){
+			srcChekin =cond_segment.substring(1,2);
+			cp.setSrcChekin(srcChekin.trim());
+		}
+		if(cond_segment.length()>=3){
+			srcBp =cond_segment.substring(2,3);
+			cp.setSrcBoardPass(srcBp.trim());
+		}
+		if(cond_segment.length()>=7){
+			bpDate = cond_segment.substring(3,7);
+			if(bpDate.equals("    ")){
+				// empty date, oK nothing to do
+			}else{			//check if format oK			
+			  int f_day = 0;
+			  try {
+				 f_day = Integer.parseInt(bpDate.trim());
+			  } catch (Exception e) {
+			    log.debug("Boardcard issue Date <" + bpDate + "> not parseable as integer, ignoring");
+				return null;
+			  }
+			  try{
+			    Date d = formatIssueDate(bpDate);
+			    cp.setBoardPassIssueDate(d);
+			  }catch(Exception p){
+				log.debug("Cannot parse issue date <"+bpDate+">");
+				info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+				info.setErrorDetails("Format of   date of Issue of Boarding Pass false "+bpDate);
+				return null;
+			  }
+			}
+		}
+		if(cond_segment.length()>=8){
+			docType =cond_segment.substring(7,8);
+			cp.setDocType(docType.trim());
+		}
+		if(cond_segment.length()>=11){
+			airlineDesBp =cond_segment.substring(8, 11);
+			cp.setAirlineDesignatorBpIssuer(airlineDesBp.trim());
+		}
+		if(cond_segment.length()>=24){
+			bTagLic =cond_segment.substring(11, 24);
+			cp.setBaggageTagLicencePlateNumber(bTagLic.trim());
+		}
+		if(cond_segment.length()>=37){
+			firstNCBLic =cond_segment.substring(24, 37);
+			cp.setFirstNonConsecutiveBagTagLicencePlateNumber(firstNCBLic.trim());
+		}
+		if(cond_segment.length()>=50){
+			secondNCBLic =cond_segment.substring(37, 50);
+			cp.setSecondNonConsecutiveBagTagLicencePlateNumber(secondNCBLic.trim());
+		}
+		return cp;
+	}
+
+	private  void setSegmentSecondPart(String cond_seg_part,  BarcodeSegment bs) {
+
+		// (.{3})(.{10})(.)(.)(.{3})(.{3})(.{16})(.)(.{3})
+		String airlineNumericCode, docSerialNumber, selecteeInd, intDocVer, mrkCarrierDesignator, frqntFlyerArlDesignator;
+		String frqntFlyerNumber, ID_AD_Ind, freeBggeAllowance, fastTrack;
+		if(cond_seg_part.length()<3){
+			log.error("conditional segment part must be at least 3 chars it is not");
+			return;
+		}
+		airlineNumericCode = cond_seg_part.substring(0,3);
+		bs.setAirlineNumericCode(airlineNumericCode.trim());
+		if(cond_seg_part.length() >=13){
+			docSerialNumber =  cond_seg_part.substring(3, 13);
+			bs.setDocSerialNumber(docSerialNumber.trim());
+		}
+		if(cond_seg_part.length() >=14){
+			 selecteeInd =  cond_seg_part.substring(13, 14);
+			 bs.setSelecteeInd( selecteeInd.trim());
+		}
+		if(cond_seg_part.length() >=15){
+			intDocVer =  cond_seg_part.substring(14, 15);
+			 bs.setIntDocVer( intDocVer.trim());
+		}
+		if(cond_seg_part.length() >=18){
+			 mrkCarrierDesignator =  cond_seg_part.substring(15, 18);
+			 bs.setMrkCarrierDesignator(  mrkCarrierDesignator.trim());
+		}
+		if(cond_seg_part.length() >=21){
+			frqntFlyerArlDesignator =  cond_seg_part.substring(18, 21);
+			bs.setFrqntFlyerArlDesignator( frqntFlyerArlDesignator.trim());
+		}
+		if(cond_seg_part.length() >=37){
+			frqntFlyerNumber =  cond_seg_part.substring( 21, 37);
+			bs.setFrqntFlyerNumber( frqntFlyerNumber.trim());
+		}
+		if(cond_seg_part.length() >=38){
+			ID_AD_Ind =  cond_seg_part.substring( 37, 38);
+			bs.setID_AD_Ind( ID_AD_Ind.trim());
+		}
+		if(cond_seg_part.length() >=41){
+			freeBggeAllowance =  cond_seg_part.substring( 38, 41);
+			bs.setFreeBaggageAllowance( freeBggeAllowance.trim());
+		}
+		if(cond_seg_part.length() >=42){
+			fastTrack =  cond_seg_part.substring( 41,42);
+			bs.setFastTrack( fastTrack.trim());
+		}
+		/*Matcher matcher;
+		boolean matched = false;
+		matcher = segment_conditional_pattern.matcher(cond_seg_part);
+		matched = matcher.matches();
+		if (matched) {
+			airlineNumericCode = matcher.group(1).trim();
+			docSerialNumber = matcher.group(2).trim();
+			selecteeInd = matcher.group(3).trim();
+			intDocVer = matcher.group(4).trim();
+			mrkCarrierDesignator = matcher.group(5).trim();
+			frqntFlyerArlDesignator = matcher.group(6).trim();
+			frqntFlyerNumber = matcher.group(7).trim();
+			ID_AD_Ind = matcher.group(8).trim();
+			freeBggeAllowance = matcher.group(9).trim();
+			bs.setAirlineNumericCode(airlineNumericCode);
+			bs.setDocSerialNumber(docSerialNumber);
+			bs.setIntDocVer(intDocVer);
+			bs.setFreeBaggageAllowance(freeBggeAllowance);
+			bs.setFrqntFlyerArlDesignator(frqntFlyerArlDesignator);
+			bs.setFrqntFlyerNumber(frqntFlyerNumber);
+			bs.setID_AD_Ind(ID_AD_Ind);
+			bs.setMrkCarrierDesignator(mrkCarrierDesignator);
+			bs.setSelecteeInd(selecteeInd);
+			log.debug("Read  REPEAT CONDITIONAL: airlineNumericCode: "
+					+ airlineNumericCode + " docSerialNumber:"
+					+ docSerialNumber + " selectInd:" + " " + selecteeInd
+					+ "intDocVer: " + intDocVer + " mrkCarrierDesignator:"
+					+ mrkCarrierDesignator + " frqntFlyerArlDesignator: "
+					+ frqntFlyerArlDesignator + " frqntFlyerNumber: "
+					+ frqntFlyerNumber + " ID_AD_Ind " + ID_AD_Ind
+					+ " freeBggeAllowance " + freeBggeAllowance
+
+			);
+		}*/
+
+	}
+   /*
+    * build Date from DateOfYear
+    */
+	public static Date formatDate(int f_day, Calendar yearC) {
+		log.debug("Parsing day of year " + f_day);
+		java.text.DateFormat dp = new SimpleDateFormat("yyyy.MM.dd");
+		Calendar cal = Calendar.getInstance();
+		cal.setTime(new Date());
+		cal.set(Calendar.DAY_OF_YEAR, f_day);
+		String dt =dp.format(cal.getTime());
+		Date ret = setYear(cal.getTime(), yearC);
+		//set day of year on the new year
+		Calendar cal2 = Calendar.getInstance();
+		cal2.setTime(ret);
+		cal2.set(Calendar.DAY_OF_YEAR, f_day);
+		Date ret2 = cal2.getTime();
+		return ret2;
+	}
+	public static Date formatIssueDate(String dat_str){
+		String year =dat_str.substring(0,1);
+		String dat =dat_str.substring(1,dat_str.length() );
+		int dayofYear =Integer.parseInt(dat);
+		Calendar cal = GregorianCalendar.getInstance();
+		cal.setTime(new Date());
+		int fyear =cal.get(Calendar.YEAR);
+		String syear = String.valueOf(fyear);
+		String cut_y = syear.substring(0, syear.length()-1);
+		cut_y +=year;
+		int cut_yi = Integer.parseInt(cut_y);
+		Integer iy = null;
+		if(cut_yi > fyear){
+			Calendar cal2 = GregorianCalendar.getInstance();
+			cal2.setTime(new Date());
+			cal2.set(Calendar.YEAR, cut_yi );
+			cal2.add(Calendar.YEAR, -10);
+			iy = new Integer(cal2.get(Calendar.YEAR));
+
+		}else{
+		   iy = Integer.parseInt(cut_y);
+		}
+		cal.set(Calendar.YEAR, iy);
+		cal.set(Calendar.DAY_OF_YEAR, dayofYear);
+		return cal.getTime();
+	}
+	/*
+	 * calculate year for boardcard - last year if the bc date month <= now_month-6
+	 */
+	public static Date setYear(Date dt, Calendar yearC){
+		Calendar cal_dt = new GregorianCalendar();
+	    cal_dt.setTime(dt);
+	    cal_dt.set(Calendar.HOUR_OF_DAY, 0);
+	    cal_dt.set(Calendar.MINUTE, 0);
+	    cal_dt.set(Calendar.SECOND, 0);
+	    cal_dt.set(Calendar.MILLISECOND, 0);
+		if(yearC!= null){
+			log.debug("Setting external year "+ yearC.get(Calendar.YEAR));
+			cal_dt.set(Calendar.YEAR, yearC.get(Calendar.YEAR));
+			 return cal_dt.getTime();
+			
+		}
+		
+		
+	    Date now = new Date();
+	    Calendar cal_now = new GregorianCalendar();
+		cal_now.setTime( now);
+		cal_now.set(Calendar.HOUR_OF_DAY, 0);
+		cal_now.set(Calendar.MINUTE, 0);
+		cal_now.set(Calendar.SECOND, 0);
+		cal_now.set(Calendar.MILLISECOND, 0);
+	    int now_year =cal_now.get(Calendar.YEAR);
+
+	    
+	    cal_dt.set(Calendar.YEAR,  now_year);
+
+	    if(cal_now.equals(cal_dt)){
+	    	return cal_dt.getTime();
+	    }
+
+	    Calendar cal_dt2 = new GregorianCalendar();
+	    cal_dt2.setTime(cal_dt.getTime());
+	    cal_dt2.add(Calendar.YEAR, -1);
+
+	    Calendar cal_test_6 = new GregorianCalendar();
+	    cal_test_6.setTime(now);
+	    cal_test_6.add(Calendar.MONTH, -6);
+
+	    //String test_6 = df.format(cal_test_6.getTime());
+	    //String test_dat =df.format(cal_dt.getTime());
+	    //String test_now = df.format(cal_now.getTime());
+
+	   // String test_2 = df.format(cal_now.getTime());
+	    if(cal_dt.after(cal_test_6)
+	    		&& cal_dt.before(cal_now)){
+	    	return cal_dt.getTime();
+	    }
+	    if(cal_dt2.after(cal_test_6)
+	    		&& cal_dt2.before(cal_now)){
+	    	return cal_dt2.getTime();
+	    }
+
+	    Calendar cal_test2 = new GregorianCalendar();
+	    cal_test2.setTime(now);
+	    cal_test2.add(Calendar.MONTH,+6);
+	    if(cal_dt.after(cal_now) && cal_dt.before(cal_test2)){
+	    	return cal_dt.getTime();
+	    }
+	    cal_dt.add(Calendar.YEAR, +1);
+	    return cal_dt.getTime();
+
+	}
+
+	/**
+	 * Convert the string valued status in a CheckinStatusType
+	 *
+	 * @param status
+	 */
+
+	private static String parseCheckInType(String status) {
+		return status;
+		/*if (status.equals("0") || status.equals("2"))
+			return "CHECKED_IN";
+		else if (status.equals("7"))
+			return "STANDBY";
+		else
+			return "OPEN";*/
+	}
+}
diff --git a/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BarcodeSegment.java b/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BarcodeSegment.java
new file mode 100644
index 00000000..7fae4554
--- /dev/null
+++ b/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/BarcodeSegment.java
@@ -0,0 +1,338 @@
+package com.materna.buc.cugate.barcode;
+
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+
+import org.apache.log4j.Logger;
+
+public class BarcodeSegment {
+	private static final Logger log = Logger
+			.getLogger("com.materna.buc.cugate.bpcheck");
+	String pnr;
+	String origin;
+	String destination;
+	String airlineCode;
+	String flightNumber;
+	Date flightDate = null;
+	String compartmentCode;
+	String seat;
+	String boardingNumber;
+	String paxStatus;
+	// /conditional part
+	String airlineNumericCode;
+	String docSerialNumber;
+	String selecteeInd;
+	String intDocVer ;
+	String mrkCarrierDesignator;
+	String frqntFlyerArlDesignator;
+	String frqntFlyerNumber;
+	String iD_AD_Ind;
+	String freeBaggageAllowance;
+	String fastTrack;
+	String airlineUsed ;
+
+	private static DateFormat df = new SimpleDateFormat("ddMMM", new Locale(
+			"en"));
+
+	public String getPnr() {
+		return pnr;
+	}
+
+	public void setPnr(String pnr) {
+		this.pnr = pnr;
+	}
+
+	public String getOrigin() {
+		return origin;
+	}
+
+	public void setOrigin(String offp, BarcodeInfo info) {
+		checkAirport(offp, info, "From City Airport Code");
+		this.origin = offp.trim();
+	}
+	public boolean checkAirport(String orr, BarcodeInfo info, String name){
+		if(orr.length()!=3){
+			info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+			info.setErrorDetails("length of "+name+ " less as 3");
+			return false;
+		}
+		for(int i=0; i<3; i++){
+			char test =orr.charAt(i);
+			if(!Character.isLetter(test)){
+				info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+				info.setErrorDetails("not letter in first 3 places of "+name);
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	public String getDestination() {
+		return destination;
+	}
+
+	public void setDestination(String dest, BarcodeInfo info ) {
+		checkAirport(dest, info, "To City Airport Code");
+		this.destination = dest.trim();
+	}
+
+	public String getAirlineCode() {
+		return airlineCode;
+	}
+
+	public void setAirlineCode(String alcd,  BarcodeInfo info) {
+		
+		if( info != null && alcd.length()!=3){
+			info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+			info.setErrorDetails("airline is empty or has length  less as 3");
+		}
+		alcd = alcd.trim();
+		this.airlineCode = alcd;
+
+	}
+
+	public String getFlightNumber() {
+		return flightNumber;
+	}
+
+	public void setFlightNumber(String flightNr,  BarcodeInfo info) {
+		checkFlightNumber(flightNr, info);
+		this.flightNumber = flightNr.trim();
+	}
+	public boolean checkFlightNumber(String fNumber, BarcodeInfo info){
+		if(fNumber.length()!=5){
+			info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+			info.setErrorDetails("Flight Number  is empty or has length less as 5");
+			return false;
+		}
+		for(int i=0; i<4; i++){
+			char test =fNumber.charAt(i);
+			if(!Character.isDigit(test)){
+				info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+				info.setErrorDetails("not digit in first 4 places of Flight Number");
+				return false;
+			}
+		}
+		char test =fNumber.charAt(4);
+
+		if(Character.isSpaceChar(test)){
+			return true;
+		}
+		if(!Character.isLetter(test)){
+			info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+			info.setErrorDetails("not alpha or blank in  place 5  of Flight Number");
+			return false;
+		}
+		return true;
+	}
+
+	public Date getFlightDate() {
+		return flightDate;
+	}
+
+	public void setFlightDate(Date date) {
+		this.flightDate = date;
+	}
+
+	public String getCompartmentCode() {
+		return compartmentCode;
+	}
+
+	public void setCompartmentCode(String compartmentCode) {
+		this.compartmentCode = compartmentCode;
+	}
+
+	public String getSeat() {
+		return seat;
+	}
+
+	public void setSeat(String seatNr, BarcodeInfo info) {
+		checkSeatNumber(seatNr, info);
+		this.seat = seatNr.trim();
+	}
+	public boolean checkSeatNumber(String fNumber, BarcodeInfo info){
+		if(fNumber.length()!=4){
+			info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+			info.setErrorDetails("length of Seat Number less as 4");
+			return false;
+		}
+		for(int i=0; i<3; i++){
+			char test =fNumber.charAt(i);
+			if(!Character.isDigit(test)){
+				info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+				info.setErrorDetails("not digit in first 3 places of Seat Number");
+				return false;
+			}
+		}
+		char test =fNumber.charAt(3);
+		if(!Character.isLetter(test)){
+			info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+			info.setErrorDetails("not alpha in place 4 of Seat Number");
+			return false;
+		}
+		return true;
+	}
+
+
+	public String getBoardingNumber() {
+		return boardingNumber;
+	}
+
+	public void setBoardingNumber(String checkInSeq, BarcodeInfo info) {
+		checkBoardingNumber(checkInSeq, info);
+		this.boardingNumber = checkInSeq.trim();
+	}
+	public boolean checkBoardingNumber(String fNumber, BarcodeInfo info){
+		if(fNumber.length()!=5){
+			info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+			info.setErrorDetails("length of Check-In Sequence Number less as 5");
+			return false;
+		}
+		for(int i=0; i<4; i++){
+			char test =fNumber.charAt(i);
+			if(!Character.isDigit(test)){
+				info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+				info.setErrorDetails("not digit in first 4 places of Check-In Sequence Number");
+				return false;
+			}
+		}
+		char test =fNumber.charAt(4);
+
+		if(Character.isSpaceChar(test)){
+			return true;
+		}
+		//CharsetEncoder asciiEncoder = Charset.forName("US-ASCII").newEncoder();
+		//if(!asciiEncoder.canEncode(test)){
+		if((int)test >127){
+			info.setWarning(BCWarning.WARN_SYNTAX_NOK);
+			info.setErrorDetails("not ASCII or blank in  place 5  of Check-In Sequence Number");
+			return false;
+		}
+		return true;
+	}
+
+	public String getPaxStatus() {
+		return paxStatus;
+	}
+
+	public void setPaxStatus(String status) {
+		this.paxStatus = status;
+	}
+
+	public static String formatDate(Date date) {
+		String ret = "";
+
+		try {
+			ret = df.format(date);
+			ret = ret.toUpperCase();
+		} catch (Exception e) {
+			log.error("Date format false");
+		}
+		return ret;
+	}
+
+	//conditional
+	public String getAirlineNumericCode() {
+		return airlineNumericCode;
+	}
+	public void setAirlineNumericCode(String airlineNumericCode) {
+		this.airlineNumericCode = airlineNumericCode;
+	}
+	public String getDocSerialNumber() {
+		return docSerialNumber;
+	}
+	public void setDocSerialNumber(String docSerialNumber) {
+		this.docSerialNumber = docSerialNumber;
+	}
+	public String getSelecteeInd() {
+		return selecteeInd;
+	}
+	public void setSelecteeInd(String selecteeInd) {
+		this.selecteeInd = selecteeInd;
+	}
+	public String getIntDocVer() {
+		return intDocVer;
+	}
+	public void setIntDocVer(String intDocVer) {
+		this.intDocVer = intDocVer;
+	}
+	public String getMrkCarrierDesignator() {
+		return mrkCarrierDesignator;
+	}
+	public void setMrkCarrierDesignator(String mrkCarrierDesignator) {
+		this.mrkCarrierDesignator = mrkCarrierDesignator;
+	}
+	public String getFrqntFlyerArlDesignator() {
+		return frqntFlyerArlDesignator;
+	}
+	public void setFrqntFlyerArlDesignator(String frqntFlyerArlDesignator) {
+		this.frqntFlyerArlDesignator = frqntFlyerArlDesignator;
+	}
+	public String getFrqntFlyerNumber() {
+		return frqntFlyerNumber;
+	}
+	public void setFrqntFlyerNumber(String frqntFlyerNumber) {
+		this.frqntFlyerNumber = frqntFlyerNumber;
+	}
+	public String getID_AD_Ind() {
+		return iD_AD_Ind;
+	}
+	public void setID_AD_Ind(String ind) {
+		iD_AD_Ind = ind;
+	}
+	public String getFreeBaggageAllowance() {
+		return freeBaggageAllowance;
+	}
+	public void setFreeBaggageAllowance(String freeBaggageAllowance) {
+		this.freeBaggageAllowance = freeBaggageAllowance;
+	}
+	public String getAirlineUsed() {
+		return airlineUsed;
+	}
+	public void setAirlineUsed(String airlineUsed) {
+		this.airlineUsed = airlineUsed;
+	}
+
+	public String getiD_AD_Ind() {
+		return iD_AD_Ind;
+	}
+
+	public void setiD_AD_Ind(String iD_AD_Ind) {
+		this.iD_AD_Ind = iD_AD_Ind;
+	}
+
+	public String getFastTrack() {
+		return fastTrack;
+	}
+
+	public void setFastTrack(String fastTrack) {
+		this.fastTrack = fastTrack;
+	}
+
+	public void setOrigin(String origin) {
+		this.origin = origin;
+	}
+
+	public void setDestination(String destination) {
+		this.destination = destination;
+	}
+
+	public void setAirlineCode(String airlineCode) {
+		this.airlineCode = airlineCode;
+	}
+
+	public void setFlightNumber(String flightNumber) {
+		this.flightNumber = flightNumber;
+	}
+
+	public void setSeat(String seat) {
+		this.seat = seat;
+	}
+
+	public void setBoardingNumber(String boardingNumber) {
+		this.boardingNumber = boardingNumber;
+	}
+}
diff --git a/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/ConditionalBCPart.java b/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/ConditionalBCPart.java
new file mode 100644
index 00000000..7473add4
--- /dev/null
+++ b/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/ConditionalBCPart.java
@@ -0,0 +1,73 @@
+package com.materna.buc.cugate.barcode;
+
+import java.util.Date;
+import java.util.Vector;
+
+public class ConditionalBCPart {
+	
+	String passengerDesc;
+	String srcChekin;
+	String srcBoardPass;
+	Date boardPassIssueDate =null;
+	String docType;
+	String airlineDesignatorBpIssuer;
+	String baggageTagLicencePlateNumber;
+	String firstNonConsecutiveBagTagLicencePlateNumber="";
+	String secondNonConsecutiveBagTagLicencePlateNumber="";
+	
+	public String getPassengerDesc() {
+		return passengerDesc;
+	}
+	public void setPassengerDesc(String passengerDesc) {
+		this.passengerDesc = passengerDesc;
+	}
+	public String getSrcChekin() {
+		return srcChekin;
+	}
+	public void setSrcChekin(String srcChekin) {
+		this.srcChekin = srcChekin;
+	}
+	public String getSrcBoardPass() {
+		return srcBoardPass;
+	}
+	public void setSrcBoardPass(String srcBoardPass) {
+		this.srcBoardPass = srcBoardPass;
+	}
+	public Date getBoardPassIssueDate() {
+		return boardPassIssueDate;
+	}
+	public void setBoardPassIssueDate(Date boardPassIssueDate) {
+		this.boardPassIssueDate = boardPassIssueDate;
+	}
+	public String getDocType() {
+		return docType;
+	}
+	public void setDocType(String docType) {
+		this.docType = docType;
+	}
+	public String getAirlineDesignatorBpIssuer() {
+		return airlineDesignatorBpIssuer;
+	}
+	public void setAirlineDesignatorBpIssuer(String airlineDesignatorBpIssuer) {
+		this.airlineDesignatorBpIssuer = airlineDesignatorBpIssuer;
+	}
+	public String getBaggageTagLicencePlateNumber() {
+		return baggageTagLicencePlateNumber;
+	}
+	public void setBaggageTagLicencePlateNumber(String baggageTagLicencePlateNumber) {
+		this.baggageTagLicencePlateNumber = baggageTagLicencePlateNumber;
+	}
+	public String getFirstNonConsecutiveBagTagLicencePlateNumber() {
+		return firstNonConsecutiveBagTagLicencePlateNumber;
+	}
+	public void setFirstNonConsecutiveBagTagLicencePlateNumber(String firstNonConsecutiveBagTagLicencePlateNumber) {
+		this.firstNonConsecutiveBagTagLicencePlateNumber = firstNonConsecutiveBagTagLicencePlateNumber;
+	}
+	public String getSecondNonConsecutiveBagTagLicencePlateNumber() {
+		return secondNonConsecutiveBagTagLicencePlateNumber;
+	}
+	public void setSecondNonConsecutiveBagTagLicencePlateNumber(String secondNonConsecutiveBagTagLicencePlateNumber) {
+		this.secondNonConsecutiveBagTagLicencePlateNumber = secondNonConsecutiveBagTagLicencePlateNumber;
+	}
+
+}
diff --git a/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/Security.java b/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/Security.java
new file mode 100644
index 00000000..6b76170c
--- /dev/null
+++ b/SelfServiceCommon/Massai/java/barcodeParserLib/src/main/java/com/materna/buc/cugate/barcode/Security.java
@@ -0,0 +1,18 @@
+package com.materna.buc.cugate.barcode;
+
+public class Security {
+	String securityStr ="";
+	String type ="";
+	public String getSecurityStr() {
+		return securityStr;
+	}
+	public void setSecurityStr(String securityStr) {
+		this.securityStr = securityStr;
+	}
+	public String getType() {
+		return type;
+	}
+	public void setType(String type) {
+		this.type = type;
+	}
+}
diff --git a/SelfServiceCommon/Massai/java/barcodeParserLib/src/test/java/com/materna/buc/cugate/barcode/BarcodeParserTest.java b/SelfServiceCommon/Massai/java/barcodeParserLib/src/test/java/com/materna/buc/cugate/barcode/BarcodeParserTest.java
new file mode 100644
index 00000000..a099f331
--- /dev/null
+++ b/SelfServiceCommon/Massai/java/barcodeParserLib/src/test/java/com/materna/buc/cugate/barcode/BarcodeParserTest.java
@@ -0,0 +1,135 @@
+package com.materna.buc.cugate.barcode;
+
+import org.apache.log4j.Logger;
+import org.junit.Test;
+
+
+import junit.framework.Assert;
+public class BarcodeParserTest {
+ private static final Logger LOG = Logger.getLogger(BarcodeParserTest.class);
+ @Test
+  public void testBC_OK() {
+    try {
+    	final String validt = "M1TREBESIUS/SIMON     EZD33IC HAMDUSAB 6753 278Y018C0045 320>2080      B0E             0FLY ";
+    	BarcodeParser bcp = new BarcodeParser();
+    	BarcodeInfo bci = bcp.parseBC(validt);    	
+    	Assert.assertNotNull(bci);     
+       Assert.assertEquals(bci.getStatus(), BCStatus.STATUS_OK);
+       Assert.assertEquals(bci.getWarning(),BCWarning.WARN_NOT_SET);
+    
+    } catch (Exception e) {     
+      Assert.assertTrue(false);
+    }
+    LOG.info("Successfully passed testBC_OK");
+  }
+ @Test
+ public void testBC_NOK() {
+   try {
+   	final String validt = "_J_BCRI#6M1PATZER/MICHAEL       5599886LHRDXBAB 2638 075 02A 815   3c#108WWW7008 29123123        2ABCSA 1234567890       20K.";
+   	BarcodeParser bcp = new BarcodeParser();
+   	BarcodeInfo bci = bcp.parseBC(validt);    	
+   	Assert.assertNotNull(bci);     
+      Assert.assertEquals(bci.getStatus(), BCStatus.STATUS_NOK);   
+   
+   } catch (Exception e) {     
+     Assert.assertTrue(false);
+   }
+   LOG.info("Successfully passed testBC_NOK");
+ }
+ 
+ @Test
+ public void testBC_WARN() {
+   try {
+   	 final String validt = "M1DALAKOURAS/GEORGIOS EJHB389 ATHGVALX 1823 146Y008F0011 15C>5180 W7145BLX              3F72411671119460    A3 107450103           Y*30600000K09  A3G    ";
+     BarcodeParser bcp = new BarcodeParser();
+   	 BarcodeInfo bci = bcp.parseBC(validt);    	
+     Assert.assertNotNull(bci);     
+      Assert.assertEquals( BCStatus.STATUS_OK, bci.getStatus());
+      Assert.assertEquals(BCWarning.WARN_CONDITIONAL_PART_NOK, bci.getWarning());
+   
+   } catch (Exception e) {     
+     Assert.assertTrue(false);
+   }
+   LOG.info("Successfully passed testBC_WARN");
+ }
+ 
+ @Test
+ public void testBC_WARN_TEXT() {
+   try {
+   	 final String validt = "SBAIRD LINDAANN                          JNBQA      SINSQ 479  262Y   53J 0019  3                  JNBSINSQ8092798375        1";
+     BarcodeParser bcp = new BarcodeParser();
+   	 BarcodeInfo bci = bcp.parseBC(validt);    	
+     Assert.assertNotNull(bci);     
+      Assert.assertEquals( BCStatus.STATUS_OK, bci.getStatus());
+      Assert.assertEquals(BCWarning.WARN_SYNTAX_NOK, bci.getWarning());
+      int test =bci.getErrorDetails().indexOf("airline is empty");
+      boolean proof = false;
+      if(test != -1){
+    	  proof=true; 
+      }
+      Assert.assertTrue(proof);
+    
+   
+   } catch (Exception e) {     
+     Assert.assertTrue(false);
+   }
+   LOG.info("Successfully passed testBC_WARN");
+ }
+ 
+ @Test
+ public void testBC_FastTrack() {
+   try {
+   	 final String validt = "M1FOX/SIX             E3499TY ATHCDGA3 9614 047C003A0006 35D>5180  7047BA3              2A39024263326170 A3                        Y*30600000K09         ";
+     BarcodeParser bcp = new BarcodeParser();
+   	 BarcodeInfo bci = bcp.parseBC(validt);    	
+     Assert.assertNotNull(bci);     
+      Assert.assertEquals(  bci.getStatus(), BCStatus.STATUS_OK);
+      Assert.assertEquals( bci.getWarning(), BCWarning.WARN_NOT_SET);
+      Assert.assertEquals(  bci.getSegments().size(), 1);
+      Assert.assertEquals(  bci.getSegments().get(0).getFastTrack(), "Y");
+   
+   } catch (Exception e) {     
+     Assert.assertTrue(false);
+   }
+   LOG.info("Successfully passed testBC_FastTrack");
+ }
+ @Test
+ public void testBC_FastTrack2Segments() {
+   try {
+     final String validt = "M2MICHAILOPOULOS/XXXXXEKKNYKC TBSATHA3 0983 182C001A0025 35D>5180  7181BA3              2A39024289051830    A3 120423306           Y*30600000K09  A3G    KKNYKC ATHSKGOA 0108 182Y015A0074 3372A39024289051830 A3 A3 120423306           Y09         ";
+     BarcodeParser bcp = new BarcodeParser();
+     BarcodeInfo bci = bcp.parseBC(validt);     
+     Assert.assertNotNull(bci);     
+      Assert.assertEquals(  bci.getStatus(), BCStatus.STATUS_OK);
+      Assert.assertEquals( bci.getWarning(), BCWarning.WARN_NOT_SET);
+      Assert.assertEquals(  bci.getSegments().size(), 2);
+      Assert.assertEquals(  bci.getSegments().get(0).getFastTrack(), "Y");
+      Assert.assertEquals(  bci.getSegments().get(1).getFastTrack(), "Y");
+   
+   } catch (Exception e) {     
+     Assert.assertTrue(false);
+   }
+   LOG.info("Successfully passed testBC_FastTrack2Segments");
+ }
+ @Test
+ public void testBC_TwoSegments() {
+   try {
+   	 final String validt = "M2GRANDMARIE/MELANIE  EABC123 GVACDGAF 0123 228C002F0025 12F>300290571234567890                         20KDEF456 CDGDTWNW 0049 228F001A0002 12B29012098765432101                       2PC^1641234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890";
+     BarcodeParser bcp = new BarcodeParser();
+   	 BarcodeInfo bci = bcp.parseBC(validt);    	
+     Assert.assertNotNull(bci);     
+      Assert.assertEquals(BCStatus.STATUS_OK, bci.getStatus());
+      Assert.assertEquals(BCWarning.WARN_NOT_SET, bci.getWarning());
+      Assert.assertEquals( 2, bci.getSegments().size());
+      Assert.assertEquals( "GVA", bci.getSegments().get(0).getOrigin());
+      Assert.assertEquals( "CDG", bci.getSegments().get(0).getDestination());
+      Assert.assertEquals("CDG", bci.getSegments().get(1).getOrigin());
+      Assert.assertEquals( "DTW", bci.getSegments().get(1).getDestination());
+   
+   } catch (Exception e) {     
+     Assert.assertTrue(false);
+   }
+   LOG.info("Successfully passed testBC_TwoSegments");
+ }
+
+}
diff --git a/SelfServiceCommon/Massai/java/barcodeParserLib/src/test/resources/log4j.xml b/SelfServiceCommon/Massai/java/barcodeParserLib/src/test/resources/log4j.xml
new file mode 100644
index 00000000..0677838b
--- /dev/null
+++ b/SelfServiceCommon/Massai/java/barcodeParserLib/src/test/resources/log4j.xml
@@ -0,0 +1,42 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
+<log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/" debug="false">
+
+  <appender name="CONSOLE" class="org.apache.log4j.ConsoleAppender">
+    <param name="Target" value="System.out" />
+    <param name="Threshold" value="DEBUG" />
+    <layout class="org.apache.log4j.PatternLayout">
+      <!-- The default pattern: Date Priority [Category] Messagen -->
+      <param name="ConversionPattern"
+      value="%m%n" />
+    </layout>
+  </appender>
+  
+  <!-- A size based file rolling appender -->
+  <appender name="FILE" class="org.apache.log4j.RollingFileAppender">
+    <param name="File" value="SecureGate.log" />
+    <param name="Append" value="false" />
+    <param name="MaxFileSize" value="10MB" />
+    <param name="MaxBackupIndex" value="10" />
+    <layout class="org.apache.log4j.PatternLayout">
+      <param name="ConversionPattern"
+      value="%d{MM-dd HH:mm:ss,SSS} %-5p (%-10.10t) [%-25.25c:%-4.4L] %m%n" />
+    </layout>
+  </appender>
+  
+  <category name="org.apache" additivity="false">
+    <priority value="ERROR" />
+    <appender-ref ref="CONSOLE" />
+  </category>
+  
+   <category name="com.materna.buc.cugate.barcode" additivity="false">
+      <priority value="DEBUG" />
+      <appender-ref ref="CONSOLE" />
+  </category>
+  
+  <root>
+    <priority value="DEBUG" />
+    <appender-ref ref="CONSOLE" />
+  </root>
+  
+</log4j:configuration>
-- 
2.41.0.windows.1

