From 95b332ddf9fc6c648822d4cd4b8a2cca843e6d85 Mon Sep 17 00:00:00 2001
From: mpatzer <mpatzer@90b65887-3827-0410-9a23-83215b262276>
Date: Mon, 26 Jul 2010 14:14:18 +0000
Subject: [PATCH 0016/1077] Update to Release 1.0.8.21

git-svn-id: svn://localhost/SelfServiceCommon/trunk@16 90b65887-3827-0410-9a23-83215b262276
---
 Massai/cpp/CfgClnt/inc/CfgNumber.hpp          |  262 ---
 Massai/cpp/CfgClnt/inc/CfgSelection.hpp       |  300 ---
 Massai/cpp/CfgClnt/inc/CfgText.hpp            |  290 ---
 Massai/cpp/CfgClnt/inc/CfgTextL.hpp           |  358 ----
 Massai/cpp/CfgClnt/makefile.mak               |  138 --
 Massai/cpp/CfgClnt/src/mEventSemW32.cpp       |  167 --
 Massai/cpp/CfgClnt/src/mMutexSemW32.cpp       |  130 --
 Massai/cpp/CfgXMgr/CfgMgr_Modules.mak         |   31 -
 Massai/cpp/CfgXMgr/GenHTML.dox                | 1105 -----------
 Massai/cpp/CfgXMgr/inc/ASSOCP.H               |   18 -
 Massai/cpp/CfgXMgr/inc/CfgBase.h              |   50 -
 Massai/cpp/CfgXMgr/inc/CfgFunc.h              |   44 -
 Massai/cpp/CfgXMgr/inc/CfgMCnt.hpp            |   31 -
 Massai/cpp/CfgXMgr/inc/CfgMgrStrings.h        |   85 -
 Massai/cpp/CfgXMgr/inc/CfgXML.hpp             |   18 -
 Massai/cpp/CfgXMgr/inc/CfgXMgr_def.h          |   12 -
 Massai/cpp/CfgXMgr/inc/DBS_Node.hpp           |  149 --
 Massai/cpp/CfgXMgr/inc/DBS_Serv.hpp           |   15 -
 Massai/cpp/CfgXMgr/inc/DBS_Sess.hpp           |   16 -
 Massai/cpp/CfgXMgr/inc/DBS_Sync.hpp           |   86 -
 Massai/cpp/CfgXMgr/inc/DBX_Comm.hpp           |  297 ---
 Massai/cpp/CfgXMgr/inc/DEBUGMAP.hpp           |   18 -
 Massai/cpp/CfgXMgr/inc/MassaiCfgX_def.h       |   12 -
 Massai/cpp/CfgXMgr/inc/UTILS.HPP              |   38 -
 Massai/cpp/CfgXMgr/inc/assoXML.h              |   73 -
 Massai/cpp/CfgXMgr/inc/cfgdbi.hpp             |  200 --
 Massai/cpp/CfgXMgr/inc/chunkedBuffer.h        |  158 --
 Massai/cpp/CfgXMgr/inc/cstrstream.h           |   52 -
 Massai/cpp/CfgXMgr/inc/instance.hpp           |  109 --
 Massai/cpp/CfgXMgr/inc/mHashMT.hpp            |  258 ---
 Massai/cpp/CfgXMgr/inc/mStringFile.hpp        |   61 -
 Massai/cpp/CfgXMgr/inc/mThreadSave.hpp        |   56 -
 Massai/cpp/CfgXMgr/inc/mWarning.hpp           |   59 -
 Massai/cpp/CfgXMgr/inc/matDaemon.h            |   96 -
 Massai/cpp/CfgXMgr/inc/matEnv.hpp             |   49 -
 Massai/cpp/CfgXMgr/inc/matSignal.h            |  199 --
 Massai/cpp/CfgXMgr/inc/stList.hpp             |  690 -------
 Massai/cpp/CfgXMgr/inc/stString.hpp           |   84 -
 Massai/cpp/CfgXMgr/inc/tcpComm.h              |  292 ---
 Massai/cpp/CfgXMgr/inc/writeTrace.hpp         |   69 -
 Massai/cpp/CfgXMgr/res/CfgXMgr.rc             |  109 --
 Massai/cpp/CfgXMgr/res/MassaiCfgX.rc          |  109 --
 Massai/cpp/CfgXMgr/src/Asso.cpp               |  494 -----
 Massai/cpp/CfgXMgr/src/AssoCStr.cpp           |  535 ------
 Massai/cpp/CfgXMgr/src/AssoCp.CPP             |   56 -
 Massai/cpp/CfgXMgr/src/AssoFlat.cpp           |  206 --
 Massai/cpp/CfgXMgr/src/CfgBase.cpp            |  791 --------
 Massai/cpp/CfgXMgr/src/CfgFunc.cpp            | 1341 -------------
 Massai/cpp/CfgXMgr/src/CfgMCnt.cpp            |   98 -
 Massai/cpp/CfgXMgr/src/CfgXML.cpp             |  349 ----
 Massai/cpp/CfgXMgr/src/Cfg_Main.cpp           |  240 ---
 Massai/cpp/CfgXMgr/src/DBS_Node.cpp           |  486 -----
 Massai/cpp/CfgXMgr/src/DBS_Serv.cpp           | 1654 -----------------
 Massai/cpp/CfgXMgr/src/DBS_Sess.cpp           |  458 -----
 Massai/cpp/CfgXMgr/src/DBS_Sync.cpp           |  197 --
 Massai/cpp/CfgXMgr/src/NT_EVSEM.cpp           |   73 -
 Massai/cpp/CfgXMgr/src/UTILS.CPP              |   96 -
 Massai/cpp/CfgXMgr/src/assoXML.cpp            |  512 -----
 Massai/cpp/CfgXMgr/src/assoXML_static.cpp     |  461 -----
 Massai/cpp/CfgXMgr/src/cfgdbi.cpp             |  273 ---
 Massai/cpp/CfgXMgr/src/mEventSemW32.cpp       |  167 --
 Massai/cpp/CfgXMgr/src/mHRTimerW32.cpp        |  100 -
 Massai/cpp/CfgXMgr/src/mMutexSemW32.cpp       |  130 --
 Massai/cpp/CfgXMgr/src/mStringFile.cpp        |   73 -
 Massai/cpp/CfgXMgr/src/massaiCfg.cpp          |  405 ----
 Massai/cpp/CfgXMgr/src/matDaemonW32.cpp       |  554 ------
 Massai/cpp/CfgXMgr/src/matEnvW32.cpp          |   83 -
 Massai/cpp/CfgXMgr/src/matSignalW32.cpp       |  135 --
 Massai/cpp/CfgXMgr/src/matThreadW32.cpp       |  580 ------
 Massai/cpp/CfgXMgr/src/tcpCommW32.cpp         | 1453 ---------------
 Massai/cpp/CfgXMgr/src/writeTrace.cpp         |  105 --
 Massai/cpp/CfgXMgrB/inc/mHRTimer.h            |   92 -
 Massai/cpp/CfgXMgrB/inc/mStringFile.hpp       |   61 -
 Massai/cpp/CfgXMgrB/inc/matDaemon.h           |   96 -
 Massai/cpp/CfgXMgrB/inc/writeTraceIF.hpp      |   41 -
 Massai/cpp/CfgXMgrB/src/mEventSemW32.cpp      |  167 --
 Massai/cpp/CfgXMgrB/src/mHRTimerW32.cpp       |  100 -
 Massai/cpp/CfgXMgrB/src/mMutexSemW32.cpp      |  130 --
 Massai/cpp/CfgXMgrB/src/mStringFile.cpp       |   73 -
 Massai/cpp/CfgXMgrB/src/matDaemonW32.cpp      |  564 ------
 Massai/cpp/CfgXMgrB/src/matThreadW32.cpp      |  580 ------
 Massai/cpp/CfgXMgrB/src/writeTraceIF.cpp      |   79 -
 Massai/cpp/Controller/inc/TRACE.H             |   31 -
 Massai/cpp/Controller/inc/VERSION.H           |   26 -
 Massai/cpp/Controller/inc/argScan.hpp         |  327 ----
 Massai/cpp/Controller/inc/matDaemon.h         |  108 --
 Massai/cpp/Controller/src/matDaemonW32.cpp    |  624 -------
 Massai/cpp/LogService/inc/ProView.h           |   15 -
 Massai/cpp/LogService/inc/intevt.h            |   40 -
 Massai/cpp/LogService/inc/logsnmp.h           |   50 -
 Massai/cpp/LogService/inc/newlogst.h          |   59 -
 Massai/cpp/LogService/inc/trapResent.h        |  200 --
 Massai/cpp/LogService/lib/intevt.dll          |  Bin 84992 -> 0 bytes
 Massai/cpp/LogService/lib/intevt.lib          |  Bin 3194 -> 0 bytes
 Massai/cpp/LogService/setupSnmp.txt           |   20 -
 Massai/cpp/LogService/trapConfiguration.txt   |  378 ----
 Massai/cpp/LogService/trapConfiguration.xls   |  Bin 88064 -> 0 bytes
 Massai/cpp/LogService/trapConfigurationEK.xls |  Bin 104960 -> 0 bytes
 .../cpp/LogService/trapConfiguration_vie.txt  |  465 -----
 99 files changed, 22824 deletions(-)
 delete mode 100644 Massai/cpp/CfgClnt/inc/CfgNumber.hpp
 delete mode 100644 Massai/cpp/CfgClnt/inc/CfgSelection.hpp
 delete mode 100644 Massai/cpp/CfgClnt/inc/CfgText.hpp
 delete mode 100644 Massai/cpp/CfgClnt/inc/CfgTextL.hpp
 delete mode 100644 Massai/cpp/CfgClnt/makefile.mak
 delete mode 100644 Massai/cpp/CfgClnt/src/mEventSemW32.cpp
 delete mode 100644 Massai/cpp/CfgClnt/src/mMutexSemW32.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/CfgMgr_Modules.mak
 delete mode 100644 Massai/cpp/CfgXMgr/GenHTML.dox
 delete mode 100644 Massai/cpp/CfgXMgr/inc/ASSOCP.H
 delete mode 100644 Massai/cpp/CfgXMgr/inc/CfgBase.h
 delete mode 100644 Massai/cpp/CfgXMgr/inc/CfgFunc.h
 delete mode 100644 Massai/cpp/CfgXMgr/inc/CfgMCnt.hpp
 delete mode 100644 Massai/cpp/CfgXMgr/inc/CfgMgrStrings.h
 delete mode 100644 Massai/cpp/CfgXMgr/inc/CfgXML.hpp
 delete mode 100644 Massai/cpp/CfgXMgr/inc/CfgXMgr_def.h
 delete mode 100644 Massai/cpp/CfgXMgr/inc/DBS_Node.hpp
 delete mode 100644 Massai/cpp/CfgXMgr/inc/DBS_Serv.hpp
 delete mode 100644 Massai/cpp/CfgXMgr/inc/DBS_Sess.hpp
 delete mode 100644 Massai/cpp/CfgXMgr/inc/DBS_Sync.hpp
 delete mode 100644 Massai/cpp/CfgXMgr/inc/DBX_Comm.hpp
 delete mode 100644 Massai/cpp/CfgXMgr/inc/DEBUGMAP.hpp
 delete mode 100644 Massai/cpp/CfgXMgr/inc/MassaiCfgX_def.h
 delete mode 100644 Massai/cpp/CfgXMgr/inc/UTILS.HPP
 delete mode 100644 Massai/cpp/CfgXMgr/inc/assoXML.h
 delete mode 100644 Massai/cpp/CfgXMgr/inc/cfgdbi.hpp
 delete mode 100644 Massai/cpp/CfgXMgr/inc/chunkedBuffer.h
 delete mode 100644 Massai/cpp/CfgXMgr/inc/cstrstream.h
 delete mode 100644 Massai/cpp/CfgXMgr/inc/instance.hpp
 delete mode 100644 Massai/cpp/CfgXMgr/inc/mHashMT.hpp
 delete mode 100644 Massai/cpp/CfgXMgr/inc/mStringFile.hpp
 delete mode 100644 Massai/cpp/CfgXMgr/inc/mThreadSave.hpp
 delete mode 100644 Massai/cpp/CfgXMgr/inc/mWarning.hpp
 delete mode 100644 Massai/cpp/CfgXMgr/inc/matDaemon.h
 delete mode 100644 Massai/cpp/CfgXMgr/inc/matEnv.hpp
 delete mode 100644 Massai/cpp/CfgXMgr/inc/matSignal.h
 delete mode 100644 Massai/cpp/CfgXMgr/inc/stList.hpp
 delete mode 100644 Massai/cpp/CfgXMgr/inc/stString.hpp
 delete mode 100644 Massai/cpp/CfgXMgr/inc/tcpComm.h
 delete mode 100644 Massai/cpp/CfgXMgr/inc/writeTrace.hpp
 delete mode 100644 Massai/cpp/CfgXMgr/res/CfgXMgr.rc
 delete mode 100644 Massai/cpp/CfgXMgr/res/MassaiCfgX.rc
 delete mode 100644 Massai/cpp/CfgXMgr/src/Asso.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/AssoCStr.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/AssoCp.CPP
 delete mode 100644 Massai/cpp/CfgXMgr/src/AssoFlat.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/CfgBase.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/CfgFunc.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/CfgMCnt.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/CfgXML.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/Cfg_Main.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/DBS_Node.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/DBS_Serv.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/DBS_Sess.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/DBS_Sync.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/NT_EVSEM.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/UTILS.CPP
 delete mode 100644 Massai/cpp/CfgXMgr/src/assoXML.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/assoXML_static.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/cfgdbi.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/mEventSemW32.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/mHRTimerW32.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/mMutexSemW32.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/mStringFile.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/massaiCfg.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/matDaemonW32.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/matEnvW32.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/matSignalW32.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/matThreadW32.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/tcpCommW32.cpp
 delete mode 100644 Massai/cpp/CfgXMgr/src/writeTrace.cpp
 delete mode 100644 Massai/cpp/CfgXMgrB/inc/mHRTimer.h
 delete mode 100644 Massai/cpp/CfgXMgrB/inc/mStringFile.hpp
 delete mode 100644 Massai/cpp/CfgXMgrB/inc/matDaemon.h
 delete mode 100644 Massai/cpp/CfgXMgrB/inc/writeTraceIF.hpp
 delete mode 100644 Massai/cpp/CfgXMgrB/src/mEventSemW32.cpp
 delete mode 100644 Massai/cpp/CfgXMgrB/src/mHRTimerW32.cpp
 delete mode 100644 Massai/cpp/CfgXMgrB/src/mMutexSemW32.cpp
 delete mode 100644 Massai/cpp/CfgXMgrB/src/mStringFile.cpp
 delete mode 100644 Massai/cpp/CfgXMgrB/src/matDaemonW32.cpp
 delete mode 100644 Massai/cpp/CfgXMgrB/src/matThreadW32.cpp
 delete mode 100644 Massai/cpp/CfgXMgrB/src/writeTraceIF.cpp
 delete mode 100644 Massai/cpp/Controller/inc/TRACE.H
 delete mode 100644 Massai/cpp/Controller/inc/VERSION.H
 delete mode 100644 Massai/cpp/Controller/inc/argScan.hpp
 delete mode 100644 Massai/cpp/Controller/inc/matDaemon.h
 delete mode 100644 Massai/cpp/Controller/src/matDaemonW32.cpp
 delete mode 100644 Massai/cpp/LogService/inc/ProView.h
 delete mode 100644 Massai/cpp/LogService/inc/intevt.h
 delete mode 100644 Massai/cpp/LogService/inc/logsnmp.h
 delete mode 100644 Massai/cpp/LogService/inc/newlogst.h
 delete mode 100644 Massai/cpp/LogService/inc/trapResent.h
 delete mode 100644 Massai/cpp/LogService/lib/intevt.dll
 delete mode 100644 Massai/cpp/LogService/lib/intevt.lib
 delete mode 100644 Massai/cpp/LogService/setupSnmp.txt
 delete mode 100644 Massai/cpp/LogService/trapConfiguration.txt
 delete mode 100644 Massai/cpp/LogService/trapConfiguration.xls
 delete mode 100644 Massai/cpp/LogService/trapConfigurationEK.xls
 delete mode 100644 Massai/cpp/LogService/trapConfiguration_vie.txt

diff --git a/Massai/cpp/CfgClnt/inc/CfgNumber.hpp b/Massai/cpp/CfgClnt/inc/CfgNumber.hpp
deleted file mode 100644
index a6e6da83..00000000
--- a/Massai/cpp/CfgClnt/inc/CfgNumber.hpp
+++ /dev/null
@@ -1,262 +0,0 @@
-/**
- **************************************************************************
- *
- * @file CfgNumber.hpp
- *
- * Contains configNumber class definition.
- *
- * @author Juergen Kreierhoff
- *
- * Copyright (c) 2000-2005, MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef CFGNUMBER_HPP
-#define CFGNUMBER_HPP
-
-#include "cfgNode.hpp"
-#include "corbaclnt.h"
-#include "corbacfg.h"
-#include "CfgMgrIPC.h"
-
-#include <iostream>
-
-#define CNC "configNumber::configNumber"
-#define CND "configNumber::~configNumber"
-#define CNG "configNumber::get"
-
-
-
-/**
- **************************************************************************
- *
- * Number configuration class
- *
- **************************************************************************
-**/
-class configNumber : public configNode
-{
-
-   //! Configuration proxy.
-   corbaClient<Config::Number>  M_NumberClnt;
-
-   //! Trace stream.
-   std::ostream *               M_pOS;
-
-   /**
-    *
-    * Virtual function, which can be overloaded by an application. It then
-    * might provide the configuration-subsystem with item-specific
-    * parameters. An item is created only, if this function is overloaded.
-    *
-   **/
-   virtual void create
-                (
-                   const char * & Rights,
-                   const char * & Explanation,
-                   long &         Default,
-                   long &,
-                   long &
-                )
-   {
-      Rights = Explanation = 0;
-      Default = 0;
-   }
-
-   /**
-    *
-    * Throws an exception and logs, if necessary.
-    *
-    * @param The throw-text.
-    *
-   **/
-   void doThrow( char const * Text )
-   {
-      if( M_pOS )
-         *M_pOS << Text << std::endl;
-      throw nConfig::exception( Text );
-   }
-
-public:
-
-   /**
-    *
-    * Constructor
-    *
-    * @param CCC               Refers an objuect of mCCC.
-    *
-    * @param pcszItem          The name of the configuration item
-    *
-    * @param pcszAuthorization The authorization string (optional)
-    *
-    * @param Trc               An ostream for debugging (optional)
-    *
-   **/
-   configNumber
-   (
-      char const *      pcszItem,
-      char const *      pcszAuthorization = 0,
-      std::ostream *    Trc = 0
-   ) :
-      configNode
-      (
-         "Configuration_Number",
-         pcszItem,
-         pcszAuthorization,
-         Trc
-      ),
-      M_pOS( Trc ),
-      M_NumberClnt( CFGMGR_HOST, CFGMGR_PORT, "Configuration_Number")
-   {
-      if( M_pOS )
-      {
-         *M_pOS << CNC << std::endl;
-      }
-   }
-
-   /**
-    *
-    * Destructor
-    *
-   **/
-   ~configNumber()
-   {
-      if( M_pOS )
-         *M_pOS << CND << std::endl;
-   }
-
-   /**
-    *
-    * Return a valid proxy or throw.
-    *
-    * @return The proxy.
-    *
-   **/
-   Config::Number * validProxy()
-   {
-      Config::Number * Ret = M_NumberClnt.proxy();
-      if( !Ret )
-         doThrow( " - no Proxy" );
-      return Ret;
-   }
-
-   /**
-    *
-    * Retrieves the configuration value.
-    *
-    * @return The value.
-    *
-   **/
-   long get()
-   {
-      Materna::MSSD::autoMutex Block( cfgNodeMutex() );
-      if( M_pOS ) *M_pOS << CNG " ..." << std::endl;
-      long Value = 0;
-      try
-      {
-         Value = validProxy()->get( access() );
-      }
-      catch( Config::Node::notFound & )
-      {
-         if( M_pOS )
-            *M_pOS << CNG " - notFound exception" << std::endl;
-         const char * R = 0;
-         const char * E = 0;
-         long         Min = 0;
-         long         Max = 0;
-         //
-         // Ask heir about create parameters
-         //
-         create( R, E, Value, Min, Max );
-         if( !E )
-            doThrow( "get() -  create() failed" );
-         //
-         // Explanation and defaults given
-         // -> create
-         //
-         try
-         {
-            description( R, E );
-            if( M_pOS )
-               *M_pOS
-                  << CNG " create Default=" << Value << " ..."
-                  << std::endl;
-            validProxy()->create
-                           (
-                              access(),
-                              description(),
-                              Value, Min, Max
-                           );
-            if( M_pOS )
-               *M_pOS << CNG " created." << std::endl;
-            //
-            // Get again
-            //
-            Value = validProxy()->get( access() );
-            if( M_pOS )
-               *M_pOS << CNG " - got now." << std::endl;
-         }
-         catch( CORBA::Exception & )
-         {
-            doThrow( CNG " - create() - CORBA::Exception" );
-         }
-         catch( ... )
-         {
-            doThrow( CNG " - create() - Unknown exception" );
-         }
-      }
-      catch( nConfig::exception & )
-      {
-         throw;
-      }
-      catch( CORBA::Exception & )
-      {
-         doThrow( CNG " - CORBA::Exception" );
-      }
-      catch( ... )
-      {
-         doThrow( CNG " - Unknown exception" );
-      }
-      if( M_pOS )
-         *M_pOS << CNG " = [" << Value << "]." << std::endl;
-      return Value;
-   }
-
-   /**
-    *
-    * Set the configuration value.
-    *
-    * @param The new value.
-    *
-   **/
-   void set( long Value )
-   {
-      validProxy()->set( access(), Value );
-   }
-
-   /**
-    *
-    * Set the initial configuration value.
-    *
-    * @param The new value.
-    *
-   **/
-   void setInitial( long Value )
-   {
-      if( M_pOS )
-         *M_pOS << "configNumber::setInitial ..." << std::endl;
-      validProxy()->setInitial( access(), Value );
-      if( M_pOS )
-         *M_pOS << "configNumber::setInitial." << std::endl;
-   }
-
-};
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgClnt/inc/CfgSelection.hpp b/Massai/cpp/CfgClnt/inc/CfgSelection.hpp
deleted file mode 100644
index 2d0efadd..00000000
--- a/Massai/cpp/CfgClnt/inc/CfgSelection.hpp
+++ /dev/null
@@ -1,300 +0,0 @@
-/**
- **************************************************************************
- *
- * @file CfgSelection.hpp
- *
- * Contains configSelection class definition.
- *
- * @author Juergen Kreierhoff
- *
- * Copyright (c) 2000-2005, MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef CFGSELECTION_HPP
-#define CFGSELECTION_HPP
-
-#include "cfgNode.hpp"
-#include "corbaclnt.h"
-#include "corbacfg.h"
-#include "CfgMgrIPC.h"
-
-#include <iostream>
-
-#define CSC "configSelection::configSelection"
-#define CSD "configSelection::~configSelection"
-#define CSG "configSelection::get"
-
-
-
-/**
- **************************************************************************
- *
- * Selection configuration class
- *
- **************************************************************************
-**/
-class configSelection : public configNode
-{
-
-   //! Configuration proxy.
-   corbaClient<Config::Selection> M_SelectionClnt;
-
-   //! Trace stream.
-   std::ostream *         M_pOS;
-
-   /**
-    *
-    * Virtual function, which can be overloaded by an application. It then
-    * might provide the configuration-subsystem with item-specific
-    * parameters. An item is created only, if this function is overloaded.
-    *
-    */
-   virtual void create
-                (
-                   char const * &                Rights,
-                   char const * &                Explanation,
-                   long &,
-                   Config::Selection::select * &,
-                   Config::Selection::select * &
-                )
-   {
-      Rights = Explanation = 0;
-   }
-
-   /**
-    *
-    * Throws an exception and logs, if necessary.
-    *
-    * @param The throw-text.
-    *
-   **/
-   void doThrow( char const * Text )
-   {
-      if( M_pOS )
-         *M_pOS << Text << std::endl;
-      throw nConfig::exception( Text );
-   }
-
-   /**
-    *
-    * Return a valid proxy or throw.
-    *
-    * @return The proxy.
-    *
-   **/
-   Config::Selection * validProxy()
-   {
-      Config::Selection * Ret = M_SelectionClnt.proxy();
-      if( !Ret )
-         doThrow( " - no Proxy" );
-      return Ret;
-   }
-
-public:
-
-   /**
-    *
-    * Constructor
-    *
-    * @param CCC               Refers an objuect of mCCC.
-    *
-    * @param pcszItem          The name of the configuration item
-    *
-    * @param pcszAuthorization The authorization string (optional)
-    *
-    * @param Trc               An ostream for debugging (optional)
-    *
-   **/
-   configSelection
-   (
-      char const *      pcszItem,
-      char const *      pcszAuthorization = 0,
-      std::ostream *    Trc = 0
-   ) :
-      configNode
-      (
-         "Configuration_Selection",
-         pcszItem,
-         pcszAuthorization,
-         Trc
-      ),
-      M_pOS( Trc ),
-      M_SelectionClnt( CFGMGR_HOST, CFGMGR_PORT, "Configuration_Selection")
-   {
-      if( M_pOS )
-      {
-         *M_pOS << CSC << std::endl;
-      }
-   }
-
-   /**
-    *
-    * Destructor
-    *
-   **/
-   ~configSelection()
-   {
-      if( M_pOS )
-         *M_pOS << CSD << std::endl;
-   }
-
-   /**
-    *
-    * Retrieves the configuration value.
-    *
-    * @return The selection index.
-    *
-   **/
-   long get()
-   {
-      Materna::MSSD::autoMutex Block( cfgNodeMutex() );
-      if( M_pOS ) *M_pOS << CSG " ..." << std::endl;
-      long NdxVal = 0;
-      try
-      {
-         NdxVal = validProxy()->get( access() );
-      }
-      catch( Config::Node::notFound & )
-      {
-         if( M_pOS )
-            *M_pOS << CSG " - notFound exception" << std::endl;
-         const char * R = 0;
-         const char * E = 0;
-         Config::Selection::select * SelBegin = 0;
-         Config::Selection::select * SelEnd = 0;
-         //
-         // Ask heir about create parameters
-         //
-         create( R, E, NdxVal, SelBegin, SelEnd );
-         if( !( E && SelBegin && SelEnd ) )
-            doThrow( "get() -  create() failed" );
-         //
-         // Explanation and selection list given
-         // -> create
-         //
-         try
-         {
-            description( R, E );
-
-            Config::Selection::selectList List;
-            int Number = 0;
-            Config::Selection::select * SelCur = SelBegin;
-            while( SelCur != SelEnd )
-            {
-               ++Number;
-               ++SelCur;
-            }
-            List.length( Number );
-            int Index = 0;
-            while( SelBegin != SelEnd )
-            {
-               if( M_pOS )
-                  *M_pOS
-                     << CSG << " Item( " << Index << " )"
-                     << std::endl;
-               List[Index] = *SelBegin;
-               ++SelBegin;
-               ++Index;
-            }
-            if( M_pOS )
-               *M_pOS
-                  << CSG << " create Default=" << NdxVal
-                  << " ..." << std::endl;
-            validProxy()->create
-            (
-               access(), description(),
-               NdxVal, List
-            );
-            if( M_pOS )
-               *M_pOS << CSG << " created." << std::endl;
-            //
-            // Get again
-            //
-            NdxVal = validProxy()->get( access() );
-            if( M_pOS )
-               *M_pOS << CSG " - got now." << std::endl;
-         }
-         catch( CORBA::Exception & )
-         {
-            doThrow( CSG " - create() - CORBA::Exception" );
-         }
-         catch( ... )
-         {
-            doThrow( CSG " - create() - Unknown exception" );
-         }
-      }
-      catch( nConfig::exception & )
-      {
-         throw;
-      }
-      catch( CORBA::Exception & )
-      {
-         doThrow( CSG " - CORBA::Exception" );
-      }
-      catch( ... )
-      {
-         doThrow( CSG " - Unknown exception" );
-      }
-      if( M_pOS )
-      {
-         if( NdxVal )
-            *M_pOS << CSG " = "
-                   << NdxVal
-                   << std::endl;
-         else
-            *M_pOS << CSG " = <null>." << std::endl;
-      }
-      return NdxVal;
-   }
-
-   /**
-    *
-    * Set the configuration value.
-    *
-    * @param The selection index.
-    *
-   **/
-   void set( long NdxVal )
-   {
-      validProxy()->set( access(), NdxVal );
-   }
-
-   /**
-    *
-    * Set the configuration value.
-    *
-    * @param The new value.
-    *
-   **/
-   void setString( std::string const & StrVal )
-   {
-      validProxy()->setString( access(), StrVal.c_str() );
-   }
-
-   /**
-    *
-    * Set the initial configuration value.
-    *
-    * @param The new value.
-    *
-   **/
-   void setInitialString( std::string const & StrVal )
-   {
-      if( M_pOS )
-         *M_pOS << "configSelection::setInitialText ..." << std::endl;
-      validProxy()->setInitialString( access(), StrVal.c_str() );
-      if( M_pOS )
-         *M_pOS << "configSelection::setInitialText." << std::endl;
-   }
-
-};
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgClnt/inc/CfgText.hpp b/Massai/cpp/CfgClnt/inc/CfgText.hpp
deleted file mode 100644
index 0ed26358..00000000
--- a/Massai/cpp/CfgClnt/inc/CfgText.hpp
+++ /dev/null
@@ -1,290 +0,0 @@
-/**
- **************************************************************************
- *
- * @file CfgText.hpp
- *
- * Contains configText class definition.
- *
- * @author Juergen Kreierhoff
- *
- * Copyright (c) 2000-2005, MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef CFGTEXT_HPP
-#define CFGTEXT_HPP
-
-#include "cfgNode.hpp"
-#include "corbaclnt.h"
-#include "corbacfg.h"
-#include "CfgMgrIPC.h"
-
-#include <iostream>
-
-#define CTC "configText::configText"
-#define CTD "configText::~configText"
-#define CTG "configText::get"
-
-
-
-/**
- **************************************************************************
- *
- * Text configuration class
- *
- **************************************************************************
-**/
-class configText : public configNode
-{
-
-   //! Configuration proxy.
-   corbaClient<Config::Text>    M_TextClnt;
-
-   //! Trace stream.
-   std::ostream *               M_pOS;
-
-   //! Refer the last get() result.
-   char *                       M_Got;
-
-   /**
-    *
-    * Virtual function, which can be overloaded by an application. It then
-    * might provide the configuration-subsystem with item-specific
-    * parameters. An item is created only, if this function is overloaded.
-    *
-   **/
-   virtual void create
-                (
-                   char const * & Rights,
-                   char const * & Explanation,
-                   char const * & Default,
-                   long &
-                )
-   {
-      Rights = Explanation = Default = 0;
-   }
-
-   /**
-    *
-    * Virtual function, which can be overloaded by an application. It then
-    * might provide the configuration-subsystem with item-specific
-    * parameters. An item is created only, if this function is overloaded.
-    *
-   **/
-   virtual void create
-                (
-                   char const * & Rights,
-                   char const * & Explanation,
-                   char const * & Default
-                )
-   {
-      Rights = Explanation = Default = 0;
-   }
-
-   /**
-    *
-    * Throws an exception and logs, if necessary.
-    *
-    * @param The throw-text.
-    *
-   **/
-   void doThrow( char const * Text )
-   {
-      if( M_pOS )
-         *M_pOS << Text << std::endl;
-      throw nConfig::exception( Text );
-   }
-
-   /**
-    *
-    * Return a valid proxy or throw.
-    *
-    * @return The proxy.
-    *
-   **/
-   Config::Text * validProxy()
-   {
-      Config::Text * Ret = M_TextClnt.proxy();
-      if( !Ret )
-         doThrow( " - no Proxy" );
-      return Ret;
-   }
-
-public:
-
-   /**
-    *
-    * Constructor
-    *
-    * @param CCC               Refers an objuect of mCCC.
-    *
-    * @param pcszItem          The name of the configuration item
-    *
-    * @param pcszAuthorization The authorization string (optional)
-    *
-    * @param Trc               An ostream for debugging (optional)
-    *
-   **/
-   configText
-   (
-      char const *      pcszItem,
-      char const *      pcszAuthorization = 0,
-      std::ostream *    Trc = 0
-   ) :
-      configNode
-      (
-         "Configuration_Text",
-         pcszItem,
-         pcszAuthorization,
-         Trc
-      ),
-      M_pOS( Trc ),
-      M_TextClnt( CFGMGR_HOST, CFGMGR_PORT, "Configuration_Text"),
-      M_Got( 0 )
-   {
-      if( M_pOS )
-      {
-         *M_pOS << CTC << std::endl;
-      }
-   }
-
-   /**
-    *
-    * Destructor
-    *
-   **/
-   ~configText()
-   {
-      if( M_Got )
-      {
-         CORBA::string_free( M_Got );
-         M_Got = 0;
-      }
-      if( M_pOS )
-         *M_pOS << CTD << std::endl;
-   }
-
-   /**
-    *
-    * Retrieves the configuration value.
-    *
-    * @return The value.
-    *
-   **/
-   char const * get()
-   {
-      Materna::MSSD::autoMutex Block( cfgNodeMutex() );
-      if( M_pOS ) *M_pOS << CTG " ..." << std::endl;
-      if( M_Got )
-      {
-         CORBA::string_free( M_Got );
-         M_Got = 0;
-      }
-      try
-      {
-         M_Got = validProxy()->get( access() );
-      }
-      catch( Config::Node::notFound & )
-      {
-         if( M_pOS )
-            *M_pOS << CTG " - notFound exception" << std::endl;
-         char const * R = 0;
-         char const * E = 0;
-         long Max = 1024;
-         //
-         // Ask heir about create parameters
-         //
-         create( R, E, M_Got, Max );
-         if( !( E && M_Got ) )
-         {
-            Max = 1023; // Trap users of old style in config file
-            create( R, E, M_Got );
-         }
-         if( !E )
-            doThrow( "get() -  create() failed" );
-         //
-         // Explanation and defaults given
-         // -> create
-         //
-         try
-         {
-            description( R, E );
-            if( M_pOS )
-               *M_pOS
-                  << CTG " create default=[" << M_Got << "] ..."
-                  << std::endl;
-#ifdef USE_STRINGMAX
-            validProxy()->create( access(), description(), M_Got, Max );
-#else
-            validProxy()->create( access(), description(), M_Got );
-#endif
-            if( M_pOS )
-               *M_pOS << CTG " created." << std::endl;
-            //
-            // Get again
-            //
-            M_Got = validProxy()->get( access() );
-            if( M_pOS )
-               *M_pOS << CTG " - got now." << std::endl;
-         }
-         catch( CORBA::Exception & )
-         {
-            doThrow( CTG " - create() - CORBA::Exception" );
-         }
-         catch( ... )
-         {
-            doThrow( CTG " - create() - Unknown exception" );
-         }
-      }
-      catch( nConfig::exception & )
-      {
-         throw;
-      }
-      catch( CORBA::Exception & )
-      {
-         doThrow( CTG " - CORBA::Exception" );
-      }
-      catch( ... )
-      {
-         doThrow( CTG " - Unknown exception" );
-      }
-      if( M_pOS )
-         *M_pOS << CTG " = [" << (M_Got ? M_Got : "") << "]."
-                << std::endl;
-      return M_Got;
-   }
-
-   /**
-    *
-    * Set the configuration value.
-    *
-   **/
-   void set( char const * Value )
-   {
-      validProxy()->set( access(), Value );
-   }
-
-   /**
-    *
-    * Set the initial configuration value.
-    *
-   **/
-   void setInitial( char const * Value )
-   {
-      if( M_pOS )
-         *M_pOS << "configText::setInitial ..." << std::endl;
-      validProxy()->setInitial( access(), Value );
-      if( M_pOS )
-         *M_pOS << "configText::setInitial." << std::endl;
-   }
-
-};
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgClnt/inc/CfgTextL.hpp b/Massai/cpp/CfgClnt/inc/CfgTextL.hpp
deleted file mode 100644
index 2626bbb9..00000000
--- a/Massai/cpp/CfgClnt/inc/CfgTextL.hpp
+++ /dev/null
@@ -1,358 +0,0 @@
-/**
- **************************************************************************
- *
- * @file CfgTextL.hpp
- *
- * Contains configTextlist class definition.
- *
- * @author Juergen Kreierhoff
- *
- * Copyright (c) 2000-2005, MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef CFGTEXTL_HPP
-#define CFGTEXTL_HPP
-
-#include "cfgNode.hpp"
-#include "corbaclnt.h"
-#include "corbacfg.h"
-#include "CfgMgrIPC.h"
-
-#include <iostream>
-#include <list>
-#include <string>
-
-#define CFGTEXTL_C "configTextlist::configTextlist"
-#define CFGTEXTL_D "configTextlist::~configTextlist"
-#define CFGTEXTL_G "configTextlist::get"
-
-/**
- *
- * Textlist type (Configuration value).
- *
-**/
-typedef std::list<std::string> configTextlistVal;
-
-/**
- *
- * Copy from std library string list
- *
-**/
-static void copy
-(
-   Config::Textlist::strings & Dst,
-   configTextlistVal const &   Src
-)
-{
-   configTextlistVal::const_iterator SrcI = Src.begin();
-   int Size = Src.size();
-   Dst.length( Size );
-   int Index = 0;
-   while( SrcI != Src.end() )
-   {
-      Dst[Index] = CORBA::string_dup( (*SrcI).c_str() );
-      ++SrcI;
-      ++Index;
-   }
-}
-
-/**
- *
- * Copy to std library string list
- *
-**/
-static void copy
-(
-  configTextlistVal &               Dst,
-  Config::Textlist::strings const & Src
-)
-{
-   int Length = Src.length();
-   Dst.erase( Dst.begin(), Dst.end() );
-   for( int Idx = 0; Idx < Length; ++Idx )
-   {
-      char const * S = Src[Idx];
-      Dst.push_back( S );
-   }
-}
-
-/**
- **************************************************************************
- *
- * Textlist configuration class
- *
- **************************************************************************
-**/
-class configTextlist : public configNode
-{
-
-   //! Configuration proxy.
-   corbaClient<Config::Textlist> M_ListClnt;
-
-   //! Trace stream.
-   std::ostream *               M_pOS;
-
-   /**
-    *
-    * Virtual function, which can be overloaded by an application. It then
-    * might provide the configuration-subsystem with item-specific
-    * parameters. An item is created only, if this function is overloaded.
-    *
-   **/
-   virtual void create
-                (
-                   const char * & Rights,
-                   const char * & Explanation,
-                   configTextlistVal &,
-                   long &
-                )
-   {
-      Rights = Explanation = 0;
-   }
-
-   /**
-    *
-    * Virtual function, which can be overloaded by an application. It then
-    * might provide the configuration-subsystem with item-specific
-    * parameters. An item is created only, if this function is overloaded.
-    *
-   **/
-   virtual void create
-                (
-                   const char * & Rights,
-                   const char * & Explanation,
-                   configTextlistVal &
-                )
-   {
-      Rights = Explanation = 0;
-   }
-
-   /**
-    *
-    * Throws an exception and logs, if necessary.
-    *
-    * @param The throw-text.
-    *
-   **/
-   void doThrow( char const * Text )
-   {
-      if( M_pOS )
-         *M_pOS << Text << std::endl;
-      throw nConfig::exception( Text );
-   }
-
-   /**
-    *
-    * Return a valid proxy or throw.
-    *
-    * @return The proxy.
-    *
-   **/
-   Config::Textlist * validProxy()
-   {
-      Config::Textlist * Ret = M_ListClnt.proxy();
-      if( !Ret )
-         doThrow( " - no Proxy" );
-      return Ret;
-   }
-
-public:
-
-   /**
-    *
-    * Constructor
-    *
-    * @param CCC               Refers an objuect of mCCC.
-    *
-    * @param pcszItem          The name of the configuration item
-    *
-    * @param pcszAuthorization The authorization string (optional)
-    *
-    * @param Trc               An ostream for debugging (optional)
-    *
-   **/
-   configTextlist
-   (
-      char const *      pcszItem,
-      char const *      pcszAuthorization = 0,
-      std::ostream *    Trc = 0
-   ) :
-      configNode
-      (
-         "Configuration_Textlist",
-         pcszItem,
-         pcszAuthorization,
-         Trc
-      ),
-      M_pOS( Trc ),
-      M_ListClnt( CFGMGR_HOST, CFGMGR_PORT, "Configuration_Textlist")
-   {
-      if( M_pOS )
-      {
-         *M_pOS << CFGTEXTL_C << std::endl;
-      }
-   }
-
-   /**
-    *
-    * Destructor
-    *
-   **/
-   ~configTextlist()
-   {
-      if( M_pOS )
-         *M_pOS << CFGTEXTL_D << std::endl;
-   }
-
-   /**
-    *
-    * Retrieves the configuration value.
-    *
-    * @return 0, if not available or a pointer to the string.
-    *
-   **/
-   configTextlistVal get()
-   {
-      Materna::MSSD::autoMutex Block( cfgNodeMutex() );
-      if( M_pOS ) *M_pOS << CFGTEXTL_G " ..." << std::endl;
-      configTextlistVal Value;
-      static configTextlistVal NoValue;
-      try
-      {
-         Config::Textlist::strings_var Strings
-            = validProxy()->get( access() );
-         copy( Value, Strings );
-      }
-      catch( Config::Node::notFound & )
-      {
-         if( M_pOS )
-            *M_pOS << CFGTEXTL_G " - notFound exception" << std::endl;
-         const char * R = 0;
-         const char * E = 0;
-         long Max = 1024;
-         //
-         // Ask heir about create parameters
-         //
-         create( R, E, Value, Max );
-         if( !E )
-         {
-            Max = 1023;  // Trap users of old style in config file
-            create( R, E, Value );
-         }
-         if( !E )
-            doThrow( "get() -  create() failed" );
-         //
-         // Explanation and defaults given
-         // -> create
-         //
-         try
-         {
-            description( R, E );
-            Config::Textlist::strings DefStrings;
-            copy( DefStrings, Value );
-            if( M_pOS )
-               *M_pOS << CFGTEXTL_G " create ..." << std::endl;
-#ifdef USE_STRINGMAX
-            M_ListClnt.proxy()->create
-                                 (
-                                    access(),
-                                    description(),
-                                    DefStrings,
-                                    Max
-                                 );
-#else
-            M_ListClnt.proxy()->create
-                                 (
-                                    access(),
-                                    description(),
-                                    DefStrings
-                                 );
-#endif
-            if( M_pOS )
-               *M_pOS << CFGTEXTL_G " created." << std::endl;
-            //
-            // Get again
-            //
-            Config::Textlist::strings_var Strings
-               = validProxy()->get( access() );
-            copy( Value, Strings );
-            if( M_pOS )
-               *M_pOS << CFGTEXTL_G " - got now." << std::endl;
-         }
-         catch( CORBA::Exception & )
-         {
-            doThrow( CFGTEXTL_G " - create() - CORBA::Exception" );
-         }
-         catch( ... )
-         {
-            doThrow( CFGTEXTL_G " - create() - Unknown exception" );
-         }
-      }
-      catch( nConfig::exception & )
-      {
-         throw;
-      }
-      catch( CORBA::Exception & )
-      {
-         doThrow( CFGTEXTL_G " - CORBA::Exception" );
-      }
-      catch( ... )
-      {
-         doThrow( CFGTEXTL_G " - Unknown exception" );
-      }
-      if( M_pOS )
-      {
-
-         *M_pOS << CFGTEXTL_G " = [";
-         configTextlistVal::iterator I = Value.begin();
-         while( I != Value.end() )
-         {
-            *M_pOS << *I;
-            ++I;
-            if( I != Value.end() ) *M_pOS << ",";
-         }
-         *M_pOS << "]." << std::endl;
-      }
-      return Value;
-   }
-
-   /**
-    *
-    * Set the configuration value.
-    *
-   **/
-   void set( configTextlistVal const & Value )
-   {
-      Config::Textlist::strings ValStrings;
-      copy( ValStrings, Value );
-      validProxy()->set( access(), ValStrings );
-   }
-
-   /**
-    *
-    * Set the initial configuration value.
-    *
-   **/
-   void setInitial( configTextlistVal const & Value )
-   {
-      if( M_pOS )
-         *M_pOS << "configTextList::setInitial ..." << std::endl;
-      Config::Textlist::strings ValStrings;
-      copy( ValStrings, Value );
-      validProxy()->setInitial( access(), ValStrings );
-      if( M_pOS )
-         *M_pOS << "configTextList::setInitial." << std::endl;
-   }
-
-};
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
-
diff --git a/Massai/cpp/CfgClnt/makefile.mak b/Massai/cpp/CfgClnt/makefile.mak
deleted file mode 100644
index d2972783..00000000
--- a/Massai/cpp/CfgClnt/makefile.mak
+++ /dev/null
@@ -1,138 +0,0 @@
-######################################################################
-#
-# /vob/SelfServiceCommon/Massai/cpp/CfgClnt/makefile.mak
-#
-######################################################################
-
-!include $(BUILDROOT)\cpp\makefile.common.mak
-
-MY_CFLAGS = \
-    -GR \
-    -DUSE_STRINGMAX \
-    -D_AFXDLL \
-    $(INC_ACETAO) \
-    $(INC_INTERFACES)
-    
-######################################################################
-
-MY_LIB1 = \
-    $(LIB_MCFGCLNT)
-
-MY_LIB1_OBJS = \
-    $(_OBJ)\cfgmgr.obj \
-    $(_OBJ)\cfgmgr_skel.obj \
-    $(_OBJ)\CfgNode.obj \
-    $(_OBJ)\mMutexSemW32.obj \
-    $(_OBJ)\nConfig.obj \
-    $(_OBJ)\nConfigBasicText.obj \
-    $(_OBJ)\nConfigNumber.obj \
-    $(_OBJ)\nConfigSelection.obj \
-    $(_OBJ)\nConfigText.obj \
-    $(_OBJ)\nConfigTextList.obj
-
-######################################################################
-
-MY_DLL1 = \
-    $(DLL_MCFGACCESS)
-	
-MY_DLL1_RES = \
-    $(_OBJ)\mConfigAccess.res
-
-MY_DLL1_OBJS = \
-    $(_OBJ)\mConfigAccess.obj
-
-MY_DLL1_LINKLIBS = \
-    $(SYS_ACETAO) \
-    $(LIB_MASSAI) \
-    $(LIB_MCORBA) \
-    $(LIB_MCFGCLNT)
-
-######################################################################
-
-MY_BIN1 = \
-    $(_BIN)\mConfigAccessTest.exe
-
-MY_BIN1_OBJS = \
-    $(_OBJ)\mConfigAccessTest.obj
-
-MY_BIN1_LINKLIBS = \
-    $(LIB_MCFGACCESS)
-
-######################################################################
-
-MY_BIN2 = \
-    $(_BIN)\NCNumGCL.exe
-    
-MY_BIN2_OBJS = \
-    $(_OBJ)\mEventSemW32.obj \
-    $(_OBJ)\NCNumGCL.obj
-
-MY_BIN2_LINKLIBS = \
-    $(SYS_ACETAO) \
-    $(LIB_MASSAI) \
-    $(LIB_MCORBA) \
-    $(LIB_MCFGCLNT)
-
-######################################################################
-
-MY_BIN3 = \
-    $(_BIN)\NCTxtGCL.exe
-
-MY_BIN3_OBJS = \
-    $(_OBJ)\mEventSemW32.obj \
-    $(_OBJ)\NCTxtGCL.obj
-
-MY_BIN3_LINKLIBS = \
-    $(SYS_ACETAO) \
-    $(LIB_MASSAI) \
-    $(LIB_MCORBA) \
-    $(LIB_MCFGCLNT)
-
-######################################################################
-
-MY_BIN4 = \
-    $(_BIN)\NCTxtLstGCL.exe
-
-MY_BIN4_OBJS = \
-    $(_OBJ)\mEventSemW32.obj \
-    $(_OBJ)\NCTxtLstGCL.obj
-
-MY_BIN4_LINKLIBS = \
-    $(SYS_ACETAO) \
-    $(LIB_MASSAI) \
-    $(LIB_MCORBA) \
-    $(LIB_MCFGCLNT)
-
-######################################################################
-
-MY_BIN5 = \
-    $(_BIN)\NCNumCache.exe
-    
-MY_BIN5_OBJS = \
-    $(_OBJ)\mEventSemW32.obj \
-    $(_OBJ)\NCNumCache.obj
-
-MY_BIN5_LINKLIBS = \
-    $(SYS_ACETAO) \
-    $(LIB_MASSAI) \
-    $(LIB_MCORBA) \
-    $(LIB_MCFGCLNT)
-
-######################################################################
-
-MY_BIN6 = \
-    $(_BIN)\TestConfig.exe
-
-MY_BIN6_OBJS = \
-    $(_OBJ)\TestConfig.obj
-
-MY_BIN6_LINKLIBS = \
-    $(SYS_ACETAO) \
-    $(LIB_MASSAI) \
-    $(LIB_MCORBA) \
-    $(LIB_MCFGCLNT)
-
-
-######################################################################
-
-!include $(BUILDROOT)\cpp\makefile.rules.mak
diff --git a/Massai/cpp/CfgClnt/src/mEventSemW32.cpp b/Massai/cpp/CfgClnt/src/mEventSemW32.cpp
deleted file mode 100644
index c135eba5..00000000
--- a/Massai/cpp/CfgClnt/src/mEventSemW32.cpp
+++ /dev/null
@@ -1,167 +0,0 @@
-/**
- **************************************************************************
- * 
- * @file mEventSemW32.cpp
- * 
- * Contains the implementation for the methods defined in mEventSem.hpp
- * for the Win32 platform.
- * 
- * @author JK
- * 
- * Copyright (c) 2002 MATERNA Information & Communications
- * 
- **************************************************************************
-**/
-
-#include "mEventsem.hpp"
-
-#include "windows.h"
-
-
-
-namespace Materna
-{
-   namespace MSSD
-   {
-      
-      class eventSemaphore_Handle
-      {
-         
-         HANDLE M_Hdl;
-         
-      public:
-
-         eventSemaphore_Handle();
-         
-         explicit eventSemaphore_Handle( char const * Name ) :
-            M_Hdl( CreateEvent( 0, TRUE, FALSE, Name ) )
-         {
-         }
-            
-         ~eventSemaphore_Handle()
-         {
-            CloseHandle( M_Hdl );
-            M_Hdl = 0;
-         }
-      
-         HANDLE winH() const
-         {
-            return M_Hdl;
-         }
-         
-      };
-      
-   }
-}
-
-
-
-using namespace Materna::MSSD;
-
-
-
-eventSemaphore::eventSemaphore() :
-   M_Handle( new eventSemaphore_Handle( 0 ) )
-{
-}
-
-
-
-eventSemaphore::eventSemaphore( char const * Name ) :
-   M_Handle( new eventSemaphore_Handle( Name ) )
-{
-}
-
-
-
-eventSemaphore::~eventSemaphore()
-{
-   delete M_Handle;
-}
-
-
-
-void eventSemaphore::wait()
-   throw( eventSemaphore_Exception )
-{
-   eventSemaphore_Handle * H = M_Handle;
-   if( !H )
-      throw eventSemaphore_Exception();
-   DWORD RC = WaitForSingleObject( H->winH(), INFINITE );
-   if( RC != WAIT_OBJECT_0 )
-      throw eventSemaphore_Exception();
-}
-
-
-
-int eventSemaphore::wait( long Time )
-   throw( eventSemaphore_Exception )
-{
-   eventSemaphore_Handle * H = M_Handle;
-   if( !H )
-      throw eventSemaphore_Exception();
-   DWORD RC = WaitForSingleObject( H->winH(), static_cast<DWORD>( Time ) );
-   if( RC == WAIT_OBJECT_0 )
-      return 0;
-   else
-      return static_cast<int>( RC );
-}
-
-
-
-int eventSemaphore::check()
-   throw( eventSemaphore_Exception )
-{
-   eventSemaphore_Handle * H = M_Handle;
-   if( !H )
-      throw eventSemaphore_Exception();
-   DWORD dwRc;
-   dwRc = WaitForSingleObject( H->winH(), 0 );
-   switch(dwRc)
-   {
-   case 0:
-      // posted state
-      return 0;
-   case WAIT_TIMEOUT:
-      // reset state
-      return 1;
-   default:
-      // error?
-      return 2;
-   }
-}
-
-
-
-void eventSemaphore::post()
-   throw( eventSemaphore_Exception )
-{
-   eventSemaphore_Handle * H = M_Handle;
-   if( !H )
-      throw eventSemaphore_Exception();
-   if( SetEvent( H->winH() ) == 0 )
-      throw eventSemaphore_Exception();
-}
-
-
-
-void eventSemaphore::reset()
-   throw( eventSemaphore_Exception )
-{
-   eventSemaphore_Handle * H = M_Handle;
-   if( !H )
-      throw eventSemaphore_Exception();
-   if( ResetEvent( H->winH() ) == 0 )
-      throw eventSemaphore_Exception();
-}
-
-
-
-/**
- **************************************************************************
- * 
- * End of file
- * 
- **************************************************************************
-**/
-
diff --git a/Massai/cpp/CfgClnt/src/mMutexSemW32.cpp b/Massai/cpp/CfgClnt/src/mMutexSemW32.cpp
deleted file mode 100644
index dd04c4c3..00000000
--- a/Massai/cpp/CfgClnt/src/mMutexSemW32.cpp
+++ /dev/null
@@ -1,130 +0,0 @@
-/**
- **************************************************************************
- *
- * @file mMutexSemW32.cpp
- * 
- * Contains the implementation for the methods defined in mMutexSem.hpp
- * for the Win32 platform.
- * 
- * @author JK
- * 
- * Copyright (c) 2002 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-
-#include "mMutexSem.hpp"
-
-#include "windows.h"
-
-
-
-namespace Materna
-{
-   namespace MSSD
-   {
-      
-      class mutexSemaphore_Handle
-      {
-         
-         HANDLE M_WinH;
-         
-      public:
-         
-         mutexSemaphore_Handle();
-         
-         explicit mutexSemaphore_Handle( char const * Name ) :
-            M_WinH( CreateMutex( 0, 0, Name ) )
-         {
-         }
-         
-         ~mutexSemaphore_Handle()
-         {
-            CloseHandle( M_WinH );
-            M_WinH = 0;
-         }
-
-         HANDLE winH() const
-         {
-            return M_WinH;
-         }
-         
-      };
-      
-   }
-}
-
-
-
-using namespace Materna::MSSD;
-
-
-
-mutexSemaphore::mutexSemaphore() :
-   M_Handle( new mutexSemaphore_Handle( 0 ) )
-{
-}
-
-
-
-mutexSemaphore::mutexSemaphore( char const * Name ) :
-   M_Handle( new mutexSemaphore_Handle( Name ) )
-{
-}
-
-
-
-mutexSemaphore::~mutexSemaphore()
-{
-   delete M_Handle;
-}
-
-
-
-void mutexSemaphore::request()
-   throw( mutexSemaphore_Exception )
-{
-   mutexSemaphore_Handle * H = M_Handle;
-   if( !H )
-      throw mutexSemaphore_Exception();
-   DWORD RC = WaitForSingleObject( H->winH(), INFINITE );
-   if( RC != WAIT_OBJECT_0 )
-      throw mutexSemaphore_Exception();
-}
-
-
-
-int mutexSemaphore::request( long Time )
-   throw( mutexSemaphore_Exception )
-{
-   mutexSemaphore_Handle * H = M_Handle;
-   if( !H )
-      throw mutexSemaphore_Exception();
-   DWORD RC = WaitForSingleObject( H->winH(), static_cast<DWORD>( Time ) );
-   if( RC == WAIT_OBJECT_0 )
-      return 0;
-   else
-      return static_cast<int>( RC );
-}
-
-
-
-void mutexSemaphore::release()
-   throw( mutexSemaphore_Exception )
-{
-   mutexSemaphore_Handle * H = M_Handle;
-   if( !H )
-      throw mutexSemaphore_Exception();
-   if( ReleaseMutex( H->winH() ) == 0 )
-      throw mutexSemaphore_Exception();
-}
-
-
-
-/**
- **************************************************************************
- * 
- * End of file
- * 
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgr/CfgMgr_Modules.mak b/Massai/cpp/CfgXMgr/CfgMgr_Modules.mak
deleted file mode 100644
index a0b3d83c..00000000
--- a/Massai/cpp/CfgXMgr/CfgMgr_Modules.mak
+++ /dev/null
@@ -1,31 +0,0 @@
-#
-# CfgMgr_Modules.mak
-#
-
-
-
-CfgMgr_Modules_OSBase =\
-   $(_OBJ)\Asso.obj\
-   $(_OBJ)\AssoCStr.obj\
-   $(_OBJ)\AssoFlat.obj\
-   $(_OBJ)\matThreadW32.obj\
-   $(_OBJ)\mEventSemW32.obj\
-   $(_OBJ)\mHRTimerW32.obj\
-   $(_OBJ)\mMutexSemW32.obj\
-   $(_OBJ)\mStringFile.obj\
-   $(_OBJ)\tcpCommW32.obj
-
-
-CfgMgr_Modules_DBCore =\
-   $(_OBJ)\CfgBase.obj\
-   $(_OBJ)\cfgdbi.obj\
-   $(_OBJ)\CfgFunc.obj\
-   $(_OBJ)\DBS_Sess.obj\
-   $(_OBJ)\DBS_Sync.obj\
-   $(_OBJ)\utils.obj\
-   $(_OBJ)\writeTrace.obj
-
-
-#
-# End of file
-#
diff --git a/Massai/cpp/CfgXMgr/GenHTML.dox b/Massai/cpp/CfgXMgr/GenHTML.dox
deleted file mode 100644
index 978238b1..00000000
--- a/Massai/cpp/CfgXMgr/GenHTML.dox
+++ /dev/null
@@ -1,1105 +0,0 @@
-# Doxyfile 1.3.2
-
-# This file describes the settings to be used by the documentation system
-# doxygen (www.doxygen.org) for a project
-#
-# All text after a hash (#) is considered a comment and will be ignored
-# The format is:
-#       TAG = value [value, ...]
-# For lists items can also be appended using:
-#       TAG += value [value, ...]
-# Values that contain spaces should be placed between quotes (" ")
-
-#---------------------------------------------------------------------------
-# General configuration options
-#---------------------------------------------------------------------------
-
-# The PROJECT_NAME tag is a single word (or a sequence of words surrounded 
-# by quotes) that should identify the project.
-
-PROJECT_NAME           = 
-
-# The PROJECT_NUMBER tag can be used to enter a project or revision number. 
-# This could be handy for archiving the generated documentation or 
-# if some version control system is used.
-
-PROJECT_NUMBER         = 
-
-# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) 
-# base path where the generated documentation will be put. 
-# If a relative path is entered, it will be relative to the location 
-# where doxygen was started. If left blank the current directory will be used.
-
-OUTPUT_DIRECTORY       = 
-
-# The OUTPUT_LANGUAGE tag is used to specify the language in which all 
-# documentation generated by doxygen is written. Doxygen will use this 
-# information to generate all constant output in the proper language. 
-# The default language is English, other supported languages are: 
-# Brazilian, Catalan, Chinese, Chinese-Traditional, Croatian, Czech, Danish, Dutch, 
-# Finnish, French, German, Greek, Hungarian, Italian, Japanese, Japanese-en 
-# (Japanese with English messages), Korean, Norwegian, Polish, Portuguese, 
-# Romanian, Russian, Serbian, Slovak, Slovene, Spanish, Swedish, and Ukrainian.
-
-OUTPUT_LANGUAGE        = English
-
-# This tag can be used to specify the encoding used in the generated output. 
-# The encoding is not always determined by the language that is chosen, 
-# but also whether or not the output is meant for Windows or non-Windows users. 
-# In case there is a difference, setting the USE_WINDOWS_ENCODING tag to YES 
-# forces the Windows encoding (this is the default for the Windows binary), 
-# whereas setting the tag to NO uses a Unix-style encoding (the default for 
-# all platforms other than Windows).
-
-USE_WINDOWS_ENCODING   = YES
-
-# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in 
-# documentation are documented, even if no documentation was available. 
-# Private class members and static file members will be hidden unless 
-# the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES
-
-EXTRACT_ALL            = NO
-
-# If the EXTRACT_PRIVATE tag is set to YES all private members of a class 
-# will be included in the documentation.
-
-EXTRACT_PRIVATE        = YES
-
-# If the EXTRACT_STATIC tag is set to YES all static members of a file 
-# will be included in the documentation.
-
-EXTRACT_STATIC         = YES
-
-# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs) 
-# defined locally in source files will be included in the documentation. 
-# If set to NO only classes defined in header files are included.
-
-EXTRACT_LOCAL_CLASSES  = YES
-
-# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all 
-# undocumented members of documented classes, files or namespaces. 
-# If set to NO (the default) these members will be included in the 
-# various overviews, but no documentation section is generated. 
-# This option has no effect if EXTRACT_ALL is enabled.
-
-HIDE_UNDOC_MEMBERS     = YES
-
-# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all 
-# undocumented classes that are normally visible in the class hierarchy. 
-# If set to NO (the default) these classes will be included in the various 
-# overviews. This option has no effect if EXTRACT_ALL is enabled.
-
-HIDE_UNDOC_CLASSES     = YES
-
-# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all 
-# friend (class|struct|union) declarations. 
-# If set to NO (the default) these declarations will be included in the 
-# documentation.
-
-HIDE_FRIEND_COMPOUNDS  = NO
-
-# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any 
-# documentation blocks found inside the body of a function. 
-# If set to NO (the default) these blocks will be appended to the 
-# function's detailed documentation block.
-
-HIDE_IN_BODY_DOCS      = NO
-
-# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will 
-# include brief member descriptions after the members that are listed in 
-# the file and class documentation (similar to JavaDoc). 
-# Set to NO to disable this.
-
-BRIEF_MEMBER_DESC      = YES
-
-# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend 
-# the brief description of a member or function before the detailed description. 
-# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the 
-# brief descriptions will be completely suppressed.
-
-REPEAT_BRIEF           = YES
-
-# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then 
-# Doxygen will generate a detailed section even if there is only a brief 
-# description.
-
-ALWAYS_DETAILED_SEC    = NO
-
-# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all inherited 
-# members of a class in the documentation of that class as if those members were 
-# ordinary class members. Constructors, destructors and assignment operators of 
-# the base classes will not be shown.
-
-INLINE_INHERITED_MEMB  = NO
-
-# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full 
-# path before files name in the file list and in the header files. If set 
-# to NO the shortest path that makes the file name unique will be used.
-
-FULL_PATH_NAMES        = NO
-
-# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag 
-# can be used to strip a user-defined part of the path. Stripping is 
-# only done if one of the specified strings matches the left-hand part of 
-# the path. It is allowed to use relative paths in the argument list.
-
-STRIP_FROM_PATH        = 
-
-# The INTERNAL_DOCS tag determines if documentation 
-# that is typed after a \internal command is included. If the tag is set 
-# to NO (the default) then the documentation will be excluded. 
-# Set it to YES to include the internal documentation.
-
-INTERNAL_DOCS          = NO
-
-# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate 
-# file names in lower-case letters. If set to YES upper-case letters are also 
-# allowed. This is useful if you have classes or files whose names only differ 
-# in case and if your file system supports case sensitive file names. Windows 
-# users are advised to set this option to NO.
-
-CASE_SENSE_NAMES       = YES
-
-# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter 
-# (but less readable) file names. This can be useful is your file systems 
-# doesn't support long names like on DOS, Mac, or CD-ROM.
-
-SHORT_NAMES            = NO
-
-# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen 
-# will show members with their full class and namespace scopes in the 
-# documentation. If set to YES the scope will be hidden.
-
-HIDE_SCOPE_NAMES       = NO
-
-# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen 
-# will put a list of the files that are included by a file in the documentation 
-# of that file.
-
-SHOW_INCLUDE_FILES     = YES
-
-# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen 
-# will interpret the first line (until the first dot) of a JavaDoc-style 
-# comment as the brief description. If set to NO, the JavaDoc 
-# comments will behave just like the Qt-style comments (thus requiring an 
-# explict @brief command for a brief description.
-
-JAVADOC_AUTOBRIEF      = YES
-
-# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen 
-# treat a multi-line C++ special comment block (i.e. a block of //! or /// 
-# comments) as a brief description. This used to be the default behaviour. 
-# The new default is to treat a multi-line C++ comment block as a detailed 
-# description. Set this tag to YES if you prefer the old behaviour instead.
-
-MULTILINE_CPP_IS_BRIEF = NO
-
-# If the DETAILS_AT_TOP tag is set to YES then Doxygen 
-# will output the detailed description near the top, like JavaDoc.
-# If set to NO, the detailed description appears after the member 
-# documentation.
-
-DETAILS_AT_TOP         = NO
-
-# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented 
-# member inherits the documentation from any documented member that it 
-# reimplements.
-
-INHERIT_DOCS           = YES
-
-# If the INLINE_INFO tag is set to YES (the default) then a tag [inline] 
-# is inserted in the documentation for inline members.
-
-INLINE_INFO            = YES
-
-# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen 
-# will sort the (detailed) documentation of file and class members 
-# alphabetically by member name. If set to NO the members will appear in 
-# declaration order.
-
-SORT_MEMBER_DOCS       = YES
-
-# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC 
-# tag is set to YES, then doxygen will reuse the documentation of the first 
-# member in the group (if any) for the other members of the group. By default 
-# all members of a group must be documented explicitly.
-
-DISTRIBUTE_GROUP_DOC   = NO
-
-# The TAB_SIZE tag can be used to set the number of spaces in a tab. 
-# Doxygen uses this value to replace tabs by spaces in code fragments.
-
-TAB_SIZE               = 8
-
-# The GENERATE_TODOLIST tag can be used to enable (YES) or 
-# disable (NO) the todo list. This list is created by putting \todo 
-# commands in the documentation.
-
-GENERATE_TODOLIST      = YES
-
-# The GENERATE_TESTLIST tag can be used to enable (YES) or 
-# disable (NO) the test list. This list is created by putting \test 
-# commands in the documentation.
-
-GENERATE_TESTLIST      = YES
-
-# The GENERATE_BUGLIST tag can be used to enable (YES) or 
-# disable (NO) the bug list. This list is created by putting \bug 
-# commands in the documentation.
-
-GENERATE_BUGLIST       = YES
-
-# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or 
-# disable (NO) the deprecated list. This list is created by putting 
-# \deprecated commands in the documentation.
-
-GENERATE_DEPRECATEDLIST= YES
-
-# This tag can be used to specify a number of aliases that acts 
-# as commands in the documentation. An alias has the form "name=value". 
-# For example adding "sideeffect=\par Side Effects:\n" will allow you to 
-# put the command \sideeffect (or @sideeffect) in the documentation, which 
-# will result in a user-defined paragraph with heading "Side Effects:". 
-# You can put \n's in the value part of an alias to insert newlines.
-
-ALIASES                = 
-
-# The ENABLED_SECTIONS tag can be used to enable conditional 
-# documentation sections, marked by \if sectionname ... \endif.
-
-ENABLED_SECTIONS       = 
-
-# The MAX_INITIALIZER_LINES tag determines the maximum number of lines 
-# the initial value of a variable or define consists of for it to appear in 
-# the documentation. If the initializer consists of more lines than specified 
-# here it will be hidden. Use a value of 0 to hide initializers completely. 
-# The appearance of the initializer of individual variables and defines in the 
-# documentation can be controlled using \showinitializer or \hideinitializer 
-# command in the documentation regardless of this setting.
-
-MAX_INITIALIZER_LINES  = 30
-
-# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources 
-# only. Doxygen will then generate output that is more tailored for C. 
-# For instance, some of the names that are used will be different. The list 
-# of all members will be omitted, etc.
-
-OPTIMIZE_OUTPUT_FOR_C  = NO
-
-# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java sources 
-# only. Doxygen will then generate output that is more tailored for Java. 
-# For instance, namespaces will be presented as packages, qualified scopes 
-# will look different, etc.
-
-OPTIMIZE_OUTPUT_JAVA   = NO
-
-# Set the SHOW_USED_FILES tag to NO to disable the list of files generated 
-# at the bottom of the documentation of classes and structs. If set to YES the 
-# list will mention the files that were used to generate the documentation.
-
-SHOW_USED_FILES        = YES
-
-#---------------------------------------------------------------------------
-# configuration options related to warning and progress messages
-#---------------------------------------------------------------------------
-
-# The QUIET tag can be used to turn on/off the messages that are generated 
-# by doxygen. Possible values are YES and NO. If left blank NO is used.
-
-QUIET                  = NO
-
-# The WARNINGS tag can be used to turn on/off the warning messages that are 
-# generated by doxygen. Possible values are YES and NO. If left blank 
-# NO is used.
-
-WARNINGS               = YES
-
-# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings 
-# for undocumented members. If EXTRACT_ALL is set to YES then this flag will 
-# automatically be disabled.
-
-WARN_IF_UNDOCUMENTED   = YES
-
-# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for 
-# potential errors in the documentation, such as not documenting some 
-# parameters in a documented function, or documenting parameters that 
-# don't exist or using markup commands wrongly.
-
-WARN_IF_DOC_ERROR      = YES
-
-# The WARN_FORMAT tag determines the format of the warning messages that 
-# doxygen can produce. The string should contain the $file, $line, and $text 
-# tags, which will be replaced by the file and line number from which the 
-# warning originated and the warning text.
-
-WARN_FORMAT            = "$file:$line: $text"
-
-# The WARN_LOGFILE tag can be used to specify a file to which warning 
-# and error messages should be written. If left blank the output is written 
-# to stderr.
-
-WARN_LOGFILE           = 
-
-#---------------------------------------------------------------------------
-# configuration options related to the input files
-#---------------------------------------------------------------------------
-
-# The INPUT tag can be used to specify the files and/or directories that contain 
-# documented source files. You may enter file names like "myfile.cpp" or 
-# directories like "/usr/src/myproject". Separate the files or directories 
-# with spaces.
-
-INPUT                  = Lib \
-                         Src
-
-# If the value of the INPUT tag contains directories, you can use the 
-# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
-# and *.h) to filter out the source-files in the directories. If left 
-# blank the following patterns are tested: 
-# *.c *.cc *.cxx *.cpp *.c++ *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh *.hxx *.hpp 
-# *.h++ *.idl *.odl *.cs
-
-FILE_PATTERNS          = *.h \
-                         *.hpp \
-                         *.c \
-                         *.cpp
-
-# The RECURSIVE tag can be used to turn specify whether or not subdirectories 
-# should be searched for input files as well. Possible values are YES and NO. 
-# If left blank NO is used.
-
-RECURSIVE              = NO
-
-# The EXCLUDE tag can be used to specify files and/or directories that should 
-# excluded from the INPUT source files. This way you can easily exclude a 
-# subdirectory from a directory tree whose root is specified with the INPUT tag.
-
-EXCLUDE                = 
-
-# The EXCLUDE_SYMLINKS tag can be used select whether or not files or directories 
-# that are symbolic links (a Unix filesystem feature) are excluded from the input.
-
-EXCLUDE_SYMLINKS       = NO
-
-# If the value of the INPUT tag contains directories, you can use the 
-# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude 
-# certain files from those directories.
-
-EXCLUDE_PATTERNS       = 
-
-# The EXAMPLE_PATH tag can be used to specify one or more files or 
-# directories that contain example code fragments that are included (see 
-# the \include command).
-
-EXAMPLE_PATH           = 
-
-# If the value of the EXAMPLE_PATH tag contains directories, you can use the 
-# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
-# and *.h) to filter out the source-files in the directories. If left 
-# blank all files are included.
-
-EXAMPLE_PATTERNS       = 
-
-# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be 
-# searched for input files to be used with the \include or \dontinclude 
-# commands irrespective of the value of the RECURSIVE tag. 
-# Possible values are YES and NO. If left blank NO is used.
-
-EXAMPLE_RECURSIVE      = NO
-
-# The IMAGE_PATH tag can be used to specify one or more files or 
-# directories that contain image that are included in the documentation (see 
-# the \image command).
-
-IMAGE_PATH             = 
-
-# The INPUT_FILTER tag can be used to specify a program that doxygen should 
-# invoke to filter for each input file. Doxygen will invoke the filter program 
-# by executing (via popen()) the command <filter> <input-file>, where <filter> 
-# is the value of the INPUT_FILTER tag, and <input-file> is the name of an 
-# input file. Doxygen will then use the output that the filter program writes 
-# to standard output.
-
-INPUT_FILTER           = 
-
-# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using 
-# INPUT_FILTER) will be used to filter the input files when producing source 
-# files to browse (i.e. when SOURCE_BROWSER is set to YES).
-
-FILTER_SOURCE_FILES    = NO
-
-#---------------------------------------------------------------------------
-# configuration options related to source browsing
-#---------------------------------------------------------------------------
-
-# If the SOURCE_BROWSER tag is set to YES then a list of source files will 
-# be generated. Documented entities will be cross-referenced with these sources.
-
-SOURCE_BROWSER         = NO
-
-# Setting the INLINE_SOURCES tag to YES will include the body 
-# of functions and classes directly in the documentation.
-
-INLINE_SOURCES         = NO
-
-# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct 
-# doxygen to hide any special comment blocks from generated source code 
-# fragments. Normal C and C++ comments will always remain visible.
-
-STRIP_CODE_COMMENTS    = YES
-
-# If the REFERENCED_BY_RELATION tag is set to YES (the default) 
-# then for each documented function all documented 
-# functions referencing it will be listed.
-
-REFERENCED_BY_RELATION = YES
-
-# If the REFERENCES_RELATION tag is set to YES (the default) 
-# then for each documented function all documented entities 
-# called/used by that function will be listed.
-
-REFERENCES_RELATION    = YES
-
-# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen 
-# will generate a verbatim copy of the header file for each class for 
-# which an include is specified. Set to NO to disable this.
-
-VERBATIM_HEADERS       = YES
-
-#---------------------------------------------------------------------------
-# configuration options related to the alphabetical class index
-#---------------------------------------------------------------------------
-
-# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index 
-# of all compounds will be generated. Enable this if the project 
-# contains a lot of classes, structs, unions or interfaces.
-
-ALPHABETICAL_INDEX     = NO
-
-# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then 
-# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns 
-# in which this list will be split (can be a number in the range [1..20])
-
-COLS_IN_ALPHA_INDEX    = 5
-
-# In case all classes in a project start with a common prefix, all 
-# classes will be put under the same header in the alphabetical index. 
-# The IGNORE_PREFIX tag can be used to specify one or more prefixes that 
-# should be ignored while generating the index headers.
-
-IGNORE_PREFIX          = 
-
-#---------------------------------------------------------------------------
-# configuration options related to the HTML output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_HTML tag is set to YES (the default) Doxygen will 
-# generate HTML output.
-
-GENERATE_HTML          = YES
-
-# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. 
-# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
-# put in front of it. If left blank `html' will be used as the default path.
-
-HTML_OUTPUT            = html
-
-# The HTML_FILE_EXTENSION tag can be used to specify the file extension for 
-# each generated HTML page (for example: .htm,.php,.asp). If it is left blank 
-# doxygen will generate files with .html extension.
-
-HTML_FILE_EXTENSION    = .html
-
-# The HTML_HEADER tag can be used to specify a personal HTML header for 
-# each generated HTML page. If it is left blank doxygen will generate a 
-# standard header.
-
-HTML_HEADER            = 
-
-# The HTML_FOOTER tag can be used to specify a personal HTML footer for 
-# each generated HTML page. If it is left blank doxygen will generate a 
-# standard footer.
-
-HTML_FOOTER            = 
-
-# The HTML_STYLESHEET tag can be used to specify a user-defined cascading 
-# style sheet that is used by each HTML page. It can be used to 
-# fine-tune the look of the HTML output. If the tag is left blank doxygen 
-# will generate a default style sheet
-
-HTML_STYLESHEET        = 
-
-# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes, 
-# files or namespaces will be aligned in HTML using tables. If set to 
-# NO a bullet list will be used.
-
-HTML_ALIGN_MEMBERS     = YES
-
-# If the GENERATE_HTMLHELP tag is set to YES, additional index files 
-# will be generated that can be used as input for tools like the 
-# Microsoft HTML help workshop to generate a compressed HTML help file (.chm) 
-# of the generated HTML documentation.
-
-GENERATE_HTMLHELP      = YES
-
-# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can 
-# be used to specify the file name of the resulting .chm file. You 
-# can add a path in front of the file if the result should not be 
-# written to the html output dir.
-
-CHM_FILE               = 
-
-# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can 
-# be used to specify the location (absolute path including file name) of 
-# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run 
-# the HTML help compiler on the generated index.hhp.
-
-HHC_LOCATION           = 
-
-# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag 
-# controls if a separate .chi index file is generated (YES) or that 
-# it should be included in the master .chm file (NO).
-
-GENERATE_CHI           = NO
-
-# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag 
-# controls whether a binary table of contents is generated (YES) or a 
-# normal table of contents (NO) in the .chm file.
-
-BINARY_TOC             = NO
-
-# The TOC_EXPAND flag can be set to YES to add extra items for group members 
-# to the contents of the HTML help documentation and to the tree view.
-
-TOC_EXPAND             = NO
-
-# The DISABLE_INDEX tag can be used to turn on/off the condensed index at 
-# top of each HTML page. The value NO (the default) enables the index and 
-# the value YES disables it.
-
-DISABLE_INDEX          = NO
-
-# This tag can be used to set the number of enum values (range [1..20]) 
-# that doxygen will group on one line in the generated HTML documentation.
-
-ENUM_VALUES_PER_LINE   = 4
-
-# If the GENERATE_TREEVIEW tag is set to YES, a side panel will be
-# generated containing a tree-like index structure (just like the one that 
-# is generated for HTML Help). For this to work a browser that supports 
-# JavaScript, DHTML, CSS and frames is required (for instance Mozilla 1.0+, 
-# Netscape 6.0+, Internet explorer 5.0+, or Konqueror). Windows users are 
-# probably better off using the HTML help feature.
-
-GENERATE_TREEVIEW      = NO
-
-# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be 
-# used to set the initial width (in pixels) of the frame in which the tree 
-# is shown.
-
-TREEVIEW_WIDTH         = 250
-
-#---------------------------------------------------------------------------
-# configuration options related to the LaTeX output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will 
-# generate Latex output.
-
-GENERATE_LATEX         = NO
-
-# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. 
-# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
-# put in front of it. If left blank `latex' will be used as the default path.
-
-LATEX_OUTPUT           = latex
-
-# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be 
-# invoked. If left blank `latex' will be used as the default command name.
-
-LATEX_CMD_NAME         = latex
-
-# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to 
-# generate index for LaTeX. If left blank `makeindex' will be used as the 
-# default command name.
-
-MAKEINDEX_CMD_NAME     = makeindex
-
-# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact 
-# LaTeX documents. This may be useful for small projects and may help to 
-# save some trees in general.
-
-COMPACT_LATEX          = NO
-
-# The PAPER_TYPE tag can be used to set the paper type that is used 
-# by the printer. Possible values are: a4, a4wide, letter, legal and 
-# executive. If left blank a4wide will be used.
-
-PAPER_TYPE             = a4wide
-
-# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX 
-# packages that should be included in the LaTeX output.
-
-EXTRA_PACKAGES         = 
-
-# The LATEX_HEADER tag can be used to specify a personal LaTeX header for 
-# the generated latex document. The header should contain everything until 
-# the first chapter. If it is left blank doxygen will generate a 
-# standard header. Notice: only use this tag if you know what you are doing!
-
-LATEX_HEADER           = 
-
-# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated 
-# is prepared for conversion to pdf (using ps2pdf). The pdf file will 
-# contain links (just like the HTML output) instead of page references 
-# This makes the output suitable for online browsing using a pdf viewer.
-
-PDF_HYPERLINKS         = NO
-
-# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of 
-# plain latex in the generated Makefile. Set this option to YES to get a 
-# higher quality PDF documentation.
-
-USE_PDFLATEX           = NO
-
-# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode. 
-# command to the generated LaTeX files. This will instruct LaTeX to keep 
-# running if errors occur, instead of asking the user for help. 
-# This option is also used when generating formulas in HTML.
-
-LATEX_BATCHMODE        = NO
-
-# If LATEX_HIDE_INDICES is set to YES then doxygen will not 
-# include the index chapters (such as File Index, Compound Index, etc.) 
-# in the output.
-
-LATEX_HIDE_INDICES     = NO
-
-#---------------------------------------------------------------------------
-# configuration options related to the RTF output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output 
-# The RTF output is optimised for Word 97 and may not look very pretty with 
-# other RTF readers or editors.
-
-GENERATE_RTF           = NO
-
-# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. 
-# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
-# put in front of it. If left blank `rtf' will be used as the default path.
-
-RTF_OUTPUT             = rtf
-
-# If the COMPACT_RTF tag is set to YES Doxygen generates more compact 
-# RTF documents. This may be useful for small projects and may help to 
-# save some trees in general.
-
-COMPACT_RTF            = NO
-
-# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated 
-# will contain hyperlink fields. The RTF file will 
-# contain links (just like the HTML output) instead of page references. 
-# This makes the output suitable for online browsing using WORD or other 
-# programs which support those fields. 
-# Note: wordpad (write) and others do not support links.
-
-RTF_HYPERLINKS         = NO
-
-# Load stylesheet definitions from file. Syntax is similar to doxygen's 
-# config file, i.e. a series of assigments. You only have to provide 
-# replacements, missing definitions are set to their default value.
-
-RTF_STYLESHEET_FILE    = 
-
-# Set optional variables used in the generation of an rtf document. 
-# Syntax is similar to doxygen's config file.
-
-RTF_EXTENSIONS_FILE    = 
-
-#---------------------------------------------------------------------------
-# configuration options related to the man page output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_MAN tag is set to YES (the default) Doxygen will 
-# generate man pages
-
-GENERATE_MAN           = NO
-
-# The MAN_OUTPUT tag is used to specify where the man pages will be put. 
-# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
-# put in front of it. If left blank `man' will be used as the default path.
-
-MAN_OUTPUT             = man
-
-# The MAN_EXTENSION tag determines the extension that is added to 
-# the generated man pages (default is the subroutine's section .3)
-
-MAN_EXTENSION          = .3
-
-# If the MAN_LINKS tag is set to YES and Doxygen generates man output, 
-# then it will generate one additional man file for each entity 
-# documented in the real man page(s). These additional files 
-# only source the real man page, but without them the man command 
-# would be unable to find the correct page. The default is NO.
-
-MAN_LINKS              = NO
-
-#---------------------------------------------------------------------------
-# configuration options related to the XML output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_XML tag is set to YES Doxygen will 
-# generate an XML file that captures the structure of 
-# the code including all documentation. Note that this 
-# feature is still experimental and incomplete at the 
-# moment.
-
-GENERATE_XML           = NO
-
-# The XML_OUTPUT tag is used to specify where the XML pages will be put. 
-# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
-# put in front of it. If left blank `xml' will be used as the default path.
-
-XML_OUTPUT             = xml
-
-# The XML_SCHEMA tag can be used to specify an XML schema, 
-# which can be used by a validating XML parser to check the 
-# syntax of the XML files.
-
-XML_SCHEMA             = 
-
-# The XML_DTD tag can be used to specify an XML DTD, 
-# which can be used by a validating XML parser to check the 
-# syntax of the XML files.
-
-XML_DTD                = 
-
-#---------------------------------------------------------------------------
-# configuration options for the AutoGen Definitions output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will 
-# generate an AutoGen Definitions (see autogen.sf.net) file 
-# that captures the structure of the code including all 
-# documentation. Note that this feature is still experimental 
-# and incomplete at the moment.
-
-GENERATE_AUTOGEN_DEF   = NO
-
-#---------------------------------------------------------------------------
-# configuration options related to the Perl module output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_PERLMOD tag is set to YES Doxygen will 
-# generate a Perl module file that captures the structure of 
-# the code including all documentation. Note that this 
-# feature is still experimental and incomplete at the 
-# moment.
-
-GENERATE_PERLMOD       = NO
-
-# If the PERLMOD_LATEX tag is set to YES Doxygen will generate 
-# the necessary Makefile rules, Perl scripts and LaTeX code to be able 
-# to generate PDF and DVI output from the Perl module output.
-
-PERLMOD_LATEX          = NO
-
-# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be 
-# nicely formatted so it can be parsed by a human reader.  This is useful 
-# if you want to understand what is going on.  On the other hand, if this 
-# tag is set to NO the size of the Perl module output will be much smaller 
-# and Perl will parse it just the same.
-
-PERLMOD_PRETTY         = YES
-
-# The names of the make variables in the generated doxyrules.make file 
-# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. 
-# This is useful so different doxyrules.make files included by the same 
-# Makefile don't overwrite each other's variables.
-
-PERLMOD_MAKEVAR_PREFIX = 
-
-#---------------------------------------------------------------------------
-# Configuration options related to the preprocessor   
-#---------------------------------------------------------------------------
-
-# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will 
-# evaluate all C-preprocessor directives found in the sources and include 
-# files.
-
-ENABLE_PREPROCESSING   = YES
-
-# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro 
-# names in the source code. If set to NO (the default) only conditional 
-# compilation will be performed. Macro expansion can be done in a controlled 
-# way by setting EXPAND_ONLY_PREDEF to YES.
-
-MACRO_EXPANSION        = NO
-
-# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES 
-# then the macro expansion is limited to the macros specified with the 
-# PREDEFINED and EXPAND_AS_PREDEFINED tags.
-
-EXPAND_ONLY_PREDEF     = NO
-
-# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files 
-# in the INCLUDE_PATH (see below) will be search if a #include is found.
-
-SEARCH_INCLUDES        = YES
-
-# The INCLUDE_PATH tag can be used to specify one or more directories that 
-# contain include files that are not input files but should be processed by 
-# the preprocessor.
-
-INCLUDE_PATH           = 
-
-# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard 
-# patterns (like *.h and *.hpp) to filter out the header-files in the 
-# directories. If left blank, the patterns specified with FILE_PATTERNS will 
-# be used.
-
-INCLUDE_FILE_PATTERNS  = 
-
-# The PREDEFINED tag can be used to specify one or more macro names that 
-# are defined before the preprocessor is started (similar to the -D option of 
-# gcc). The argument of the tag is a list of macros of the form: name 
-# or name=definition (no spaces). If the definition and the = are 
-# omitted =1 is assumed.
-
-PREDEFINED             = 
-
-# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then 
-# this tag can be used to specify a list of macro names that should be expanded. 
-# The macro definition that is found in the sources will be used. 
-# Use the PREDEFINED tag if you want to use a different macro definition.
-
-EXPAND_AS_DEFINED      = 
-
-# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then 
-# doxygen's preprocessor will remove all function-like macros that are alone 
-# on a line, have an all uppercase name, and do not end with a semicolon. Such 
-# function macros are typically used for boiler-plate code, and will confuse the 
-# parser if not removed.
-
-SKIP_FUNCTION_MACROS   = YES
-
-#---------------------------------------------------------------------------
-# Configuration::addtions related to external references   
-#---------------------------------------------------------------------------
-
-# The TAGFILES option can be used to specify one or more tagfiles. 
-# Optionally an initial location of the external documentation 
-# can be added for each tagfile. The format of a tag file without 
-# this location is as follows: 
-#   TAGFILES = file1 file2 ... 
-# Adding location for the tag files is done as follows: 
-#   TAGFILES = file1=loc1 "file2 = loc2" ... 
-# where "loc1" and "loc2" can be relative or absolute paths or 
-# URLs. If a location is present for each tag, the installdox tool 
-# does not have to be run to correct the links.
-# Note that each tag file must have a unique name
-# (where the name does NOT include the path)
-# If a tag file is not located in the directory in which doxygen 
-# is run, you must also specify the path to the tagfile here.
-
-TAGFILES               = 
-
-# When a file name is specified after GENERATE_TAGFILE, doxygen will create 
-# a tag file that is based on the input files it reads.
-
-GENERATE_TAGFILE       = 
-
-# If the ALLEXTERNALS tag is set to YES all external classes will be listed 
-# in the class index. If set to NO only the inherited external classes 
-# will be listed.
-
-ALLEXTERNALS           = NO
-
-# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed 
-# in the modules index. If set to NO, only the current project's groups will 
-# be listed.
-
-EXTERNAL_GROUPS        = YES
-
-# The PERL_PATH should be the absolute path and name of the perl script 
-# interpreter (i.e. the result of `which perl').
-
-PERL_PATH              = /usr/bin/perl
-
-#---------------------------------------------------------------------------
-# Configuration options related to the dot tool   
-#---------------------------------------------------------------------------
-
-# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will 
-# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base or 
-# super classes. Setting the tag to NO turns the diagrams off. Note that this 
-# option is superceded by the HAVE_DOT option below. This is only a fallback. It is 
-# recommended to install and use dot, since it yields more powerful graphs.
-
-CLASS_DIAGRAMS         = YES
-
-# If set to YES, the inheritance and collaboration graphs will hide 
-# inheritance and usage relations if the target is undocumented 
-# or is not a class.
-
-HIDE_UNDOC_RELATIONS   = YES
-
-# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is 
-# available from the path. This tool is part of Graphviz, a graph visualization 
-# toolkit from AT&T and Lucent Bell Labs. The other options in this section 
-# have no effect if this option is set to NO (the default)
-
-HAVE_DOT               = YES
-
-# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen 
-# will generate a graph for each documented class showing the direct and 
-# indirect inheritance relations. Setting this tag to YES will force the 
-# the CLASS_DIAGRAMS tag to NO.
-
-CLASS_GRAPH            = YES
-
-# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen 
-# will generate a graph for each documented class showing the direct and 
-# indirect implementation dependencies (inheritance, containment, and 
-# class references variables) of the class with other documented classes.
-
-COLLABORATION_GRAPH    = YES
-
-# If the UML_LOOK tag is set to YES doxygen will generate inheritance and 
-# colloborations diagrams in a style similiar to the OMG's Unified Modeling 
-# Language.
-
-UML_LOOK               = NO
-
-# If set to YES, the inheritance and collaboration graphs will show the 
-# relations between templates and their instances.
-
-TEMPLATE_RELATIONS     = NO
-
-# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT 
-# tags are set to YES then doxygen will generate a graph for each documented 
-# file showing the direct and indirect include dependencies of the file with 
-# other documented files.
-
-INCLUDE_GRAPH          = YES
-
-# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and 
-# HAVE_DOT tags are set to YES then doxygen will generate a graph for each 
-# documented header file showing the documented files that directly or 
-# indirectly include this file.
-
-INCLUDED_BY_GRAPH      = YES
-
-# If the CALL_GRAPH and HAVE_DOT tags are set to YES then doxygen will 
-# generate a call dependency graph for every global function or class method. 
-# Note that enabling this option will significantly increase the time of a run. 
-# So in most cases it will be better to enable call graphs for selected 
-# functions only using the \callgraph command.
-
-CALL_GRAPH             = NO
-
-# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen 
-# will graphical hierarchy of all classes instead of a textual one.
-
-GRAPHICAL_HIERARCHY    = YES
-
-# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images 
-# generated by dot. Possible values are png, jpg, or gif
-# If left blank png will be used.
-
-DOT_IMAGE_FORMAT       = png
-
-# The tag DOT_PATH can be used to specify the path where the dot tool can be 
-# found. If left blank, it is assumed the dot tool can be found on the path.
-
-DOT_PATH               = 
-
-# The DOTFILE_DIRS tag can be used to specify one or more directories that 
-# contain dot files that are included in the documentation (see the 
-# \dotfile command).
-
-DOTFILE_DIRS           = 
-
-# The MAX_DOT_GRAPH_WIDTH tag can be used to set the maximum allowed width 
-# (in pixels) of the graphs generated by dot. If a graph becomes larger than 
-# this value, doxygen will try to truncate the graph, so that it fits within 
-# the specified constraint. Beware that most browsers cannot cope with very 
-# large images.
-
-MAX_DOT_GRAPH_WIDTH    = 1024
-
-# The MAX_DOT_GRAPH_HEIGHT tag can be used to set the maximum allows height 
-# (in pixels) of the graphs generated by dot. If a graph becomes larger than 
-# this value, doxygen will try to truncate the graph, so that it fits within 
-# the specified constraint. Beware that most browsers cannot cope with very 
-# large images.
-
-MAX_DOT_GRAPH_HEIGHT   = 1024
-
-# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the 
-# graphs generated by dot. A depth value of 3 means that only nodes reachable 
-# from the root by following a path via at most 3 edges will be shown. Nodes that 
-# lay further from the root node will be omitted. Note that setting this option to 
-# 1 or 2 may greatly reduce the computation time needed for large code bases. Also 
-# note that a graph may be further truncated if the graph's image dimensions are 
-# not sufficient to fit the graph (see MAX_DOT_GRAPH_WIDTH and MAX_DOT_GRAPH_HEIGHT). 
-# If 0 is used for the depth value (the default), the graph is not depth-constrained.
-
-MAX_DOT_GRAPH_DEPTH    = 0
-
-# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will 
-# generate a legend page explaining the meaning of the various boxes and 
-# arrows in the dot generated graphs.
-
-GENERATE_LEGEND        = YES
-
-# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will 
-# remove the intermediate dot files that are used to generate 
-# the various graphs.
-
-DOT_CLEANUP            = YES
-
-#---------------------------------------------------------------------------
-# Configuration::addtions related to the search engine   
-#---------------------------------------------------------------------------
-
-# The SEARCHENGINE tag specifies whether or not a search engine should be 
-# used. If set to NO the values of all tags below this one will be ignored.
-
-SEARCHENGINE           = NO
-
-# The CGI_NAME tag should be the name of the CGI script that 
-# starts the search engine (doxysearch) with the correct parameters. 
-# A script with this name will be generated by doxygen.
-
-CGI_NAME               = search.cgi
-
-# The CGI_URL tag should be the absolute URL to the directory where the 
-# cgi binaries are located. See the documentation of your http daemon for 
-# details.
-
-CGI_URL                = 
-
-# The DOC_URL tag should be the absolute URL to the directory where the 
-# documentation is located. If left blank the absolute path to the 
-# documentation, with file:// prepended to it, will be used.
-
-DOC_URL                = 
-
-# The DOC_ABSPATH tag should be the absolute path to the directory where the 
-# documentation is located. If left blank the directory on the local machine 
-# will be used.
-
-DOC_ABSPATH            = 
-
-# The BIN_ABSPATH tag must point to the directory where the doxysearch binary 
-# is installed.
-
-BIN_ABSPATH            = /usr/local/bin/
-
-# The EXT_DOC_PATHS tag can be used to specify one or more paths to 
-# documentation generated for other projects. This allows doxysearch to search 
-# the documentation for these projects as well.
-
-EXT_DOC_PATHS          = 
diff --git a/Massai/cpp/CfgXMgr/inc/ASSOCP.H b/Massai/cpp/CfgXMgr/inc/ASSOCP.H
deleted file mode 100644
index fde1d998..00000000
--- a/Massai/cpp/CfgXMgr/inc/ASSOCP.H
+++ /dev/null
@@ -1,18 +0,0 @@
-
-#ifndef ASSOCP_H
-#define ASSOCP_H
-
-//
-// ASSOCP.H
-//
-// Interface file for ~\ALL\TOOLS\ASSOCP.CPP
-//
-// deep copy for asso
-//
-
-#include "asso.h"
-
-aMap& copyMap(aMap& Dst, const aMap& Src);
-
-#endif
-
diff --git a/Massai/cpp/CfgXMgr/inc/CfgBase.h b/Massai/cpp/CfgXMgr/inc/CfgBase.h
deleted file mode 100644
index 64ed5e6e..00000000
--- a/Massai/cpp/CfgXMgr/inc/CfgBase.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/**
- **************************************************************************
- * 
- * @file CfgBase.h
- * 
- * Declares functions exported by CfgBase.cpp
- * 
- * @author Maz, JK
- * 
- * Copyright (c) 1997-2001 MATERNA Information & Communications
- * 
- **************************************************************************
-**/
-#ifndef CFGBASE_H
-#define CFGBASE_H
-
-#include "Asso.h"
-#include <iostream>
-
-void           cfgFileName( char const * );
-char const *   cfgFileName();
-long           cfgFileRead( char const * );
-long           cfgFileWrite( char const * );
-
-long           freeConfiguration();
-
-aMap *         getCfgDB();
-
-void           addUpdList( const aMap& iData );
-void           clrUpdList();
-aMap *         getUpdList();
-
-void           addOldList( const aMap& iData );
-void           clrOldList();
-long           getOldListEntry( const aMap& iData, aMap& oData );
-
-long           clrRejectData( const aMap& iData, aMap& oData );
-long           setRejectData( const aMap& iData, aMap& oData, long fSet );
-long           isRejected( const aMap& iData );
-
-long           updateValue( aMap& iData );
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- * 
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgr/inc/CfgFunc.h b/Massai/cpp/CfgXMgr/inc/CfgFunc.h
deleted file mode 100644
index da6e5670..00000000
--- a/Massai/cpp/CfgXMgr/inc/CfgFunc.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/**
- **************************************************************************
- * 
- * @file CfgFunc.h
- * 
- * Declares exports of CfgFunc.cpp
- * 
- * @author Maz, JK
- * 
- * Copyright (c) 1997-2001 MATERNA Information & Communications
- * 
- **************************************************************************
-**/
-#ifndef DB_CFGFUNC_H
-#define DB_CFGFUNC_H
-
-long cfgFunc_DBStatus     ( aMap const & In, aMap & Out );
-
-long cfgFunc_Delete       ( aMap const & In );
-
-long cfgFunc_Directory    ( aMap const & In, aMap & Out );
-
-long cfgFunc_Item         ( aMap const & In, aMap & Out );
-
-long cfgFunc_Kiosks       ( aMap const & In, aMap & Out );
-
-long cfgFunc_List         ( aMap const & In, aMap & Out );
-
-long cfgFunc_ModifyData   ( aMap const & In, char const * Date );
-
-long cfgFunc_OldItem      ( aMap const & In, aMap & Out );
-
-long cfgFunc_SimilarList  ( aMap const & In, aMap & Out );
-
-long cfgFunc_Update       ( aMap const & In );
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- * 
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgr/inc/CfgMCnt.hpp b/Massai/cpp/CfgXMgr/inc/CfgMCnt.hpp
deleted file mode 100644
index fe2fa4d3..00000000
--- a/Massai/cpp/CfgXMgr/inc/CfgMCnt.hpp
+++ /dev/null
@@ -1,31 +0,0 @@
-/**
- **************************************************************************
- * 
- * @file CfgMCnt.hpp
- * 
- **************************************************************************
-**/
-
-#include "Asso.h"
-
-/**
- * 
- * Insert COUNT keys in the map.
- * 
-**/
-void cfgMCnt_Insert( aMap &, aMap const & );
-
-/**
- * 
- * Remove COUNT keys from the map.
- * 
-**/
-void cfgMCnt_Remove( aMap &, aMap const & );
-
-/**
- **************************************************************************
- * 
- * End of file
- * 
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgr/inc/CfgMgrStrings.h b/Massai/cpp/CfgXMgr/inc/CfgMgrStrings.h
deleted file mode 100644
index 94232439..00000000
--- a/Massai/cpp/CfgXMgr/inc/CfgMgrStrings.h
+++ /dev/null
@@ -1,85 +0,0 @@
-/**
- **************************************************************************
- * 
- * @file CfgMgrStrings.h
- * 
- * Contains CfgMgr string constants.
- * 
- **************************************************************************
-**/
-#ifndef CFGMGRSTRINGS_H
-#define CFGMGRSTRINGS_H
-
-//
-// Config names - Values
-//
-static const char DB_Values_SuperSec[]        = "GLOBALS";
-static const char DB_Values_SubSuperSec[]     = "VALUES";
-static const char DB_Client_SuperSec[]        = "LOCALS";
-
-//
-// Config names - Descriptions
-// Subsupersection, Section and Subsection from application
-//
-static const char DB_Descr_SuperSec[]         = "DESCRIPTIONS";
-
-//
-// Description entries
-//
-static const char DB_Descr_AccessL[]          = "AccessL";
-static const char DB_Descr_ChangeMode[]       = "Change-Mode";
-static const char DB_Descr_Default[]          = "Default";
-static const char DB_Descr_Global[]           = "Global";
-static const char DB_Descr_LongDescription[]  = "Long-Description";
-static const char DB_Descr_Range[]            = "Range";
-static const char DB_Descr_RangeComment[]     = "RangeComment";
-static const char DB_Descr_RangeInteger[]     = "RangeInteger";
-static const char DB_Descr_ShortDescription[] = "Short-Description";
-static const char DB_Descr_Type[]             = "Type";
-
-//
-// Config names - Environment
-//
-static const char DB_Environ_SuperSec[]       = "INTERNAL";
-static const char DB_Environ_SubSuperSec[]    = "DATA";
-   //
-   // Section, Subsection for THIS
-   //
-static const char DB_Environ_Sec_This[]       = "THIS";
-static const char DB_Environ_SubSec_This[]    = "ENVIRONMENT";
-   //
-   // Section, Item for CLIENTS
-   // Subsection is client name
-   //
-static const char DB_Environ_Sec_Clients[]    = "CLIENTS";
-static const char DB_Environ_Itm_ClientLink[] = "MasterLink";
-
-//
-// Config values
-//
-static const char DB_Value_On[]               = "ON";
-static const char DB_Value_Off[]              = "OFF";
-
-//
-// Low-level communication
-//
-static const char DB_LOGIN_Host[]             = "CLIENT_HOST_ADDR";
-static const char DB_LOGIN_Name[]             = "NAME";
-static const char DB_LOGIN_Session[]          = "SESSION";
-static const char DB_LOGIN_Version[]          = "VERSION";
-
-//
-// Low-level state reply
-//
-static const char DB_STATE_Sessions[]         = "Sessions";
-static const char DB_STATE_Version[]          = "Version";
-static const char DB_STATE_Started[]          = "Started";
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- * 
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgr/inc/CfgXML.hpp b/Massai/cpp/CfgXMgr/inc/CfgXML.hpp
deleted file mode 100644
index ce1bfeab..00000000
--- a/Massai/cpp/CfgXMgr/inc/CfgXML.hpp
+++ /dev/null
@@ -1,18 +0,0 @@
-/**
- * 
- * @file CfgXML.hpp
- * 
- */
-#ifndef CFGXML_HPP
-#define CFGXML_HPP
-
-#include "Asso.h"
-
-void cfgXML_Delete();
-void cfgXML_Read();
-void cfgXML_SetFile( char const * );
-void cfgXML_SetFileBackup( char const * );
-void cfgXML_Write();
-
-#endif
-
diff --git a/Massai/cpp/CfgXMgr/inc/CfgXMgr_def.h b/Massai/cpp/CfgXMgr/inc/CfgXMgr_def.h
deleted file mode 100644
index 581bdd5a..00000000
--- a/Massai/cpp/CfgXMgr/inc/CfgXMgr_def.h
+++ /dev/null
@@ -1,12 +0,0 @@
-#define IDI_ICON1 101
-#define IDI_ICON2 102
-
-#define FILE_VER_BIN     1,0,0,0
-#define FILE_VER_STR     "FileVersion", "1.0.0.0\0"
-
-#define FILEDESCRIPTION  "FileDescription"  ,"CfgXMgr\0"
-#define INTERNALNAME     "InternalName"     ,"CfgXMgr\0"
-#define LEGALTRADEMARKS  "LegalTrademarks"  ,"\0"
-#define ORIGINALFILENAME "OriginalFilename" ,"CfgXMgr.exe\0"
-
-
diff --git a/Massai/cpp/CfgXMgr/inc/DBS_Node.hpp b/Massai/cpp/CfgXMgr/inc/DBS_Node.hpp
deleted file mode 100644
index 0c47abb2..00000000
--- a/Massai/cpp/CfgXMgr/inc/DBS_Node.hpp
+++ /dev/null
@@ -1,149 +0,0 @@
-/**
- **************************************************************************
- *
- * @file DBS_Node.hpp
- *
- * Interface file for DBS_Node.cpp
- *
- * @author JK
- *
- * Copyright (c) 2000-2001 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef DBS_NODE_HPP
-#define DBS_NODE_HPP
-
-#ifdef _ORBACUS_
-#include <ob/corba.h>
-#include "CfgMgr_skel.h"
-#endif
-
-#ifdef _TAO_
-#include "CfgMgr.h"
-#include "CfgMgr_skel.h"
-#include "CfgMgr_skel_T.h"
-#endif
-
-#include "asso.h"
-
-
-
-/**
- *
- * Configuration has changed
- *
- */
-void nodeChange( char const * );
-
-/**
- *
- * Release DBS_Node resources
- *
- */
-void nodeExit();
-
-/**
- *
- * Initialize DBS_Node module.
- *
- */
-void nodeInit();
-
-/**
- *
- * Token parser in description
- *
- * @param 1. The destination string
- *
- * @param 2. The source description
- *
- * @param 4. The option pattern (if any)
- *
- */
-void nodeParse
-(
-   std::string &,
-   char const *,
-   char const * = 0
-);
-
-/**
- **************************************************************************
- *
- * CfgMgr CORBA services base class
- *
- **************************************************************************
-**/
-class serviceCfgNode
-{
-
-protected:
-
-   void addChangeListener
-   (
-      Config::access const &,
-      Config::changeListener *
-   );
-
-   void removeChangeListener
-   (
-      Config::changeListener *
-   );
-
-   void removeChangeListenerItem
-   (
-      Config::changeListener *,
-      char const *
-   );
-
-   int nodeCommit();
-
-   void nodeCreate
-   (
-      aMap &,
-      Config::access const &,
-      Config::description const &
-   );
-
-   void nodeCreate
-   (
-      aMap &,
-      Config::access const &
-   );
-
-   int nodeRequest
-   (
-      Config::access const &,
-      aMap &,
-      aMap &
-   );
-
-   int nodeGetValue
-   (
-      Config::access const &,
-      aObject &
-   );
-
-   int nodeSetInitial
-   (
-      Config::access const &,
-      aObject const &
-   );
-
-   int nodeSetValue
-   (
-      Config::access const &,
-      aObject const &
-   );
-
-};
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgr/inc/DBS_Serv.hpp b/Massai/cpp/CfgXMgr/inc/DBS_Serv.hpp
deleted file mode 100644
index 1279865c..00000000
--- a/Massai/cpp/CfgXMgr/inc/DBS_Serv.hpp
+++ /dev/null
@@ -1,15 +0,0 @@
-//-------------------------------------------------------------------------
-//
-// DBS_Serv.hpp
-//
-//-------------------------------------------------------------------------
-
-#include "asso.h"
-
-int servIndication( const aMap & Indication );
-int servMain( int argc, char ** argv );
-int servCleanUp();
-
-//-------------------------------------------------------------------------
-// End of file
-//-------------------------------------------------------------------------
diff --git a/Massai/cpp/CfgXMgr/inc/DBS_Sess.hpp b/Massai/cpp/CfgXMgr/inc/DBS_Sess.hpp
deleted file mode 100644
index 0f77d5bc..00000000
--- a/Massai/cpp/CfgXMgr/inc/DBS_Sess.hpp
+++ /dev/null
@@ -1,16 +0,0 @@
-
-//
-// dbs_sess.hpp
-//
-#ifndef DBS_SESS_HPP
-#define DBS_SESS_HPP
-
-#include "asso.h"
-
-int sessIndication( const aMap & Indication );
-int sessMain();
-int sessCleanUp();  //  ts 13.1.1999 Delete Objects Free Memory for ShutDown
-
-
-#endif
-
diff --git a/Massai/cpp/CfgXMgr/inc/DBS_Sync.hpp b/Massai/cpp/CfgXMgr/inc/DBS_Sync.hpp
deleted file mode 100644
index 551546ad..00000000
--- a/Massai/cpp/CfgXMgr/inc/DBS_Sync.hpp
+++ /dev/null
@@ -1,86 +0,0 @@
-/**
- **************************************************************************
- *
- * @file DBS_Sync.hpp
- *
- * Contains prototypes for functions exported by DBS_Sync.cpp
- *
- * @author JK, TS
- *
- * Copyright (c) 1998-2003 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-
-//! Popular parameter class
-class aMap;
-
-/**
- *
- * DB request.
- *
- * @param IData:       Request input.
- *
- * @param OData:      Request output.
- *
- * @return 0, if success.
- *
-**/
-long syncReq        ( aMap const & IData, aMap& OData );
-
-/**
- *
- * DB request for master.
- *
- * @param IData:       Request input.
- *
- * @param OData:      Request output.
- *
- * @return 0, if success.
- *
-**/
-long syncReq_Master ( aMap const & OData, aMap& IData );
-
-/**
- *
- * Create DB.
- *
- * @return 0, if success.
- *
-**/
-int  syncCreate     ();
-
-/**
- *
- * Delete DB objects for shutDown.
- *
- * @return 0, if success.
- *
-**/
-int  syncDelete     ();
-
-/**
- *
- * Disable DB access.
- *
- * Should be followed by syncEnable() soon.
- *
-**/
-void syncDisable    ();
-
-/**
- *
- * Enable DB access.
- *
- * Must be preceeded by syncDisable().
- *
-**/
-void syncEnable     ();
-
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgr/inc/DBX_Comm.hpp b/Massai/cpp/CfgXMgr/inc/DBX_Comm.hpp
deleted file mode 100644
index 2d67668e..00000000
--- a/Massai/cpp/CfgXMgr/inc/DBX_Comm.hpp
+++ /dev/null
@@ -1,297 +0,0 @@
- 
-//
-// DBX_COMM.HPP
-//
-#ifndef DBX_COMM_HPP
-#define DBX_COMM_HPP
-
-#include "tcpcomm.h"
-#include "asso.h"
-#include "assoFlat.hpp"
-#include "version.h"
-#include "CfgMgrStrings.h"
-#include <iostream.h>
-
-#define COMM_IP_SERVICE            "cfgdb"
-#define COMM_IP_PORT               2100
-
-#define COMM_KEY                0xdbcbd
-#define COMM_VERSION            0
-
-#define COMM_TYPE_NONE          'n'
-#define COMM_TYPE_ERR_RSP       '?'
-#define COMM_TYPE_OBJ_REQ       'Q'
-#define COMM_TYPE_OBJ_RSP       'R'
-#define COMM_TYPE_OBJ_IND       'I'
-#define COMM_TYPE_CMD_IND       'i'
-#define COMM_TYPE_CMD_LOGIN     'l'
-#define COMM_TYPE_CMD_STATUS    't'
-#define COMM_TYPE_CMD_RSP       'r'
-#define COMM_TYPE_CMD_SHUTDOWN  's'
-
-#define COMM_CODE_CMD_TRACE_OFF 't'
-#define COMM_CODE_CMD_TRACE_ON  'T'
-
-#define COMM_HEADER_LENGTH      8
-#define COMM_MAX_NAME           127
-
-class cfgComm;
-
-class cfgCommBuffer
-{
-   // offset 0
-   long     _Sync;                 // 0
-   short    _Version;              // 4
-   char     _Type;                 // 6
-   char     _Code;                 // 6
-   // offset 8
-   aMap     _Mapdata;
-public:
-   cfgCommBuffer()
-            {
-               _Sync = 0;
-               _Version = COMM_VERSION;
-               _Type = COMM_TYPE_NONE;
-               _Code = 0;
-            }
-   cfgCommBuffer( char SrcType, char SrcCode )
-            {
-               _Sync = COMM_KEY;
-               _Version = COMM_VERSION;
-               _Type = SrcType;
-               _Code = SrcCode;
-            }
-
-   cfgCommBuffer( char SrcType, char SrcCode, const aMap & Src )
-            {
-               _Sync = COMM_KEY;
-               _Version = COMM_VERSION;
-               _Type = SrcType;
-               _Code = SrcCode;
-               _Mapdata = Src;
-            }
-
-   int valid()
-            {
-               return _Sync == COMM_KEY;
-            }
-
-   char     type() const
-            {
-               return _Type;
-            }
-
-   char     code() const
-            {
-               return _Code;
-            }
-
-   aMap & data()
-            {
-               return _Mapdata;
-            }
-
-   aMap & data_c() const
-            {
-               return (aMap &)_Mapdata;
-            }
-
-
-   friend class cfgComm;
-};
-
-struct COMBUFSTRUCT
-{
-   long     _Sync;                 // 0
-   short    _Version;              // 4
-   char     _Type;                 // 6
-   char     _Code;                 // 7
-   long     _Length;               // 8
-   char     FlatData[4];           // 12
-};
-#define COMBUFLEN 12
-
-class cfgComm : public tcpComm
-{
-   long       _Openerr;
-   ostream *  _pTrace;
-   char       _CurrentReqId;
-
-public:
-
-   cfgComm( const char * Host )
-   : tcpComm( COMM_IP_SERVICE, Host )
-   {
-      _Openerr = 0;
-      _pTrace = 0;
-      _CurrentReqId = 0;
-   }
-
-   cfgComm()
-   : tcpComm( COMM_IP_SERVICE )
-   {
-      _Openerr = 0;
-      _pTrace = 0;
-      _CurrentReqId = 0;
-   }
-
-   cfgComm( const char * Host, long DirectPort )
-   : tcpComm( COMM_IP_PORT, Host )
-   {
-      _Openerr = 0;
-      _pTrace = 0;
-      _CurrentReqId = 0;
-   }
-
-   cfgComm( long DirectPort )
-   : tcpComm( COMM_IP_PORT )
-   {
-      _Openerr = 0;
-      _pTrace = 0;
-      _CurrentReqId = 0;
-   }
-
-   long open( long retry = 0 )
-   {
-      _Openerr = tcpComm::open( retry );
-      return _Openerr;
-   }
-
-   long open( char szA[16], char szN[128], long retry = 0 )
-   {
-      _Openerr = tcpComm::open( szA, szN, retry );
-      return _Openerr;
-   }
-
-   void setTrace( ostream * pStr )
-   {
-      _pTrace = pStr;
-   }
-
-   int read( cfgCommBuffer & Dst )
-   {
-      if( !_Openerr )
-      {
-         long rc;
-         COMBUFSTRUCT RxHeader;
-         rc = tcpComm::read( (char *)&RxHeader, COMBUFLEN);
-         if(rc)
-         {
-            if( _pTrace )
-            {
-               *_pTrace << "cfgComm::read tcpComm::read()=" << rc << endl;
-            }
-            return 7;
-         }
-         Dst._Sync    = RxHeader._Sync;
-         Dst._Version = RxHeader._Version;
-         Dst._Type    = RxHeader._Type;
-         Dst._Code    = RxHeader._Code;
-         if( _pTrace )
-         {
-            *_pTrace << "cfgComm::read typ=" << RxHeader._Type
-                                  << " cod=" << (int)RxHeader._Code
-                                  << " len=" << RxHeader._Length
-                                  << endl;
-         }
-         if( Dst.valid() )
-         {
-            if( RxHeader._Length )
-            {
-               char *pBuffer = new char[ RxHeader._Length ];
-               char const *pB = pBuffer;
-               rc = tcpComm::read( pBuffer, RxHeader._Length );
-               aObject * pO = assoFlatNew( pB, pB + RxHeader._Length  );
-               if( pO )
-               {
-                  Dst.data() = pO->mapObject();
-                  delete pO;
-               }
-               delete pBuffer;
-            }
-            if( !rc )
-               return 0;
-            else
-               return 7;
-         }
-         else
-            return 7;
-      }
-      else
-      {
-         if( _pTrace )
-         {
-            *_pTrace << "cfgComm::read - ignored" << endl;
-         }
-         return 7;
-      }
-   }
-
-   int write( const cfgCommBuffer & Src )
-   {
-      if( !_Openerr )
-      {
-         long SrcLength = assoFlatSize( Src.data_c() );
-         char *pFlt = new char[ COMBUFLEN + SrcLength ];
-         COMBUFSTRUCT * pData = ( COMBUFSTRUCT *) pFlt;
-         pData->_Sync    =  Src._Sync;
-         pData->_Version =  Src._Version;
-         pData->_Type    =  Src._Type;
-         pData->_Code    =  Src._Code;
-         pData->_Length  = SrcLength;
-         char * pFlat = pData->FlatData;
-         assoFlatCopy( pFlat, pFlat + pData->_Length, Src.data_c() );
-         long rc = tcpComm::writeblocking( pFlt, COMBUFLEN + pData->_Length);
-         if( rc )
-         {
-            if( _pTrace )
-            {
-               *_pTrace << "cfgComm::write tcpComm::write()=" << rc << endl;
-            }
-         }
-         else
-         {
-            if( _pTrace )
-            {
-               *_pTrace << "cfgComm::write typ=" << Src._Type
-                                      << " cod=" << (int)Src._Code
-                                      << " len=" << SrcLength
-                                      << endl;
-            }
-         }
-         delete pFlt;
-         return 0;
-      }
-      else
-      {
-         if( _pTrace )
-         {
-            *_pTrace << "cfgComm::write - ignored" << endl;
-         }
-         return 7;
-      }
-   }
-
-   int writeLogin( const char * Name, const char * Origin )
-   {
-      aMap Loginreq;
-      Loginreq.set( DB_LOGIN_Version, GET_VERSION() );
-      Loginreq.set( DB_LOGIN_Name, Name );
-      if( Origin && *Origin)
-         Loginreq.set( DB_LOGIN_Host, Origin );
-      cfgCommBuffer Login( COMM_TYPE_CMD_LOGIN, 0, Loginreq );
-      return write( Login );
-   }
-
-   int writeRequest( const aMap& iData )
-   {
-      ++_CurrentReqId;
-      cfgCommBuffer Request( COMM_TYPE_OBJ_REQ, _CurrentReqId, iData );
-      return write( Request );
-   }
-
-};
-
-#endif
-
-
diff --git a/Massai/cpp/CfgXMgr/inc/DEBUGMAP.hpp b/Massai/cpp/CfgXMgr/inc/DEBUGMAP.hpp
deleted file mode 100644
index a9060aaa..00000000
--- a/Massai/cpp/CfgXMgr/inc/DEBUGMAP.hpp
+++ /dev/null
@@ -1,18 +0,0 @@
-#ifndef DEBUGMAP_HPP
-#define DEBUGMAP_HPP
-
-#include "TraceClt.h"
-
-void writeTraceMap
-(
-   long Lev, char const * Mod, short Lin, char const * Fun,
-   char const * Title, aMap const & Map
-);
-
-#define DEBUGMAP( TIT, MAP )\
-{\
-   char __FUNCTION__[] = "DEBUGMAP";\
-   writeTraceMap( SecondaryRuntime_HERE, TIT, MAP );\
-}
-
-#endif
diff --git a/Massai/cpp/CfgXMgr/inc/MassaiCfgX_def.h b/Massai/cpp/CfgXMgr/inc/MassaiCfgX_def.h
deleted file mode 100644
index 9d6ed236..00000000
--- a/Massai/cpp/CfgXMgr/inc/MassaiCfgX_def.h
+++ /dev/null
@@ -1,12 +0,0 @@
-#define IDI_ICON1 101
-#define IDI_ICON2 102
-
-#define FILE_VER_BIN     1,0,0,0
-#define FILE_VER_STR     "FileVersion", "1.0.0.0\0"
-
-#define FILEDESCRIPTION  "FileDescription"  ,"MassaiCfgX\0"
-#define INTERNALNAME     "InternalName"     ,"MassaiCfgX\0"
-#define LEGALTRADEMARKS  "LegalTrademarks"  ,"\0"
-#define ORIGINALFILENAME "OriginalFilename" ,"MassaiCfgX.exe\0"
-
-
diff --git a/Massai/cpp/CfgXMgr/inc/UTILS.HPP b/Massai/cpp/CfgXMgr/inc/UTILS.HPP
deleted file mode 100644
index ed16efb1..00000000
--- a/Massai/cpp/CfgXMgr/inc/UTILS.HPP
+++ /dev/null
@@ -1,38 +0,0 @@
-#ifndef UTILS_HPP
-#define UTILS_HPP
-#include "asso.h"
-#include "stlist.hpp"
-#include "ststring.hpp"
-
-
-// is usable only for maps without any maps included!!!
-
-class aSortedMap : public aMap
-{
-  stSortableList<stString> *pList;
-  stListCursor<stString> *pListC;
-  
-
-  // hide copy constructor and assignment operator
-  aSortedMap(const aSortedMap&){};
-  aSortedMap& operator=(const aSortedMap&){ return *this;}
-
-protected:
-
-   void insert(const stString& str);
-   void insert(const aMap& map);
-   void insert(const aObject& key);
-
-public:
-
-
-  aSortedMap();
-  aSortedMap(const aMap&);
-  ~aSortedMap();
-  
-      void      set        ( const aObject& key, const aObject& val);
-const aObject   *getNextKey (const aObject*pItem);
-  
-};
-
-#endif
diff --git a/Massai/cpp/CfgXMgr/inc/assoXML.h b/Massai/cpp/CfgXMgr/inc/assoXML.h
deleted file mode 100644
index 4d32c0ac..00000000
--- a/Massai/cpp/CfgXMgr/inc/assoXML.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/**
- **************************************************************************
- *
- * @file assoXML.h
- *
- * Dumps an aMap object to a std::string in XML format
- * Reconstructs an aMap object from an XML source
- *
- * @author MaK
- *
- * Copyright (c) 2001 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef _ASSOXML_H_
-#define _ASSOXML_H_
-
-#include <string>
-#include <exception>
-
-#include "asso.h"
-#include "stringTab.h"
-
-/**
- **************************************************************************
- * Map from XML conversion exception class.
- */
-class assoXMLException : public exception
-{
-  std::string message;
-public:
-  /**
-   **************************************************************************
-   * Exception constructor - with message text.
-   *
-   * @param message Information about this exception.
-   */
-  assoXMLException(const std::string& message);
-
-  /**
-   **************************************************************************
-   * Get the exception iformation.
-   *
-   * @return Information about this exception.
-   */
-  virtual const char* assoXMLException::what() const throw();
-};
-
-/**
- **************************************************************************
- * Convert the contents of an aMap object to a character buffer in XML format
- *
- * @param srcMap     The map object to convert.
- * @param dst        The std::string which is filled with the XML data
- * @param st         A class derived from stringTab, used to 
- *                   translate long IDs to their MACRO representation
- *
-**/
-void mapToXML(const aMap& srcMap, 
-              std::string& dst, 
-              const stringTab& st);
-
-/**
- **************************************************************************
- * Construct an aMap object from a character buffer in XML format
- *
- * @param src        A std::string containing the XML data.
- * @param dstMap     An aMap object which is filled with the data.
- *
-**/
-void mapFromXML(const std::string& src, aMap& dstMap) throw(assoXMLException);
-
-#endif //_ASSOXML_H_
\ No newline at end of file
diff --git a/Massai/cpp/CfgXMgr/inc/cfgdbi.hpp b/Massai/cpp/CfgXMgr/inc/cfgdbi.hpp
deleted file mode 100644
index 50fc027d..00000000
--- a/Massai/cpp/CfgXMgr/inc/cfgdbi.hpp
+++ /dev/null
@@ -1,200 +0,0 @@
-/**
- **************************************************************************
- * 
- * @file cfgdbi.hpp
- * 
- * This file defines the
- * Configuration Database Interface and the necessary constants.
- * 
- * @author Maz, JK
- * 
- * Copyright (c) 1997-2001 MATERNA Information & Communications
- * 
- **************************************************************************
-**/
-#ifndef CFGDBI_HPP
-#define CFGDBI_HPP
-
-#include "Asso.h"
-
-#define GETNUM(v) get(v).numObject()
-#define GETSTR(v) get(v).strObject()
-#define GETLISTENTRY(v,n) get(v).mapObject().get(n).strObject()
-
-/**
- * 
- * Returncodes
- * 
-**/
-enum DBERRORS
-{
-  CFGDB_OK,
-  CFGDB_ERR,
-  CFGDB_ERR_CMD,
-  CFGDB_ERR_NOCFG,
-  CFGDB_ERR_NOT_FOUND,
-  CFGDB_ERR_INVPARAM,
-  CFGDB_ERR_SERVER_NOT_FOUND
-};
-
-/**
- * 
- * Keys to be used in parameter maps.
- * 
-**/
-enum CFGDB_ACCESSKEY
-{
-  KEY_RESERVED,
-  KEY_CMDID,
-  KEY_KIOSKNAME,
-  KEY_SUPERSECNAME,
-  KEY_SUBSUPERSECNAME,
-  KEY_SECNAME,
-  KEY_SUBSECNAME,
-  KEY_ITEMNAME,
-  KEY_VALUE,
-  KEY_CHANGEMODE,
-  KEY_SHORTDESCR,
-  KEY_LONGDESCR,
-  KEY_TYPE,
-  KEY_RANGE,
-  KEY_GLOBAL,
-  KEY_DEFAULT,
-  KEY_RANGECOMMENT,
-
-  KEY_MODIFY_DATE,
-  KEY_MODIFY_ADDR,
-  KEY_MASTER_LINK,
-  KEY_MASTER_NAME,
-
-  KEY_CLIENT_NAME,
-  KEY_VERSION,
-  KEY_CLIENT_ID,
-
-  KEY_RANGEINTEGER,
-
-  KEY_ACCESS_L,
-   
-  KEY_LAST
-};
-
-/**
- * 
- * Values for KEY_CMDID.
- * 
-**/
-enum CFGDB_CMDID
-{
-  GET_KIOSKS = 1,
-  GET_SECS,
-  GET_SUBSECS,
-  GET_ITEMS,
-  GET_ITEM,
-  GET_VALUE,
-  GET_DIRECTORY,
-
-  UPD_KIOSK = 100,
-  UPD_SEC,
-  UPD_SUBSEC,
-  UPD_ITEM,
-
-  DEL_KIOSK  = 200,
-  DEL_SEC,
-  DEL_SUBSEC,
-  DEL_ITEM,
-
-  DB_COMMIT = 300,
-  DB_ROLLBACK,
-  DB_STATUS,
-
-  CLT_REJECT = 400,     // Client application has rejected a change
-  CLT_DOWN,             // Client application down
-  CLT_ACCEPT            // Client application has accepted a change
-};
-
-/**
- * 
- * Values for KEY_TYPE
- * 
-**/
-enum CFGTYPES
-{
-  CFGTYPE_RESERVED,        // Not used
-  CFGTYPE_STRING,          // ASCII string (no ctrl chars)
-  CFGTYPE_INTEGER,         // Scalar
-  CFGTYPE_TOGGLE,          // Selection
-  CFGTYPE_STRING_LIST,     // List of CFGTYPE_STRING
-  CFGTYPE_TEXT             // ASCII string (including ctrl chars)
-};
-
-#define CFGDB_TRUE  "TRUE"
-#define CFGDB_FALSE "FALSE"
-
-#define LIST_COUNT "__DB_LIST_COUNT__"
-
-/**
- * 
- * Configuration interface class.
- * 
- */
-class cfgdbi
-{
-   
-   //! Handle class
-   friend class cfgdbi_;
-   
-   //! Handle class reference
-   cfgdbi_ * Handle;
-   
-   /**
-    * 
-    * Indication. This method is calles upon a change in configuration
-    * values.
-    * 
-    * @param 1.  The map with the configuration items, which have changed.
-    * 
-    * @return Should be CFGDB_OK.
-    * 
-   **/
-   virtual long ind( aMap const & ) { return 0; };
-   
-public:
-   
-   /**
-    * 
-    * Constructor.
-    * 
-    * @param 1. The name of the application.
-   **/
-   cfgdbi( char const * );
-   
-   /**
-    * 
-    * Destructor.
-    * 
-   **/
-   ~cfgdbi();
-   
-   /**
-    * 
-    * Request.
-    * 
-    * @param 1. Data to the configuration server.
-    * 
-    * @param 2. Data from the configuration server.
-    * 
-    * @return Value from DBERRORS.
-    * 
-   **/
-   long req( aMap const &, aMap & );
-   
-};
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- * 
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgr/inc/chunkedBuffer.h b/Massai/cpp/CfgXMgr/inc/chunkedBuffer.h
deleted file mode 100644
index 220963c7..00000000
--- a/Massai/cpp/CfgXMgr/inc/chunkedBuffer.h
+++ /dev/null
@@ -1,158 +0,0 @@
-#ifndef CHUNKEDBUFFER_H_
-#define CHUNKEDBUFFER_H_
-
-#pragma warning (disable:4786)
-
-#include <string>
-#include <vector>
-
-class chunkedBuffer
-{
-  std::string::size_type chunkSize;
-  std::vector<std::string*> chunks;
-  std::string *pChunk;
-
-  void deleteVector()
-  {
-    for(std::vector<std::string*>::iterator it = chunks.begin(); it != chunks.end(); ++it)
-    {
-      delete *it;
-    }
-    chunks.clear();
-  };
-
-public:
-  chunkedBuffer(std::string::size_type chunkSize = 1024)
-  {
-    this->chunkSize = chunkSize;
-    pChunk = new std::string();
-    pChunk->reserve(chunkSize);
-    chunks.insert(chunks.end(), pChunk);
-  }
-
-  ~chunkedBuffer()
-  {
-    deleteVector();
-  }
-
-  chunkedBuffer& operator << (unsigned long ul)
-  {
-    stringstream ss;
-    ss << ul;
-    addString(ss.str());
-    return *this;
-  }
-
-  chunkedBuffer& operator << (long l)
-  {
-    stringstream ss;
-    ss << l;
-    addString(ss.str());
-    return *this;
-  }
-
-  chunkedBuffer& operator << (const std::string& s)
-  {
-    addString(s);
-    return *this;
-  }
-
-  chunkedBuffer& operator << (unsigned char c)
-  {
-    if(pChunk->size() < chunkSize)
-    {
-      pChunk->append(std::string(1, c));
-    } else
-    {
-      // allocate new chunk
-      pChunk = new std::string();
-      pChunk->reserve(chunkSize);
-      pChunk->assign(std::string(1, c));
-      chunks.insert(chunks.end(), pChunk);
-    }
-    return *this;
-  }
-
-  void addString(const std::string& s)
-  {
-    if(pChunk->size() < chunkSize)
-    {
-      // reuse current chunk
-      if((chunkSize - pChunk->size()) >= s.size())
-      {
-        // new string fits completely into current chunk
-        pChunk->append(s);
-      } else
-      {
-        // new string does not fit completely into current chunk
-        std::string::size_type copied = chunkSize - pChunk->size();
-
-        pChunk->append(s.substr(0, copied));
-
-        // allocate new chunk
-        pChunk = new std::string();
-        if(s.size() - copied > chunkSize) 
-          pChunk->reserve(s.size() - copied);
-        else
-          pChunk->reserve(chunkSize);
-        chunks.insert(chunks.end(), pChunk);
-
-        pChunk->append(s.substr(copied));
-      }
-    } else
-    {
-      // allocate new chunk
-      pChunk = new std::string();
-      if(s.size() > chunkSize)
-      {
-        pChunk->reserve(s.size());
-        pChunk->assign(s);
-        chunks.insert(chunks.end(), pChunk);
-
-        pChunk = new std::string();
-        pChunk->reserve(chunkSize);
-        chunks.insert(chunks.end(), pChunk);
-      } else
-      {
-        pChunk->reserve(chunkSize);
-        pChunk->assign(s);
-        chunks.insert(chunks.end(), pChunk);
-      }
-    
-    }
-  }
-
-  std::string::size_type size()
-  {
-    std::string::size_type size = 0;
-    for(std::vector<std::string*>::iterator it = chunks.begin(); it != chunks.end(); ++it)
-    {
-      size += (*it)->size();
-    }
-    return size;
-  }
-
-  const std::string& str()
-  {
-    pChunk = new std::string();
-    pChunk->reserve(size());
-
-    for(std::vector<std::string*>::iterator it = chunks.begin(); it != chunks.end(); ++it)
-    {
-      *pChunk += **it;
-    }
-
-    deleteVector();
-    chunks.insert(chunks.end(), pChunk);
-
-    return *pChunk;
-  }
-
-  const std::string& endl()
-  {
-    static std::string endl("\n");
-    return endl;
-  }
-};
-
-#endif //CHUNKEDBUFFER_H_
\ No newline at end of file
diff --git a/Massai/cpp/CfgXMgr/inc/cstrstream.h b/Massai/cpp/CfgXMgr/inc/cstrstream.h
deleted file mode 100644
index 51f75569..00000000
--- a/Massai/cpp/CfgXMgr/inc/cstrstream.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/**
- **************************************************************************
- *
- * @file cstrstream.h
- *
- * a safe derivate of the strstream class which provides a char* operator
- * returning the buffer as zero terminated string (the str() member of
- * strstream does NOT do this!)
- *
- * @author MaK
- *
- * Copyright (c) 2001 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-
-#ifndef _CSTRSTREAM_HPP_
-#define _CSTRSTREAM_HPP_
-
-#include <iostream>
-#include <strstream>
-#include <string>
-
-namespace
-{
-  class cstrstream : public strstream
-  {
-    char* pszContent;
-
-  public:
-    cstrstream() : strstream(), pszContent(0) {};
-    cstrstream(char* pch, int nLength, int nMode = ios_base::in | ios_base::out)
-      : strstream(pch, nLength, nMode), pszContent(0) {};
-
-    operator const char * ()
-    {
-      if(pszContent == 0)
-        pszContent = new char[pcount() + 1];
-      memcpy(pszContent, str(), pcount());
-      pszContent[pcount()] = 0;
-      return pszContent;
-    }
-
-    ~cstrstream()
-    {
-      if(pszContent)
-        delete [] pszContent;
-    }
-  };
-}
-
-#endif //_CSTRSTREAM_HPP_
diff --git a/Massai/cpp/CfgXMgr/inc/instance.hpp b/Massai/cpp/CfgXMgr/inc/instance.hpp
deleted file mode 100644
index ea7910bc..00000000
--- a/Massai/cpp/CfgXMgr/inc/instance.hpp
+++ /dev/null
@@ -1,109 +0,0 @@
-/**
- **************************************************************************
- * 
- * @file instance.hpp
- * 
- * Contains class instance
- * 
- * @author JK
- * 
- * Copyright (c) 2000,2001 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef INSTANCE_HPP
-#define INSTANCE_HPP
-
-/**
- * 
- * Count instances of objects of a derived class. Used to have a unique
- * object identifier (e.g. for debugging/traceing).
- * 
-**/
-class instance
-{
-   
-   /**
-    * 
-    * The instance of this object.
-    * 
-   **/
-   int const M_Instance;
-
-   /**
-    * 
-    * Refers the anchor element.
-    * 
-    */
-   int &     M_Anchor;
-   
-public:
-   
-   /**
-    * 
-    * Standard constructor - intentionally not implemented.
-    * 
-   **/
-   instance();
-
-   /**
-    * 
-    * Constructor. The instance counter for this object (M_Instance) is
-    * initialized from the anchor given and the anchor then incremented.
-    * 
-    * @param Anchor
-    * 
-   **/
-   instance( int & Anchor ) :
-      M_Instance( Anchor ),
-      M_Anchor( Anchor )
-   {
-      ++M_Anchor;
-   }
-
-   /**
-    * 
-    * Copy constructor. The instance counter for this obeject is
-    * initialized from the source objects anchor reference. The anchor
-    * then is incremented.
-    * 
-   **/
-   instance( instance const & Src ) :
-      M_Instance( Src.M_Anchor ),
-      M_Anchor( Src.M_Anchor )
-   {
-      ++M_Anchor;
-   }
-
-   /**
-    * 
-    * Assignment operator. The instance counter is not affected.
-    * 
-   **/
-   instance & operator=( instance const & )
-   {
-      return *this;
-   }
-
-   /**
-    * 
-    * Retrieve the current instance.
-    * 
-    * @return Instance counter for this object.
-    * 
-   **/
-   int getInstance() const
-   {
-      return M_Instance;
-   }
-   
-};
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- * 
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgr/inc/mHashMT.hpp b/Massai/cpp/CfgXMgr/inc/mHashMT.hpp
deleted file mode 100644
index ae59ea42..00000000
--- a/Massai/cpp/CfgXMgr/inc/mHashMT.hpp
+++ /dev/null
@@ -1,258 +0,0 @@
-/**
- **************************************************************************
- * 
- * @file mHashMT.hpp
- * 
- * Contains template class Materna::MSSD::hashMT.
- * 
- * @author JK
- * 
- * Copyright (c) 2002 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef MHASHMT_HPP
-#define MHASHMT_HPP
-
-#include "mMutexSem.hpp"
-
-
-
-//! MATERNA Information & Communications
-namespace Materna
-{
-   //! Self Service Devices
-   namespace MSSD
-   {
-      
-      
-      
-      /**
-       **************************************************************************
-       *
-       * Implements thread-safe hashing. Template arguments:
-       * 
-       * - V Value type
-       * 
-       * - K Key type
-       *
-       **************************************************************************
-      **/
-      template <class V, class K>
-      class hashMT
-      {
-         
-         //! The vector of hash values
-         V *             M_Values;
-         
-         //! The vector of hash keys
-         K *             M_Keys;
-         
-         //! The size of the vectors
-         unsigned        M_HashSize;
-         
-         //! The current number of entries
-         unsigned        M_HashEntries;
-         
-         //! The value retruned for not found
-         V               M_NoValue;
-         
-         //! Represents the no-entry entry
-         K               M_NoKey;
-         
-         //! Access protection
-         Materna::MSSD::mutexSemaphore
-                         M_Mutex;
-      
-         /**
-          * 
-          * Find the vector index for a key given.
-          * 
-          * @param 1. The key.
-          * 
-          * @param 2. Refers the varible to place the index found.
-          * 
-          * @return 1 if success, 0 if not
-          * 
-         **/
-         int indexForKey( K Key, unsigned & Ind ) const
-         {
-            // Apply the hash function:
-            // - Assume the key can be converted to an unsigned
-            // - Calc modulo hashsize
-            unsigned UKey = (unsigned)Key;
-            Ind = UKey % M_HashSize;
-            // Scan to the actual key
-            while( M_Keys[Ind] != M_NoKey )
-            {
-               if( M_Keys[Ind] == Key )
-               {
-                  // That is our index
-                  return 1;
-               }
-               Ind = ( Ind + 1 ) % M_HashSize;
-            }
-            // Not found
-            return 0;
-         }
-         
-      public:
-      
-         /**
-          * 
-          * Standard constructor - intentionally not implemented.
-          * 
-         **/
-         hashMT();
-      
-         /**
-          * 
-          * Constructor
-          * 
-          * @param 1. The hash size
-          * 
-          * @param 2. This is value is to be returned when no value is found.
-          *
-          * @param 3. This key does not occur.
-          * 
-         **/
-         hashMT( unsigned HashSize, V NoValue, K NoKey )
-            : M_Values( new V[ HashSize ] ),
-              M_Keys( new K[ HashSize ] ),
-              M_HashSize( HashSize ),
-              M_HashEntries( 0 ),
-              M_NoValue( NoValue ),
-              M_NoKey( NoKey ),
-              M_Mutex()
-         {
-            for( unsigned i=0; i<HashSize; ++i ) M_Keys[i] = M_NoKey;
-         }
-         
-         /**
-          * 
-          * Copy constructor - intentionally not implemented.
-          * 
-         **/
-         hashMT( hashMT<V,K> const & );
-      
-         /**
-          * 
-          * Destructor
-          * 
-         **/
-         ~hashMT()
-         {
-            delete[] M_Keys;
-            delete[] M_Values;
-         }
-      
-         /**
-          * 
-          * Assignment operator - intentionally not implemented.
-          * 
-         **/
-         hashMT<V,K> const & operator=( hashMT<V,K> const & );
-         
-         /**
-          * 
-          * Clear a key from the map.
-          *
-          * @param 1. The key to be cleared.
-          *
-         **/
-         void clr( const K & Key )
-         {
-            M_Mutex.request();
-            unsigned Ind;
-            if( indexForKey( Key, Ind ) )
-            {
-               //
-               // Release slot
-               //
-               M_Keys[Ind] = M_NoKey;
-               --M_HashEntries;
-            }
-            M_Mutex.release();
-         }
-      
-         /**
-          * 
-          * Retrieve a value for a key.
-          * 
-          * @param 1. The input key.
-          *
-          * @return The value.
-          * 
-         **/
-         V const & get( K const & Key )
-         {
-            M_Mutex.request();
-            unsigned Ind;
-            V const * pR;
-            if( indexForKey( Key, Ind ) )
-            {
-               pR = &M_Values[Ind];
-            }
-            else
-            {
-               pR = &M_NoValue;
-            }
-            M_Mutex.release();
-            return *pR;
-         }
-      
-         /**
-          * 
-          * Set the value for a key.
-          * 
-          * @param 1. The key to set.
-          * 
-          * @param 2. The value for the key.
-          *
-          * @return The value, if sucessful.
-         **/
-         V const & set( K const & Key, V const & Value )
-         {
-            M_Mutex.request();
-            if( M_HashEntries < M_HashSize )
-            {
-               unsigned Ind;
-               if( !indexForKey( Key, Ind ) )
-               {
-                  //
-                  // Empty slot
-                  //
-                  M_Keys[Ind] = Key;
-                  ++M_HashEntries;
-               }
-               M_Values[Ind] = Value;
-               M_Mutex.release();
-               return M_Values[Ind];
-            }
-            else
-            {
-               //
-               // All slots in use
-               //
-               M_Mutex.release();
-               return M_NoValue;
-            }
-         }
-         
-      };
-      
-      
-      
-   } // namespace MSSD
-} // namespace Materna
-
-
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgr/inc/mStringFile.hpp b/Massai/cpp/CfgXMgr/inc/mStringFile.hpp
deleted file mode 100644
index a92ecf64..00000000
--- a/Massai/cpp/CfgXMgr/inc/mStringFile.hpp
+++ /dev/null
@@ -1,61 +0,0 @@
-/**
- **************************************************************************
- *
- * @file mStringFile.hpp
- *
- * Copy a standard string to file and vice versa.
- *
- * @author JK
- *
- * Copyright (c) 2004 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-
-
-
-#include <string>
-
-
-
-/**
- *
- * Copy file data to a standard string.
- *
- * @param Dst:          The destination string
- *
- * @param Filename:     Name of the source file.
- *
-**/
-void mStringFromFile
-(
-   std::string &        Dst,
-   std::string const &  Filename
-);
-
-
-
-/**
- *
- * Copy a standard string to file.
- *
- * @param Filename:     Name of the destination file.
- *
- * @param Src:          The source string
- *
-**/
-void mStringToFile
-(
-   std::string const &  Filename,
-   std::string const &  Src
-);
-
-
-
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgr/inc/mThreadSave.hpp b/Massai/cpp/CfgXMgr/inc/mThreadSave.hpp
deleted file mode 100644
index c3bf3915..00000000
--- a/Massai/cpp/CfgXMgr/inc/mThreadSave.hpp
+++ /dev/null
@@ -1,56 +0,0 @@
-/**
- **************************************************************************
- * 
- * @file mThreadSave.hpp
- * 
- * @author JK
- * 
- **************************************************************************
-**/
-#ifndef MTHREADSAVE_HPP
-#define MTHREADSAVE_HPP
-
-
-
-namespace Materna
-{
-   namespace MSSD
-   {
-
-      /**
-       * 
-       * Mutex-protected increment.
-       * Idea from CUJ Feb.2001 (Locking pointer)
-       * 
-       * @param 1. A reference to the mutex samaphore.
-       *
-       * @param 2. The variable to be incremented.
-       * 
-       * @return The incremented value.
-       * 
-      **/
-      template<typename T>
-      T threadSaveIncrement( mutexSemaphore & Mx, T volatile & Var )
-      {
-         Mx.request();
-         T Ret = ++Var;
-         Mx.release();
-         return Ret;
-      }
-      
-   }
-}
-
-
-
-#endif // MTHREADSAVE_HPP
-
-/**
- **************************************************************************
- * 
- * End of file
- * 
- **************************************************************************
-**/
-
-
diff --git a/Massai/cpp/CfgXMgr/inc/mWarning.hpp b/Massai/cpp/CfgXMgr/inc/mWarning.hpp
deleted file mode 100644
index 126a9cf7..00000000
--- a/Massai/cpp/CfgXMgr/inc/mWarning.hpp
+++ /dev/null
@@ -1,59 +0,0 @@
-/**
- **************************************************************************
- *
- * @file MassaiDevice.hpp
- *
- * Massai device tools.
- *
- * @author JK
- *
- * Copyright (c) 2002 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef MWARNING_HPP
-#define MWARNING_HPP
-
-
-
-namespace Materna
-{
-
-   /**
-    *
-    * Issue a warning to the console and to the tracer. This function
-    * should be called to indicate some severe problem. The application
-    * will be able to continue operation.
-    *
-    * @param Msg:            Warning string
-    *
-    * @param Detail:         Warning detail string (optional)
-    *
-   **/
-   void warningAndContinue( char const * Msg, char const * Detail = 0 );
-
-   /**
-    *
-    * Issue a warning to the console and to the tracer. This function
-    * should be called in extreme situations, e.g. if the application
-    * cannot continue properly.
-    *
-    * @param Msg:            Warning string
-    *
-    * @param Detail:         Warning detail string (optional)
-    *
-   **/
-   void warningAndStop( char const * Msg, char const * Detail = 0 );
-
-}
-
-
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgr/inc/matDaemon.h b/Massai/cpp/CfgXMgr/inc/matDaemon.h
deleted file mode 100644
index 04bf7016..00000000
--- a/Massai/cpp/CfgXMgr/inc/matDaemon.h
+++ /dev/null
@@ -1,96 +0,0 @@
-/**
- **************************************************************************
- *
- * @file mDaemon.h
- *
- * Interface to mDaemon functions.
- *
- * @author JK
- *
- * Copyright (c) 2001 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef MDAEMON_H
-#define MDAEMON_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-  /**
-    *
-    * List of services that must start before this service
-    * This function is implemented by the service-specific part of the daemon.
-    *
-   **/
-   char const * mDaemon_dependencies();
-   /**
-    *
-    * Give command-line parameters help.
-    * This function is implemented by the service-specific part of the daemon.
-    *
-   **/
-   char const * mDaemon_help();
-
-   /**
-    *
-    * Get the name for the daemon process.
-    * This function is implemented by the service-specific part of the daemon.
-    *
-   **/
-   char const * mDaemon_name();
-
-   /**
-    *
-    * Run the daemon process.
-    * This function is implemented by the service-specific part of the daemon.
-    *
-   **/
-   int mDaemon_main( int argc, char ** argv );
-
-   /**
-    *
-    * Stop the daemon process.
-    * This function is implemented by the service-specific part of the daemon.
-    *
-   **/
-   void mDaemon_stop( void );
-
-   /**
-    *
-    * This function is called by the service-specific part of the daemon
-    * to indicate the service is initializing.
-    *
-   **/
-   int mDaemon_indInitializing( unsigned long mSec );
-
-   /**
-    *
-    * This function is called by the service-specific part of the daemon
-    * to indicate the service is ready for operation.
-    *
-   **/
-   int mDaemon_indReady( unsigned long mSec );
-
-   /**
-    *
-    * This function is called by the service-specific part of the daemon
-    * to write an application event.
-    *
-   **/
-   void mDaemon_log( char const * Data );
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
-
diff --git a/Massai/cpp/CfgXMgr/inc/matEnv.hpp b/Massai/cpp/CfgXMgr/inc/matEnv.hpp
deleted file mode 100644
index b9a1de7a..00000000
--- a/Massai/cpp/CfgXMgr/inc/matEnv.hpp
+++ /dev/null
@@ -1,49 +0,0 @@
-/**
- **************************************************************************
- * 
- * @file matEnv.hpp
- *
- * Interface for environment function definitions.
- * 
- * @author JK
- * 
- * Copyright (c) 2001 MATERNA Information & Communications
- * 
- **************************************************************************
-**/
-#ifndef MATENV_HPP
-#define MATENV_HPP
-
-#include <string>
-
-/**
- * 
- * Append the path to the directory with the current program binary to a
- * string.
- * 
- * @param Dst The destination string
- * 
- * @return 0 if successful
- * 
-**/
-int matEnvBindir( std::string & Dst );
-
-/**
- * 
- * Append the current date and time to a string
- * 
- * @param Dst The destination string
- * 
- * @return 0 if successful
- * 
-**/
-int matEnvDateTime( std::string & Dst );
-
-#endif
-/**
- **************************************************************************
- * 
- * End of file
- * 
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgr/inc/matSignal.h b/Massai/cpp/CfgXMgr/inc/matSignal.h
deleted file mode 100644
index 4903055f..00000000
--- a/Massai/cpp/CfgXMgr/inc/matSignal.h
+++ /dev/null
@@ -1,199 +0,0 @@
-/**
- **************************************************************************
- * 
- * @file matSignal.h
- * 
- * Contains OS signal handler.
- * 
- * @author JK
- * 
- * Copyright (c) 2000-2001 MATERNA Information & Communications
- * 
- **************************************************************************
-**/
-#ifndef MATSIGNAL_H
-#define MATSIGNAL_H
-
-#include "matRC.h"
-
-//! Forward declaration.
-struct matSignalPrivate;
-
-/**
- * 
- * "Handle" to be used with the library functions.
- * 
-**/
-typedef struct matSignalPrivate * matSignalHdl;
-
-
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif
-
-/**
- * 
- * "C"-function, create handle.
- * 
-**/
-matSignalHdl matSignalCreate();
-   
-/**
- * 
- * "C"-function, delete handle.
- * 
-**/
-void matSignalDelete( matSignalHdl Handle );
-   
-/**
- * 
- * "C"-function, wait for signal.
- * 
-**/
-MATRC matSignalWaitInf( matSignalHdl Handle );
-   
-/**
- * 
- * "C"-function, wait for signal.
- * 
-**/
-MATRC matSignalWaitReasonInf( matSignalHdl Handle, long * Reason );
-   
-/**
- * 
- * "C"-function, wait for signal.
- * 
-**/
-MATRC matSignalWait( matSignalHdl Handle, int MS );
-   
-/**
- * 
- * "C"-function, wait for signal.
- * 
-**/
-MATRC matSignalWaitReason( matSignalHdl Handle, int MS, long * Reason );
-   
-#ifdef __cplusplus
-}
-#endif
-
-
-
-#ifdef __cplusplus
-
-/**
- **************************************************************************
- * 
- * C++ Signal handler class.
- * 
- **************************************************************************
-**/
-class matSignal
-{
-
-   /**
-    * 
-    * Handle for private data.
-    * 
-   **/
-   matSignalHdl Handle;
-   
-public:
-
-   /**
-    * 
-    * Standard constructor.
-    * 
-   **/
-   matSignal() :
-      Handle( matSignalCreate() )
-   {
-   }
-
-   /**
-    * 
-    * Destructor.
-    * 
-   **/
-   ~matSignal()
-   {
-      matSignalDelete( Handle );
-      Handle = 0;
-   }
-
-   /**
-    * 
-    * Wait.
-    * 
-    * @return MATRC_OK, when signal occured.
-    * 
-   **/
-   MATRC wait()
-   {
-      return matSignalWaitInf( Handle );
-   }
-
-   /**
-    * 
-    * Wait.
-    * 
-    * @param Reason Will on return contain the signal type.
-    *
-    * @return MATRC_OK, when signal occured.
-    * 
-   **/
-   MATRC wait( long & Reason )
-   {
-      return matSignalWaitReasonInf( Handle, &Reason );
-   }
-   
-   /**
-    * 
-    * Wait.
-    * 
-    * @param Milliseconds Time to wait for signal.
-    *
-    * @return MATRC_OK, when signal occured, MATRC_TIMEOUT, when no
-    *         signal has occured within the number of milliseconds
-    *         specified.
-    * 
-   **/
-   MATRC wait( int Milliseconds )
-   {
-      return matSignalWait( Handle, Milliseconds );
-   }
-   
-   /**
-    * 
-    * Wait.
-    * 
-    * @param Milliseconds Time to wait for signal.
-    *
-    * @param Reason Will on return contain the signal type.
-    *
-    * @return MATRC_OK, when signal occured, MATRC_TIMEOUT, when no
-    *         signal has occured within the number of milliseconds
-    *         specified.
-    * 
-   **/
-   MATRC wait( int Milliseconds, long & Reason )
-   {
-      return matSignalWaitReason( Handle, Milliseconds, &Reason );
-   }
-   
-};
-
-#endif
-
-
-
-#endif
-/**
- **************************************************************************
- * 
- * End of file
- * 
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgr/inc/stList.hpp b/Massai/cpp/CfgXMgr/inc/stList.hpp
deleted file mode 100644
index 92ef0d34..00000000
--- a/Massai/cpp/CfgXMgr/inc/stList.hpp
+++ /dev/null
@@ -1,690 +0,0 @@
-
-//-------------------------------------------------------------------
-//
-// STLIST.HPP
-//
-// Simple Template List classes
-//
-// Definitions for:     stList
-//                      stSortableList
-//                      stListCursor
-//
-// Debugging is enabled by defining STLIST_STREAM
-// (e.g. "#define STLIST_STREAM cout")
-//
-//-------------------------------------------------------------------
-#ifndef STLIST_HPP
-#define STLIST_HPP
-
-#ifdef STLIST_STREAM
-
-#include <iostream.h>
-
-static int stList_Level = 0;
-
-#define _STLIST_TRACE_BEGIN(trc,pro)\
-                                    stList_Level++;\
-                                    for( int i = 0; i<stList_Level;i++)\
-                                       STLIST_STREAM << "   ";\
-                                    STLIST_STREAM <<\
-                                    hex << (unsigned)this <<\
-                                    pro << trc << endl;
-
-#define STLIST_TRACE_BEGIN(trc)     _STLIST_TRACE_BEGIN(trc," stList<T>::")
-#define STLISTC_TRACE_BEGIN(trc)    _STLIST_TRACE_BEGIN(trc," stListCursor<T>::")
-#define STLISTL_TRACE_BEGIN(trc)    _STLIST_TRACE_BEGIN(trc," stCarrier<T>::")
-#define STLISTS_TRACE_BEGIN(trc)    _STLIST_TRACE_BEGIN(trc," stSortableList<T>::")
-#define STLIST_TRACE_END            stList_Level--;
-
-#else
-
-#define STLIST_TRACE_BEGIN(trc)
-#define STLISTC_TRACE_BEGIN(trc)
-#define STLISTL_TRACE_BEGIN(trc)
-#define STLISTS_TRACE_BEGIN(trc)
-#define STLIST_TRACE_END
-
-#endif
-
-#define STLISTC_TRACE_END STLIST_TRACE_END
-#define STLISTL_TRACE_END STLIST_TRACE_END
-#define STLISTS_TRACE_END STLIST_TRACE_END
-
-
-//
-// Prototype
-//
-template<class T> class stListCursor;
-
-
-//-------------------------------------------------------------------
-//
-// stList
-//
-//-------------------------------------------------------------------
-#define NELEMENTS(p) (sizeof(p)/sizeof(p[0]))
-#define ELEMENTS(p) p,NELEMENTS(p)
-
-template<class T> class stList
-{
-
-   friend class stListCursor<T>;
-
-protected:
-
-   //
-   // PRIVATE:   Link structure
-   //
-   class stCarrier
-   {
-      stCarrier *  pSucc;
-      stCarrier *  pPred;
-      T *          pInfo;
-   public:
-      stCarrier( const T & t )
-         {
-            STLISTL_TRACE_BEGIN("stCarrier( const T & )")
-            pInfo = new T(t);
-            pSucc = pPred = 0;
-            STLISTL_TRACE_END
-         }
-      ~stCarrier()
-         {
-            STLISTL_TRACE_BEGIN("~stCarrier()")
-            delete pInfo;
-            STLISTL_TRACE_END
-         };
-      T * info()                { return pInfo; }
-      void unlink()             {
-                                   STLISTL_TRACE_BEGIN("unlink()")
-                                   if( pPred ) pPred->pSucc = pSucc;
-                                   if( pSucc ) pSucc->pPred = pPred;
-                                   pPred = pSucc = 0;
-                                   STLISTL_TRACE_END
-                                }
-      stCarrier * pred()        { return pPred; }
-      stCarrier * succ()        { return pSucc; }
-      stCarrier * succ( stCarrier * pC )
-                                {
-                                   STLISTL_TRACE_BEGIN("succ( stCarrier * )")
-                                   if( pC->pPred )
-                                   {
-                                      //
-                                      // The new successor already has a predecessor
-                                      // -> insert this before the new successor
-                                      //
-                                      pPred = pC->pPred;
-                                      pPred->pSucc = this;
-                                   }
-                                   // we assume: this->pSucc = 0;
-                                   pSucc = pC;
-                                   pC->pPred = this;
-                                   STLISTL_TRACE_END
-                                   return pSucc;
-                                }
-   };
-
-   //
-   // PRIVATE:   List object data
-   //
-   stCarrier *    pFstCarrier;
-   stCarrier *    pLstCarrier;
-
-public:
-
-   //
-   // PUBLIC:    stList<T>::stList()
-   //
-   // Default constructor, makes the empty list
-   //
-   stList()
-         {
-            STLIST_TRACE_BEGIN("stList()")
-            pFstCarrier = pLstCarrier = 0;
-            STLIST_TRACE_END
-         }
-
-   //
-   // PUBLIC:    stList<T>::stList( const T * pSrc, int nSrc )
-   //
-   // Constructor to make a list from an array of T (pSrc) and the number of
-   // items in the array (nSrc)
-   //
-   stList( const T *pSrc, int nSrc )
-         {
-            STLIST_TRACE_BEGIN("stList( pSrc, nSrc )")
-            pFstCarrier = pLstCarrier = 0;
-            while( nSrc-- )
-            {
-               append( *pSrc++ );
-            }
-            STLIST_TRACE_END
-         }
-
-   //
-   // PUBLIC:    stList<T>::stList( const stList<T> & Src )
-   //
-   // Copy constructor
-   //
-   stList( const stList<T> & Src )
-         {
-            STLIST_TRACE_BEGIN("stList( const stList<T> & )")
-            stListCursor<T> CS( (stList<T> &) Src );
-            pFstCarrier = pLstCarrier = 0;
-            while( !CS.eof() )
-            {
-               append( **CS );
-               ++CS;
-            }
-            STLIST_TRACE_END
-         }
-
-   //
-   // destructor
-   //
-   ~stList()
-         {
-            STLIST_TRACE_BEGIN("~stList()")
-            clear();
-            STLIST_TRACE_END
-         }
-
-   //
-   // PUBLIC:    stList<T>& stList<T>::clear()
-   //
-   // Clears the list completelly
-   //
-   stList<T>& clear()
-         {
-            STLIST_TRACE_BEGIN("clear()")
-            stCarrier * p = pFstCarrier;
-            while( p )
-            {
-               stCarrier * q = p;
-               p = p->succ();
-               //
-               // Delete carrier
-               //
-               delete q;
-            }
-            pFstCarrier = pLstCarrier = 0;
-            STLIST_TRACE_END
-            return *this;
-         }
-
-   //
-   // PUBLIC:    stList<T>& stList<T>::operator=( const stList<T> & Src )
-   //
-   // Assignment operator
-   //
-   stList<T>& operator =( const stList<T> & Src )
-         {
-            STLIST_TRACE_BEGIN("operator=( const stList<T> & )")
-            clear();
-            stListCursor<T> CS( (stList<T> &) Src );
-            while( !CS.eof() )
-            {
-               append( **CS );
-               ++CS;
-            }
-            STLIST_TRACE_END
-            return *this;
-         }
-
-   //
-   // PUBLIC:    stList<T>& stList<T>::append( const T& t )
-   //
-   // Appends a copy of an object of type T to the end of the list.
-   //
-   stList<T>& append( const T & t )
-         {
-            STLIST_TRACE_BEGIN("append( const T & )")
-            //
-            // Create carrier
-            //
-            stCarrier * c = new stCarrier( t );
-            //
-            // Link it to the list
-            //
-            if( pLstCarrier )
-            {
-               pLstCarrier = pLstCarrier->succ( c );
-            }
-            else
-            {
-               pFstCarrier = c;
-               pLstCarrier = c;
-            }
-            STLIST_TRACE_END
-            return *this;
-         }
-
-   //
-   // PUBLIC:    stList<T>::insert( int, const T& )
-   //
-   // Insert the element at the index given
-   //
-   stList<T>& insert( int Index, const T& t )
-         {
-            STLIST_TRACE_BEGIN("insert( int, const T & )")
-            stCarrier * pC = pFstCarrier;
-            while( Index )
-            {
-               if( pC )
-               {
-                  --Index;
-                  pC = pC->succ();
-               }
-               else
-                  Index = 0;
-            }
-            if( pC )
-            {
-               if( pC == pFstCarrier )
-               {
-                  //
-                  // insert before pFstCarrier
-                  //
-                  stCarrier * pIns = new stCarrier( t );
-                  pIns->succ( pFstCarrier );
-                  pFstCarrier = pIns;
-               }
-               else
-               {
-                  //
-                  // insert in the middle
-                  //
-                  stCarrier * pIns = new stCarrier( t );
-                  pIns->succ( pC );
-               }
-            }
-            else
-            {
-               append( t );
-            }
-            STLIST_TRACE_END
-            return *this;
-         }
-
-   //
-   // PUBLIC:    stList<T>::remove( int, T & )
-   //
-   // Remove the element at the index given ( -1 means the last element )
-   //
-   stList<T>& remove( int Index, T& t )
-         {
-            STLIST_TRACE_BEGIN("remove( int )")
-            stCarrier * pC = pFstCarrier;
-            if( Index == -1 )
-               pC = pLstCarrier;
-            else
-               while( Index )
-               {
-                  if( pC )
-                  {
-                     --Index;
-                     pC = pC->succ();
-                  }
-                  else
-                     Index = 0;
-               }
-            if( pC )
-            {
-               if( pC == pFstCarrier ) pFstCarrier = pC->succ();
-               if( pC == pLstCarrier ) pLstCarrier = pC->pred();
-               pC->unlink();
-               t = *pC->info();
-               delete pC;
-            }
-            STLIST_TRACE_END
-            return *this;
-         }
-
-   //
-   // PUBLIC:    int stList<T>::length()
-   //
-   // Returns the actual number of objects of type T held in the list.
-   //
-   int length() const
-         {
-            STLIST_TRACE_BEGIN("length()")
-            int N = 0;
-            stCarrier * p = pFstCarrier;
-            while( p )
-            {
-               ++N;
-               p = p->succ();
-            }
-            STLIST_TRACE_END
-            return N;
-         }
-
-};
-
-
-//-------------------------------------------------------------------
-//
-// stSortableList
-//
-//-------------------------------------------------------------------
-template<class T> class stSortableList : public stList<T>
-{
-
-public:
-
-   //
-   // PUBLIC:    stSortableList<T>::stSortableList()
-   //
-   // Default constructor, makes the empty list
-   //
-   stSortableList()
-         {
-            STLISTS_TRACE_BEGIN("stSortableList()")
-            pFstCarrier = pLstCarrier = 0;
-            STLISTS_TRACE_END
-         }
-
-   //
-   // PUBLIC:    stSortableList<T>::stSortableList( const stSortableList<T> & Src )
-   //
-   // Copy constructor
-   //
-   stSortableList( const stSortableList<T> & Src )
-         {
-            STLISTS_TRACE_BEGIN("stSortableList( const stSortableList<T> & )")
-            stListCursor<T> CS( (stList<T> &) Src );
-            pFstCarrier = pLstCarrier = 0;
-            while( !CS.eof() )
-            {
-               append( **CS );
-               ++CS;
-            }
-            STLISTS_TRACE_END
-         }
-
-   //
-   // PUBLIC:    stSortableList<T>::stSortableList( const stList<T> & Src )
-   //
-   // Constructor from an unsorted list
-   //
-   stSortableList( const stList<T> & Src )
-         {
-            STLISTS_TRACE_BEGIN("stSortableList( const stList<T> & )")
-            stListCursor<T> CS( (stList<T> &) Src );
-            pFstCarrier = pLstCarrier = 0;
-            while( !CS.eof() )
-            {
-               insert( **CS );
-               ++CS;
-            }
-            STLISTS_TRACE_END
-         }
-
-   //
-   // PUBLIC:    stSortableList<T>::insert( const T& )
-   //
-   // Insert an element at the correct place of the list.
-   // If the "<" operator always returns 0, it will
-   // insert at the beginning of the list;
-   //
-   stSortableList<T>& insert( const T& t )
-         {
-            STLISTS_TRACE_BEGIN("insert( const T & )")
-            stCarrier * pC = pFstCarrier;
-            int IO = 1;
-            //
-            // Find a place to insert
-            //
-            while( pC && IO )
-            {
-               if( *(pC->info()) < t )
-                  pC = pC->succ();
-               else
-                  IO = 0;
-            }
-            if( pC )
-            {
-               if( pC == pFstCarrier )
-               {
-                  //
-                  // insert before pFstCarrier
-                  //
-                  stCarrier * pIns = new stCarrier( t );
-                  pIns->succ( pFstCarrier );
-                  pFstCarrier = pIns;
-               }
-               else
-               {
-                  //
-                  // insert in the middle
-                  //
-                  stCarrier * pIns = new stCarrier( t );
-                  pIns->succ( pC );
-               }
-            }
-            else
-            {
-               append( t );
-            }
-            STLISTS_TRACE_END
-            return *this;
-         }
-
-   //
-   // PUBLIC:    stSortableList<T>::remove( int, T & )
-   //
-   // Remove the element at the index given ( -1 means the last element )
-   //
-   stSortableList<T>& remove( int Index, T& t )
-   {
-      stList<T>::remove( Index, t );
-      return *this;
-   }
-
-   //
-   // PUBLIC:    stSortableList<T>::remove( const T& )
-   //
-   // Remove all elements from the list, which are equal ("=" operator)
-   // to the given one.
-   //
-   stSortableList<T>& remove( const T& t )
-         {
-            STLISTS_TRACE_BEGIN("remove( const T & )")
-            stCarrier * pC = pFstCarrier;
-            while( pC )
-            {
-               stCarrier *pTmpC = pC->succ();
-               if( *(pC->info()) == t )
-               {
-                  if( pC == pFstCarrier ) pFstCarrier = pC->succ();
-                  if( pC == pLstCarrier ) pLstCarrier = pC->pred();
-                  pC->unlink();
-                  delete pC;
-                  pC = pTmpC;
-               }
-               else
-               {
-                  pC = pC->succ();
-               }
-            }
-            STLISTS_TRACE_END
-            return *this;
-         }
-
-};
-
-
-//-------------------------------------------------------------------
-//
-// stListCursor
-//
-//-------------------------------------------------------------------
-template<class T> class stListCursor
-{
-
-   //
-   // Private object data
-   //
-   const stList<T> *       pList;
-   stList<T>::stCarrier *  pCarrier;
-public:
-
-   //
-   // PUBLIC:    stListCursor<T>::stListCursor()
-   //
-   // default constructor
-   //
-   stListCursor()
-         {
-            STLISTC_TRACE_BEGIN("stListCursor()")
-            pList = 0;
-            pCarrier = 0;
-            STLISTC_TRACE_END
-         }
-
-   //
-   // PUBLIC:    stListCursor<T>::stListCursor( const stList<T> & List )
-   //
-   // constructor, creates a cursor object for the list given
-   //
-   stListCursor( const stList<T> & List )
-         {
-            STLISTC_TRACE_BEGIN("stListCursor( const stList<T> & )")
-            pList = &List;
-            pCarrier = pList->pFstCarrier;
-            STLISTC_TRACE_END
-         };
-
-   //
-   // PUBLIC:    stListCursor<T>::stListCursor( const stListCursor<T> & List )
-   //
-   // copy constructor
-   //
-   stListCursor( const stListCursor<T> & Src )
-         {
-            STLISTC_TRACE_BEGIN("stListCursor( const stListCursor<T> & )")
-            pList = Src.pList;
-            pCarrier = Src.pCarrier;
-            STLISTC_TRACE_END
-         };
-
-   //
-   // PUBLIC:    stListCursor<T>::operator=( const stList<T> & )
-   //
-   // returns the current item
-   //
-   stListCursor<T>& operator=( const stList<T> & Src )
-         {
-            STLISTC_TRACE_BEGIN("operator=( const stList<T> & )")
-            pList = &Src;
-            pCarrier = pList->pFstCarrier;
-            STLISTC_TRACE_END
-            return *this;
-         }
-   //
-   // PUBLIC:    stListCursor<T>::~stListCursor()
-   //
-   // destructor, destroys the cursor - not the list referred
-   //
-   ~stListCursor()
-         {
-            STLISTC_TRACE_BEGIN("~stListCursor()")
-            STLISTC_TRACE_END
-         };
-
-   //
-   // PUBLIC:    stListCursor<T>::getCurrent()
-   //
-   // returns a pointer to the item currently under the cursor
-   //
-   const T * getCurrent() const
-         {
-            STLISTC_TRACE_BEGIN("getCurrent()")
-            STLISTC_TRACE_END
-            if( pCarrier )
-               return pCarrier->info();
-            return 0;
-         }
-
-   //
-   // PUBLIC:    stListCursor<T>::getFirst()
-   //
-   // returns a pointer to the first item in the list
-   //
-   const T * getFirst()
-         {
-            STLISTC_TRACE_BEGIN("getFirst()")
-            pCarrier = pList->pFstCarrier;
-            const T *pItem = getCurrent();
-            STLISTC_TRACE_END
-            return pItem;
-         }
-
-   //
-   // PUBLIC:    stListCursor<T>::getNext()
-   //
-   // returns a pointer to the next item in the list
-   //
-   const T * getNext()
-         {
-            STLISTC_TRACE_BEGIN("getFirst()")
-            operator++();
-            const T *pItem = getCurrent();
-            STLISTC_TRACE_END
-            return pItem;
-         }
-
-   //
-   // PUBLIC:    stListCursor<T>::eof()
-   //
-   // returns 0, if the cursor refers a valid position. 1 otherwise.
-   //
-   long eof() const
-         {
-            STLISTC_TRACE_BEGIN("eof()")
-            STLISTC_TRACE_END
-            if( pCarrier ) return 0;
-            else return 1;
-         }
-
-   //
-   // PUBLIC:    stListCursor<T>::operator++()
-   //
-   // prefix cursor increment
-   //
-   stListCursor<T> & operator++()
-         {
-            STLISTC_TRACE_BEGIN("operator++()")
-            if( pCarrier )
-            {
-               pCarrier = pCarrier->succ();
-            }
-            STLISTC_TRACE_END
-            return *this;
-         }
-
-   //
-   // PUBLIC:    stListCursor<T>::operator*()
-   //
-   // returns the current item
-   //
-   const T * operator*() const
-         {
-            STLISTC_TRACE_BEGIN("operator*()")
-            STLISTC_TRACE_END
-            if( pCarrier )
-               return pCarrier->info();
-            else
-               return 0;
-         }
-
-};
-
-
-#endif
-//-------------------------------------------------------------------
-//
-// End of file
-//
-//-------------------------------------------------------------------
-
diff --git a/Massai/cpp/CfgXMgr/inc/stString.hpp b/Massai/cpp/CfgXMgr/inc/stString.hpp
deleted file mode 100644
index ef332976..00000000
--- a/Massai/cpp/CfgXMgr/inc/stString.hpp
+++ /dev/null
@@ -1,84 +0,0 @@
-
-#ifndef STSTRING_HPP
-#define STSTRING_HPP
-
-class stString
-{
-   char *       _Buffer;
-   void _create( const char *Buf )
-   {
-      long Length = 0;
-      // count nbr of chars incl. term. zero
-      while( Buf[Length++] );
-      // allocate buffer
-      _Buffer = new char[Length];
-      // copy from source
-      while( Length-- ) { _Buffer[Length] = Buf[Length]; }
-   }
-   void _delete()
-   {
-      if( _Buffer )
-      {
-         delete _Buffer;
-         _Buffer = 0;
-      }
-   }
-public:
-   stString( const stString & Src )
-   {
-      if( Src._Buffer )
-      {
-         _create( Src._Buffer );
-      }
-      else
-      {
-         _Buffer = 0;
-      }
-   }
-   stString()
-   {
-      _Buffer = 0;
-   }
-   stString( const char *Src )
-   {
-      if( Src )
-      {
-         _create( Src );
-      }
-      else
-      {
-         _Buffer = 0;
-      }
-   }
-   ~stString()
-   {
-      _delete();
-   }
-   stString & operator =( const stString & Src )
-   {
-      _delete();
-      if( Src._Buffer )
-      {
-         _create( Src._Buffer );
-      }
-      return *this;
-   }
-   operator char *()
-   {
-      if (_Buffer)
-        return _Buffer;
-      else
-        return "";  
-   }
-   operator const char *() const
-   {
-      if (_Buffer)
-        return _Buffer;
-      else
-        return "";  
-   }
-};
-
-#endif
-
-
diff --git a/Massai/cpp/CfgXMgr/inc/tcpComm.h b/Massai/cpp/CfgXMgr/inc/tcpComm.h
deleted file mode 100644
index 9731fb50..00000000
--- a/Massai/cpp/CfgXMgr/inc/tcpComm.h
+++ /dev/null
@@ -1,292 +0,0 @@
-/**
- **************************************************************************
- * 
- * @file tcpComm.h
- * 
- * Contains tcpComm interface definitions.
- * 
- * @author RB, JK
- *
- * Copyright (c) 1997-2000 MATERNA Information & Communications.
- * 
- **************************************************************************
-**/
-#ifndef TCPCOMM_H
-#define TCPCOMM_H
-
-//! Forward declaration
-class _tcpComm;
-
-//! The type to use for the 16-bit port numbers.
-typedef unsigned short portnumber;
-
-/**
- **************************************************************************
- * 
- * Every instance of this class can handle a TCP/IP session.
- * 
- **************************************************************************
-**/
-class tcpComm
-{
-   
-   /**
-    * 
-    * Private reference.
-    * 
-   **/
-   _tcpComm  *handle;
-
-public:
-
-   /**
-    * 
-    * Standard constructor - intentionally not implemented.
-    * 
-   **/
-   tcpComm();
-
-   /**
-    * 
-    * Copy constructor - intentionally not implemented.
-    * 
-   **/
-   tcpComm( tcpComm const & );
-   
-   /**
-    * 
-    * Assignment operator - intentionally not implemented.
-    * 
-   **/
-   tcpComm & operator=( tcpComm const & );
-   
-   /**
-    * 
-    * Server object constructor.
-    * 
-    * @param Port The portnumber to listen to.
-    * 
-   **/
-   tcpComm( portnumber Port );
-
-   /**
-    * 
-    * Client object constructor.
-    * 
-    * @param Port The portnumber to connect to.
-    * 
-    * @param szHost The (remote?) server host.
-    * 
-   **/
-   tcpComm( portnumber, char const * szHost );
-
-   /**
-    * 
-    * Client object constructor.
-    * 
-    * @param Port The portnumber to connect to.
-    * 
-    * @param szHost The (remote?) server host.
-    * 
-    * @param bDontLinger 0: same as tcpComm(portnumber, const * szHost);
-    *                    <>0: wait for complete message sent.
-    * 
-   **/
-   tcpComm( portnumber, char const * szHost, int bDontLinger );
-
-   /**
-    * 
-    * Server object constructor.
-    * 
-    * @param szService The service to listen to.
-    * 
-   **/
-   tcpComm( char const * szService );
-
-   /**
-    * 
-    * Client object constructor.
-    * 
-    * @param szService The target service to connect to to. If the host
-    *                  is remote, the service name port mapping should be
-    *                  as on the local host.
-    * 
-    * @param szHost   The target host.
-    * 
-   **/
-   tcpComm( char const * szService, char const * szHost );
-
-
-   /**
-    * 
-    * Client object constructor.
-    * 
-    * @param szService The target service to connect to to. If the host
-    *                  is remote, the service name port mapping should be
-    *                  as on the local host.
-    * 
-    * @param szHost   The target host.
-    * 
-    * @param bDontLinger 0: same as tcpComm(portnumber, const * szHost);
-    *                    <>0: wait for complete message sent.
-    * 
-   **/
-   tcpComm( char const * szService, char const * szHost, int bDontLinger );
-   
-   /**
-    * 
-    * Destructor
-    * 
-   **/
-    ~tcpComm();
-
-   /**
-    * 
-    * Cancel a blocking call.
-    * 
-   **/
-   void cancel();
-
-   /**
-    * 
-    * Open blocks until session could be established or number of retries
-    * fails
-    * 
-    * @param retry The number of retries (0 means repeat for ever).
-    * 
-    * @note a server object will always block
-    * 
-    * @return 0 on success.
-    * 
-   **/
-   long open(long retry = 0);
-
-   /**
-    * 
-    * Blocks until session could be established or number of retries fails.
-    * 
-    * @param szAddress Buffer to write the dot address format (e.g. 10.20.0.1).
-    * 
-    * @param szHost Buffer to write the logical host name (if available).
-    * 
-    * @param retry The number of retries (0 means repeat for ever).
-    *
-    * @note a server object will always block
-    * 
-    * @return 0 on success.
-    * 
-   **/
-   long open(char szAddress[16], char szHost[128] = 0, long retry = 0 );
-
-   /**
-    * 
-    * Blocks until session could be established or number of retries fails.
-    * 
-    * @param szHostAddr Buffer to write the dot address format (e.g. 10.20.0.1).
-    * 
-    * @param pPort Buffer to write the portnumber.
-    * 
-    * @param szHostName Buffer to write the logical host name (if available).
-    * 
-    * @param szService Buffer to write the logical service name (if available).
-    * 
-    * @param retry The number of retries (0 means repeat for ever).
-    *
-    * @note a server object will always block
-    * 
-    * @return 0 on success.
-    * 
-   **/
-   long open
-        (
-           char szHostAddr[16],
-           portnumber * pPort,
-           char szHostName[128] = 0,
-           char szService[128] = 0,
-           long retry = 0
-        );
-
-   /**
-    * 
-    * Retrieve the own portnumber.
-    * 
-    * @return The portnumber.
-    * 
-   **/
-   portnumber port() const;
-   
-   /**
-    * 
-    * Blocks until destlen character are read into destination.
-    * 
-    * @param dst Buffer to write the received data to.
-    * 
-    * @param dstlen Size of dst buffer.
-    * 
-    * @return 0 on success.
-    *
-   **/
-   long read ( char *dst, long dstlen );
-
-   /**
-    * 
-    * Write data over a session. Blocks until all bytes are written.
-    * 
-    * @param src The data to write.
-    * 
-    * @param srclen The number of bytes to write.
-    * 
-    * @return 0 on success
-    * 
-   **/
-   long writeblocking( char const *src, long srclen );
-
-   /**
-    * 
-    * Write data over a session.
-    * 
-    * @param src The data to write.
-    * 
-    * @param srclen The number of bytes to write.
-    * 
-    * @return 0 on success
-    * 
-   **/
-   long write( char const *src, long srclen );
-
-   /**
-    * 
-    * Close a session.
-    * 
-    * @return 0 on success
-    * 
-   **/
-   long close();
-
-};
-
-/**
- * 
- * @return pointer to own ip address in the dot address format (e.g. 255.255.255.244 ).
- * 
-**/
-char const *tcpGetIpAddress();
-
-/**
- * 
- * Write logging information to the file specified.
- *
- * @param Filename The log file to use.
- * 
-**/
-void tcpCommModuleLog( char const * Filename );
-
-#endif
-/**
- **************************************************************************
- * 
- * End of file
- * 
- **************************************************************************
-**/
-
diff --git a/Massai/cpp/CfgXMgr/inc/writeTrace.hpp b/Massai/cpp/CfgXMgr/inc/writeTrace.hpp
deleted file mode 100644
index 261133ba..00000000
--- a/Massai/cpp/CfgXMgr/inc/writeTrace.hpp
+++ /dev/null
@@ -1,69 +0,0 @@
-/**
- **************************************************************************
- *
- * @file writeTrace.hpp
- *
- * Trace function declarations for configuration server.
- *
- * @author JK
- *
- * Copyright (c) 2002 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef WRITETRACE_HPP
-#define WRITETRACE_HPP
-
-#include "TraceClt.h"
-#include "Asso.h"
-#include <iostream>
-
-
-/**
- *
- * Dump a map to the trace.
- *
- * @param 1. Trace level for this call
- *
- * @param 2. Module name
- *
- * @param 3. Line number
- *
- * @param 4. Function name
- *
- * @param 5. Trace title
- *
- * @param 6. Map to dump
- *
-**/
-void writeTraceMap
-(
-   long,
-   char const *, short, char const *,
-   char const *, aMap const &
-);
-
-
-/**
- *
- * Initialize tracing.
- *
- * @param 1. Stream to use for traces.
- *
- * @param 2. Trace level threshold.
- *
-**/
-void writeTrace_Init( std::ostream &, long );
-
-
-#define __FUNCTION__ ""
-
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgr/res/CfgXMgr.rc b/Massai/cpp/CfgXMgr/res/CfgXMgr.rc
deleted file mode 100644
index 31714416..00000000
--- a/Massai/cpp/CfgXMgr/res/CfgXMgr.rc
+++ /dev/null
@@ -1,109 +0,0 @@
-#include "Global_def.h"
-#include "CfgXMgr_def.h"
-
-
-//IDI_ICON1 ICON "res\massai30.ico"
-//IDI_ICON2 ICON "res\massai16x16.ico"
-
-#define APSTUDIO_READONLY_SYMBOLS
-/////////////////////////////////////////////////////////////////////////////
-//
-// Generated from the TEXTINCLUDE 2 resource.
-//
-#include "afxres.h"
-
-/////////////////////////////////////////////////////////////////////////////
-#undef APSTUDIO_READONLY_SYMBOLS
-
-/////////////////////////////////////////////////////////////////////////////
-// German (Germany) resources
-
-#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_DEU)
-#ifdef _WIN32
-LANGUAGE LANG_GERMAN, SUBLANG_GERMAN
-#pragma code_page(1252)
-#endif //_WIN32
-
-#ifndef _MAC
-/////////////////////////////////////////////////////////////////////////////
-//
-// Version
-//
-
-VS_VERSION_INFO VERSIONINFO
- FILEVERSION FILE_VER_BIN
- PRODUCTVERSION PRODUCT_VER_BIN
- FILEFLAGSMASK 0x3fL
-#ifdef _DEBUG
- FILEFLAGS 0x1L
-#else
- FILEFLAGS 0x0L
-#endif
- FILEOS 0x40004L
- FILETYPE 0x2L
- FILESUBTYPE 0x0L
-BEGIN
-    BLOCK "StringFileInfo"
-    BEGIN
-        BLOCK "040704b0"
-        BEGIN
-            VALUE COMPANY
-			VALUE FILEDESCRIPTION
-			VALUE FILE_VER_STR
-			VALUE INTERNALNAME
-			VALUE COPYRIGHT
-			VALUE LEGALTRADEMARKS
-			VALUE ORIGINALFILENAME
-			VALUE PRODUCT
-            VALUE PRODUCT_VER_STR
-        END
-    END
-    BLOCK "VarFileInfo"
-    BEGIN
-        VALUE "Translation", 0x407, 1200
-    END
-END
-
-#endif    // !_MAC
-
-
-#ifdef APSTUDIO_INVOKED
-/////////////////////////////////////////////////////////////////////////////
-//
-// TEXTINCLUDE
-//
-
-1 TEXTINCLUDE DISCARDABLE
-BEGIN
-    "resource.h\0"
-END
-
-2 TEXTINCLUDE DISCARDABLE
-BEGIN
-    "#include ""afxres.h""\r\n"
-    "\0"
-END
-
-3 TEXTINCLUDE DISCARDABLE
-BEGIN
-    "\r\n"
-    "\0"
-END
-
-#endif    // APSTUDIO_INVOKED
-
-#endif    // German (Germany) resources
-/////////////////////////////////////////////////////////////////////////////
-
-
-
-#ifndef APSTUDIO_INVOKED
-/////////////////////////////////////////////////////////////////////////////
-//
-// Generated from the TEXTINCLUDE 3 resource.
-//
-
-
-/////////////////////////////////////////////////////////////////////////////
-#endif    // not APSTUDIO_INVOKED
-
diff --git a/Massai/cpp/CfgXMgr/res/MassaiCfgX.rc b/Massai/cpp/CfgXMgr/res/MassaiCfgX.rc
deleted file mode 100644
index 2803870c..00000000
--- a/Massai/cpp/CfgXMgr/res/MassaiCfgX.rc
+++ /dev/null
@@ -1,109 +0,0 @@
-#include "Global_def.h"
-#include "MassaiCfgX_def.h"
-
-
-//IDI_ICON1 ICON "res\massai30.ico"
-//IDI_ICON2 ICON "res\massai16x16.ico"
-
-#define APSTUDIO_READONLY_SYMBOLS
-/////////////////////////////////////////////////////////////////////////////
-//
-// Generated from the TEXTINCLUDE 2 resource.
-//
-#include "afxres.h"
-
-/////////////////////////////////////////////////////////////////////////////
-#undef APSTUDIO_READONLY_SYMBOLS
-
-/////////////////////////////////////////////////////////////////////////////
-// German (Germany) resources
-
-#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_DEU)
-#ifdef _WIN32
-LANGUAGE LANG_GERMAN, SUBLANG_GERMAN
-#pragma code_page(1252)
-#endif //_WIN32
-
-#ifndef _MAC
-/////////////////////////////////////////////////////////////////////////////
-//
-// Version
-//
-
-VS_VERSION_INFO VERSIONINFO
- FILEVERSION FILE_VER_BIN
- PRODUCTVERSION PRODUCT_VER_BIN
- FILEFLAGSMASK 0x3fL
-#ifdef _DEBUG
- FILEFLAGS 0x1L
-#else
- FILEFLAGS 0x0L
-#endif
- FILEOS 0x40004L
- FILETYPE 0x2L
- FILESUBTYPE 0x0L
-BEGIN
-    BLOCK "StringFileInfo"
-    BEGIN
-        BLOCK "040704b0"
-        BEGIN
-            VALUE COMPANY
-			VALUE FILEDESCRIPTION
-			VALUE FILE_VER_STR
-			VALUE INTERNALNAME
-			VALUE COPYRIGHT
-			VALUE LEGALTRADEMARKS
-			VALUE ORIGINALFILENAME
-			VALUE PRODUCT
-            VALUE PRODUCT_VER_STR
-        END
-    END
-    BLOCK "VarFileInfo"
-    BEGIN
-        VALUE "Translation", 0x407, 1200
-    END
-END
-
-#endif    // !_MAC
-
-
-#ifdef APSTUDIO_INVOKED
-/////////////////////////////////////////////////////////////////////////////
-//
-// TEXTINCLUDE
-//
-
-1 TEXTINCLUDE DISCARDABLE
-BEGIN
-    "resource.h\0"
-END
-
-2 TEXTINCLUDE DISCARDABLE
-BEGIN
-    "#include ""afxres.h""\r\n"
-    "\0"
-END
-
-3 TEXTINCLUDE DISCARDABLE
-BEGIN
-    "\r\n"
-    "\0"
-END
-
-#endif    // APSTUDIO_INVOKED
-
-#endif    // German (Germany) resources
-/////////////////////////////////////////////////////////////////////////////
-
-
-
-#ifndef APSTUDIO_INVOKED
-/////////////////////////////////////////////////////////////////////////////
-//
-// Generated from the TEXTINCLUDE 3 resource.
-//
-
-
-/////////////////////////////////////////////////////////////////////////////
-#endif    // not APSTUDIO_INVOKED
-
diff --git a/Massai/cpp/CfgXMgr/src/Asso.cpp b/Massai/cpp/CfgXMgr/src/Asso.cpp
deleted file mode 100644
index 7ac1b517..00000000
--- a/Massai/cpp/CfgXMgr/src/Asso.cpp
+++ /dev/null
@@ -1,494 +0,0 @@
-/*
- * ASSO.CPP
- *
- * associative array class
- *
- * history:
- * KW 8/97: initial coding
- * 090597rb use refcnt
- * 150997rb getFirstKey/getLastKey correct: none objects (DEL/NIL)
- *          have no key!!
- * 220997rb mapObject returns always a correct object
- * 161297rb aObject((char*)0) creates an deleted object
- * 130198rb OBJ_DEL behaviour corrected
- * 050298rb aObject is able to handle binaery memory
- * 120298rb remove getFirstKey method
- * 110398rb fix self assignment problem e.g. a = a.get( "hello" );
- * 020999rbts fix clear key problem e.g. a.set( "hello", aObject() ); - same behaviour as a.set( "hello", (char *)0 );
- * 210700rbts fix memory leak for copy constructor of aMap
- * 250700rbts use -D_MULTI_THREAD definition to use critical sections within all public member functions
- * 260700rb   add UNLOCK for each required function return
- *
- * next changes:
- *
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "asso.h"
-
-#define MIN_SIZE        (13)
-enum { FALSE, TRUE };
-
-#ifdef  _MULTI_THREAD
-
-#include "mutex.hpp"
-
-static mutexSemaphore asso_mx;
-
-
-#define LOCK()      asso_mx.request()
-#define UNLOCK()    asso_mx.release()
-
-#else
-#define LOCK()
-#define UNLOCK()
-
-#endif
-
-
-
-class _aMap;
-
-struct oBuf
-{
-  long  lSize;
-  char *pData;
-  oBuf( const char *s, long len )
-  {
-    if(len)
-    {
-      lSize = len;
-      pData = new char[lSize+1];
-      memcpy(pData, s, len);
-      pData[len] = 0;     // trailing zero!!
-    }
-    else
-    {
-      lSize = 0; pData = 0;
-    }
-  }
-  ~oBuf() { delete pData; }
-};
-
-union ObjV
-{
-  long    v_num;
-  oBuf   *v_str;
-  _aMap  *v_map;
-};
-
-//
-// the _aBuf class gives/hides access to information
-//
-class _aMap
-{
-public:
-  struct pair {
-    aObject    key;
-    aObject    val;
-  };
-
-  pair    *sTab;
-  short    limit,       // table size
-           used,
-           fence,
-           bgrow;
-
-  _aMap( const long n )
-  {
-    fence = (short)n;
-    if( fence < 3 ) fence = 3;
-    used = bgrow = 0;
-    limit =(short)((fence * 10)/7);
-    sTab = new pair[limit];
-  }
-
-  _aMap( const _aMap& src )
-  {
-    fence = src.fence; bgrow = 0;
-    used  = src.used;
-    limit = src.limit;
-    sTab = new pair[limit];
-    for(long i=0; i<limit; i++)
-    { // copy contents
-      sTab[i].key = src.sTab[i].key;
-      sTab[i].val = src.sTab[i].val;
-    }
-  }
-
-  ~_aMap() { delete [] sTab; }
-
-};
-
-class _aObject
-{
-  public:
-  int   refcnt;
-  ObjT  tag;
-  ObjV  val;
-  _aObject()           { tag = OBJ_NIL; refcnt = 1;}
-  ~_aObject()
-  {
-    switch( tag )
-    {
-      case OBJ_STR: delete    val.v_str;  break;
-      case OBJ_MAP: delete    val.v_map; break;
-    }
-  }
-};
-
-aMap::aMap(): aObject()
-{
-  LOCK();
-  handle->tag= OBJ_MAP;
-  handle->val.v_map = new _aMap(MIN_SIZE);
-  UNLOCK();
-}
-
-aMap::aMap(long n): aObject()
-{
-  LOCK();
-  handle->tag= OBJ_MAP;
-  handle->val.v_map = new _aMap(n);
-  UNLOCK();
-}
-
-// copy constructor
-aMap::aMap( const aMap &src ) /* : aObject() */
-{
-  LOCK();
-  delete handle;
-  handle = src.handle;
-  handle->refcnt++;
-  UNLOCK();
-}
-
-aMap::~aMap()
-{ // do nothing - reference freed by aObject destructor!!
-}
-
-static long hash( const char *s, long cnt )
-{
-  char *p = (char *) s;
-  long sum = 0;
-  while( cnt-- )
-    sum = ((sum<<5)-sum)^(unsigned char) *p++;
-  return sum;
-}
-
-static inline long equalObj( const aObject& a, const aObject& b)
-{
-  ObjT atag = a.getTag();
-  if( atag != b.getTag() ) return FALSE;
-  switch( atag )
-  {
-    case OBJ_NUM: return a.numObject() == b.numObject();
-    case OBJ_STR: return !strcmp(a.strObject(), b.strObject());
-    case OBJ_MAP: return &a.mapObject() == &b.mapObject();
-  }
-  return FALSE;
-}
-
-static long hashindex( _aMap& tab, const aObject& key)
-{
-  long n;
-  switch( key.getTag() )
-  {
-    case OBJ_NUM:       n = key.numObject(); break;
-    case OBJ_STR:       n = hash(key.strObject(), key.count()); break;
-    case OBJ_MAP:       n = (long)&key.mapObject(); break;
-    default:            n = 0; break;
-  }
-  if( n < 0 ) n = -n;
-  return n % tab.limit;
-}
-
-_aMap::pair& getEntry( _aMap& tab, long index, const aObject& key )
-{
-  long lOldIndex = index;
-  long lLastDel = index;
-  ObjT ttag;
-
-  while( (ttag = tab.sTab[index].val.getTag()) != OBJ_NIL )
-  { // collision or hit
-    if(equalObj(tab.sTab[index].key, key))
-      return tab.sTab[index];
-
-    if(ttag == OBJ_DEL)
-      lLastDel = index;
-
-    index = (index+1) % tab.limit;
-
-    if (index == lOldIndex)  // endless loop detected return last DEL-object
-    {
-      index = lLastDel;
-      break;
-    }
-  }
-  tab.sTab[index].key = key;
-  return tab.sTab[index];
-}
-
-aObject::aObject()
-{
-  LOCK();
-  handle = new _aObject();
-  UNLOCK();
-}
-
-aObject::aObject( const long val )
-{
-  LOCK();
-  handle = new _aObject();
-  *this = val;
-  UNLOCK();
-}
-
-aObject::aObject( const char *val )
-{
-  LOCK();
-  handle = new _aObject();
-  *this = val;
-  UNLOCK();
-}
-
-aObject::aObject( const char *val, long len )
-{
-  LOCK();
-  handle = new _aObject();
-  if( len )
-  {
-    handle->tag = OBJ_STR;
-    handle->val.v_str = new oBuf(val, len);
-  }
-  UNLOCK();
-}
-
-aObject::aObject(const aObject& obj)
-{
-  LOCK();
-  handle = obj.handle;
-  handle->refcnt++;
-  UNLOCK();
-}
-
-ObjT aObject::getTag() const
-{
-  return handle->tag;
-}
-
-// returns FALS if object contains data
-long aObject::isEmpty()   const
-{
-  return (handle->tag < OBJ_NUM);
-}
-
-long aObject::count() const
-{
-  switch( handle->tag )
-  {
-    case OBJ_STR: return handle->val.v_str->lSize;
-    case OBJ_NUM: return sizeof(long);
-    case OBJ_MAP: return handle->val.v_map->used;
-  }
-  return 0;
-}
-
-const char *aObject::strObject() const
-{
-   return (handle->tag == OBJ_STR)? handle->val.v_str->pData: NULL;
-}
-
-long        aObject::numObject() const
-{
-  return (handle->tag == OBJ_NUM)? handle->val.v_num: -1;
-}
-
-// 220897rb return empty object if no OBJ_MAP tag
-aMap&       aObject::mapObject() const
-{
-  LOCK();
-  if(handle->tag == OBJ_MAP)
-  {
-    UNLOCK();
-    return (aMap&) *this;
-  }
-  static aMap dum;
-  dum.clr();
-  UNLOCK();
-  return dum;
-}
-
-aObject::~aObject()
-{  // release memory if allocated
-  LOCK();
-  if( !(--(handle->refcnt)))
-  {
-    delete handle;
-    handle = 0;
-  }
-  UNLOCK();
-}
-
-// clear whole contents
-long aObject::clr()
-{
-  LOCK();
-  ObjT tag = handle->tag;
-  if( !(--(handle->refcnt)))
-    delete handle;
-  handle = new _aObject();
-  if( tag == OBJ_MAP )
-  {
-    handle->tag= OBJ_MAP;
-    handle->val.v_map = new _aMap(MIN_SIZE);
-  }
-  UNLOCK();
-  return 0;
-}
-
-aObject& aObject::operator=(const aObject& obj)
-{
-  LOCK();
-  if( this != &obj )
-  {  // release memory if allocated
-    obj.handle->refcnt++; // lock
-    if( !(--(handle->refcnt)))
-      delete handle;
-    obj.handle->refcnt--; // unlock
-    handle = obj.handle;
-    handle->refcnt++;
-  }
-  UNLOCK();
-  return *this;
-}
-
-aObject& aObject::operator=(const char *str)
-{  // release memory if allocated
-  LOCK();
-  if( !(--(handle->refcnt)))
-    delete handle;
-  handle = new _aObject();
-  if( str )
-  {
-    handle->tag = OBJ_STR;
-    handle->val.v_str = new oBuf(str, strlen(str) + 1);
-  }
-  else
-  { // 161297rb mark as deleted
-    handle->tag = OBJ_DEL;
-  }
-  UNLOCK();
-  return *this;
-}
-
-aObject& aObject::operator=(long n)
-{  // release memory if allocated
-  LOCK();
-  if( !(--(handle->refcnt)))
-    delete handle;
-  handle = new _aObject();
-  handle->tag = OBJ_NUM;
-  handle->val.v_num = n;
-  UNLOCK();
-  return *this;
-}
-
-aMap& aMap::set( const aObject& key, const aObject& val)
-{
-  LOCK();
-  int reorg = 0;
-  aObject cpval = val;           // temporary copy
-  if( handle->refcnt > 1)
-  { // make a copy
-    _aMap *pHlp = handle->val.v_map;
-
-    handle->refcnt--;   // release ref
-    handle = new _aObject();
-    handle->tag= OBJ_MAP;
-    handle->val.v_map = new _aMap(*pHlp);
-  }
-
-  _aMap& d = *handle->val.v_map;
-  _aMap::pair& o= getEntry(*handle->val.v_map, hashindex(*handle->val.v_map, key), key);
-  if( o.val.getTag() <= OBJ_DEL )
-  { // entry not found
-    if( val.getTag() > OBJ_DEL)
-    { // new entry
-      if(++d.used == d.fence )
-        reorg = 1;      // grow
-    }
-  }
-  else
-  { // entry found
-    if(val.getTag() <= OBJ_DEL)
-    { // entry deleted
-      o.key = (char *)0;
-      cpval = (char *)0;
-      if(--d.used < d.limit/4 && d.bgrow)
-        reorg = 2;      // shrink
-    }
-  }
-  o.val = cpval;
-  if( reorg )
-  {
-    if( reorg == 1 )
-    { // grow
-      handle->val.v_map = new _aMap(d.limit << 1);
-      handle->val.v_map->bgrow = TRUE;
-    }
-    else
-    { // shrink
-      handle->val.v_map = new _aMap(d.limit >> 1);
-    }
-    for( long i=0; i<d.limit; i++ )
-      if(d.sTab[i].val.getTag() >= OBJ_NUM )
-        set(d.sTab[i].key, d.sTab[i].val);
-    delete &d;  // to be checked!!!
-  }
-  UNLOCK();
-
-  return(*this);
-}
-
-aMap& aMap::add( const aObject& key, const aObject& val)
-{
-    return(set(key,val));
-}
-
-const aObject& aMap::get( const aObject& key) const
-{
-  LOCK();
-  const aObject& e = getEntry(*handle->val.v_map, hashindex(*handle->val.v_map, key), key).val;
-  UNLOCK();
-  return e;
-}
-
-const aObject   *aMap::getNextKey (const aObject *pKey) const
-{
-  LOCK();
-  long index = 0;
-  _aMap& d = *handle->val.v_map;
-  if(pKey)
-  {
-/* search pKey */
-    index = hashindex(d, *pKey);
-    while( &d.sTab[index].key != pKey )
-      index = (index+1) % d.limit;
-/* step on */
-    index++;
-  }
-  for( long i=index; i<d.limit; i++ )
-    if(d.sTab[i].val.getTag() >= OBJ_NUM )
-    {
-      UNLOCK();
-      return &d.sTab[i].key;
-    }
-  UNLOCK();
-  return 0;
-}
-/*
-** *** end of file ***
-*/
diff --git a/Massai/cpp/CfgXMgr/src/AssoCStr.cpp b/Massai/cpp/CfgXMgr/src/AssoCStr.cpp
deleted file mode 100644
index e2b7538f..00000000
--- a/Massai/cpp/CfgXMgr/src/AssoCStr.cpp
+++ /dev/null
@@ -1,535 +0,0 @@
-/**
- **************************************************************************
- * 
- * @file AssoCStr.cpp
- * 
- * Contains the implementation for function prototypes in AssoCStr.hpp.
- * 
- * @author JK
- * 
- * Copyright (c) 2000-2002 MATERNA Information & Communications
- * 
- **************************************************************************
-**/
-
-
-#include "AssoCStr.hpp"
-
-#include <stdlib.h>
-#include <limits.h>
-
-
-
-/**
- *
- * Size-type used here.
- *
-**/
-typedef unsigned long asize;
-
-
-
-/**
- **************************************************************************
- * 
- * Write a single char to a buffer.
- * 
- * @param DstPtr    Start of buffer, adjusted on return to next start.
- * 
- * @param DstSiz    Length of buffer, adjusted on return to new length.
- *
- * @param Src       The char to write.
- * 
- **************************************************************************
-**/
-static inline void toBuffer_C
-(
-   char * &      DstPtr,
-   asize &        DstSiz,
-   char          Src
-)
-{
-   if( DstSiz )
-   {
-      --DstSiz;
-      if( DstPtr )
-         *DstPtr++ = Src;
-   }
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Write a C-string to a buffer.
- * 
- * @param DstPtr    Start of buffer, adjusted on return to next start.
- * 
- * @param DstSiz    Length of buffer, adjusted on return to new length.
- *
- * @param Src       The string (zero-terminated) to write.
- * 
- **************************************************************************
-**/
-static void toBuffer
-(
-   char * &      DstPtr,
-   asize &        DstSiz,
-   char const *  Src
-)
-{
-   if( Src )
-   {
-      while( *Src && DstSiz )
-         toBuffer_C( DstPtr, DstSiz, *Src++ );
-   }
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Write a C-string to a buffer (flagged with []).
- * 
- * @param DstPtr    Start of buffer, adjusted on return to next start.
- * 
- * @param DstSiz    Length of buffer, adjusted on return to new length.
- *
- * @param Src       The string (zero-terminated) to write.
- * 
- * @param CutString String objects are cut before this offset (0 = no cut).
- * 
- **************************************************************************
-**/
-static void toBuffer_F
-(
-   char * &      DstPtr,
-   asize &        DstSiz,
-   char const *  Src,
-   unsigned long CutString
-)
-{
-   if( Src )
-   {
-      toBuffer_C( DstPtr, DstSiz, '[' );
-      while( *Src && DstSiz && --CutString )
-      {
-         char X = *Src++;
-         switch( X )
-         {
-         case ']':
-         case '\\':
-         case '[':
-            toBuffer_C( DstPtr, DstSiz, '\\' );
-         default:
-            toBuffer_C( DstPtr, DstSiz, X );
-         }
-      }
-      toBuffer_C( DstPtr, DstSiz, ']' );
-      if( CutString == 0 )
-         toBuffer_C( DstPtr, DstSiz, '+' );
-   }
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Write a long variable to a buffer.
- * 
- * @param DstPtr    Start of buffer, adjusted on return to next start.
- * 
- * @param DstSiz    Length of buffer, adjusted on return to new length.
- *
- * @param Src       The variable to write.
- * 
- **************************************************************************
-**/
-static void toBuffer
-(
-   char * & DstPtr,
-   asize &   DstSiz,
-   long     Src
-)
-{
-   char Temp[40];
-   itoa( Src, Temp, 10 );
-   toBuffer( DstPtr, DstSiz, Temp );
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Write a new-line to a buffer.
- * 
- * @param DstPtr    Start of buffer, adjusted on return to next start.
- * 
- * @param DstSiz    Length of buffer, adjusted on return to new length.
- * 
- **************************************************************************
-**/
-static void toBufferNL
-(
-   char * & DstPtr,
-   asize &   DstSiz
-)
-{
-   toBuffer( DstPtr, DstSiz, "\n" );
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Write an aMap variable to a buffer.
- * 
- * @param DstPtr    Start of buffer, adjusted on return to next start.
- * 
- * @param DstSiz    Length of buffer, adjusted on return to new length.
- * 
- * @param Src       The aMap to be copied.
- * 
- * @param Lvl       The current tab level.
- * 
- * @param Tab       String to be used for mapObject separation.
- * 
- * @param Indent    String to be used as an indentation.
- * 
- * @param CutString String objects are cut before this offset (0 = no cut).
- * 
- **************************************************************************
-**/
-static void toBuffer
-(
-   char * &        DstPtr,
-   asize &          DstSiz,
-   aMap const &    Src,
-   int             Lvl,
-   aMap const &    Format,
-   char const *    Tab,
-   char const *    Indent,
-   unsigned long   CutString
-)
-{
-   const aObject *pKey = 0;
-   while( ( pKey = Src.getNextKey( pKey )) != 0 )
-   {
-      //
-      // Write indentation
-      //
-      toBuffer( DstPtr, DstSiz, Indent );
-      for( int i=0; i< Lvl; i++ )
-         toBuffer( DstPtr, DstSiz, Tab );
-
-      aObject Value = Src.get(*pKey);
-      char const * FormatPair = Format
-                                 .get( *pKey ).mapObject()
-                                 .get( Value ).strObject();
-      if( FormatPair )
-      {
-         //
-         // Format match -> write translation
-         //
-         toBuffer( DstPtr, DstSiz, FormatPair );
-         toBufferNL( DstPtr, DstSiz );
-      }
-      else
-      {
-         //
-         // No format match -> write key
-         //
-         switch( pKey->getTag() )
-         {
-         case OBJ_NIL:
-         case OBJ_DEL:
-            break;
-         case OBJ_NUM:
-            toBuffer( DstPtr, DstSiz, pKey->numObject() );
-            break;
-         case OBJ_STR:
-            toBuffer_F( DstPtr, DstSiz, pKey->strObject(), CutString );
-            break;
-         case OBJ_MAP:
-            break;
-         }
-         //
-         // Write value
-         //
-         switch( Src.get(*pKey).getTag() )
-         {
-         case OBJ_NIL:
-         case OBJ_DEL:
-            break;
-         case OBJ_NUM:
-            toBuffer( DstPtr, DstSiz, " = " );
-            toBuffer( DstPtr, DstSiz, Src.get(*pKey).numObject() );
-            toBufferNL( DstPtr, DstSiz );
-            break;
-         case OBJ_STR:
-            toBuffer( DstPtr, DstSiz, " = " );
-            toBuffer_F( DstPtr, DstSiz, Src.get(*pKey).strObject(), CutString );
-            toBufferNL( DstPtr, DstSiz );
-            break;
-         case OBJ_MAP:
-            toBuffer( DstPtr, DstSiz, " =" );
-            toBufferNL( DstPtr, DstSiz );
-            toBuffer
-            (
-               DstPtr, DstSiz,
-               Src.get(*pKey).mapObject(), Lvl + 1,
-               Format,
-               Tab, Indent, CutString
-            );
-            break;
-         }
-      }
-   }
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Write an aMap variable to a buffer.
- * 
- * @param DstPtr    Start of buffer, adjusted on return to next start.
- * 
- * @param DstSiz    Length of buffer, adjusted on return to new length.
- * 
- * @param Src       The aMap to be copied.
- * 
- * @param Lvl       The current tab level.
- * 
- * @param Tab       String to be used for mapObject separation.
- * 
- * @param Indent    String to be used as an indentation.
- * 
- * @param CutString String objects are cut before this offset (0 = no cut).
- * 
- **************************************************************************
-**/
-static void toBuffer
-(
-   char * &        DstPtr,
-   asize &          DstSiz,
-   aMap const &    Src,
-   int             Lvl,
-   char const *    Tab,
-   char const *    Indent,
-   unsigned long   CutString
-)
-{
-   const aObject *pKey = 0;
-   while( ( pKey = Src.getNextKey( pKey )) != 0 )
-   {
-      //
-      // Write indentation
-      //
-      toBuffer( DstPtr, DstSiz, Indent );
-      for( int i=0; i< Lvl; i++ )
-         toBuffer( DstPtr, DstSiz, Tab );
-      
-      //
-      // Write key
-      //
-      switch( pKey->getTag() )
-      {
-      case OBJ_NIL:
-      case OBJ_DEL:
-         break;
-      case OBJ_NUM:
-         toBuffer( DstPtr, DstSiz, pKey->numObject() );
-         break;
-      case OBJ_STR:
-         toBuffer_F( DstPtr, DstSiz, pKey->strObject(), CutString );
-         break;
-      case OBJ_MAP:
-         break;
-      }
-      //
-      // Write value
-      //
-      switch (Src.get(*pKey).getTag())
-      {
-      case OBJ_NIL:
-      case OBJ_DEL:
-         break;
-      case OBJ_NUM:
-         toBuffer( DstPtr, DstSiz, " = " );
-         toBuffer( DstPtr, DstSiz, Src.get(*pKey).numObject() );
-         toBufferNL( DstPtr, DstSiz );
-         break;
-      case OBJ_STR:
-         toBuffer( DstPtr, DstSiz, " = " );
-         toBuffer_F( DstPtr, DstSiz, Src.get(*pKey).strObject(), CutString );
-         toBufferNL( DstPtr, DstSiz );
-         break;
-      case OBJ_MAP:
-         toBuffer( DstPtr, DstSiz, " =" );
-         toBufferNL( DstPtr, DstSiz );
-         toBuffer
-         (
-            DstPtr, DstSiz,
-            Src.get(*pKey).mapObject(), Lvl + 1, Tab, Indent, CutString
-         );
-         break;
-      }
-   }
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Public function - see AssoCStr.hpp
- * 
- **************************************************************************
-**/
-asize assoCStr
-(
-   char *           DstBegin,
-   char const *     DstEnd,
-   aObject const &  Src,
-   aMap const &     Format,
-   char const *     Tab,
-   char const *     Indent,
-   unsigned long    CutString
-)
-{
-   asize DstSiz = DstEnd - DstBegin;
-   char * Dst = DstBegin;
-   switch( Src.getTag() )
-   {
-   case OBJ_NIL:
-   case OBJ_DEL:
-      break;
-   case OBJ_NUM:
-      toBuffer( Dst, DstSiz, Src.numObject() );
-      break;
-   case OBJ_STR:
-      toBuffer_F( Dst, DstSiz, Src.strObject(), CutString );
-      break;
-   case OBJ_MAP:
-      toBuffer
-      (
-         Dst, DstSiz,
-         Src.mapObject(), 1,
-         Format,
-         Tab, Indent, CutString
-      );
-      break;
-   }
-   if( Dst == DstEnd )
-   {
-      *(Dst-1) = 0;
-   }
-   else
-      *Dst = 0;
-   return Dst - DstBegin;
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Public function - see AssoCStr.hpp
- * 
- **************************************************************************
-**/
-asize assoCStr
-(
-   char *          DstBegin,
-   char const *    DstEnd,
-   aObject const & Src,
-   char const *    Tab,
-   char const *    Indent,
-   unsigned long   CutString
-)
-{
-   asize DstSiz = DstEnd - DstBegin;
-   char * Dst = DstBegin;
-   switch( Src.getTag() )
-   {
-   case OBJ_NIL:
-   case OBJ_DEL:
-      break;
-   case OBJ_NUM:
-      toBuffer( Dst, DstSiz, Src.numObject() );
-      break;
-   case OBJ_STR:
-      toBuffer_F( Dst, DstSiz, Src.strObject(), CutString );
-      break;
-   case OBJ_MAP:
-      toBuffer
-      (
-         Dst, DstSiz,
-         Src.mapObject(), 1,
-         Tab, Indent, CutString
-      );
-      break;
-   }
-   if( Dst == DstEnd )
-   {
-      *(Dst-1) = 0;
-   }
-   else
-      *Dst = 0;
-   return Dst - DstBegin;
-}
-
-
-
-/**
- **************************************************************************
- *
- * Public function - see AssoCStr.hpp
- * 
- **************************************************************************
-**/
-asize assoCStrSize
-(
-   aObject const & Src,
-   char const *    Tab,
-   char const *    Indent,
-   unsigned long   CutString
-)
-{
-   char * N = 0;
-   asize DstSiz = INT_MAX;
-   switch( Src.getTag() )
-   {
-   case OBJ_NIL:
-   case OBJ_DEL:
-      break;
-   case OBJ_NUM:
-      toBuffer( N, DstSiz, Src.numObject() );
-      break;
-   case OBJ_STR:
-      toBuffer_F( N, DstSiz, Src.strObject(), CutString );
-      break;
-   case OBJ_MAP:
-      toBuffer( N, DstSiz, Src.mapObject(), 1, Tab, Indent, CutString );
-      break;
-   }
-   return INT_MAX - DstSiz + 1;
-}
-
-
-
-/**
- **************************************************************************
- * 
- * End of file
- * 
- **************************************************************************
-**/
-
diff --git a/Massai/cpp/CfgXMgr/src/AssoCp.CPP b/Massai/cpp/CfgXMgr/src/AssoCp.CPP
deleted file mode 100644
index 94edc230..00000000
--- a/Massai/cpp/CfgXMgr/src/AssoCp.CPP
+++ /dev/null
@@ -1,56 +0,0 @@
-
-//
-// ASSOCP.CPP
-//
-// Implementation file for ~\ALL\INC\ASSOCP.H
-//
-//
-//
-
-#include "assocp.h"
-
-aMap& copyMap(aMap& Dst, const aMap& Src)
-{
-  aMap rDst;
-  const aObject *pKey = 0;
-  while( ( pKey = Src.getNextKey( pKey )) != 0 )
-  {
-    switch(pKey->getTag())
-    {
-      case OBJ_NUM:
-        switch (Src.get(*pKey).getTag())
-        {
-          case OBJ_NUM:
-            Dst.set(pKey->numObject(), Src.get(*pKey).numObject());
-            break;
-          case OBJ_STR:
-            Dst.set(pKey->numObject(), Src.get(*pKey).strObject());
-            break;
-          case OBJ_MAP:
-            rDst.clr();
-            copyMap(rDst, Src.get(*pKey).mapObject());
-            Dst.set(pKey->numObject(), rDst);
-            break;
-        }
-        break;
-      case OBJ_STR:
-        switch (Src.get(*pKey).getTag())
-        {
-          case OBJ_NUM:
-            Dst.set(pKey->strObject(), Src.get(*pKey).numObject());
-            break;
-          case OBJ_STR:
-            Dst.set(pKey->strObject(), Src.get(*pKey).strObject());
-            break;
-          case OBJ_MAP:
-            rDst.clr();
-            copyMap(rDst, Src.get(*pKey).mapObject());
-            Dst.set(pKey->strObject(), rDst);
-            break;
-        }
-        break;
-    }
-  }
-  return Dst;
-}
-
diff --git a/Massai/cpp/CfgXMgr/src/AssoFlat.cpp b/Massai/cpp/CfgXMgr/src/AssoFlat.cpp
deleted file mode 100644
index a73afdd1..00000000
--- a/Massai/cpp/CfgXMgr/src/AssoFlat.cpp
+++ /dev/null
@@ -1,206 +0,0 @@
-/**
- **************************************************************************
- * 
- * @file AssoFlat.cpp
- * 
- * Implements the functions declared in "assoFlat.hpp".
- * 
- * @author JK
- * 
- * Copyright (c) 2000, MATERNA Information & Communications
- * 
- **************************************************************************
-**/
-
-
-
-#include "assoFlat.hpp"
-#include <string.h>
-
-
-
-/**
- **************************************************************************
- *
- * Read a long value from a char pointer and advance the pointer.
- * 
- **************************************************************************
-**/
-static inline long readLong( const char * & SrcBeg )
-{
-   long * pL = (long *)SrcBeg;
-   SrcBeg += sizeof(long);
-   return * pL;
-}
-
-
-
-/**
- **************************************************************************
- *
- * Public function (see AssoFlat.hpp).
- * 
- **************************************************************************
-**/
-aObject *assoFlatNew( const char * & SrcBeg, const char * SrcEnd )
-{
-   aObject *pObj = 0;
-   if( SrcBeg >= SrcEnd )
-      return 0;
-   const char tag = *SrcBeg++;
-   switch( tag )
-   {
-   case OBJ_NUM:
-      pObj = new aObject( readLong( SrcBeg ) );
-      break;
-   case OBJ_STR:
-      {
-         long len;
-         unsigned char oldlen = *(unsigned char *)SrcBeg++;
-         if( oldlen==255 )
-            len = readLong( SrcBeg );
-         else
-            len = oldlen;
-         pObj = new aObject( SrcBeg, len );
-         SrcBeg += len;
-      }
-      break;
-   case OBJ_MAP:
-      {
-         aMap *pMap = new aMap();
-         pObj = pMap;
-         long cnt = readLong( SrcBeg );
-         while( cnt-- > 0 )
-         {
-            aObject *key = assoFlatNew( SrcBeg, SrcEnd );
-            aObject *val = assoFlatNew( SrcBeg, SrcEnd );
-            pMap->set( *key, *val );
-            delete key; delete val;
-         }
-      }
-      break;
-  }
-  return pObj;
-}
-
-
-
-/**
- **************************************************************************
- *
- * Write a long value to a char pointer and advance the pointer.
- * 
- **************************************************************************
-**/
-static void writeLong( char * & Dst, long Src )
-{
-   long * lDst = (long *)Dst;
-   *lDst = Src;
-   Dst += sizeof(long);
-}
-
-
-
-/**
- **************************************************************************
- *
- * Public function (see AssoFlat.hpp).
- * 
- **************************************************************************
-**/
-void assoFlatCopy( char * & DstBeg, char * DstEnd, const aObject & Src )
-{
-   char tag = (char)Src.getTag();
-   *DstBeg++ = tag;
-   switch( tag )
-   {
-   case OBJ_NUM:
-      writeLong( DstBeg, Src.numObject() );
-      break;
-   case OBJ_STR:
-      {
-         unsigned char oldcnt;
-         long cnt = Src.count();
-         if( cnt < 255 )
-         {
-            oldcnt = (unsigned char)cnt;
-            *DstBeg++ = oldcnt;
-         }
-         else
-         {
-            oldcnt=255;
-            *DstBeg++ = oldcnt;
-            writeLong( DstBeg, cnt );
-         }
-         memcpy( DstBeg, Src.strObject(), cnt );
-         DstBeg += cnt;
-      }
-      break;
-   case OBJ_MAP:
-      writeLong( DstBeg, Src.count() );
-      {
-         aMap& oo = Src.mapObject();
-         const aObject *pKey = 0;
-         while( ( pKey = oo.getNextKey( pKey ) ) != 0 )
-         {
-            assoFlatCopy( DstBeg, DstEnd, *pKey );
-            assoFlatCopy( DstBeg, DstEnd, oo.get( *pKey ) );
-         }
-      }
-      break;
-   }
-}
-
-
-
-/**
- **************************************************************************
- *
- * Public function (see AssoFlat.hpp).
- * 
- **************************************************************************
-**/
-long assoFlatSize( const aObject & Src )
-{
-   long Length = 0;
-   char tag = (char)Src.getTag();
-   ++Length;
-   switch( tag )
-   {
-   case OBJ_NUM:
-      Length += sizeof(long);
-      break;
-   case OBJ_STR:
-      {
-         long cnt = Src.count();
-         ++Length;
-         if( cnt >= 255 )
-            Length += sizeof(long);
-         Length += cnt;
-      }
-      break;
-   case OBJ_MAP:
-      Length += sizeof(long);
-      {
-         aMap& oo = Src.mapObject();
-         const aObject *pKey = 0;
-         while( ( pKey = oo.getNextKey( pKey ) ) != 0 )
-         {
-            Length += assoFlatSize( *pKey );
-            Length += assoFlatSize( oo.get( *pKey ) );
-         }
-      }
-      break;
-   }
-   return Length;
-}
-
-
-
-/**
- **************************************************************************
- *
- * End of file
- * 
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgr/src/CfgBase.cpp b/Massai/cpp/CfgXMgr/src/CfgBase.cpp
deleted file mode 100644
index 96ae7417..00000000
--- a/Massai/cpp/CfgXMgr/src/CfgBase.cpp
+++ /dev/null
@@ -1,791 +0,0 @@
-/**
- **************************************************************************
- * 
- * @file CfgBase.cpp
- * 
- * Basic configuration functions.
- * 
- * @author Maz, JK
- * 
- * Copyright (c) 1997-2001 MATERNA Information & Communications
- * 
- **************************************************************************
-**/
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <ctype.h>
-#include <fstream>
-using namespace std;
-
-
-#include "cfgdbi.hpp"
-#include "cfgbase.h"
-#include "TraceClt.h"
-
-#define FILTERLISTCOUNT 0
-
-
-
-enum LASTDATA
-{
-   LD_ITEMNAME = 1,
-   LD_SUBSECNAME,
-   LD_SECNAME,
-   LD_SUBSUPERSECNAME,
-   LD_SUPERSECNAME,
-   LD_LASTENTRY
-};
-
-
-
-#define GETSUPERSEC    getCfgDB()->get(lastData.GETSTR(LD_SUPERSECNAME))
-#define GETSUBSUPERSEC GETSUPERSEC.mapObject().get(lastData.GETSTR(LD_SUBSUPERSECNAME))
-#define GETSEC         GETSUBSUPERSEC.mapObject().get(lastData.GETSTR(LD_SECNAME))
-#define GETSUBSEC      GETSEC.mapObject().get(lastData.GETSTR(LD_SUBSECNAME))
-#define GETITEM(s)     GETSUBSEC.mapObject().get(s)
-
-
-
-static aMap *updList = NULL;
-static aMap *oldList = NULL;
-static aMap  lastData;
-static aMap  rejectTable;
-static char CnfFile[256] = "CfgMgr.cfg";
-
-
-
-#ifdef USE_XML_FILE
-#else
-
-
-
-static aMap *cfgDB = NULL;
-
-
-
-long freeConfiguration()
-{
-   if (cfgDB)
-      delete cfgDB;
-   cfgDB = NULL;
-   return CFGDB_OK;
-}
-
-
-
-aMap *getCfgDB()
-{
-   return cfgDB;
-}
-
-
-
-#endif
-
-
-aMap *getUpdList()
-{
-   return updList;
-}
-
-
-
-long updateValue(aMap& iData)
-{
-   lastData.set(LD_SUPERSECNAME,iData.GETSTR(KEY_SUPERSECNAME));
-   lastData.set(LD_SUBSUPERSECNAME,iData.GETSTR(KEY_SUBSUPERSECNAME));
-   lastData.set(LD_SECNAME,iData.GETSTR(KEY_SECNAME));
-   lastData.set(LD_SUBSECNAME,iData.GETSTR(KEY_SUBSECNAME));
-   lastData.set(LD_ITEMNAME,iData.GETSTR(KEY_ITEMNAME));
-   if (GETSUPERSEC.getTag() != OBJ_MAP)
-   {
-      aMap superSec;
-      getCfgDB()->set(lastData.GETSTR(LD_SUPERSECNAME),superSec);
-   }
-   // create SubSuperSec if not available
-   if (GETSUBSUPERSEC.getTag() != OBJ_MAP)
-   {
-      aMap subSuperSec;
-      GETSUPERSEC.mapObject().set(lastData.GETSTR(LD_SUBSUPERSECNAME),subSuperSec);
-   }
-   // create Section if not available
-   if (lastData.GETSTR(LD_SECNAME))
-   {
-      if (GETSEC.getTag() != OBJ_MAP)
-      {
-         aMap Sections;
-         GETSUBSUPERSEC.mapObject().set(lastData.GETSTR(LD_SECNAME),Sections);
-      }
-   }
-   else
-   {
-      writeTrace
-      (
-         MajorError, "CfgBase", 0, "updateValue",
-         "ERROR: No Section defined!"
-      );
-      return CFGDB_ERR_INVPARAM;
-   }
-   // create SubSection if not available
-   if (lastData.GETSTR(LD_SUBSECNAME))
-   {
-      if (GETSUBSEC.getTag() != OBJ_MAP)
-      {
-         aMap SubSections;
-         GETSEC.mapObject().set(lastData.GETSTR(LD_SUBSECNAME),SubSections);
-      }
-   }
-   else
-   {
-      writeTrace
-      (
-         MajorError, "CfgBase", 0, "updateValue",
-         "ERROR: No Subsection defined!"
-      );
-      return CFGDB_ERR_INVPARAM;
-   }
-   if(iData.get(KEY_VALUE).getTag() == OBJ_MAP)
-   {
-      // add or update Item
-      GETSUBSEC.mapObject().set(lastData.GETSTR(LD_ITEMNAME),iData.get(KEY_VALUE));
-   }
-   else
-   {
-      // delete
-      GETSUBSEC.mapObject().set(lastData.GETSTR(LD_ITEMNAME),(char*)NULL);
-   }
-   return CFGDB_OK;
-}
-
-
-
-#ifdef USE_XML_FILE
-#else
-
-
-
-static long parseLevel(long lLevel, char *szName)
-{
-   if ((lLevel+1) < LD_LASTENTRY)
-   {
-      for (long i = lLevel; i > 1; i--)
-         lastData.set(i,(char*) NULL);
-      lastData.set((lLevel+1),szName);
-      return CFGDB_OK;
-   }
-   else
-   {
-      writeTrace
-      (
-         MajorError, "CfgBase", 0, "parseLevel",
-         "ERROR: LEVEL too high!"
-      );
-      return CFGDB_ERR_INVPARAM;
-   }
-}
-
-
-
-static long insertValue( char *szName, char *szValue, unsigned long Line )
-{
-   if (getCfgDB())
-   {
-      
-      if (!lastData.GETSTR(LD_SUPERSECNAME))
-         lastData.set(LD_SUPERSECNAME,"GLOBALS");
-
-      if (!lastData.GETSTR(LD_SUBSUPERSECNAME))
-         lastData.set(LD_SUBSUPERSECNAME,"VALUES");
-
-      // create SuperSec if not available
-      if (GETSUPERSEC.getTag() != OBJ_MAP)
-      {
-         aMap superSec;
-         getCfgDB()->set(lastData.GETSTR(LD_SUPERSECNAME),superSec);
-      }
-
-      // create SubSuperSec if not available
-      if (GETSUBSUPERSEC.getTag() != OBJ_MAP)
-      {
-         aMap subSuperSec;
-         GETSUPERSEC.mapObject().set(lastData.GETSTR(LD_SUBSUPERSECNAME),
-                                     subSuperSec);
-      }
-
-      // create Section if not available
-      if (lastData.GETSTR(LD_SECNAME))
-      {
-         if (GETSEC.getTag() != OBJ_MAP)
-         {
-            aMap Sections;
-            GETSUBSUPERSEC.mapObject().set(lastData.GETSTR(LD_SECNAME),
-                                           Sections);
-         }
-      }
-      else
-      {
-         writeTrace
-         (
-            MajorError, "CfgBase", 0, "insertValue",
-            "Line %lu: ERROR: No Section defined!", Line
-         );
-         return CFGDB_ERR_INVPARAM;
-      }
-
-      // create SubSection if not available
-      if (lastData.GETSTR(LD_SUBSECNAME))
-      {
-         if (GETSUBSEC.getTag() != OBJ_MAP)
-         {
-            aMap SubSections;
-            GETSEC.mapObject().set(lastData.GETSTR(LD_SUBSECNAME),
-                                   SubSections);
-         }
-      }
-      else
-      {
-         writeTrace
-         (
-            MajorError, "CfgBase", 0, "insertValue",
-            "Line %lu: ERROR: No Subsection defined!", Line
-         );
-         return CFGDB_ERR_INVPARAM;
-      }
-
-      // add Item
-      if (*szName && (GETITEM(szName).getTag() >= OBJ_NUM))
-      {
-         writeTrace
-         (
-            MinorError, "CfgBase", 0, "insertValue",
-            "ERROR: %s.%s.%s.%s exists!",
-                    lastData.GETSTR(LD_SUPERSECNAME),
-                       lastData.GETSTR(LD_SECNAME),
-                          lastData.GETSTR(LD_SUBSECNAME),
-                             szName
-         );
-         return CFGDB_ERR;
-      }
-      else
-      {
-         if (*szName)
-         {
-            aMap Item;
-            if (*szValue)
-            {
-               Item.set(1,szValue);
-               Item.set(LIST_COUNT,1);
-            }
-            else
-               Item.set(LIST_COUNT,(long) 0);
-
-            GETSUBSEC.mapObject().set(szName,Item);
-            lastData.set(LD_ITEMNAME,szName);
-         }
-         else
-         {
-            long lCnt = GETITEM(lastData.GETSTR(LD_ITEMNAME)).mapObject().
-               GETNUM(LIST_COUNT);
-            if (*szValue)
-            {
-               lCnt++;
-               GETITEM(lastData.GETSTR(LD_ITEMNAME)).mapObject().set(lCnt,
-                                                                     szValue);
-               GETITEM(lastData.GETSTR(LD_ITEMNAME)).mapObject().set(LIST_COUNT,lCnt);
-            }
-         }
-      }
-
-   }
-   return CFGDB_ERR;
-}
-
-
-
-static long parseItem( char *szItem, unsigned long Line )
-{
-   char szName[100];
-   char szValue[1000];
-   char *pHlp = szItem;
-   long i;
-
-   {
-      i = 0;
-      while (pHlp && *pHlp && (*pHlp != '='))
-      {
-         if (*pHlp != ' ')
-            szName[i++] = *pHlp;
-
-         pHlp++;
-      }
-
-      if (pHlp && (*pHlp!='=') && *szName)
-      {
-         writeTrace
-         (
-            MajorError, "CfgBase", 0, "parseItem",
-            "Line %lu: ERROR: No value for item!", Line
-         );
-         return CFGDB_ERR;
-      }
-
-      pHlp++;
-
-      szName[i] = '\0';
-
-      if (i && (szName[i-1]=='+'))
-      {
-         szName[i-1] = '\0';
-         if (lastData.GETSTR(LD_ITEMNAME) &&
-             !strcmp(lastData.GETSTR(LD_ITEMNAME),szName))
-            szName[0] = '\0';
-      }
-
-      while (pHlp && *pHlp && ((*pHlp == ' ') || (*pHlp == '\t')))
-         pHlp++;
-
-      i = 0;
-      while (pHlp && *pHlp )
-         szValue[i++] = *pHlp++;
-
-      if (i)
-      {
-         szValue[i--] = '\0';
-
-         while((szValue[i] == ' ') || (szValue[i] == '\t'))
-         {
-            szValue[i--] = '\0';
-         }
-      }
-      else
-      {
-         // no Value given -> to avoid empty list insert just a blank
-         strcpy(szValue,"");
-      }
-
-      return insertValue( szName, szValue, Line );
-   }
-   
-}
-
-
-
-static long parseCfgLine( char *szLine, unsigned long Line )
-{
-   char *pHlp = szLine;
-   long lLevel = 0;
-   char buf[1000];
-   long indx =0;
-   while (pHlp  && *pHlp && ((*pHlp == ' ') || (*pHlp == '\t')) )
-      pHlp++;
-   while (pHlp && *pHlp && (*pHlp == '['))
-   {
-      pHlp++;
-      lLevel++;
-   }
-   if (!pHlp || !*pHlp)
-   {
-      lastData.set(LD_ITEMNAME, (char*) NULL);
-      return CFGDB_OK;
-   }
-   if (lLevel)
-   {
-      while (pHlp && *pHlp && (*pHlp != ']'))
-         buf[indx++] = *pHlp++;
-      buf[indx] = '\0';
-      if (*buf)
-         return parseLevel(lLevel,buf);
-      else
-         return CFGDB_OK;
-   }
-   else
-   {
-      while (pHlp && *pHlp)
-      {
-#ifdef CFG_COMMENTS_ALLOWED
-         if ( (*pHlp == '/') && (*(pHlp+1) == '/') )
-            break;
-#endif
-         buf[indx++] = *pHlp++;
-      }
-      buf[indx] = '\0';
-      if (!*buf)
-      {
-         lastData.set(LD_ITEMNAME, (char*) NULL);
-         return CFGDB_OK;
-      }
-      return parseItem( buf, Line );
-   }
-}
-
-
-
-static void writeTabs(long lLevel, ostream& os )
-{
-   for (int i=0; i< lLevel; i++)
-      os << "  ";
-}
-
-
-
-static void writeSecs(long lLevel, char ch, ostream& os )
-{
-   long lCnt = LD_LASTENTRY - 2 - lLevel;
-   if (lCnt < 0)
-      lCnt = 0;
-   for (int i=0; i< lCnt; i++)
-      os << ch;
-}
-
-
-
-static void displayMap(long lLevel,aMap const & map, ostream& os)
-{
-   const aObject *pKey;
-   pKey  = map.getNextKey(NULL);
-   while(pKey)
-   {
- #if FILTERLISTCOUNT
-      if(pKey->strObject() && !strcmp(pKey->strObject(),LIST_COUNT))
-      {
-         pKey = map.getNextKey(pKey);
-         continue;
-      }
- #endif
-      os << endl;
-      writeTabs(lLevel,os);
-      switch(pKey->getTag())
-      {
-      case OBJ_NUM:
-         writeSecs(lLevel,'[',os);
-         os << pKey->numObject();
-         writeSecs(lLevel,']',os);
-         break;
-      case OBJ_STR:
-         writeSecs(lLevel,'[',os);
-         os << pKey->strObject();
-         writeSecs(lLevel,']',os);
-         break;
-      }
-      switch (map.get(*pKey).getTag())
-      {
-      case OBJ_NUM:
-         os  << map.get(*pKey).numObject();
-         break;
-      case OBJ_STR:
-         os << map.get(*pKey).strObject();
-         break;
-      case OBJ_MAP:
-         if( map.get(*pKey).mapObject().GETNUM(LIST_COUNT) >= 0 )
-         {
-            long lCnt = map.get(*pKey).mapObject().GETNUM(LIST_COUNT);
-            for( int i = 1; i <= lCnt; i++ )
-            {
-               if (i == 1)
-                  os << "  = ";
-               else
-               {
-                  os << endl;
-                  writeTabs(lLevel,os);
-                  switch(pKey->getTag())
-                  {
-                  case OBJ_NUM:
-                     os << pKey->numObject();
-                     break;
-                  case OBJ_STR:
-                     os << pKey->strObject();
-                     break;
-                  }
-                  os << " += ";
-               }
-               os << map.GETLISTENTRY(*pKey,i) << " " ;//<< endl;
-            }
-            if (!lCnt)
-               os << "  = ";
-            // return;
-         }
-         else
-            displayMap(lLevel+1,map.get(*pKey).mapObject(),os);
-         break;
-      }
-      pKey = map.getNextKey(pKey);
-   }
-}
-
-
-
-static void displayConfiguration(ostream& os)
-{
-   if (cfgDB)
-   {
-      displayMap(0,*getCfgDB(),os);
-      os << endl;
-   }
-   else
-      writeTrace
-      (
-         MajorError, "CfgBase", 0, "displayConfiguration",
-         "ERROR: cfgDB = NULL"
-      );
-}
-
-
-
-void cfgFileName( char const * File )
-{
-   strcpy( CnfFile, File );
-}
-
-
-
-char const * cfgFileName()
-{
-   return CnfFile;
-}
-
-
-
-long cfgFileRead( char const *pszFilename )
-{
-   if (!pszFilename || !(*pszFilename))
-      return CFGDB_ERR;
-   
-   if (!cfgDB)
-      cfgDB = new aMap;
-
-   ifstream is( pszFilename );
-   if (!is.fail())
-   {
-      char buf[1000];
-      unsigned long Line = 1;
-      while(!is.eof() && !is.fail())
-      {
-         is.getline(buf,sizeof(buf));
-         parseCfgLine( buf, Line++ );
-         buf[0] = '\0';
-      }
-   }
-   else
-   {
-      writeTrace
-      (
-         MinorError, "CfgBase", 0, "cfgFileRead",
-         "ERROR: File %s not found!",
-         pszFilename
-      );
-      return CFGDB_ERR;
-   }
-   return CFGDB_OK;
-}
-
-
-
-long cfgFileWrite( char const * pszFilename )
-{
-   char szOldFile[256];
-   strcpy(szOldFile,pszFilename);
-   char *pChr = strrchr(szOldFile,'.');
-   sprintf(pChr,".BAK");
-   rename(pszFilename,szOldFile);
-   ofstream os(pszFilename);
-   displayConfiguration( os );
-   return CFGDB_OK;
-}
-
-
-
-#endif
-
-
-
-void addUpdList(aMap const & iData)
-{
-   if (!updList)
-   {
-      updList = new aMap;
-      updList->set(LIST_COUNT,(long)0);
-   }
-   long lCnt = updList->GETNUM(LIST_COUNT);
-   lCnt++;
-   updList->set(lCnt,iData);
-   updList->set(LIST_COUNT,lCnt);
-}
-
-
-
-void clrUpdList()
-{
-   delete updList;
-   updList = NULL;
-}
-
-
-
-void addOldList(aMap const & iData)
-{
-   if( !oldList )
-      oldList = new aMap;
-   char buf[256];
-   sprintf(buf,"%s:%s:%s:%s:%s",iData.GETSTR(KEY_SUPERSECNAME),
-                                iData.GETSTR(KEY_SUBSUPERSECNAME),
-                                iData.GETSTR(KEY_SECNAME),
-                                iData.GETSTR(KEY_SUBSECNAME),
-                                iData.GETSTR(KEY_ITEMNAME)
-          );
-   oldList->set(buf,iData);
-}
-
-
-
-void clrOldList()
-{
-   delete oldList;
-   oldList = NULL;
-}
-
-
-
-long getOldListEntry(aMap const & iData, aMap& oData)
-{
-   long rc = 0;
-   if( oldList )
-   {
-      char buf[256];
-      sprintf(buf,"%s:%s:%s:%s:%s",iData.GETSTR(KEY_SUPERSECNAME),
-                                   iData.GETSTR(KEY_SUBSUPERSECNAME),
-                                   iData.GETSTR(KEY_SECNAME),
-                                   iData.GETSTR(KEY_SUBSECNAME),
-                                   iData.GETSTR(KEY_ITEMNAME)
-             );
-      aObject otData = oldList->get(buf);
-      if(otData.getTag() == OBJ_MAP)
-         oData = otData.mapObject();
-      else
-         rc = 1;
-   }
-   else
-      rc = 1;
-   return rc;
-}
-
-
-
-long clrRejectData( aMap const & iData, aMap & )
-{
-   long rc = 0;
-   long clientId = iData.GETNUM(KEY_CLIENT_ID);
-   if(clientId < 0)
-      return CFGDB_ERR_INVPARAM;
-   aMap itData = iData;
-   if( itData.GETSTR(KEY_SUPERSECNAME) == NULL )
-   {
-      itData.set(KEY_SUPERSECNAME,"GLOBALS");
-      itData.set(KEY_SUBSUPERSECNAME,"VALUES");
-   }
-   char buf[256];
-   sprintf(buf,"%s:%s:%s:%s:%s",itData.GETSTR(KEY_SUPERSECNAME),
-                                itData.GETSTR(KEY_SUBSUPERSECNAME),
-                                itData.GETSTR(KEY_SECNAME),
-                                itData.GETSTR(KEY_SUBSECNAME),
-                                itData.GETSTR(KEY_ITEMNAME)
-          );
-   if(rejectTable.get(clientId).getTag() == OBJ_MAP)
-   {
-      aMap& aEntry = rejectTable.get(clientId).mapObject();
-      aEntry.set(buf,(char *) NULL);
-   }
-   return rc;
-}
-
-
-
-long setRejectData( aMap const & iData, aMap &, long fSet )
-{
-   // if fSet = 1, the flag for rejected data will be set
-   // if fSet = 0, the flag for rejected data will be cleared
-   long rc = 0;
-   long clientId = iData.GETNUM(KEY_CLIENT_ID);
-   if( clientId < 0 )
-      return CFGDB_ERR_INVPARAM;
-   if( !fSet )
-   {
-      // clear all entries for this client
-      rejectTable.set(clientId,(char*) NULL);
-   }
-   else
-   {
-      aMap itData = iData;
-      if( itData.GETSTR(KEY_SUPERSECNAME) == NULL )
-      {
-         itData.set(KEY_SUPERSECNAME,"GLOBALS");
-         itData.set(KEY_SUBSUPERSECNAME,"VALUES");
-      }
-      char buf[256];
-      sprintf(buf,"%s:%s:%s:%s:%s",itData.GETSTR(KEY_SUPERSECNAME),
-                               itData.GETSTR(KEY_SUBSUPERSECNAME),
-                               itData.GETSTR(KEY_SECNAME),
-                               itData.GETSTR(KEY_SUBSECNAME),
-                               itData.GETSTR(KEY_ITEMNAME)
-                            );
-      if( rejectTable.get(clientId).getTag() != OBJ_MAP )
-      {
-         // new Entry
-         aMap nwEntry;
-         nwEntry.set(buf,1);
-         rejectTable.set(clientId, nwEntry);
-      }
-      else
-      {
-         aMap& aEntry = rejectTable.get(clientId).mapObject();
-         aEntry.set(buf,1);
-      }
-   }
-   return rc;
-}
-
-
-
-long isRejected(aMap const & iData)
-{
-   aMap itData = iData;
-
-   if(itData.GETSTR(KEY_SUPERSECNAME) == NULL)
-   {
-      itData.set(KEY_SUPERSECNAME,"GLOBALS");
-      itData.set(KEY_SUBSUPERSECNAME,"VALUES");
-   }
-
-   char buf[256];
-   sprintf
-   (
-      buf,
-      "%s:%s:%s:%s:%s",
-       itData.GETSTR(KEY_SUPERSECNAME),
-          itData.GETSTR(KEY_SUBSUPERSECNAME),
-             itData.GETSTR(KEY_SECNAME),
-                itData.GETSTR(KEY_SUBSECNAME),
-                   itData.GETSTR(KEY_ITEMNAME)
-   );
-
-   const aObject* pItem = NULL;
-
-   while( (pItem = rejectTable.getNextKey(pItem)) != NULL)
-   {
-      if(rejectTable.get(*pItem).mapObject().get(buf).numObject() == 1)
-         return CFGDB_ERR;
-   }
-
-   return CFGDB_OK;
-}
-
-
-
-/**
- **************************************************************************
- *
- * End of file
- * 
- **************************************************************************
-**/
-
diff --git a/Massai/cpp/CfgXMgr/src/CfgFunc.cpp b/Massai/cpp/CfgXMgr/src/CfgFunc.cpp
deleted file mode 100644
index 21cfc962..00000000
--- a/Massai/cpp/CfgXMgr/src/CfgFunc.cpp
+++ /dev/null
@@ -1,1341 +0,0 @@
-/**
- **************************************************************************
- *
- * @file CfgFunc.cpp
- *
- * Contains database access functions.
- *
- * @author Maz, JK
- *
- * Copyright (c) 1997-2003 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-
-
-#include "cfgdbi.hpp"
-#include "cfgbase.h"
-#include "cfgfunc.h"
-#include "utils.hpp"
-#include "version.h"
-#include "CfgMgrStrings.h"
-
-
-#define KSKNAME     "INTERNAL","DATA","THIS","ENVIRONMENT","Name"
-#define TRCTOPIC    "INTERNAL","DATA","THIS","ENVIRONMENT","TraceTopic"
-#define TRCFILE     "INTERNAL","DATA","THIS","ENVIRONMENT","TraceFile"
-#define MDFYDTE     "INTERNAL","DATA","THIS","ENVIRONMENT","ModifyDate"
-#define MDFYADR     "INTERNAL","DATA","THIS","ENVIRONMENT","ModifyFrom"
-#define MASLINK     "INTERNAL","DATA","THIS","ENVIRONMENT","MasterLink"
-#define MASNAME     "INTERNAL","DATA","THIS","ENVIRONMENT","MasterName"
-#define CLTMASLINK  "INTERNAL","DATA","CLIENTS","","MasterLink"
-
-
-
-#define GETSUPERSEC    getCfgDB()->get(iData.GETSTR(KEY_SUPERSECNAME))
-#define GETSUBSUPERSEC GETSUPERSEC.mapObject().get(iData.GETSTR(KEY_SUBSUPERSECNAME))
-#define GETSEC         GETSUBSUPERSEC.mapObject().get(iData.GETSTR(KEY_SECNAME))
-#define GETSUBSEC      GETSEC.mapObject().get(iData.GETSTR(KEY_SUBSECNAME))
-#define GETITEM        GETSUBSEC.mapObject().get(iData.GETSTR(KEY_ITEMNAME))
-
-
-#define DISPITEM(v) displayItems(v,#v,iData)
-#define SECINFO     iData.GETSTR(KEY_SECNAME),iData.GETSTR(KEY_SUBSECNAME),iData.GETSTR(KEY_ITEMNAME)
-#define GIVENINFO   iData.GETSTR(KEY_SUPERSECNAME),iData.GETSTR(KEY_SUBSUPERSECNAME)
-
-
-
-static char const * attrib2Str( int Attrib )
-{
-   switch( Attrib )
-   {
-   case KEY_CHANGEMODE:   return DB_Descr_ChangeMode;
-   case KEY_SHORTDESCR:   return DB_Descr_ShortDescription;
-   case KEY_LONGDESCR:    return DB_Descr_LongDescription;
-   case KEY_TYPE:         return DB_Descr_Type;
-   case KEY_RANGE:        return DB_Descr_Range;
-   case KEY_GLOBAL:       return DB_Descr_Global;
-   case KEY_DEFAULT:      return DB_Descr_Default;
-   case KEY_RANGECOMMENT: return DB_Descr_RangeComment;
-   case KEY_RANGEINTEGER: return DB_Descr_RangeInteger;
-   case KEY_ACCESS_L:     return DB_Descr_AccessL;
-   default:               return 0;
-   }
-}
-
-
-
-static aMap & configMap()
-{
-   return *getCfgDB();
-}
-
-
-
-static long getEntry_map( long lWhere, const aMap& iData, aMap &oData )
-{
-   if( getCfgDB() )
-   {
-      if
-      (
-         iData.GETSTR(KEY_SUPERSECNAME) &&
-         iData.GETSTR(KEY_SUBSUPERSECNAME) &&
-         iData.GETSTR(KEY_SECNAME) &&
-         iData.GETSTR(KEY_SUBSECNAME) &&
-         iData.GETSTR(KEY_ITEMNAME)
-      )
-      {
-         if
-         (
-            (GETSUPERSEC.getTag()==OBJ_MAP) &&
-            (GETSUBSUPERSEC.getTag()==OBJ_MAP) &&
-            (GETSEC.getTag()==OBJ_MAP) &&
-            (GETSUBSEC.getTag()==OBJ_MAP) &&
-            (GETITEM.getTag()==OBJ_MAP)
-         )
-         {
-            aMap value = GETITEM.mapObject();
-            oData.set(lWhere,value);
-            return CFGDB_OK;
-         }
-         else
-         {
-            return CFGDB_ERR_NOT_FOUND;
-         }
-      }
-      else
-      {
-         return CFGDB_ERR_CMD;
-      }
-   }
-   else
-   {
-      return CFGDB_ERR_NOCFG;
-   }
-}
-
-
-
-static long getEntry
-(
-   CFGDB_ACCESSKEY lWhere,
-   const char* szSuperSec,
-   const char* szSubSuperSec,
-   const char *szSec,
-   const char *szSubSec,
-   const char *szItem,
-   aMap& oData
-)
-{
-   aMap req;
-   if( szSuperSec && *szSuperSec )
-      req.set( KEY_SUPERSECNAME, szSuperSec );
-   if( szSubSuperSec && *szSubSuperSec )
-      req.set( KEY_SUBSUPERSECNAME, szSubSuperSec );
-   if( szSec && *szSec )
-      req.set( KEY_SECNAME, szSec );
-   if( szSubSec && *szSubSec )
-      req.set( KEY_SUBSECNAME, szSubSec );
-   if( szItem && *szItem )
-      req.set( KEY_ITEMNAME, szItem );
-   long R = getEntry_map( lWhere, req, oData );
-   return R;
-}
-
-
-
-static long getEntryDescrip
-(
-   CFGDB_ACCESSKEY Attrib,
-   char const *    Sec,
-   char const *    Sub,
-   char const *    Itm,
-   aMap &          Out
-)
-{
-   return getEntry
-          (
-             Attrib, DB_Descr_SuperSec, Sec, Sub, Itm, attrib2Str( Attrib ),
-             Out
-          );
-}
-
-
-
-static char *getKioskname()
-{
-   aMap   oData;
-   if( !getEntry( KEY_KIOSKNAME, KSKNAME, oData) )
-   {
-      static char buf[100];
-      strcpy( buf, oData.GETLISTENTRY( KEY_KIOSKNAME, 1 ) );
-      return buf;
-   }
-   else
-      return 0;
-}
-
-
-
-static long _compareData(const aMap& iData, CFGDB_ACCESSKEY lWhere,const char* szItem)
-{
-long rc= 0;
-
-  if (szItem && *szItem)
-     if(!iData.GETSTR(lWhere) || (strcmp(iData.GETSTR(lWhere),szItem) != 0))
-       rc = 1;
-
- return rc;
-}
-
-
-
-static long compareData(const aMap& iData,  const char* szSuperSec,
-                                     const char* szSubSuperSec,
-                                     const char *szSec,
-                                     const char *szSubSec,
-                                     const char *szItem)
-{
-long rc =0;
-
-  rc |= _compareData(iData,KEY_SUPERSECNAME,szSuperSec);
-  rc |= _compareData(iData,KEY_SUBSUPERSECNAME,szSubSuperSec);
-  rc |= _compareData(iData,KEY_SECNAME,szSec);
-  rc |= _compareData(iData,KEY_SUBSECNAME,szSubSec);
-  rc |= _compareData(iData,KEY_ITEMNAME,szItem);
-
- return rc;
-}
-
-
-
-static void insItem(CFGDB_ACCESSKEY lWhere,const char* szValue,aMap& oData)
-{
-aMap entry;
-long lCnt = 1;
-
-  if(oData.get(lWhere).getTag() == OBJ_MAP)
-  {
-    entry = oData.get(lWhere).mapObject();
-    lCnt = entry.get(LIST_COUNT).numObject() +1;
-    if(!lCnt)
-      lCnt = 1;
-  }
-
-  entry.set(lCnt,szValue);
-  entry.set(LIST_COUNT,lCnt);
-  oData.set(lWhere,entry);
-}
-
-
-
-static void insItem(CFGDB_ACCESSKEY lWhere,long lValue,aMap& oData)
-{
-char buf[30];
-
-  sprintf(buf,"%d",lValue);
-  insItem(lWhere,buf,oData);
-}
-
-
-
-static long getInternalData(const aMap& iData, aMap& oData)
-{
-long rc = 0;
-
-  // first test if internal super section
-  if(!compareData(iData,"INTERNAL","","","",""))
-  {
-    // general: get the value from the database
-    long rc1 = getEntry(KEY_VALUE,GIVENINFO,SECINFO,oData);
-
-
-    // now test the items
-    if(!compareData(iData,KSKNAME))
-    {
-      // Kioskname has been requested
-      if(rc1)
-        insItem(KEY_VALUE,"",oData);
-
-      insItem(KEY_CHANGEMODE   ,"CHANGE ON THE FLY", oData);
-      insItem(KEY_SHORTDESCR   ,"Host name of this machine", oData);
-      insItem(KEY_LONGDESCR    ,"Host name of this machine", oData);
-      insItem(KEY_TYPE         , CFGTYPE_STRING, oData);
-    }
-    else
-    if(!compareData(iData,TRCTOPIC))
-    {
-      // TraceTopic has been requested
-      if(rc1)
-        insItem(KEY_VALUE,"NONE",oData);
-
-      insItem(KEY_CHANGEMODE   ,"NO CHANGE", oData);
-      insItem(KEY_SHORTDESCR   ,"Enables Database trace",oData);
-      insItem(KEY_LONGDESCR    ,"Enables Database trace for the parts given:\nDB: Database basic functions\nSESSIONS: Database Clients\nMASTER: Master Database Connections", oData);
-      insItem(KEY_TYPE         , CFGTYPE_STRING_LIST, oData);
-    }
-    else
-    if(!compareData(iData,TRCFILE))
-    {
-      // TraceFile has been requested
-      if(rc1)
-        insItem(KEY_VALUE,"\\CONSOLE",oData);
-
-      insItem(KEY_CHANGEMODE   ,"NO CHANGE", oData);
-      insItem(KEY_SHORTDESCR   ,"Database trace file name",oData);
-      insItem(KEY_LONGDESCR    ,"Database tracefile name (\\CONSOLE: trace on the screen)", oData);
-      insItem(KEY_TYPE         , CFGTYPE_STRING, oData);
-    }
-    else
-    if(!compareData(iData,MASLINK))
-    {
-      // MasterLink has been requested
-      if(rc1)
-        insItem(KEY_VALUE,"OFF",oData);
-
-      insItem(KEY_CHANGEMODE   ,"CHANGE ON THE FLY", oData);
-      insItem(KEY_SHORTDESCR   ,"Update Database from master",oData);
-      insItem(KEY_LONGDESCR    ,"If On the database is updated and controlled by the master", oData);
-      insItem(KEY_TYPE         , CFGTYPE_TOGGLE, oData);
-      insItem(KEY_RANGE        ,"ON", oData);
-      insItem(KEY_RANGE        ,"OFF", oData);
-      insItem(KEY_RANGECOMMENT ,"Update from master", oData);
-      insItem(KEY_RANGECOMMENT ,"No Update from master", oData);
-    }
-    else
-    if(!compareData(iData,MASNAME))
-    {
-      // MasterLink has been requested
-      if(rc1)
-        insItem(KEY_VALUE,"",oData);
-
-      insItem(KEY_CHANGEMODE   ,"CHANGE ON THE FLY", oData);
-      insItem(KEY_SHORTDESCR   ,"Host name of the Master-Database",oData);
-      insItem(KEY_LONGDESCR    ,"Host name of the Master-Database", oData);
-      insItem(KEY_TYPE         , CFGTYPE_STRING, oData);
-    }
-    else
-    if(!compareData(iData,CLTMASLINK))
-    {
-      // Client MasterLink has been requested
-      if(rc1)
-      {
-        //insItem(KEY_VALUE,"OFF",oData);
-        rc = rc1;
-      }
-      else
-      {
-        insItem(KEY_CHANGEMODE   ,"CHANGE ON THE FLY", oData);
-        insItem(KEY_SHORTDESCR   ,"Update Client Database by this master",oData);
-        insItem(KEY_LONGDESCR    ,"If On  Client database is updated and controlled by this master", oData);
-        insItem(KEY_TYPE         , CFGTYPE_TOGGLE, oData);
-        insItem(KEY_RANGE        ,"ON", oData);
-        insItem(KEY_RANGE        ,"OFF", oData);
-        insItem(KEY_RANGECOMMENT ,"Update this Client", oData);
-        insItem(KEY_RANGECOMMENT ,"Don't Update this Client", oData);
-      }
-    }
-    else
-      rc = CFGDB_ERR_NOT_FOUND;
-
-  }
-  else
-    rc = CFGDB_ERR_NOT_FOUND;
-
-  return rc;
-}
-
-
-
-static long getGlobalSections(const aMap& iData, aMap& oData)
-{
-  aMap map = iData;
-
-  map.set(KEY_SUPERSECNAME,DB_Values_SuperSec);
-  map.set(KEY_SUBSUPERSECNAME,DB_Values_SubSuperSec);
-
-  return cfgFunc_List(map,oData);
-}
-
-
-
-static long getClientSections(const aMap& iData, aMap& oData)
-{
-  aMap map = iData;
-
-  map.set(KEY_SUPERSECNAME,"INTERNAL");
-  map.set(KEY_SUBSUPERSECNAME,"DATA");
-  map.set(KEY_SECNAME,"CLIENTS");
-
-  return cfgFunc_List(map,oData);
-}
-
-
-
-static long update_value(CFGDB_ACCESSKEY lWhere,const char* szSuperSec,
-                                     const char* szSubSuperSec,
-                                     const char *szSec,
-                                     const char *szSubSec,
-                                     const char *szItem,
-                                     const aMap& iData)
-{
-aMap values;
-aMap Item;
-
-
-  switch (iData.get(lWhere).getTag())
-  {
-  case OBJ_NUM:
-               {
-                 char buf[100];
-                 Item.set(1,itoa(iData.GETNUM(lWhere),buf,10));
-                 Item.set(LIST_COUNT,1);
-               }
-               break;
-
-
-  case OBJ_STR:
-               Item.set(1,iData.GETSTR(lWhere));
-               Item.set(LIST_COUNT,1);
-               break;
-
-  case OBJ_MAP:
-               if (iData.get(lWhere).mapObject().GETNUM(LIST_COUNT) < 0)
-                 return CFGDB_ERR_INVPARAM;
-               else
-                 Item = iData.get(lWhere).mapObject();
-               break;
-
-  default:
-               return 0; //CFGDB_ERR_NOT_FOUND;
-
-  }
-
-  values.set(KEY_SUPERSECNAME,szSuperSec);
-  values.set(KEY_SUBSUPERSECNAME,szSubSuperSec);
-  values.set(KEY_SECNAME,szSec);
-  values.set(KEY_SUBSECNAME,szSubSec);
-  values.set(KEY_ITEMNAME,szItem);
-  values.set(KEY_VALUE,Item);
-
-  return updateValue(values);
-}
-
-
-
-static long update_valueDescrip
-(
-   CFGDB_ACCESSKEY        Where,
-   char const *           Sec,
-   char const *           Sub,
-   char const *           Itm,
-   aMap const &           Source
-)
-{
-   return update_value
-          (
-             Where,
-             DB_Descr_SuperSec, Sec, Sub, Itm, attrib2Str( Where ),
-             Source
-          );
-}
-
-
-
-static long recurseSimList(long lKey,const aMap& iData, aMap& oData)
-{
-   // exit function if key already defined
-   if( iData.GETSTR( lKey ) )
-      return CFGDB_ERR;
-   aMap rsp;
-   long rc = cfgFunc_List( iData, rsp );
-   if( rc )
-      return rc;
-   long lCnt = rsp.get(KEY_VALUE).mapObject().GETNUM(LIST_COUNT);
-   for( int i=1; i <= lCnt; i++ )
-   {
-      aMap req = iData;
-      req.set(lKey,rsp.GETLISTENTRY(KEY_VALUE,i));
-      rc = cfgFunc_SimilarList(req,oData);
-   }
-   return rc;
-}
-
-
-
-/**
- *
- * Clear a map-entry with string key.
- *
-**/
-static void clearKey( aMap & M, char const * Key )
-{
-   M.set( Key, (char *)0 );
-}
-
-
-
-/**
- *
- * Clear a map-entry with integer key.
- *
-**/
-static void clearKey( aMap & M, int Key )
-{
-   M.set( Key, (char *)0 );
-}
-
-
-
-/**
- *
- * Check, whether a request is for GLOBALS-VALUES.
- *
-**/
-static bool gvKeys( aMap const & M )
-{
-   if( strcmp( M.get( KEY_SUPERSECNAME ).strObject(), DB_Values_SuperSec ) )
-      return false;
-   if( strcmp( M.get( KEY_SUBSUPERSECNAME ).strObject(), DB_Values_SubSuperSec ) )
-      return false;
-   return true;
-}
-
-
-
-/**
- *
- * Check, whether a request for GLOBALS-VALUES has description.
- *
-**/
-static bool gvHasDescription( aMap const & M )
-{
-   aObject DBObj = getCfgDB()->get( DB_Descr_SuperSec );
-   //
-   // Check section
-   //
-   char const * MString = M.get( KEY_SECNAME ).strObject();
-   if( !MString )
-      //
-      // No section given -> description so far found.
-      //
-      return true;
-   DBObj = DBObj.mapObject().get( MString );
-   if( DBObj.getTag() != OBJ_MAP )
-      //
-      // DB is not a map -> no description
-      //
-      return false;
-   //
-   // Check subsection
-   //
-   MString = M.get( KEY_SUBSECNAME ).strObject();
-   if( !MString )
-      //
-      // No subsection given -> description so far found.
-      //
-      return true;
-   DBObj = DBObj.mapObject().get( MString );
-   if( DBObj.getTag() != OBJ_MAP )
-      //
-      // DB is not a map -> no description
-      //
-      return false;
-   //
-   // Check item
-   //
-   MString = M.get( KEY_ITEMNAME ).strObject();
-   if( !MString )
-      //
-      // No item given -> description so far found.
-      //
-      return true;
-   DBObj = DBObj.mapObject().get( MString );
-   if( DBObj.getTag() != OBJ_MAP )
-      //
-      // DB is not a map -> no description
-      //
-      return false;
-   return true;
-}
-
-
-
-/**
- *
- * Check, if a key reference is NOT the list-counter
- *
-**/
-static int notListCountKey( aObject const * pObj )
-{
-   return
-   (
-      !
-      (
-         (pObj->getTag() == OBJ_STR)
-         &&
-         (!strcmp(LIST_COUNT,pObj->strObject()))
-      )
-   );
-}
-
-
-
-/**
- *
- * Exported function.
- *
-**/
-long cfgFunc_DBStatus( aMap const &, aMap & oData )
-{
-long rc = 0;
-
-  getEntry(KEY_MODIFY_DATE,MDFYDTE,oData);
-  getEntry(KEY_MODIFY_ADDR,MDFYADR,oData);
-  getEntry(KEY_MASTER_LINK,MASLINK,oData);
-  getEntry(KEY_MASTER_NAME,MASNAME,oData);
-  getEntry(KEY_KIOSKNAME,  KSKNAME,oData);
-
-  if (getUpdList())
-  {
-    aMap Item;
-    Item.set(LIST_COUNT,1);
-    Item.set(1,"Changed");
-    oData.set(KEY_CHANGEMODE,Item);
-  }
-
-  // Get the information if Globals Values contains any Sections
-  {
-    aMap itData, otData;
-    if (!getGlobalSections(itData,otData))
-    {
-      aMap Item;
-      Item.set(LIST_COUNT,1);
-      Item.set(1,"GLOBAL DATA AVAILABLE");
-      oData.set(KEY_GLOBAL,Item);
-    }
-  }
-
-  // Get the information about the clients
-  {
-    aMap itData;
-    getClientSections(itData,oData);
-  }
-
-  {
-   aMap verItem;
-   verItem.set(LIST_COUNT,1);
-   verItem.set(1,GET_VERSION());
-   oData.set(KEY_VERSION,verItem);
-  }
-
-  return rc;
-}
-
-
-
-/**
- *
- * Exported function.
- *
-**/
-long cfgFunc_Delete( const aMap& iData )
-{
-   long rc = 0;
-   if( iData.GETSTR(KEY_SUPERSECNAME) && ( GETSUPERSEC.getTag() == OBJ_MAP ) )
-   {
-      if( iData.GETSTR(KEY_SUBSUPERSECNAME) && ( GETSUBSUPERSEC.getTag() == OBJ_MAP ) )
-      {
-         if( iData.GETSTR(KEY_SECNAME) && ( GETSEC.getTag() == OBJ_MAP ) )
-         {
-            if( iData.GETSTR(KEY_SUBSECNAME) && ( GETSUBSEC.getTag() == OBJ_MAP ) )
-            {
-               if( iData.GETSTR(KEY_ITEMNAME) && ( GETITEM.getTag() == OBJ_MAP ) )
-               {
-                  //
-                  // delete item from subsection
-                  //
-                  clearKey( GETSUBSEC.mapObject(), iData.GETSTR(KEY_ITEMNAME) );
-                  if( GETSUBSEC.mapObject().count() == 0 )
-                  {
-                     //
-                     // No item left in subsection
-                     // -> delete subsection as well
-                     //
-                     aMap ReMap( iData );
-                     clearKey( ReMap, KEY_ITEMNAME );
-                     rc = cfgFunc_Delete( ReMap );
-                  }
-               }
-               else
-               {
-                  if( iData.GETSTR( KEY_ITEMNAME ) )
-                  {
-                     //
-                     // Item specified, but not found
-                     //
-                     rc = CFGDB_ERR_INVPARAM;
-                  }
-                  else
-                  {
-                     //
-                     // No item specified
-                     // -> delete subsection from section
-                     //
-                     clearKey( GETSEC.mapObject(), iData.GETSTR( KEY_SUBSECNAME ) );
-                     if( GETSEC.mapObject().count() == 0 )
-                     {
-                        //
-                        // No subsection left in section
-                        // -> delete section as well
-                        //
-                        aMap ReMap( iData );
-                        clearKey( ReMap, KEY_SUBSECNAME );
-                        rc = cfgFunc_Delete( ReMap );
-                     }
-                  }
-               }
-            }
-            else
-            {
-               if( iData.GETSTR( KEY_SUBSECNAME ) )
-               {
-                  //
-                  // Subsection specified, but not found
-                  //
-                  rc = CFGDB_ERR_INVPARAM;
-               }
-               else
-               {
-                  //
-                  // No subsection specified
-                  // -> delete section from subsupersection
-                  //
-                  clearKey( GETSUBSUPERSEC.mapObject(), iData.GETSTR( KEY_SECNAME ) );
-                  if( GETSUBSUPERSEC.mapObject().count() == 0 )
-                  {
-                     //
-                     // No section left in subsupersection
-                     // -> delete subsupersection as well
-                     //
-                     aMap ReMap( iData );
-                     clearKey( ReMap, KEY_SECNAME );
-                     rc = cfgFunc_Delete( ReMap );
-                  }
-               }
-            }
-         }
-         else
-         {
-            if( iData.GETSTR( KEY_SECNAME ) )
-            {
-               //
-               // Section specified, but not found
-               //
-               rc = CFGDB_ERR_INVPARAM;
-            }
-            else
-            {
-               //
-               // No section specified
-               // -> delete subsupersection from section
-               //
-               clearKey( GETSUPERSEC.mapObject(), iData.GETSTR( KEY_SUBSUPERSECNAME ) );
-               if( GETSUPERSEC.mapObject().count() == 0 )
-               {
-                  //
-                  // No subsupersection left in supersection
-                  // -> delete supersection as well
-                  //
-                  aMap ReMap( iData );
-                  clearKey( ReMap, KEY_SUBSUPERSECNAME );
-                  rc = cfgFunc_Delete( ReMap );
-               }
-            }
-         }
-      }
-      else
-      {
-         if( iData.GETSTR( KEY_SUBSUPERSECNAME ) )
-         {
-            //
-            // Subsupersection specified, but not found
-            //
-            rc = CFGDB_ERR_INVPARAM;
-         }
-         else
-         {
-            //
-            // No subsupersection specified
-            // -> delete supersection
-            //
-            clearKey( configMap(), iData.GETSTR( KEY_SUPERSECNAME ) );
-         }
-      }
-   }
-   else
-   {
-      //
-      // Supersection not specified or not found
-      //
-      rc = CFGDB_ERR_INVPARAM;
-   }
-   return rc;
-}
-
-
-
-/**
- *
- * Exported function.
- *
-**/
-long cfgFunc_Item( const aMap& iData, aMap& oData )
-{
-   long rc = getInternalData( iData, oData );
-   if( rc )
-   {
-      if
-      (
-         iData.GETSTR( KEY_SUPERSECNAME ) &&
-         iData.GETSTR( KEY_SUBSUPERSECNAME )
-      )
-      {
-         rc = getEntry( KEY_VALUE, GIVENINFO, SECINFO, oData );
-      }
-      else
-      {
-         rc = getEntry
-              (
-                 KEY_VALUE,
-                 DB_Values_SuperSec, DB_Values_SubSuperSec, SECINFO, oData
-              );
-         if( rc )
-         {
-            char const * Name = getKioskname();
-            if( Name )
-               rc = getEntry( KEY_VALUE, DB_Client_SuperSec, Name, SECINFO, oData );
-         }
-      }
-
-      // Try to get the description even, if the value is not available
-      getEntryDescrip( KEY_CHANGEMODE,   SECINFO, oData );
-      getEntryDescrip( KEY_SHORTDESCR,   SECINFO, oData );
-      getEntryDescrip( KEY_LONGDESCR,    SECINFO, oData );
-      getEntryDescrip( KEY_TYPE,         SECINFO, oData );
-      getEntryDescrip( KEY_RANGE,        SECINFO, oData );
-      getEntryDescrip( KEY_DEFAULT,      SECINFO, oData );
-      getEntryDescrip( KEY_RANGECOMMENT, SECINFO, oData );
-      getEntryDescrip( KEY_RANGEINTEGER, SECINFO, oData );
-      getEntryDescrip( KEY_ACCESS_L,     SECINFO, oData );
-
-      // if the item has been rejected, the global key will be set
-      if( isRejected( iData ) )
-      {
-         aMap Item;
-         Item.set( LIST_COUNT, 1 );
-         Item.set( 1, "Rejected Item" );
-         oData.set( KEY_GLOBAL, Item );
-      }
-   }
-   return rc;
-}
-
-
-
-/**
- *
- * Exported function.
- *
-**/
-long cfgFunc_Kiosks( aMap const &, aMap& oData )
-{
-  aMap map;
-  map.set( KEY_SUPERSECNAME, DB_Client_SuperSec );
-  return cfgFunc_List( map, oData );
-}
-
-
-
-/**
- *
- * Exported function.
- *
-**/
-long cfgFunc_Directory( aMap const & SrcData, aMap & oData )
-{
-//   aMap iData = SrcData;
-
-   aMap DirDescr = getCfgDB()->get( DB_Descr_SuperSec ).mapObject();
-
-   aMap DirValue = getCfgDB()->get( DB_Values_SuperSec ).mapObject()
-                              .get( DB_Values_SubSuperSec ).mapObject();
-
-   long CurrentKey = KEY_SECNAME;
-   char const * PathItem = SrcData.get( CurrentKey ).strObject();
-   while( PathItem )
-   {
-
-      // Get the description
-      DirDescr = DirDescr.get( PathItem ).mapObject();
-
-      // Get the value
-      DirValue = DirValue.get( PathItem ).mapObject();
-      if( DirValue.getTag() != OBJ_MAP )
-      {
-         return CFGDB_ERR_NOT_FOUND;
-      }
-
-      // Scan down the tree
-      ++CurrentKey;
-      PathItem = SrcData.get( CurrentKey ).strObject();
-   }
-
-   aMap ItemDescList;
-   aMap ItemNameList;
-   aMap ItemValuList;
-   const aObject *pKey = DirValue.getNextKey( 0 );
-   int lCnt = 0;
-   while(pKey)
-   {
-      if( notListCountKey( pKey ) )
-      {
-         char const * IName = pKey->strObject();
-         if( IName )
-         {
-            aMap IDesc = DirDescr.get( IName ).mapObject();
-            if( IDesc.getTag() == OBJ_MAP )
-            {
-               char const * IType = IDesc.get( DB_Descr_Type ).mapObject()
-                                         .get( 1 ).strObject();
-               if( IType )
-               {
-                  char const * AccessL
-                     = IDesc.get( DB_Descr_AccessL ).mapObject()
-                            .get( 1 ).strObject();
-                  if( !AccessL ) AccessL = "";
-                  //
-                  // Simplified list access control
-                  //
-                  if( !( AccessL[0] && ( AccessL[2] != 'l' ) ) )
-                  {
-                     //
-                     // Item allowes to be listed
-                     //
-                     lCnt++;
-                     ItemNameList.set( lCnt, IName );
-                     ItemDescList.set( lCnt, IDesc );
-                     ItemValuList.set( lCnt, DirValue.get( IName ).mapObject() );
-                  }
-               }
-               else
-               {
-                  lCnt++;
-                  ItemNameList.set( lCnt, IName );
-                  ItemDescList.set( lCnt, aMap() );
-               }
-
-            }
-         }
-      }
-      pKey = DirValue.getNextKey( pKey );
-   }
-   oData.set( KEY_DEFAULT,  ItemDescList );
-   oData.set( KEY_ITEMNAME, ItemNameList );
-   oData.set( KEY_VALUE,    ItemValuList );
-   return CFGDB_OK;
-
-}
-
-
-
-/**
- *
- * Exported function.
- *
-**/
-long cfgFunc_List( aMap const & iData, aMap & oData )
-{
-   aMap ItemValueList, TypeList, DescrList, ValueList, RejectList;
-   long lCnt = 0;
-   if
-   (
-      iData.GETSTR(KEY_SUPERSECNAME) &&
-      ( GETSUPERSEC.getTag() == OBJ_MAP )
-   )
-   {
-      if
-      (
-         iData.GETSTR( KEY_SUBSUPERSECNAME ) &&
-         ( GETSUBSUPERSEC.getTag() == OBJ_MAP )
-      )
-      {
-         if
-         (
-            iData.GETSTR( KEY_SECNAME ) &&
-            ( GETSEC.getTag() == OBJ_MAP )
-         )
-         {
-            if
-            (
-               iData.GETSTR( KEY_SUBSECNAME ) &&
-               ( GETSUBSEC.getTag() == OBJ_MAP )
-            )
-            {
-               // make a list of items
-               aSortedMap items( GETSUBSEC.mapObject() );
-               const aObject *pKey = items.getNextKey( NULL );
-               while(pKey)
-               {
-                  if( notListCountKey( pKey ) )
-                  {
-                     lCnt++;
-                     ItemValueList.set(lCnt,*pKey);
-                     ValueList.set(lCnt,items.get(*pKey));
-                  }
-                  pKey = items.getNextKey(pKey);
-               }
-
-               int i;
-               for( i=1; i<= lCnt; i++ )
-               {
-                  aMap otData;
-                  int rc1 = getEntryDescrip
-                            (
-                               KEY_TYPE,
-                               iData.GETSTR(KEY_SECNAME),
-                               iData.GETSTR(KEY_SUBSECNAME),
-                               ItemValueList.GETSTR(i),
-                               otData
-                            );
-                  if( !rc1 )
-                  {
-                     TypeList.set( i, otData.GETLISTENTRY( KEY_TYPE, 1 ) );
-                  }
-                  else
-                  {
-                     TypeList.set( i, "" );
-                  }
-               }
-
-               for( i=1; i<= lCnt; i++ )
-               {
-                  aMap otData;
-                  int rc1 = getEntryDescrip
-                            (
-                               KEY_SHORTDESCR,
-                               iData.GETSTR(KEY_SECNAME),
-                               iData.GETSTR(KEY_SUBSECNAME),
-                               ItemValueList.GETSTR(i),
-                               otData
-                            );
-                  if( !rc1 )
-                     DescrList.set( i, otData.GETLISTENTRY( KEY_SHORTDESCR, 1 ) );
-                  else
-                     DescrList.set( i, "" );
-               }
-
-               for(i=1; i<= lCnt; i++)
-               {
-                  aMap itData = iData;
-                  itData.set(KEY_ITEMNAME,ItemValueList.GETSTR(i));
-                  if(isRejected(itData))
-                     RejectList.set(i,"Rejected");
-                  else
-                     RejectList.set(i,"");
-               }
-
-            }
-            else
-            {
-               if(!iData.GETSTR(KEY_SUBSECNAME))
-               {
-                  // make a list of subsections
-                  const aObject *pKey = GETSEC.mapObject().getNextKey(NULL);
-                  if( gvKeys( iData ) )
-                  {
-                     while(pKey)
-                     {
-                        aMap Stripped;
-                        Stripped.set( KEY_SECNAME, iData.GETSTR(KEY_SECNAME) );
-                        if( notListCountKey( pKey ) )
-                        {
-                           Stripped.set( KEY_SUBSECNAME, pKey->strObject() );
-                           if( gvHasDescription( Stripped ) )
-                           {
-                              lCnt++;
-                              ItemValueList.set(lCnt,*pKey);
-                           }
-                        }
-                        pKey = GETSEC.mapObject().getNextKey(pKey);
-                     }
-                  }
-                  else
-                  {
-                     while(pKey)
-                     {
-                        if( notListCountKey( pKey ) )
-                        {
-                           lCnt++;
-                           ItemValueList.set(lCnt,*pKey);
-                        }
-                        pKey = GETSEC.mapObject().getNextKey(pKey);
-                     }
-                  }
-               }
-            }
-         }
-         else
-         {
-            if(!iData.GETSTR(KEY_SECNAME))
-            {
-               // make a list of sections
-               const aObject *pKey = GETSUBSUPERSEC.mapObject().getNextKey(NULL);
-               if( gvKeys( iData ) )
-               {
-                  while(pKey)
-                  {
-                     if( notListCountKey( pKey ) )
-                     {
-                            aMap Stripped;
-                           Stripped.set( KEY_SECNAME, pKey->strObject() );
-                           if( gvHasDescription( Stripped ) )
-                           {
-                           lCnt++;
-                           ItemValueList.set(lCnt,*pKey);
-                           }
-                     }
-                     pKey = GETSUBSUPERSEC.mapObject().getNextKey(pKey);
-                  }
-               }
-               else
-               {
-                  while(pKey)
-                  {
-                     if( notListCountKey( pKey ) )
-                     {
-                        lCnt++;
-                        ItemValueList.set(lCnt,*pKey);
-                     }
-                     pKey = GETSUBSUPERSEC.mapObject().getNextKey(pKey);
-                  }
-               }
-            }
-         }
-      }
-      else
-      {
-         if(!iData.GETSTR(KEY_SUBSUPERSECNAME))
-         {
-            // make a list of sub super sections
-            const aObject *pKey = GETSUPERSEC.mapObject().getNextKey(NULL);
-            while(pKey)
-            {
-               if( notListCountKey( pKey ) )
-               {
-                  lCnt++;
-                  ItemValueList.set(lCnt,*pKey);
-               }
-               pKey = GETSUPERSEC.mapObject().getNextKey(pKey);
-            }
-         }
-      }
-   }
-   else
-   {
-      if(!iData.GETSTR(KEY_SUPERSECNAME))
-      {
-         // make a list of super sections
-         const aObject *pKey = getCfgDB()->mapObject().getNextKey(NULL);
-         while(pKey)
-         {
-            if( notListCountKey( pKey ) )
-            {
-               lCnt++;
-               ItemValueList.set(lCnt,*pKey);
-            }
-            pKey = getCfgDB()->mapObject().getNextKey(pKey);
-         }
-      }
-   }
-
-   if (lCnt)
-   {
-      ItemValueList.set(LIST_COUNT,lCnt);
-      oData.set(KEY_VALUE,ItemValueList);
-
-      if(TypeList.count())
-      {
-         TypeList.set(LIST_COUNT,lCnt);
-         oData.set(KEY_TYPE,TypeList);
-      }
-      if(DescrList.count())
-      {
-         DescrList.set(LIST_COUNT,lCnt);
-         oData.set(KEY_SHORTDESCR,DescrList);
-      }
-      if(RejectList.count())
-      {
-         RejectList.set(LIST_COUNT,lCnt);
-         oData.set(KEY_GLOBAL,RejectList);
-      }
-      if(ValueList.count())
-      {
-         ValueList.set(LIST_COUNT,lCnt);
-         oData.set(KEY_RANGE,ValueList);
-      }
-      return 0;
-   }
-   else
-      return CFGDB_ERR_NOT_FOUND;
-
-}
-
-
-
-/**
- *
- * Exported function.
- *
-**/
-long cfgFunc_ModifyData( aMap const & iData, char const * Date )
-{
-   aMap Map = iData;
-   Map.set( KEY_MODIFY_DATE, Date );
-   update_value( KEY_MODIFY_DATE, MDFYDTE, Map );
-   update_value( KEY_MODIFY_ADDR, MDFYADR, Map );
-   return 0;
-}
-
-
-
-/**
- *
- * Exported function.
- *
-**/
-long cfgFunc_OldItem(const aMap& iData, aMap& oData)
-{
-   long rc = 0;
-   aMap itData = iData;
-   if ( (iData.GETSTR(KEY_SUPERSECNAME)==NULL) || (iData.GETSTR(KEY_SUPERSECNAME)==NULL))
-   {
-      itData.set(KEY_SUPERSECNAME,DB_Values_SuperSec);
-      itData.set(KEY_SUBSUPERSECNAME,DB_Values_SubSuperSec);
-   }
-   if(getOldListEntry(itData,oData))
-      rc = CFGDB_ERR_NOT_FOUND;
-   return rc;
-}
-
-
-
-/**
- *
- * Exported function.
- *
-**/
-long cfgFunc_SimilarList( const aMap& iData, aMap& oData )
-{
-   long rc = recurseSimList(KEY_SUPERSECNAME,iData,oData);
-
-   if( rc == CFGDB_ERR )
-      rc = recurseSimList(KEY_SUBSUPERSECNAME,iData,oData);
-
-   if( rc == CFGDB_ERR )
-      rc = recurseSimList(KEY_SECNAME,iData,oData);
-
-   if( rc == CFGDB_ERR )
-      rc = recurseSimList(KEY_SUBSECNAME,iData,oData);
-
-   if( rc == CFGDB_ERR )
-      rc = recurseSimList(KEY_ITEMNAME,iData,oData);
-
-   if( rc == CFGDB_ERR )
-   {
-      //
-      // Collect things
-      //
-      aMap Item = iData;
-      long rc1 = getEntry_map( KEY_VALUE, iData,Item );
-      if( !rc1 )
-      {
-         aMap list = oData.get(KEY_VALUE).mapObject();
-         long lCnt = list.GETNUM(LIST_COUNT);
-         if(lCnt <= 0)
-          lCnt = 0;
-         lCnt++;
-         list.set(LIST_COUNT,lCnt);
-         list.set(lCnt,Item);
-
-         oData.set(KEY_VALUE,list);
-      }
-   }
-
-   if( oData.get(KEY_VALUE).mapObject().GETNUM(LIST_COUNT) <= 0 )
-      return CFGDB_ERR_NOT_FOUND;
-   else
-      return 0;
-}
-
-
-
-/**
- *
- * Exported function.
- *
-**/
-long cfgFunc_Update(const aMap& iData)
-{
-   long rc = 0;
-   aMap oData = iData;
-   if( !cfgFunc_Item( iData, oData) )
-   {
-      // save Data
-      if(iData.GETSTR(KEY_SUPERSECNAME) == NULL)
-      {
-         oData.set(KEY_SUPERSECNAME,DB_Values_SuperSec);
-         oData.set(KEY_SUBSUPERSECNAME,DB_Values_SubSuperSec);
-      }
-      addOldList(oData);
-   }
-   if (iData.GETSTR(KEY_SUPERSECNAME))
-      rc |= update_value
-            (
-               KEY_VALUE,
-               GIVENINFO, SECINFO, iData
-            );
-   else
-      rc |= update_value
-            (
-               KEY_VALUE,
-               DB_Values_SuperSec, DB_Values_SubSuperSec, SECINFO, iData
-            );
-   rc |= update_valueDescrip( KEY_CHANGEMODE,   SECINFO, iData );
-   rc |= update_valueDescrip( KEY_SHORTDESCR,   SECINFO, iData );
-   rc |= update_valueDescrip( KEY_LONGDESCR,    SECINFO, iData );
-   rc |= update_valueDescrip( KEY_TYPE,         SECINFO, iData );
-   rc |= update_valueDescrip( KEY_RANGE,        SECINFO, iData );
-   rc |= update_valueDescrip( KEY_GLOBAL,       SECINFO, iData );
-   rc |= update_valueDescrip( KEY_DEFAULT,      SECINFO, iData );
-   rc |= update_valueDescrip( KEY_RANGECOMMENT, SECINFO, iData );
-   rc |= update_valueDescrip( KEY_RANGEINTEGER, SECINFO, iData );
-   rc |= update_valueDescrip( KEY_ACCESS_L,     SECINFO, iData );
-   addUpdList( iData );
-   return rc;
-}
-
-
-
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
-
diff --git a/Massai/cpp/CfgXMgr/src/CfgMCnt.cpp b/Massai/cpp/CfgXMgr/src/CfgMCnt.cpp
deleted file mode 100644
index 96d2af34..00000000
--- a/Massai/cpp/CfgXMgr/src/CfgMCnt.cpp
+++ /dev/null
@@ -1,98 +0,0 @@
-/**
- * 
- * @file CfgMCnt.cpp
- * 
- */
-
-#include "CfgMCnt.hpp"
-
-#include "CfgDBI.hpp"
-
-#include <iostream>
-
-#include "AssoCStr.hpp"
-
-#include "assocp.h"
-
-
-
-namespace
-{
-   
-   char const CountKey[] = LIST_COUNT;
-   
-   char const * const Empty = 0;
-   
-
-   typedef void (* scanFunc)( aMap &, int );
-   
-   
-   
-   long scanSubmaps( aMap & Map, scanFunc Func, int Indent )
-   {
-      long Number = 0;
-      aObject const * pKey = Map.getNextKey( 0 );
-      while( pKey )
-      {
-         aObject SubObj = Map.get( *pKey );
-         if( SubObj.getTag() == OBJ_MAP )
-         {
-            aMap SubMap = SubObj.mapObject();
-            Func( SubMap, Indent );
-            Map.set( *pKey, SubMap );
-         }
-         ++Number;
-         pKey = Map.getNextKey( pKey );
-      }
-      return Number;
-   }
-   
-      
-   
-   void scanInsert( aMap & Map, int Indent )
-   {
-      // Remove any counter.
-      Map.set( CountKey, Empty );
-      // Handle submaps
-      long Number = scanSubmaps( Map, scanInsert, Indent + 1 );
-      // Insert counter
-      Map.set( CountKey, Number );
-      
-   }
-   
-   
-   
-   void scanRemove( aMap & Map, int Indent )
-   {
-      // Remove any counter.
-      Map.set( CountKey, Empty );
-      // Handle submaps
-      scanSubmaps( Map, scanRemove, Indent + 1 );
-   }
-   
-}
-
-
-
-void cfgMCnt_Insert( aMap & Dst, aMap const & Src )
-{
-   copyMap( Dst, Src );
-   scanInsert( Dst, 0 );
-}
-
-
-
-void cfgMCnt_Remove( aMap & Dst, aMap const & Src )
-{
-   copyMap( Dst, Src );
-   scanRemove( Dst, 0 );
-}
-
-
-
-/**
- * 
- * End of file
- * 
- */
-
diff --git a/Massai/cpp/CfgXMgr/src/CfgXML.cpp b/Massai/cpp/CfgXMgr/src/CfgXML.cpp
deleted file mode 100644
index 13fb2225..00000000
--- a/Massai/cpp/CfgXMgr/src/CfgXML.cpp
+++ /dev/null
@@ -1,349 +0,0 @@
-/**
- **************************************************************************
- *
- * @file CfgXML.cpp
- *
- * Read and write configuration data to an XML-formatted file.
- *
- * @author JK
- *
- * Copyright (c) 2001 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-
-#include "CfgXML.hpp"
-
-#include <string>
-#include <exception>
-#include "AssoXML.h"
-#include "CfgMCnt.hpp"
-#include "matThread.hpp"
-#include "DBS_Sync.hpp"
-#include "mEventSem.hpp"
-#include "mStringFile.hpp"
-#include "mWarning.hpp"
-
-
-
-/**
- *
- * XML-formatted configuration file interface class.
- *
-**/
-class cfgXML :
-   public matThread
-{
-
-   std::string const              M_Name;
-
-   std::string const              M_NameBackup;
-
-   aMap                           M_Config;
-
-   Materna::MSSD::eventSemaphore  M_Write;
-
-   void function()
-   {
-      for(;;)
-      {
-         //
-         // the wait() methow may throw an exception, leading to
-         // thread termination.
-         //
-         M_Write.wait();
-         //
-         // Reset sema to call writeNow another time, if write() has been
-         // called during the following execution of writeNow().
-         //
-         M_Write.reset();
-         //
-         // Give it a short time before actually writing to the file.
-         // This is useful because writing will block the database and
-         // hence delay sending change-indications.
-         //
-         matThreadSleep( 2500 );
-         //
-         // Write config file now, may take some seconds
-         //
-         writeNow();
-      }
-   }
-
-public:
-
-   /**
-    *
-    * Standard constructor - intentionally not implemented.
-    *
-   **/
-   cfgXML();
-
-   /**
-    *
-    * Copy constructor - intentionally not implemented.
-    *
-   **/
-   cfgXML( cfgXML const & );
-
-   /**
-    *
-    * Constructor
-    *
-    * param 1. The name of the configuration file.
-    *
-    * param 2. The name of the configuration backup file.
-    *
-   **/
-   explicit cfgXML( char const * Name, char const * NameBackup ) :
-      matThread(),
-      M_Name( Name ),
-      M_NameBackup( NameBackup ),
-      M_Config(),
-      M_Write()
-   {
-      // Start thread function
-      start( THREADPRTY_LOW );
-   }
-
-   /**
-    *
-    * Assignment - intentionally not implemented.
-    *
-   **/
-   cfgXML & operator=( cfgXML const & );
-
-   /**
-    *
-    * Read the configuration from file.
-    *
-   **/
-   void read();
-
-   /**
-    *
-    * Write the configuration to the file (later with low priority)
-    *
-   **/
-   void write()
-   {
-      M_Write.post();
-   }
-
-   /**
-    *
-    * Write the configuration to the file immediately.
-    *
-   **/
-   void writeNow();
-
-   /**
-    *
-    * Get a configuration map reference.
-    *
-   **/
-   aMap & getDB()
-   {
-      return M_Config;
-   }
-
-};
-
-
-
-namespace
-{
-   cfgXML *     CfgXML = 0;
-
-   std::string  FileName( "CfgMgr.xml" );
-
-   std::string  FileNameBackup( "CfgMgr.xml.bak" );
-
-}
-
-
-
-void cfgXML_Delete()
-{
-   delete CfgXML;
-   CfgXML = 0;
-}
-
-
-
-void cfgXML_Read()
-{
-   if( !CfgXML )
-      CfgXML = new cfgXML( FileName.c_str(), FileNameBackup.c_str() );
-   CfgXML->read();
-}
-
-
-
-void cfgXML_SetFile( char const * Name )
-{
-   FileName = Name;
-}
-
-
-
-void cfgXML_SetFileBackup( char const * Name )
-{
-   FileNameBackup = Name;
-}
-
-
-
-void cfgXML_Write()
-{
-   CfgXML->write();
-}
-
-
-
-aMap * getCfgDB()
-{
-   if( CfgXML )
-      return &( CfgXML->getDB() );
-   else
-      return 0;
-}
-
-
-
-/**
- *
- * Method implementation
- *
-**/
-void cfgXML::read()
-{
-   std::string ConfigStr;
-   mStringFromFile( ConfigStr, M_Name );
-   if( ConfigStr.size() )
-   {
-      try
-      {
-         aMap Pure;
-         mapFromXML( ConfigStr, Pure );
-         mStringToFile( M_NameBackup, ConfigStr );
-         //
-         // Save the valid configuration to a backup
-         //
-         cfgMCnt_Insert( M_Config, Pure );
-         return;
-      }
-      catch( assoXMLException & X )
-      {
-         Materna::warningAndContinue
-         (
-            "Config read XML exception",
-            X.what()
-         );
-      }
-      catch( std::exception & X )
-      {
-         Materna::warningAndContinue
-         (
-            "Config read STD exception",
-            X.what()
-         );
-      }
-      catch( ... )
-      {
-         Materna::warningAndContinue
-         (
-            "Config read unknown exception"
-         );
-      }
-   }
-   else
-   {
-         Materna::warningAndContinue
-         (
-            "Config file not found"
-         );
-   }
-   //
-   // Now try the backup
-   //
-   mStringFromFile( ConfigStr, M_NameBackup );
-   if( ConfigStr.size() )
-   {
-      try
-      {
-         aMap Pure;
-         mapFromXML( ConfigStr, Pure );
-         Materna::warningAndContinue
-         (
-            "Backup config used"
-         );
-         //
-         // Save the valid backup configuration to the original file.
-         //
-         mStringToFile( M_Name, ConfigStr );
-         cfgMCnt_Insert( M_Config, Pure );
-         return;
-      }
-      catch( assoXMLException & X )
-      {
-         Materna::warningAndContinue
-         (
-            "Backup config read XML exception",
-            X.what()
-         );
-      }
-      catch( std::exception & X )
-      {
-         Materna::warningAndContinue
-         (
-            "Backup config read STD exception",
-            X.what()
-         );
-      }
-      catch( ... )
-      {
-         Materna::warningAndContinue
-         (
-            "Backup config read unknown exception"
-         );
-      }
-   }
-   else
-   {
-      Materna::warningAndContinue
-      (
-         "Backup config file not found"
-      );
-   }
-}
-
-
-
-/**
- *
- * Method implementation
- *
-**/
-void cfgXML::writeNow()
-{
-   std::string ConfigStr;
-   stringTab ST;
-   aMap Pure;
-   syncDisable();
-   cfgMCnt_Remove( Pure, M_Config );
-   syncEnable();
-   mapToXML( Pure, ConfigStr, ST );
-   mStringToFile( M_Name, ConfigStr );
-}
-
-
-
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
-
diff --git a/Massai/cpp/CfgXMgr/src/Cfg_Main.cpp b/Massai/cpp/CfgXMgr/src/Cfg_Main.cpp
deleted file mode 100644
index 51d40ae8..00000000
--- a/Massai/cpp/CfgXMgr/src/Cfg_Main.cpp
+++ /dev/null
@@ -1,240 +0,0 @@
-//-------------------------------------------------------------------------
-//
-// Cfg_Main.cpp
-//
-// This is the main implementation file for CfgMgr.exe.
-// CfgMgr is a CORBA server for the configuration interface
-// defined in "CfgMgr.idl".
-//
-// Author: Juergen Kreierhoff
-//
-// Copyright (c) 2000-2004, MATERNA Information & Communications
-//
-//-------------------------------------------------------------------------
-
-
-#include "version.h"
-
-//-------------------------------------------------------------------------
-//
-//        01.Feb.2001, JK  First fully operational version, copied from
-//                         cfgdb.exe and modified for massai.
-// ATSA_VER( 01, 06, 00 );
-//
-//        11.Apr.2001, JK  Latest tcpcomm modules incorporated.
-// ATSA_VER( 01, 06, 01 );
-//
-//        30.Apr.2001, JK  Minor bugfixes.
-// ATSA_VER( 01, 06, 02 );
-//
-//        10.Aug.2001, JK  Restrict access for items without a "comment"
-//                         section.
-// ATSA_VER( 01, 06, 03 );
-//
-//        09.Oct.2001, JK  First working version with XML config file.
-// ATSA_VER( 01, 06, 04 );
-//
-//        08.Nov.2001, JK  Use latest .IDL
-// ATSA_VER( 01, 07, 00 );
-//
-//        08.Nov.2001, JK  Use latest (rollback) .IDL
-// ATSA_VER( 01, 07, 01 );
-//
-//        23.Nov.2001, JK  Use latest .IDL
-// ATSA_VER( 01, 07, 02 );
-//
-//        24.Jan.2002, JK  Using massaiCORBA interface
-// ATSA_VER( 01, 07, 04 );
-//
-//        26.Apr.2002, JK  Include timestamp in CfgXMgr console traces
-// ATSA_VER( 01, 07, 05 );
-//
-//        16.May.2002, JK  Fixed performance problems with large configs
-// ATSA_VER( 01, 07, 06 );
-//
-//        02.Jul.2002, JK  Traces improved
-// ATSA_VER( 01, 07, 07 );
-//
-//        26.Jul.2002, JK  Memory leak in DBX_Comm.hpp fixed
-//        22.Aug.2002, JK  Selection index with directory-get fixed
-// ATSA_VER( 01, 07, 08 );
-//
-//        10.Oct.2002, JK  - Use "static" 5M file buffer.
-//                         - Create a backupfile when reading config.
-// ATSA_VER( 01, 07, 09 );
-//
-//        27.Mar.2003, JK  Use "chunkedBuffer" for XML conversion.
-// ATSA_VER( 01, 07, 10 );
-//
-//        14.Aug.2003, JK  - Reinstall separate indication thread
-//                         - Cleanup dbs_sync interface
-//                         - first draft for directory::erase
-// ATSA_VER( 01, 07, 11 );
-//
-//        29.Jan.2004, JK  - In case of corrupted configuration try
-//                           the backup file first.
-// ATSA_VER( 01, 07, 12 );
-//
-//        04.Jun.2004, JK  - Support modified cfgmgr.idl
-//                           - improved throw lists
-//                           - Selection::setString()/getString()
-//                           - Directory::rightsSet()
-// ATSA_VER( 01, 07, 20 );
-//
-//        04.Jun.2004, JK  - Fix selection problem with index not
-//                           starting with 0
-//                         - Support modified cfgmgr.idl
-//                           - Replace Directory::rightsSet()
-//                              by Node::setRights()
-//                           - New dummy for Number::incrementGet()
-ATSA_VER( 01, 07, 30 );
-
-
-
-#include "matThread.hpp"
-#include "matSignal.h"
-
-#include "dbs_sync.hpp"
-#include "dbs_serv.hpp"
-#include "dbs_sess.hpp"
-
-#include "writeTrace.hpp"
-#include "mWarning.hpp"
-
-#include <iostream>
-using namespace std;
-
-#include "mMutexSem.hpp"
-#include <stdarg.h>
-
-#include "AssoCStr.hpp"
-#include "mHRTimer.h"
-
-
-
-static matSignal * pS = 0;
-static int         fActiveServ = 0;
-static int         fActiveSess = 0;
-static mHRTimer    Timer;
-
-
-
-void writeTraceSrv( long Level, char const * Text )
-{
-   writeTrace( Level, "Thread", 0, "servThread", Text );
-}
-
-void writeTraceSes( long Level, char const * Text )
-{
-   writeTrace( Level, "Thread", 0, "sessThread", Text );
-}
-
-class servThread : public matThread
-{
-   int M_argc;
-   char ** M_argv;
-
-   void function()
-   {
-      fActiveServ = 1;
-      if( servMain( M_argc, M_argv ) )
-      {
-         fActiveServ = 0;
-         delete pS;
-      }
-   }
-
-public:
-
-   servThread( int argc, char ** argv ) :
-      matThread( writeTraceSrv )
-   {
-      M_argc = argc;
-      M_argv = argv;
-      start();
-   }
-
-};
-
-
-
-class sessThread : public matThread
-{
-   void function()
-   {
-      fActiveSess = 1;
-      sessMain();
-   }
-
-public:
-
-   sessThread( int, char ** ) :
-      matThread( writeTraceSes )
-   {
-      start();
-   }
-
-};
-
-
-
-//void tcpCommModuleLog( char const * );
-
-int main( int argc, char ** argv )
-{
-   //tcpCommModuleLog( "tcp.log" );
-   writeTrace_Init( cout, 9 );
-   pS = new matSignal;
-   syncCreate();
-   servThread Serv( argc, argv );
-   sessThread Sess( argc, argv );
-   if( pS ) pS->wait();
-   if( fActiveServ ) servCleanUp();
-   if( fActiveSess ) sessCleanUp();
-   syncDelete();
-   return 0;
-}
-
-
-
-namespace Materna
-{
-
-   void warningAndContinue( char const * Msg, char const * Detail )
-   {
-      if( Msg )
-      {
-         if( Detail )
-         {
-            writeTrace
-            (
-               9, "main", 0, "warning",
-               "WARNING: %s [%s]", Msg, Detail
-            );
-         }
-         else
-         {
-            writeTrace
-            (
-               9, "main", 0, "warning",
-               "WARNING: %s", Msg
-            );
-         }
-      }
-      else
-      {
-         writeTrace
-         (
-            9, "main", 0, "warning",
-            "WARNING: ???"
-         );
-      }
-   }
-
-}
-
-
-
-//-------------------------------------------------------------------------
-// End of file
-//-------------------------------------------------------------------------
diff --git a/Massai/cpp/CfgXMgr/src/DBS_Node.cpp b/Massai/cpp/CfgXMgr/src/DBS_Node.cpp
deleted file mode 100644
index 67df8ffa..00000000
--- a/Massai/cpp/CfgXMgr/src/DBS_Node.cpp
+++ /dev/null
@@ -1,486 +0,0 @@
-/**
- **************************************************************************
- *
- * @file DBS_Node.cpp
- *
- * Contains CORBA base services
- *
- * @author JK
- *
- * Copyright (c) 2000 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#pragma warning (disable: 4786 )
-
-#define MLISTEN_METHOD valueChanged
-#include "mListen.hpp"
-
-
-#include "dbs_node.hpp"
-#include "cfgdbi.hpp"
-#include "DBS_Sync.hpp"
-#include "mMutexSem.hpp"
-#include "mFMTQueue.hpp"
-#include "matThread.hpp"
-
-#define NAME_SIZE  256
-
-#include <map>
-#include <string>
-
-#include "TraceClt.h"
-#define __FUNCTION__ ""
-
-#define SCN "serviceCfgNode::"
-
-
-/**
- *
- * Declare the change listeners for a configuration item.
- *
-**/
-typedef mListen<Config::changeListener_ptr, char const *>
-   mLst;
-
-/**
- *
- * Declare the change listeners for a number configuration items.
- *
-**/
-typedef std::map< std::string, mLst * >
-   mNameLst;
-
-namespace
-{
-   /*
-    * Module-privates
-    */
-
-
-
-   /**
-    *
-    * Keep all the change listeners here.
-    *
-   **/
-   mNameLst CList;
-
-
-
-   /**
-    *
-    * Protect change listeners against mutual access.
-    *
-   **/
-   Materna::MSSD::mutexSemaphore Mutex;
-
-
-
-   /**
-    *
-    * Retrieve an indexed part of a configuration item name.
-    *
-    * @param 1st Begin of bufferspace to use
-    *
-    * @param 2nd End of bufferspace to use
-    *
-    * @param 3rd The configuration item, a string like "AAA.BBB.CCC"
-    *
-    * @param 4th The index
-    *
-    * @return The verb between the index-th and index+1-th dot or 0.
-    *
-   **/
-   char * dotTok( char * BufferFrom, char * BufferTo, char const * Name, int Index )
-   {
-      while( Index-- )
-      {
-         while( *Name && ( *Name != '.' ) ) ++Name;
-         if( *Name == 0 )
-            return 0;
-         ++Name;
-      }
-      char * BufferCur = BufferFrom;
-      while( *Name && ( *Name != '.' ) && ( BufferCur < (BufferTo-1) ) )
-      {
-         *BufferCur++ = *Name++;
-      }
-      if( BufferCur == BufferFrom )
-         return 0;
-      *BufferCur = 0;
-      return BufferFrom;
-   }
-
-
-
-   /*
-    * End of module-privates
-    */
-}
-
-
-
-/**
- *
- * Method implementation (see DBS_Node.hpp)
- *
-**/
-void serviceCfgNode::addChangeListener
-(
-   const Config::access &    Acc,
-   Config::changeListener *  Listener
-)
-{
-   std::string ItemKey( Acc.Item );
-   Mutex.request();
-//   std::cout << "addChangeListener - size=" << CList.size() << "..." << std::endl;
-   mNameLst::iterator CListI( CList.find( ItemKey ) );
-   mLst * pLst;
-   if( CListI == CList.end() )
-   {
-      pLst = new mLst();
-      CList[ItemKey] = pLst;
-   }
-   else
-   {
-      pLst = CListI->second;
-   }
-   pLst->set( Listener->_duplicate( Listener ) );
-//   std::cout << "addChangeListener - size=" << CList.size() << "." << std::endl;
-   Mutex.release();
-}
-
-
-
-/**
- *
- * Method implementation (see DBS_Node.hpp)
- *
-**/
-void serviceCfgNode::removeChangeListener
-(
-   Config::changeListener * Listener
-)
-{
-   Mutex.request();
-//   std::cout << "removeChangeListener - size=" << CList.size() << "..." << std::endl;
-   mNameLst::iterator I;
-   for( I = CList.begin(); I != CList.end(); ++I )
-   {
-      mLst * Lst = I->second;
-      Lst->clr( Listener );
-   }
-//   std::cout << "removeChangeListener - size=" << CList.size() << "." << std::endl;
-   Mutex.release();
-}
-
-
-
-/**
- *
- * Method implementation (see DBS_Node.hpp)
- *
-**/
-void serviceCfgNode::removeChangeListenerItem
-(
-   Config::changeListener *  Listener,
-   char const *              Item
-)
-{
-   Mutex.request();
-//   std::cout << "removeChangeListenerItem - size=" << CList.size() << "..." << std::endl;
-   mNameLst::iterator CListI( CList.find( Item ) );
-   if( CListI != CList.end() )
-   {
-      mLst * pLst = CListI->second;
-      pLst->clr( Listener );
-   }
-//   std::cout << "removeChangeListenerItem - size=" << CList.size() << "." << std::endl;
-   Mutex.release();
-}
-
-
-
-/**
- *
- * Method implementation (see DBS_Node.hpp)
- *
-**/
-int serviceCfgNode::nodeCommit()
-{
-   aMap Req, Rsp;
-   Req.set( KEY_CMDID, DB_COMMIT );
-   return syncReq( Req, Rsp );
-}
-
-
-
-/**
- *
- * Method implementation (see DBS_Node.hpp)
- *
-**/
-void serviceCfgNode::nodeCreate
-(
-   aMap &                      Request,
-   Config::access const &      Acc,
-   Config::description const & Desc
-)
-{
-   writeTrace( BasicRuntime_HERE, SCN "nodeCreate ..." );
-
-   Request.set( KEY_CMDID, GET_ITEM );
-   Request.set( KEY_CMDID, GET_ITEM );
-   aMap IResp;
-   nodeRequest( Acc, Request, IResp );
-   aObject Default = IResp.get( KEY_DEFAULT );
-   if( Default.getTag() == OBJ_MAP )
-   {
-      writeTrace( BasicRuntime_HERE, SCN "nodeCreate - got initial" );
-      Request.set( KEY_VALUE, Default );
-   }
-
-   //
-   // Defaults
-   //
-   Request.set( KEY_CMDID, UPD_ITEM );
-   Request.set( KEY_GLOBAL, CFGDB_TRUE );
-   Request.set( KEY_CHANGEMODE, "CHANGE ON THE FLY" );
-   //
-   // Description
-   //
-   std::string S;
-   nodeParse( S, Desc.Explanation, "LONG" );
-   if( S.length() )
-      Request.set( KEY_LONGDESCR, S.c_str() );
-   else
-      Request.set( KEY_LONGDESCR, (char const *)Desc.Explanation );
-   S = " ";
-   nodeParse( S, Desc.Explanation, "SHORT" );
-   Request.set( KEY_SHORTDESCR, S.c_str() );
-   //
-   // Rights
-   //
-   char const * R = Desc.Rights;
-   Request.set( KEY_ACCESS_L, R );
-   //
-   // Issue the request ...
-   //
-   aMap Response;
-   if( nodeRequest( Acc, Request, Response ) )
-   {
-      writeTrace( MajorWarning_HERE, SCN "nodeCreate - nodeRequest exception" );
-      throw Config::Node::notCreated();
-   }
-   if( nodeCommit() )
-   {
-      writeTrace( MajorWarning_HERE, SCN "nodeCreate - nodeCommit exception" );
-      throw Config::Node::notCreated();
-   }
-   writeTrace( BasicRuntime_HERE, SCN "nodeCreate." );
-}
-
-
-
-/**
- *
- * Method implementation (see DBS_Node.hpp)
- *
-**/
-int serviceCfgNode::nodeRequest( const Config::access & Acc, aMap & Req, aMap & Rsp )
-{
-   char const * Auth = Acc.Authorization;
-   Req.set( KEY_CLIENT_NAME, Auth );
-   char const * Item = Acc.Item;
-   char Buffer[256];
-   Req.set( KEY_SECNAME,    dotTok( Buffer, Buffer + sizeof(Buffer), Item, 0 ) );
-   Req.set( KEY_SUBSECNAME, dotTok( Buffer, Buffer + sizeof(Buffer), Item, 1 ) );
-   Req.set( KEY_ITEMNAME,   dotTok( Buffer, Buffer + sizeof(Buffer), Item, 2 ) );
-   int R = syncReq( Req, Rsp );
-   return R;
-}
-
-
-
-/**
- *
- * Method implementation (see DBS_Node.hpp)
- *
-**/
-int serviceCfgNode::nodeGetValue( const Config::access & Acc, aObject & Value )
-{
-   aMap Request, Response;
-   aObject ORsp;
-   Request.set( KEY_CMDID, GET_VALUE );
-   int RC = nodeRequest( Acc, Request, Response );
-   if( RC == 0 )
-      Value = Response.get( KEY_VALUE );
-   return RC;
-}
-
-
-
-/**
- *
- * Method implementation (see DBS_Node.hpp)
- *
-**/
-int serviceCfgNode::nodeSetInitial( const Config::access & Acc, const aObject & Value )
-{
-   aMap Request, Response;
-   aObject ORsp;
-   Request.set( KEY_CMDID, UPD_ITEM );
-   Request.set( KEY_DEFAULT, Value );
-   return nodeRequest( Acc, Request, Response );
-}
-
-
-
-/**
- *
- * Method implementation (see DBS_Node.hpp)
- *
-**/
-int serviceCfgNode::nodeSetValue( const Config::access & Acc, const aObject & Value )
-{
-   aMap Request, Response;
-   aObject ORsp;
-   Request.set( KEY_CMDID, UPD_ITEM );
-   Request.set( KEY_VALUE, Value );
-   return nodeRequest( Acc, Request, Response );
-}
-
-
-
-/**
- *
- * Public function (see DBS_Node.hpp)
- *
-**/
-void nodeExit()
-{
-}
-
-
-
-/**
- *
- * Public function (see DBS_Node.hpp)
- *
-**/
-void nodeInit()
-{
-}
-
-
-
-namespace
-{
-
-   Materna::MSSD::fmtQueue<std::string> CQ( 10 );
-
-   class nodeChangeThread :
-      public matThread
-   {
-
-      void function()
-      {
-         std::string ItemStr;
-         for(;;)
-         {
-//            std::cout << "nodeChangeThread - wait" << std::endl;
-            CQ.read( ItemStr );
-            char const * ItemC = ItemStr.c_str();
-            Mutex.request();
-//            std::cout << "nodeChangeThread - item=" << ItemC << " size=" << CList.size() << std::endl;
-            mNameLst::iterator CListI( CList.find( ItemC ) );
-            if( CListI != CList.end() )
-            {
-               mLst * pLst = CListI->second;
-               pLst->valueChanged( ItemC );
-            }
-            Mutex.release();
-         }
-      }
-
-   public:
-
-      nodeChangeThread()
-      {
-         start();
-      }
-
-   };
-
-   nodeChangeThread CT;
-
-
-
-   char const * nodeParseS( char const * Src, char const * Pat )
-   {
-      while( *Src && *Pat && ( *Src == *Pat ) )
-      {
-         ++Src;
-         ++Pat;
-      }
-      return Src;
-   }
-
-}
-
-
-
-/**
- *
- * Public function (see DBS_Node.hpp)
- *
-**/
-void nodeChange( char const * Item )
-{
-   CQ.write( Item );
-}
-
-
-
-/**
- *
- * Public function (see DBS_Node.hpp)
- *
-**/
-void nodeParse
-(
-   std::string & Dst,
-   char const * Src,
-   char const * Pattern
-)
-{
-   while( *Src )
-   {
-      if( *Src == '[' )
-      {
-         char const * End = nodeParseS( Src+1, Pattern );
-         if( *End == '=' )
-         {
-            std::string R;
-            ++End;
-            while( *End && ( *End != ']' ) )
-            {
-               R += *End;
-               ++End;
-            }
-            Dst = R;
-            return;
-         }
-         Src = End;
-      }
-      ++Src;
-   }
-}
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
\ No newline at end of file
diff --git a/Massai/cpp/CfgXMgr/src/DBS_Serv.cpp b/Massai/cpp/CfgXMgr/src/DBS_Serv.cpp
deleted file mode 100644
index c49f4878..00000000
--- a/Massai/cpp/CfgXMgr/src/DBS_Serv.cpp
+++ /dev/null
@@ -1,1654 +0,0 @@
-/**
- **************************************************************************
- *
- * @file DBS_Serv.cpp
- *
- * Contains CORBA main configuration servers.
- *
- * @author Juergen Kreierhoff
- *
- * Copyright (c) 2000-2005, MATERNA Information & Communications
- *
- **************************************************************************
-**/
-
-#include <iostream>
-
-#include "DBS_Serv.hpp"
-
-#include "orbincdefs.h"
-
-#ifdef _TAO_
-#include "Tao/CORBA.h"
-#include "Tao/PortableServer/POA.h"
-#include "CfgMgr.h"
-#include "CfgMgr_skel.h"
-#include "CfgMgr_skel_T.h"
-#endif
-
-#ifdef _ORBACUS_
-#include <CfgMgr_skel.h>
-#endif
-
-
-#include "CfgMgrIPC.h"
-#include "CfgMgrStrings.h"
-#include "TraceClt.h"
-#define __FUNCTION__ ""
-
-#include <fstream>
-using namespace std;
-#include "argScan.hpp"
-
-#include "dbs_node.hpp"
-#include "corbasrvr.h"
-
-#include "cfgdbi.hpp"
-#include "mEventSem.hpp"
-
-#include "DBS_Sync.hpp"
-
-#define SCT  "serviceCfgText::"
-#define SCTL "serviceCfgTextlist::"
-#define SCN  "serviceCfgNumber::"
-#define SCS  "serviceCfgSelection::"
-#define SCD  "serviceCfgDirectory::"
-
-#define CFGKEY_ONEVALUE  1
-#define CFGKEY_LIMIT_MIN 1
-#define CFGKEY_LIMIT_MAX 2
-
-
-namespace
-{
-
-
-
-   /**
-    *
-    * Get a numeric value from a string item in a map given
-    *
-    * @param Src The map given
-    *
-    * @param SrcX The numeric map key to use
-    *
-    * @return The value
-    *
-   **/
-   long getNumFromVal( aMap const & Src, int SrcX )
-   {
-      char const * pS = Src.get( SrcX ).strObject();
-      if( pS )
-         return atoi( pS );
-      else
-         return 0;
-   }
-
-
-
-   /**
-    *
-    * Set a numeric value as string to a map with a numeric key given.
-    *
-    * @param Dst The destination map
-    *
-    * @param DstX The numeric key to use
-    *
-    * @param Src  The value to set
-    *
-   **/
-   void setNumToVal( aMap & Dst, int DstX, long Src )
-   {
-      char Buffer[32];
-      itoa( Src, Buffer, 10 );
-      Dst.set( DstX, Buffer );
-   }
-
-
-   /**
-    *
-    * Create a map object from strings
-    *
-   **/
-   aMap mapFromStrings( Config::Textlist::strings const & Src )
-   {
-      long RetNumber = 0;
-      aMap RetMap;
-      long RetLen = Src.length();
-      while( RetNumber < RetLen )
-      {
-         char const * SrcString = Src[RetNumber];
-         RetMap.set( RetNumber + 1, SrcString );
-         ++RetNumber;
-      }
-      RetMap.set( LIST_COUNT, RetNumber );
-      return RetMap;
-   }
-
-
-
-   /**
-    *
-    * Create strings from a map
-    *
-   **/
-   Config::Textlist::strings * mapToStrings( aMap const & Src )
-   {
-      Config::Textlist::strings* pSList = new Config::Textlist::strings;
-      int Idx = 0;
-      pSList->length( Src.get( LIST_COUNT ).numObject() );
-      char const * SStr = Src.get( Idx + 1 ).strObject();
-      while( SStr )
-      {
-         (*pSList)[Idx] = CORBA::string_dup( SStr );
-         ++Idx;
-         SStr = Src.get( Idx + 1 ).strObject();
-      }
-      return pSList;
-   }
-
-
-
-   /**
-    *
-    * Retrieve the string value of a map with the same key as a index value
-    * in an index map.
-    *
-    * @param Ndx The value in the index map
-    *
-    * @param NdxMap The index map
-    *
-    * @param ValMap The string map
-    *
-    * @return The string from the string map (or 0)
-    *
-   **/
-   char const * ranValFromNdx
-   (
-      long         Ndx,
-      aMap const & NdxMap,
-      aMap const & ValMap
-   )
-   {
-      //
-      // Look for the index in the range
-      // (beginning with key 1).
-      //
-      int I = 1;
-      char const * pszNdx = NdxMap.get( I ).strObject();
-      while( pszNdx )
-      {
-         if( getNumFromVal( NdxMap, I ) == Ndx )
-         {
-            //
-            // Index found
-            //
-            return ValMap.get( I ).strObject();
-         }
-         ++I;
-         pszNdx = NdxMap.get( I ).strObject();
-      }
-      return 0;
-   }
-
-
-
-   /**
-    *
-    * Retrieve a non-null zero terminated string from a map value
-    * with key 1.
-    *
-   **/
-   char const * validStringMap1( aMap const & Map )
-   {
-      char const * Ret = Map.get( 1 ).strObject();
-      if( Ret )
-         return Ret;
-      else
-         return "";
-   }
-
-
-
-   /**
-    *
-    * Retrieve a non-null zero terminated string from a map value
-    * with a given key -> map with key 1.
-    *
-   **/
-   char const * validStringMapKey1( aMap const & Map, char const * Key )
-   {
-      return validStringMap1( Map.get( Key ).mapObject() );
-   }
-
-
-
-} // namespace
-
-
-
-/**
- **************************************************************************
- *
- * Text configuration service implementation class
- *
- **************************************************************************
-**/
-class serviceCfgText :
-   public POA_Config::Text,
-   public serviceCfgNode
-{
-
-   /**
-    *
-    * Add a configuration change listener
-    *
-   **/
-   void addChangeListener
-   (
-      Config::access const & Acc,
-      Config::changeListener * L
-   )
-   {
-      writeTrace
-              (
-                 BasicRuntime_HERE,
-                 SCT "addChangeListener"
-              );
-      serviceCfgNode::addChangeListener( Acc, L );
-   }
-
-   /**
-    *
-    * Remove a configuration change listener
-    *
-   **/
-   void removeChangeListener( Config::changeListener * L )
-   {
-      writeTrace
-              (
-                 BasicRuntime_HERE,
-                 SCT "removeChangeListener"
-              );
-      serviceCfgNode::removeChangeListener( L );
-   }
-
-   /**
-    *
-    * Remove a configuration change listener
-    *
-   **/
-   void removeChangeListenerItem
-        (
-           Config::changeListener * L,
-           char const * I
-        )
-   {
-      writeTrace
-              (
-                 BasicRuntime_HERE,
-                 SCT "removeChangeListenerItem"
-              );
-      serviceCfgNode::removeChangeListenerItem( L, I );
-   }
-
-   /**
-    *
-    * Get configuration access rights.
-    *
-   **/
-   char * getRights( Config::access const & Acc )
-   {
-      writeTrace
-      (
-         SecondaryRuntime_HERE, SCT "getRights(%s)",
-         Acc.Item
-      );
-      return CORBA::string_dup( "???" );
-   }
-
-   /**
-    *
-    * Set configuration access rights
-    *
-   **/
-   void setRights( Config::access const & Acc, char const * Rights )
-   {
-      writeTrace
-      (
-         SecondaryRuntime_HERE, SCT "setRights(%s) = [%s]",
-         Acc.Item, Rights
-      );
-   }
-
-   /**
-    *
-    * Create a configuration item
-    *
-   **/
-   void create
-        (
-           Config::access const &            Acc,
-           Config::description const &       Desc,
-           char const *                      D
-#ifdef USE_STRINGMAX
-           ,
-           CORBA::Long                       MaxLength
-#endif
-        )
-   {
-      writeTrace
-              (
-                 BasicRuntime_HERE,
-                 SCT "create rights:%s explanation:%s",
-                 Desc.Rights, Desc.Explanation
-              );
-      // The value list
-      aMap Val;
-      Val.set( 1, D );
-      Val.set( LIST_COUNT, 1 );
-      // The range list
-      aMap Ran;
-      setNumToVal( Ran, CFGKEY_LIMIT_MIN, 0 );
-#ifdef USE_STRINGMAX
-      setNumToVal( Ran, CFGKEY_LIMIT_MAX, MaxLength );
-#else
-      std::string S = "1024";
-      nodeParse( S, Desc.Explanation, "SIZE" );
-      setNumToVal( Ran, CFGKEY_LIMIT_MAX, atoi( S.c_str() ) );
-#endif
-      Ran.set( LIST_COUNT, 2 );
-      // Build request
-      aMap Request;
-      Request.set( KEY_DEFAULT, Val );
-      Request.set( KEY_TYPE, CFGTYPE_STRING );
-      Request.set( KEY_RANGE, Ran );
-      Request.set( KEY_VALUE, Val );
-      nodeCreate( Request, Acc, Desc );
-   }
-
-   /**
-    *
-    * Get a configuration value
-    *
-   **/
-   char * get( Config::access const & Acc )
-   {
-      aObject ORsp;
-      nodeGetValue( Acc, ORsp );
-      if( ORsp.getTag() == OBJ_MAP )
-      {
-         char const * S = ORsp.mapObject().get( 1 ).strObject();
-         if( S )
-         {
-            writeTrace( SecondaryRuntime_HERE, SCT "get = %s", S );
-            return CORBA::string_dup( S );
-         }
-         else
-         {
-            writeTrace( SecondaryRuntime_HERE, SCT "get = NULL" );
-            throw Config::Node::notFound();
-            return 0;
-         }
-      }
-      else
-      {
-         writeTrace( MajorWarning_HERE, SCT "get exception" );
-         throw Config::Node::notFound();
-         return 0;
-      }
-   }
-
-   /**
-    *
-    * Set a configuration value
-    *
-   **/
-   void set( Config::access const & Acc, char const * Text )
-   {
-      writeTrace( SecondaryRuntime_HERE, SCT "set: %s", Text );
-      aMap Val;
-      Val.set( 1, Text );
-      Val.set( LIST_COUNT, 1 );
-      if( nodeSetValue( Acc, Val ) )
-      {
-         writeTrace( MajorWarning_HERE, SCT "set exception" );
-         throw Config::Node::notFound();
-      }
-      if( nodeCommit() )
-      {
-         writeTrace( MajorWarning_HERE, SCT "set commit exception" );
-         throw Config::Node::notFound();
-      }
-   }
-
-   /**
-    *
-    * Set an initial configuration value
-    *
-   **/
-   void setInitial( Config::access const & Acc, char const * Text )
-   {
-      writeTrace( SecondaryRuntime_HERE, SCT "setInitial: %s", Text );
-      aMap Val;
-      Val.set( 1, Text );
-      Val.set( LIST_COUNT, 1 );
-      if( nodeSetInitial( Acc, Val ) )
-      {
-         writeTrace( MajorWarning_HERE, SCT "setInitial exception" );
-         throw Config::Node::wrongParam();
-      }
-      if( nodeCommit() )
-      {
-         writeTrace( MajorWarning_HERE, SCT "setInitial commit exception" );
-         throw Config::Node::wrongParam();
-      }
-   }
-
-};
-
-
-
-/**
- **************************************************************************
- *
- * Textlist configuration service implementation class
- *
- **************************************************************************
-**/
-class serviceCfgTextlist :
-   public POA_Config::Textlist,
-   public serviceCfgNode
-{
-
-   /**
-    *
-    * Add a configuration change listener
-    *
-   **/
-   void addChangeListener
-   (
-      Config::access const & Acc,
-      Config::changeListener * L
-   )
-   {
-      writeTrace
-              (
-                 BasicRuntime_HERE,
-                 SCTL "addChangeListener"
-              );
-      serviceCfgNode::addChangeListener( Acc, L );
-   }
-
-   /**
-    *
-    * Remove a configuration change listener
-    *
-   **/
-   void removeChangeListener( Config::changeListener * L )
-   {
-      writeTrace
-              (
-                 BasicRuntime_HERE,
-                 SCTL "removeChangeListener"
-              );
-      serviceCfgNode::removeChangeListener( L );
-   }
-
-   /**
-    *
-    * Remove a configuration change listener
-    *
-   **/
-   void removeChangeListenerItem
-        (
-           Config::changeListener * L,
-           char const * I
-        )
-   {
-      writeTrace
-              (
-                 BasicRuntime_HERE,
-                 SCTL "removeChangeListenerItem"
-              );
-      serviceCfgNode::removeChangeListenerItem( L, I );
-   }
-
-   /**
-    *
-    * Get configuration access rights.
-    *
-   **/
-   char * getRights( Config::access const & Acc )
-   {
-      writeTrace
-      (
-         SecondaryRuntime_HERE, SCTL "getRights(%s)",
-         Acc.Item
-      );
-      return CORBA::string_dup( "???" );
-   }
-
-   /**
-    *
-    * Set configuration access rights
-    *
-   **/
-   void setRights( Config::access const & Acc, char const * Rights )
-   {
-      writeTrace
-      (
-         SecondaryRuntime_HERE, SCTL "setRights(%s) = [%s]",
-         Acc.Item, Rights
-      );
-   }
-
-   /**
-    *
-    * Create a configuration value
-    *
-   **/
-   void create
-        (
-           Config::access const &            Acc,
-           Config::description const &       Desc,
-           Config::Textlist::strings const & D
-#ifdef USE_STRINGMAX
-           ,
-           CORBA::Long                       MaxLength
-#endif
-        )
-   {
-      writeTrace
-              (
-                 BasicRuntime_HERE,
-                 SCTL "create rights:%s explanation:%s",
-                 Desc.Rights, Desc.Explanation
-              );
-      // The value
-      aMap Val = mapFromStrings( D );
-      // The range list
-      aMap Ran;
-      setNumToVal( Ran, CFGKEY_LIMIT_MIN, 0 );
-#ifdef USE_STRINGMAX
-      setNumToVal( Ran, CFGKEY_LIMIT_MAX, MaxLength );
-#else
-      std::string S = "1024";
-      nodeParse( S, Desc.Explanation, "SIZE" );
-      setNumToVal( Ran, CFGKEY_LIMIT_MAX, atoi( S.c_str() ) );
-#endif
-      Ran.set( LIST_COUNT, 2 );
-      // Build request
-      aMap Request;
-      Request.set( KEY_DEFAULT, Val );
-      Request.set( KEY_TYPE, CFGTYPE_STRING_LIST );
-      Request.set( KEY_RANGE, Ran );
-      Request.set( KEY_VALUE, Val );
-      nodeCreate( Request, Acc, Desc );
-   }
-
-   /**
-    *
-    * Get a configuration value
-    *
-   **/
-   Config::Textlist::strings * get( Config::access const & Acc )
-   {
-
-      aObject ORsp;
-      nodeGetValue( Acc, ORsp );
-      if( ORsp.getTag() == OBJ_MAP )
-      {
-         writeTrace( SecondaryRuntime_HERE, SCTL "get." );
-         return mapToStrings( ORsp.mapObject() );
-      }
-      else
-      {
-         writeTrace( MajorWarning_HERE, SCTL "get - exception" );
-         throw Config::Node::notFound();
-         return 0;
-      }
-   }
-
-   /**
-    *
-    * Set a configuration value
-    *
-   **/
-   void set
-        (
-           Config::access const & Acc,
-           Config::Textlist::strings const & Texts
-        )
-   {
-      writeTrace( SecondaryRuntime_HERE, SCTL "set" );
-      if( nodeSetValue( Acc, mapFromStrings( Texts ) ) )
-      {
-         writeTrace( MajorWarning_HERE, SCTL "set - exception" );
-         throw Config::Node::notFound();
-      }
-      if( nodeCommit() )
-      {
-         writeTrace( MajorWarning_HERE, SCTL "set - commit exception" );
-         throw Config::Node::notFound();
-      }
-   }
-
-   /**
-    *
-    * Set an initial configuration value
-    *
-   **/
-   void setInitial
-        (
-           Config::access const & Acc,
-           Config::Textlist::strings const & Texts
-        )
-   {
-      writeTrace( SecondaryRuntime_HERE, SCTL "setInitial" );
-      if( nodeSetInitial( Acc, mapFromStrings( Texts ) ) )
-      {
-         writeTrace( MajorWarning_HERE, SCTL "setInitial - exception" );
-         throw Config::Node::wrongParam();
-      }
-      if( nodeCommit() )
-      {
-         writeTrace( MajorWarning_HERE, SCTL "setInitial - commit exception" );
-         throw Config::Node::wrongParam();
-      }
-   }
-
-};
-
-
-
-
-/**
- **************************************************************************
- *
- * Number configuration service implementation class
- *
- **************************************************************************
-**/
-class serviceCfgNumber :
-   public POA_Config::Number,
-   public serviceCfgNode
-{
-
-   /**
-    *
-    * Add a configuration change listener
-    *
-   **/
-   void addChangeListener
-   (
-      Config::access const & Acc,
-      Config::changeListener * L
-   )
-   {
-      writeTrace
-              (
-                 BasicRuntime_HERE,
-                 SCN "addChangeListener"
-              );
-      serviceCfgNode::addChangeListener( Acc, L );
-   }
-
-   /**
-    *
-    * Remove a configuration change listener
-    *
-   **/
-   void removeChangeListener( Config::changeListener * L )
-   {
-      writeTrace
-              (
-                 BasicRuntime_HERE,
-                 SCN "removeChangeListener"
-              );
-      serviceCfgNode::removeChangeListener( L );
-   }
-
-   /**
-    *
-    * Remove a configuration change listener
-    *
-   **/
-   void removeChangeListenerItem
-        (
-           Config::changeListener * L,
-           char const * I
-        )
-   {
-      writeTrace
-              (
-                 BasicRuntime_HERE,
-                 SCN "removeChangeListenerItem"
-              );
-      serviceCfgNode::removeChangeListenerItem( L, I );
-   }
-
-   /**
-    *
-    * Get configuration access rights.
-    *
-   **/
-   char * getRights( Config::access const & Acc )
-   {
-      writeTrace
-      (
-         SecondaryRuntime_HERE, SCN "getRights(%s)",
-         Acc.Item
-      );
-      return CORBA::string_dup( "???" );
-   }
-
-   /**
-    *
-    * Set configuration access rights
-    *
-   **/
-   void setRights( Config::access const & Acc, char const * Rights )
-   {
-      writeTrace
-      (
-         SecondaryRuntime_HERE, SCN "setRights(%s) = [%s]",
-         Acc.Item, Rights
-      );
-   }
-
-   /**
-    *
-    * Create a configuration item
-    *
-   **/
-   void create
-        (
-           Config::access const &       Acc,
-           Config::description const &  Desc,
-           CORBA::Long                  Def,
-           CORBA::Long                  Min,
-           CORBA::Long                  Max
-        )
-   {
-      writeTrace
-              (
-                 BasicRuntime_HERE,
-                 SCN "create rights:%s explanation:%s",
-                 Desc.Rights, Desc.Explanation
-              );
-      // The value list
-      aMap Val;
-      setNumToVal( Val, CFGKEY_ONEVALUE, Def );
-      Val.set( LIST_COUNT, 1 );
-      // The range list
-      aMap Ran;
-      setNumToVal( Ran, CFGKEY_LIMIT_MIN, Min );
-      setNumToVal( Ran, CFGKEY_LIMIT_MAX, Max );
-      Ran.set( LIST_COUNT, 2 );
-      // Build request
-      aMap Request;
-      Request.set( KEY_DEFAULT, Val );
-      Request.set( KEY_TYPE, CFGTYPE_INTEGER );
-      Request.set( KEY_RANGE, Ran );
-      Request.set( KEY_VALUE, Val );
-      nodeCreate( Request, Acc, Desc );
-   }
-
-   /**
-    *
-    * Get a configuration value
-    *
-   **/
-   CORBA::Long get( Config::access const & Acc )
-   {
-      aObject ORsp;
-      nodeGetValue( Acc, ORsp );
-      if( ORsp.getTag() == OBJ_MAP )
-      {
-         return getNumFromVal( ORsp.mapObject(), 1 );
-      }
-      else
-      {
-         writeTrace( MajorWarning_HERE, SCN "get exception" );
-         throw Config::Node::notFound();
-         return 0;
-      }
-   }
-
-   /**
-    *
-    * Increment and get the incremented configuration value
-    *
-   **/
-   CORBA::Long incrementGet( Config::access const & Acc, CORBA::Long Diff )
-   {
-      writeTrace( SecondaryRuntime_HERE, SCN "incrementGet: %d", Diff );
-      throw Config::Node::notFound();
-   }
-
-   /**
-    *
-    * Set a configuration value
-    *
-   **/
-   void set( Config::access const & Acc, CORBA::Long Number )
-   {
-      writeTrace( SecondaryRuntime_HERE, SCN "set: %d", Number );
-      aMap Val;
-      setNumToVal( Val, CFGKEY_ONEVALUE, Number );
-      Val.set( LIST_COUNT, 1 );
-      if( nodeSetValue( Acc, Val ) )
-      {
-         writeTrace( MajorWarning_HERE, SCN "set exception" );
-         throw Config::Node::notFound();
-      }
-      if( nodeCommit() )
-      {
-         writeTrace( MajorWarning_HERE, SCN "set commit exception" );
-         throw Config::Node::notFound();
-      }
-   }
-
-   /**
-    *
-    * Set an initial configuration value
-    *
-   **/
-   void setInitial( Config::access const & Acc, CORBA::Long Number )
-   {
-      writeTrace( SecondaryRuntime_HERE, SCN "setInitial: %d", Number );
-      aMap Val;
-      setNumToVal( Val, CFGKEY_ONEVALUE, Number );
-      Val.set( LIST_COUNT, 1 );
-      if( nodeSetInitial( Acc, Val ) )
-      {
-         writeTrace( MajorWarning_HERE, SCN "setInitial exception" );
-         throw Config::Node::wrongParam();
-      }
-      if( nodeCommit() )
-      {
-         writeTrace( MajorWarning_HERE, SCN "setInitial commit exception" );
-         throw Config::Node::wrongParam();
-      }
-   }
-
-};
-
-
-
-/**
- **************************************************************************
- *
- * Selection configuration service implementation class
- *
- **************************************************************************
-**/
-class serviceCfgSelection :
-   public POA_Config::Selection,
-   public serviceCfgNode
-{
-
-   /**
-    *
-    * Add a configuration change listener
-    *
-   **/
-   void addChangeListener
-   (
-      Config::access const & Acc,
-      Config::changeListener * L
-   )
-   {
-      writeTrace
-              (
-                 BasicRuntime_HERE,
-                 SCS "addChangeListener"
-              );
-      serviceCfgNode::addChangeListener( Acc, L );
-   }
-
-   /**
-    *
-    * Remove a configuration change listener
-    *
-   **/
-   void removeChangeListener( Config::changeListener * L )
-   {
-      writeTrace
-              (
-                 BasicRuntime_HERE,
-                 SCS "removeChangeListener"
-              );
-      serviceCfgNode::removeChangeListener( L );
-   }
-
-   /**
-    *
-    * Remove a configuration change listener
-    *
-   **/
-   void removeChangeListenerItem
-        (
-           Config::changeListener * L,
-           char const * I
-        )
-   {
-      writeTrace
-              (
-                 BasicRuntime_HERE,
-                 SCS "removeChangeListenerItem"
-              );
-      serviceCfgNode::removeChangeListenerItem( L, I );
-   }
-
-   /**
-    *
-    * Get configuration access rights.
-    *
-   **/
-   char * getRights( Config::access const & Acc )
-   {
-      writeTrace
-      (
-         SecondaryRuntime_HERE, SCS "getRights(%s)",
-         Acc.Item
-      );
-      return CORBA::string_dup( "???" );
-   }
-
-   /**
-    *
-    * Set configuration access rights
-    *
-   **/
-   void setRights( Config::access const & Acc, char const * Rights )
-   {
-      writeTrace
-      (
-         SecondaryRuntime_HERE, SCS "setRights(%s) = [%s]",
-         Acc.Item, Rights
-      );
-   }
-
-   /**
-    *
-    * Create a configuration item
-    *
-   **/
-   void create
-        (
-           Config::access const &                Acc,
-           Config::description const &           Desc,
-           CORBA::Long                           Def,
-           Config::Selection::selectList const & Range
-        )
-   {
-      writeTrace
-              (
-                 BasicRuntime_HERE,
-                 SCS "create rights:%s explanation:%s default=%d",
-                 Desc.Rights, Desc.Explanation, Def
-              );
-      // The range list
-      long RanNumber = 0;
-      aMap RanStr, RanInt, RanRmk;
-      long RanLen = Range.length();
-      while( RanNumber < RanLen )
-      {
-         setNumToVal( RanInt, RanNumber + 1, Range[RanNumber].selLong );
-         RanStr.set( RanNumber + 1, Range[RanNumber].selString.in() );
-         RanRmk.set( RanNumber + 1, Range[RanNumber].selExplanation.in() );
-         ++RanNumber;
-      }
-      RanInt.set( LIST_COUNT, RanNumber );
-      RanStr.set( LIST_COUNT, RanNumber );
-      RanRmk.set( LIST_COUNT, RanNumber );
-      // The value list
-      aMap Val;
-      Val.set( 1, ranValFromNdx( Def, RanInt, RanStr ) );
-      Val.set( LIST_COUNT, 1 );
-      // Build request
-      aMap Request;
-      Request.set( KEY_DEFAULT, Val );
-      Request.set( KEY_TYPE, CFGTYPE_TOGGLE );
-      Request.set( KEY_VALUE, Val );
-      Request.set( KEY_RANGEINTEGER, RanInt );
-      Request.set( KEY_RANGE, RanStr );
-      Request.set( KEY_RANGECOMMENT, RanRmk );
-      nodeCreate( Request, Acc, Desc );
-   }
-
-   /**
-    *
-    * Get a configuration value
-    *
-   **/
-   CORBA::Long get( Config::access const & Acc )
-   {
-      aMap Request, Response;
-      Request.set( KEY_CMDID, GET_ITEM );
-      int RC = nodeRequest( Acc, Request, Response );
-      if( RC == 0 )
-      {
-         //
-         // Get the (string) value, always index 1.
-         //
-         aObject ORspVal = Response.get( KEY_VALUE ).mapObject().get( 1 );
-         char const * CurVal = ORspVal.strObject();
-         if( CurVal )
-         {
-            //
-            // Value found - look for the string in the range
-            // (beginning with key 1).
-            //
-            aMap RanLst = Response.get( KEY_RANGE ).mapObject();
-            int I = 1;
-            char const * RanVal = RanLst.get( I ).strObject();
-            while( RanVal )
-            {
-               if( !strcmp( RanVal, CurVal ) )
-               {
-                  aObject NdxLstObj
-                     = Response.get( KEY_RANGEINTEGER );
-                  if( NdxLstObj.getTag() == OBJ_MAP )
-                  {
-                     writeTrace( SecondaryRuntime_HERE,
-                                 SCS "get (IndexMap)" );
-                     return getNumFromVal( NdxLstObj.mapObject(), I );
-                  }
-                  else
-                  {
-                     writeTrace( SecondaryRuntime_HERE,
-                                 SCS "get (RangeMap)" );
-                     return I - 1;
-                  }
-               }
-               ++I;
-               RanVal = RanLst.get( I ).strObject();
-            }
-         }
-      }
-      writeTrace( MajorWarning_HERE, SCS "get exception" );
-      throw Config::Node::notFound();
-      return 0;
-   }
-
-   /**
-    *
-    * Get a configuration value string.
-    *
-   **/
-   char * getString( Config::access const & Acc )
-   {
-      writeTrace( MajorWarning_HERE, SCS "getString exception" );
-      throw Config::Node::notFound();
-      return CORBA::string_dup( "" );
-   }
-
-   /**
-    *
-    * Set a configuration value
-    *
-   **/
-   void set( Config::access const & Acc, CORBA::Long NdxVal )
-   {
-      writeTrace( SecondaryRuntime_HERE, SCS "set: %d ...", NdxVal );
-      aMap Request, Response;
-      Request.set( KEY_CMDID, GET_ITEM );
-      int RC = nodeRequest( Acc, Request, Response );
-      if( RC == 0 )
-      {
-         //
-         // Look for the index in the range
-         // (beginning with key 1).
-         //
-         aObject      NdxLstObj = Response.get( KEY_RANGEINTEGER );
-         aMap         RanLst = Response.get( KEY_RANGE ).mapObject();
-         char const * RanVal;
-         if( NdxLstObj.getTag() == OBJ_MAP )
-         {
-            //
-            // We have a separate index map
-            //
-            RanVal = ranValFromNdx
-                     (
-                        NdxVal,
-                        NdxLstObj.mapObject(),
-                        RanLst
-                     );
-            writeTrace( SecondaryRuntime_HERE,
-                        SCS "set (IndexMap): Val=%s ...", RanVal );
-         }
-         else
-         {
-            //
-            // Take the value from the range map directly
-            // (compatibility mode). Here the index starts from 1.
-            RanVal = RanLst.get( NdxVal + 1 ).strObject();
-            writeTrace( SecondaryRuntime_HERE,
-                        SCS "set (RangeMap): Val=%s ...", RanVal );
-         }
-
-         if( !RanVal )
-         {
-            writeTrace( MajorWarning_HERE,
-                        SCS "set range exception" );
-            throw Config::Node::outOfRange();
-         }
-         aMap Val;
-         Val.set( 1, RanVal );
-         Val.set( LIST_COUNT, 1 );
-         if( nodeSetValue( Acc, Val ) )
-         {
-            writeTrace( MajorWarning_HERE, SCS "set exception" );
-            throw Config::Node::notFound();
-         }
-         if( nodeCommit() )
-         {
-            writeTrace( MajorWarning_HERE, SCS "set commit exception" );
-            throw Config::Node::notFound();
-         }
-         writeTrace( SecondaryRuntime_HERE, SCS "set." );
-         return;
-      }
-      writeTrace( MajorWarning_HERE, SCS "get exception" );
-      throw Config::Node::notFound();
-   }
-
-   /**
-    *
-    * Set a configuration value string
-    *
-   **/
-   void setString( Config::access const & Acc, char const * StrVal )
-   {
-      writeTrace( MajorWarning_HERE, SCS "setString exception" );
-      throw Config::Node::notFound();
-   }
-
-   /**
-    *
-    * Set an initial configuration value
-    *
-   **/
-   void setInitialString( Config::access const & Acc, char const * Value )
-   {
-      writeTrace( SecondaryRuntime_HERE, SCS "setInitialString: %s", Value );
-      aMap Val;
-      Val.set( 1, Value );
-      Val.set( LIST_COUNT, 1 );
-      if( nodeSetInitial( Acc, Val ) )
-      {
-         writeTrace( MajorWarning_HERE, SCS "setInitialString exception" );
-         throw Config::Node::wrongParam();
-      }
-      if( nodeCommit() )
-      {
-         writeTrace( MajorWarning_HERE, SCS "setInitialString commit exception" );
-         throw Config::Node::wrongParam();
-      }
-   }
-
-};
-
-
-#ifdef USE_DIRECTORY
-
-/**
- **************************************************************************
- *
- * Configuration directory service implementation class
- *
- **************************************************************************
-**/
-class serviceCfgDirectory :
-   public POA_Config::Directory,
-   public serviceCfgNode
-{
-
-   /**
-    *
-    * Add a configuration change listener
-    *
-   **/
-   void addChangeListener
-   (
-      Config::access const & Acc,
-      Config::changeListener * L
-   )
-   {
-      writeTrace
-              (
-                 BasicRuntime_HERE,
-                 SCD "addChangeListener"
-              );
-      serviceCfgNode::addChangeListener( Acc, L );
-   }
-
-   /**
-    *
-    * Remove a configuration change listener
-    *
-   **/
-   void removeChangeListener( Config::changeListener * L )
-   {
-      writeTrace
-              (
-                 BasicRuntime_HERE,
-                 SCD "removeChangeListener"
-              );
-      serviceCfgNode::removeChangeListener( L );
-   }
-
-   /**
-    *
-    * Remove a configuration change listener
-    *
-   **/
-   void removeChangeListenerItem
-        (
-           Config::changeListener * L,
-           char const * I
-        )
-   {
-      writeTrace
-              (
-                 BasicRuntime_HERE,
-                 SCD "removeChangeListenerItem"
-              );
-      serviceCfgNode::removeChangeListenerItem( L, I );
-   }
-
-   /**
-    *
-    * Get configuration access rights.
-    *
-   **/
-   char * getRights( Config::access const & Acc )
-   {
-      writeTrace
-      (
-         SecondaryRuntime_HERE, SCD "getRights(%s)",
-         Acc.Item
-      );
-      return CORBA::string_dup( "???" );
-   }
-
-   /**
-    *
-    * Set configuration access rights
-    *
-   **/
-   void setRights( Config::access const & Acc, char const * Rights )
-   {
-      writeTrace
-      (
-         SecondaryRuntime_HERE, SCD "setRights(%s) = [%s]",
-         Acc.Item, Rights
-      );
-   }
-
-   /**
-    *
-    * Get the directory specified.
-    *
-   **/
-   Config::Directory::dir * get( Config::access const & Acc )
-   {
-      writeTrace( MajorWarning_HERE, SCD "get ..." );
-      Config::Directory::dir * pRet = 0;
-      aMap MReq, MRsp;
-      MReq.set( KEY_CMDID, GET_DIRECTORY );
-      int RC = nodeRequest( Acc, MReq, MRsp );
-      if( RC )
-      {
-         writeTrace( MajorWarning_HERE, SCD "get - notFound exception" );
-         throw Config::Node::notFound();
-      }
-      aMap IDescList = MRsp.get( KEY_DEFAULT ).mapObject();
-      aMap INameList = MRsp.get( KEY_ITEMNAME ).mapObject();
-      aMap IValuList = MRsp.get( KEY_VALUE ).mapObject();
-      int Number = 1;
-      bool More = true;
-      char const * Str = INameList.get( Number ).strObject();
-      if( Str )
-      {
-         writeTrace( MajorWarning_HERE, SCD "get - found directory" );
-         // Calc number of items in the directory
-         while( Str )
-         {
-            ++Number;
-            Str = INameList.get( Number ).strObject();
-         }
-         pRet = new Config::Directory::dir;
-         pRet->length( Number - 1 );
-         for( int Ndx = 1; Ndx < Number; ++Ndx )
-         {
-            char const * SStr = INameList.get( Ndx ).strObject();
-            writeTrace( SecondaryRuntime_HERE, SCD "put %s", SStr );
-            Config::Directory::item * pItem = &(*pRet)[Ndx - 1];
-            pItem->Name = CORBA::string_dup( SStr );
-            aMap IDesc = IDescList.get( Ndx ).mapObject();
-            aMap IValu = IValuList.get( Ndx ).mapObject();
-            if( IDesc.getTag() == OBJ_MAP )
-            {
-               char const * IType = IDesc.get( DB_Descr_Type ).mapObject()
-                                         .get( 1 ).strObject();
-               if( IType )
-               {
-                  switch( IType[0] - '0' )
-                  {
-                  case CFGTYPE_STRING:
-                  case CFGTYPE_TEXT:
-                     pItem->Type = Config::Directory::CFG_TEXT;
-                     pItem->Value.textValue
-                     (
-                        CORBA::string_dup( validStringMap1( IValu ) )
-                     );
-                     break;
-                  case CFGTYPE_INTEGER:
-                     pItem->Type = Config::Directory::CFG_NUMBER;
-                     pItem->Value.numberValue
-                     (
-                        atoi( validStringMap1( IValu ) )
-                     );
-                     break;
-                  case CFGTYPE_TOGGLE:
-                     pItem->Type = Config::Directory::CFG_SELECTION;
-                     {
-                        char const * pszVal = IValu.get( 1 ).strObject();
-                        if( !pszVal )
-                        {
-                           writeTrace
-                           (
-                              MajorWarning_HERE,
-                              SCD "get - value notFound exception"
-                           );
-                           throw Config::Node::notFound();
-                        }
-                        aMap MRange = IDesc.get( DB_Descr_Range )
-                                           .mapObject();
-                        aMap MRaInt = IDesc.get( DB_Descr_RangeInteger )
-                                           .mapObject();
-                        aMap MRaCom = IDesc.get( DB_Descr_RangeComment )
-                                           .mapObject();
-                        // Build Sel.List (and set Sel_Curr)
-                        long Sel_Curr = -1;
-                        Config::Selection::selectList Sel_List;
-                        Sel_List.length( MRange.get( LIST_COUNT )
-                                               .numObject() );
-                        long Idx = 0;
-                        char const * SStr = MRange.get( Idx + 1 )
-                                                  .strObject();
-                        while( SStr )
-                        {
-                           char const * Tmp = MRaInt.get( Idx + 1 ).strObject();
-                           if( Tmp )
-                           {
-                              long XVal = atol( Tmp );
-                              Sel_List[Idx].selLong = XVal;
-                              if( !strcmp( SStr, pszVal ) )
-                              {
-                                 Sel_Curr = XVal;
-                              }
-                           }
-                           else
-                           {
-                              Sel_List[Idx].selLong = Idx;
-                              if( !strcmp( SStr, pszVal ) )
-                              {
-                                 Sel_Curr = Idx;
-                              }
-                           }
-                           Sel_List[Idx].selString
-                              = CORBA::string_dup( SStr );
-                           Sel_List[Idx].selExplanation
-                              = CORBA::string_dup
-                                (
-                                   MRaCom.get( Idx + 1 ).strObject()
-                                );
-                           ++Idx;
-                           SStr = MRange.get( Idx + 1 ).strObject();
-                        }
-                        // Build Sel
-                        Config::Directory::selectionData Sel;
-                        Sel.CurrentIndex = Sel_Curr;
-                        Sel.List = Sel_List;
-                        // Set the value
-                        pItem->Value.selectionValue( Sel );
-                     }
-                     break;
-
-                  case CFGTYPE_STRING_LIST:
-                     pItem->Type = Config::Directory::CFG_TEXTLIST;
-                     pItem->Value.textlistValue
-                     (
-                        *mapToStrings( IValu )
-                     );
-                     break;
-                  }
-               }
-               else
-               {
-                  pItem->Type = Config::Directory::CFG_DIR;
-                  pItem->Value.nullValue( 0 );
-               }
-               pItem->Desc.Explanation
-                  = CORBA::string_dup
-                    (
-                       validStringMapKey1( IDesc, DB_Descr_LongDescription )
-                    );
-
-               pItem->Desc.Rights
-                  = CORBA::string_dup
-                    (
-                       validStringMapKey1( IDesc, DB_Descr_AccessL )
-                    );
-            }
-         }
-      }
-      else
-      {
-         writeTrace( MajorWarning_HERE, SCD "get - not a directory" );
-         throw Config::Node::notFound();
-      }
-      writeTrace( SecondaryRuntime_HERE, SCD "get." );
-      return pRet;
-
-   }
-
-   /**
-    *
-    * Erase an item.
-    *
-   **/
-   void erase( Config::access const & Acc )
-   {
-      writeTrace( MajorWarning_HERE, SCD "erase - not found" );
-      throw Config::Node::notFound();
-   }
-
-};
-
-#endif
-
-
-
-/**
- *
- * A configuration change indication
- *
-**/
-int servIndication( const aMap & Indication )
-{
-   int IndicIndex = 1;
-   aObject Indic = Indication.get( IndicIndex );
-   while( Indic.getTag() == OBJ_MAP )
-   {
-      writeTrace( SecondaryRuntime_HERE, "servIndication X" );
-      aMap IndicM = Indic.mapObject();
-      std::string IndicItem( "" );
-      char const * pStr = IndicM.get( KEY_SECNAME ).strObject();
-      if( pStr )
-         IndicItem += pStr;
-      IndicItem += ".";
-      pStr = IndicM.get( KEY_SUBSECNAME ).strObject();
-      if( pStr )
-         IndicItem += pStr;
-      IndicItem += ".";
-      pStr = IndicM.get( KEY_ITEMNAME ).strObject();
-      if( pStr )
-         IndicItem += pStr;
-      nodeChange( IndicItem.c_str() );
-      Indic = Indication.get( ++IndicIndex );
-   }
-   return 0;
-}
-
-
-
-namespace
-{
-
-   /**
-    *
-    * CORBA communication object for text configuration items.
-    *
-   **/
-   serviceCfgText *                     pLC_Text = 0;
-   corbaServant<serviceCfgText> *       pLD_Text = 0;
-
-   /**
-    *
-    * CORBA communication object for textlist configuration items.
-    *
-   **/
-   serviceCfgTextlist *                 pLC_Textlist = 0;
-   corbaServant<serviceCfgTextlist> *   pLD_Textlist = 0;
-
-   /**
-    *
-    * CORBA communication object for number configuration items.
-    *
-   **/
-   serviceCfgNumber *                   pLC_Number = 0;
-   corbaServant<serviceCfgNumber> *     pLD_Number = 0;
-
-   /**
-    *
-    * CORBA communication object for selection configuration items.
-    *
-   **/
-   serviceCfgSelection *                pLC_Selection = 0;
-   corbaServant<serviceCfgSelection> *  pLD_Selection = 0;
-
-#ifdef USE_DIRECTORY
-   /**
-    *
-    * CORBA communication object for directory operations.
-    *
-   **/
-   serviceCfgDirectory *                pLC_Directory = 0;
-   corbaServant<serviceCfgDirectory> *  pLD_Directory = 0;
-#endif
-
-}
-
-
-/**
- *
- * Public function (see DBS_Serv.hpp)
- *
-**/
-int servMain( int argc, char ** argv )
-{
-   argScan Arg( argc, argv );
-   if( Arg.help() )
-   {
-      cout << "usage: CfgMgr [-trace]"
-           << endl;
-      return -1;
-   }
-
-   nodeInit();
-
-   pLC_Text =      new serviceCfgText;
-   pLD_Text =      new corbaServant<serviceCfgText>
-                       (
-                          *pLC_Text,
-                          CFGMGR_SRVNAME_TEXT, CFGMGR_PORT
-                       );
-
-   pLC_Textlist =  new serviceCfgTextlist;
-   pLD_Textlist =  new corbaServant<serviceCfgTextlist>
-                       (
-                          *pLC_Textlist,
-                          CFGMGR_SRVNAME_TEXTLIST, CFGMGR_PORT
-                       );
-
-   pLC_Number =    new serviceCfgNumber;
-   pLD_Number =    new corbaServant<serviceCfgNumber>
-                       (
-                          *pLC_Number,
-                          CFGMGR_SRVNAME_NUMBER, CFGMGR_PORT
-                       );
-
-   pLC_Selection = new serviceCfgSelection;
-   pLD_Selection = new corbaServant<serviceCfgSelection>
-                       (
-                         *pLC_Selection,
-                         CFGMGR_SRVNAME_SELECTION, CFGMGR_PORT
-                       );
-
-#ifdef USE_DIRECTORY
-
-   pLC_Directory = new serviceCfgDirectory;
-   pLD_Directory = new corbaServant<serviceCfgDirectory>
-                       (
-                         *pLC_Directory,
-                         CFGMGR_SRVNAME_DIRECTORY, CFGMGR_PORT
-                       );
-#endif
-
-   //
-   // Ready for operation ...
-   //
-   Materna::MSSD::eventSemaphore().wait();
-
-   //
-   // Terminating ...
-   //
-#ifdef USE_DIRECTORY
-   delete pLD_Directory;
-#endif
-   delete pLD_Selection;
-   delete pLD_Number;
-   delete pLD_Textlist;
-   delete pLD_Text;
-   nodeExit();
-   //
-   return 0;
-}
-
-
-
-/**
- *
- * Public function (see DBS_Serv.hpp)
- *
-**/
-int servCleanUp()
-{
-   return 0;
-}
-
-
-
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgr/src/DBS_Sess.cpp b/Massai/cpp/CfgXMgr/src/DBS_Sess.cpp
deleted file mode 100644
index bf7c6c2a..00000000
--- a/Massai/cpp/CfgXMgr/src/DBS_Sess.cpp
+++ /dev/null
@@ -1,458 +0,0 @@
-
-//
-// DBS_SESS.CPP
-//
-
-#define PRIVATE static
-
-
-
-//
-// Exports
-//
-#include "dbs_sess.hpp"
-
-
-
-//
-// Imports
-//
-#include "matThread.hpp"
-#include "mEventsem.hpp"
-#include <iostream.h>
-#include "dbx_comm.hpp"
-#include "dbs_sync.hpp"
-#include "stlist.hpp"
-#include <stdio.h>
-#include <string.h>
-#include <time.h>
-#include "cfgdbi.hpp"
-#include "version.h"
-#include "CfgMgrStrings.h"
-#include "TraceClt.h"
-
-
-
-//
-// PRIVATE data
-//
-PRIVATE Materna::MSSD::eventSemaphore AllocateSema;
-PRIVATE int AllMore = 1;
-PRIVATE int SessionsAllocated = 0;
-PRIVATE int SessionsUsed = 0;
-PRIVATE int LastLinkId = 0;
-PRIVATE char szStartup[20];
-
-
-
-//
-// List of sessions
-//
-class session;
-PRIVATE stList<session *> SessionList;
-
-
-
-//
-// localConfig
-//
-PRIVATE void localConfig( const char * Item, char * Var, int VarSize )
-{
-   aMap Req,Rsp;
-   Req.set( KEY_SUPERSECNAME, DB_Environ_SuperSec );
-   Req.set( KEY_SUBSUPERSECNAME, DB_Environ_SubSuperSec );
-   Req.set( KEY_SECNAME, DB_Environ_Sec_This );
-   Req.set( KEY_SUBSECNAME, DB_Environ_SubSec_This );
-   Req.set( KEY_CMDID, GET_ITEM );
-   Req.set( KEY_ITEMNAME, Item );
-   int RC = syncReq( Req, Rsp );
-   if( RC == 0 )
-   {
-      const char *pS = Rsp.GETLISTENTRY(KEY_VALUE,1);
-      if( pS )
-      {
-         strncpy( Var, pS, VarSize );
-         return;
-      }
-   }
-   Var[0] = 0;
-}
-
-
-
-//
-// setClientstate
-//
-void setClientstate( const char * Client, const char * State )
-{
-   const char DBPattern[] = "CFGDB@";
-   const char *pP = DBPattern;
-   const char *pC = Client;
-   while( *pP )
-   {
-      if( *pC != *pP )
-         return;
-      ++pP;
-      ++pC;
-   }
-   aMap Req, Rsp;
-   Req.set( KEY_CMDID, UPD_ITEM );
-   Req.set( KEY_SUPERSECNAME, DB_Environ_SuperSec );
-   Req.set( KEY_SUBSUPERSECNAME, DB_Environ_SubSuperSec );
-   Req.set( KEY_SECNAME, DB_Environ_Sec_Clients );
-   Req.set( KEY_SUBSECNAME, pC );
-   Req.set( KEY_ITEMNAME, DB_Environ_Itm_ClientLink );
-   Req.set( KEY_VALUE, State );
-   syncReq( Req, Rsp );
-   //
-   // commit update
-   //
-   Req.clr();
-   Req.set( KEY_CMDID, DB_COMMIT );
-   syncReq( Req, Rsp );
-}
-
-
-//
-// session
-//
-// An object of this class exists for every client application linked
-// to the configuration database
-//
-
-void writeTraceSess( long Level, char const * Text )
-{
-   writeTrace( Level, "Thread", 0, "session", Text );
-}
-
-#define DBS_ACTIVE      'A'
-#define DBS_TERMINATING 'T'
-#define DBS_FREE        0
-#define __FUNCTION__    ""
-
-class session : public matThread
-{
-   long              _SessionId;
-   long              _LinkId;
-   long              _Status;
-   long              _NbrReq, _NbrInd;
-   cfgComm *         _Comm;
-   char              _Clientname[COMM_MAX_NAME + 1];
-   char              _Sessionname[COMM_MAX_NAME + 1];
-   char              _HostAddress[16 + 3 + 16];
-   char              _HostName[128];
-
-   void trace( const char * Text )
-   {
-      writeTrace( BasicRuntime_HERE, "%s", Text );
-   }
-
-   void trace( const char * Text, long Num )
-   {
-      writeTrace( BasicRuntime_HERE, "%s%d", Text, Num );
-   }
-
-   void trace( const char * Text, long Num, const char * Txt2 )
-   {
-      writeTrace( BasicRuntime_HERE, "%s%d%s", Text, Num, Txt2 );
-   }
-
-   void trace( const char * Text, const char * Txt2 )
-   {
-      writeTrace( BasicRuntime_HERE, "%s%s", Text, Txt2 );
-   }
-
-   void function()
-   {
-      while( AllMore )
-      {
-         long RC = -1;
-         _Comm = new cfgComm();
-         if( _Comm )
-         {
-            _HostAddress[0] = 0;
-            _HostName[0] = 0;
-            RC = _Comm->open( _HostAddress, _HostName );
-            if (RC == -1)
-            {
-               delete _Comm;
-               _Comm = new cfgComm( 1 );
-               if( _Comm )
-               {
-                  RC = _Comm->open( _HostAddress, _HostName );
-               }
-            }
-         }
-         if( RC )
-         {
-            trace( "Link.open failed" );
-         }
-         else
-         {
-            //- for debug only _Comm->setTrace( &cout );
-            ++SessionsUsed;
-            _NbrReq = _NbrInd = 0;
-            strcpy( _Clientname, "-" );
-            _Status = DBS_ACTIVE;
-            _LinkId = ++LastLinkId;
-            trace( "Link ", _LinkId, " openend" );
-            AllocateSema.post();
-            while( ( _Status == DBS_ACTIVE ) && AllMore )
-            {
-               cfgCommBuffer RxBuffer;
-               RC = _Comm->read( RxBuffer );
-               if( RC )
-               {
-                  trace( "Link read error:", RC );
-                  _Status = DBS_TERMINATING;
-               }
-               else
-               {
-                  switch( RxBuffer.type() )
-                  {
-                  default:
-                     {
-                        static char Tracebuffer[] = "got _ ?";
-                        Tracebuffer[4] = RxBuffer.type();
-                        trace( Tracebuffer );
-                        cfgCommBuffer TxBuffer( COMM_TYPE_ERR_RSP, 1 );
-                        _Comm->write( TxBuffer );
-                     }
-                     break;
-                  case COMM_TYPE_CMD_LOGIN:
-                     {
-                        //
-                        // Clients version
-                        //
-                        const char *pVers = RxBuffer.data().get( DB_LOGIN_Version ).strObject();
-                        if
-                        (
-                           !pVers ||
-                           ( pVers[0] != GET_VERSION()[0] ) ||
-                           ( pVers[1] != GET_VERSION()[1] )
-                        )
-                        {
-                           trace( "got CMD_LOGIN - wrong version" );
-                           _Status = DBS_TERMINATING;
-                        }
-                        else
-                        {
-                           //
-                           // Clients name
-                           //
-                           const char *pName = RxBuffer.data().get( DB_LOGIN_Name ).strObject();
-                           if( pName )
-                              strncpy( _Clientname, pName, COMM_MAX_NAME );
-                           else
-                              strcpy( _Clientname, "?" );
-                           _Clientname[COMM_MAX_NAME] = 0;
-                           //
-                           // Terminal clients address
-                           //
-                           const char *pRA = RxBuffer.data().get( DB_LOGIN_Host ).strObject();
-                           if( pRA )
-                           {
-                              strcat( _HostAddress, " [" );
-                              strncat( _HostAddress, pRA, 16 );
-                              strcat( _HostAddress, "]" );
-                           }
-                           //
-                           // Handle login
-                           //
-                           trace( "got CMD_LOGIN for ", _Clientname );
-                           aMap Loginreply;
-                           Loginreply.set( DB_LOGIN_Session, _Sessionname);
-                           cfgCommBuffer TxBuffer( COMM_TYPE_CMD_RSP, 0, Loginreply );
-                           _Comm->write( TxBuffer );
-                           char Clienttrace[5];
-                           localConfig( "ClientTrace", Clienttrace, sizeof(Clienttrace) );
-                           if( !strcmp( Clienttrace, "ON" ) )
-                           {
-                              cfgCommBuffer TxBuffer( COMM_TYPE_CMD_IND, COMM_CODE_CMD_TRACE_ON );
-                              _Comm->write( TxBuffer );
-                           }
-                        }
-                     }
-                     setClientstate( _Clientname, DB_Value_On );
-                     break;
-                  case COMM_TYPE_CMD_SHUTDOWN:
-                     trace( "got CMD_SHUTDOWN" );
-                     AllMore = 0;
-                     {
-                        cfgCommBuffer TxBuffer( COMM_TYPE_CMD_RSP, 0 );
-                        _Comm->write( TxBuffer );
-                     }
-                     AllocateSema.post();
-                     break;
-                  case COMM_TYPE_CMD_STATUS:
-                     trace( "got CMD_STATUS" );
-                     {
-                        aMap Statusreply;
-                        Statusreply.set( DB_STATE_Version, GET_VERSION() );
-                        Statusreply.set( "Sessions allocated",SessionsAllocated );
-                        Statusreply.set( "Sessions in use",SessionsUsed );
-                        Statusreply.set( DB_STATE_Started, szStartup );
-                        stListCursor<session *> SC( SessionList );
-                        aMap SessListStatus;
-                        while( !SC.eof() )
-                        {
-                           session * X = **SC;
-                           if( X->_Status != DBS_FREE )
-                           {
-                              aMap LinkStatus;
-                              LinkStatus.set( "Client", X->_Clientname );
-                              if( strcmp( X->_HostAddress, "127.0.0.1" ) )
-                              {
-                                 LinkStatus.set( "Host", X->_HostName );
-                                 LinkStatus.set( "Host address", X->_HostAddress );
-                              }
-                              LinkStatus.set( "Requests", X->_NbrReq );
-                              LinkStatus.set( "Indications", X->_NbrInd );
-                              LinkStatus.set( "Session", X->_Sessionname);
-                              SessListStatus.set( X->_LinkId, LinkStatus );
-                           }
-                           ++SC;
-                        }
-                        Statusreply.set( DB_STATE_Sessions, SessListStatus );
-                        cfgCommBuffer TxBuffer( COMM_TYPE_CMD_RSP, 0, Statusreply );
-                        _Comm->write( TxBuffer );
-                     }
-                     break;
-                  case COMM_TYPE_OBJ_REQ:
-                     trace( "got OBJ_REQ ", RxBuffer.code() );
-                     ++_NbrReq;
-                     {
-                        aMap ObjReq, ObjRsp;
-                        long rrc;
-                        ObjReq = RxBuffer.data();
-//-+-                        dumpMap( &_T, ObjReq );
-                        ObjReq.set( KEY_CLIENT_ID, _SessionId );
-                        ObjReq.set( KEY_CLIENT_NAME, _Clientname );
-                        rrc = syncReq( ObjReq , ObjRsp );
-                        trace( "send OBJ_RSP ", rrc );
-//-+-                        dumpMap( &_T, ObjRsp );
-                        cfgCommBuffer TxBuffer( COMM_TYPE_OBJ_RSP, rrc, ObjRsp );
-                        _Comm->write( TxBuffer );
-                     }
-                     break;
-                  }
-               }
-            }
-            _Comm->close();
-            trace( "Link closed" );
-            setClientstate( _Clientname, DB_Value_Off );
-            {
-               aMap ObjReq, ObjRsp;
-               ObjReq.set( KEY_CLIENT_ID, _SessionId );
-               ObjReq.set( KEY_CMDID, CLT_DOWN );
-               syncReq( ObjReq , ObjRsp );
-            }
-            --SessionsUsed;
-            _Status = DBS_FREE;
-         }
-         delete _Comm;
-         _Comm = 0;
-      }
-   }
-
-public:
-
-   session( long Id ) : matThread( writeTraceSess, 200000 )
-   {
-      _SessionId = Id;
-      _Status = DBS_FREE;
-      _NbrReq = _NbrInd = 0;
-      _Comm = 0;
-      _Clientname[0] = 0;
-      sprintf( _Sessionname, "CFGDBS%d", _SessionId );
-//-+-      _T.setContext( 2, _Sessionname );
-//-+-      _T.setRoot( Traceroot );
-      start();
-   }
-
-   void indicate( const aMap & Indication )
-   {
-      if( _Status == DBS_ACTIVE )
-      {
-         if( _Comm )
-         {
-            trace( "send OBJ_IND" );
-//-+-            dumpMap( &_T, Indication );
-            ++_NbrInd;
-            cfgCommBuffer TxBuffer( COMM_TYPE_OBJ_IND, 0, Indication );
-            _Comm->write( TxBuffer );
-         }
-      }
-   }
-
-};
-
-
-
-//
-// Issue indication to all clients
-//
-int sessIndication( const aMap & Indication )
-{
-   stListCursor<session *> C( SessionList );
-   while( !C.eof() )
-   {
-      session * X = **C;
-      X->indicate( Indication );
-      ++C;
-   }
-   return 0;
-}
-
-
-//
-// sessMain()
-//
-extern long DebugTcpComm;
-int sessMain()
-{
-   // DebugTcpComm = 1;
-   time_t Time;
-   time( &Time );
-   strncpy( szStartup, ctime( &Time ), sizeof( szStartup ) - 1 );
-   while( AllMore )
-   {
-      AllocateSema.reset();
-      if( SessionsAllocated == SessionsUsed )
-      {
-         //
-         // Allocate a new session
-         //
-         session * pSession = new session( SessionsAllocated );
-         if( pSession )
-         {
-            SessionList.append( pSession );
-            ++SessionsAllocated;
-         }
-      }
-      AllocateSema.wait();
-   };
-   return 0;
-}
-
-//
-// sessMain()
-//
-int sessCleanUp()  //  ts 13.1.1999 Delete Objects Free Memory for ShutDown
-{
-   session* pSession;
-   stListCursor<session *> SessionCursor(SessionList);
-   SessionCursor.getFirst();
-   while (!SessionCursor.eof())
-   {
-      pSession=*(SessionCursor.getCurrent());
-      if (pSession)
-      {
-         pSession->stop();
-      };
-      SessionCursor.getNext();
-   };
-   return 0;
-};
-
-
diff --git a/Massai/cpp/CfgXMgr/src/DBS_Sync.cpp b/Massai/cpp/CfgXMgr/src/DBS_Sync.cpp
deleted file mode 100644
index 66118540..00000000
--- a/Massai/cpp/CfgXMgr/src/DBS_Sync.cpp
+++ /dev/null
@@ -1,197 +0,0 @@
-/**
- **************************************************************************
- *
- * @file DBS_Sync.cpp
- *
- * Contains synchronizing access to cfgdbi interface.
- *
- * @author JK
- *
- * Copyright (c) 1998-2001 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-
-
-
-#include "dbs_sync.hpp"
-
-#include "cfgdbi.hpp"
-//-+-#include "dbs_mstr.hpp"
-#include "dbs_sess.hpp"
-#include "dbs_serv.hpp"
-//#include "dbx_tool.hpp"
-#include "mMutexSem.hpp"
-#include "matThread.hpp"
-
-#include "writeTrace.hpp"
-
-#include <string.h>
-//#include "AssoCStr.hpp"
-#include "mThreadSave.hpp"
-
-#define INDQ 1
-#if INDQ
-#include "mFmtqueue.hpp"
-static Materna::MSSD::fmtQueue<aMap> indQueue( 10 );
-#endif
-
-
-
-static int Sem = 0;
-static Materna::MSSD::mutexSemaphore P;
-
-
-
-class cfgdbiSync : public cfgdbi
-{
-   long ind( aMap const & Indication )
-   {
-#if INDQ
-      indQueue.write( Indication );
-#else
-      P.request();
-      writeTraceMap( SecondaryRuntime_HERE, "Sync: ind", Indication );
-//-+-      mstrIndication( Indication );
-      sessIndication( Indication );
-      servIndication( Indication );
-      P.release();
-#endif
-      return 0;
-   }
-public:
-   cfgdbiSync( const char * Name )
-   : cfgdbi( Name )
-   {
-   }
-};
-
-
-
-static cfgdbiSync *                  pSync = 0;
-static volatile unsigned char        LocalCI = 0;
-static Materna::MSSD::mutexSemaphore MutexCI;
-
-
-#if INDQ
-
-class indThread : public matThread
-{
-   int _More;
-   void function()
-   {
-      while( _More )
-      {
-         aMap Indication;
-         indQueue.read( Indication );
-         writeTrace( SecondaryRuntime_HERE, "Sync: ind ..." );
-         P.request();
-         writeTraceMap( SecondaryRuntime_HERE, "Sync: ind", Indication );
-//-+-         trcIndication( Indication );
-//-+-         mstrIndication( Indication );
-         sessIndication( Indication );
-         servIndication( Indication );
-         writeTrace( SecondaryRuntime_HERE, "Sync: ind." );
-         P.release();
-      }
-   }
-public:
-   indThread()
-   {
-      _More = 1;
-      start();
-   }
-   ~indThread()
-   {
-      _More = 0;
-   }
-};
-
-static indThread It;
-
-#endif
-
-
-long syncReq( aMap const & IData, aMap & OData)
-{
-   if( !pSync ) return 1;
-//-+-   mstrRequest( IData );
-   unsigned char CI = Materna::MSSD::threadSaveIncrement( MutexCI, LocalCI );
-   writeTrace( SecondaryRuntime_HERE, "syncReq-%02X ...", CI );
-   P.request();
-   writeTrace( SecondaryRuntime_HERE, "syncReq-%02X now", CI );
-   writeTraceMap( SecondaryRuntime_HERE, "syncReq IN", IData );
-   long RC = pSync->req( IData, OData );
-   writeTraceMap( SecondaryRuntime_HERE, "syncReq OUT", OData );
-   switch( RC )
-   {
-   case CFGDB_OK:
-      writeTrace( SecondaryRuntime_HERE, "syncReq-%02X.", CI );
-      break;
-   case CFGDB_ERR:
-      writeTrace( SecondaryRuntime_HERE, "syncReq-%02X - internal error", CI );
-      break;
-   case CFGDB_ERR_CMD:
-      writeTrace( SecondaryRuntime_HERE, "syncReq-%02X - error wrong command", CI );
-      break;
-   case CFGDB_ERR_NOCFG:
-      writeTrace( SecondaryRuntime_HERE, "syncReq-%02X - error no configuration", CI );
-      break;
-   case CFGDB_ERR_NOT_FOUND:
-      writeTrace( SecondaryRuntime_HERE, "syncReq-%02X - error not in configuration", CI );
-      break;
-   case CFGDB_ERR_INVPARAM:
-      writeTrace( SecondaryRuntime_HERE, "syncReq-%02X - error invalid parameter", CI );
-      break;
-   default:
-      writeTrace( SecondaryRuntime_HERE, "syncReq-%02X - error:%d", CI, RC );
-   }
-   P.release();
-   return RC;
-}
-
-
-
-int syncCreate()
-{
-   pSync = new cfgdbiSync( "CFGDB" );
-   if( pSync )
-      return 0;
-   else
-      return 1;
-}
-
-
-
-int syncDelete()
-{
-   if( pSync )
-      delete pSync;
-   return 0;
-};
-
-
-
-void syncDisable()
-{
-   P.request();
-   writeTrace( SecondaryRuntime_HERE, "syncDisable" );
-};
-
-
-
-void syncEnable()
-{
-   writeTrace( SecondaryRuntime_HERE, "syncEnable" );
-   P.release();
-};
-
-
-
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgr/src/NT_EVSEM.cpp b/Massai/cpp/CfgXMgr/src/NT_EVSEM.cpp
deleted file mode 100644
index 080ff1b2..00000000
--- a/Massai/cpp/CfgXMgr/src/NT_EVSEM.cpp
+++ /dev/null
@@ -1,73 +0,0 @@
-// -------------------------------------------------------------------
-//
-// NT_EVSEM.CPP
-//
-// This module contains os dependent api functions
-//
-// Dr. Materna GmbH - JK - 1997
-//
-// -------------------------------------------------------------------
-
-#include "eventsem.hpp"
-
-#include "windows.h"
-
-#define PRIVATE static
-
-PRIVATE int nextid = 0;
-
-eventSemaphore::eventSemaphore()
-{
-   iID = ++nextid;
-   hES = (unsigned long)CreateEvent( 0, TRUE, FALSE, 0 );
-}
-
-eventSemaphore::eventSemaphore(const char* const szName)
-{
-   iID = ++nextid;
-   hES = (unsigned long)CreateEvent( 0, TRUE, FALSE, szName );
-}
-
-eventSemaphore::~eventSemaphore()
-{
-   CloseHandle( (HANDLE)hES );
-}
-
-void eventSemaphore::wait()
-{
-   WaitForSingleObject( (HANDLE)hES, INFINITE );
-}
-
-int eventSemaphore::wait( long milliSeconds )
-{
-   return WaitForSingleObject( (HANDLE)hES, (DWORD)milliSeconds );
-}
-
-int eventSemaphore::check()
-{
-   DWORD dwRc;
-   dwRc = WaitForSingleObject( (HANDLE)hES, 0 );
-   switch(dwRc)
-   {
-   case 0:
-      // posted state
-      return 0;
-   case WAIT_TIMEOUT:
-      // reset state
-      return 1;
-   default:
-      // error?
-      return 2;
-   }
-}
-
-void eventSemaphore::post()
-{
-   SetEvent( (HANDLE)hES );
-}
-
-void eventSemaphore::reset()
-{
-   ResetEvent( (HANDLE)hES );
-}
-
diff --git a/Massai/cpp/CfgXMgr/src/UTILS.CPP b/Massai/cpp/CfgXMgr/src/UTILS.CPP
deleted file mode 100644
index b0f20bfb..00000000
--- a/Massai/cpp/CfgXMgr/src/UTILS.CPP
+++ /dev/null
@@ -1,96 +0,0 @@
-#include <stdio.h>
-#include <string.h>
-
-#include "utils.hpp"
-
-
-int operator<(const stString& p1,const stString& p2)
-{
-  return (strcmp(p1,p2) < 0);
-}
-
-
-aSortedMap::aSortedMap()
-{
-   pList = new stSortableList<stString>;
-   pListC = NULL;
-   pListC = new stListCursor<stString>(*pList);
-}
-
-aSortedMap::aSortedMap(const aMap& map)
-{
-   pList = new stSortableList<stString>;
-   pListC = NULL;
-   pListC = new stListCursor<stString>(*pList);
-   
-   insert(map);
-}
-
-aSortedMap::~aSortedMap()
-{
- delete pListC;
- delete pList;
-}
-
-void aSortedMap::set( const aObject& key, const aObject& val)
-{
-  insert(key);
-  aMap::set(key,val);
-}
-
-const aObject *aSortedMap::getNextKey (const aObject*pItem)
-{
-  static aObject a;
-  stString *pStr;
-
-  if(pItem)
-    pStr = (stString*) pListC->getNext();
-  else
-    pStr = (stString*) pListC->getFirst();   
-    
-  if(pStr)
-  {
-    a=  *pStr;
-    return &a;
-  }
-  else
-    return NULL;  
-}
-  
-
-void aSortedMap::insert(const stString& str)
-{
-  pList->insert(str);
-}
-
-void aSortedMap::insert(const aObject& key)
-{
-  switch(key.getTag())
-  {
-   case OBJ_NUM:
-                {
-                 char buf[20];
-                 sprintf(buf,"%d",key.numObject());
-                 pList->insert(buf);
-                }
-                break;
-                
-   case OBJ_STR:
-                pList->insert(key.strObject());
-                break;
-  }
-}
-
-void aSortedMap::insert(const aMap& map)
-{
-  // get first entry
-  const aObject *pItem = map.getNextKey(NULL);
- 
-  while(pItem)
-  {
-    insert(*pItem);
-    aMap::set(*pItem,map.get(*pItem));
-    pItem = map.getNextKey(pItem);
-  }
-}
-
diff --git a/Massai/cpp/CfgXMgr/src/assoXML.cpp b/Massai/cpp/CfgXMgr/src/assoXML.cpp
deleted file mode 100644
index 691c31bc..00000000
--- a/Massai/cpp/CfgXMgr/src/assoXML.cpp
+++ /dev/null
@@ -1,512 +0,0 @@
-/**
- **************************************************************************
- *
- * @file assoXML.cpp
- *
- * Dumps an aMap object to a std::string in XML format
- * Reconstructs an aMap object from an XML source
- *
- * @author MaK
- *
- * Copyright (c) 2001 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#include <string>
-#include <sstream>
-#include <algorithm>
-#include <iostream>
-using namespace std;
-
-#include "dom\dom.hpp"
-#include "util\platformutils.hpp"
-#include "parsers\domparser.hpp"
-#include "framework\MemBufInputSource.hpp"
-#include "sax\ErrorHandler.hpp"
-#include "sax\SAXParseException.hpp"
-
-#include "assoXML.h"
-#include "stringtab.h"
-#include "chunkedBuffer.h"
-
-/**
- **************************************************************************
- * Replace characters which are illegal in XML data with their escaped 
- * representations.
- *
- * @param s     A std::string containing the input data,
- *              this string will be changed!
- *
-**/
-static void escapeSpecialChars(string& s)
-{
-  string::const_iterator first = s.begin();
-  string::const_iterator last = s.end();
-  string::const_iterator it;
-
-  std::string str;
-  for(it= first; it != last; it++)
-  {
-    switch(*it)
-    {
-      case '&':
-        str.append("&amp;");
-        break;
-      case '<':
-        str.append("&lt;");
-        break;
-      case '>':
-        str.append("&gt;");  // avoid "]]>"
-        break;
-      default:
-        if (*it < ' ')
-        {
-          char buffer[10];
-          sprintf(buffer, "&#x%X;", (unsigned char)*it);
-          str.append(buffer);
-        }
-        else
-          str.append(1, (unsigned char)*it);
-    }
-  }
-  s.assign(str);
-}
-
-/**
- **************************************************************************
- * Extract an attribute value from a DOM_NamedNodeMap object.
- *
- * @param attrs       The Attribute map.
- * @param ssAttribute The Attribute name we are looking for.
- * @param ssValue     A std::string which is filled with the attribute value,
- *                    or erased if the attribute is not found.
- *
-**/
-static void getAttribute(const DOM_NamedNodeMap& attrs, 
-                  const string& ssAttribute, 
-                  string& ssValue)
-{
-  DOM_Node node = attrs.getNamedItem(DOMString(ssAttribute.c_str()));
-  if(node.isNull())
-    ssValue.erase();
-  else
-    ssValue.assign(node.getNodeValue().transcode());
-}
-
-/**
- **************************************************************************
- * Get the aMap tag value from it's text representation
- *
- * @param ssTag       The Tag as text.
- *
- * @return            The tag value.
- *
-**/
-static long getTag(const string& ssTag)
-{
-  if(!ssTag.compare("NUM"))
-    return OBJ_NUM;
-  else if(!ssTag.compare("STR"))
-    return OBJ_STR;
-  else if(!ssTag.compare("MAP"))
-    return OBJ_MAP;
-  return OBJ_NIL;
-}
-
-/**
- **************************************************************************
- * Get the aMap tag value from it's MENTRY_XXX text representation
- *
- * @param ssTag       The Tag as text.
- *
- * @return            The tag value.
- *
-**/
-static long getEntryTag(const string& ssTag)
-{
-  if(!ssTag.compare("MENTRY_NUM"))
-    return OBJ_NUM;
-  else if(!ssTag.compare("MENTRY_STR"))
-    return OBJ_STR;
-  else if(!ssTag.compare("MENTRY_MAP"))
-    return OBJ_MAP;
-  return OBJ_NIL;
-}
-
-/**
- **************************************************************************
- * dump the contents of an aMap object to a strstream in XML format
- *
- * @param lLevel   Curent indention level.
- * @param Map      The map object to be dumped.
- * @param os       A reference to an ostream object to dump the data to.
- * @param ssTab    The String to be used for indention.
- * @param st       A class derived from stringTab, used to 
- *                 translate long IDs to their MACRO representation
- *
-**/
-static void dumpMapXML(long lLevel, 
-                       const aMap& Map, 
-                       chunkedBuffer& buf, 
-                       string ssTab,
-                       const stringTab& st)
-{
-  if(lLevel == 0)
-    buf << "<MAP>" << buf.endl();
-
-  const aObject *pKey = 0;
-  while((pKey = Map.getNextKey(pKey)) != 0)
-  {
-    //
-    // get key name
-    //
-    long lEntryType = Map.get(*pKey).getTag();
-    string ssEntry;
-    switch(lEntryType)
-    {
-    case OBJ_NUM:
-      ssEntry.assign("MENTRY_NUM");
-      break;
-    case OBJ_STR:
-      ssEntry.assign("MENTRY_STR");
-      break;
-    case OBJ_MAP:
-      ssEntry.assign("MENTRY_MAP");
-      break;
-    }
-
-#if 0    
-    //
-    // Write start tag
-    //
-    ostringstream tag;
-    switch(pKey->getTag())
-    {
-    case OBJ_NUM:
-      if(st.isDefined(pKey->numObject()))
-      {
-        tag << "<" << ssEntry << " keyType=\"NUM\" "
-            << "key=\"" << pKey->numObject() << "\" "
-            << "keyName=\"" << st.toString(pKey->numObject()) << "\">";
-      } else
-        tag << "<" << ssEntry << " keyType=\"NUM\" "
-            << "key=\"" << pKey->numObject() << "\">";
-      break;
-    case OBJ_STR:
-      string key(pKey->strObject());
-      escapeSpecialChars(key);
-      tag << "<" << ssEntry << " keyType=\"STR\" "
-          << "key=\"" << key << "\">";
-      break;
-    }
-
-    //
-    // Write indentation
-    //
-    for(int i=0; i< lLevel; i++) buf << ssTab;
-
-    buf << tag.str();
-#else
-    //
-    // Write start tag
-    //
-    std::string tag;
-    switch(pKey->getTag())
-    {
-    case OBJ_NUM:
-      if(st.isDefined(pKey->numObject()))
-      {
-        tag = "<";
-        tag += ssEntry + " keyType=\"NUM\" ";
-        tag += "key=\"";
-
-        char szTmp[16];
-        sprintf(szTmp, "%d", pKey->numObject());
-        tag += szTmp;
-        
-        tag += "\" ";
-        tag += "keyName=\"";
-        tag += st.toString(pKey->numObject());
-        tag += "\">";
-      } else
-      {
-        tag = "<";
-        tag += ssEntry + " keyType=\"NUM\" ";
-        tag += "key=\"";
-
-        char szTmp[16];
-        sprintf(szTmp, "%d", pKey->numObject());
-        tag += szTmp;
-        
-        tag += "\">";
-      }
-      break;
-    case OBJ_STR:
-      string key(pKey->strObject());
-      escapeSpecialChars(key);
-      tag = "<";
-      tag += ssEntry + " keyType=\"STR\" ";
-      tag += "key=\"";
-      tag += key + "\">";
-      break;
-    }
-
-    //
-    // Write indentation
-    //
-    for(int i=0; i< lLevel; i++) buf << ssTab;
-
-    buf << tag;
-#endif
-
-    if(lEntryType == OBJ_MAP)
-      buf << buf.endl();
-
-    //
-    // Write value
-    //
-    switch (lEntryType)
-    {
-    case OBJ_NUM:
-      buf << Map.get(*pKey).numObject();
-      break;
-    case OBJ_STR:
-      {
-        string value(Map.get(*pKey).strObject());
-        escapeSpecialChars(value);
-        buf << value;
-      }
-      break;
-    case OBJ_MAP:
-        dumpMapXML(lLevel+1, Map.get(*pKey).mapObject(), buf, ssTab, st);
-      break;
-    }
-
-    //
-    // Write indentation
-    //
-    if(lEntryType == OBJ_MAP)
-      for(i=0; i< lLevel; i++) buf << ssTab;
-
-    //
-    // Write end tag
-    //
-    buf << "</" << ssEntry << ">" << buf.endl();
-
-    }
-
-  if(lLevel == 0)
-    buf << "</MAP>" << buf.endl();
-}
-
-/**
- **************************************************************************
- * Convert an XML DOM_Node tree into an aMap object.
- *
- * @param node     Curent root node.
- * @param map      The aMap object to be filled.
- *
-**/
-static void document2Map(DOM_Node node, aMap& map)
-{
-  while(!node.isNull())
-  {
-    if(node.getNodeType() == DOM_Node::ELEMENT_NODE)
-    {
-      if(!strcmp(node.getNodeName().transcode(),"MAP"))
-      {
-        document2Map(node.getFirstChild(), map);
-      } else if(!strcmp(node.getNodeName().transcode(),"MENTRY_MAP") ||
-                !strcmp(node.getNodeName().transcode(),"MENTRY_STR") ||
-                !strcmp(node.getNodeName().transcode(),"MENTRY_NUM"))
-      {
-        DOM_NamedNodeMap attrs = node.getAttributes();
-
-        string ssKeyType;
-        getAttribute(attrs, "keyType", ssKeyType);
-        long lKeyTag = getTag(ssKeyType);
-
-        long lValueTag = getEntryTag(node.getNodeName().transcode());
-
-        string ssKey;
-        getAttribute(attrs, "key", ssKey);
-
-        aObject* pKeyObj = 0;
-        switch(lKeyTag)
-        {
-        case OBJ_NUM:
-          pKeyObj = new aObject(atoi(ssKey.c_str()));
-          break;
-
-        case OBJ_STR:
-          pKeyObj = new aObject(ssKey.c_str());
-          break;
-        }
-          
-        switch(lValueTag)
-        {
-        case OBJ_NUM:
-          if(node.getFirstChild().isNull())
-            throw assoXMLException("empty/invalid numeric value");
-          else
-          {
-            string val = node.getFirstChild().getNodeValue().transcode();
-
-            if(val.find_first_not_of("1234567890-") != string::npos)
-              throw assoXMLException("empty/invalid numeric value");
-
-            map.set(*pKeyObj, atoi(val.c_str()));
-          }
-          break;
-
-        case OBJ_STR:
-          if(node.getFirstChild().isNull())
-            map.set(*pKeyObj, "");
-          else
-            map.set(*pKeyObj, node.getFirstChild().getNodeValue().transcode());
-          break;
-
-        case OBJ_MAP:
-          aMap subMap;
-
-          if(!node.getFirstChild().isNull())
-            document2Map(node.getFirstChild(), subMap);
-
-          map.set(*pKeyObj, subMap);
-          break;
-        }
-        if(pKeyObj)
-          delete pKeyObj;
-      }
-    }
-    node = node.getNextSibling();
-  }
-}
-
-/**
- **************************************************************************
- * Convert the contents of an aMap object to a character buffer in XML format
- *
- * @param srcMap     The map object to convert.
- * @param dst        The std::string which is filled with the XML data
- * @param st         A class derived from stringTab, used to 
- *                   translate long IDs to their MACRO representation
- *
-**/
-void mapToXML(const aMap& srcMap, std::string& dst, const stringTab& st)
-{
-  chunkedBuffer o;
-  dumpMapXML(0, srcMap, o, "  ", st);
-  dst.assign(o.str());
-}
-
-class assoErrorHandler : public ErrorHandler
-{
-public:
-  /**
-   **************************************************************************
-   * Receive notification of a warning.
-   */
-  virtual void warning(const SAXParseException &exception)
-  {
-  }
-                 
-  /**
-   **************************************************************************
-   * Receive notification of a recoverable error.
-   */
-  virtual void error (const SAXParseException &exception)
-  {
-  }
-                         
-  /**
-   **************************************************************************
-   * Receive notification of a non-recoverable error.
-   */
-  virtual void fatalError(const SAXParseException &exception)
-  {
-    char szEx[1024];
-    sprintf(szEx, "Exception parsing XML map: Line %d:%d",
-                  exception.getLineNumber(),
-                  exception.getColumnNumber());
-
-    throw assoXMLException(szEx);
-  }
-
-  /**
-   **************************************************************************
-   * Reset internal data
-   */
-  virtual void resetErrors()
-  {
-  }
-};
-
-/**
- **************************************************************************
- * Construct an aMap object from a character buffer in XML format
- *
- * @param src        A std::string containing the XML data.
- * @param dstMap     An aMap object which is filled with the data.
- *
-**/
-void mapFromXML(const string& src, aMap& dstMap) throw(assoXMLException)
-{
-  try 
-  {
-    XMLPlatformUtils::Initialize();
-  }
-  catch (const XMLException& toCatch) 
-  {
-    string ex("Exception initializing Xerces XML platform:\n");
-    ex += (char*)toCatch.getMessage();
-    throw assoXMLException(ex);
-    return;
-  }   
-
-  assoErrorHandler errHandler;
-  DOMParser* parser = new DOMParser();
-  parser->setErrorHandler(&errHandler);
-
-  try 
-  {
-    MemBufInputSource source((XMLByte*)src.c_str(), 
-                             src.length(), 
-                             "");
-    parser->parse(source);
-    DOM_Document document = parser->getDocument();
-    DOM_TreeWalker tree = document.createTreeWalker(document.getDocumentElement(), 0,0,0);              
-
-    document2Map(tree.getCurrentNode(), dstMap);
-  }
-  catch (const XMLException& toCatch) 
-  {
-    string ex("Exception parsing XML map:\n");
-    ex += (char*)toCatch.getMessage();
-    throw assoXMLException(ex);
-  }
-
-  delete parser;
-}
-
-/**
- **************************************************************************
- * Exception constructor - with message text.
- *
- * @param message Information about this exception.
- */
-assoXMLException::assoXMLException(const std::string& message)
-{
-  this->message = message;
-}
-
-/**
- **************************************************************************
- * Get the exception iformation.
- *
- * @return Information about this exception.
- */
-const char* assoXMLException::what() const
-{
-  return message.c_str();
-}
diff --git a/Massai/cpp/CfgXMgr/src/assoXML_static.cpp b/Massai/cpp/CfgXMgr/src/assoXML_static.cpp
deleted file mode 100644
index 3821f019..00000000
--- a/Massai/cpp/CfgXMgr/src/assoXML_static.cpp
+++ /dev/null
@@ -1,461 +0,0 @@
-/**
- **************************************************************************
- *
- * @file assoXML.cpp
- *
- * Dumps an aMap object to a std::string in XML format
- * Reconstructs an aMap object from an XML source
- *
- * @author MaK
- *
- * Copyright (c) 2001 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#include <string>
-#include <sstream>
-#include <algorithm>
-#include <iostream>
-using namespace std;
-
-#include "dom\dom.hpp"
-#include "util\platformutils.hpp"
-#include "parsers\domparser.hpp"
-#include "framework\MemBufInputSource.hpp"
-#include "sax\ErrorHandler.hpp"
-#include "sax\SAXParseException.hpp"
-
-#include "cstrstream.h"
-#include "assoXML.h"
-#include "stringtab.h"
-
-/**
- **************************************************************************
- * Replace characters which are illegal in XML data with their escaped 
- * representations.
- *
- * @param s     A std::string containing the input data,
- *              this string will be changed!
- *
-**/
-static void escapeSpecialChars(string& s)
-{
-  string::const_iterator first = s.begin();
-  string::const_iterator last = s.end();
-  string::const_iterator it;
-  ostringstream tmp;
-
-  for(it= first; it != last; it++)
-  {
-    switch(*it)
-    {
-      case '&':
-        tmp << "&amp;";
-        break;
-      case '<':
-        tmp << "&lt;";
-        break;
-      case '>':
-        tmp << "&gt;";  // avoid "]]>"
-        break;
-      default:
-        if (*it < ' ')
-        {
-          char buffer[10];
-          sprintf(buffer, "&#x%X;", (unsigned char)*it);
-          tmp << buffer;
-        }
-        else
-          tmp << *it;
-    }
-  }
-  s.assign(tmp.str());
-}
-
-/**
- **************************************************************************
- * Extract an attribute value from a DOM_NamedNodeMap object.
- *
- * @param attrs       The Attribute map.
- * @param ssAttribute The Attribute name we are looking for.
- * @param ssValue     A std::string which is filled with the attribute value,
- *                    or erased if the attribute is not found.
- *
-**/
-static void getAttribute(const DOM_NamedNodeMap& attrs, 
-                  const string& ssAttribute, 
-                  string& ssValue)
-{
-  DOM_Node node = attrs.getNamedItem(DOMString(ssAttribute.c_str()));
-  if(node.isNull())
-    ssValue.erase();
-  else
-    ssValue.assign(node.getNodeValue().transcode());
-}
-
-/**
- **************************************************************************
- * Get the aMap tag value from it's text representation
- *
- * @param ssTag       The Tag as text.
- *
- * @return            The tag value.
- *
-**/
-static long getTag(const string& ssTag)
-{
-  if(!ssTag.compare("NUM"))
-    return OBJ_NUM;
-  else if(!ssTag.compare("STR"))
-    return OBJ_STR;
-  else if(!ssTag.compare("MAP"))
-    return OBJ_MAP;
-  return OBJ_NIL;
-}
-
-/**
- **************************************************************************
- * Get the aMap tag value from it's MENTRY_XXX text representation
- *
- * @param ssTag       The Tag as text.
- *
- * @return            The tag value.
- *
-**/
-static long getEntryTag(const string& ssTag)
-{
-  if(!ssTag.compare("MENTRY_NUM"))
-    return OBJ_NUM;
-  else if(!ssTag.compare("MENTRY_STR"))
-    return OBJ_STR;
-  else if(!ssTag.compare("MENTRY_MAP"))
-    return OBJ_MAP;
-  return OBJ_NIL;
-}
-
-/**
- **************************************************************************
- * dump the contents of an aMap object to a strstream in XML format
- *
- * @param lLevel   Curent indention level.
- * @param Map      The map object to be dumped.
- * @param os       A reference to an ostream object to dump the data to.
- * @param ssTab    The String to be used for indention.
- * @param st       A class derived from stringTab, used to 
- *                 translate long IDs to their MACRO representation
- *
-**/
-static void dumpMapXML(long lLevel, 
-                       const aMap& Map, 
-                       ostream& os, 
-                       string ssTab,
-                       const stringTab& st)
-{
-  if(lLevel == 0)
-    os << "<MAP>" << endl;
-
-  const aObject *pKey = 0;
-  while((pKey = Map.getNextKey(pKey)) != 0)
-  {
-    //
-    // get key name
-    //
-    long lEntryType = Map.get(*pKey).getTag();
-    string ssEntry;
-    switch(lEntryType)
-    {
-    case OBJ_NUM:
-      ssEntry.assign("MENTRY_NUM");
-      break;
-    case OBJ_STR:
-      ssEntry.assign("MENTRY_STR");
-      break;
-    case OBJ_MAP:
-      ssEntry.assign("MENTRY_MAP");
-      break;
-    }
-    
-    //
-    // Write start tag
-    //
-    ostringstream tag;
-    switch(pKey->getTag())
-    {
-    case OBJ_NUM:
-      if(st.isDefined(pKey->numObject()))
-      {
-        tag << "<" << ssEntry << " keyType=\"NUM\" "
-            << "key=\"" << pKey->numObject() << "\" "
-            << "keyName=\"" << st.toString(pKey->numObject()) << "\">";
-      } else
-        tag << "<" << ssEntry << " keyType=\"NUM\" "
-            << "key=\"" << pKey->numObject() << "\">";
-      break;
-    case OBJ_STR:
-      string key(pKey->strObject());
-      escapeSpecialChars(key);
-      tag << "<" << ssEntry << " keyType=\"STR\" "
-          << "key=\"" << key << "\">";
-      break;
-    }
-
-    //
-    // Write indentation
-    //
-    for(int i=0; i< lLevel; i++) os << ssTab;
-
-    os << tag.str();
-
-    if(lEntryType == OBJ_MAP)
-      os << endl;
-
-    //
-    // Write value
-    //
-    switch (lEntryType)
-    {
-    case OBJ_NUM:
-      os << Map.get(*pKey).numObject();
-      break;
-    case OBJ_STR:
-      {
-        string value(Map.get(*pKey).strObject());
-        escapeSpecialChars(value);
-        os << value;
-      }
-      break;
-    case OBJ_MAP:
-      dumpMapXML(lLevel+1, Map.get(*pKey).mapObject(), os, ssTab, st);
-      break;
-    }
-
-    //
-    // Write indentation
-    //
-    if(lEntryType == OBJ_MAP)
-      for(i=0; i< lLevel; i++) os << ssTab;
-
-    //
-    // Write end tag
-    //
-    os << "</" << ssEntry << ">" << endl;
-
-  }
-
-  if(lLevel == 0)
-    os << "</MAP>" << endl;
-}
-
-/**
- **************************************************************************
- * Convert an XML DOM_Node tree into an aMap object.
- *
- * @param node     Curent root node.
- * @param map      The aMap object to be filled.
- *
-**/
-static void document2Map(DOM_Node node, aMap& map)
-{
-  while(!node.isNull())
-  {
-    if(node.getNodeType() == DOM_Node::ELEMENT_NODE)
-    {
-      if(!strcmp(node.getNodeName().transcode(),"MAP"))
-      {
-        document2Map(node.getFirstChild(), map);
-      } else if(!strcmp(node.getNodeName().transcode(),"MENTRY_MAP") ||
-                !strcmp(node.getNodeName().transcode(),"MENTRY_STR") ||
-                !strcmp(node.getNodeName().transcode(),"MENTRY_NUM"))
-      {
-        DOM_NamedNodeMap attrs = node.getAttributes();
-
-        string ssKeyType;
-        getAttribute(attrs, "keyType", ssKeyType);
-        long lKeyTag = getTag(ssKeyType);
-
-        long lValueTag = getEntryTag(node.getNodeName().transcode());
-
-        string ssKey;
-        getAttribute(attrs, "key", ssKey);
-
-        aObject* pKeyObj = 0;
-        switch(lKeyTag)
-        {
-        case OBJ_NUM:
-          pKeyObj = new aObject(atoi(ssKey.c_str()));
-          break;
-
-        case OBJ_STR:
-          pKeyObj = new aObject(ssKey.c_str());
-          break;
-        }
-          
-        switch(lValueTag)
-        {
-        case OBJ_NUM:
-          if(node.getFirstChild().isNull())
-            throw assoXMLException("empty/invalid numeric value");
-          else
-          {
-            string val = node.getFirstChild().getNodeValue().transcode();
-
-            if(val.find_first_not_of("1234567890-") != string::npos)
-              throw assoXMLException("empty/invalid numeric value");
-
-            map.set(*pKeyObj, atoi(val.c_str()));
-          }
-          break;
-
-        case OBJ_STR:
-          if(node.getFirstChild().isNull())
-            map.set(*pKeyObj, "");
-          else
-            map.set(*pKeyObj, node.getFirstChild().getNodeValue().transcode());
-          break;
-
-        case OBJ_MAP:
-          aMap subMap;
-
-          if(!node.getFirstChild().isNull())
-            document2Map(node.getFirstChild(), subMap);
-
-          map.set(*pKeyObj, subMap);
-          break;
-        }
-        if(pKeyObj)
-          delete pKeyObj;
-      }
-    }
-    node = node.getNextSibling();
-  }
-}
-
-/**
- **************************************************************************
- * Convert the contents of an aMap object to a character buffer in XML format
- *
- * @param srcMap     The map object to convert.
- * @param dst        The std::string which is filled with the XML data
- * @param st         A class derived from stringTab, used to 
- *                   translate long IDs to their MACRO representation
- *
-**/
-void mapToXML(const aMap& srcMap, std::string& dst, const stringTab& st)
-{
-  static char Buffer[5000000];
-  cstrstream o(Buffer, sizeof(Buffer) );
-  dumpMapXML(0, srcMap, o, "  ", st);
-
-  dst.assign(o);
-}
-
-class assoErrorHandler : public ErrorHandler
-{
-public:
-  /**
-   **************************************************************************
-   * Receive notification of a warning.
-   */
-  virtual void warning(const SAXParseException &exception)
-  {
-  }
-                 
-  /**
-   **************************************************************************
-   * Receive notification of a recoverable error.
-   */
-  virtual void error (const SAXParseException &exception)
-  {
-  }
-                         
-  /**
-   **************************************************************************
-   * Receive notification of a non-recoverable error.
-   */
-  virtual void fatalError(const SAXParseException &exception)
-  {
-    char szEx[1024];
-    sprintf(szEx, "Exception parsing XML map: Line %d:%d",
-                  exception.getLineNumber(),
-                  exception.getColumnNumber());
-
-    throw assoXMLException(szEx);
-  }
-
-  /**
-   **************************************************************************
-   * Reset internal data
-   */
-  virtual void resetErrors()
-  {
-  }
-};
-
-/**
- **************************************************************************
- * Construct an aMap object from a character buffer in XML format
- *
- * @param src        A std::string containing the XML data.
- * @param dstMap     An aMap object which is filled with the data.
- *
-**/
-void mapFromXML(const string& src, aMap& dstMap) throw(assoXMLException)
-{
-  try 
-  {
-    XMLPlatformUtils::Initialize();
-  }
-  catch (const XMLException& toCatch) 
-  {
-    string ex("Exception initializing Xerces XML platform:\n");
-    ex += (char*)toCatch.getMessage();
-    throw assoXMLException(ex);
-    return;
-  }   
-
-  assoErrorHandler errHandler;
-  DOMParser* parser = new DOMParser();
-  parser->setErrorHandler(&errHandler);
-
-  try 
-  {
-    MemBufInputSource source((XMLByte*)src.c_str(), 
-                             src.length(), 
-                             "");
-    parser->parse(source);
-    DOM_Document document = parser->getDocument();
-    DOM_TreeWalker tree = document.createTreeWalker(document.getDocumentElement(), 0,0,0);              
-
-    document2Map(tree.getCurrentNode(), dstMap);
-  }
-  catch (const XMLException& toCatch) 
-  {
-    string ex("Exception parsing XML map:\n");
-    ex += (char*)toCatch.getMessage();
-    throw assoXMLException(ex);
-  }
-
-  delete parser;
-}
-
-/**
- **************************************************************************
- * Exception constructor - with message text.
- *
- * @param message Information about this exception.
- */
-assoXMLException::assoXMLException(const std::string& message)
-{
-  this->message = message;
-}
-
-/**
- **************************************************************************
- * Get the exception iformation.
- *
- * @return Information about this exception.
- */
-const char* assoXMLException::what() const
-{
-  return message.c_str();
-}
diff --git a/Massai/cpp/CfgXMgr/src/cfgdbi.cpp b/Massai/cpp/CfgXMgr/src/cfgdbi.cpp
deleted file mode 100644
index f0c31f30..00000000
--- a/Massai/cpp/CfgXMgr/src/cfgdbi.cpp
+++ /dev/null
@@ -1,273 +0,0 @@
-/**
- **************************************************************************
- * 
- * @file cfgdbi.cpp
- * 
- * Implements cfgdbi class methods.
- * 
- * @author Maz, JK
- * 
- * Copyright (c) 1997-2001 MATERNA Information & Communications
- * 
- **************************************************************************
-**/
-
-#include "cfgdbi.hpp"
-
-#include "cfgbase.h"
-#include "cfgfunc.h"
-#include "matEnv.hpp"
-
-#include <string.h>
-#include <time.h>
-
-#ifdef USE_XML_FILE
-#include "CfgXML.hpp"
-#endif
-
-
-// private Data
-
-static long lRefCnt = 0;
-//static IString szPathname;
-
-
-
-static long fDel = 0;
-
-
-
-enum _REQUESTED_SEC_
-{
-  REQ_SUPERSEC    = 0x0001,
-  REQ_SUBSUPERSEC = 0x0002,
-  REQ_SEC         = 0x0004,
-  REQ_SUBSEC      = 0x0008,
-  REQ_ITEM        = 0x0010
-};
-
-
-
-long checkParam(const aMap& iData)
-{
- long lCheck = 0;
-
- if (iData.GETSTR(KEY_SUPERSECNAME))     lCheck |= REQ_SUPERSEC;
- if (iData.GETSTR(KEY_SUBSUPERSECNAME))  lCheck |= REQ_SUBSUPERSEC;
- if (iData.GETSTR(KEY_SECNAME))          lCheck |= REQ_SEC;
- if (iData.GETSTR(KEY_SUBSECNAME))       lCheck |= REQ_SUBSEC;
- if (iData.GETSTR(KEY_ITEMNAME))         lCheck |= REQ_ITEM;
-
- return lCheck;
-}
-
-
-
-#define MAX_CLIENTNAME 127
-class cfgdbi_
-{
-
-   char      Clientname[MAX_CLIENTNAME + 1];
-
-public:
-
-   char * clientName()
-   {
-     return Clientname;
-   }
-
-   cfgdbi_( const char * Name )
-   {
-      strncpy( Clientname, Name, MAX_CLIENTNAME );
-      Clientname[MAX_CLIENTNAME] = 0;
-   }
-
-};
-
-
-
-cfgdbi::cfgdbi( const char * pszName)
-{
-   Handle = new cfgdbi_( pszName );
-   lRefCnt++;
-   if( !getCfgDB() )
-   {
-#ifdef USE_XML_FILE
-      cfgXML_Read();
-#else
-      cfgFileRead( cfgFileName() );
-#endif      
-   }
-}
-
-
-
-cfgdbi::~cfgdbi()
-{
-   if (Handle)
-      delete Handle;
-   lRefCnt--;
-   if( !lRefCnt )
-   {
-#ifdef USE_XML_FILE
-      cfgXML_Delete();
-#else      
-      freeConfiguration();
-#endif      
-   }
-}
-
-
-
-#define IS_EDITOR  ( (strcmp(Handle->clientName(),"CFGED") == 0) || ( iData.GETSTR(KEY_CLIENT_NAME) && (strcmp(iData.GETSTR(KEY_CLIENT_NAME),"CFGED") == 0) ) )
-#define IS_DELETOR ( (strcmp(Handle->clientName(),"CFGDEL") == 0) || ( iData.GETSTR(KEY_CLIENT_NAME) && (strcmp(iData.GETSTR(KEY_CLIENT_NAME),"CFGDEL") == 0) ) )
-long cfgdbi::req  ( const aMap& iData, aMap& oData)
-{
-   long err = CFGDB_OK;
-   long cmdid = iData.GETNUM(KEY_CMDID);
-  
-   switch(cmdid)
-   {
-   case GET_KIOSKS:
-      err = cfgFunc_Kiosks(iData,oData);
-      break;
-  
-   case GET_SECS:
-      if( (checkParam(iData) == (REQ_SUPERSEC | REQ_SUBSUPERSEC) ) || IS_DELETOR )
-         err = cfgFunc_List(iData,oData);
-      else
-         err = CFGDB_ERR_INVPARAM;
-      break;
-  
-   case GET_SUBSECS:
-      if( checkParam(iData) == (REQ_SUPERSEC | REQ_SUBSUPERSEC | REQ_SEC) )
-         err = cfgFunc_List(iData,oData);
-      else
-         err = CFGDB_ERR_INVPARAM;
-      break;
-  
-   case GET_ITEMS:
-      if( checkParam(iData) == (REQ_SUPERSEC | REQ_SUBSUPERSEC | REQ_SEC | REQ_SUBSEC) )
-         err = cfgFunc_List(iData,oData);
-      else
-      {
-         if( IS_EDITOR )
-            err = cfgFunc_SimilarList(iData,oData);
-         else
-            err = CFGDB_ERR_INVPARAM;
-      }
-      break;
-  
-   case GET_ITEM:
-      if( IS_EDITOR )
-         err = CFGDB_ERR_NOT_FOUND;
-      else
-         err = cfgFunc_OldItem(iData,oData);
- 
-      if( err )
-         err = cfgFunc_Item(iData,oData);
-      break;
-  
-   case GET_VALUE:
-      {
-         aMap otData;
-         err = cfgFunc_OldItem(iData,otData);
-         if( err )
-            err = cfgFunc_Item(iData,otData);
-         if( !err )
-            oData.set(KEY_VALUE,otData.get(KEY_VALUE));
-      }
-      break;
-  
-   case GET_DIRECTORY:
-      err = cfgFunc_Directory(iData,oData);
-      break;
-  
-   case UPD_KIOSK:
-   case UPD_SEC:
-   case UPD_SUBSEC:
-      break;
-  
-   case UPD_ITEM:
-      err = cfgFunc_Update( iData );
-      break;
-  
-   case DEL_KIOSK:
-   case DEL_SEC:    
-   case DEL_SUBSEC:
-   case DEL_ITEM:
-      fDel = 1;
-      err = cfgFunc_Delete( iData );
-      break;
-  
-   case DB_COMMIT:
-      if( getUpdList() || fDel )
-      {
-         std::string Datim;
-         matEnvDateTime( Datim );
-         cfgFunc_ModifyData( iData, Datim.c_str() );
-#ifdef USE_XML_FILE
-         cfgXML_Write();
-#else
-         cfgFileWrite( cfgFileName() );
-#endif      
-         if( getUpdList() )
-         {
-            ind(*getUpdList());
-            clrUpdList();
-         }  
-         fDel = 0;
-      }
-      clrOldList();
-      break;
-  
-   case DB_ROLLBACK:
-      if (getUpdList())
-      {
-         clrUpdList();
-#ifdef USE_XML_FILE
-         cfgXML_Delete();
-         cfgXML_Read();
-#else
-         freeConfiguration();
-         cfgFileRead( cfgFileName() );
-#endif      
-      }
-      clrOldList();
-      break;
-  
-   case DB_STATUS:
-      err = cfgFunc_DBStatus(iData,oData);
-      break;
-  
-   case CLT_REJECT:
-      err = setRejectData(iData,oData,true);
-      break;
-  
-   case CLT_DOWN:
-      err = setRejectData(iData,oData,false);
-      break;
-  
-   case CLT_ACCEPT:
-      err = clrRejectData(iData,oData);
-      break;
-  
-   default:
-      err = CFGDB_ERR_CMD;
-      
-   }
-
-   return err;
-
-}
-
-
-
-/**
- **************************************************************************
- *
- * End of file
- * 
- **************************************************************************
-**/
-
diff --git a/Massai/cpp/CfgXMgr/src/mEventSemW32.cpp b/Massai/cpp/CfgXMgr/src/mEventSemW32.cpp
deleted file mode 100644
index c135eba5..00000000
--- a/Massai/cpp/CfgXMgr/src/mEventSemW32.cpp
+++ /dev/null
@@ -1,167 +0,0 @@
-/**
- **************************************************************************
- * 
- * @file mEventSemW32.cpp
- * 
- * Contains the implementation for the methods defined in mEventSem.hpp
- * for the Win32 platform.
- * 
- * @author JK
- * 
- * Copyright (c) 2002 MATERNA Information & Communications
- * 
- **************************************************************************
-**/
-
-#include "mEventsem.hpp"
-
-#include "windows.h"
-
-
-
-namespace Materna
-{
-   namespace MSSD
-   {
-      
-      class eventSemaphore_Handle
-      {
-         
-         HANDLE M_Hdl;
-         
-      public:
-
-         eventSemaphore_Handle();
-         
-         explicit eventSemaphore_Handle( char const * Name ) :
-            M_Hdl( CreateEvent( 0, TRUE, FALSE, Name ) )
-         {
-         }
-            
-         ~eventSemaphore_Handle()
-         {
-            CloseHandle( M_Hdl );
-            M_Hdl = 0;
-         }
-      
-         HANDLE winH() const
-         {
-            return M_Hdl;
-         }
-         
-      };
-      
-   }
-}
-
-
-
-using namespace Materna::MSSD;
-
-
-
-eventSemaphore::eventSemaphore() :
-   M_Handle( new eventSemaphore_Handle( 0 ) )
-{
-}
-
-
-
-eventSemaphore::eventSemaphore( char const * Name ) :
-   M_Handle( new eventSemaphore_Handle( Name ) )
-{
-}
-
-
-
-eventSemaphore::~eventSemaphore()
-{
-   delete M_Handle;
-}
-
-
-
-void eventSemaphore::wait()
-   throw( eventSemaphore_Exception )
-{
-   eventSemaphore_Handle * H = M_Handle;
-   if( !H )
-      throw eventSemaphore_Exception();
-   DWORD RC = WaitForSingleObject( H->winH(), INFINITE );
-   if( RC != WAIT_OBJECT_0 )
-      throw eventSemaphore_Exception();
-}
-
-
-
-int eventSemaphore::wait( long Time )
-   throw( eventSemaphore_Exception )
-{
-   eventSemaphore_Handle * H = M_Handle;
-   if( !H )
-      throw eventSemaphore_Exception();
-   DWORD RC = WaitForSingleObject( H->winH(), static_cast<DWORD>( Time ) );
-   if( RC == WAIT_OBJECT_0 )
-      return 0;
-   else
-      return static_cast<int>( RC );
-}
-
-
-
-int eventSemaphore::check()
-   throw( eventSemaphore_Exception )
-{
-   eventSemaphore_Handle * H = M_Handle;
-   if( !H )
-      throw eventSemaphore_Exception();
-   DWORD dwRc;
-   dwRc = WaitForSingleObject( H->winH(), 0 );
-   switch(dwRc)
-   {
-   case 0:
-      // posted state
-      return 0;
-   case WAIT_TIMEOUT:
-      // reset state
-      return 1;
-   default:
-      // error?
-      return 2;
-   }
-}
-
-
-
-void eventSemaphore::post()
-   throw( eventSemaphore_Exception )
-{
-   eventSemaphore_Handle * H = M_Handle;
-   if( !H )
-      throw eventSemaphore_Exception();
-   if( SetEvent( H->winH() ) == 0 )
-      throw eventSemaphore_Exception();
-}
-
-
-
-void eventSemaphore::reset()
-   throw( eventSemaphore_Exception )
-{
-   eventSemaphore_Handle * H = M_Handle;
-   if( !H )
-      throw eventSemaphore_Exception();
-   if( ResetEvent( H->winH() ) == 0 )
-      throw eventSemaphore_Exception();
-}
-
-
-
-/**
- **************************************************************************
- * 
- * End of file
- * 
- **************************************************************************
-**/
-
diff --git a/Massai/cpp/CfgXMgr/src/mHRTimerW32.cpp b/Massai/cpp/CfgXMgr/src/mHRTimerW32.cpp
deleted file mode 100644
index 13e5184f..00000000
--- a/Massai/cpp/CfgXMgr/src/mHRTimerW32.cpp
+++ /dev/null
@@ -1,100 +0,0 @@
-/**
- **************************************************************************
- * 
- * @file mHRTimerW32.cpp
- * 
- **************************************************************************
-**/
-
-#include "mHRTimer.h"
-
-#include <windows.h>
-#include <stdio.h>
-
-
-
-struct mHRTimer_
-{
-   LARGE_INTEGER TimeZero;
-   LARGE_INTEGER TimeDiv;
-   unsigned      Precision;
-   char const *  Format;
-};
-
-
-
-mHRTimer_Handle mHRTimer_Create( unsigned Digits )
-{
-   mHRTimer_ * H = new mHRTimer_;
-   QueryPerformanceCounter( &H->TimeZero );
-   QueryPerformanceFrequency( &H->TimeDiv );
-   switch( Digits )
-   {
-   default:
-      H->Precision = 1;
-      H->Format = "%02ld:%02ld:%02ld ";
-      break;
-   case 1:
-      H->Precision = 10;
-      H->Format = "%02ld:%02ld:%02ld.%01ld";
-      break;
-   case 2:
-      H->Precision = 100;
-      H->Format = "%02ld:%02ld:%02ld.%02ld";
-      break;
-   case 3:
-      H->Precision = 1000;
-      H->Format = "%02ld:%02ld:%02ld.%03ld";
-      break;
-   case 4:
-      H->Precision = 10000;
-      H->Format = "%02ld:%02ld:%02ld.%04ld";
-      break;
-   case 5:
-      H->Precision = 100000;
-      H->Format = "%02ld:%02ld:%02ld.%05ld";
-      break;
-   }
-   H->TimeDiv.QuadPart /= H->Precision;
-   return H;
-}
-
-
-
-void mHRTimer_Delete( mHRTimer_Handle Hdl )
-{
-   delete Hdl;
-}
-
-
-
-void mHRTimer_TimestampString( mHRTimer_Handle Hdl, char * Dst )
-{
-   LARGE_INTEGER Count;
-   QueryPerformanceCounter( &Count );
-   LONGLONG TimeOff = Count.QuadPart - Hdl->TimeZero.QuadPart;
-   unsigned long TimeMS = static_cast<unsigned long>
-                          ( TimeOff / Hdl->TimeDiv.QuadPart );
-   unsigned long TimeS = TimeMS / Hdl->Precision;
-   unsigned long TimeM = TimeS / 60;
-   unsigned long TimeH = TimeM / 60;
-   TimeH %= 24;
-   TimeM %= 60;
-   TimeS %= 60;
-   TimeMS %= Hdl->Precision;
-   sprintf
-   (
-      Dst, Hdl->Format,
-      TimeH,TimeM,TimeS,TimeMS
-   );
-}
-
-
-
-/**
- **************************************************************************
- * 
- * End of file
- * 
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgr/src/mMutexSemW32.cpp b/Massai/cpp/CfgXMgr/src/mMutexSemW32.cpp
deleted file mode 100644
index dd04c4c3..00000000
--- a/Massai/cpp/CfgXMgr/src/mMutexSemW32.cpp
+++ /dev/null
@@ -1,130 +0,0 @@
-/**
- **************************************************************************
- *
- * @file mMutexSemW32.cpp
- * 
- * Contains the implementation for the methods defined in mMutexSem.hpp
- * for the Win32 platform.
- * 
- * @author JK
- * 
- * Copyright (c) 2002 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-
-#include "mMutexSem.hpp"
-
-#include "windows.h"
-
-
-
-namespace Materna
-{
-   namespace MSSD
-   {
-      
-      class mutexSemaphore_Handle
-      {
-         
-         HANDLE M_WinH;
-         
-      public:
-         
-         mutexSemaphore_Handle();
-         
-         explicit mutexSemaphore_Handle( char const * Name ) :
-            M_WinH( CreateMutex( 0, 0, Name ) )
-         {
-         }
-         
-         ~mutexSemaphore_Handle()
-         {
-            CloseHandle( M_WinH );
-            M_WinH = 0;
-         }
-
-         HANDLE winH() const
-         {
-            return M_WinH;
-         }
-         
-      };
-      
-   }
-}
-
-
-
-using namespace Materna::MSSD;
-
-
-
-mutexSemaphore::mutexSemaphore() :
-   M_Handle( new mutexSemaphore_Handle( 0 ) )
-{
-}
-
-
-
-mutexSemaphore::mutexSemaphore( char const * Name ) :
-   M_Handle( new mutexSemaphore_Handle( Name ) )
-{
-}
-
-
-
-mutexSemaphore::~mutexSemaphore()
-{
-   delete M_Handle;
-}
-
-
-
-void mutexSemaphore::request()
-   throw( mutexSemaphore_Exception )
-{
-   mutexSemaphore_Handle * H = M_Handle;
-   if( !H )
-      throw mutexSemaphore_Exception();
-   DWORD RC = WaitForSingleObject( H->winH(), INFINITE );
-   if( RC != WAIT_OBJECT_0 )
-      throw mutexSemaphore_Exception();
-}
-
-
-
-int mutexSemaphore::request( long Time )
-   throw( mutexSemaphore_Exception )
-{
-   mutexSemaphore_Handle * H = M_Handle;
-   if( !H )
-      throw mutexSemaphore_Exception();
-   DWORD RC = WaitForSingleObject( H->winH(), static_cast<DWORD>( Time ) );
-   if( RC == WAIT_OBJECT_0 )
-      return 0;
-   else
-      return static_cast<int>( RC );
-}
-
-
-
-void mutexSemaphore::release()
-   throw( mutexSemaphore_Exception )
-{
-   mutexSemaphore_Handle * H = M_Handle;
-   if( !H )
-      throw mutexSemaphore_Exception();
-   if( ReleaseMutex( H->winH() ) == 0 )
-      throw mutexSemaphore_Exception();
-}
-
-
-
-/**
- **************************************************************************
- * 
- * End of file
- * 
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgr/src/mStringFile.cpp b/Massai/cpp/CfgXMgr/src/mStringFile.cpp
deleted file mode 100644
index 404a413b..00000000
--- a/Massai/cpp/CfgXMgr/src/mStringFile.cpp
+++ /dev/null
@@ -1,73 +0,0 @@
-/**
- **************************************************************************
- *
- * @file mStringFile.cpp
- *
- * Copy a standard string to file and vice versa.
- *
- * @author JK
- *
- * Copyright (c) 2004 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-
-
-
-#include "mStringFile.hpp"
-#include <fstream>
-
-
-
-/*
- *
- * Function implementation (see mStringFile.hpp).
- *
- */
-void mStringFromFile
-(
-   std::string &        Dst,
-   std::string const &  Filename
-)
-{
-   Dst.erase();
-   std::ifstream IS( Filename.c_str() );
-   if( IS )
-   {
-      char Buffer[0x10000];
-      while( IS.read( Buffer, sizeof(Buffer) ) )
-         Dst.append
-         (
-            Buffer,
-            static_cast<unsigned>( sizeof(Buffer) )
-         );
-      Dst.append( Buffer, IS.gcount() );
-   }
-}
-
-
-
-/*
- *
- * Function implementation (see mStringFile.hpp).
- *
- */
-void mStringToFile
-(
-   std::string const &  Filename,
-   std::string const &  Src
-)
-{
-   std::ofstream OS( Filename.c_str() );
-   OS << Src << std::flush;
-}
-
-
-
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgr/src/massaiCfg.cpp b/Massai/cpp/CfgXMgr/src/massaiCfg.cpp
deleted file mode 100644
index 6965a196..00000000
--- a/Massai/cpp/CfgXMgr/src/massaiCfg.cpp
+++ /dev/null
@@ -1,405 +0,0 @@
-/**
- **************************************************************************
- *
- * @file massaiCfg.cpp
- *
- * Main module for massaiCfg.exe.
- *
- * @author Juergen Kreierhoff
- *
- * Copyright (c) 2001-2004 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-
-#include "version.h"
-
-//-------------------------------------------------------------------------
-//
-//        01.Feb.2001, JK  First fully operational version, copied from
-//                         cfgdb.exe and modified for massai.
-// ATSA_VER( 01, 10, 00 );
-//
-//        11.Apr.2001, JK  Latest tcpcomm modules incorporated.
-// ATSA_VER( 01, 10, 01 );
-//
-//        30.Apr.2001, JK  Minor bugfixes.
-// ATSA_VER( 01, 10, 02 );
-//
-//        10.Aug.2001, JK  Restrict access for items without a "comment"
-//                         section.
-// ATSA_VER( 01, 10, 03 );
-//
-//        09.Oct.2001, JK  First working version with XML config file.
-// ATSA_VER( 01, 10, 04 );
-//
-//        08.Nov.2001, JK  Use latest .IDL
-// ATSA_VER( 01, 11, 00 );
-//
-//        08.Nov.2001, JK  Use latest (rollback) .IDL
-// ATSA_VER( 01, 11, 01 );
-//
-//        23.Nov.2001, JK  Use latest .IDL
-// ATSA_VER( 01, 11, 02 );
-//
-//        13.Dec.2001, JK  Use latest matDaemon interface
-// ATSA_VER( 01, 11, 03 );
-//
-//        24.Jan.2002, JK  Using massaiCORBA interface
-// ATSA_VER( 01, 11, 04 );
-//
-//        09.May.2002, ts  AUTOSTART option added
-// ATSA_VER( 01, 11, 05 );
-//
-//        16.May.2002, JK  Fixed performance problems with large configs
-// ATSA_VER( 01, 11, 06 );
-//
-//        02.Jul.2002, JK  Traces improved
-// ATSA_VER( 01, 11, 07 );
-//
-//        26.Jul.2002, JK  Memory leak in DBX_Comm.hpp fixed
-//        22.Aug.2002, JK  Selection index with directory-get fixed
-// ATSA_VER( 01, 11, 08 );
-//
-//        10.Oct.2002, JK  - Use "static" 5M file buffer.
-//                         - Create a backupfile when reading config.
-// ATSA_VER( 01, 11, 09 );
-//
-//        27.Mar.2003, JK  Use "chunkedBuffer" for XML conversion.
-// ATSA_VER( 01, 11, 10 );
-//
-//        15.Jul.2003, JK  More traces to fond Michael-Laptop pblms
-// ATSA_VER( 01, 11, 11 );
-//
-//        14.Aug.2003, JK  - Reinstall separate indication thread
-//                         - Cleanup dbs_sync interface
-//                         - first draft for directory::erase
-// ATSA_VER( 01, 11, 11 );
-//
-//        29.Jan.2004, JK  - In case of corrupted configuration try
-//                           the backup file first.
-//                         - Write config file trouble into the event log.
-// ATSA_VER( 01, 11, 12 );
-//
-//        04.Jun.2004, JK  - Support modified cfgmgr.idl
-//                           - improved throw lists
-//                           - Selection::setString()/getString()
-//                           - Directory::rightsSet()
-// ATSA_VER( 01, 11, 20 );
-//
-//        04.Jun.2004, JK  - Fix selection problem with index not
-//                           starting with 0
-//                         - Support modified cfgmgr.idl
-//                           - Replace Directory::rightsSet()
-//                              by Node::setRights()
-//                           - New dummy for Number::incrementGet()
-ATSA_VER( 01, 11, 30 );
-
-
-
-#include "matDaemon.h"
-#include "matEnv.hpp"
-
-#include "matThread.hpp"
-#include "mEventSem.hpp"
-
-#include "CfgBase.h"
-#include "dbs_sync.hpp"
-#include "dbs_serv.hpp"
-#include "dbs_sess.hpp"
-
-#include "writeTrace.hpp"
-#include "mWarning.hpp"
-
-#ifdef USE_XML_FILE
-#include "CfgXML.hpp"
-#endif
-
-#include <fstream>
-
-
-namespace
-{
-
-   Materna::MSSD::eventSemaphore * pStopit;
-
-   int                             fActiveServ = 0;
-
-   int                             fActiveSess = 0;
-
-   void writeTraceSrv( long Level, char const * Text )
-   {
-      writeTrace( Level, "Thread", 0, "servThread", Text );
-   }
-
-   void writeTraceSes( long Level, char const * Text )
-   {
-      writeTrace( Level, "Thread", 0, "sessThread", Text );
-   }
-
-}
-
-
-
-class servThread : public matThread
-{
-   int M_argc;
-   char ** M_argv;
-
-   void function()
-   {
-      fActiveServ = 1;
-      if( servMain( M_argc, M_argv ) )
-      {
-         fActiveServ = 0;
-//         delete pS;
-      }
-   }
-
-public:
-
-   servThread( int argc, char ** argv ) :
-      matThread( writeTraceSrv ),
-      M_argc( argc ),
-      M_argv( argv )
-   {
-      start();
-   }
-
-};
-
-
-
-class sessThread : public matThread
-{
-   void function()
-   {
-      fActiveSess = 1;
-      sessMain();
-   }
-
-public:
-
-   sessThread( int, char ** ) :
-      matThread( writeTraceSes )
-   {
-      start();
-   }
-
-};
-
-
-
-/**
- **************************************************************************
- *
- * Return dependencies.
- *
- **************************************************************************
-**/
-char const * mDaemon_dependencies()
-{
-   // No dependencies
-   return 0;
-}
-
-
-
-/**
- **************************************************************************
- *
- * Return commandline help.
- *
- **************************************************************************
-**/
-char const * mDaemon_help()
-{
-   return "[ -OAnumeric true ]";
-}
-
-
-
-/**
- **************************************************************************
- *
- * Return the service name.
- *
- **************************************************************************
-**/
-char const * mDaemon_name()
-{
-#ifdef USE_XML_FILE
-   return "massaiCfgX";
-#else
-   return "massaiConfig";
-#endif
-}
-
-
-
-/**
- **************************************************************************
- *
- * Run configuration service.
- *
- **************************************************************************
-**/
-int mDaemon_main( int argc, char ** argv )
-{
-
-   if( mDaemon_indInitializing( 5000 ) )
-      return 1;
-
-   pStopit = new Materna::MSSD::eventSemaphore();
-
-   //
-   // Traces
-   //
-#ifdef USE_XML_FILE
-   char const * TraceFile = getenv( "massaiCfgX_Trace_File" );
-#else
-   char const * TraceFile = getenv( "massaiConfig_Trace_File" );
-#endif
-   std::ostream * pTrace = 0;
-   if( TraceFile )
-   {
-      pTrace = new std::ofstream( TraceFile );
-   }
-   if( pTrace )
-   {
-      writeTrace_Init( *pTrace, 9 );
-   }
-   else
-   {
-      writeTrace_Init( std::cout, 0 );
-   }
-
-   //
-   // Setup the configuration file to use
-   //
-   std::string ConfigFile;
-   matEnvBindir( ConfigFile );
-#ifdef USE_XML_FILE
-   ConfigFile += "\\CfgMgr.xml";
-   writeTrace
-   (
-      5, "", 0, "",
-      "Using XML configuration in %s", ConfigFile.c_str()
-   );
-   cfgXML_SetFile( ConfigFile.c_str() );
-   std::string BackupFile( ConfigFile );
-   BackupFile += ".bak";
-   cfgXML_SetFileBackup( BackupFile.c_str() );
-#else
-   ConfigFile += "\\CfgMgr.cfg";
-   writeTrace
-   (
-      5, "", 0, "",
-      "Using configuration in %s", ConfigFile.c_str()
-   );
-   cfgFileName( ConfigFile.c_str() );
-#endif
-
-   syncCreate();
-
-   writeTrace
-   (
-      5, "", 0, "",
-      "Starting server thread ..."
-   );
-   servThread Serv( argc, argv );
-
-   writeTrace
-   (
-      5, "", 0, "",
-      "Starting session thread ..."
-   );
-   sessThread Sess( argc, argv );
-
-   if( mDaemon_indReady( 0 ) )
-   {
-      writeTrace
-      (
-         5, "", 0, "",
-         "Error not ready - exiting"
-      );
-      return 1;
-   }
-
-   if( pStopit )
-   {
-      writeTrace
-      (
-         5, "", 0, "",
-         "Stopint - wait"
-      );
-      pStopit->wait();
-   }
-
-   writeTrace
-   (
-      5, "", 0, "",
-      "Exiting ..."
-   );
-   if( fActiveServ ) servCleanUp();
-   if( fActiveSess ) sessCleanUp();
-   syncDelete();
-   return 0;
-}
-
-
-
-/**
- **************************************************************************
- *
- * Stop servicing - mDaemon_main shall return.
- *
- **************************************************************************
-**/
-void mDaemon_stop()
-{
-   if( pStopit )
-      pStopit->post();
-}
-
-
-
-namespace Materna
-{
-
-   void warningAndContinue( char const * Msg, char const * Detail )
-   {
-      std::string Warning = "WARNING: ";
-      if( Msg )
-      {
-         Warning += " ";
-         Warning += Msg;
-         if( Detail )
-         {
-            Warning += " [";
-            Warning += Detail;
-            Warning += "]";
-         }
-      }
-      else
-      {
-         Warning += " ???";
-      }
-      mDaemon_log( Warning.c_str() );
-      writeTrace
-      (
-         9, "main", 0, "warning", Warning.c_str()
-      );
-   }
-
-}
-
-
-
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgr/src/matDaemonW32.cpp b/Massai/cpp/CfgXMgr/src/matDaemonW32.cpp
deleted file mode 100644
index 119f0cc2..00000000
--- a/Massai/cpp/CfgXMgr/src/matDaemonW32.cpp
+++ /dev/null
@@ -1,554 +0,0 @@
-/**
- **************************************************************************
- *
- * @file matDaemonW32.cpp
- *
- * Windows-32 implementation for functions of matDaemon.h.
- *
- * @author JK
- *
- * Copyright (c) 2001-2002 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-// ts 08.05.2002 AUTOSTART option added
-
-#include "matDaemon.h"
-#include <fstream>
-using namespace std;
-#include "argScan.hpp"
-#include <iostream>
-#include <windows.h>
-
-
-
-namespace
-{
-   /**
-    ***********************************************************************
-    *
-    * Module-private part
-    *
-    ***********************************************************************
-   **/
-
-
-
-   /**
-    *
-    * Use the service name for display name as well.
-    *
-   **/
-   char const * mDaemon_getDisplayname()
-   {
-      return mDaemon_name();
-   }
-
-
-
-   /**
-    *
-    * Are we a console application?
-    *
-   **/
-   bool                    Console = false;
-
-
-
-   /**
-    *
-    * Current state of the service.
-    *
-   **/
-   SERVICE_STATUS          SState;
-
-
-
-   /**
-    *
-    * Handle to the current service state.
-    *
-   **/
-   SERVICE_STATUS_HANDLE   SStateHdl;
-
-
-
-   /**
-    *
-    * Module-private function.
-    *
-   **/
-   int indToSCM
-   (
-      DWORD dwCurrentState,
-      DWORD dwWin32ExitCode,
-      DWORD dwWaitHint
-   )
-   {
-      static DWORD dwCheckPoint = 1;
-      if( !Console )
-      {
-         if( dwCurrentState == SERVICE_START_PENDING )
-             SState.dwControlsAccepted = 0;
-         else
-             SState.dwControlsAccepted = SERVICE_ACCEPT_STOP;
-
-         SState.dwCurrentState = dwCurrentState;
-         SState.dwWin32ExitCode = dwWin32ExitCode;
-         SState.dwWaitHint = dwWaitHint;
-
-         if
-         (
-            ( dwCurrentState == SERVICE_RUNNING ) ||
-            ( dwCurrentState == SERVICE_STOPPED )
-         )
-            SState.dwCheckPoint = 0;
-         else
-            SState.dwCheckPoint = dwCheckPoint++;
-
-         //
-         // Report the status of the service to the service control manager.
-         //
-         if( SetServiceStatus( SStateHdl, &SState ) )
-            return 0;
-         else
-         {
-            mDaemon_log( "SetServiceStatus" );
-            return 1;
-         }
-      }
-      else
-         return 0;
-   }
-
-
-
-   /**
-    *
-    * Module-private function.
-    *
-   **/
-   BOOL WINAPI console_ctrl ( DWORD Type )
-   {
-      switch( Type )
-      {
-      case CTRL_BREAK_EVENT:  // use Ctrl+C or Ctrl+Break to simulate
-      case CTRL_C_EVENT:      // SERVICE_CONTROL_STOP in debug mode
-         mDaemon_stop();
-         return TRUE;
-
-      default:
-         return FALSE;
-      }
-   }
-
-
-
-   /**
-    *
-    * Module-private function.
-    *
-   **/
-   VOID WINAPI service_ctrl(DWORD dwCtrlCode)
-   {
-       // Handle the requested control code.
-       //
-       switch(dwCtrlCode)
-       {
-           // Stop the service.
-           //
-           // SERVICE_STOP_PENDING should be reported before
-           // setting the Stop Event - hServerStopEvent - in
-           // ServiceStop().  This avoids a race condition
-           // which may result in a 1053 - The Service did not respond...
-           // error.
-           case SERVICE_CONTROL_STOP:
-               indToSCM(SERVICE_STOP_PENDING, NO_ERROR, 0);
-               mDaemon_stop();
-               return;
-
-           // Update the service status.
-           //
-           case SERVICE_CONTROL_INTERROGATE:
-               break;
-
-           // invalid control code
-           //
-           default:
-               break;
-
-       }
-
-       indToSCM(SState.dwCurrentState, NO_ERROR, 0);
-   }
-
-
-
-   /**
-    *
-    * Module-private function.
-    *
-   **/
-   char const * lastError()
-   {
-      LPTSTR LocalBuffer = 0;
-      DWORD dwRet =
-         FormatMessage
-         (
-            FORMAT_MESSAGE_ALLOCATE_BUFFER |
-            FORMAT_MESSAGE_FROM_SYSTEM |
-            FORMAT_MESSAGE_ARGUMENT_ARRAY,
-            NULL,
-            GetLastError(),
-            LANG_NEUTRAL,
-            reinterpret_cast<LPTSTR>( &LocalBuffer ),
-            0,
-            NULL
-         );
-      if( LocalBuffer )
-      {
-         static string Return;
-         // supplied buffer is not long enough
-         if( !dwRet )
-            return "";
-         else
-         {
-            Return = " - ";
-            Return += LocalBuffer;
-         }
-         LocalFree( LocalBuffer );
-         return Return.c_str();
-      }
-      else
-         return "";
-   }
-
-
-
-   /**
-    *
-    * Module-private function.
-    *
-   **/
-   // ts 08.05.2002 AUTOSTART option added
-   int install(bool bAutoStart)
-   {
-      TCHAR szPath[512];
-      if( GetModuleFileName( NULL, szPath, 512 ) == 0 )
-      {
-         cout << "Unable to install "
-              << mDaemon_getDisplayname()
-              << lastError()
-              << endl;
-         return 1;
-      }
-
-      SC_HANDLE SCManagerHdl =
-         OpenSCManager
-         (
-            NULL,
-            NULL,
-            SC_MANAGER_ALL_ACCESS
-         );
-      if( SCManagerHdl )
-      {
-         SC_HANDLE ServiceHdl =
-            CreateService
-            (
-               SCManagerHdl,               // SCManager database
-               mDaemon_name(),             // name of service
-               mDaemon_getDisplayname(),   // name to display
-               SERVICE_ALL_ACCESS,         // desired access
-               SERVICE_WIN32_OWN_PROCESS,  // service type
-               // ts 08.05.2002 AUTOSTART option added
-               bAutoStart?SERVICE_AUTO_START:SERVICE_DEMAND_START, // start type
-               SERVICE_ERROR_NORMAL,       // error control type
-               szPath,                     // services binary
-               NULL,                       // no load ordering group
-               NULL,                       // no tag identifier
-               mDaemon_dependencies(),     // no dependencies
-               NULL,                       // LocalSystem account
-               NULL                        // no password
-            );
-         if( ServiceHdl )
-         {
-            cout << mDaemon_getDisplayname() << " installed."
-                 << endl;
-            CloseServiceHandle( ServiceHdl );
-            return 0;
-         }
-         else
-         {
-            cout << "CreateService" << lastError() << endl;
-         }
-         CloseServiceHandle( SCManagerHdl );
-      }
-      else
-         cout << "OpenSCManager" << lastError() << endl;
-      return 1;
-   }
-
-
-
-   /**
-    *
-    * Module-private function.
-    *
-   **/
-   int deinstall()
-   {
-      SC_HANDLE SCManagerHdl =
-         OpenSCManager
-         (
-            NULL,
-            NULL,
-            SC_MANAGER_ALL_ACCESS
-         );
-      if( SCManagerHdl )
-      {
-         SC_HANDLE ServiceHdl =
-            OpenService
-            (
-               SCManagerHdl,
-               mDaemon_name(),
-               SERVICE_ALL_ACCESS
-            );
-         if( ServiceHdl )
-         {
-            // try to stop the service
-            if
-            (
-               ControlService
-               (
-                  ServiceHdl,
-                  SERVICE_CONTROL_STOP,
-                  &SState
-               )
-            )
-            {
-               cout << "Stopping " << mDaemon_getDisplayname() << endl;
-               Sleep( 1000 );
-               bool More = true;
-               while( More && QueryServiceStatus( ServiceHdl, &SState ) )
-               {
-                  if( SState.dwCurrentState == SERVICE_STOP_PENDING )
-                  {
-                     cout << "." << flush;
-                     Sleep( 1000 );
-                  }
-                  else
-                     More = false;
-               }
-               if( SState.dwCurrentState == SERVICE_STOPPED )
-                  cout << mDaemon_getDisplayname() << " stopped." << endl;
-               else
-                  cout << mDaemon_getDisplayname()
-                       << " stop failed."
-                       << endl;
-            }
-            // now remove the service
-            if( DeleteService( ServiceHdl ) )
-               cout << mDaemon_getDisplayname() << " removed." << endl;
-            else
-               cout << "DeleteService" << lastError() << endl;
-            CloseServiceHandle( ServiceHdl );
-         }
-         else
-            cout << "OpenService" << lastError() << endl;
-         CloseServiceHandle( SCManagerHdl );
-      }
-      else
-         cout << "OpenSCManager" << lastError() << endl;
-      return 0;
-   }
-
-
-   /**
-    *
-    * Module-private function.
-    *
-   **/
-   void WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv)
-   {
-
-      //
-      // Register the service control handler
-      //
-      SStateHdl =
-         RegisterServiceCtrlHandler
-         (
-            mDaemon_name(),
-            service_ctrl
-         );
-      if( !SStateHdl )
-         return;
-
-      //
-      // SERVICE_STATUS members that dont change in example
-      //
-      SState.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
-      SState.dwServiceSpecificExitCode = 0;
-
-      //
-      // Report pending status to the service control manager.
-      //
-      if
-      (
-         indToSCM
-         (
-            SERVICE_START_PENDING, // service state
-            NO_ERROR,              // exit code
-            3000                   // wait hint
-         ) == 0
-      )
-      {
-         mDaemon_main( static_cast<int>( dwArgc ), lpszArgv );
-      }
-
-      //
-      // Report stopped status to the service control manager.
-      //
-      indToSCM( SERVICE_STOPPED, NO_ERROR, 0 );
-   }
-
-
-
-   /**
-    ***********************************************************************
-    *
-    * End of module-private part
-    *
-    ***********************************************************************
-   **/
-}
-
-
-
-/**
- *
- * (see mDaemon.h)
- *
-**/
-int mDaemon_indInitializing( unsigned long mSec )
-{
-   return indToSCM( SERVICE_START_PENDING, NO_ERROR, mSec );
-}
-
-
-
-/**
- *
- * (see mDaemon.h)
- *
-**/
-int mDaemon_indReady( unsigned long mSec )
-{
-   return( indToSCM( SERVICE_RUNNING, NO_ERROR, mSec ) );
-}
-
-
-
-/**
- *
- * (see mDaemon.h)
- *
-**/
-void mDaemon_log( char const * Data )
-{
-   if( !Console )
-   {
-      //
-      // Write to event log
-      //
-      HANDLE hEventSource = RegisterEventSource( NULL, mDaemon_name() );
-      if( hEventSource )
-      {
-         LPCTSTR Strings[1];
-         Strings[0] = Data;
-         ReportEvent
-         (
-            hEventSource,         // handle of event source
-            EVENTLOG_ERROR_TYPE,  // event type
-            0,                    // event category
-            0,                    // event ID
-            NULL,                 // current users SID
-            1,                    // strings in lpszStrings
-            0,                    // no bytes of raw data
-            Strings,              // array of error strings
-            0                     // no raw data
-         );
-         DeregisterEventSource(hEventSource);
-      }
-   }
-}
-
-
-
-/**
- **************************************************************************
- *
- * Standard main.
- *
- * @param argc Argument count
- *
- * @param argv Argument vector
- *
- * @return 0 if OK
- *
- **************************************************************************
-**/
-int main( int argc, char ** argv )
-{
-   argScan Arg( argc, argv );
-   if( Arg.help() )
-   {
-      // ts 08.05.2002 AUTOSTART option added
-      cout << "Usage: "
-           << argv[0]
-           << " [ -install [-autostart] | -deinstall | -console ";
-      if( mDaemon_help() )
-      {
-         cout << "<consoleparameter> ]\n"
-              << "       <consoleparameter> = "
-              << mDaemon_help() << endl;
-      }
-      else
-      {
-         cout << "]" << endl;
-      }
-      return 0;
-   }
-
-   if( Arg.option( "INSTALL" ) )
-      return install(Arg.option("AUTOSTART")!=0);// ts 08.05.2002 AUTOSTART option added
-
-   if( Arg.option( "DEINSTALL" ) )
-      return deinstall();
-
-   if( Arg.option( "CONSOLE" ) )
-   {
-      Console = true;
-      SetConsoleCtrlHandler( console_ctrl, true );
-      return mDaemon_main( argc, argv );
-   }
-
-   SERVICE_TABLE_ENTRY STE[2];
-   STE[0].lpServiceName = const_cast<char *>( mDaemon_name() );
-   STE[0].lpServiceProc = service_main;
-   STE[1].lpServiceName = 0;
-   STE[1].lpServiceProc = 0;
-   if( !StartServiceCtrlDispatcher( STE ) )
-      mDaemon_log( "StartServiceCtrlDispatcher failed." );
-   return 0;
-}
-
-
-
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
-
diff --git a/Massai/cpp/CfgXMgr/src/matEnvW32.cpp b/Massai/cpp/CfgXMgr/src/matEnvW32.cpp
deleted file mode 100644
index 1afc07a0..00000000
--- a/Massai/cpp/CfgXMgr/src/matEnvW32.cpp
+++ /dev/null
@@ -1,83 +0,0 @@
-/**
- **************************************************************************
- * 
- * @file matEnvW32.cpp
- *
- * Environment functions.
- * 
- * @author JK
- * 
- * Copyright (c) 2001 MATERNA Information & Communications
- * 
- **************************************************************************
-**/
-
-#include <string>
-#include <windows.h>
-#include <stdio.h>
-
-
-
-/**
- * 
- * See matEnv.hpp
- * 
-**/
-int matEnvBindir( std::string & Dst )
-{
-   static char Path[256];
-   if( !GetModuleFileName( 0, Path, sizeof( Path ) ) )
-   {
-      return 1;
-   }
-   
-   std::string BFile( Path );
-   int Off = BFile.find_last_of( '\\' );
-   int Len = BFile.length();
-   if( Off >= Len )
-   {
-      return 2;
-   }
-   
-   BFile.erase( Off, Len );
-   Dst += BFile;
-   return 0;
-}
-
-
-
-/**
- * 
- * See matEnv.hpp
- * 
-**/
-int matEnvDateTime( std::string & Dst )
-{
-   SYSTEMTIME T;
-   GetLocalTime( &T );
-   char Buffer[31];
-   sprintf
-   (
-      Buffer,
-      "%02d.%02d.%04d %02d:%02d:%02d",
-       T.wDay,
-            T.wMonth,
-                 T.wYear,
-                      T.wHour,
-                           T.wMinute,
-                                T.wSecond
-   );
-   Dst += Buffer;
-   return 0;
-}
-
-
-
-/**
- **************************************************************************
- * 
- * End of file
- * 
- **************************************************************************
-**/
-
diff --git a/Massai/cpp/CfgXMgr/src/matSignalW32.cpp b/Massai/cpp/CfgXMgr/src/matSignalW32.cpp
deleted file mode 100644
index 07d5e41e..00000000
--- a/Massai/cpp/CfgXMgr/src/matSignalW32.cpp
+++ /dev/null
@@ -1,135 +0,0 @@
-//-------------------------------------------------------------------------
-//
-// matSignalW32.cpp
-//
-// Implementation of the signal functions declared in the "matAsync.hpp"
-// interface class header file.
-//
-// Author: JK
-//
-// Copyright (c) 2000 MATERNA Information & Communications
-//
-//-------------------------------------------------------------------------
-
-#include "matSignal.h"
-
-#include "mEventSem.hpp"
-
-#include <signal.h>
-
-
-
-static Materna::MSSD::eventSemaphore TermEvent;
-
-static long                          LastReason;
-
-
-
-extern "C" 
-{
-   
-static void exitHandler( int Sig );
-
-typedef void (* SIGFUN)(int);
-   
-}
-
-
-
-struct matSignalPrivate
-{
-};
-
-
-
-matSignalHdl matSignalCreate()
-{
-   matSignalPrivate * pP = new matSignalPrivate;
-   LastReason = 0;
-   signal( SIGILL,  (SIGFUN)exitHandler );
-   signal( SIGSEGV, (SIGFUN)exitHandler );
-   signal( SIGFPE,  (SIGFUN)exitHandler );
-   signal( SIGTERM, (SIGFUN)exitHandler );
-   signal( SIGABRT, (SIGFUN)exitHandler );
-   signal( SIGINT,  (SIGFUN)exitHandler );
-   signal( SIGBREAK,(SIGFUN)exitHandler );
-   return pP;
-}
-
-
-
-void matSignalDelete( matSignalHdl pP )
-{
-   signal( SIGILL,   SIG_DFL );
-   signal( SIGSEGV,  SIG_DFL );
-   signal( SIGFPE,   SIG_DFL );
-   signal( SIGTERM,  SIG_DFL );
-   signal( SIGABRT,  SIG_DFL );
-   signal( SIGINT,   SIG_DFL );
-   signal( SIGBREAK, SIG_DFL );
-   LastReason = 0;
-   TermEvent.post();
-   delete pP;
-}
-      
-
-
-MATRC matSignalWaitInf( matSignalHdl )
-{
-   TermEvent.wait();
-   return MATRC_OK;
-}
-
-
-
-MATRC matSignalWaitReasonInf( matSignalHdl, long * Reason )
-{
-   TermEvent.wait();
-   if( Reason ) *Reason = LastReason;
-   return MATRC_OK;
-}
-
-
-
-MATRC matSignalWait( matSignalHdl, int MS )
-{
-   if( TermEvent.wait( MS ) )
-      return MATRC_TIMEOUT;
-   else
-      return MATRC_OK;
-}
-
-
-
-MATRC matSignalWaitReason( matSignalHdl, int MS, long * Reason )
-{
-   if( TermEvent.wait( MS ) )
-      return MATRC_TIMEOUT;
-   else
-   {
-      if( Reason ) *Reason = LastReason;
-      return MATRC_OK;
-   }
-}
-
-
-
-extern "C" 
-{
-   
-static void exitHandler( int Sig )
-{
-   LastReason = Sig;
-   TermEvent.post();
-}
-
-}
-
-
-
-//-------------------------------------------------------------------------
-//
-// end of file
-//
-//-------------------------------------------------------------------------
-
diff --git a/Massai/cpp/CfgXMgr/src/matThreadW32.cpp b/Massai/cpp/CfgXMgr/src/matThreadW32.cpp
deleted file mode 100644
index cd55c7b5..00000000
--- a/Massai/cpp/CfgXMgr/src/matThreadW32.cpp
+++ /dev/null
@@ -1,580 +0,0 @@
-/**
- **************************************************************************
- *
- * @file matThreadW32.cpp
- *
- * Implements the functions defined in matThread.hpp for Win32
- * environment.
- *
- * @author JK
- *
- * Copyright (c) 2000 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-
-#include "matThread.hpp"
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <process.h>
-
-#include <windows.h>
-#include <winbase.h>
-
-
-
-#define TRACE_LEVEL_ERROR  1       // Major error
-#define TRACE_LEVEL_NORMAL 7       // Secondary runtime
-
-#define NT_MIN_STACK 65536
-
-
-
-static char * makeChild( char * Buf, char const * Src )
-{
-   sprintf( Buf, "child[%d]: %s", matThreadId(), Src );
-   return Buf;
-}
-
-
-
-static char * makeParent( char * Buf, char const * Src )
-{
-   sprintf( Buf, "parent[%d]: %s", matThreadId(), Src );
-   return Buf;
-}
-
-
-
-static matThreadRC win2rc( DWORD WErr )
-{
-   switch( WErr )
-   {
-   case ERROR_SUCCESS: return THREADRC_OK;
-   case WAIT_TIMEOUT:  return THREADRC_TIMEOUT;
-   default:            return THREADRC_ERROR;
-   }
-}
-
-
-
-/**
- **************************************************************************
- *
- * Handle class
- *
- **************************************************************************
-**/
-class matThread_Handle
-{
-
-   //! CLient trace function
-   matThreadTrace MH_Trace;
-
-   //! Refers the parent thread class
-   matThread *    MH_pPublic;
-
-public:
-
-   //! Win32 thread handle
-   HANDLE         MH_Handle;
-
-   //! Stack allocated for thread
-   long           MH_Stacksize;
-
-   //! Thread status
-   int            MH_Terminated;
-
-   //! Semaphore to control the start sequence
-   HANDLE         MH_StartSema;
-
-   /**
-    *
-    * Trace normal events
-    *
-   **/
-   void        traceNormal( char const * Text )
-               {
-                  if( MH_Trace )
-                  {
-                     char Buffer[256];
-                     MH_Trace( TRACE_LEVEL_NORMAL, makeParent( Buffer, Text ) );
-                  }
-               }
-
-   /**
-    *
-    * Trace error events
-    *
-   **/
-   void        traceError( char const * Text )
-               {
-                  if( MH_Trace )
-                  {
-                     char Buffer[256];
-                     MH_Trace( TRACE_LEVEL_ERROR, makeParent( Buffer, Text ) );
-                  }
-               }
-
-   /**
-    *
-    * Trace Win32 errors
-    *
-   **/
-   matThreadRC traceLastError( char const * Text )
-               {
-                  DWORD LE = GetLastError();
-                  if( MH_Trace )
-                  {
-                     char Buffer[256];
-                     char TBuffer[256];
-                     sprintf( TBuffer, "%s error %d", Text, LE );
-                     MH_Trace( TRACE_LEVEL_ERROR, makeParent( Buffer, TBuffer ) );
-                  }
-                  return win2rc( LE );
-               }
-
-   /**
-    *
-    * Thread function
-    *
-   **/
-   void        function()
-               {
-                  if( MH_Trace )
-                  {
-                     char Buffer[256];
-                     MH_Trace( TRACE_LEVEL_NORMAL, makeChild( Buffer, "call" ) );
-                               MH_pPublic->function();
-                     MH_Trace( TRACE_LEVEL_NORMAL, makeChild( Buffer, "return" ) );
-                  }
-                  else
-                     MH_pPublic->function();
-               }
-
-   /**
-    *
-    * Constructor
-    *
-    * @param IFObject Refers the parent thread class
-    *
-    * @param Stack    The thread stack
-    *
-    * @param Trace    The trace function to use (may be 0)
-    *
-   **/
-   matThread_Handle
-   (
-      matThread *              IFObject,
-      long                     Stack,
-      matThreadTrace           Trace
-    ) :
-      MH_Trace( Trace ),
-      MH_pPublic( IFObject ),
-      MH_Handle( 0 ),
-      MH_Stacksize( ( Stack > NT_MIN_STACK ) ? Stack : NT_MIN_STACK ),
-      MH_Terminated( 1 ),
-      MH_StartSema( CreateEvent( 0, TRUE, FALSE, 0 ) )
-   {
-      if( Trace )
-      {
-         char Buffer[256];
-         Trace( TRACE_LEVEL_NORMAL, makeParent( Buffer, "created" ) );
-      }
-   }
-
-   /**
-    *
-    * Standard constructor - intentionally not implemented.
-    *
-   **/
-   matThread_Handle();
-
-   /**
-    *
-    * Destructor
-    *
-   **/
-   ~matThread_Handle()
-   {
-      if( MH_Trace )
-      {
-         char Buffer[256];
-         MH_Trace( TRACE_LEVEL_NORMAL, makeParent( Buffer, "deleted" ) );
-      }
-   }
-
-};
-
-
-
-/**
- **************************************************************************
- *
- * Controls child thread execution.
- *
- * @param pV "void" pointer to handle class
- *
- **************************************************************************
-**/
-#ifdef __IBMCPP__
-static void _Optlink privateEnterThreadC( void * pV )
-#else
-static void __cdecl privateEnterThreadC( void * pV )
-#endif
-{
-   matThread_Handle *pPara = (matThread_Handle *)pV;
-   SetEvent( pPara->MH_StartSema );
-   pPara->MH_Terminated = 0;
-   pPara->function();
-   pPara->MH_Terminated = 1;
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThread::matThread( long stacksize ) :
-   M_Handle( 0 )
-{
-   M_Handle = new matThread_Handle( this, stacksize, 0 );
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThread::matThread( matThreadTrace Trace, long stacksize ) :
-   M_Handle( 0 )
-{
-   M_Handle = new matThread_Handle( this, stacksize, Trace );
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThread::~matThread()
-{
-   M_Handle->traceNormal( "~matThread ..." );
-   if( M_Handle->MH_Handle )
-   {
-      if( !M_Handle->MH_Terminated )
-      {
-        M_Handle->traceNormal( "~matThread - terminate" );
-        TerminateThread( M_Handle->MH_Handle, 13 );
-      }
-      CloseHandle( M_Handle->MH_Handle );
-   }
-
-   //@@MaK CloseHandle( M_Handle->MH_StartSema );
-   M_Handle->traceNormal( "~matThread." );
-   delete M_Handle;
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThreadRC matThread::start( matThreadPrty Prty )
-{
-   if( M_Handle->MH_Handle )
-   {
-      if( !M_Handle->MH_Terminated )
-      {
-         //
-         // Thread currently running - do not start twice
-         //
-         M_Handle->traceError( "start - ignored" );
-         return THREADRC_ERROR;
-      }
-      CloseHandle( M_Handle->MH_Handle );
-      M_Handle->MH_Handle = 0;
-   }
-
-#ifdef __IBMCPP__
-   HANDLE NewHandle = (HANDLE)_beginthread
-                      (
-                         privateEnterThreadC,
-                         NULL,
-                         M_Handle->MH_Stacksize,
-                         M_Handle
-                      );
-#else
-   HANDLE NewHandle = (HANDLE)_beginthread
-                      (
-                         privateEnterThreadC,
-                         M_Handle->MH_Stacksize,
-                         M_Handle
-                      );
-#endif
-   if( NewHandle == 0 )
-   {
-      return M_Handle->traceLastError( "start - CreateThread" );
-   }
-#if 0 //@@MaK
-   if
-   (
-      !DuplicateHandle
-      (
-         GetCurrentProcess(), NewHandle,
-         GetCurrentProcess(), &M_Handle->MH_Handle,
-         0, FALSE, DUPLICATE_SAME_ACCESS
-      )
-   )
-   {
-      return M_Handle->traceLastError( "start - DuplicateHandle" );
-   }
-#else
-   M_Handle->MH_Handle = NewHandle;
-#endif
-
-   M_Handle->traceNormal( "start - waiting" );
-   WaitForSingleObject( M_Handle->MH_StartSema, INFINITE );
-
-   //@@MaK
-   CloseHandle( M_Handle->MH_StartSema );
-
-   Sleep( 1 );
-   M_Handle->traceNormal( "start" );
-   switch( Prty )
-   {
-   default:
-      return THREADRC_OK;
-   case THREADPRTY_HIGH:
-      if
-      (
-         SetThreadPriority
-         (
-            M_Handle->MH_Handle,
-            THREAD_PRIORITY_ABOVE_NORMAL
-         )
-      ) return THREADRC_OK;
-      else return M_Handle->traceLastError( "start - SetThreadPriority" );
-   case THREADPRTY_LOW:
-      if
-      (
-         SetThreadPriority
-         (
-            M_Handle->MH_Handle,
-            THREAD_PRIORITY_BELOW_NORMAL
-         )
-      ) return THREADRC_OK;
-      else return M_Handle->traceLastError( "start - SetThreadPriority" );
-   }
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThreadRC matThread::stop()
-{
-   if( M_Handle->MH_Handle == 0 )
-   {
-      //
-      // Thread currently not running - cannot stop it
-      //
-      M_Handle->traceError( "stop - error" );
-      return THREADRC_ERROR;
-   }
-   M_Handle->traceNormal( "stop" );
-   TerminateThread( M_Handle->MH_Handle, 12 );
-   CloseHandle( M_Handle->MH_Handle );
-   M_Handle->MH_Handle = 0;
-   M_Handle->MH_Terminated = 1;
-   return THREADRC_OK;
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThreadRC matThread::waitTerminated()
-{
-   return waitTerminated( INFINITE );
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThreadRC matThread::waitTerminated( long Time )
-{
-   M_Handle->traceNormal( "waitTerminated ..." );
-   int RC = WaitForSingleObject( M_Handle->MH_Handle, Time );
-   switch( RC )
-   {
-   default:
-      M_Handle->traceNormal( "waitTerminated - error." );
-      return THREADRC_ERROR;
-   case WAIT_TIMEOUT:
-      M_Handle->traceNormal( "waitTerminated - timeout." );
-      return THREADRC_TIMEOUT;
-   case ERROR_SUCCESS:
-      M_Handle->traceNormal( "waitTerminated." );
-      return THREADRC_OK;
-   }
-}
-
-
-
-/**
- *
- * Handle parameters to the thread function
- *
-**/
-struct privatePara
-{
-
-   //! Client function pointer
-   matThreadF     pFunc;
-
-   //! Client function parameters
-   void *         FuncPara;
-
-   //! Client trace function
-   matThreadTrace Trace;
-
-};
-
-
-
-/**
- **************************************************************************
- *
- * Thread function
- *
- * @param pV "void" pointer to handle structure
- *
- **************************************************************************
-**/
-#ifdef __IBMCPP__
-static void _Optlink privateEnterThreadF( void * pV )
-#else
-static void __cdecl privateEnterThreadF( void * pV )
-#endif
-{
-   privatePara * pP = (privatePara *)pV;
-   if( pP->Trace )
-   {
-      char Buf[64];
-      sprintf( Buf, "[%d] ...", GetCurrentThreadId() );
-      pP->Trace( TRACE_LEVEL_NORMAL, Buf );
-   }
-   pP->pFunc( pP->FuncPara );
-   if( pP->Trace )
-   {
-      char Buf[64];
-      sprintf( Buf, "[%d].", GetCurrentThreadId() );
-      pP->Trace( TRACE_LEVEL_NORMAL, Buf );
-   }
-   delete pV;
-}
-
-
-
-/**
- *
- * Interface function implementation
- *
-**/
-matThreadRC matThreadFStart
-(
-   matThreadF     ThreadF,
-   void *         ThreadFParameter,
-   long           Stack,
-   matThreadTrace Trace
-)
-{
-   HANDLE H;
-   privatePara * pP = new privatePara;
-   pP->pFunc = ThreadF;
-   pP->FuncPara = ThreadFParameter;
-   pP->Trace = Trace;
-#ifdef __IBMCPP__
-   H = (HANDLE)_beginthread
-       (
-          privateEnterThreadF,
-          NULL,
-          (Stack > NT_MIN_STACK) ? Stack : NT_MIN_STACK,
-          pP
-       );
-#else
-   H = (HANDLE)_beginthread
-       (
-          privateEnterThreadF,
-          (Stack > NT_MIN_STACK) ? Stack : NT_MIN_STACK,
-          pP
-       );
-#endif
-   if( H == (HANDLE)-1 )
-   {
-      if( Trace ) Trace( TRACE_LEVEL_ERROR, "matThreadFStart failed" );
-      return win2rc( GetLastError() );
-   }
-   else
-   {
-      if( Trace )
-      {
-         char Buf[64];
-         sprintf( Buf, "matThreadFStart" );
-         Trace( TRACE_LEVEL_NORMAL, Buf );
-      }
-      return THREADRC_OK;
-   }
-}
-
-
-
-/**
- *
- * Interface function implementation
- *
-**/
-long matThreadId()
-{
-   return GetCurrentThreadId();
-}
-
-
-
-/**
- *
- * Interface function implementation
- *
-**/
-void matThreadSleep( long milliSeconds )
-{
-   Sleep( milliSeconds );
-}
-
-
-
-//-------------------------------------------------------------------------
-//
-// End of file
-//
-//-------------------------------------------------------------------------
diff --git a/Massai/cpp/CfgXMgr/src/tcpCommW32.cpp b/Massai/cpp/CfgXMgr/src/tcpCommW32.cpp
deleted file mode 100644
index b04c997d..00000000
--- a/Massai/cpp/CfgXMgr/src/tcpCommW32.cpp
+++ /dev/null
@@ -1,1453 +0,0 @@
-/**
- **************************************************************************
- * 
- * @file tcpCommW32.cpp
- * 
- * Implementation module for TCP/IP communication class.
- * 
- * @author RB, JK
- * 
- * 
- * 200897rb universal tcp/ip object class
- * 210897rb multiple session on one port possible
- * 111297rb change setaddress to speedup a session
- * 111297rb allow new open after close (for clients)
- * 110398jk in open() sleep only, when retry
- * 151098jk swaps() corrected
- * 041199ts/rb add additional client constructor using DONT_LINGER
- *          (send complete messages)
- * 081199ts add additional client constructor for tcpComm
- * 310100jk removed some sleep in destructors
- *          changed logIt
- * 130300jk beautifications
- * 250500jk major redesign
- * 210700jk MSVC warnings removed
- * 140900jk/rb add PRIVATE definition
- *             mutex usage corrected
- *             add close in _tcpComm::cancel()
- * 180900jk create hashMap with novalue( 0 ) as well
- * 010201jk new logDmp and renamed logFmt
- * 110301jk use freePort( Port, 1 ) to close a server socket in cancel()
- * 170801jk logDmp protected against no-file.
- * 280901jk - code beautifications
- *          - modifications due to lint warnings
- * 050302jk - Branched from tcpcomm.cpp
- * 140302jk - BCC warnings removed
- *
- * Copyright (c) 1997-2002 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-
-
-#define MAX_PORTS       512
-
-#define PRIVATE         static
-
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdarg.h>
-
-#include "tcpComm.h"
-#include "mMutexSem.hpp"
-
-#include "mHashMT.hpp"
-
-#include <windows.h>
-#include <winsock.h>
-
-#include <string.h>
-
-
-
-
-
-
-/**
- **************************************************************************
- * 
- * Server socket organization.
- * 
- **************************************************************************
-**/
-struct portinfo
-{
-   //! Server socket id
-   SOCKET     sSocket;
-   
-   //! Actual reference count
-   int        refcnt;
-   
-   //! Port number
-   portnumber port;
-};
-
-
-
-
-/**
- **************************************************************************
- * 
- * Handles the static module-local data.
- * 
- **************************************************************************
-**/
-struct moduleLocal
-{
-   
-   //! Protect pointer to handle class
-   Materna::MSSD::mutexSemaphore             HMutex;
-
-   //! Protect PortMap
-   Materna::MSSD::mutexSemaphore             PortMapMutex;
-   
-   //! Fast acces to the portinfo objects
-   Materna::MSSD::hashMT< portinfo *, long > PortMap;
-   
-   //! How often has initProtocol be called
-   int                                       ProtocolLevel;
-
-   //! The name of the logging file
-   char                                      LogFile[64];
-
-   /**
-    * Constructor
-    * 
-    * Creates PortMap with a very odd hash-value
-    * 
-   **/
-   moduleLocal() :
-      HMutex(),
-      PortMapMutex(),
-      PortMap( MAX_PORTS * 10 / 7, 0, 0 ),
-      ProtocolLevel( 0 )
-   {
-      LogFile[0] = 0;
-   }
-   
-};
-
-
-
-/**
- **************************************************************************
- * 
- * Keeps the module local data.
- * 
- **************************************************************************
-**/
-PRIVATE moduleLocal * Loc;
-
-
-
-/**
- **************************************************************************
- * 
- * Initialize all module data
- * 
- **************************************************************************
-**/
-struct initModule
-{
-   initModule()
-   {
-      Loc = new moduleLocal;
-   }
-   
-};
-
-
-
-/**
- **************************************************************************
- * 
- * Initialize all module data
- * 
- **************************************************************************
-**/
-PRIVATE initModule IM;
-
-
-
-void tcpCommModuleLog( char const * File )
-{
-   if( File )
-   {
-      strncpy( Loc->LogFile, File, sizeof(Loc->LogFile) );
-      Loc->LogFile[sizeof(Loc->LogFile)-1] = 0;
-   }
-   else
-      Loc->LogFile[0] = 0;
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Write event logging.
- * 
- * @param pszFormat printf-style format string
- * 
- **************************************************************************
-**/
-PRIVATE void logFmt( char *pszFormat, ... )
-{
-   if(!Loc->LogFile[0] )
-      return;
-
-   static Materna::MSSD::mutexSemaphore MX;
-   MX.request();
-   va_list      arg_ptr;
-   char         tmpBuf[2048];
-   
-   /* get pointer to first argument */
-   va_start(arg_ptr, pszFormat);
-   
-   /* print into buffer */
-   vsprintf(tmpBuf, pszFormat, arg_ptr);
-
-   va_end(arg_ptr);
-   FILE *FOut;
-   if( (FOut = fopen( Loc->LogFile, "a" ))!=NULL)
-   {
-      SYSTEMTIME systemtime;
-      GetLocalTime(&systemtime);
-      fprintf( FOut, "%02d%02d:%02d.%02d %d|%s\n",
-                        systemtime.wHour,
-                        systemtime.wMinute,
-                        systemtime.wSecond,
-                        systemtime.wMilliseconds/10,
-                        GetCurrentThreadId(),
-                        tmpBuf);
-      fclose( FOut );
-   }
-   MX.release();
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Write event logging.
- * 
- * @param Begin Points to the first byte of the buffer
- * 
- * @param End   Points to the first byte after the buffer
- * 
- **************************************************************************
-**/
-PRIVATE void logDmp( char const * Begin, char const * End )
-{
-   if(!Loc->LogFile[0] )
-      return;
-   
-   FILE * FOut = fopen( Loc->LogFile, "a" );
-   if( FOut )
-   {
-      SYSTEMTIME systemtime;
-      GetLocalTime(&systemtime);
-      fprintf
-      (
-         FOut, "%02d%02d:%02d.%02d %d|",
-                systemtime.wHour,
-                    systemtime.wMinute,
-                         systemtime.wSecond,
-                              systemtime.wMilliseconds/10,
-                                   GetCurrentThreadId()
-      );
-      int Count = 16;
-      while( Begin != End )
-      {
-         if( !Count )
-         {
-            fprintf( FOut, "\n              |" );
-            Count = 15;
-         }
-         else
-            --Count;
-         fprintf( FOut, " %02X", (unsigned char)*Begin++ );
-      }
-      fprintf( FOut, "\n" );
-      fclose( FOut );
-   }
-   
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Organize WSAStartup
- * 
- **************************************************************************
-**/
-PRIVATE void initProtocol()
-{
-   logFmt( " - initProtocol: %d beg", Loc->ProtocolLevel++ );
-   WSADATA Dta;
-   int err = WSAStartup( MAKEWORD(1,1), &Dta );
-   if( err != 0 )
-   {
-      logFmt( " - initProtocol err:%d", err );
-   }
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Organize WSACleanup
- * 
- **************************************************************************
-**/
-PRIVATE void exitProtocol()
-{
-   logFmt( " - exitProtocol: %d", --Loc->ProtocolLevel );
-   long erg = WSACleanup();
-   if(erg)
-      logFmt( " - exitProtocol err=%d", erg);
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Create a server socket.
- * 
- * @param port Portnumber.
- * 
- * @return The new server socket for the port specified or INVALID_SOCKET.
- * 
- **************************************************************************
-**/
-PRIVATE SOCKET newServerSocket( portnumber port )
-{
-   SOCKET SSock = socket( AF_INET, SOCK_STREAM, 0 );
-   if( SSock == INVALID_SOCKET )
-   {
-      logFmt( " - newServerSocket(%d) error:%d", port, WSAGetLastError());
-      return SSock;
-   }
-
-   int value = 1;        /* rb age 120997 use int var */
-   setsockopt(SSock,SOL_SOCKET,SO_REUSEADDR,(CHAR *)&value,sizeof(value));
-
-   // bind the socket to the server address.
-   struct sockaddr_in server;
-   server.sin_family      = AF_INET;
-   server.sin_port        = htons( (unsigned short) port );
-   server.sin_addr.s_addr = INADDR_ANY;
-   if
-   (
-      bind( SSock, (struct sockaddr *)&server, sizeof(server) )
-      == SOCKET_ERROR
-   )
-   {
-      logFmt( " - newServerSocket(%d) bind error:%d", port, WSAGetLastError());
-      closesocket(SSock);
-      return INVALID_SOCKET;
-   }
-   
-   if(listen(SSock,0) != 0)    // no pending sessions allowed
-   {
-      logFmt( " - server listen() err:%d", WSAGetLastError());
-      closesocket(SSock);
-      return INVALID_SOCKET;
-   }
-
-   logFmt( " - newServerSocket(%d) = %d", port, SSock );
-   return SSock;
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Create a client socket
- * 
- * @param bLinger
- *
- * @return The new socket
- * 
- **************************************************************************
-**/
-PRIVATE SOCKET newClientSocket( int bLinger = 0 )
-{
-   logFmt( "newClientSocket:%d", bLinger );
-   SOCKET cs = socket(AF_INET,SOCK_STREAM,0);
-   if( cs == INVALID_SOCKET )
-   {
-      logFmt( "socket() err:%d", WSAGetLastError());
-      return cs;
-   }
-
-   SOCKADDR_IN sin;
-   sin.sin_family = AF_INET;
-   sin.sin_port = 0;
-   sin.sin_addr.s_addr = htonl (INADDR_ANY);;
-   long erg = bind (cs, (struct sockaddr *)&sin, sizeof (sin));
-   if( erg == SOCKET_ERROR )
-   {
-      logFmt( "client bind err:%d", WSAGetLastError());
-      return erg;
-   }
-   if( !bLinger )
-   {
-      // default usage
-      static LINGER ling = { 1, 0 };
-      erg = setsockopt(cs,SOL_SOCKET,SO_LINGER,(char *)&ling,sizeof(ling));
-      logFmt( "setsockopt:%d", erg );
-   }
-   else
-   {
-      logFmt( "dont linger" );
-   }
-   return cs;
-}
-
-
-/**
- **************************************************************************
- * 
- * Look if a port is already in use. If yes return socket if resources
- * match. If no, create the server socket and return it.
- * 
- * @param Port Portnumber.
- * 
- * @return socket handle or INVALID_SOCKET.
- *
- **************************************************************************
-**/
-PRIVATE SOCKET allocPort( portnumber Port )
-{
-   logFmt( " - allocPort( %d ) ...", Port );
-   SOCKET Socket;
-   Loc->PortMapMutex.request();
-   portinfo * pI = Loc->PortMap.get( Port );
-   if( pI )
-   {
-      /* found entry increase session count*/
-      pI->refcnt++;
-      logFmt( " - allocPort(%d) refcnt:%d", Port, pI->refcnt);
-      Socket = pI->sSocket;
-   }
-   else
-   {
-      Socket = newServerSocket( Port );
-      if( Socket != INVALID_SOCKET )
-      {
-         pI = new portinfo;
-         pI->refcnt = 1;
-         pI->sSocket = Socket;
-         pI->port = Port;
-         logFmt( " - allocPort(%d) new socket %d refcnt:1", Port, Socket );
-         pI = Loc->PortMap.set( Port, pI );
-         if( !pI )
-         {
-            logFmt( " - allocPort(%d) - error max ports in use", Port );
-            Socket = INVALID_SOCKET;
-         }
-      }
-   }
-   Loc->PortMapMutex.release();
-   logFmt( " - allocPort( %d ) = %d.", Port, Socket );
-   return Socket;
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Release a port from the hashmap.
- * 
- * @param Port
- * 
- * @param All if true forces the socket to close.
- * 
- **************************************************************************
-**/
-PRIVATE void freePort( portnumber Port, int All = 0 )
-{
-   Loc->PortMapMutex.request();
-   portinfo * pI = Loc->PortMap.get( Port );
-   if( pI )
-   {
-
-      pI->refcnt--;
-      logFmt( " - freePort(%d) refcnt:%d", Port, pI->refcnt);
-      if( ( pI->refcnt <= 0 ) || All )
-      {
-         SOCKET Sock = pI->sSocket;
-         long rc = closesocket( Sock );
-         if( rc < 0 ) rc = WSAGetLastError();
-         logFmt( " - freePort(%d) close socket %d rc:%d", Port, Sock, rc );
-         // delete hashentry
-         Loc->PortMap.clr( Port );
-         delete pI;
-      }
-   }
-   Loc->PortMapMutex.release();
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Fill client sockaddr_in structure.
- * 
- * @param Dst  The structure to fill
- * 
- * @param Port The portnumber
- * 
- * @param Host The (remote) host
- * 
- **************************************************************************
-**/
-PRIVATE void setAddress
-             (
-                struct sockaddr_in & Dst,
-                portnumber           Port,
-                char const *         Host
-             )
-{
-   logFmt( "setAddress( %ld, %s) ...", Port, Host );
-   memset(&Dst,0,sizeof(Dst));
-   Dst.sin_family = AF_INET;
-   Dst.sin_port   = htons( Port );
-   //
-   // get the server address.
-   //
-   Dst.sin_addr.s_addr = inet_addr( (char *) Host );
-   if( Dst.sin_addr.s_addr == INADDR_NONE )
-   {
-      //
-      // server host name information
-      //
-      struct hostent * hostnm = gethostbyname( (char *) Host );
-      if( hostnm )
-         Dst.sin_addr.s_addr = *((ULONG *)hostnm->h_addr);
-      else
-         Dst.sin_addr.s_addr = inet_addr( "127.0.0.1" );
-   }
-   logFmt( "setAddress." );
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Socket state values.
- * 
- **************************************************************************
-**/
-enum STATE
-{
-  ST_INIT,
-  ST_IDLE,
-  ST_READY,
-  ST_CLOSED
-};
-
-
-
-/**
- **************************************************************************
- * 
- * Handle class.
- * 
- **************************************************************************
-**/
-class _tcpComm
-{
-   
-   //! The name of the remote host, ether dot-notation or logical
-   char       M_Host[128];
-   
-   //! The port number
-   portnumber M_Port;
-   
-   //! The server socket
-   SOCKET     M_ServerSocket;
-   
-public:
-
-   //! Current connection state
-   STATE      M_State;
-   
-   //! Communication socket
-   SOCKET     M_Socket;
-
-   /**
-    * 
-    * Cancel current operation
-    * 
-   **/
-   void cancel()
-   {
-      logFmt( "_tcpComm::cancel ..." );
-      if( M_ServerSocket != INVALID_SOCKET )
-      {
-         // remove server socket (all references)
-         M_ServerSocket = INVALID_SOCKET;
-         freePort( M_Port, 0 );
-      }
-      close();
-      logFmt( "_tcpComm::cancel." );
-   }
-
-   /**
-    * 
-    * Destructor
-    * 
-   **/
-   ~_tcpComm()
-   {
-      logFmt( "_tcpComm::~_tcpCommm ..." );
-      if( M_ServerSocket != INVALID_SOCKET )
-      {
-         // remove server socket
-         M_ServerSocket = INVALID_SOCKET;
-         freePort( M_Port );
-      }
-      if( M_Socket != INVALID_SOCKET )
-      {
-         long rc = shutdown( M_Socket, 2 );
-         if( rc < 0 ) rc = WSAGetLastError();
-         logFmt( "shutdown %d rc:%d", M_Socket, rc );
-         rc = closesocket( M_Socket );
-         if( rc < 0 ) rc = WSAGetLastError();
-         logFmt( "close %d rc:%d", M_Socket, rc );
-         M_Socket = INVALID_SOCKET;
-      }
-      logFmt( "_tcpComm::~_tcpComm." );
-   }
-
-   /**
-    * 
-    * Constructor for server side halfsession.
-    * 
-    * @param 1. Port
-    * 
-   **/
-   _tcpComm( portnumber Port ) :
-      M_ServerSocket( INVALID_SOCKET ),
-      M_Socket( INVALID_SOCKET )
-   {
-      M_Port = Port;
-      M_State = ST_INIT;
-      M_Host[0] = 0;
-      if( Port )
-      {
-         M_ServerSocket = allocPort( Port );
-         M_State = ST_IDLE;
-      }
-   }
-
-   /**
-    * 
-    * Constructor for client side halfsession.
-    * 
-    * @param 1. Remote port
-    * 
-    * @param 2. Remote host
-    * 
-   **/
-   _tcpComm( portnumber Port, char const *szHost ) :
-      M_ServerSocket( INVALID_SOCKET ),
-      M_Socket( INVALID_SOCKET )
-   {
-      M_Port = Port;
-      M_State = ST_INIT;
-      /* */
-      strcpy( M_Host, szHost );
-      if( Port )
-      {
-         M_Socket = newClientSocket();
-         M_State = ST_IDLE;
-      }
-   }
-
-   /**
-    * 
-    * Constructor for client side halfsession.
-    *
-    * @param 1. Remote port
-    * 
-    * @param 2. Remote host
-    * 
-    * @param 3. Set, if not to linger
-    * 
-   **/
-   _tcpComm( portnumber Port, char const *szHost, int bDontLinger ) :
-      M_ServerSocket( INVALID_SOCKET ),
-      M_Socket( INVALID_SOCKET )
-   {
-      M_Port = Port;
-      M_State = ST_INIT;
-      /* */
-      strcpy( M_Host, szHost );
-      if( Port )
-      {
-         M_Socket = newClientSocket( bDontLinger );
-         M_State = ST_IDLE;
-      }
-   }
-
-   /**
-    * 
-    * Close session.
-    * 
-   **/
-   long close()
-   {
-      if( M_Socket != INVALID_SOCKET )
-      {
-         long rc = closesocket( M_Socket );
-         if( rc < 0 ) rc = WSAGetLastError();
-         M_Socket = INVALID_SOCKET;
-      }
-      M_State = (serverSocket())? ST_IDLE: ST_CLOSED;
-      return 0;
-   }
-   
-   /**
-    * 
-    * Retrieve the remote host name.
-    * 
-   **/
-   char const * host() const
-   {
-      return M_Host;
-   }
-
-   /**
-    * 
-    * Retrieve the portnumber
-    * 
-   **/
-   portnumber port() const
-   {
-      return M_Port;
-   }
-   
-   /**
-    * 
-    * Retrieve the server socket.
-    * 
-   **/
-   long serverSocket() const
-   {
-      return M_ServerSocket;
-   }
-   
-};
-
-
-
-/**
- **************************************************************************
- * 
- * Open a session for a server
- * 
- * @param srv Refers the handle class
- * 
- * @return 0 = success, -1 = error
- * 
- **************************************************************************
-**/
-PRIVATE long openServer( _tcpComm& srv )
-{
-   logFmt( " - openServer port:%d ...", srv.port() );
-   SOCKET SS = srv.serverSocket();
-   struct sockaddr sin;
-   int namelen = sizeof(sin);
-   int err = WSAEWOULDBLOCK;
-   while( SS && ( err == WSAEWOULDBLOCK ) )
-   {
-      logFmt( " - openServer accept for serversocket %d ...",
-         srv.serverSocket() );
-      srv.M_Socket = accept( SS, &sin, &namelen );
-      logFmt( " - openServer accept so=%d", srv.M_Socket );
-      if( srv.M_Socket != INVALID_SOCKET )
-      {
-         srv.M_State = ST_READY;
-         // set socket to non blocking mode
-         u_long noblock = 1;
-         long rc = ioctlsocket( srv.M_Socket, FIONBIO, &noblock );
-         logFmt( " - openServer so:%d ioctlrc:%d.", srv.M_Socket, rc );
-         return 0;
-      }
-      else
-      {
-         err = WSAGetLastError();
-         logFmt( " - openServer loop ..." );
-      }
-   }
-   if( SS )
-   {
-      logFmt( " - openServer: accept error:%d.", err );
-   }
-   else
-   {
-      logFmt( " - openServer: error no server socket." );
-   }
-   return -1;
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Open a session for a client
- * 
- * @param clnt Refers the handle class
- * 
- * @param retry Specifies the retries to do
- * 
- * @return 0 = success, -1 = error
- * 
- **************************************************************************
-**/
-PRIVATE long openClient( _tcpComm& clnt, long retry )
-{
-  logFmt( "openClient host:%s port:%d ...", clnt.host(), clnt.port() );
-  struct sockaddr_in sin;
-  setAddress( sin, clnt.port(), clnt.host() );
-  long erg;
-  int bretry = retry;
-  do
-  {
-    logFmt( "[%s]try to connect:<%s> port:%d - cs:%d", clnt.host(),
-             inet_ntoa(sin.sin_addr), clnt.port(), clnt.M_Socket );
-    if
-    (
-       connect( clnt.M_Socket, (struct sockaddr *)&sin, sizeof(sin) )
-       == SOCKET_ERROR
-    )
-    {
-      erg = WSAGetLastError();
-      logFmt( "[%s]err:%d bretry=%d retry=%d", clnt.host(), erg, bretry,
-         retry );
-      if( bretry && !--retry)
-          break;
-    }
-    else erg = 0;
-  }
-  while( erg == WSAECONNREFUSED );
-  if(!erg)
-  {
-    clnt.M_State = ST_READY;
-
-    // set socket to non blocking mode
-    u_long noblock = 1;
-    long rc = ioctlsocket( clnt.M_Socket, FIONBIO, &noblock );
-    if( rc ) logFmt( "openClient ioctlrc:%d.", rc );
-  }
-  else
-  {
-    logFmt( "openClient err:%d", erg );
-  }
-  return erg;
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Receive data
- * 
- * @param rx Refers the handle class
- * 
- * @param pData Buffer address
- * 
- * @param len Buffer length
- * 
- * @return number of bytes received
- * 
- **************************************************************************
-**/
-PRIVATE long recvData(_tcpComm& rx, char *pData, int len)
-{
-   long pos = 0;
-   logFmt( " - recvData(%d) so=%d ...", len, rx.M_Socket );
-   while(len != pos)
-   {
-      long rc = recv( rx.M_Socket, pData+pos, len-pos, 0 );
-      if( rc > 0 )
-      {
-         pos += rc;
-      }
-      else
-      {
-         long err = WSAGetLastError();
-         if( err != WSAEWOULDBLOCK )
-         {
-            /* error */
-            logFmt( " - recvData() so=%d err=%d.", rx.M_Socket, err );
-            closesocket( rx.M_Socket );
-            rx.M_State = ST_CLOSED;
-            return -pos;
-         }
-         else
-         {
-            Sleep(10);
-         }
-      }
-   }
-   logFmt( " - recvData() so=%d actlen=%d.", rx.M_Socket, len );
-   return pos;
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Swap the byte order for a port number
- * 
- * @param n Original order
- * 
- * @return Swapped order
- * 
- **************************************************************************
-**/
-PRIVATE portnumber swaps( portnumber n )
-{
-   return (portnumber)
-          (
-             ( ( n & 0x00FF ) << 8 )
-             |
-             ( ( n & 0xFF00 ) >> 8 )
-          );
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Public method (see tcpComm.hpp)
- * 
- **************************************************************************
-**/
-tcpComm::tcpComm( portnumber Port )
-{
-   logFmt( "tcpComm::tcpComm( %d ) ...", Port );
-   initProtocol();
-   handle = new _tcpComm( Port );
-   logFmt( "tcpComm::tcpComm( %d ).", Port );
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Public method (see tcpComm.hpp)
- * 
- **************************************************************************
-**/
-tcpComm::tcpComm( char const *szService )
-{
-   logFmt( "tcpComm::tcpComm( %s ) ...", szService );
-   initProtocol();
-   struct servent *pS = getservbyname( szService, NULL );
-   portnumber CPort;
-   if( pS )
-      CPort = swaps( pS->s_port );
-   else
-      CPort = 0;
-   handle = new _tcpComm( CPort );
-   logFmt( "tcpComm::tcpComm( %s ).", szService );
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Public method (see tcpComm.hpp)
- * 
- **************************************************************************
-**/
-tcpComm::tcpComm( portnumber Port, char const *szHost )
-{
-   logFmt( "tcpComm::tcpComm( %d, %s ) ...", Port, szHost );
-   initProtocol();
-   handle = new _tcpComm( Port, szHost );
-   logFmt( "tcpComm::tcpComm( %d, %s ).", Port, szHost );
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Public method (see tcpComm.hpp)
- * 
- **************************************************************************
-**/
-tcpComm::tcpComm( char const *szService, char const *szHost )
-{
-   logFmt( "tcpComm::tcpComm( %s, %s ) ...", szService, szHost );
-   initProtocol();
-   struct servent *pS = getservbyname( szService, NULL );
-   portnumber CPort;
-   if( pS )
-      CPort = swaps( pS->s_port );
-   else
-      CPort = 0;
-   handle = new _tcpComm( CPort, szHost );
-   logFmt( "tcpComm::tcpComm( %s, %s ).", szService, szHost );
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Public method (see tcpComm.hpp)
- * 
- **************************************************************************
-**/
-tcpComm::tcpComm( portnumber Port, char const *szHost, int bDontLinger )
-{
-   logFmt( "tcpComm::tcpComm( %d, %s, %d ) ...", Port, szHost, bDontLinger );
-   initProtocol();
-   handle = new _tcpComm( Port, szHost, bDontLinger );
-   logFmt( "tcpComm::tcpComm( %d, %s, %d ).", Port, szHost, bDontLinger );
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Public method (see tcpComm.hpp)
- * 
- **************************************************************************
-**/
-tcpComm::tcpComm( char const *szService, char const *szHost, int DontLing )
-{
-  logFmt( "tcpComm::tcpComm( %s, %s, %d )", szService, szHost, DontLing );
-  initProtocol();
-  struct servent *pS = getservbyname( szService, NULL );
-  portnumber CPort;
-  if( pS )
-    CPort = swaps( pS->s_port );
-  else
-    CPort = 0;
-  logFmt( "service:<%s> port:%d", szService, CPort);
-
-  handle = new _tcpComm( CPort, szHost, DontLing  );
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Public method (see tcpComm.hpp)
- * 
- **************************************************************************
-**/
-tcpComm::~tcpComm()
-{
-   logFmt( "tcpComm::~tcpComm() ..." );
-   Loc->HMutex.request();
-   if( handle )
-   {
-      handle->close();
-      delete handle;
-      handle = 0;
-   }
-   exitProtocol();
-   Loc->HMutex.release();
-   logFmt( "tcpComm::~tcpComm()." );
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Public method (see tcpComm.hpp)
- * 
- **************************************************************************
-**/
-void tcpComm::cancel()
-{
-   logFmt( "tcpComm::cancel() ..." );
-   Loc->HMutex.request();
-   if( handle )
-   {
-      handle->cancel();
-   }
-   Loc->HMutex.release();
-   logFmt( "tcpComm::cancel()." );
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Public method (see tcpComm.hpp)
- * 
- **************************************************************************
-**/
-long tcpComm::open( long retry )
-{
-   logFmt( "tcpComm::open ...", retry );
-   int RC = 0;
-   Loc->HMutex.request();
-   if( handle )
-   {
-      if( handle->M_State == ST_CLOSED )
-      {
-         _tcpComm *oldhandle = handle;
-         handle = new _tcpComm( oldhandle->port(), oldhandle->host() );
-         delete oldhandle;
-      }
-      if( handle->M_State != ST_IDLE )
-      {
-         logFmt( "tcpComm::open - wrong state error, (%d)",
-                handle->M_State );
-         RC = -1;
-      }
-      if( RC == 0 )
-      {
-         _tcpComm * H = handle;
-         Loc->HMutex.release();
-         if( *H->host() )
-            RC = openClient( *H, retry );
-         else
-            RC = openServer( *H );
-         logFmt( "tcpComm::open = %d", RC );
-         return RC;
-      }
-      logFmt( "tcpComm::open - RC=%d", RC );
-   }
-   else
-   {
-      logFmt( "tcpComm::open - destroyed." );
-      RC = -1;
-   }
-   Loc->HMutex.release();
-   return RC;
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Public method (see tcpComm.hpp)
- * 
- **************************************************************************
-**/
-long tcpComm::open( char szAddress[16], char szHostName[128], long retry )
-{
-   long erg = open(retry);
-   if( !erg && szAddress)
-   {
-      szAddress[0] = 0;
-      if( szHostName ) szHostName[0] = 0;
-      SOCKADDR_IN addr;
-      int nAddrLen = sizeof(addr);
-      if
-      (
-         getpeername( handle->M_Socket, (sockaddr *)&addr, &nAddrLen)
-         == SOCKET_ERROR
-      )
-      {
-         logFmt( "tcpComm::open - getpeername %d err:%d",
-                handle->M_Socket, WSAGetLastError() );
-      }
-      else
-      {
-         // we have some info
-         logFmt( "tcpComm::open - getpeername ok <%s>",
-            inet_ntoa(addr.sin_addr) );
-         strcpy( szAddress, inet_ntoa(addr.sin_addr));
-         if( szHostName )
-         {
-            PHOSTENT phost;
-            if
-            (
-               (
-                 phost =
-                 gethostbyaddr( (char *)&addr.sin_addr.s_addr, 4, PF_INET)
-               )
-               == NULL
-            )
-            {
-               logFmt( "tcpComm::open - gethostbyaddr %d err:%d",
-                      handle->M_Socket, WSAGetLastError() );
-            }
-            else
-            {
-               strcpy( szHostName, phost->h_name );
-            }
-         }
-      }
-   }
-   return erg;
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Public method (see tcpComm.hpp)
- * 
- **************************************************************************
-**/
-long tcpComm::open
-(
-   char szHostAddr[16],
-   portnumber * pPort,
-   char szHostName[128],
-   char szServiceName[128],
-   long retry
-)
-{
-   //
-   // Standard opne()
-   //
-   long erg = open(retry);
-   if( !erg )
-   {
-      SOCKADDR_IN addr;
-      int nAddrLen = sizeof(addr);
-      if
-      (
-         getpeername( handle->M_Socket, (SOCKADDR *)&addr, &nAddrLen)
-         == SOCKET_ERROR
-      )
-      {
-         logFmt( "tcpComm::open - getpeername %d err:%d",
-                handle->M_Socket, WSAGetLastError() );
-      }
-      else
-      {
-         //
-         // Got some info
-         //
-         logFmt( "tcpComm::open - getpeername ok <%s>",
-                inet_ntoa(addr.sin_addr));
-         if( szHostAddr )
-         {
-            strcpy( szHostAddr, inet_ntoa(addr.sin_addr));
-         }
-         if( pPort )
-         {
-            *pPort = swaps( addr.sin_port );
-         }
-         if( szHostName )
-         {
-            PHOSTENT phost = gethostbyaddr
-                             (
-                                (char *)&addr.sin_addr.s_addr, 4,
-                                PF_INET
-                             );
-            if( !phost )
-            {
-               logFmt( "tcpComm::open - gethostbyaddr %d err:%d",
-                      handle->M_Socket, WSAGetLastError() );
-            }
-            else
-            {
-               strcpy( szHostName, phost->h_name );
-            }
-         }
-         if( szServiceName ) szServiceName[0] = 0;
-         return 0;
-      }
-   }
-   if( szHostAddr ) szHostAddr[0] = 0;
-   if( szHostName ) szHostName[0] = 0;
-   if( szServiceName ) szServiceName[0] = 0;
-   return erg;
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Public method (see tcpComm.hpp)
- * 
- **************************************************************************
-**/
-long tcpComm::close()
-{
-   long RC;
-   Loc->HMutex.request();
-   if( handle )
-   {
-      RC = handle->close();
-      logFmt( "tcpComm::close %d RC:%d", handle->M_Socket, RC );
-   }
-   else
-   {
-      logFmt( "tcpComm::close - destroyed." );
-      RC = -1;
-   }
-   Loc->HMutex.release();
-   return RC;
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Public method (see tcpComm.hpp)
- * 
- **************************************************************************
-**/
-portnumber tcpComm::port() const
-{
-   if( !handle )
-      // No handle allocated - should not occur
-      return 0;
-   portnumber P = handle->port();
-   logFmt( "tcpComm::port - %d", P );
-   return P;
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Public method (see tcpComm.hpp)
- * 
- **************************************************************************
-**/
-long tcpComm::read ( char *dst, long dstlen )
-{
-   if( !handle )
-      // No handle allocated - should not occur
-      return -1;
-   if( handle->M_State != ST_READY )
-   {
-      logFmt( "tcpComm::read - error: wrong state" );
-      return -1;
-   }
-   logFmt( "tcpComm::read ..." );
-   long erg = recvData(*handle, dst, dstlen);
-   if( erg == dstlen )
-   {
-      logFmt( "tcpComm::read(%d).", dstlen );
-      logDmp( dst, dst + erg );
-      return 0;
-   }
-   else
-   {
-      logFmt( "tcpComm::read(%d) - length error(%d).", dstlen, erg );
-      return -1;
-   }
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Public method (see tcpComm.hpp)
- * 
- **************************************************************************
-**/
-long tcpComm::write( char const *src, long len )
-{
-   if( !handle )
-      // No handle allocated - should not occur
-      return -1;
-   if( handle->M_State != ST_READY )
-   {
-      logFmt( "tcpComm::write so(%d) error state=%d", handle->M_Socket,
-         handle->M_State );
-      return -1;
-   }
-   logFmt( "tcpComm::write so(%d) len(%d) ...",  handle->M_Socket, len );
-   logDmp( src, src + len );
-   long rc = send( handle->M_Socket, src, len, 0 );
-   if( rc != len )
-   {
-      long err = WSAGetLastError();
-      if(!err)
-         err = -1;
-      logFmt( "tcpComm::write so(%d) len(%d) rc(%d) Error:%d",
-             handle->M_Socket, len, rc, err );
-      return err;
-   }
-   logFmt( "tcpComm::write so(%d) len(%d).",  handle->M_Socket, len );
-   return 0;
-}
-
-
-
-/**
- **************************************************************************
- * 
- * Public method (see tcpComm.hpp)
- * 
- **************************************************************************
-**/
-long tcpComm::writeblocking( char const *src, long len )
-{
-   if( !handle )
-      // No handle allocated - should not occur
-      return -1;
-   if( handle->M_State != ST_READY )
-   {
-      logFmt( "tcpComm::writeblocking so(%d) error state=%d", handle->M_Socket,
-         handle->M_State );
-      return -1;
-   }
-   u_long ulCMD=0;
-   // put socket into blocking mode
-   ioctlsocket( handle->M_Socket, FIONBIO, &ulCMD );
-   logFmt( "tcpComm::writeblocking so(%d) len(%d) ...",
-          handle->M_Socket, len );
-   long rc = send( handle->M_Socket, src, len, 0 );
-   ulCMD=1;
-   // put socket into non blocking mode   
-   ioctlsocket( handle->M_Socket, FIONBIO, &ulCMD );
-   if( rc != len )
-   {
-      long err = WSAGetLastError();
-      if(!err)
-        err = -1;
-      logFmt( "tcpComm::writeblocking so(%d) len(%d) rc(%d) Error:%d",
-         handle->M_Socket, len, rc, err );
-      return err;
-   }
-   return 0;
-}
-
-
-
-/**
- **************************************************************************
- * 
- * End of file
- * 
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgr/src/writeTrace.cpp b/Massai/cpp/CfgXMgr/src/writeTrace.cpp
deleted file mode 100644
index 21d44bbc..00000000
--- a/Massai/cpp/CfgXMgr/src/writeTrace.cpp
+++ /dev/null
@@ -1,105 +0,0 @@
-/**
- **************************************************************************
- *
- * @file writeTrace.cpp
- *
- * Trace function implementation for configuration server.
- *
- * @author JK
- *
- * Copyright (c) 2002 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-
-#include "writeTrace.hpp"
-
-#include "mMutexSem.hpp"
-#include "mHRTimer.h"
-#include "AssoCStr.hpp"
-
-#include <stdarg.h>
-#include <stdio.h>
-
-
-
-namespace
-{
-   
-   mHRTimer        S_Timer;
-   long            S_Level = 0;
-   std::ostream *  S_Stream = 0;
-}
-
-
-
-long _stdcall writeTrace
-(
-   long Level,
-   char const *, short, char const *,
-   char const * Format, ...
-)
-{
-   if( Level <= S_Level )
-   {
-      static Materna::MSSD::mutexSemaphore X;
-      X.request();
-      va_list Arg;
-      char String[4096];
-      va_start( Arg, Format );
-      vsprintf( String, Format, Arg );
-      va_end( Arg );
-      char Time[20];
-      S_Timer.timestampString( Time );
-#if 0      
-      *S_Stream << Time << ": " << String << std::endl;
-#else      
-      *S_Stream << "[" << Level << "]" << Time << ": " << String << std::endl;
-#endif      
-      X.release();
-   }
-   return 0;
-}
-
-
-
-void writeTraceMap
-(
-   long Level,
-   char const * Mod, short Lin, char const * Fun,
-   char const * Title, aMap const & Map
-)
-{
-   if( Level <= S_Level )
-   {
-      char Buffer[1024];
-      strcpy( Buffer, Title );
-      strcat( Buffer, "\n" );
-      assoCStr
-      (
-         Buffer + strlen( Buffer ),
-         Buffer + sizeof(Buffer),
-         Map,
-         "    "
-      );
-      writeTrace( Level, Mod, Lin, Fun, Buffer );
-   }
-}
-
-
-
-void writeTrace_Init( std::ostream & Stream, long Level )
-{
-   S_Level = Level;
-   S_Stream = &Stream;
-}
-
-
-
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgrB/inc/mHRTimer.h b/Massai/cpp/CfgXMgrB/inc/mHRTimer.h
deleted file mode 100644
index d96e63ac..00000000
--- a/Massai/cpp/CfgXMgrB/inc/mHRTimer.h
+++ /dev/null
@@ -1,92 +0,0 @@
-/**
- **************************************************************************
- * 
- * @file mHRTimer.h
- * 
- **************************************************************************
-**/
-#ifndef MHRTIMER_H
-#define MHRTIMER_H
-
-#define MHRTIMER_STRING_SIZE(D) (sizeof("HH:MM:SS.")+D)
-#define MHRTIMER_STRING_LEN(D)  (sizeof("HH:MM:SS.")-1+D)
-
-/**
- * 
- * Implementation private.
- * 
-**/
-struct mHRTimer_;
-
-/**
- * 
- * Interface handle.
- * 
-**/
-typedef struct mHRTimer_ * mHRTimer_Handle;
-
-#ifdef __cplusplus
-
-extern "C"
-{
-#endif
-
-   /**
-    * 
-    * Constructor.
-    * 
-   **/
-   mHRTimer_Handle mHRTimer_Create( unsigned );
-
-   /**
-    * 
-    * Destructor.
-    * 
-   **/
-   void mHRTimer_Delete( mHRTimer_Handle );
-
-   /**
-    * 
-    * Write a timestamp.
-    * 
-   **/
-   void mHRTimer_TimestampString( mHRTimer_Handle, char * );
-
-#ifdef __cplusplus
-}
-
-
-class mHRTimer
-{
-   
-   mHRTimer_Handle H;
-   
-public:
-   
-   explicit mHRTimer( unsigned Digits = 3 ) :
-      H( mHRTimer_Create( Digits ) )
-   {
-   }
-
-   ~mHRTimer()
-   {
-      mHRTimer_Delete( H );
-   }
-   
-   void timestampString( char * Dst )
-   {
-      mHRTimer_TimestampString( H, Dst );
-   }
-        
-};
-
-#endif
-   
-#endif
-/**
- **************************************************************************
- * 
- * End of file
- * 
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgrB/inc/mStringFile.hpp b/Massai/cpp/CfgXMgrB/inc/mStringFile.hpp
deleted file mode 100644
index a92ecf64..00000000
--- a/Massai/cpp/CfgXMgrB/inc/mStringFile.hpp
+++ /dev/null
@@ -1,61 +0,0 @@
-/**
- **************************************************************************
- *
- * @file mStringFile.hpp
- *
- * Copy a standard string to file and vice versa.
- *
- * @author JK
- *
- * Copyright (c) 2004 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-
-
-
-#include <string>
-
-
-
-/**
- *
- * Copy file data to a standard string.
- *
- * @param Dst:          The destination string
- *
- * @param Filename:     Name of the source file.
- *
-**/
-void mStringFromFile
-(
-   std::string &        Dst,
-   std::string const &  Filename
-);
-
-
-
-/**
- *
- * Copy a standard string to file.
- *
- * @param Filename:     Name of the destination file.
- *
- * @param Src:          The source string
- *
-**/
-void mStringToFile
-(
-   std::string const &  Filename,
-   std::string const &  Src
-);
-
-
-
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgrB/inc/matDaemon.h b/Massai/cpp/CfgXMgrB/inc/matDaemon.h
deleted file mode 100644
index 04bf7016..00000000
--- a/Massai/cpp/CfgXMgrB/inc/matDaemon.h
+++ /dev/null
@@ -1,96 +0,0 @@
-/**
- **************************************************************************
- *
- * @file mDaemon.h
- *
- * Interface to mDaemon functions.
- *
- * @author JK
- *
- * Copyright (c) 2001 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef MDAEMON_H
-#define MDAEMON_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-  /**
-    *
-    * List of services that must start before this service
-    * This function is implemented by the service-specific part of the daemon.
-    *
-   **/
-   char const * mDaemon_dependencies();
-   /**
-    *
-    * Give command-line parameters help.
-    * This function is implemented by the service-specific part of the daemon.
-    *
-   **/
-   char const * mDaemon_help();
-
-   /**
-    *
-    * Get the name for the daemon process.
-    * This function is implemented by the service-specific part of the daemon.
-    *
-   **/
-   char const * mDaemon_name();
-
-   /**
-    *
-    * Run the daemon process.
-    * This function is implemented by the service-specific part of the daemon.
-    *
-   **/
-   int mDaemon_main( int argc, char ** argv );
-
-   /**
-    *
-    * Stop the daemon process.
-    * This function is implemented by the service-specific part of the daemon.
-    *
-   **/
-   void mDaemon_stop( void );
-
-   /**
-    *
-    * This function is called by the service-specific part of the daemon
-    * to indicate the service is initializing.
-    *
-   **/
-   int mDaemon_indInitializing( unsigned long mSec );
-
-   /**
-    *
-    * This function is called by the service-specific part of the daemon
-    * to indicate the service is ready for operation.
-    *
-   **/
-   int mDaemon_indReady( unsigned long mSec );
-
-   /**
-    *
-    * This function is called by the service-specific part of the daemon
-    * to write an application event.
-    *
-   **/
-   void mDaemon_log( char const * Data );
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
-
diff --git a/Massai/cpp/CfgXMgrB/inc/writeTraceIF.hpp b/Massai/cpp/CfgXMgrB/inc/writeTraceIF.hpp
deleted file mode 100644
index defe1b29..00000000
--- a/Massai/cpp/CfgXMgrB/inc/writeTraceIF.hpp
+++ /dev/null
@@ -1,41 +0,0 @@
-/**
- **************************************************************************
- *
- * @file writeTraceIF.hpp
- *
- * Trace function declarations for configuration server.
- *
- * @author Juergen Kreierhoff
- *
- * Copyright (c) 2002-2004 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef WRITETRACEIF_HPP
-#define WRITETRACEIF_HPP
-
-#include "TraceClt.h"
-#include <iostream>
-
-
-
-/**
- *
- * Initialize tracing.
- *
- * @param Dst:          Stream to use for traces.
- *
- * @param Lvl:          Trace level threshold.
- *
-**/
-void writeTrace_Init( std::ostream & Dst, long Lvl );
-
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgrB/src/mEventSemW32.cpp b/Massai/cpp/CfgXMgrB/src/mEventSemW32.cpp
deleted file mode 100644
index c135eba5..00000000
--- a/Massai/cpp/CfgXMgrB/src/mEventSemW32.cpp
+++ /dev/null
@@ -1,167 +0,0 @@
-/**
- **************************************************************************
- * 
- * @file mEventSemW32.cpp
- * 
- * Contains the implementation for the methods defined in mEventSem.hpp
- * for the Win32 platform.
- * 
- * @author JK
- * 
- * Copyright (c) 2002 MATERNA Information & Communications
- * 
- **************************************************************************
-**/
-
-#include "mEventsem.hpp"
-
-#include "windows.h"
-
-
-
-namespace Materna
-{
-   namespace MSSD
-   {
-      
-      class eventSemaphore_Handle
-      {
-         
-         HANDLE M_Hdl;
-         
-      public:
-
-         eventSemaphore_Handle();
-         
-         explicit eventSemaphore_Handle( char const * Name ) :
-            M_Hdl( CreateEvent( 0, TRUE, FALSE, Name ) )
-         {
-         }
-            
-         ~eventSemaphore_Handle()
-         {
-            CloseHandle( M_Hdl );
-            M_Hdl = 0;
-         }
-      
-         HANDLE winH() const
-         {
-            return M_Hdl;
-         }
-         
-      };
-      
-   }
-}
-
-
-
-using namespace Materna::MSSD;
-
-
-
-eventSemaphore::eventSemaphore() :
-   M_Handle( new eventSemaphore_Handle( 0 ) )
-{
-}
-
-
-
-eventSemaphore::eventSemaphore( char const * Name ) :
-   M_Handle( new eventSemaphore_Handle( Name ) )
-{
-}
-
-
-
-eventSemaphore::~eventSemaphore()
-{
-   delete M_Handle;
-}
-
-
-
-void eventSemaphore::wait()
-   throw( eventSemaphore_Exception )
-{
-   eventSemaphore_Handle * H = M_Handle;
-   if( !H )
-      throw eventSemaphore_Exception();
-   DWORD RC = WaitForSingleObject( H->winH(), INFINITE );
-   if( RC != WAIT_OBJECT_0 )
-      throw eventSemaphore_Exception();
-}
-
-
-
-int eventSemaphore::wait( long Time )
-   throw( eventSemaphore_Exception )
-{
-   eventSemaphore_Handle * H = M_Handle;
-   if( !H )
-      throw eventSemaphore_Exception();
-   DWORD RC = WaitForSingleObject( H->winH(), static_cast<DWORD>( Time ) );
-   if( RC == WAIT_OBJECT_0 )
-      return 0;
-   else
-      return static_cast<int>( RC );
-}
-
-
-
-int eventSemaphore::check()
-   throw( eventSemaphore_Exception )
-{
-   eventSemaphore_Handle * H = M_Handle;
-   if( !H )
-      throw eventSemaphore_Exception();
-   DWORD dwRc;
-   dwRc = WaitForSingleObject( H->winH(), 0 );
-   switch(dwRc)
-   {
-   case 0:
-      // posted state
-      return 0;
-   case WAIT_TIMEOUT:
-      // reset state
-      return 1;
-   default:
-      // error?
-      return 2;
-   }
-}
-
-
-
-void eventSemaphore::post()
-   throw( eventSemaphore_Exception )
-{
-   eventSemaphore_Handle * H = M_Handle;
-   if( !H )
-      throw eventSemaphore_Exception();
-   if( SetEvent( H->winH() ) == 0 )
-      throw eventSemaphore_Exception();
-}
-
-
-
-void eventSemaphore::reset()
-   throw( eventSemaphore_Exception )
-{
-   eventSemaphore_Handle * H = M_Handle;
-   if( !H )
-      throw eventSemaphore_Exception();
-   if( ResetEvent( H->winH() ) == 0 )
-      throw eventSemaphore_Exception();
-}
-
-
-
-/**
- **************************************************************************
- * 
- * End of file
- * 
- **************************************************************************
-**/
-
diff --git a/Massai/cpp/CfgXMgrB/src/mHRTimerW32.cpp b/Massai/cpp/CfgXMgrB/src/mHRTimerW32.cpp
deleted file mode 100644
index 13e5184f..00000000
--- a/Massai/cpp/CfgXMgrB/src/mHRTimerW32.cpp
+++ /dev/null
@@ -1,100 +0,0 @@
-/**
- **************************************************************************
- * 
- * @file mHRTimerW32.cpp
- * 
- **************************************************************************
-**/
-
-#include "mHRTimer.h"
-
-#include <windows.h>
-#include <stdio.h>
-
-
-
-struct mHRTimer_
-{
-   LARGE_INTEGER TimeZero;
-   LARGE_INTEGER TimeDiv;
-   unsigned      Precision;
-   char const *  Format;
-};
-
-
-
-mHRTimer_Handle mHRTimer_Create( unsigned Digits )
-{
-   mHRTimer_ * H = new mHRTimer_;
-   QueryPerformanceCounter( &H->TimeZero );
-   QueryPerformanceFrequency( &H->TimeDiv );
-   switch( Digits )
-   {
-   default:
-      H->Precision = 1;
-      H->Format = "%02ld:%02ld:%02ld ";
-      break;
-   case 1:
-      H->Precision = 10;
-      H->Format = "%02ld:%02ld:%02ld.%01ld";
-      break;
-   case 2:
-      H->Precision = 100;
-      H->Format = "%02ld:%02ld:%02ld.%02ld";
-      break;
-   case 3:
-      H->Precision = 1000;
-      H->Format = "%02ld:%02ld:%02ld.%03ld";
-      break;
-   case 4:
-      H->Precision = 10000;
-      H->Format = "%02ld:%02ld:%02ld.%04ld";
-      break;
-   case 5:
-      H->Precision = 100000;
-      H->Format = "%02ld:%02ld:%02ld.%05ld";
-      break;
-   }
-   H->TimeDiv.QuadPart /= H->Precision;
-   return H;
-}
-
-
-
-void mHRTimer_Delete( mHRTimer_Handle Hdl )
-{
-   delete Hdl;
-}
-
-
-
-void mHRTimer_TimestampString( mHRTimer_Handle Hdl, char * Dst )
-{
-   LARGE_INTEGER Count;
-   QueryPerformanceCounter( &Count );
-   LONGLONG TimeOff = Count.QuadPart - Hdl->TimeZero.QuadPart;
-   unsigned long TimeMS = static_cast<unsigned long>
-                          ( TimeOff / Hdl->TimeDiv.QuadPart );
-   unsigned long TimeS = TimeMS / Hdl->Precision;
-   unsigned long TimeM = TimeS / 60;
-   unsigned long TimeH = TimeM / 60;
-   TimeH %= 24;
-   TimeM %= 60;
-   TimeS %= 60;
-   TimeMS %= Hdl->Precision;
-   sprintf
-   (
-      Dst, Hdl->Format,
-      TimeH,TimeM,TimeS,TimeMS
-   );
-}
-
-
-
-/**
- **************************************************************************
- * 
- * End of file
- * 
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgrB/src/mMutexSemW32.cpp b/Massai/cpp/CfgXMgrB/src/mMutexSemW32.cpp
deleted file mode 100644
index dd04c4c3..00000000
--- a/Massai/cpp/CfgXMgrB/src/mMutexSemW32.cpp
+++ /dev/null
@@ -1,130 +0,0 @@
-/**
- **************************************************************************
- *
- * @file mMutexSemW32.cpp
- * 
- * Contains the implementation for the methods defined in mMutexSem.hpp
- * for the Win32 platform.
- * 
- * @author JK
- * 
- * Copyright (c) 2002 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-
-#include "mMutexSem.hpp"
-
-#include "windows.h"
-
-
-
-namespace Materna
-{
-   namespace MSSD
-   {
-      
-      class mutexSemaphore_Handle
-      {
-         
-         HANDLE M_WinH;
-         
-      public:
-         
-         mutexSemaphore_Handle();
-         
-         explicit mutexSemaphore_Handle( char const * Name ) :
-            M_WinH( CreateMutex( 0, 0, Name ) )
-         {
-         }
-         
-         ~mutexSemaphore_Handle()
-         {
-            CloseHandle( M_WinH );
-            M_WinH = 0;
-         }
-
-         HANDLE winH() const
-         {
-            return M_WinH;
-         }
-         
-      };
-      
-   }
-}
-
-
-
-using namespace Materna::MSSD;
-
-
-
-mutexSemaphore::mutexSemaphore() :
-   M_Handle( new mutexSemaphore_Handle( 0 ) )
-{
-}
-
-
-
-mutexSemaphore::mutexSemaphore( char const * Name ) :
-   M_Handle( new mutexSemaphore_Handle( Name ) )
-{
-}
-
-
-
-mutexSemaphore::~mutexSemaphore()
-{
-   delete M_Handle;
-}
-
-
-
-void mutexSemaphore::request()
-   throw( mutexSemaphore_Exception )
-{
-   mutexSemaphore_Handle * H = M_Handle;
-   if( !H )
-      throw mutexSemaphore_Exception();
-   DWORD RC = WaitForSingleObject( H->winH(), INFINITE );
-   if( RC != WAIT_OBJECT_0 )
-      throw mutexSemaphore_Exception();
-}
-
-
-
-int mutexSemaphore::request( long Time )
-   throw( mutexSemaphore_Exception )
-{
-   mutexSemaphore_Handle * H = M_Handle;
-   if( !H )
-      throw mutexSemaphore_Exception();
-   DWORD RC = WaitForSingleObject( H->winH(), static_cast<DWORD>( Time ) );
-   if( RC == WAIT_OBJECT_0 )
-      return 0;
-   else
-      return static_cast<int>( RC );
-}
-
-
-
-void mutexSemaphore::release()
-   throw( mutexSemaphore_Exception )
-{
-   mutexSemaphore_Handle * H = M_Handle;
-   if( !H )
-      throw mutexSemaphore_Exception();
-   if( ReleaseMutex( H->winH() ) == 0 )
-      throw mutexSemaphore_Exception();
-}
-
-
-
-/**
- **************************************************************************
- * 
- * End of file
- * 
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgrB/src/mStringFile.cpp b/Massai/cpp/CfgXMgrB/src/mStringFile.cpp
deleted file mode 100644
index 404a413b..00000000
--- a/Massai/cpp/CfgXMgrB/src/mStringFile.cpp
+++ /dev/null
@@ -1,73 +0,0 @@
-/**
- **************************************************************************
- *
- * @file mStringFile.cpp
- *
- * Copy a standard string to file and vice versa.
- *
- * @author JK
- *
- * Copyright (c) 2004 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-
-
-
-#include "mStringFile.hpp"
-#include <fstream>
-
-
-
-/*
- *
- * Function implementation (see mStringFile.hpp).
- *
- */
-void mStringFromFile
-(
-   std::string &        Dst,
-   std::string const &  Filename
-)
-{
-   Dst.erase();
-   std::ifstream IS( Filename.c_str() );
-   if( IS )
-   {
-      char Buffer[0x10000];
-      while( IS.read( Buffer, sizeof(Buffer) ) )
-         Dst.append
-         (
-            Buffer,
-            static_cast<unsigned>( sizeof(Buffer) )
-         );
-      Dst.append( Buffer, IS.gcount() );
-   }
-}
-
-
-
-/*
- *
- * Function implementation (see mStringFile.hpp).
- *
- */
-void mStringToFile
-(
-   std::string const &  Filename,
-   std::string const &  Src
-)
-{
-   std::ofstream OS( Filename.c_str() );
-   OS << Src << std::flush;
-}
-
-
-
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
diff --git a/Massai/cpp/CfgXMgrB/src/matDaemonW32.cpp b/Massai/cpp/CfgXMgrB/src/matDaemonW32.cpp
deleted file mode 100644
index 5e55b8d1..00000000
--- a/Massai/cpp/CfgXMgrB/src/matDaemonW32.cpp
+++ /dev/null
@@ -1,564 +0,0 @@
-/**
- **************************************************************************
- *
- * @file matDaemonW32.cpp
- *
- * Windows-32 implementation for functions of matDaemon.h.
- *
- * @author JK
- *
- * Copyright (c) 2001-2002 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-// ts 08.05.2002 AUTOSTART option added
-
-#include "matDaemon.h"
-#include <fstream>
-using namespace std;
-#include "argScan.hpp"
-#include <iostream>
-#include <windows.h>
-
-
-
-namespace
-{
-   /**
-    ***********************************************************************
-    *
-    * Module-private part
-    *
-    ***********************************************************************
-   **/
-
-
-
-   /**
-    *
-    * Use the service name for display name as well.
-    *
-   **/
-   char const * mDaemon_getDisplayname()
-   {
-      return mDaemon_name();
-   }
-
-
-
-   /**
-    *
-    * Are we a console application?
-    *
-   **/
-   bool                    Console = false;
-
-
-
-   /**
-    *
-    * Current state of the service.
-    *
-   **/
-   SERVICE_STATUS          SState;
-
-
-
-   /**
-    *
-    * Handle to the current service state.
-    *
-   **/
-   SERVICE_STATUS_HANDLE   SStateHdl;
-
-
-
-   /**
-    *
-    * Module-private function.
-    *
-   **/
-   int indToSCM
-   (
-      DWORD dwCurrentState,
-      DWORD dwWin32ExitCode,
-      DWORD dwWaitHint
-   )
-   {
-      static DWORD dwCheckPoint = 1;
-      if( !Console )
-      {
-         if( dwCurrentState == SERVICE_START_PENDING )
-             SState.dwControlsAccepted = SERVICE_ACCEPT_SHUTDOWN;
-         else
-             SState.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
-
-         SState.dwCurrentState = dwCurrentState;
-         SState.dwWin32ExitCode = dwWin32ExitCode;
-         SState.dwWaitHint = dwWaitHint;
-
-         if
-         (
-            ( dwCurrentState == SERVICE_RUNNING ) ||
-            ( dwCurrentState == SERVICE_STOPPED )
-         )
-            SState.dwCheckPoint = 0;
-         else
-            SState.dwCheckPoint = dwCheckPoint++;
-
-         //
-         // Report the status of the service to the service control manager.
-         //
-         if( SetServiceStatus( SStateHdl, &SState ) )
-            return 0;
-         else
-         {
-            mDaemon_log( "SetServiceStatus" );
-            return 1;
-         }
-      }
-      else
-         return 0;
-   }
-
-
-
-   /**
-    *
-    * Module-private function.
-    *
-   **/
-   BOOL WINAPI console_ctrl ( DWORD Type )
-   {
-      switch( Type )
-      {
-      case CTRL_BREAK_EVENT:  // use Ctrl+C or Ctrl+Break to simulate
-      case CTRL_C_EVENT:      // SERVICE_CONTROL_STOP in debug mode
-         mDaemon_stop();
-         return TRUE;
-
-      default:
-         return FALSE;
-      }
-   }
-
-
-
-   /**
-    *
-    * Module-private function.
-    *
-   **/
-   VOID WINAPI service_ctrl(DWORD dwCtrlCode)
-   {
-
-       // Handle the requested control code.
-       //
-       switch(dwCtrlCode)
-       {
-           // Stop the service.
-           //
-           // SERVICE_STOP_PENDING should be reported before
-           // setting the Stop Event - hServerStopEvent - in
-           // ServiceStop().  This avoids a race condition
-           // which may result in a 1053 - The Service did not respond...
-           // error.
-           case SERVICE_CONTROL_STOP:
-               indToSCM(SERVICE_STOP_PENDING, NO_ERROR, 20000);
-               mDaemon_stop();
-               return;
-
-           // Update the service status.
-           //
-           case SERVICE_CONTROL_INTERROGATE:
-               break;
-
-
-           // Computer shutdown, cleanup
-
-           case SERVICE_CONTROL_SHUTDOWN:
-               indToSCM(SERVICE_STOP_PENDING, NO_ERROR, 20000);
-               mDaemon_stop();
-               return;
-
-
-           // invalid control code
-           //
-           default:
-               break;
-
-       }
-
-       indToSCM(SState.dwCurrentState, NO_ERROR, 0);
-   }
-
-
-
-   /**
-    *
-    * Module-private function.
-    *
-   **/
-   char const * lastError()
-   {
-      LPTSTR LocalBuffer = 0;
-      DWORD dwRet =
-         FormatMessage
-         (
-            FORMAT_MESSAGE_ALLOCATE_BUFFER |
-            FORMAT_MESSAGE_FROM_SYSTEM |
-            FORMAT_MESSAGE_ARGUMENT_ARRAY,
-            NULL,
-            GetLastError(),
-            LANG_NEUTRAL,
-            reinterpret_cast<LPTSTR>( &LocalBuffer ),
-            0,
-            NULL
-         );
-      if( LocalBuffer )
-      {
-         static string Return;
-         // supplied buffer is not long enough
-         if( !dwRet )
-            return "";
-         else
-         {
-            Return = " - ";
-            Return += LocalBuffer;
-         }
-         LocalFree( LocalBuffer );
-         return Return.c_str();
-      }
-      else
-         return "";
-   }
-
-
-
-   /**
-    *
-    * Module-private function.
-    *
-   **/
-   // ts 08.05.2002 AUTOSTART option added
-   int install(bool bAutoStart)
-   {
-      TCHAR szPath[512];
-      if( GetModuleFileName( NULL, szPath, 512 ) == 0 )
-      {
-         cout << "Unable to install "
-              << mDaemon_getDisplayname()
-              << lastError()
-              << endl;
-         return 1;
-      }
-
-      SC_HANDLE SCManagerHdl =
-         OpenSCManager
-         (
-            NULL,
-            NULL,
-            SC_MANAGER_ALL_ACCESS
-         );
-      if( SCManagerHdl )
-      {
-         SC_HANDLE ServiceHdl =
-            CreateService
-            (
-               SCManagerHdl,               // SCManager database
-               mDaemon_name(),             // name of service
-               mDaemon_getDisplayname(),   // name to display
-               SERVICE_ALL_ACCESS,         // desired access
-               SERVICE_WIN32_OWN_PROCESS,  // service type
-               // ts 08.05.2002 AUTOSTART option added
-               bAutoStart?SERVICE_AUTO_START:SERVICE_DEMAND_START, // start type
-               SERVICE_ERROR_NORMAL,       // error control type
-               szPath,                     // services binary
-               NULL,                       // no load ordering group
-               NULL,                       // no tag identifier
-               mDaemon_dependencies(),     // no dependencies
-               NULL,                       // LocalSystem account
-               NULL                        // no password
-            );
-         if( ServiceHdl )
-         {
-            cout << mDaemon_getDisplayname() << " installed."
-                 << endl;
-            CloseServiceHandle( ServiceHdl );
-            return 0;
-         }
-         else
-         {
-            cout << "CreateService" << lastError() << endl;
-         }
-         CloseServiceHandle( SCManagerHdl );
-      }
-      else
-         cout << "OpenSCManager" << lastError() << endl;
-      return 1;
-   }
-
-
-
-   /**
-    *
-    * Module-private function.
-    *
-   **/
-   int deinstall()
-   {
-      SC_HANDLE SCManagerHdl =
-         OpenSCManager
-         (
-            NULL,
-            NULL,
-            SC_MANAGER_ALL_ACCESS
-         );
-      if( SCManagerHdl )
-      {
-         SC_HANDLE ServiceHdl =
-            OpenService
-            (
-               SCManagerHdl,
-               mDaemon_name(),
-               SERVICE_ALL_ACCESS
-            );
-         if( ServiceHdl )
-         {
-            // try to stop the service
-            if
-            (
-               ControlService
-               (
-                  ServiceHdl,
-                  SERVICE_CONTROL_STOP,
-                  &SState
-               )
-            )
-            {
-               cout << "Stopping " << mDaemon_getDisplayname() << endl;
-               Sleep( 1000 );
-               bool More = true;
-               while( More && QueryServiceStatus( ServiceHdl, &SState ) )
-               {
-                  if( SState.dwCurrentState == SERVICE_STOP_PENDING )
-                  {
-                     cout << "." << flush;
-                     Sleep( 1000 );
-                  }
-                  else
-                     More = false;
-               }
-               if( SState.dwCurrentState == SERVICE_STOPPED )
-                  cout << mDaemon_getDisplayname() << " stopped." << endl;
-               else
-                  cout << mDaemon_getDisplayname()
-                       << " stop failed."
-                       << endl;
-            }
-            // now remove the service
-            if( DeleteService( ServiceHdl ) )
-               cout << mDaemon_getDisplayname() << " removed." << endl;
-            else
-               cout << "DeleteService" << lastError() << endl;
-            CloseServiceHandle( ServiceHdl );
-         }
-         else
-            cout << "OpenService" << lastError() << endl;
-         CloseServiceHandle( SCManagerHdl );
-      }
-      else
-         cout << "OpenSCManager" << lastError() << endl;
-      return 0;
-   }
-
-
-   /**
-    *
-    * Module-private function.
-    *
-   **/
-   void WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv)
-   {
-
-      //
-      // Register the service control handler
-      //
-      SStateHdl =
-         RegisterServiceCtrlHandler
-         (
-            mDaemon_name(),
-            service_ctrl
-         );
-      if( !SStateHdl )
-         return;
-
-      //
-      // SERVICE_STATUS members that dont change in example
-      //
-      SState.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
-      SState.dwServiceSpecificExitCode = 0;
-
-      //
-      // Report pending status to the service control manager.
-      //
-      if
-      (
-         indToSCM
-         (
-            SERVICE_START_PENDING, // service state
-            NO_ERROR,              // exit code
-            3000                   // wait hint
-         ) == 0
-      )
-      {
-         mDaemon_main( static_cast<int>( dwArgc ), lpszArgv );
-      }
-
-      //
-      // Report stopped status to the service control manager.
-      //
-      indToSCM( SERVICE_STOPPED, NO_ERROR, 0 );
-   }
-
-
-
-   /**
-    ***********************************************************************
-    *
-    * End of module-private part
-    *
-    ***********************************************************************
-   **/
-}
-
-
-
-/**
- *
- * (see mDaemon.h)
- *
-**/
-int mDaemon_indInitializing( unsigned long mSec )
-{
-   return indToSCM( SERVICE_START_PENDING, NO_ERROR, mSec );
-}
-
-
-
-/**
- *
- * (see mDaemon.h)
- *
-**/
-int mDaemon_indReady( unsigned long mSec )
-{
-   return( indToSCM( SERVICE_RUNNING, NO_ERROR, mSec ) );
-}
-
-
-
-/**
- *
- * (see mDaemon.h)
- *
-**/
-void mDaemon_log( char const * Data )
-{
-   if( !Console )
-   {
-      //
-      // Write to event log
-      //
-      HANDLE hEventSource = RegisterEventSource( NULL, mDaemon_name() );
-      if( hEventSource )
-      {
-         LPCTSTR Strings[1];
-         Strings[0] = Data;
-         ReportEvent
-         (
-            hEventSource,         // handle of event source
-            EVENTLOG_ERROR_TYPE,  // event type
-            0,                    // event category
-            0,                    // event ID
-            NULL,                 // current users SID
-            1,                    // strings in lpszStrings
-            0,                    // no bytes of raw data
-            Strings,              // array of error strings
-            0                     // no raw data
-         );
-         DeregisterEventSource(hEventSource);
-      }
-   }
-}
-
-
-
-/**
- **************************************************************************
- *
- * Standard main.
- *
- * @param argc Argument count
- *
- * @param argv Argument vector
- *
- * @return 0 if OK
- *
- **************************************************************************
-**/
-int main( int argc, char ** argv )
-{
-   argScan Arg( argc, argv );
-   if( Arg.help() )
-   {
-      // ts 08.05.2002 AUTOSTART option added
-      cout << "Usage: "
-           << argv[0]
-           << " [ -install [-autostart] | -deinstall | -console ";
-      if( mDaemon_help() )
-      {
-         cout << "<consoleparameter> ]\n"
-              << "       <consoleparameter> = "
-              << mDaemon_help() << endl;
-      }
-      else
-      {
-         cout << "]" << endl;
-      }
-      return 0;
-   }
-
-   if( Arg.option( "INSTALL" ) )
-      return install(Arg.option("AUTOSTART")!=0);// ts 08.05.2002 AUTOSTART option added
-
-   if( Arg.option( "DEINSTALL" ) )
-      return deinstall();
-
-   if( Arg.option( "CONSOLE" ) )
-   {
-      Console = true;
-      SetConsoleCtrlHandler( console_ctrl, true );
-      return mDaemon_main( argc, argv );
-   }
-
-   SERVICE_TABLE_ENTRY STE[2];
-   STE[0].lpServiceName = const_cast<char *>( mDaemon_name() );
-   STE[0].lpServiceProc = service_main;
-   STE[1].lpServiceName = 0;
-   STE[1].lpServiceProc = 0;
-   if( !StartServiceCtrlDispatcher( STE ) )
-      mDaemon_log( "StartServiceCtrlDispatcher failed." );
-   return 0;
-}
-
-
-
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
-
diff --git a/Massai/cpp/CfgXMgrB/src/matThreadW32.cpp b/Massai/cpp/CfgXMgrB/src/matThreadW32.cpp
deleted file mode 100644
index cd55c7b5..00000000
--- a/Massai/cpp/CfgXMgrB/src/matThreadW32.cpp
+++ /dev/null
@@ -1,580 +0,0 @@
-/**
- **************************************************************************
- *
- * @file matThreadW32.cpp
- *
- * Implements the functions defined in matThread.hpp for Win32
- * environment.
- *
- * @author JK
- *
- * Copyright (c) 2000 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-
-#include "matThread.hpp"
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <process.h>
-
-#include <windows.h>
-#include <winbase.h>
-
-
-
-#define TRACE_LEVEL_ERROR  1       // Major error
-#define TRACE_LEVEL_NORMAL 7       // Secondary runtime
-
-#define NT_MIN_STACK 65536
-
-
-
-static char * makeChild( char * Buf, char const * Src )
-{
-   sprintf( Buf, "child[%d]: %s", matThreadId(), Src );
-   return Buf;
-}
-
-
-
-static char * makeParent( char * Buf, char const * Src )
-{
-   sprintf( Buf, "parent[%d]: %s", matThreadId(), Src );
-   return Buf;
-}
-
-
-
-static matThreadRC win2rc( DWORD WErr )
-{
-   switch( WErr )
-   {
-   case ERROR_SUCCESS: return THREADRC_OK;
-   case WAIT_TIMEOUT:  return THREADRC_TIMEOUT;
-   default:            return THREADRC_ERROR;
-   }
-}
-
-
-
-/**
- **************************************************************************
- *
- * Handle class
- *
- **************************************************************************
-**/
-class matThread_Handle
-{
-
-   //! CLient trace function
-   matThreadTrace MH_Trace;
-
-   //! Refers the parent thread class
-   matThread *    MH_pPublic;
-
-public:
-
-   //! Win32 thread handle
-   HANDLE         MH_Handle;
-
-   //! Stack allocated for thread
-   long           MH_Stacksize;
-
-   //! Thread status
-   int            MH_Terminated;
-
-   //! Semaphore to control the start sequence
-   HANDLE         MH_StartSema;
-
-   /**
-    *
-    * Trace normal events
-    *
-   **/
-   void        traceNormal( char const * Text )
-               {
-                  if( MH_Trace )
-                  {
-                     char Buffer[256];
-                     MH_Trace( TRACE_LEVEL_NORMAL, makeParent( Buffer, Text ) );
-                  }
-               }
-
-   /**
-    *
-    * Trace error events
-    *
-   **/
-   void        traceError( char const * Text )
-               {
-                  if( MH_Trace )
-                  {
-                     char Buffer[256];
-                     MH_Trace( TRACE_LEVEL_ERROR, makeParent( Buffer, Text ) );
-                  }
-               }
-
-   /**
-    *
-    * Trace Win32 errors
-    *
-   **/
-   matThreadRC traceLastError( char const * Text )
-               {
-                  DWORD LE = GetLastError();
-                  if( MH_Trace )
-                  {
-                     char Buffer[256];
-                     char TBuffer[256];
-                     sprintf( TBuffer, "%s error %d", Text, LE );
-                     MH_Trace( TRACE_LEVEL_ERROR, makeParent( Buffer, TBuffer ) );
-                  }
-                  return win2rc( LE );
-               }
-
-   /**
-    *
-    * Thread function
-    *
-   **/
-   void        function()
-               {
-                  if( MH_Trace )
-                  {
-                     char Buffer[256];
-                     MH_Trace( TRACE_LEVEL_NORMAL, makeChild( Buffer, "call" ) );
-                               MH_pPublic->function();
-                     MH_Trace( TRACE_LEVEL_NORMAL, makeChild( Buffer, "return" ) );
-                  }
-                  else
-                     MH_pPublic->function();
-               }
-
-   /**
-    *
-    * Constructor
-    *
-    * @param IFObject Refers the parent thread class
-    *
-    * @param Stack    The thread stack
-    *
-    * @param Trace    The trace function to use (may be 0)
-    *
-   **/
-   matThread_Handle
-   (
-      matThread *              IFObject,
-      long                     Stack,
-      matThreadTrace           Trace
-    ) :
-      MH_Trace( Trace ),
-      MH_pPublic( IFObject ),
-      MH_Handle( 0 ),
-      MH_Stacksize( ( Stack > NT_MIN_STACK ) ? Stack : NT_MIN_STACK ),
-      MH_Terminated( 1 ),
-      MH_StartSema( CreateEvent( 0, TRUE, FALSE, 0 ) )
-   {
-      if( Trace )
-      {
-         char Buffer[256];
-         Trace( TRACE_LEVEL_NORMAL, makeParent( Buffer, "created" ) );
-      }
-   }
-
-   /**
-    *
-    * Standard constructor - intentionally not implemented.
-    *
-   **/
-   matThread_Handle();
-
-   /**
-    *
-    * Destructor
-    *
-   **/
-   ~matThread_Handle()
-   {
-      if( MH_Trace )
-      {
-         char Buffer[256];
-         MH_Trace( TRACE_LEVEL_NORMAL, makeParent( Buffer, "deleted" ) );
-      }
-   }
-
-};
-
-
-
-/**
- **************************************************************************
- *
- * Controls child thread execution.
- *
- * @param pV "void" pointer to handle class
- *
- **************************************************************************
-**/
-#ifdef __IBMCPP__
-static void _Optlink privateEnterThreadC( void * pV )
-#else
-static void __cdecl privateEnterThreadC( void * pV )
-#endif
-{
-   matThread_Handle *pPara = (matThread_Handle *)pV;
-   SetEvent( pPara->MH_StartSema );
-   pPara->MH_Terminated = 0;
-   pPara->function();
-   pPara->MH_Terminated = 1;
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThread::matThread( long stacksize ) :
-   M_Handle( 0 )
-{
-   M_Handle = new matThread_Handle( this, stacksize, 0 );
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThread::matThread( matThreadTrace Trace, long stacksize ) :
-   M_Handle( 0 )
-{
-   M_Handle = new matThread_Handle( this, stacksize, Trace );
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThread::~matThread()
-{
-   M_Handle->traceNormal( "~matThread ..." );
-   if( M_Handle->MH_Handle )
-   {
-      if( !M_Handle->MH_Terminated )
-      {
-        M_Handle->traceNormal( "~matThread - terminate" );
-        TerminateThread( M_Handle->MH_Handle, 13 );
-      }
-      CloseHandle( M_Handle->MH_Handle );
-   }
-
-   //@@MaK CloseHandle( M_Handle->MH_StartSema );
-   M_Handle->traceNormal( "~matThread." );
-   delete M_Handle;
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThreadRC matThread::start( matThreadPrty Prty )
-{
-   if( M_Handle->MH_Handle )
-   {
-      if( !M_Handle->MH_Terminated )
-      {
-         //
-         // Thread currently running - do not start twice
-         //
-         M_Handle->traceError( "start - ignored" );
-         return THREADRC_ERROR;
-      }
-      CloseHandle( M_Handle->MH_Handle );
-      M_Handle->MH_Handle = 0;
-   }
-
-#ifdef __IBMCPP__
-   HANDLE NewHandle = (HANDLE)_beginthread
-                      (
-                         privateEnterThreadC,
-                         NULL,
-                         M_Handle->MH_Stacksize,
-                         M_Handle
-                      );
-#else
-   HANDLE NewHandle = (HANDLE)_beginthread
-                      (
-                         privateEnterThreadC,
-                         M_Handle->MH_Stacksize,
-                         M_Handle
-                      );
-#endif
-   if( NewHandle == 0 )
-   {
-      return M_Handle->traceLastError( "start - CreateThread" );
-   }
-#if 0 //@@MaK
-   if
-   (
-      !DuplicateHandle
-      (
-         GetCurrentProcess(), NewHandle,
-         GetCurrentProcess(), &M_Handle->MH_Handle,
-         0, FALSE, DUPLICATE_SAME_ACCESS
-      )
-   )
-   {
-      return M_Handle->traceLastError( "start - DuplicateHandle" );
-   }
-#else
-   M_Handle->MH_Handle = NewHandle;
-#endif
-
-   M_Handle->traceNormal( "start - waiting" );
-   WaitForSingleObject( M_Handle->MH_StartSema, INFINITE );
-
-   //@@MaK
-   CloseHandle( M_Handle->MH_StartSema );
-
-   Sleep( 1 );
-   M_Handle->traceNormal( "start" );
-   switch( Prty )
-   {
-   default:
-      return THREADRC_OK;
-   case THREADPRTY_HIGH:
-      if
-      (
-         SetThreadPriority
-         (
-            M_Handle->MH_Handle,
-            THREAD_PRIORITY_ABOVE_NORMAL
-         )
-      ) return THREADRC_OK;
-      else return M_Handle->traceLastError( "start - SetThreadPriority" );
-   case THREADPRTY_LOW:
-      if
-      (
-         SetThreadPriority
-         (
-            M_Handle->MH_Handle,
-            THREAD_PRIORITY_BELOW_NORMAL
-         )
-      ) return THREADRC_OK;
-      else return M_Handle->traceLastError( "start - SetThreadPriority" );
-   }
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThreadRC matThread::stop()
-{
-   if( M_Handle->MH_Handle == 0 )
-   {
-      //
-      // Thread currently not running - cannot stop it
-      //
-      M_Handle->traceError( "stop - error" );
-      return THREADRC_ERROR;
-   }
-   M_Handle->traceNormal( "stop" );
-   TerminateThread( M_Handle->MH_Handle, 12 );
-   CloseHandle( M_Handle->MH_Handle );
-   M_Handle->MH_Handle = 0;
-   M_Handle->MH_Terminated = 1;
-   return THREADRC_OK;
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThreadRC matThread::waitTerminated()
-{
-   return waitTerminated( INFINITE );
-}
-
-
-
-/**
- *
- * Interface class method implementation
- *
-**/
-matThreadRC matThread::waitTerminated( long Time )
-{
-   M_Handle->traceNormal( "waitTerminated ..." );
-   int RC = WaitForSingleObject( M_Handle->MH_Handle, Time );
-   switch( RC )
-   {
-   default:
-      M_Handle->traceNormal( "waitTerminated - error." );
-      return THREADRC_ERROR;
-   case WAIT_TIMEOUT:
-      M_Handle->traceNormal( "waitTerminated - timeout." );
-      return THREADRC_TIMEOUT;
-   case ERROR_SUCCESS:
-      M_Handle->traceNormal( "waitTerminated." );
-      return THREADRC_OK;
-   }
-}
-
-
-
-/**
- *
- * Handle parameters to the thread function
- *
-**/
-struct privatePara
-{
-
-   //! Client function pointer
-   matThreadF     pFunc;
-
-   //! Client function parameters
-   void *         FuncPara;
-
-   //! Client trace function
-   matThreadTrace Trace;
-
-};
-
-
-
-/**
- **************************************************************************
- *
- * Thread function
- *
- * @param pV "void" pointer to handle structure
- *
- **************************************************************************
-**/
-#ifdef __IBMCPP__
-static void _Optlink privateEnterThreadF( void * pV )
-#else
-static void __cdecl privateEnterThreadF( void * pV )
-#endif
-{
-   privatePara * pP = (privatePara *)pV;
-   if( pP->Trace )
-   {
-      char Buf[64];
-      sprintf( Buf, "[%d] ...", GetCurrentThreadId() );
-      pP->Trace( TRACE_LEVEL_NORMAL, Buf );
-   }
-   pP->pFunc( pP->FuncPara );
-   if( pP->Trace )
-   {
-      char Buf[64];
-      sprintf( Buf, "[%d].", GetCurrentThreadId() );
-      pP->Trace( TRACE_LEVEL_NORMAL, Buf );
-   }
-   delete pV;
-}
-
-
-
-/**
- *
- * Interface function implementation
- *
-**/
-matThreadRC matThreadFStart
-(
-   matThreadF     ThreadF,
-   void *         ThreadFParameter,
-   long           Stack,
-   matThreadTrace Trace
-)
-{
-   HANDLE H;
-   privatePara * pP = new privatePara;
-   pP->pFunc = ThreadF;
-   pP->FuncPara = ThreadFParameter;
-   pP->Trace = Trace;
-#ifdef __IBMCPP__
-   H = (HANDLE)_beginthread
-       (
-          privateEnterThreadF,
-          NULL,
-          (Stack > NT_MIN_STACK) ? Stack : NT_MIN_STACK,
-          pP
-       );
-#else
-   H = (HANDLE)_beginthread
-       (
-          privateEnterThreadF,
-          (Stack > NT_MIN_STACK) ? Stack : NT_MIN_STACK,
-          pP
-       );
-#endif
-   if( H == (HANDLE)-1 )
-   {
-      if( Trace ) Trace( TRACE_LEVEL_ERROR, "matThreadFStart failed" );
-      return win2rc( GetLastError() );
-   }
-   else
-   {
-      if( Trace )
-      {
-         char Buf[64];
-         sprintf( Buf, "matThreadFStart" );
-         Trace( TRACE_LEVEL_NORMAL, Buf );
-      }
-      return THREADRC_OK;
-   }
-}
-
-
-
-/**
- *
- * Interface function implementation
- *
-**/
-long matThreadId()
-{
-   return GetCurrentThreadId();
-}
-
-
-
-/**
- *
- * Interface function implementation
- *
-**/
-void matThreadSleep( long milliSeconds )
-{
-   Sleep( milliSeconds );
-}
-
-
-
-//-------------------------------------------------------------------------
-//
-// End of file
-//
-//-------------------------------------------------------------------------
diff --git a/Massai/cpp/CfgXMgrB/src/writeTraceIF.cpp b/Massai/cpp/CfgXMgrB/src/writeTraceIF.cpp
deleted file mode 100644
index 4511912b..00000000
--- a/Massai/cpp/CfgXMgrB/src/writeTraceIF.cpp
+++ /dev/null
@@ -1,79 +0,0 @@
-/**
- **************************************************************************
- *
- * @file writeTraceIF.cpp
- *
- * Trace function implementation for configuration server.
- *
- * @author Juergen Kreierhoff
- *
- * Copyright (c) 2002 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-
-#include "writeTraceIF.hpp"
-
-#include "mMutexSem.hpp"
-#include "mHRTimer.h"
-
-#include "TraceClt.h"
-
-#include <stdarg.h>
-#include <stdio.h>
-
-
-
-namespace
-{
-
-   mHRTimer        S_Timer;
-   long            S_Level = 0;
-   std::ostream *  S_Stream = 0;
-}
-
-
-
-long _stdcall writeTrace
-(
-   long Level,
-   char const *, short, char const *,
-   char const * Format, ...
-)
-{
-   if( Level <= S_Level )
-   {
-      static Materna::MSSD::mutexSemaphore X;
-      X.request();
-      va_list Arg;
-      char String[4096];
-      va_start( Arg, Format );
-      vsprintf( String, Format, Arg );
-      va_end( Arg );
-      char Time[20];
-      S_Timer.timestampString( Time );
-      *S_Stream << "[" << Level << "]" << Time << ": " << String << std::endl;
-      X.release();
-   }
-   return 0;
-}
-
-
-
-
-
-void writeTrace_Init( std::ostream & Stream, long Level )
-{
-   S_Level = Level;
-   S_Stream = &Stream;
-}
-
-
-
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
diff --git a/Massai/cpp/Controller/inc/TRACE.H b/Massai/cpp/Controller/inc/TRACE.H
deleted file mode 100644
index d206fb79..00000000
--- a/Massai/cpp/Controller/inc/TRACE.H
+++ /dev/null
@@ -1,31 +0,0 @@
-/*---------------------------------------------------------------------------
-
- FILE:      trace.h
-
- PURPOSE:   Class definition.
-
- DATE:      12/02/96 - 11:55:07
-
- AUTHOR:    Dr. Materna GmbH   (AGe)
-
----------------------------------------------------------------------------*/
-
-#ifndef TRACE_H
-#define TRACE_H
-
-#include "traceClt.h"
-
-#define TRACE writeTrace
-#define DUMP  dumpTrace
-
-#ifdef HERE
-  #undef HERE
-#endif
-
-#define HERE 0, __FILE__, __LINE__, ""
-
-#endif // TRACE_H
-
-/*---------------------------------------------------------------------------
- END OF FILE
----------------------------------------------------------------------------*/
diff --git a/Massai/cpp/Controller/inc/VERSION.H b/Massai/cpp/Controller/inc/VERSION.H
deleted file mode 100644
index 7ea2bd77..00000000
--- a/Massai/cpp/Controller/inc/VERSION.H
+++ /dev/null
@@ -1,26 +0,0 @@
-/****************************************************************************
-
- FILE:      version.h
-
- PURPOSE:   version header module
-
- DATE:      10.05.2001 14:00
-
- AUTHOR:    Dr. Materna GmbH (VP)
-
- HISTORY
-
-  14.08.01  V01.00.00 MaK  Added version information, set working directory
-
-****************************************************************************/
-
-#ifndef VERSION_H
-#define VERSION_H
-
-#define VERSION "01"
-#define SUBVER  "00"
-#define RELEASE "00"
-
-char _ATSAVersion[] = "$Materna$Ver$Rel$Rev: " VERSION "." SUBVER "." RELEASE", "__DATE__ ", "__TIME__;
-
-#endif
diff --git a/Massai/cpp/Controller/inc/argScan.hpp b/Massai/cpp/Controller/inc/argScan.hpp
deleted file mode 100644
index 0e3446c7..00000000
--- a/Massai/cpp/Controller/inc/argScan.hpp
+++ /dev/null
@@ -1,327 +0,0 @@
-/**
- **************************************************************************
- * 
- * @file argScan.hpp
- * 
- * Contains inline class argScan
- * 
- * @note please include either <fstream> or <ftream.h> as well.
- * 
- * @author JK
- * 
- * Copyright (c) 1998-2000 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef ARGSCAN_HPP
-#define ARGSCAN_HPP
-
-#include <stdlib.h>
-
-/**
- * 
- * Commandline argument scanner class.
- * 
-**/
-class argScan
-{
-   
-   //! Copy of main-argc
-   int          M_ArgC;
-   
-   //! Copy of main-argv
-   char **      M_ArgV;
-   
-   //! Name of file with additional parameters (0, if none)
-   char const * M_Filename;
-   
-public:
-   
-   /**
-    * 
-    * Constructor
-    * 
-    * @param argc Please provide argc from main().
-    * 
-    * @param argv Please provide argv from main().
-    * 
-   **/
-   argScan( int argc, char ** argv )
-      : M_ArgC( argc ), M_ArgV( argv ), M_Filename( 0 )
-   {
-   }
-
-   /**
-    * 
-    * Standard constructor - intentionally not implemented.
-    * 
-   **/
-   argScan();
-   
-   /**
-    * 
-    * Copy constructor - intentionally not implemented.
-    * 
-   **/
-   argScan( argScan const & );
-   
-   /**
-    * 
-    * Assignment operator - intentionally not implemented.
-    * 
-   **/
-   argScan & operator=( argScan const & );
-
-   /**
-    * 
-    * Give the name of a file with additional parameters.
-    * The file is supposed to contain one parameter per line.
-    *
-    * @param File path and name
-    * 
-   **/
-   void file( char const * pszM_Filename )
-   {
-      M_Filename = pszM_Filename;
-   }
-
-   /**
-    * 
-    * Retrieve a string argument by argument index. Every parameter, which
-    * is not an option (see option() method), is an argument. The command
-    * itself is retrieved with the index 0. The first non-option argument
-    * would be returned with the index 1. If the index exceeds the number
-    * of arguments, the 0 pointer is returned.
-    * If a parameter file (see file() method) is given, every non-empty
-    * line of the parameter file is returned as an argument. Index counting
-    * for a parameter file starts after the last index for commandline
-    * arguments.
-    *
-    * @param Index Argument index.
-    * 
-    * @return Argument string.
-    * 
-   **/
-   char const * argument( int Index ) const
-   {
-      int M_ArgCount = 0;           // Counts the non-special arguments
-      int AllCount = 0;             // Counts all commandline arguments
-      //
-      // Check the commandline parameters
-      //
-      while( AllCount < M_ArgC )
-      {
-         char *pArg = M_ArgV[AllCount];
-         if( (*pArg == '-') || (*pArg == '/') )
-         {
-            //
-            // Skip special arguments
-            //
-            ++AllCount;
-         }
-         else
-         {
-            //
-            // These we are interested in
-            //
-            if( M_ArgCount == Index )
-            {
-               //
-               // This has the index wanted
-               //
-               return pArg;
-            }
-            ++M_ArgCount;
-            ++AllCount;
-         }
-      }
-      //
-      // Check for an input file
-      //
-      if( M_Filename )
-      {
-         ifstream I( M_Filename );
-         static char Buffer[256];
-         for(;;)
-         {
-            // read a line
-            I.getline( Buffer, sizeof(Buffer) - 1 );
-            if( I )
-            {
-               if( Buffer[0] )
-               {
-                  // We have got a non-empty line (empty lines ignored)
-                  if( M_ArgCount == Index )
-                  {
-                     // Line index matches
-                     Buffer[sizeof(Buffer) - 1] = 0;
-                     return Buffer;
-                  }
-                  ++M_ArgCount;
-               }
-            }
-            else
-               // At end-of-file -> no success
-               return 0;
-         }
-      }
-      return 0;
-   }
-
-   /**
-    * 
-    * Retrieve an integer argument by argument index. For indexes and
-    * parameterfiles see argument() method.
-    * If the index exceeds the number of arguments, the default value
-    * is returned.
-    * 
-    * @param Index Argument index.
-    * 
-    * @param Default The value to be returned in case of failure.
-    * 
-    * @return Argument value.
-    * 
-   **/
-   int argumentInteger( int Index, int Default = 0 ) const
-   {
-      char const * String = argument( Index );
-      if( String )
-         Default = atoi( String );
-      return Default;
-   }
-
-   /**
-    * 
-    * Retrieve a string option by option key. An option is supposed to look
-    * like "-<key>[:<value>]" or "/<key>[:<value>]" i.e. the "/", "-" and
-    * ":" characters are treated specially.
-    * The key string should be given in upper-case only, commandline
-    * parameter evaluation then is not case-sensitive.
-    * If an option key not found, the 0 pointer is returned.
-    *
-    * @param Key Option key (without leading "-" or "/").
-    * 
-    * @return Option string (all after the ":") or
-    *         0, if option not found or
-    *         the "" string (length 0), if no option value is specified.
-    * 
-   **/
-   char const *option( char const * Key ) const
-   {
-      int cnt = 1;
-      while( cnt < M_ArgC )
-      {
-         char const *pArg = M_ArgV[cnt];
-         if( (*pArg == '-') || (*pArg == '/') )
-         {
-            ++pArg;
-            char const *pP = Key;
-            int Equal = 1;
-            while( *pP && Equal )
-            {
-               char X = *pArg;
-               if( ( X >= 'a' ) && ( X <= 'z' ) ) X &= ~0x20;
-               if( X != *pP )
-                  Equal = 0;
-               ++pP;
-               ++pArg;
-            }
-            if( Equal )
-            {
-               while( *pArg && ( *pArg != ':' ) ) ++pArg;
-               if( *pArg ) ++pArg;
-               return pArg;
-            }
-         }
-         ++cnt;
-      }
-      return 0;
-   }
-
-   /**
-    *
-    * Retrieve an integer option by option key.
-    * Works like the option() method and argumentInteger() method combined.
-    * 
-    * @param Key Option key (without leading "-" or "/").
-    * 
-    * @param Default The value to be returned in case of failure.
-    * 
-    * @return Option value.
-    * 
-   **/
-   int optionInteger( char const * Key, int Default = 0 ) const
-   {
-      char const * String = option( Key);
-      if( String )
-         Default = atoi( String );
-      return Default;
-   }
-   
-   /**
-    * 
-    * Retrieve a hexadecimal integer option by option key.
-    * Works like optionInteger(), but expects the parameter in hexadecimal
-    * notation (e.g. "affe" or "0E")
-    * 
-    * @param Key Option key (without leading "-" or "/").
-    * 
-    * @param Default The value to be returned in case of failure.
-    * 
-    * @return Option value.
-    * 
-   **/
-   int optionInteger16( char const * Key, int Default = 0 ) const
-   {
-      char const * String = option( Key );
-      if( String )
-      {
-         Default = 0;
-         while( *String )
-         {
-            int C = (int)*String++;
-            if( C >= 'A' )
-               C = (C & 0x0F) + 9;
-            else
-               C = C & 0x0F;
-            Default = Default * 0x10 + C;
-         }
-      }
-      return Default;
-   }
-   
-   /**
-    * 
-    * Checks the existence of commandline parameters.
-    * 
-    * @return 1 if commandline contains no parameters, 0 else.
-    * 
-   **/
-   int none() const
-   {
-      return M_ArgC == 1;
-   }
-
-   /**
-    * 
-    * Checks the existence of commandline help patterns.
-    * 
-    * @return 1, if help desired, 0 if not.
-    * 
-   **/
-   int help() const
-   {
-      return option( "HELP" ) || option( "?" );
-   }
-
-};
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
-
diff --git a/Massai/cpp/Controller/inc/matDaemon.h b/Massai/cpp/Controller/inc/matDaemon.h
deleted file mode 100644
index 134a6e2c..00000000
--- a/Massai/cpp/Controller/inc/matDaemon.h
+++ /dev/null
@@ -1,108 +0,0 @@
-/**
- **************************************************************************
- *
- * @file mDaemon.h
- *
- * Interface to mDaemon functions.
- *
- * @author JK
- *
- * Copyright (c) 2001 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-#ifndef MDAEMON_H
-#define MDAEMON_H
-
-#include <windows.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-  /**
-    *
-    * List of services that must start before this service
-    * This function is implemented by the service-specific part of the daemon.
-    *
-   **/
-   char const * mDaemon_dependencies();
-   /**
-    *
-    * Give command-line parameters help.
-    * This function is implemented by the service-specific part of the daemon.
-    *
-   **/
-   char const * mDaemon_help();
-
-   /**
-    *
-    * Get the name for the daemon process.
-    * This function is implemented by the service-specific part of the daemon.
-    *
-   **/
-   char const * mDaemon_name();
-
-   /**
-    *
-    * Run the daemon process.
-    * This function is implemented by the service-specific part of the daemon.
-    *
-   **/
-   //int mDaemon_main( int argc, char ** argv );
-   int mDaemon_main(HINSTANCE hInst, HINSTANCE hPreInst, char *szCmdLine, int iCmdShow);
-
-
-   /**
-    *
-    * Stop the daemon process.
-    * This function is implemented by the service-specific part of the daemon.
-    *
-   **/
-   void mDaemon_stop( void );
-
-   /**
-    *
-    * This function is called by the service-specific part of the daemon
-    * to indicate the service is initializing.
-    *
-   **/
-   int mDaemon_indInitializing( unsigned long mSec );
-
-   /**
-    *
-    * This function is called by the service-specific part of the daemon
-    * to indicate the service is ready for operation.
-    *
-   **/
-   int mDaemon_indReady( unsigned long mSec );
-
-   /**
-    *
-    * This function is called by the service-specific part of the daemon
-    * to write an application event.
-    *
-   **/
-   void mDaemon_log( char const * Data );
-
-   /**
-    *
-    * This function is called by the service-specific part of the daemon
-    * to check if the process is running as service
-    *
-   **/
-   int mDaemon_isService();
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
-
diff --git a/Massai/cpp/Controller/src/matDaemonW32.cpp b/Massai/cpp/Controller/src/matDaemonW32.cpp
deleted file mode 100644
index fd0bb7d9..00000000
--- a/Massai/cpp/Controller/src/matDaemonW32.cpp
+++ /dev/null
@@ -1,624 +0,0 @@
-/**
- **************************************************************************
- *
- * @file mDaemonW32.cpp
- *
- * Windows-32 implementation for functions of mDaemon.h.
- *
- * @author JK
- *
- * Copyright (c) 2001 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-
-
-#include "matDaemon.h"
-#include <fstream>
-using namespace std;
-#include "argScan.hpp"
-#include <iostream>
-#include <windows.h>
-
-
-
-namespace
-{
-   /**
-    ***********************************************************************
-    *
-    * Module-private part
-    *
-    ***********************************************************************
-   **/
-
-
-
-   /**
-    *
-    * Use the service name for display name as well.
-    *
-   **/
-   char const * mDaemon_getDisplayname()
-   {
-      return mDaemon_name();
-   }
-
-
-
-   /**
-    *
-    * Are we a console application?
-    * (by default YES !! - AGe)
-    * (by default no - SteT)
-   **/
-   bool                    Console = false;
-
-
-
-   /**
-    *
-    * Current state of the service.
-    *
-   **/
-   SERVICE_STATUS          SState;
-
-
-
-   /**
-    *
-    * Handle to the current service state.
-    *
-   **/
-   SERVICE_STATUS_HANDLE   SStateHdl;
-
-
-
-   /**
-    *
-    * Module-private function.
-    *
-   **/
-   int indToSCM
-   (
-      DWORD dwCurrentState,
-      DWORD dwWin32ExitCode,
-      DWORD dwWaitHint
-   )
-   {
-      static DWORD dwCheckPoint = 1;
-      if( !Console )
-      {
-         if( dwCurrentState == SERVICE_START_PENDING )
-             SState.dwControlsAccepted = 0;
-         else
-             SState.dwControlsAccepted = SERVICE_ACCEPT_STOP;
-
-         SState.dwCurrentState = dwCurrentState;
-         SState.dwWin32ExitCode = dwWin32ExitCode;
-         SState.dwWaitHint = dwWaitHint;
-
-         if
-         (
-            ( dwCurrentState == SERVICE_RUNNING ) ||
-            ( dwCurrentState == SERVICE_STOPPED )
-         )
-            SState.dwCheckPoint = 0;
-         else
-            SState.dwCheckPoint = dwCheckPoint++;
-
-         //
-         // Report the status of the service to the service control manager.
-         //
-         if( SetServiceStatus( SStateHdl, &SState ) )
-            return 0;
-         else
-         {
-            mDaemon_log( "SetServiceStatus" );
-            return 1;
-         }
-      }
-      else
-         return 0;
-   }
-
-
-
-   /**
-    *
-    * Module-private function.
-    *
-   **/
-   BOOL WINAPI console_ctrl ( DWORD Type )
-   {
-      switch( Type )
-      {
-      case CTRL_BREAK_EVENT:  // use Ctrl+C or Ctrl+Break to simulate
-      case CTRL_C_EVENT:      // SERVICE_CONTROL_STOP in debug mode
-         mDaemon_stop();
-         return TRUE;
-
-      default:
-         return FALSE;
-      }
-   }
-
-
-
-   /**
-    *
-    * Module-private function.
-    *
-   **/
-   VOID WINAPI service_ctrl(DWORD dwCtrlCode)
-   {
-       // Handle the requested control code.
-       //
-       switch(dwCtrlCode)
-       {
-           // Stop the service.
-           //
-           // SERVICE_STOP_PENDING should be reported before
-           // setting the Stop Event - hServerStopEvent - in
-           // ServiceStop().  This avoids a race condition
-           // which may result in a 1053 - The Service did not respond...
-           // error.
-           case SERVICE_CONTROL_STOP:
-               indToSCM(SERVICE_STOP_PENDING, NO_ERROR, 0);
-               mDaemon_stop();
-               return;
-
-           // Update the service status.
-           //
-           case SERVICE_CONTROL_INTERROGATE:
-               break;
-
-           // invalid control code
-           //
-           default:
-               break;
-
-       }
-
-       indToSCM(SState.dwCurrentState, NO_ERROR, 0);
-   }
-
-
-
-   /**
-    *
-    * Module-private function.
-    *
-   **/
-   char const * lastError()
-   {
-      LPTSTR lpszTemp = 0;
-      DWORD dwRet =
-         FormatMessage
-         (
-            FORMAT_MESSAGE_ALLOCATE_BUFFER |
-            FORMAT_MESSAGE_FROM_SYSTEM |
-            FORMAT_MESSAGE_ARGUMENT_ARRAY,
-            NULL,
-            GetLastError(),
-            LANG_NEUTRAL,
-            (LPTSTR)&lpszTemp,
-            0,
-            NULL
-         );
-      if( lpszTemp )
-      {
-         static string Return;
-         // supplied buffer is not long enough
-         if( !dwRet )
-            return "";
-         else
-         {
-            Return = " - ";
-            Return += lpszTemp;
-         }
-         LocalFree((HLOCAL) lpszTemp );
-         return Return.c_str();
-      }
-      else
-         return "";
-   }
-
-
-
-   /**
-    *
-    * Module-private function.
-    *
-   **/
-   int install(const char* dependency, bool bAutoStart)
-   {
-      TCHAR szPath[512];
-      string dependencies;
-      bool bUseDep;
-      if (dependency)
-      {
-        dependencies= dependency;
-        dependencies+= '\0';
-        dependencies+= '\0';
-        bUseDep= true;
-      }
-      else
-        bUseDep= false;
-      if( GetModuleFileName( NULL, szPath, 512 ) == 0 )
-      {
-         cout << "Unable to install "
-              << mDaemon_getDisplayname()
-              << lastError()
-              << endl;
-         return 1;
-      }
-
-      SC_HANDLE SCManagerHdl =
-         OpenSCManager
-         (
-            NULL,
-            NULL,
-            SC_MANAGER_ALL_ACCESS
-         );
-      if( SCManagerHdl )
-      {
-         std::cout << (bUseDep?dependencies.c_str():mDaemon_dependencies()) << std::endl;
-         SC_HANDLE ServiceHdl =
-            CreateService
-            (
-               SCManagerHdl,               // SCManager database
-               mDaemon_name(),             // name of service
-               mDaemon_getDisplayname(),   // name to display
-               SERVICE_ALL_ACCESS,         // desired access
-               SERVICE_WIN32_OWN_PROCESS|SERVICE_INTERACTIVE_PROCESS,  // service type
-               bAutoStart?SERVICE_AUTO_START:SERVICE_DEMAND_START, // start type
-               SERVICE_ERROR_NORMAL,       // error control type
-               szPath,                     // services binary
-               NULL,                       // no load ordering group
-               NULL,                       // no tag identifier
-               bUseDep?dependencies.data():mDaemon_dependencies(),     // use command line dependencies or default dependencies
-               NULL,                       // LocalSystem account
-               NULL                        // no password
-            );
-         if( ServiceHdl )
-         {
-            cout << mDaemon_getDisplayname() << " installed."
-                 << endl;
-            CloseServiceHandle( ServiceHdl );
-            return 0;
-         }
-         else
-         {
-            cout << "CreateService" << lastError() << endl;
-         }
-         CloseServiceHandle( SCManagerHdl );
-      }
-      else
-         cout << "OpenSCManager" << lastError() << endl;
-      return 1;
-   }
-
-
-
-   /**
-    *
-    * Module-private function.
-    *
-   **/
-   int deinstall()
-   {
-      SC_HANDLE SCManagerHdl =
-         OpenSCManager
-         (
-            NULL,
-            NULL,
-            SC_MANAGER_ALL_ACCESS
-         );
-      if( SCManagerHdl )
-      {
-         SC_HANDLE ServiceHdl =
-            OpenService
-            (
-               SCManagerHdl,
-               mDaemon_name(),
-               SERVICE_ALL_ACCESS
-            );
-         if( ServiceHdl )
-         {
-            // try to stop the service
-            if
-            (
-               ControlService
-               (
-                  ServiceHdl,
-                  SERVICE_CONTROL_STOP,
-                  &SState
-               )
-            )
-            {
-               cout << "Stopping " << mDaemon_getDisplayname() << endl;
-               Sleep( 1000 );
-               bool More = true;
-               while( More && QueryServiceStatus( ServiceHdl, &SState ) )
-               {
-                  if( SState.dwCurrentState == SERVICE_STOP_PENDING )
-                  {
-                     cout << "." << flush;
-                     Sleep( 1000 );
-                  }
-                  else
-                     More = false;
-               }
-               if( SState.dwCurrentState == SERVICE_STOPPED )
-                  cout << mDaemon_getDisplayname() << " stopped." << endl;
-               else
-                  cout << mDaemon_getDisplayname()
-                       << " stop failed."
-                       << endl;
-            }
-            // now remove the service
-            if( DeleteService( ServiceHdl ) )
-               cout << mDaemon_getDisplayname() << " removed." << endl;
-            else
-               cout << "DeleteService" << lastError() << endl;
-            CloseServiceHandle( ServiceHdl );
-         }
-         else
-            cout << "OpenService" << lastError() << endl;
-         CloseServiceHandle( SCManagerHdl );
-      }
-      else
-         cout << "OpenSCManager" << lastError() << endl;
-      return 0;
-   }
-
-
-   /**
-    *
-    * Module-private function.
-    *
-   **/
-   void WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv)
-   {
-      // 15.10.2005 AGe
-
-      Console = false;
-
-      //
-      // Register the service control handler
-      //
-      SStateHdl =
-         RegisterServiceCtrlHandler
-         (
-            mDaemon_name(),
-            service_ctrl
-         );
-      if( !SStateHdl )
-         return;
-
-      //
-      // SERVICE_STATUS members that dont change in example
-      //
-      SState.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
-      SState.dwServiceSpecificExitCode = 0;
-
-      //
-      // Report pending status to the service control manager.
-      //
-      if
-      (
-         indToSCM
-         (
-            SERVICE_START_PENDING, // service state
-            NO_ERROR,              // exit code
-            3000                   // wait hint
-         ) == 0
-      )
-      {
-         //mDaemon_main( dwArgc, lpszArgv );
-         mDaemon_main(GetModuleHandle(0), 0, GetCommandLine(), SW_SHOWNORMAL);
-      }
-
-      //
-      // Report stopped status to the service control manager.
-      //
-      indToSCM( SERVICE_STOPPED, NO_ERROR, 0 );
-   }
-
-
-
-   /**
-    ***********************************************************************
-    *
-    * End of module-private part
-    *
-    ***********************************************************************
-   **/
-}
-
-
-
-/**
- *
- * (see mDaemon.h)
- *
-**/
-int mDaemon_indInitializing( unsigned long mSec )
-{
-   return indToSCM( SERVICE_START_PENDING, NO_ERROR, mSec );
-}
-
-
-
-/**
- *
- * (see mDaemon.h)
- *
-**/
-int mDaemon_indReady( unsigned long mSec )
-{
-   return( indToSCM( SERVICE_RUNNING, NO_ERROR, mSec ) );
-}
-
-
-
-/**
- *
- * (see mDaemon.h)
- *
-**/
-void mDaemon_log( char const * Data )
-{
-   if( !Console )
-   {
-      //
-      // Write to event log
-      //
-      HANDLE hEventSource = RegisterEventSource( NULL, mDaemon_name() );
-      if( hEventSource )
-      {
-         LPCTSTR Strings[1];
-         Strings[0] = Data;
-         ReportEvent
-         (
-            hEventSource,         // handle of event source
-            EVENTLOG_ERROR_TYPE,  // event type
-            0,                    // event category
-            0,                    // event ID
-            NULL,                 // current users SID
-            1,                    // strings in lpszStrings
-            0,                    // no bytes of raw data
-            Strings,              // array of error strings
-            0                     // no raw data
-         );
-         DeregisterEventSource(hEventSource);
-      }
-   }
-}
-
-/**
- *
- * (see mDaemon.h)
- *
-**/
-int mDaemon_isService()
-{
-  return !Console;
-}
-
-
-/**
- **************************************************************************
- *
- * Standard main.
- *
- * @param argc Argument count
- *
- * @param argv Argument vector
- *
- * @return 0 if OK
- *
- **************************************************************************
-**/
-int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPreInst, char *szCmdLine, int iCmdShow)
-// int main( int argc, char ** argv )
-{
-   long success;
-   LPWSTR cmdLine;
-   int argc;
-   cmdLine= GetCommandLineW();
-   LPWSTR* argvw;
-   argvw= CommandLineToArgvW(cmdLine, &argc);
-   if(argvw == 0)
-   {
-     argc= 0;
-   }
-   char** argv= new char*[argc];
-   for(int i= 0; i < argc; ++i)
-   {
-     int len= wcslen(argvw[i]);
-     argv[i]= new char[len + 1];
-     sprintf(argv[i], "%ws", argvw[i]);
-   }
-   // MaM GlobalFree(cmdLine);
-   // MaM GlobalFree(argvw);
-   LocalFree(cmdLine);
-   LocalFree(argvw);
-
-   argScan Arg( argc, argv );
-   if( Arg.help() )
-   {
-      cout << "Usage: "
-           << argv[0]
-           << " [ -install -autostart -dep:dependency| -deinstall | -normal ";
-      if( mDaemon_help() )
-      {
-         cout << "<parameter> ]\n"
-              << "       <parameter> = "
-              << mDaemon_help() << endl;
-      }
-      else
-      {
-         cout << "]" << endl;
-      }
-      return 0;
-   }
-
-   if( Arg.option( "INSTALL" ) )
-      return install(Arg.option("DEP"), Arg.option("AUTOSTART") != 0);
-
-   if( Arg.option( "DEINSTALL" ) )
-      return deinstall();
-
-/* 15.10.2005 AGe
-   17.05.2006 SteT */
-
-   if( Arg.option( "NORMAL" ) )
-   {
-      Console = true;
-      SetConsoleCtrlHandler( console_ctrl, true );
-      // return mDaemon_main( argc, argv );
-      return mDaemon_main(hInst, hPreInst, szCmdLine, iCmdShow);
-   }
-
-
-   SERVICE_TABLE_ENTRY STE[2];
-   STE[0].lpServiceName = const_cast<char *>( mDaemon_name() );
-   STE[0].lpServiceProc = service_main;
-   STE[1].lpServiceName = 0;
-   STE[1].lpServiceProc = 0;
-
-   if((success = StartServiceCtrlDispatcher( STE )) == false)
-     mDaemon_log( "StartServiceCtrlDispatcher failed." );
-
-   for(int j= 0; j < argc; ++j)
-   {
-     delete[] argv[j];
-   }
-
-   delete[] argv;
-
-   // 15.10.2005 AGe
-/*
-   if(!success && Console)
-   {
-      SetConsoleCtrlHandler( console_ctrl, true );
-      // return mDaemon_main( argc, argv );
-      return mDaemon_main(hInst, hPreInst, szCmdLine, iCmdShow);
-   }
-*/
-
-   return 0;
-}
-
-
-
-/**
- **************************************************************************
- *
- * End of file
- *
- **************************************************************************
-**/
-
diff --git a/Massai/cpp/LogService/inc/ProView.h b/Massai/cpp/LogService/inc/ProView.h
deleted file mode 100644
index 6ed5a75a..00000000
--- a/Massai/cpp/LogService/inc/ProView.h
+++ /dev/null
@@ -1,15 +0,0 @@
-//---------------------------------------------------------------------------
-//
-//  file:       proview.h
-//
-//  purpose:    Header file
-//
-//  date:       09.01.01, 08:59
-//
-//  author:     Dr. Materna GmbH (AGe)
-//
-//---------------------------------------------------------------------------
-
-// interface to the ProView system
-
-long logProViewEvent(const char* buffer);
diff --git a/Massai/cpp/LogService/inc/intevt.h b/Massai/cpp/LogService/inc/intevt.h
deleted file mode 100644
index 2440d2e2..00000000
--- a/Massai/cpp/LogService/inc/intevt.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
-** intevt.h
-**
-**
-**
-** Version history
-**
-** Date         Version     Who    Comment
-** -----------------------------------------------------------------------
-** 30-Oct-1999     2         rb     use plain "C"-style to export LogEvent
-** 13-Aug-1999     1         rb     initial coding
-**
-**
-*/
-
-#define __EXPORT__ __declspec(dllexport)
-
-typedef void (__cdecl *CALLBACK_FP)( long, char *);
-
-extern "C" {
-
-/* internal ProView Event-Module interface */
- __EXPORT__ int __stdcall LogEvent( const char *buffer, int len );
-
-
-/* ProView Event-Module interface */
- __EXPORT__ int Init( CALLBACK_FP fpCallBackAddress,
-         long handle,
-         long moduleId,
-         char *pszConfigSection );
-
- __EXPORT__ void Exit( void );
-
-}
-
-/*
- *
- * end of file
- *
- */
diff --git a/Massai/cpp/LogService/inc/logsnmp.h b/Massai/cpp/LogService/inc/logsnmp.h
deleted file mode 100644
index cd3cf35d..00000000
--- a/Massai/cpp/LogService/inc/logsnmp.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/**
- **************************************************************************
- *
- * @file logSNMP.h
- *
- * prototypes used for snmp- and other traplistener
- *
- * @author git
- *
- * Copyright (c) 2003 MATERNA Information & Communications
- *
- * 27-06-2003  git    	first integration
- *
- **************************************************************************
-**/
-
-#ifndef LOGSNMP_H_
-#define LOGSNMP_H_
-
-/**
- *************************************************************************
- * trap class for internal usage
-**/
-
-class trapEvent
-{
-  long  lID;
-  long  lThreshold;
-  bool resent;
-  std::string trap;
-  std::string description;
-
-public:
-  trapEvent(const char* pszData);
-
-  trapEvent(const trapEvent& tE);
-
-  trapEvent() : lID(0), lThreshold(0), trap(), description() { };
-
-  long getID() const;
-  long getThreshold() const;
-  const std::string& getTrapText() const;
-  const std::string& getDescription() const;
-
-  void setRepeated(bool flag) ;
-
-  void trace(long lLevel, const char* pszFile, short sLine, const char* pszFunction, const char* pszText);
-};
-
-#endif //LOGSNMP_H_
diff --git a/Massai/cpp/LogService/inc/newlogst.h b/Massai/cpp/LogService/inc/newlogst.h
deleted file mode 100644
index 73e4f1d3..00000000
--- a/Massai/cpp/LogService/inc/newlogst.h
+++ /dev/null
@@ -1,59 +0,0 @@
-//---------------------------------------------------------------------------
-//
-//  file:       NewLogST.h
-//
-//  purpose:    Write formatted Logdata
-//
-//  date:       21.08.2003
-//
-//  author:     Materna Information & Communications (GiT)
-//
-//              21.08.2003 V00.00.01 adaption from xlog source git
-//---------------------------------------------------------------------------
-
-#if !defined(NEWLOGST_H)
-#define NEWLOGST_H
-
-
-#include <string>
-#include <list>
-#include <fstream>
-
-//using namespace std;
-
-class CfgText;
-
-class newlog
-{
-private:
-
-	std::ofstream* pout;
-
-	CfgText* cnfLogPath;
-	std::string sSLPath;
-	std::string logfilename;
-
-	void OpenNewLogFile();
-	void CloseNewLogFile();
-
-	std::string getOutputPath(const std::string sSLPath);
-
-public:
-	newlog(const std::string& path,const std::string& logname);
-	~newlog();
-
-	void newLogWriteEvent(
-	  const long timeStamp,
-	  const std::string& KioskId,
-	  const std::string& Text
-	  );
-
-	void newLogWrite(
-	  const long timeStamp,
-	  const std::string& Text
-	  );
-};
-
-
-
-#endif // NEWLOGST_H
\ No newline at end of file
diff --git a/Massai/cpp/LogService/inc/trapResent.h b/Massai/cpp/LogService/inc/trapResent.h
deleted file mode 100644
index 5d6a0d51..00000000
--- a/Massai/cpp/LogService/inc/trapResent.h
+++ /dev/null
@@ -1,200 +0,0 @@
-/**
- **************************************************************************
- *
- * @file trapResent.h
- *
- * tracks error traps for repeated sent if state remains constant
- *
- * @author GiT
- *
- * Copyright (c) 2003 MATERNA Information & Communications
- *
- **************************************************************************
-**/
-
-#include <string>
-#include <set>
-#include <map>
-#include <time.h>
-
-#include "alert.h"
-#include "trapListener.h"
-#include "mThread.hpp"
-#include "mLog.h"
-
-/**
- *	global definitions
-**/
-
-typedef long tidtype;
-
-typedef std::set<tidtype> slist;
-typedef std::set<tidtype>* pslist;
-
-typedef enum
-{
-	MEID_NOTHING			= 0,
-	MEID_SET_ERRORTRAP 		= 1<<0,
-	MEID_CLEAR_ERRORTRAPS 	= 1<<1,
-	MEID_SZTRAP				= 1<<2,
-	MEID_FTRAP				= 1<<3
-} EIDState;
-
-typedef struct
-{
-	time_t firstSent;
-	time_t lastResent;
-	long resentCount;
-	std::string moduleID;
-	std::string szTrap;
-	alert::eventData e;
-	alert::dataVector eData;
-	long tstatus;
-} activeErrorTrap;
-
-typedef std::map<int,activeErrorTrap> activeErrorTrapsT;
-
-class mapEID
-{
-
-public:
-
-	typedef struct
-	{
-	public:
-		std::string compName;
-		slist TrapsToChange;
-		long trapState;
-	} TrapDefsForComponentT;
-
-	typedef std::map<tidtype,TrapDefsForComponentT> TrapDefsT;
-
-private:
-	TrapDefsT TrapDefs;
-
-	int readETConfig(const std::string& CompConfListName);
-	int splitTrapDefs(std::string tstr,tidtype& tid, slist& SETraps);
-
-public:
-	int ReadConfig();
-	void clearAll();
-
-	EIDState checkID(tidtype ID, slist & endErrorState);
-};
-
-class repeatResentThread;
-
-class trapResent : public trapListener
-{
-private:
-
-	activeErrorTrapsT activeErrorTraps;
-
-	mapEID fTrapList;
-
-	long lResentInterval;
-
-	repeatResentThread* ResentThread;
-
-	int ReadRIConfig(const std::string& CompConfListName);
-
-	int resent(activeErrorTrap& trapID);
-
-	void addtrap(const char* pszTrap, tidtype id, long status);
-
-  	void addtrap(const std::string& moduleID, const alert::eventData& e, const alert::dataVector& eData, tidtype id, long status);
-
-public:
-
-	trapResent();
-	~trapResent();
-
-	int ReadConfig();
-
-	virtual void trap(const char *pszTrap, const long status);
-
-  	virtual void trap(const std::string& moduleID,
-                    const alert::eventData& e,
-                    const alert::dataVector& eData,
-                    const long status);
-
-	void clear();
-
-	void checkResent();
-};
-
-class repeatResentThread : public mThread
-{
-private:
-
-	volatile long interval;
-	trapResent* pL;
-
-    long function()
-    {
-      while(!fDone)
-      {
-		  //writeTrace(BasicRuntime_HERE, "repeatResentThread triggered");
-
-		  if(interval) if(pL) pL->checkResent();
-		  if(interval)
-		  	OS_Sleep(interval);
-		  else
-		  	OS_Sleep(5000);
-
-  	  }
-      return (-1);
-    }
-
-public:
-
-	long fDone;
-
-	repeatResentThread()
-    {
-		interval = 0;
-		pL = NULL;
-		fDone = false;
-		run();
-	}
-
-	repeatResentThread(long repeatInterval,trapResent* pListener)
-	{
-		interval = repeatInterval;
-		pL = pListener;
-		fDone = false;
-		run();
-	}
-
-	void setInterval(long repeatInterval)
-	{
-//		if(!mThread::fRun)
-//		{
-			interval = repeatInterval;
-			return;
-//		}
-//		mThread::stop();
-		interval = repeatInterval;
-//		mThread::restart();
-	}
-
-   ~repeatResentThread()
-    {
-      fDone = true;
-
-//	  if(interval)
-//        OS_Sleep(2*interval+1000);
-//	  else
-	    OS_Sleep(2000);
-
-      mThread::stop();
-    }
-
-};
-
-
-/*
- *
- * end of file
- *
- */
diff --git a/Massai/cpp/LogService/lib/intevt.dll b/Massai/cpp/LogService/lib/intevt.dll
deleted file mode 100644
index 916d308adfc8d7dd579d305d9e32aff82e00c545..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 84992
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
Y{U^F}y34vyZKH0RZaWSS{wMwZFZ`iv&;S4c

diff --git a/Massai/cpp/LogService/lib/intevt.lib b/Massai/cpp/LogService/lib/intevt.lib
deleted file mode 100644
index b9585334d76294149f22ada3c3e66c22e71f4ce6..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 3194
zcmd^B&ubGw6#jOT)R^{=gI=ma3VKq~ZJWddi)=B07GoP~3f{KGlr|8f$P#)JJofML
z<S7Rao;`TZQN)7>@AZAVGy5aWng&W0d@wWby?L{F-}^C>rS*fiFOMJRmJ4yJm8@FD
zTCLU)*IP<lsaDm_eh$EOz%+sMDUhiHbBq4SS^!6`#nJ7%hXdEyde++6Z9DbG^C!Do
zt@h3?w)dLN3F>$1fVbV=+}nQY)Hm82aGdU|H;&Ud>AJRsVD+_IebKH|-~^1XZ@xZi
z3=aFQU4;|jXU1I%anA{GqCQOn^$f5m3M&h=Bq9<Jm`EdoIW-$dB>@c}1U^SR978*X
z@*KFtASXrBKTz!SdVVaXWxgEAeA6(o^!;Y_y#ZVk#3R6%H$?ao<z-W%HpNPe#E`bZ
zszj>(A{D!x1NY$Ws&?UqFm(a*LIFyNya^1IT}9h12s4P-QE#I#<T_5Yl@NI`h13l>
zhC&KWxG-ZP3Q<d<117Y8w)jBJvDSE=@T)1UDbYq0p-nl|P=AM$BAx_FO5$RoDRW}M
z&Dhl;s*Ba(%4#{dftpfttizW0qtalgIIPiA67#g~apA-~g;Jc0NA;F$CIHIK?0LBq
z@!apAo_v4I^Ro7bo^-UJRvVVCuplM0JDy+{RmD-=maWUW7fKJ;BB;_{KEBEK=l!2I
zitgcw8*xQ0OMH;=QR#@jkT2}3yv5LelD*FnJ3Bua{TH$MI@vDh!>sI&Wc*ZiT<m;d
zcy^B*tDFxSz4M9p8i!B5bauwa2Z&;#|0#p#R2~%<#p89K!5mDq@iNJ7PsMCZc|{Ps
zbHaM3gHHF5@tY}w*fja4DCwM&_q$m4H6;`GWlrqk`13P!t(U6*Q&sT&zS^o_P9Ja*
zVohCMRj>i4RYmZBMKiP4N9}xl{E%P%*KUmk@o6OEmkdp_-x~UF-PPB~vT{19Mu<<-
T#cz&Ba%5VKXv|}OymP++h)TFA

diff --git a/Massai/cpp/LogService/setupSnmp.txt b/Massai/cpp/LogService/setupSnmp.txt
deleted file mode 100644
index 1c2b6d9f..00000000
--- a/Massai/cpp/LogService/setupSnmp.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-massai.setup.Platform.GENERAL
-massai.setup.ATB.GENERAL
-massai.setup.ATB.ESCROW
-massai.setup.ATB.CAPTURE
-massai.setup.ATB.BIN1
-massai.setup.ATB.BIN2
-massai.setup.ATB.BIN3
-massai.setup.BTP.GENERAL
-massai.setup.BTP.BIN1
-massai.setup.Applications.massai-SERVICE
-massai.setup.Applications.massai-CLA
-massai.setup.Applications.EK-CKI
-massai.setup.Applications.AUA-CKI
-massai.setup.Applications.DLH-CKI
-massai.setup.CRD.GENERAL
-massai.setup.CRD.CAPTURE
-massai.setup.CON.GENERAL
-massai.setup.CON.SCANNER
-massai.setup.CON.SCALE
-massai.setup.CON.BAGGAGESYSTEM
\ No newline at end of file
diff --git a/Massai/cpp/LogService/trapConfiguration.txt b/Massai/cpp/LogService/trapConfiguration.txt
deleted file mode 100644
index 5e1e398f..00000000
--- a/Massai/cpp/LogService/trapConfiguration.txt
+++ /dev/null
@@ -1,378 +0,0 @@
-1000;10000,MAGCARD_READER;1;Cardreader available;CardReaderAvail;MASSAI Alarms;Normal;handleTrap $r.Platform.CRD.GENERAL $s
-1001;30101,MAGCARD_READER;1;Cardreader unavailable: MEDIA_JAMMED;CardReaderNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CRD.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-1002;30302,MAGCARD_READER;1;Cardreader unavailable: HARDWARE_ERROR;CardReaderNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CRD.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-1003;30303,MAGCARD_READER;1;Cardreader unavailable: CRITICAL_SOFTWARE_ERROR;CardReaderNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CRD.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-1004;30304,MAGCARD_READER;1;Cardreader unavailable: NOT_REACHABLE;CardReaderNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CRD.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-1005;30305,MAGCARD_READER;1;Cardreader unavailable: NOT_RESPONDING;CardReaderNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CRD.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-
-1010;10000,MAGCARD_WRITER;1;Cardwriter available;CardWriterAvail;MASSAI Alarms;Normal;handleTrap $r.Platform.CRD.GENERAL $s
-1011;30101,MAGCARD_WRITER;1;Cardwriter unavailable: MEDIA_JAMMED;CardWriterNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CRD.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-1012;30302,MAGCARD_WRITER;1;Cardwriter unavailable: HARDWARE_ERROR;CardWriterNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CRD.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-1013;30303,MAGCARD_WRITER;1;Cardwriter unavailable: CRITICAL_SOFTWARE_ERROR;CardWriterNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CRD.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-1014;30304,MAGCARD_WRITER;1;Cardwriter unavailable: NOT_REACHABLE;CardWriterNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CRD.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-1015;30305,MAGCARD_WRITER;1;Cardwriter unavailable: NOT_RESPONDING;CardWriterNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CRD.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-
-1020;10000,MAGCARD_DISPENSER;1;Carddispenser available;CardDispenserAvail;MASSAI Alarms;Normal;handleTrap $r.Platform.CRD.GENERAL $s
-1021;30101,MAGCARD_DISPENSER;1;Carddispenser unavailable: MEDIA_JAMMED;CardDispenserNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CRD.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-1022;30302,MAGCARD_DISPENSER;1;Carddispenser unavailable: HARDWARE_ERROR;CardDispenserNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CRD.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-1023;30303,MAGCARD_DISPENSER;1;Carddispenser unavailable: CRITICAL_SOFTWARE_ERROR;CardDispenserNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CRD.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-1024;30304,MAGCARD_DISPENSER;1;Carddispenser unavailable: NOT_REACHABLE;CardDispenserNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CRD.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-1025;30305,MAGCARD_DISPENSER;1;Carddispenser unavailable: NOT_RESPONDING;CardDispenserNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CRD.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-
-1030;10000,MAGCARD_CAPTURE;1;Cardcapture available;CardCaptureAvail;MASSAI Alarms;Normal;handleTrap $r.Platform.CRD.CAPTURE $s
-1031;30101,MAGCARD_CAPTURE;1;Cardcapture unavailable: MEDIA_JAMMED;CardCaptureNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CRD.CAPTURE $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-1032;30302,MAGCARD_CAPTURE;1;Cardcapture unavailable: HARDWARE_ERROR;CardCaptureNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CRD.CAPTURE $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-1033;30303,MAGCARD_CAPTURE;1;Cardcapture unavailable: CRITICAL_SOFTWARE_ERROR;CardCaptureNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CRD.CAPTURE $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-1034;30304,MAGCARD_CAPTURE;1;Cardcapture unavailable: NOT_REACHABLE;CardCaptureNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CRD.CAPTURE $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-1035;30305,MAGCARD_CAPTURE;1;Cardcapture unavailable: NOT_RESPONDING;CardCaptureNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CRD.CAPTURE $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-
-2000;10000,ATB_PRNT_READER;1;ATB - Printer (Reader) available;AtbReaderAvail;MASSAI Alarms;Normal;handleTrap $r.Platform.ATB.GENERAL $s
-2001;30101,ATB_PRNT_READER;1;ATB - Printer (Reader) unavailable: MEDIA_JAMMED;AtbReaderNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-2002;30302,ATB_PRNT_READER;1;ATB - Printer (Reader) unavailable: HARDWARE_ERROR;AtbReaderNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-2003;30303,ATB_PRNT_READER;1;ATB - Printer (Reader) unavailable: CRITICAL_SOFTWARE_ERROR;AtbReaderNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-2004;30304,ATB_PRNT_READER;1;ATB - Printer (Reader) unavailable: NOT_REACHABLE;AtbReaderNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-2005;30305,ATB_PRNT_READER;1;ATB - Printer (Reader) unavailable: NOT_RESPONDING;AtbReaderNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-2006;50000,ATB_PRNT_READER;0;ATB_PRNT_READER released by the application
-2007;60000,ATB_PRNT_READER;0;ATB_PRNT_READER released by any authorized component except the application itself
-2008;70000,ATB_PRNT_READER;0;ATB_PRNT_READER changed state of caused by a call to acquire()
-
-2010;10000,ATB_PRNT_INSERTED;1;ATB - Printer (insert) available;AtbInsertAvail;MASSAI Alarms;Normal;handleTrap $r.Platform.ATB.GENERAL $s
-2011;30101,ATB_PRNT_INSERTED;1;ATB - Printer (insert) unavailable: MEDIA_JAMMED;AtbInsertNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-2012;30302,ATB_PRNT_INSERTED;1;ATB - Printer (insert) unavailable: HARDWARE_ERROR;AtbInsertNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-2013;30303,ATB_PRNT_INSERTED;1;ATB - Printer (insert) unavailable: CRITICAL_SOFTWARE_ERROR;AtbInsertNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-2014;30304,ATB_PRNT_INSERTED;1;ATB - Printer (insert) unavailable: NOT_REACHABLE;AtbInsertNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-2015;30305,ATB_PRNT_INSERTED;1;ATB - Printer (insert) unavailable: NOT_RESPONDING;AtbInsertNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-2016;50000,ATB_PRNT_INSERTED;0;ATB_PRNT_INSERTED released by the application
-2017;60000,ATB_PRNT_INSERTED;0;ATB_PRNT_INSERTED released by any authorized component except the application itself
-2018;70000,ATB_PRNT_INSERTED;0;ATB_PRNT_INSERTED changed state of caused by a call to acquire()
-
-2020;10000,ATB_PRNT_DISPENSER;1;ATB - Printer (dispenser) available;AtbDispenserAvail;MASSAI Alarms;Normal;handleTrap $r.Platform.ATB.ESCROW $s
-2021;30101,ATB_PRNT_DISPENSER;1;ATB - Printer (dispenser) unavailable: MEDIA_JAMMED;AtbDispenserNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.ESCROW $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-2022;30302,ATB_PRNT_DISPENSER;1;ATB - Printer (dispenser) unavailable: HARDWARE_ERROR;AtbDispenserNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.ESCROW $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-2023;30303,ATB_PRNT_DISPENSER;1;ATB - Printer (dispenser) unavailable: CRITICAL_SOFTWARE_ERROR;AtbDispenserNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.ESCROW $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-2024;30304,ATB_PRNT_DISPENSER;1;ATB - Printer (dispenser) unavailable: NOT_REACHABLE;AtbDispenserNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.ESCROW $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-2025;30305,ATB_PRNT_DISPENSER;1;ATB - Printer (dispenser) unavailable: NOT_RESPONDING;AtbDispenserNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.ESCROW $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-2026;50000,ATB_PRNT_DISPENSER;0;ATB_PRNT_DISPENSER released by the application
-2027;60000,ATB_PRNT_DISPENSER;0;ATB_PRNT_DISPENSER released by any authorized component except the application itself
-2028;70000,ATB_PRNT_DISPENSER;0;ATB_PRNT_DISPENSER changed state of caused by a call to acquire()
-
-2030;50000,ATB_PRNT_TK;0;ATB_PRNT_TK released by the application
-2031;60000,ATB_PRNT_TK;0;ATB_PRNT_TK released by any authorized component except the application itself
-2032;70000,ATB_PRNT_TK;0;ATB_PRNT_TK changed state of caused by a call to acquire()
-2040;50000,ATB_PRNT_BP;0;ATB_PRNT_BP released by the application
-2041;60000,ATB_PRNT_BP;0;ATB_PRNT_BP released by any authorized component except the application itself
-2042;70000,ATB_PRNT_BP;0;ATB_PRNT_BP changed state of caused by a call to acquire()
-2050;50000,ATB_PRNT_GP;0;ATB_PRNT_GP released by the application
-2051;60000,ATB_PRNT_GP;0;ATB_PRNT_GP released by any authorized component except the application itself
-2052;70000,ATB_PRNT_GP;0;ATB_PRNT_GP changed state of caused by a call to acquire()
-
-2106;10106,ATB2Bin1;1;ATB - In Service - Stock 1:MEDIA_FULL;AtbBin1;MASSAI Alarms;Normal;handleTrap $r.Platform.ATB.BIN1 $s
-2107;10105,ATB2Bin1;1;ATB - In Service - Stock 1:MEDIA_HIGH;AtbBin1;MASSAI Alarms;Normal;handleTrap $r.Platform.ATB.BIN1 $s
-2108;10107,ATB2Bin1;1;ATB - In Service, attention required - Stock 1:MEDIA_LOW;AtbBin1;MASSAI Alarms;Major;handleTrap $r.Platform.ATB.BIN1 $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-2109;10108,ATB2Bin1;1;ATB - In Service, attention required - Stock 1:MEDIA_EMPTY;AtbBin1;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.BIN1 $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-2110;10106,ATB2Bin2;1;ATB - In Service - Stock 2:MEDIA_FULL;AtbBin2;MASSAI Alarms;Normal;handleTrap $r.Platform.ATB.BIN2 $s
-2111;10105,ATB2Bin2;1;ATB - In Service - Stock 2:MEDIA_HIGH;AtbBin2;MASSAI Alarms;Normal;handleTrap $r.Platform.ATB.BIN2 $s
-2112;10107,ATB2Bin2;1;ATB - In Service, attention required - Stock 2:MEDIA_LOW;AtbBin2;MASSAI Alarms;Major;handleTrap $r.Platform.ATB.BIN2 $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-2113;10108,ATB2Bin2;1;ATB - In Service, attention required - Stock 2:MEDIA_EMPTY;AtbBin2;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.BIN2 $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-2114;10106,ATB2Bin3;1;ATB - In Service - Stock 3:MEDIA_FULL;AtbBin3;MASSAI Alarms;Normal;handleTrap $r.Platform.ATB.BIN3 $s
-2115;10105,ATB2Bin3;1;ATB - In Service - Stock 3:MEDIA_HIGH;AtbBin3;MASSAI Alarms;Normal;handleTrap $r.Platform.ATB.BIN3 $s
-2116;10107,ATB2Bin3;1;ATB - In Service, attention required - Stock 3:MEDIA_LOW;AtbBin3;MASSAI Alarms;Major;handleTrap $r.Platform.ATB.BIN3 $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-2117;10108,ATB2Bin3;1;ATB - In Service, attention required - Stock 3:MEDIA_EMPTY;AtbBin3;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.BIN3 $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-
-3000;10000,BAGTAG_PRINTER;1;BTP - Printer available;BagTagPrinterAvail;MASSAI Alarms;Normal;handleTrap $r.Platform.BTP.GENERAL $s
-3001;30101,BAGTAG_PRINTER;1;BTP - Printer unavailable:MEDIA_JAMMED;BagTagPrinterNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.BTP.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-3002;30108,BAGTAG_PRINTER;1;BTP - Printer unavailable:MEDIA_EMPTY;BagTagPrinterNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.BTP.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-3003;30302,BAGTAG_PRINTER;1;BTP - Printer unavailable: HARDWARE_ERROR;BagTagPrinterNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.BTP.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-3004;30303,BAGTAG_PRINTER;1;BTP - Printer unavailable: CRITICAL_SOFTWARE_ERROR;BagTagPrinterNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.BTP.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-3005;30304,BAGTAG_PRINTER;1;BTP - Printer unavailable: NOT_REACHABLE;BagTagPrinterNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.BTP.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-3006;30305,BAGTAG_PRINTER;1;BTP - Printer unavailable: NOT_RESPONDING;BagTagPrinterNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.BTP.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-3007;20000,BAGTAG_PRINTER;0;BAGTAG_PRINTER Released by any authorized component except the application itself
-3008;50000,BAGTAG_PRINTER;0;BAGTAG_PRINTER released by the application
-3009;60000,BAGTAG_PRINTER;0;BAGTAG_PRINTER released by any authorized component except the application itself
-3010;70000,BAGTAG_PRINTER;0;BAGTAG_PRINTER changed state of caused by a call to acquire()
-3011;10201,BAGTAG_PRINTER;1;BTP - Format Error in command to BAGTAG_PRINTER;BagTagPrinterNotAvail;MASSAI Alarms;Warning;handleTrap $r.Platform.BTP.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-3012;2020300,BAGTAG_PRINTER;1;BTP - unavailable;BagTagPrinterNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.BTP.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-3100;10106,BAGTAG_FEEDER;1;BTP - In Service - BagTags:MEDIA_FULL;BagTagPrinterBin1;MASSAI Alarms;Normal;handleTrap $r.Platform.BTP.BIN1 $s
-3101;10105,BAGTAG_FEEDER;1;BTP - In Service - BagTags:MEDIA_HIGH;BagTagPrinterBin1;MASSAI Alarms;Normal;handleTrap $r.Platform.BTP.BIN1 $s
-3102;10107,BAGTAG_FEEDER;1;BTP - In Service, attention required - BagTags:MEDIA_LOW;BagTagPrinterBin1;MASSAI Alarms;Major;handleTrap $r.Platform.BTP.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-3103;10108,BAGTAG_FEEDER;1;BTP - In Service, attention required - BagTags:MEDIA_EMPTY;BagTagPrinterBin1;MASSAI Alarms;Critical;handleTrap $r.Platform.BTP.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-
-4000;50000,TOUCHSCREEN_DISPLAY;0;TOUCHSCREEN_DISPLAY released by the application
-4001;60000,TOUCHSCREEN_DISPLAY;0;TOUCHSCREEN_DISPLAY released by any authorized component except the application itself
-4002;70000,TOUCHSCREEN_DISPLAY;0;TOUCHSCREEN_DISPLAY changed state of caused by a call to acquire()
-
-5000;50000,ATB_ESCR_CAPTURE;0;ATB_ESCR_CAPTURE released by the application
-5001;60000,ATB_ESCR_CAPTURE;0;ATB_ESCR_CAPTURE released by any authorized component except the application itself
-5002;70000,ATB_ESCR_CAPTURE;0;ATB_ESCR_CAPTURE changed state of caused by a call to acquire()
-5100;50000,ATB_ESCR_DISPENSER;0;ATB_ESCR_DISPENSER released by the application
-5101;60000,ATB_ESCR_DISPENSER;0;ATB_ESCR_DISPENSER released by any authorized component except the application itself
-5102;70000,ATB_ESCR_DISPENSER;0;ATB_ESCR_DISPENSER changed state of caused by a call to acquire()
-
-6000;50000,MAGCARD_CAPTURE;0;MAGCARD_CAPTURE released by the application
-6001;60000,MAGCARD_CAPTURE;0;MAGCARD_CAPTURE released by any authorized component except the application itself
-6002;70000,MAGCARD_CAPTURE;0;MAGCARD_CAPTURE changed state of caused by a call to acquire()
-6100;50000,MAGCARD_DISPENSER;0;MAGCARD_DISPENSER released by the application
-6101;60000,MAGCARD_DISPENSER;0;MAGCARD_DISPENSER released by any authorized component except the application itself
-6102;70000,MAGCARD_DISPENSER;0;MAGCARD_DISPENSER changed state of caused by a call to acquire()
-6200;50000,MAGCARD_READER;0;MAGCARD_READER released by the application
-6201;60000,MAGCARD_READER;0;MAGCARD_READER released by any authorized component except the application itself
-6202;70000,MAGCARD_READER;0;MAGCARD_READER changed state of caused by a call to acquire()
-
-9000;10000,CONVEYOR;1;Conveyor available;ConveyorAvail;MASSAI Alarms;Normal;handleTrap $r.Platform.CON.GENERAL $s
-9001;10004,CONVEYOR;1;Conveyor Error;ConveyorNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CON.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-9002;30101,CONVEYOR;1;Conveyor unavailable: MEDIA_JAMMED;ConveyorNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CON.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-9003;30302,CONVEYOR;1;Conveyor unavailable: HARDWARE_ERROR;ConveyorNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CON.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-9004;30303,CONVEYOR;1;Conveyor unavailable: CRITICAL_SOFTWARE_ERROR;ConveyorNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CON.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-9005;30304,CONVEYOR;1;Conveyor unavailable: NOT_REACHABLE;ConveyorNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CON.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-9006;30305,CONVEYOR;1;Conveyor unavailable: NOT_RESPONDING;ConveyorNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CON.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-9007;50000,CONVEYOR;0;CONVEYOR released by the application
-9008;60000,CONVEYOR;0;CONVEYOR released by any authorized component except the application itself
-9009;70000,CONVEYOR;0;CONVEYOR changed state of caused by a call to acquire()
-9010;2100002,CONVEYOR;1;Conveyor is busy
-
-10000;1190000,MAT_CLA;1;Launch Application initialize;CommonLaunchScreenAvail;MASSAI Alarms;Normal;handleTrap $r.Applications.massai-CLA $s
-10001;1040000,MAT_CLA;1;Launch Application init ready;CommonLaunchScreenAvail;MASSAI Alarms;Normal;handleTrap $r.Applications.massai-CLA $s
-10002;1050801,MAT_CLA;0;Launch Application activated;CommonLaunchScreenAvail;MASSAI Alarms;Normal;handleTrap $r.Applications.massai-CLA $s
-10003;1060000,MAT_CLA;0;Launch Application terminated;CommonLaunchScreenNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-CLA $s
-10004;1130000,MAT_CLA;1;Launch Application unavailable;CommonLaunchScreenNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-CLA $s
-10005;1120000,MAT_CLA;1;Launch Application available;CommonLaunchScreenAvail;MASSAI Alarms;Normal;handleTrap $r.Applications.massai-CLA $s
-10006;1030001,MAT_CLA;1;Launch Application disabled;CommonLaunchScreenNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-CLA $s
-10006;1010001,MAT_CLA;1;Launch Application disabled;CommonLaunchScreenNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-CLA $s
-10007;1070000,MAT_CLA;1;Launch Application stopped;CommonLaunchScreenNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-CLA $s
-10007;1080000,MAT_CLA;1;Launch Application stopped;CommonLaunchScreenNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-CLA $s
-10007;1090000,MAT_CLA;1;Launch Application stopped;CommonLaunchScreenNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-CLA $s
-10007;1100000,MAT_CLA;1;Launch Application stopped;CommonLaunchScreenNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-CLA $s
-10007;1110000,MAT_CLA;1;Launch Application stopped;CommonLaunchScreenNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-CLA $s
-10008;1070802,MAT_CLA;1;Launch Application stopped by SM;CommonLaunchScreenNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-CLA $s
-10008;1080802,MAT_CLA;1;Launch Application stopped by SM;CommonLaunchScreenNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-CLA $s
-10008;1090802,MAT_CLA;1;Launch Application stopped by SM;CommonLaunchScreenNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-CLA $s
-10008;1100802,MAT_CLA;1;Launch Application stopped by SM;CommonLaunchScreenNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-CLA $s
-10008;1110802,MAT_CLA;1;Launch Application stopped by SM;CommonLaunchScreenNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-CLA $s
-10009;1060801,MAT_CLA;0;Launch Application terminated;CommonLaunchScreenNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-CLA $s
-10011;1290000,MAT_CLA;1;Launch Application changed state from initialize to unavailable;CommonLaunchScreenNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-CLA $s
-
-11000;1190000,MAT_SRVC_APP;1;Service Application initialize;ServiceApplicationAvail;MASSAI Alarms;Normal;handleTrap $r.Applications.massai-SERVICE $s
-11001;1040000,MAT_SRVC_APP;1;Service Application init ready;ServiceApplicationAvail;MASSAI Alarms;Normal;handleTrap $r.Applications.massai-SERVICE $s
-11002;1050801,MAT_SRVC_APP;0;Service Application activated;ServiceApplicationAvail;MASSAI Alarms;Normal;handleTrap $r.Applications.massai-SERVICE $s
-11003;1060000,MAT_SRVC_APP;0;Service Application terminated;ServiceApplicationNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-SERVICE $s
-11004;1130000,MAT_SRVC_APP;1;Service Application unavailable;ServiceApplicationNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-SERVICE $s
-11005;1120000,MAT_SRVC_APP;1;Service Application available;ServiceApplicationAvail;MASSAI Alarms;Normal;handleTrap $r.Applications.massai-SERVICE $s
-11006;1030001,MAT_SRVC_APP;1;Service Application disabled;ServiceApplicationNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-SERVICE $s
-11006;1010001,MAT_SRVC_APP;1;Service Application disabled;ServiceApplicationNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-SERVICE $s
-11007;1070000,MAT_SRVC_APP;1;Service Application stopped;ServiceApplicationNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-SERVICE $s
-11007;1080000,MAT_SRVC_APP;1;Service Application stopped;ServiceApplicationNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-SERVICE $s
-11007;1090000,MAT_SRVC_APP;1;Service Application stopped;ServiceApplicationNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-SERVICE $s
-11007;1100000,MAT_SRVC_APP;1;Service Application stopped;ServiceApplicationNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-SERVICE $s
-11007;1110000,MAT_SRVC_APP;1;Service Application stopped;ServiceApplicationNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-SERVICE $s
-11008;1070802,MAT_SRVC_APP;1;Service Application stopped by SM;ServiceApplicationNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-SERVICE $s
-11008;1080802,MAT_SRVC_APP;1;Service Application stopped by SM;ServiceApplicationNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-SERVICE $s
-11008;1090802,MAT_SRVC_APP;1;Service Application stopped by SM;ServiceApplicationNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-SERVICE $s
-11008;1100802,MAT_SRVC_APP;1;Service Application stopped by SM;ServiceApplicationNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-SERVICE $s
-11008;1110802,MAT_SRVC_APP;1;Service Application stopped by SM;ServiceApplicationNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-SERVICE $s
-11009;1060801,MAT_SRVC_APP;0;Service Application terminated;ServiceApplicationNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-SERVICE $s
-11010;1290000,MAT_SRVC_APP;1;Service Application changed state from initialize to unavailable;ServiceApplicationNotAvail;MASSAI Alarms;Critical;handleTrap $r.Applications.massai-SERVICE $s
-11011;1050804,MAT_SRVC_APP;0;Service Application change state from available to active requestet by itself;ServiceApplicationAvail;MASSAI Alarms;Normal;handleTrap $r.Applications.massai-SERVICE $s
-
-12000;1190000,DLH_CKI;1;DLH CKI Application initialize
-12001;1040000,DLH_CKI;1;DLH CKI Application init ready
-12002;1050801,DLH_CKI;0;DLH CKI Application activated;ApplicationState;MASSAI Alarms;Major;handleTrap $r.Applications.DLH-CKI $s
-12003;1060000,DLH_CKI;0;DLH CKI Application terminated;ApplicationState;MASSAI Alarms;Normal;handleTrap $r.Applications.DLH-CKI $s
-12004;1130000,DLH_CKI;1;DLH CKI Application unavailable;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.DLH-CKI $s
-12005;1120000,DLH_CKI;1;DLH CKI Application available;ApplicationState;MASSAI Alarms;Normal;handleTrap $r.Applications.DLH-CKI $s
-12006;1030001,DLH_CKI;1;DLH CKI Application disabled;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.DLH-CKI $s
-12006;1010001,DLH_CKI;1;DLH CKI Application disabled;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.DLH-CKI $s
-12007;1070000,DLH_CKI;1;DLH CKI Application stopped;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.DLH-CKI $s
-12007;1080000,DLH_CKI;1;DLH CKI Application stopped;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.DLH-CKI $s
-12007;1090000,DLH_CKI;1;DLH CKI Application stopped;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.DLH-CKI $s
-12007;1100000,DLH_CKI;1;DLH CKI Application stopped;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.DLH-CKI $s
-12007;1110000,DLH_CKI;1;DLH CKI Application stopped;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.DLH-CKI $s
-12008;1070802,DLH_CKI;1;DLH CKI Application stopped by SM;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.DLH-CKI $s
-12008;1080802,DLH_CKI;1;DLH CKI CheckIn Application stopped by SM;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.DLH-CKI $s
-12008;1090802,DLH_CKI;1;DLH CKI CheckIn Application stopped by SM;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.DLH-CKI $s
-12008;1100802,DLH_CKI;1;DLH CKI CheckIn Application stopped by SM;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.DLH-CKI $s
-12008;1110802,DLH_CKI;1;DLH CKI CheckIn Application stopped by SM;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.DLH-CKI $s
-12009;1060801,DLH_CKI;0;DLH CKI CheckIn Application terminated;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.DLH-CKI $s
-12010;1300000,DLH_CKI;1;DLH CKI changed state from available to unavailable;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.DLH-CKI $s
-12011;1290000,DLH_CKI;1;DLH CKI changed state from initialize to unavailable;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.DLH-CKI $s
-12012;1280802,DLH_CKI;1;DLH CKI change state request from unavailable to stopped requested by System Manager;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.DLH-CKI $s
-12013;1050804,DLH_CKI;0;DLH CKI change state from available to active requestet by DLH_CKI;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.DLH-CKI $s
-
-14000;1190000,AUA_CKI;1;AUA CKI Application initialize
-14001;1040000,AUA_CKI;1;AUA CKI Application init ready
-14002;1050801,AUA_CKI;0;AUA CKI Application activated;ApplicationState;MASSAI Alarms;Major;handleTrap $r.Applications.AUA-CKI $s
-14003;1060000,AUA_CKI;0;AUA CKI Application terminated;ApplicationState;MASSAI Alarms;Normal;handleTrap $r.Applications.AUA-CKI $s
-14004;1130000,AUA_CKI;1;AUA CKI Application unavailable;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.AUA-CKI $s
-14005;1120000,AUA_CKI;1;AUA CKI Application available;ApplicationState;MASSAI Alarms;Normal;handleTrap $r.Applications.AUA-CKI $s
-14006;1030001,AUA_CKI;1;AUA CKI Application disabled;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.AUA-CKI $s
-14006;1010001,AUA_CKI;1;AUA CKI Application disabled;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.AUA-CKI $s
-14007;1070000,AUA_CKI;1;AUA CKI Application stopped;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.AUA-CKI $s
-14007;1080000,AUA_CKI;1;AUA CKI Application stopped;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.AUA-CKI $s
-14007;1090000,AUA_CKI;1;AUA CKI Application stopped;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.AUA-CKI $s
-14007;1100000,AUA_CKI;1;AUA CKI Application stopped;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.AUA-CKI $s
-14007;1110000,AUA_CKI;1;AUA CKI Application stopped;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.AUA-CKI $s
-14008;1070802,AUA_CKI;1;AUA CKI Application stopped by SM;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.AUA-CKI $s
-14008;1080802,AUA_CKI;1;AUA CKI CheckIn Application stopped by SM;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.AUA-CKI $s
-14008;1090802,AUA_CKI;1;AUA CKI CheckIn Application stopped by SM;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.AUA-CKI $s
-14008;1100802,AUA_CKI;1;AUA CKI CheckIn Application stopped by SM;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.AUA-CKI $s
-14008;1110802,AUA_CKI;1;AUA CKI CheckIn Application stopped by SM;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.AUA-CKI $s
-14009;1060801,AUA_CKI;0;AUA CKI CheckIn Application terminated;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.AUA-CKI $s
-14010;1300000,AUA_CKI;1;AUA CKI changed state from available to unavailable;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.AUA-CKI $s
-14011;1290000,AUA_CKI;1;AUA CKI changed state from initialize to unavailable;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.AUA-CKI $s
-14012;1280802,AUA_CKI;1;AUA CKI change state request from unavailable to stopped requested by System Manager;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.AUA-CKI $s
-14013;1050804,AUA_CKI;0;AUA CKI change state from available to active requestet by AUA_CKI;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.AUA-CKI $s
-
-15000;1190000,UAE_EKCKI;1;EK CKI Application initialize
-15001;1040000,UAE_EKCKI;1;EK CKI Application init ready
-15002;1050801,UAE_EKCKI;0;EK CKI Application activated;ApplicationState;MASSAI Alarms;Major;handleTrap $r.Applications.EK-CKI $s
-15003;1060000,UAE_EKCKI;0;EK CKI Application terminated;ApplicationState;MASSAI Alarms;Normal;handleTrap $r.Applications.EK-CKI $s
-15004;1130000,UAE_EKCKI;1;EK CKI Application unavailable;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.EK-CKI $s
-15005;1120000,UAE_EKCKI;1;EK CKI Application available;ApplicationState;MASSAI Alarms;Normal;handleTrap $r.Applications.EK-CKI $s
-15006;1030001,UAE_EKCKI;1;EK CKI Application disabled;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.EK-CKI $s
-15006;1010001,UAE_EKCKI;1;EK CKI Application disabled;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.EK-CKI $s
-15007;1070000,UAE_EKCKI;1;EK CKI Application stopped;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.EK-CKI $s
-15007;1080000,UAE_EKCKI;1;EK CKI Application stopped;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.EK-CKI $s
-15007;1090000,UAE_EKCKI;1;EK CKI Application stopped;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.EK-CKI $s
-15007;1100000,UAE_EKCKI;1;EK CKI Application stopped;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.EK-CKI $s
-15007;1110000,UAE_EKCKI;1;EK CKI Application stopped;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.EK-CKI $s
-15008;1070802,UAE_EKCKI;1;EK CKI Application stopped by SM;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.EK-CKI $s
-15008;1080802,UAE_EKCKI;1;EK CKI CheckIn Application stopped by SM;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.EK-CKI $s
-15008;1090802,UAE_EKCKI;1;EK CKI CheckIn Application stopped by SM;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.EK-CKI $s
-15008;1100802,UAE_EKCKI;1;EK CKI CheckIn Application stopped by SM;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.EK-CKI $s
-15008;1110802,UAE_EKCKI;1;EK CKI CheckIn Application stopped by SM;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.EK-CKI $s
-15009;1060801,UAE_EKCKI;0;EK CKI CheckIn Application terminated;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.EK-CKI $s
-15010;1300000,UAE_EKCKI;1;EK CKI changed state from available to unavailable;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.EK-CKI $s
-15011;1290000,UAE_EKCKI;1;EK CKI changed state from initialize to unavailable;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.EK-CKI $s
-15012;1280802,UAE_EKCKI;1;EK CKI change state request from unavailable to stopped requested by System Manager;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.EK-CKI $s
-15013;1050804,UAE_EKCKI;0;EK CKI change state from available to active requestet by UAE_EKCKI;ApplicationState;MASSAI Alarms;Critical;handleTrap $r.Applications.EK-CKI $s
-
-20000;10000,_;0; _ Eventhandling OK
-20001;10105,_;0; _ Eventhandling MEDIA_HIGH
-20002;10106,_;0; _ Eventhandling MEDIA_FULL
-20003;10107,_;0; _ Eventhandling MEDIA_LOW
-20004;30304,_;0; _ Eventhandling unavailable error: not reachable
-
-100001;massai.notification.drivers.ConveyorDev.18;1;Conveyor ALERT_CODE_PIECE_UNEXPECTED;ConveyerDevNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CON.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100002;massai.notification.drivers.ConveyorDev.19;1;Conveyor ALERT_CODE_PIECE_LOST;ConveyerDevNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CON.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100003;massai.notification.drivers.ConveyorDev.20;1;Conveyor ALERT_CODE_TOO_MANY_PIECES;ConveyerDevNotAvail;MASSAI Alarms;Normal;
-100004;massai.notification.drivers.ConveyorDev.21;1;Conveyor ALERT_CODE_PIECE_TOO_HIGH;ConveyerDevNotAvail;MASSAI Alarms;Normal;
-100005;massai.notification.drivers.ConveyorDev.22;1;Conveyor ALERT_CODE_PIECE_TOO_LONG;ConveyerDevNotAvail;MASSAI Alarms;Normal;
-100006;massai.notification.drivers.ConveyorDev.23;1;Conveyor ALERT_CODE_PIECE_WEIGHT_CHANGED;ConveyerDevNotAvail;MASSAI Alarms;Normal;
-100007;massai.notification.drivers.ConveyorDev.24;1;Conveyor ALERT_CODE_PIECE_NOT_RETURNED;ConveyerDevNotAvail;MASSAI Alarms;Normal;
-100013;massai.notification.drivers.ConveyorDev.13;1;Conveyor ALERT_CODE_PIECE_UNEXPECTED_ON_BELT_3;ConveyerDevNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CON.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100014;massai.notification.drivers.ConveyorDev.33;1;Conveyor ALERT_CODE_PIECE_BLOCKED_ON_BELT_3;ConveyerDevNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CON.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100025;massai.notification.drivers.ConveyorDev.25;1;Conveyor ALERT_CODE_PIECE_NOT_FORWARDED;ConveyerDevNotAvail;MASSAI Alarms;Normal;
-100015;massai.notification.drivers.ConveyorDev.0;1;Conveyor OK;ConveyorDevAvail;MASSAI Alarms;Normal;handleTrap $r.Platform.CON.GENERAL $s
-
-100100;massai.notification.drivers.ConveyorDev.Scanner.0;1;Scanner available;ConveyorDevAvail;MASSAI Alarms;Normal;handleTrap $r.Platform.CON.SCANNER $s
-100102;massai.notification.drivers.ConveyorDev.Scanner.2;1;Scanner hardware error;ConveyerDevNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CON.SCANNER $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-
-100200;massai.notification.drivers.ConveyorDev.SPS.0;1;SPS devices available;ConveyorDevAvail;MASSAI Alarms;Normal;handleTrap $r.Platform.CON.BAGGAGESYSTEM $s
-100201;massai.notification.drivers.ConveyorDev.SPS.2;1;SPS failure;ConveyerDevNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CON.BAGGAGESYSTEM $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100202;massai.notification.drivers.ConveyorDev.SPS.4;1;Belts 1-3 failure;ConveyerDevNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CON.BAGGAGESYSTEM $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100203;massai.notification.drivers.ConveyorDev.SPS.8;1;Main belt failure;ConveyerDevNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CON.BAGGAGESYSTEM $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-
-100300;massai.notification.drivers.ConveyorDev.Scale.0;1;Scale available;ConveyorDevAvail;MASSAI Alarms;Normal;handleTrap $r.Platform.CON.SCALE $s
-100302;massai.notification.drivers.ConveyorDev.Scale.2;1;Scale hardware error;ConveyerDevNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.CON.SCALE $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-
-100400;massai.notification.drivers.Atb2Dev1.Escrow.0;1;Escrow available;EscrowAvail;MASSAI Alarms;Normal;handleTrap $r.Platform.ATB.ESCROW $s
-100401;massai.notification.drivers.Atb2Dev1.Escrow.3;1;Escrow hardware error;EscrowNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.ESCROW $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100402;massai.notification.drivers.Atb2Dev1.Escrow.7;1;Escrow not conf.;EscrowNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.ESCROW $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100403;massai.notification.drivers.Atb2Dev1.Escrow.2;1;Escrow disconnected;EscrowNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.ESCROW $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100404;massai.notification.drivers.Atb2Dev1.Escrow.10;1;Escrow door not locked;EscrowNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.ESCROW $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-
-100420;massai.notification.drivers.Atb2Dev1.Escrow.22;1;Escrow disconnected in idle state
-100421;massai.notification.drivers.Atb2Dev1.Escrow.23;1;Escrow hardware error in idle state
-100422;massai.notification.drivers.Atb2Dev1.Escrow.30;1;Escrow door not locked in idle state
-
-100500;massai.notification.drivers.Atb2Dev1.ATB.0;1;ATB available;AtbDevAvail;MASSAI Alarms;Normal;handleTrap $r.Platform.ATB.GENERAL $s
-100501;massai.notification.drivers.Atb2Dev1.ATB.3;1;ATB hardware error;AtbDevNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100502;massai.notification.drivers.Atb2Dev1.ATB.2;1;ATB disconected;AtbDevNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100503;massai.notification.drivers.Atb2Dev1.ATB.4;1;ATB paper jam;AtbDevNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100504;massai.notification.drivers.Atb2Dev1.ATB.5;1;ATB ribbon out;AtbDevNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100505;massai.notification.drivers.Atb2Dev1.ATB.6;1;ATB offline;AtbDevNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100506;massai.notification.drivers.Atb2Dev1.ATB.7;1;ATB not conf.;AtbDevNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100507;massai.notification.drivers.Atb2Dev1.Stock1.0;1;ATB Stock1 available;AtbDevBin1;MASSAI Alarms;Normal;handleTrap $r.Platform.ATB.BIN1 $s
-100508;massai.notification.drivers.Atb2Dev1.Stock1.1;1;ATB Stock1 is empty;AtbDevBin1;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.BIN1 $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100509;massai.notification.drivers.Atb2Dev1.Stock2.0;1;ATB Stock2 available;AtbDevBin2;MASSAI Alarms;Normal;handleTrap $r.Platform.ATB.BIN2 $s
-100510;massai.notification.drivers.Atb2Dev1.Stock2.1;1;ATB Stock2 is empty;AtbDevBin2;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.BIN2 $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100511;massai.notification.drivers.Atb2Dev1.Stock3.0;1;ATB Stock3 available;AtbDevBin3;MASSAI Alarms;Normal;handleTrap $r.Platform.ATB.BIN3 $s
-100512;massai.notification.drivers.Atb2Dev1.Stock3.1;1;ATB Stock3 is empty;AtbDevBin3;MASSAI Alarms;Critical;handleTrap $r.Platform.ATB.BIN3 $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100522;massai.notification.drivers.Atb2Dev1.122;1;ATB Document voided;AtbDevAvail;MASSAI Alarms;Normal;
-
-100600;massai.notification.drivers.BagTagDev1.ATB.0;1;BTP available;BtpDevAvail;MASSAI Alarms;Normal;handleTrap $r.Platform.ATB.GENERAL $s
-100601;massai.notification.drivers.BagTagDev1.ATB.3;1;BTP hardware error;BtpDevNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.BTP.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100602;massai.notification.drivers.BagTagDev1.ATB.2;1;BTP disconected;BtpDevNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.BTP.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100603;massai.notification.drivers.BagTagDev1.ATB.4;1;BTP paper jam;BtpDevNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.BTP.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100604;massai.notification.drivers.BagTagDev1.ATB.5;1;BTP ribbon out;BtpDevNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.BTP.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100605;massai.notification.drivers.BagTagDev1.ATB.6;1;BTP offline;BtpDevNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.BTP.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100606;massai.notification.drivers.BagTagDev1.ATB.7;1;BTP not conf.;BtpDevNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.BTP.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100607;massai.notification.drivers.BagTagDev1.Stock1.0;1;BTP Stock1 available;BtpDevBin1;MASSAI Alarms;Normal;handleTrap $r.Platform.BTP.BIN1 $s
-100608;massai.notification.drivers.BagTagDev1.Stock1.1;1;BTP Stock1 is empty;BtpDevBin1;MASSAI Alarms;Critical;handleTrap $r.Platform.BTP.BIN1 $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-
-
-100701;massai.notification.drivers.Sel.1;1;Special Electronic ALERT_CODE_DOOR_OPENED;KioskNotAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.SEL.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100702;massai.notification.drivers.Sel.2;1;Special Electronic ALERT_CODE_DOOR_CLOSED;KioskAvail;MASSAI Alarms;Normal;handleTrap $r.Platform.SEL.GENERAL $s
-100703;massai.notification.drivers.Sel.Bin1.3;1;Special Electronic ALERT_CODE_PAPER_LOW_BIN1;Bin1Avail;MASSAI Alarms;Normal;handleTrap $r.Platform.SEL.GENERAL $s
-100704;massai.notification.drivers.Sel.Bin1.4;1;Special Electronic ALERT_CODE_PAPER_OK_BIN;Bin1Avail;MASSAI Alarms;Normal;handleTrap $r.Platform.SEL.GENERAL $s
-100705;massai.notification.drivers.Sel.Bin2.5;1;Special Electronic ALERT_CODE_PAPER_LOW_BIN2;Bin2Avail;MASSAI Alarms;Normal;handleTrap $r.Platform.SEL.GENERAL $s
-100706;massai.notification.drivers.Sel.Bin2.6;1;Special Electronic ALERT_CODE_PAPER_OK_BIN2;Bin2Avail;MASSAI Alarms;Normal;handleTrap $r.Platform.SEL.GENERAL $s
-100707;massai.notification.drivers.Sel.Bin3.7;1;Special Electronic ALERT_CODE_PAPER_LOW_BIN3;Bin3Avail;MASSAI Alarms;Normal;handleTrap $r.Platform.SEL.GENERAL $s
-100708;massai.notification.drivers.Sel.Bin3.8;1;Special Electronic ALERT_CODE_PAPER_OK_BIN3;Bin3Avail;MASSAI Alarms;Normal;handleTrap $r.Platform.SEL.GENERAL $s
-100709;massai.notification.drivers.Sel.BagTag.9;1;Special Electronic ALERT_CODE_BAGTAG_LOW;BagTagAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.SEL.GENERAL $s SENDMAIL "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-100710;massai.notification.drivers.Sel.BagTag.10;1;Special Electronic ALERT_CODE_BAGTAG_OK;BagTagAvail;MASSAI Alarms;Normal;handleTrap $r.Platform.SEL.GENERAL $s
-100711;massai.notification.drivers.Sel.16;1;Special Electronic ALERT_CODE_POWER_OFF;BagTagAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.SEL.GENERAL $s
-100712;massai.notification.drivers.Sel.17;1;Special Electronic ALERT_CODE_ATB_POWER_OFF;BagTagAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.SEL.GENERAL $s
-100713;massai.notification.drivers.Sel.18;1;Special Electronic ALERT_CODE_ATB_POWER_ON;BagTagAvail;MASSAI Alarms;Normal;handleTrap $r.Platform.SEL.GENERAL $s
-100714;massai.notification.drivers.Sel.19;1;Special Electronic ALERT_CODE_BTP_POWER_OFF;BagTagAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.SEL.GENERAL $s
-100715;massai.notification.drivers.Sel.20;1;Special Electronic ALERT_CODE_BTP_POWER_ON;BagTagAvail;MASSAI Alarms;Normal;handleTrap $r.Platform.SEL.GENERAL $s
-100716;massai.notification.drivers.Sel.21;1;Special Electronic ALERT_CODE_CRD_POWER_OFF;BagTagAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.SEL.GENERAL $s
-100717;massai.notification.drivers.Sel.22;1;Special Electronic ALERT_CODE_CRD_POWER_ON;BagTagAvail;MASSAI Alarms;Normal;handleTrap $r.Platform.SEL.GENERAL $s
-100718;massai.notification.drivers.Sel.32;1;Special Electronic ALERT_CODE_SEL_AVAILABLE;BagTagAvail;MASSAI Alarms;Normal;handleTrap $r.Platform.SEL.GENERAL $s
-100719;massai.notification.drivers.Sel.33;1;Special Electronic ALERT_CODE_SEL_UNAVAILABLE;BagTagAvail;MASSAI Alarms;Critical;handleTrap $r.Platform.SEL.GENERAL $s
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-999999;massai.setup.ATB.GENERAL;1;Platform::ATB::GENERAL;Setup;MASSAI Setup;Normal;handleTrap $r::$2 dummy SETUP "$x:$X: $2<nl><nl>reported from SSD:<nl><nl>$r<nl><nl>"
-999999;massai.setup.ATB.BIN1;1;Platform::ATB::BIN1
-999999;massai.setup.ATB.BIN2;1;Platform::ATB::BIN2
-999999;massai.setup.ATB.BIN3;1;Platform::ATB::BIN3
-999999;massai.setup.ATB.ESCROW;1;Platform::ATB::ESCROW
-
-999999;massai.setup.CON.GENERAL;1;Platform::CON::GENERAL
-999999;massai.setup.CON.SCANNER;1;Platform::CON::SCANNER
-999999;massai.setup.CON.BAGGAGESYSTEM.0;1;Platform::CON::BAGGAGESYSTEM
-999999;massai.setup.CON.SCALE;1;Platform::CON::SCALE
-
-999999;massai.setup.BTP.GENERAL;1;Platform::BTP::GENERAL
-999999;massai.setup.BTP.BIN1;1;Platform::BTP::BIN1
-
-999999;massai.setup.CRD.GENERAL;1;Platform::CRD::GENERAL
-999999;massai.setup.CRD.CAPTURE;1;Platform::CRD::CAPTURE
-
-999999;massai.setup.Applications.massai-SERVICE;1;Applications::massai-SERVICE
-999999;massai.setup.Applications.massai-CLA;1;Applications::massai-CLA
-999999;massai.setup.Applications.EK-CKI;1;Applications::EK-CKI
-999999;massai.setup.Applications.AUA-CKI;1;Applications::AUA-CKI
-999999;massai.setup.Applications.DLH-CKI;1;Applications::DLH-CKI
\ No newline at end of file
diff --git a/Massai/cpp/LogService/trapConfiguration.xls b/Massai/cpp/LogService/trapConfiguration.xls
deleted file mode 100644
index 28bdd2446ada4861c630ab72d24c5f96a35a5938..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 88064
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

diff --git a/Massai/cpp/LogService/trapConfigurationEK.xls b/Massai/cpp/LogService/trapConfigurationEK.xls
deleted file mode 100644
index bcd180ab75f3671a824cef4822a8149f389b38fb..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 104960
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
W+f9S^wPo3~Dg4@qOjGe!q5p5XnjcUA

diff --git a/Massai/cpp/LogService/trapConfiguration_vie.txt b/Massai/cpp/LogService/trapConfiguration_vie.txt
deleted file mode 100644
index 72f66fab..00000000
--- a/Massai/cpp/LogService/trapConfiguration_vie.txt
+++ /dev/null
@@ -1,465 +0,0 @@
-//
-//  File : TrapConfiguration
-//
-//  Last Changed :
-//    22.07.03 git added/changed defs for CONVEYOR_DRIVER 
-//    03.12.03 git added defs for ATB_DRIVER 
-//    21.01.04 git added defs
-//    03.02.04 git added defs for CONVEYOR
-//    15.04.04 git added defs for ATB
-//    17.05.04 MaK added Atb2Dev-definitions for multicontext-configuration
-//    17.06.04 git added defs for ATB Hardware-Errors
-//    18.06.04 git added added Session Timeout for applications
-//    06.07.04 MaK added new trap Atb2Dev.44 (REC_PAPERJAM)
-//    14.07.04 MaK added new trap for 1030801,DLH_CKI und 1030801,AUA_CKI
-//
-//Overview:
-//ATB_ALL
-//ATB_PRNT_ALL
-//ATB_PRNT_TK           
-//ATB_PRNT_BP
-//ATB_PRNT_GP          
-//ATB_PRNT_INSERTED
-//ATB_PRNT_READER
-//ATB_PRNT_DISPENSER
-//ATB_FEEDER_ALL
-//ATB_FEEDER_STOCK1
-//ATB_FEEDER_STOCK2
-//ATB_FEEDER_STOCK3
-//ATB_ESCR_ALL
-//ATB_ESCR_DISPENSER
-//ATB_ESCR_CAPTURE
-//BAGTAG_ALL
-//BAGTAG_PRINTER
-//BAGTAG_FEEDER
-//MAGCARD_ALL
-//MAGCARD_READER
-//MAGCARD_WRITER
-//MAGCARD_DISPENSER
-//MAGCARD_CAPTURE
-//TOUCHSCREEN_ALL
-//TOUCHSCREEN_INPUT
-//TOUCHSCREEN_DISPLAY
-//NETWORK_ALL
-//NETWORK_INPUT
-//NETWORK_OUTPUT
-//HARDDISK
-//NONE
-//BaggageSystem
-//CONVEYOR
-//CONVEYOR_DRIVER
-//ATB_DRIVER
-//BTP_DRIVER
-
-
-//CardReader
-1000;10000,MAGCARD_READER;1;Cardreader available
-1001;30101,MAGCARD_READER;1;Cardreader unavailable: MEDIA_JAMMED
-1002;30302,MAGCARD_READER;1;Cardreader unavailable: HARDWARE_ERROR
-1003;30303,MAGCARD_READER;1;Cardreader unavailable: CRITICAL_SOFTWARE_ERROR
-1004;30304,MAGCARD_READER;1;Cardreader unavailable: NOT_REACHABLE
-1005;30305,MAGCARD_READER;1;Cardreader unavailable: NOT_RESPONDING
-
-1010;10000,MAGCARD_WRITER;1;Cardwriter available
-1011;30101,MAGCARD_WRITER;1;Cardwriter unavailable: MEDIA_JAMMED
-1012;30302,MAGCARD_WRITER;1;Cardwriter unavailable: HARDWARE_ERROR
-1013;30303,MAGCARD_WRITER;1;Cardwriter unavailable: CRITICAL_SOFTWARE_ERROR
-1014;30304,MAGCARD_WRITER;1;Cardwriter unavailable: NOT_REACHABLE
-1015;30305,MAGCARD_WRITER;1;Cardwriter unavailable: NOT_RESPONDING
-
-1020;10000,MAGCARD_DISPENSER;1;Carddispenser available
-1021;30101,MAGCARD_DISPENSER;1;Carddispenser unavailable: MEDIA_JAMMED
-1022;30302,MAGCARD_DISPENSER;1;Carddispenser unavailable: HARDWARE_ERROR
-1023;30303,MAGCARD_DISPENSER;1;Carddispenser unavailable: CRITICAL_SOFTWARE_ERROR
-1024;30304,MAGCARD_DISPENSER;1;Carddispenser unavailable: NOT_REACHABLE
-1025;30305,MAGCARD_DISPENSER;1;Carddispenserunavailable: NOT_RESPONDING
-
-1030;10000,MAGCARD_CAPTURE;1;Cardcapture available
-1031;30101,MAGCARD_CAPTURE;1;Cardcapture unavailable: MEDIA_JAMMED
-1032;30302,MAGCARD_CAPTURE;1;Cardcapture unavailable: HARDWARE_ERROR
-1033;30303,MAGCARD_CAPTURE;1;Cardcapture unavailable: CRITICAL_SOFTWARE_ERROR
-1034;30304,MAGCARD_CAPTURE;1;Cardcapture unavailable: NOT_REACHABLE
-1035;30305,MAGCARD_CAPTURE;1;Cardcapture unavailable: NOT_RESPONDING
-
-//ATB Printer
-2000;10000,ATB_PRNT_READER;1;ATB - Printer (Reader) available
-2001;30101,ATB_PRNT_READER;1;ATB - Printer (Reader) unavailable: MEDIA_JAMMED
-2002;30302,ATB_PRNT_READER;1;ATB - Printer (Reader) unavailable: HARDWARE_ERROR
-2003;30303,ATB_PRNT_READER;1;ATB - Printer (Reader) unavailable: CRITICAL_SOFTWARE_ERROR
-2004;30304,ATB_PRNT_READER;1;ATB - Printer (Reader) unavailable: NOT_REACHABLE
-2005;30305,ATB_PRNT_READER;1;ATB - Printer (Reader) unavailable: NOT_RESPONDING
-2006;50000,ATB_PRNT_READER;0;ATB_PRNT_READER released by the application                                       
-2007;60000,ATB_PRNT_READER;0;ATB_PRNT_READER released by any authorized component except the application itself
-2008;70000,ATB_PRNT_READER;0;ATB_PRNT_READER changed state of caused by a call to acquire()                    
-2009;2020302,ATB_PRNT_READER;1;ATB - Printer (Reader) unavailable: HARDWARE_ERROR
-
-2010;10000,ATB_PRNT_INSERTED;1;ATB - Printer (insert) available
-2011;30101,ATB_PRNT_INSERTED;1;ATB - Printer (insert) unavailable: MEDIA_JAMMED
-2012;30302,ATB_PRNT_INSERTED;1;ATB - Printer (insert) unavailable: HARDWARE_ERROR
-2013;30303,ATB_PRNT_INSERTED;1;ATB - Printer (insert) unavailable: CRITICAL_SOFTWARE_ERROR
-2014;30304,ATB_PRNT_INSERTED;1;ATB - Printer (insert) unavailable: NOT_REACHABLE
-2015;30305,ATB_PRNT_INSERTED;1;ATB - Printer (insert) unavailable: NOT_RESPONDING
-2016;50000,ATB_PRNT_INSERTED;0;ATB_PRNT_INSERTED released by the application                                       
-2017;60000,ATB_PRNT_INSERTED;0;ATB_PRNT_INSERTED released by any authorized component except the application itself
-2018;70000,ATB_PRNT_INSERTED;0;ATB_PRNT_INSERTED changed state of caused by a call to acquire()                    
-2019;2020302,ATB_PRNT_INSERTED;1;ATB - Printer (insert) unavailable: HARDWARE_ERROR
-
-2020;10000,ATB_PRNT_DISPENSER;1;ATB - Printer (dispenser) available
-2021;30101,ATB_PRNT_DISPENSER;1;ATB - Printer (dispenser) unavailable: MEDIA_JAMMED
-2022;30302,ATB_PRNT_DISPENSER;1;ATB - Printer (dispenser) unavailable: HARDWARE_ERROR
-2023;30303,ATB_PRNT_DISPENSER;1;ATB - Printer (dispenser) unavailable: CRITICAL_SOFTWARE_ERROR
-2024;30304,ATB_PRNT_DISPENSER;1;ATB - Printer (dispenser) unavailable: NOT_REACHABLE
-2025;30305,ATB_PRNT_DISPENSER;1;ATB - Printer (dispenser) unavailable: NOT_RESPONDING
-2026;50000,ATB_PRNT_DISPENSER;0;ATB_PRNT_DISPENSER released by the application                                       
-2027;60000,ATB_PRNT_DISPENSER;0;ATB_PRNT_DISPENSER released by any authorized component except the application itself
-2028;70000,ATB_PRNT_DISPENSER;0;ATB_PRNT_DISPENSER changed state of caused by a call to acquire()                    
-2029;2020302,ATB_PRNT_DISPENSER;1;ATB - Printer (dispenser) unavailable: HARDWARE_ERROR
-
-//ATB_PRNT_TK           
-2030;50000,ATB_PRNT_TK;0;ATB_PRNT_TK released by the application
-2031;60000,ATB_PRNT_TK;0;ATB_PRNT_TK released by any authorized component except the application itself
-2032;70000,ATB_PRNT_TK;0;ATB_PRNT_TK changed state of caused by a call to acquire()
-2033;2020302,ATB_PRNT_TK;0;ATB_PRNT_TK unavailable: HARDWARE_ERROR
-
-//ATB_PRNT_BP
-2040;50000,ATB_PRNT_BP;0;ATB_PRNT_BP released by the application                                       
-2041;60000,ATB_PRNT_BP;0;ATB_PRNT_BP released by any authorized component except the application itself
-2042;70000,ATB_PRNT_BP;0;ATB_PRNT_BP changed state of caused by a call to acquire()                    
-2043;2020302,ATB_PRNT_BP;1;ATB_PRNT_BP unavailable: HARDWARE_ERROR
-
-//ATB_PRNT_GP
-2050;50000,ATB_PRNT_GP;0;ATB_PRNT_GP released by the application                                        
-2051;60000,ATB_PRNT_GP;0;ATB_PRNT_GP released by any authorized component except the application itself 
-2052;70000,ATB_PRNT_GP;0;ATB_PRNT_GP changed state of caused by a call to acquire()                     
-2053;2020302,ATB_PRNT_GP;0;ATB_PRNT_GP unavailable: HARDWARE_ERROR
-
-2106;10106,ATB2Bin1;1;ATB - In Service - Stock 1:MEDIA_FULL
-2107;10105,ATB2Bin1;1;ATB - In Service - Stock 1:MEDIA_HIGH
-2108;10107,ATB2Bin1;1;ATB - In Service, attention required - Stock 1:MEDIA_LOW
-2109;10108,ATB2Bin1;1;ATB - In Service, attention required - Stock 1:MEDIA_EMPTY
-2110;10106,ATB2Bin2;1;ATB - In Service - Stock 2:MEDIA_FULL
-2111;10105,ATB2Bin2;1;ATB - In Service - Stock 2:MEDIA_HIGH
-2112;10107,ATB2Bin2;1;ATB - In Service, attention required - Stock 2:MEDIA_LOW
-2113;10108,ATB2Bin2;1;ATB - In Service, attention required - Stock 2:MEDIA_EMPTY
-2114;10106,ATB2Bin3;1;ATB - In Service - Stock 3:MEDIA_FULL
-2115;10105,ATB2Bin3;1;ATB - In Service - Stock 3:MEDIA_HIGH
-2116;10107,ATB2Bin3;1;ATB - In Service, attention required - Stock 3:MEDIA_LOW
-2117;10108,ATB2Bin3;1;ATB - In Service, attention required - Stock 3:MEDIA_EMPTY
-
-//Bagtag Printer
-3000;10000,BAGTAG_PRINTER;1;BTP - Printer available
-3001;30101,BAGTAG_PRINTER;1;BTP - Printer unavailable:MEDIA_JAMMED
-3002;30108,BAGTAG_PRINTER;1;BTP - Printer unavailable:MEDIA_EMPTY
-3003;30302,BAGTAG_PRINTER;1;BTP - Printer unavailable: HARDWARE_ERROR
-3004;30303,BAGTAG_PRINTER;1;BTP - Printer unavailable: CRITICAL_SOFTWARE_ERROR
-3005;30304,BAGTAG_PRINTER;1;BTP - Printer unavailable: NOT_REACHABLE
-3006;30305,BAGTAG_PRINTER;1;BTP - Printer unavailable: NOT_RESPONDING
-3007;20000,BAGTAG_PRINTER;0;BAGTAG_PRINTER Released by any authorized component except the application itself
-3008;50000,BAGTAG_PRINTER;0;BAGTAG_PRINTER released by the application                                       
-3009;60000,BAGTAG_PRINTER;0;BAGTAG_PRINTER released by any authorized component except the application itself
-3010;70000,BAGTAG_PRINTER;0;BAGTAG_PRINTER changed state of caused by a call to acquire()                    
-3011;10201,BAGTAG_PRINTER;1;BTP - Format Error in command to BAGTAG_PRINTER
-3012;2020300,BAGTAG_PRINTER;1;BTP - unavailable
-3013;2020108,BAGTAG_PRINTER;1;BTP - Media empty
-
-3100;10106,BAGTAG_FEEDER;1;BTP - In Service - BagTags:MEDIA_FULL
-3101;10105,BAGTAG_FEEDER;1;BTP - In Service - BagTags:MEDIA_HIGH
-3102;10107,BAGTAG_FEEDER;1;BTP - In Service, attention required - BagTags:MEDIA_LOW
-3103;10108,BAGTAG_FEEDER;1;BTP - In Service, attention required - BagTags:MEDIA_EMPTY
-
-4000;50000,TOUCHSCREEN_DISPLAY;0;TOUCHSCREEN_DISPLAY released by the application                                       
-4001;60000,TOUCHSCREEN_DISPLAY;0;TOUCHSCREEN_DISPLAY released by any authorized component except the application itself
-4002;70000,TOUCHSCREEN_DISPLAY;0;TOUCHSCREEN_DISPLAY changed state of caused by a call to acquire()                    
-
-//ATB_ESCR
-5000;50000,ATB_ESCR_CAPTURE;0;ATB_ESCR_CAPTURE released by the application                                       
-5001;60000,ATB_ESCR_CAPTURE;0;ATB_ESCR_CAPTURE released by any authorized component except the application itself
-5002;70000,ATB_ESCR_CAPTURE;0;ATB_ESCR_CAPTURE changed state of caused by a call to acquire()                    
-5003;2020302,ATB_ESCR_CAPTURE;1;ATB_ESCR_CAPTURE unavailable: HARDWARE_ERROR
-
-5100;50000,ATB_ESCR_DISPENSER;0;ATB_ESCR_DISPENSER released by the application                                       
-5101;60000,ATB_ESCR_DISPENSER;0;ATB_ESCR_DISPENSER released by any authorized component except the application itself
-5102;70000,ATB_ESCR_DISPENSER;0;ATB_ESCR_DISPENSER changed state of caused by a call to acquire()                    
-5103;2020302,ATB_ESCR_DISPENSER;1;ATB_ESCR_DISPENSER unavailable: HARDWARE_ERROR
-
-//MAGCARD
-6000;50000,MAGCARD_CAPTURE;0;MAGCARD_CAPTURE released by the application                                       
-6001;60000,MAGCARD_CAPTURE;0;MAGCARD_CAPTURE released by any authorized component except the application itself
-6002;70000,MAGCARD_CAPTURE;0;MAGCARD_CAPTURE changed state of caused by a call to acquire()                    
-
-6100;50000,MAGCARD_DISPENSER;0;MAGCARD_DISPENSER released by the application                                       
-6101;60000,MAGCARD_DISPENSER;0;MAGCARD_DISPENSER released by any authorized component except the application itself
-6102;70000,MAGCARD_DISPENSER;0;MAGCARD_DISPENSER changed state of caused by a call to acquire()                    
-
-6200;50000,MAGCARD_READER;0;MAGCARD_READER released by the application                                       
-6201;60000,MAGCARD_READER;0;MAGCARD_READER released by any authorized component except the application itself
-6202;70000,MAGCARD_READER;0;MAGCARD_READER changed state of caused by a call to acquire()                    
-
-//Application related events - Common Launch Application (CLA)
-10000;1190000,MAT_CLA;1;Launch Application initialize
-10001;1040000,MAT_CLA;1;Launch Application init ready
-10002;1050801,MAT_CLA;0;Launch Application activated
-10003;1060000,MAT_CLA;0;Launch Application terminated
-10004;1130000,MAT_CLA;1;Launch Application unavailable
-10005;1120000,MAT_CLA;1;Launch Application available
-10006;1030001,MAT_CLA;1;Launch Application disabled
-10006;1010001,MAT_CLA;1;Launch Application disabled
-10007;1070000,MAT_CLA;1;Launch Application stopped
-10007;1080000,MAT_CLA;1;Launch Application stopped
-10007;1090000,MAT_CLA;1;Launch Application stopped
-10007;1100000,MAT_CLA;1;Launch Application stopped
-10007;1110000,MAT_CLA;1;Launch Application stopped
-10008;1070802,MAT_CLA;1;Launch Application stopped by SM
-10008;1080802,MAT_CLA;1;Launch Application stopped by SM
-10008;1090802,MAT_CLA;1;Launch Application stopped by SM
-10008;1100802,MAT_CLA;1;Launch Application stopped by SM
-10008;1110802,MAT_CLA;1;Launch Application stopped by SM
-10009;1060801,MAT_CLA;0;Launch Application terminated
-10011;1290000,MAT_CLA;1;Launch Application changed state from initialize to unavailable
-
-//Application related events - Service Application
-11000;1190000,MAT_SRVC_APP;1;Service Application initialize
-11001;1040000,MAT_SRVC_APP;1;Service Application init ready
-11002;1050801,MAT_SRVC_APP;1;Service Application activated
-11003;1060000,MAT_SRVC_APP;1;Service Application terminated
-11004;1130000,MAT_SRVC_APP;1;Service Application unavailable
-11005;1120000,MAT_SRVC_APP;1;Service Application available
-11006;1030001,MAT_SRVC_APP;1;Service Application disabled
-11006;1010001,MAT_SRVC_APP;1;Service Application disabled
-11007;1070000,MAT_SRVC_APP;1;Service Application stopped
-11007;1080000,MAT_SRVC_APP;1;Service Application stopped
-11007;1090000,MAT_SRVC_APP;1;Service Application stopped
-11007;1100000,MAT_SRVC_APP;1;Service Application stopped
-11007;1110000,MAT_SRVC_APP;1;Service Application stopped
-11008;1070802,MAT_SRVC_APP;1;Service Application stopped by SM
-11008;1080802,MAT_SRVC_APP;1;Service Application stopped by SM
-11008;1090802,MAT_SRVC_APP;1;Service Application stopped by SM
-11008;1100802,MAT_SRVC_APP;1;Service Application stopped by SM
-11008;1110802,MAT_SRVC_APP;1;Service Application stopped by SM
-11009;1060801,MAT_SRVC_APP;1;Service Application terminated
-11010;1290000,MAT_SRVC_APP;1;Service Application changed state from initialize to unavailable
-11011;1050804,MAT_SRVC_APP;1;Service Application change state from available to active
-
-//Application related events - DLH CKI Application
-12000;1190000,DLH_CKI;1;DLH CKI Application initialize
-12001;1040000,DLH_CKI;1;DLH CKI Application init ready
-12002;1050801,DLH_CKI;0;DLH CKI Application activated
-12003;1060000,DLH_CKI;0;DLH CKI Application terminated
-12004;1130000,DLH_CKI;1;DLH CKI Application unavailable
-12005;1120000,DLH_CKI;1;DLH CKI Application available
-12006;1030001,DLH_CKI;1;DLH CKI Application disabled
-12006;1030801,DLH_CKI;1;DLH CKI Application disabled
-12006;1010001,DLH_CKI;1;DLH CKI Application disabled
-12007;1070000,DLH_CKI;1;DLH CKI Application stopped
-12007;1080000,DLH_CKI;1;DLH CKI Application stopped
-12007;1090000,DLH_CKI;1;DLH CKI Application stopped
-12007;1100000,DLH_CKI;1;DLH CKI Application stopped
-12007;1110000,DLH_CKI;1;DLH CKI Application stopped
-12008;1070802,DLH_CKI;1;DLH CKI Application stopped by SM
-12008;1080802,DLH_CKI;1;DLH CKI Application stopped by SM
-12008;1090802,DLH_CKI;1;DLH CKI Application stopped by SM
-12008;1100802,DLH_CKI;1;DLH CKI Application stopped by SM
-12008;1110802,DLH_CKI;1;DLH CKI Application stopped by SM
-12009;1060801,DLH_CKI;0;DLH CKI Application terminated
-12010;1300000,DLH_CKI;1;DLH CKI Application changed state from available to unavailable
-12011;1290000,DLH_CKI;1;DLH CKI Application changed state from initialize to unavailable
-12012;1280802,DLH_CKI;1;DLH CKI Application change state request from unavailable to stopped requested by System Manager
-12013;1050804,DLH_CKI;0;DLH CKI Application change state from available to active requestet by DLH_CKI
-12014;1290309,DLH_CKI;1;DLH CKI changed state from initialize to unavailable - Session Timeout 
-
-//Application related events - AUA CKI Application
-14000;1190000,AUA_CKI;1;AUA CKI Application initialize
-14001;1040000,AUA_CKI;1;AUA CKI Application init ready
-14002;1050801,AUA_CKI;0;AUA CKI Application activated
-14003;1060000,AUA_CKI;0;AUA CKI Application terminated
-14004;1130000,AUA_CKI;1;AUA CKI Application unavailable
-14005;1120000,AUA_CKI;1;AUA CKI Application available
-14006;1030001,AUA_CKI;1;AUA CKI Application disabled
-14006;1030801,AUA_CKI;1;AUA CKI Application disabled
-14006;1010001,AUA_CKI;1;AUA CKI Application disabled
-14007;1070000,AUA_CKI;1;AUA CKI Application stopped
-14007;1080000,AUA_CKI;1;AUA CKI Application stopped
-14007;1090000,AUA_CKI;1;AUA CKI Application stopped
-14007;1100000,AUA_CKI;1;AUA CKI Application stopped
-14007;1110000,AUA_CKI;1;AUA CKI Application stopped
-14008;1070802,AUA_CKI;1;AUA CKI Application stopped by SM
-14008;1080802,AUA_CKI;1;AUA CKI CheckIn Application stopped by SM
-14008;1090802,AUA_CKI;1;AUA CKI CheckIn Application stopped by SM
-14008;1100802,AUA_CKI;1;AUA CKI CheckIn Application stopped by SM
-14008;1110802,AUA_CKI;1;AUA CKI CheckIn Application stopped by SM
-14009;1060801,AUA_CKI;0;AUA CKI CheckIn Application terminated
-14010;1300000,AUA_CKI;1;AUA CKI changed state from available to unavailable
-14011;1290000,AUA_CKI;1;AUA CKI changed state from initialize to unavailable
-14012;1280802,AUA_CKI;1;AUA CKI change state request from unavailable to stopped requested by System Manager
-14013;1050804,AUA_CKI;0;AUA CKI change state from available to active requestet by AUA_CKI
-14014;1290309,AUA_CKI;1;AUA CKI changed state from initialize to unavailable - Session Timeout 
-
-//Application related events - AUA CKI Application
-16000;1190000,KLM_CKC;1;KLM CKI Application initialize
-16001;1040000,KLM_CKC;1;KLM CKI Application init ready
-16002;1050801,KLM_CKC;0;KLM CKI Application activated
-16003;1060000,KLM_CKC;0;KLM CKI Application terminated
-16004;1130000,KLM_CKC;1;KLM CKI Application unavailable
-16005;1120000,KLM_CKC;1;KLM CKI Application available
-16006;1030001,KLM_CKC;1;KLM CKI Application disabled
-16006;1030801,KLM_CKC;1;KLM CKI Application disabled
-16006;1010001,KLM_CKC;1;KLM CKI Application disabled
-16007;1070000,KLM_CKC;1;KLM CKI Application stopped
-16007;1080000,KLM_CKC;1;KLM CKI Application stopped
-16007;1090000,KLM_CKC;1;KLM CKI Application stopped
-16007;1100000,KLM_CKC;1;KLM CKI Application stopped
-16007;1110000,KLM_CKC;1;KLM CKI Application stopped
-16008;1070802,KLM_CKC;1;KLM CKI Application stopped by SM
-16008;1080802,KLM_CKC;1;KLM CKI CheckIn Application stopped by SM
-16008;1090802,KLM_CKC;1;KLM CKI CheckIn Application stopped by SM
-16008;1100802,KLM_CKC;1;KLM CKI CheckIn Application stopped by SM
-16008;1110802,KLM_CKC;1;KLM CKI CheckIn Application stopped by SM
-16009;1060801,KLM_CKC;0;KLM CKI CheckIn Application terminated
-16010;1300000,KLM_CKC;1;KLM CKI changed state from available to unavailable
-16011;1290000,KLM_CKC;1;KLM CKI changed state from initialize to unavailable
-16012;1280802,KLM_CKC;1;KLM CKI change state request from unavailable to stopped requested by System Manager
-16013;1050804,KLM_CKC;0;KLM CKI change state from available to active requestet by KLM_CKC
-16014;1290309,KLM_CKC;1;KLM CKI changed state from initialize to unavailable - Session Timeout 
-
-20000;10000,_;0; _ Eventhandling OK
-20001;10105,_;0; _ Eventhandling MEDIA_HIGH
-20002;10106,_;0; _ Eventhandling MEDIA_FULL
-20003;10107,_;0; _ Eventhandling MEDIA_LOW
-20004;30304,_;0; _ Eventhandling unavailable error: not reachable
-
-//CONVEYOR
-9000;10000,CONVEYOR;1;Conveyor available
-9001;10004,CONVEYOR;1;Conveyor Error
-9002;30101,CONVEYOR;1;Conveyor unavailable: MEDIA_JAMMED
-9003;30302,CONVEYOR;1;Conveyor unavailable: HARDWARE_ERROR
-9004;30303,CONVEYOR;1;Conveyor unavailable: CRITICAL_SOFTWARE_ERROR
-9005;30304,CONVEYOR;1;Conveyor unavailable: NOT_REACHABLE
-9006;30305,CONVEYOR;1;Conveyor unavailable: NOT_RESPONDING
-9007;50000,CONVEYOR;0;CONVEYOR released by the application                                       
-9008;60000,CONVEYOR;0;CONVEYOR released by any authorized component except the application itself
-9009;70000,CONVEYOR;0;CONVEYOR changed state of caused by a call to acquire()                    
-9010;2100002,CONVEYOR;1;Conveyor is busy
-9011;30002,CONVEYOR;1;Conveyor unavailable: WRONG_STATE
-
-//CONVEYOR_DRIVER
-//100000;massai.notification.drivers.ConveyorDev.17;1;Conveyor ALERT_CODE_PIECE_TOO_EARLY
-100001;massai.notification.drivers.ConveyorDev.18;1;Conveyor ALERT_CODE_PIECE_UNEXPECTED
-100002;massai.notification.drivers.ConveyorDev.19;1;Conveyor ALERT_CODE_PIECE_LOST
-100003;massai.notification.drivers.ConveyorDev.20;1;Conveyor ALERT_CODE_TOO_MANY_PIECES
-100004;massai.notification.drivers.ConveyorDev.21;1;Conveyor ALERT_CODE_PIECE_TOO_HIGH
-100005;massai.notification.drivers.ConveyorDev.22;1;Conveyor ALERT_CODE_PIECE_TOO_LONG
-100006;massai.notification.drivers.ConveyorDev.23;1;Conveyor ALERT_CODE_PIECE_WEIGHT_CHANGED
-100007;massai.notification.drivers.ConveyorDev.24;1;Conveyor ALERT_CODE_PIECE_NOT_RETURNED
-100013;massai.notification.drivers.ConveyorDev.13;1;Conveyor ALERT_CODE_PIECE_UNEXPECTED_ON_BELT_3
-100014;massai.notification.drivers.ConveyorDev.33;1;Conveyor ALERT_CODE_PIECE_BLOCKED_ON_BELT_3
-100015;massai.notification.drivers.ConveyorDev.0;1;Conveyor OK
-100025;massai.notification.drivers.ConveyorDev.25;1;Conveyor ALERT_CODE_PIECE_NOT_FORWARDED
-
-100100;massai.notification.drivers.ConveyorDev.Scanner.0;1;Scanner available
-//100101;massai.notification.drivers.ConveyorDev.Scanner.1;1;Scanner busy
-100102;massai.notification.drivers.ConveyorDev.Scanner.2;1;Scanner hardware error
-//100103;massai.notification.drivers.ConveyorDev.Scanner.3;1;Scanner disconnected
-
-100200;massai.notification.drivers.ConveyorDev.SPS.0;1;SPS devices available
-100201;massai.notification.drivers.ConveyorDev.SPS.2;1;SPS failure
-100202;massai.notification.drivers.ConveyorDev.SPS.4;1;Belts 1-3 failure
-100203;massai.notification.drivers.ConveyorDev.SPS.8;1;Main belt failure
-
-100300;massai.notification.drivers.ConveyorDev.Scale.0;1;Scale available
-//100301;massai.notification.drivers.ConveyorDev.Scale.1;1;Scale busy
-100302;massai.notification.drivers.ConveyorDev.Scale.2;1;Scale hardware error
-//100303;massai.notification.drivers.ConveyorDev.Scale.3;1;Scale disconnected 
-
-//ATB_DRIVER
-100400;massai.notification.drivers.Atb2Dev1.Escrow.0;1;Escrow available
-100401;massai.notification.drivers.Atb2Dev1.Escrow.3;1;Escrow hardware error
-100402;massai.notification.drivers.Atb2Dev1.Escrow.7;1;Escrow not conf.
-100403;massai.notification.drivers.Atb2Dev1.Escrow.2;1;Escrow disconnected
-100404;massai.notification.drivers.Atb2Dev1.Escrow.10;1;Escrow door not locked
-
-100420;massai.notification.drivers.Atb2Dev1.Escrow.22;1;Escrow disconnected in idle state
-100421;massai.notification.drivers.Atb2Dev1.Escrow.23;1;Escrow hardware error in idle state
-100422;massai.notification.drivers.Atb2Dev1.Escrow.30;1;Escrow door not locked in idle state
-
-100500;massai.notification.drivers.Atb2Dev1.ATB.0;1;ATB available
-100501;massai.notification.drivers.Atb2Dev1.ATB.3;1;ATB hardware error
-100502;massai.notification.drivers.Atb2Dev1.ATB.2;1;ATB disconected
-100503;massai.notification.drivers.Atb2Dev1.ATB.4;1;ATB paper jam
-100504;massai.notification.drivers.Atb2Dev1.ATB.5;1;ATB ribbon out
-100505;massai.notification.drivers.Atb2Dev1.ATB.6;1;ATB offline
-100506;massai.notification.drivers.Atb2Dev1.ATB.7;1;ATB not conf.
-
-100507;massai.notification.drivers.Atb2Dev1.Stock1.0;1;ATB Stock1 available
-100508;massai.notification.drivers.Atb2Dev1.Stock1.1;1;ATB Stock1 is empty
-100509;massai.notification.drivers.Atb2Dev1.Stock2.0;1;ATB Stock2 available
-100510;massai.notification.drivers.Atb2Dev1.Stock2.1;1;ATB Stock2 is empty
-100511;massai.notification.drivers.Atb2Dev1.Stock3.0;1;ATB Stock3 available
-100512;massai.notification.drivers.Atb2Dev1.Stock3.1;1;ATB Stock3 is empty
-100522;massai.notification.drivers.Atb2Dev1.122;1;ATB Document voided
-
-100531;massai.notification.drivers.Atb2Dev1.ATB.31;1;Printhead not locked.
-
-//ATB_DRIVER / multicontext configuration
-100400;massai.notification.drivers.Atb2Dev.Escrow.0;1;Escrow available
-100401;massai.notification.drivers.Atb2Dev.Escrow.3;1;Escrow hardware error
-100402;massai.notification.drivers.Atb2Dev.Escrow.7;1;Escrow not conf.
-100403;massai.notification.drivers.Atb2Dev.Escrow.2;1;Escrow disconnected
-100404;massai.notification.drivers.Atb2Dev.Escrow.10;1;Escrow door not locked
-
-100420;massai.notification.drivers.Atb2Dev.Escrow.22;1;Escrow disconnected in idle state
-100421;massai.notification.drivers.Atb2Dev.Escrow.23;1;Escrow hardware error in idle state
-100422;massai.notification.drivers.Atb2Dev.Escrow.30;1;Escrow door not locked in idle state
-
-100500;massai.notification.drivers.Atb2Dev.ATB.0;1;ATB available
-100501;massai.notification.drivers.Atb2Dev.ATB.3;1;ATB hardware error
-100502;massai.notification.drivers.Atb2Dev.ATB.2;1;ATB disconected
-100503;massai.notification.drivers.Atb2Dev.ATB.4;1;ATB paper jam
-100504;massai.notification.drivers.Atb2Dev.ATB.5;1;ATB ribbon out
-100505;massai.notification.drivers.Atb2Dev.ATB.6;1;ATB offline
-100506;massai.notification.drivers.Atb2Dev.ATB.7;1;ATB not conf.
-
-100507;massai.notification.drivers.Atb2Dev.Stock1.0;1;ATB Stock1 available
-100508;massai.notification.drivers.Atb2Dev.Stock1.1;1;ATB Stock1 is empty
-100509;massai.notification.drivers.Atb2Dev.Stock2.0;1;ATB Stock2 available
-100510;massai.notification.drivers.Atb2Dev.Stock2.1;1;ATB Stock2 is empty
-100511;massai.notification.drivers.Atb2Dev.Stock3.0;1;ATB Stock3 available
-100512;massai.notification.drivers.Atb2Dev.Stock3.1;1;ATB Stock3 is empty
-100522;massai.notification.drivers.Atb2Dev.122;1;ATB Document voided
-
-100531;massai.notification.drivers.Atb2Dev.ATB.31;1;Printhead not locked.
-100544;massai.notification.drivers.Atb2Dev.ATB.44;1;ATB recoverable paper jam
-
-//BTP_DRIVER
-100600;massai.notification.drivers.BagTagDev1.ATB.0;1;BTP available
-100601;massai.notification.drivers.BagTagDev1.ATB.3;1;BTP hardware error
-100602;massai.notification.drivers.BagTagDev1.ATB.2;1;BTP disconected
-100603;massai.notification.drivers.BagTagDev1.ATB.4;1;BTP paper jam
-100604;massai.notification.drivers.BagTagDev1.ATB.5;1;BTP ribbon out
-100605;massai.notification.drivers.BagTagDev1.ATB.6;1;BTP offline
-100606;massai.notification.drivers.BagTagDev1.ATB.7;1;BTP not conf.
-
-100607;massai.notification.drivers.BagTagDev1.Stock1.0;1;BTP Stock1 available
-100608;massai.notification.drivers.BagTagDev1.Stock1.1;1;BTP Stock1 is empty
-
-100701;massai.notification.drivers.Sel.1;1;Special Electronic ALERT_CODE_DOOR_OPENED
-100702;massai.notification.drivers.Sel.2;1;Special Electronic ALERT_CODE_DOOR_CLOSED
-100703;massai.notification.drivers.Sel.Bin1.3;1;Special Electronic ALERT_CODE_PAPER_LOW_BIN1
-100704;massai.notification.drivers.Sel.Bin1.4;1;Special Electronic ALERT_CODE_PAPER_OK_BIN
-100705;massai.notification.drivers.Sel.Bin2.5;1;Special Electronic ALERT_CODE_PAPER_LOW_BIN2
-100706;massai.notification.drivers.Sel.Bin2.6;1;Special Electronic ALERT_CODE_PAPER_OK_BIN2
-100707;massai.notification.drivers.Sel.Bin3.7;1;Special Electronic ALERT_CODE_PAPER_LOW_BIN3
-100708;massai.notification.drivers.Sel.Bin3.8;1;Special Electronic ALERT_CODE_PAPER_OK_BIN3
-100709;massai.notification.drivers.Sel.BagTag.9;1;Special Electronic ALERT_CODE_BAGTAG_LOW
-100710;massai.notification.drivers.Sel.BagTag.10;1;Special Electronic ALERT_CODE_BAGTAG_OK
-100711;massai.notification.drivers.Sel.16;1;Special Electronic ALERT_CODE_POWER_OFF
-100712;massai.notification.drivers.Sel.17;1;Special Electronic ALERT_CODE_ATB_POWER_OFF
-100713;massai.notification.drivers.Sel.18;1;Special Electronic ALERT_CODE_ATB_POWER_ON
-100714;massai.notification.drivers.Sel.19;1;Special Electronic ALERT_CODE_BTP_POWER_OFF
-100715;massai.notification.drivers.Sel.20;1;Special Electronic ALERT_CODE_BTP_POWER_ON
-100716;massai.notification.drivers.Sel.21;1;Special Electronic ALERT_CODE_CRD_POWER_OFF
-100717;massai.notification.drivers.Sel.22;1;Special Electronic ALERT_CODE_CRD_POWER_ON
-100718;massai.notification.drivers.Sel.32;1;Special Electronic ALERT_CODE_SEL_AVAILABLE
-100719;massai.notification.drivers.Sel.33;1;Special Electronic ALERT_CODE_SEL_UNAVAILABLE
-
-
-
-- 
2.41.0.windows.1

